(ns portkey.aws.lightsail.-2016-11-28 (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope {:service "lightsail", :region "ap-northeast-1"},
    :ssl-common-name "lightsail.ap-northeast-1.amazonaws.com",
    :endpoint "https://lightsail.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "lightsail", :region "eu-west-1"},
    :ssl-common-name "lightsail.eu-west-1.amazonaws.com",
    :endpoint "https://lightsail.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "lightsail", :region "us-east-2"},
    :ssl-common-name "lightsail.us-east-2.amazonaws.com",
    :endpoint "https://lightsail.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "lightsail", :region "ap-southeast-2"},
    :ssl-common-name "lightsail.ap-southeast-2.amazonaws.com",
    :endpoint "https://lightsail.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "lightsail", :region "ap-southeast-1"},
    :ssl-common-name "lightsail.ap-southeast-1.amazonaws.com",
    :endpoint "https://lightsail.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "lightsail", :region "ap-northeast-2"},
    :ssl-common-name "lightsail.ap-northeast-2.amazonaws.com",
    :endpoint "https://lightsail.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "lightsail", :region "eu-west-3"},
    :ssl-common-name "lightsail.eu-west-3.amazonaws.com",
    :endpoint "https://lightsail.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "lightsail", :region "ca-central-1"},
    :ssl-common-name "lightsail.ca-central-1.amazonaws.com",
    :endpoint "https://lightsail.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "lightsail", :region "eu-central-1"},
    :ssl-common-name "lightsail.eu-central-1.amazonaws.com",
    :endpoint "https://lightsail.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "lightsail", :region "eu-west-2"},
    :ssl-common-name "lightsail.eu-west-2.amazonaws.com",
    :endpoint "https://lightsail.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "lightsail", :region "us-west-2"},
    :ssl-common-name "lightsail.us-west-2.amazonaws.com",
    :endpoint "https://lightsail.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "lightsail", :region "us-east-1"},
    :ssl-common-name "lightsail.us-east-1.amazonaws.com",
    :endpoint "https://lightsail.us-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "lightsail", :region "ap-south-1"},
    :ssl-common-name "lightsail.ap-south-1.amazonaws.com",
    :endpoint "https://lightsail.ap-south-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-port-info-source-type)

(clojure.core/declare serboolean)

(clojure.core/declare ser-string-list)

(clojure.core/declare ser-metric-statistic-list)

(clojure.core/declare ser-string-max-256)

(clojure.core/declare ser-disk-map-list)

(clojure.core/declare ser-port-info)

(clojure.core/declare ser-non-empty-string)

(clojure.core/declare serstring)

(clojure.core/declare ser-instance-entry-list)

(clojure.core/declare ser-load-balancer-metric-name)

(clojure.core/declare ser-tag-key)

(clojure.core/declare ser-base-64)

(clojure.core/declare sertimestamp)

(clojure.core/declare ser-domain-entry)

(clojure.core/declare ser-metric-unit)

(clojure.core/declare ser-metric-period)

(clojure.core/declare ser-relational-database-password-version)

(clojure.core/declare ser-relational-database-parameter-list)

(clojure.core/declare ser-sensitive-string)

(clojure.core/declare ser-disk-map)

(clojure.core/declare ser-region-name)

(clojure.core/declare ser-domain-name-list)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-relational-database-metric-name)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-relational-database-parameter)

(clojure.core/declare ser-tag-value)

(clojure.core/declare ser-port)

(clojure.core/declare ser-iso-date)

(clojure.core/declare ser-resource-name-list)

(clojure.core/declare ser-resource-name)

(clojure.core/declare ser-domain-entry-options-keys)

(clojure.core/declare serinteger)

(clojure.core/declare ser-instance-metric-name)

(clojure.core/declare ser-metric-statistic)

(clojure.core/declare ser-instance-entry)

(clojure.core/declare ser-network-protocol)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-attached-disk-map)

(clojure.core/declare ser-domain-entry-type)

(clojure.core/declare ser-domain-name)

(clojure.core/declare ser-load-balancer-attribute-name)

(clojure.core/declare ser-instance-access-protocol)

(clojure.core/declare ser-port-info-list)

(clojure.core/declare ser-domain-entry-options)

(clojure.core/defn- ser-port-info-source-type [input] #:http.request.field{:value (clojure.core/get {"DEFAULT" "DEFAULT", :default "DEFAULT", "INSTANCE" "INSTANCE", :instance "INSTANCE", "NONE" "NONE", :none "NONE", "CLOSED" "CLOSED", :closed "CLOSED"} input), :shape "PortInfoSourceType"})

(clojure.core/defn- serboolean [input] #:http.request.field{:value input, :shape "boolean"})

(clojure.core/defn- ser-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (serstring coll) #:http.request.field{:shape "string"}))) input), :shape "StringList", :type "list"})

(clojure.core/defn- ser-metric-statistic-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-metric-statistic coll) #:http.request.field{:shape "MetricStatistic"}))) input), :shape "MetricStatisticList", :type "list"})

(clojure.core/defn- ser-string-max-256 [input] #:http.request.field{:value input, :shape "StringMax256"})

(clojure.core/defn- ser-disk-map-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-disk-map coll) #:http.request.field{:shape "DiskMap"}))) input), :shape "DiskMapList", :type "list"})

(clojure.core/defn- ser-port-info [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PortInfo", :type "structure"} (clojure.core/contains? input :from-port) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-port (input :from-port)) #:http.request.field{:name "fromPort", :shape "Port"})) (clojure.core/contains? input :to-port) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-port (input :to-port)) #:http.request.field{:name "toPort", :shape "Port"})) (clojure.core/contains? input :protocol) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-network-protocol (input :protocol)) #:http.request.field{:name "protocol", :shape "NetworkProtocol"}))))

(clojure.core/defn- ser-non-empty-string [input] #:http.request.field{:value input, :shape "NonEmptyString"})

(clojure.core/defn- serstring [input] #:http.request.field{:value input, :shape "string"})

(clojure.core/defn- ser-instance-entry-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-entry coll) #:http.request.field{:shape "InstanceEntry"}))) input), :shape "InstanceEntryList", :type "list"})

(clojure.core/defn- ser-load-balancer-metric-name [input] #:http.request.field{:value (clojure.core/get {:http-code-instance-4-xx-count "HTTPCode_Instance_4XX_Count", "InstanceResponseTime" "InstanceResponseTime", "RejectedConnectionCount" "RejectedConnectionCount", "HTTPCode_LB_5XX_Count" "HTTPCode_LB_5XX_Count", :healthy-host-count "HealthyHostCount", :instance-response-time "InstanceResponseTime", :http-code-lb-4-xx-count "HTTPCode_LB_4XX_Count", :http-code-lb-5-xx-count "HTTPCode_LB_5XX_Count", "RequestCount" "RequestCount", :http-code-instance-3-xx-count "HTTPCode_Instance_3XX_Count", :http-code-instance-5-xx-count "HTTPCode_Instance_5XX_Count", "ClientTLSNegotiationErrorCount" "ClientTLSNegotiationErrorCount", :client-tls-negotiation-error-count "ClientTLSNegotiationErrorCount", :http-code-instance-2-xx-count "HTTPCode_Instance_2XX_Count", :unhealthy-host-count "UnhealthyHostCount", "HTTPCode_Instance_5XX_Count" "HTTPCode_Instance_5XX_Count", "HTTPCode_LB_4XX_Count" "HTTPCode_LB_4XX_Count", "HTTPCode_Instance_2XX_Count" "HTTPCode_Instance_2XX_Count", :rejected-connection-count "RejectedConnectionCount", "HealthyHostCount" "HealthyHostCount", "UnhealthyHostCount" "UnhealthyHostCount", :request-count "RequestCount", "HTTPCode_Instance_3XX_Count" "HTTPCode_Instance_3XX_Count", "HTTPCode_Instance_4XX_Count" "HTTPCode_Instance_4XX_Count"} input), :shape "LoadBalancerMetricName"})

(clojure.core/defn- ser-tag-key [input] #:http.request.field{:value input, :shape "TagKey"})

(clojure.core/defn- ser-base-64 [input] #:http.request.field{:value input, :shape "Base64"})

(clojure.core/defn- sertimestamp [input] #:http.request.field{:value input, :shape "timestamp"})

(clojure.core/defn- ser-domain-entry [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DomainEntry", :type "structure"} (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-non-empty-string (input :id)) #:http.request.field{:name "id", :shape "NonEmptyString"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-name (input :name)) #:http.request.field{:name "name", :shape "DomainName"})) (clojure.core/contains? input :target) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :target)) #:http.request.field{:name "target", :shape "string"})) (clojure.core/contains? input :is-alias) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :is-alias)) #:http.request.field{:name "isAlias", :shape "boolean"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-entry-type (input :type)) #:http.request.field{:name "type", :shape "DomainEntryType"})) (clojure.core/contains? input :options) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-entry-options (input :options)) #:http.request.field{:name "options", :shape "DomainEntryOptions", :deprecated true}))))

(clojure.core/defn- ser-metric-unit [input] #:http.request.field{:value (clojure.core/get {:kilobytes-second "Kilobytes/Second", :megabits "Megabits", "Terabytes" "Terabytes", :bits-second "Bits/Second", :count-second "Count/Second", :kilobits "Kilobits", "Kilobits/Second" "Kilobits/Second", "Count" "Count", :megabytes-second "Megabytes/Second", "Bits" "Bits", "Percent" "Percent", "Gigabits/Second" "Gigabits/Second", :terabytes "Terabytes", :terabits-second "Terabits/Second", "None" "None", :seconds "Seconds", :bits "Bits", :terabits "Terabits", :bytes-second "Bytes/Second", :kilobytes "Kilobytes", :microseconds "Microseconds", "Count/Second" "Count/Second", "Bytes" "Bytes", "Gigabytes/Second" "Gigabytes/Second", :megabits-second "Megabits/Second", "Megabits/Second" "Megabits/Second", :gigabits "Gigabits", "Kilobytes/Second" "Kilobytes/Second", :gigabits-second "Gigabits/Second", :kilobits-second "Kilobits/Second", :megabytes "Megabytes", "Terabytes/Second" "Terabytes/Second", "Bits/Second" "Bits/Second", "Bytes/Second" "Bytes/Second", "Milliseconds" "Milliseconds", :count "Count", :gigabytes-second "Gigabytes/Second", "Kilobytes" "Kilobytes", :bytes "Bytes", :milliseconds "Milliseconds", "Microseconds" "Microseconds", :percent "Percent", "Terabits" "Terabits", :gigabytes "Gigabytes", "Megabytes/Second" "Megabytes/Second", :terabytes-second "Terabytes/Second", "Gigabytes" "Gigabytes", "Gigabits" "Gigabits", "Megabits" "Megabits", :none "None", "Kilobits" "Kilobits", "Terabits/Second" "Terabits/Second", "Megabytes" "Megabytes", "Seconds" "Seconds"} input), :shape "MetricUnit"})

(clojure.core/defn- ser-metric-period [input] #:http.request.field{:value input, :shape "MetricPeriod"})

(clojure.core/defn- ser-relational-database-password-version [input] #:http.request.field{:value (clojure.core/get {"CURRENT" "CURRENT", :current "CURRENT", "PREVIOUS" "PREVIOUS", :previous "PREVIOUS", "PENDING" "PENDING", :pending "PENDING"} input), :shape "RelationalDatabasePasswordVersion"})

(clojure.core/defn- ser-relational-database-parameter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-relational-database-parameter coll) #:http.request.field{:shape "RelationalDatabaseParameter"}))) input), :shape "RelationalDatabaseParameterList", :type "list"})

(clojure.core/defn- ser-sensitive-string [input] #:http.request.field{:value input, :shape "SensitiveString"})

(clojure.core/defn- ser-disk-map [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DiskMap", :type "structure"} (clojure.core/contains? input :original-disk-path) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-non-empty-string (input :original-disk-path)) #:http.request.field{:name "originalDiskPath", :shape "NonEmptyString"})) (clojure.core/contains? input :new-disk-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :new-disk-name)) #:http.request.field{:name "newDiskName", :shape "ResourceName"}))))

(clojure.core/defn- ser-region-name [input] #:http.request.field{:value (clojure.core/get {:apnortheast-1 "ap-northeast-1", :apsouth-1 "ap-south-1", "ap-northeast-1" "ap-northeast-1", "eu-west-1" "eu-west-1", :euwest-3 "eu-west-3", :useast-1 "us-east-1", :apsoutheast-2 "ap-southeast-2", :apnortheast-2 "ap-northeast-2", "us-east-2" "us-east-2", "ap-southeast-2" "ap-southeast-2", "ap-southeast-1" "ap-southeast-1", "ap-northeast-2" "ap-northeast-2", "eu-west-3" "eu-west-3", :cacentral-1 "ca-central-1", "ca-central-1" "ca-central-1", "eu-central-1" "eu-central-1", :euwest-2 "eu-west-2", "eu-west-2" "eu-west-2", :uswest-1 "us-west-1", :eucentral-1 "eu-central-1", :apsoutheast-1 "ap-southeast-1", "us-west-2" "us-west-2", "us-east-1" "us-east-1", "us-west-1" "us-west-1", "ap-south-1" "ap-south-1", :euwest-1 "eu-west-1", :useast-2 "us-east-2", :uswest-2 "us-west-2"} input), :shape "RegionName"})

(clojure.core/defn- ser-domain-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-domain-name coll) #:http.request.field{:shape "DomainName"}))) input), :shape "DomainNameList", :type "list"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-relational-database-metric-name [input] #:http.request.field{:value (clojure.core/get {:free-storage-space "FreeStorageSpace", :network-receive-throughput "NetworkReceiveThroughput", :network-transmit-throughput "NetworkTransmitThroughput", "NetworkTransmitThroughput" "NetworkTransmitThroughput", "NetworkReceiveThroughput" "NetworkReceiveThroughput", :cpu-utilization "CPUUtilization", "DatabaseConnections" "DatabaseConnections", "DiskQueueDepth" "DiskQueueDepth", "CPUUtilization" "CPUUtilization", "FreeStorageSpace" "FreeStorageSpace", :disk-queue-depth "DiskQueueDepth", :database-connections "DatabaseConnections"} input), :shape "RelationalDatabaseMetricName"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag-key coll) #:http.request.field{:shape "TagKey"}))) input), :shape "TagKeyList", :type "list"})

(clojure.core/defn- ser-relational-database-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RelationalDatabaseParameter", :type "structure"} (clojure.core/contains? input :allowed-values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :allowed-values)) #:http.request.field{:name "allowedValues", :shape "string"})) (clojure.core/contains? input :apply-method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :apply-method)) #:http.request.field{:name "applyMethod", :shape "string"})) (clojure.core/contains? input :apply-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :apply-type)) #:http.request.field{:name "applyType", :shape "string"})) (clojure.core/contains? input :data-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :data-type)) #:http.request.field{:name "dataType", :shape "string"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :description)) #:http.request.field{:name "description", :shape "string"})) (clojure.core/contains? input :is-modifiable) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :is-modifiable)) #:http.request.field{:name "isModifiable", :shape "boolean"})) (clojure.core/contains? input :parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :parameter-name)) #:http.request.field{:name "parameterName", :shape "string"})) (clojure.core/contains? input :parameter-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :parameter-value)) #:http.request.field{:name "parameterValue", :shape "string"}))))

(clojure.core/defn- ser-tag-value [input] #:http.request.field{:value input, :shape "TagValue"})

(clojure.core/defn- ser-port [input] #:http.request.field{:value input, :shape "Port"})

(clojure.core/defn- ser-iso-date [input] #:http.request.field{:value input, :shape "IsoDate"})

(clojure.core/defn- ser-resource-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-resource-name coll) #:http.request.field{:shape "ResourceName"}))) input), :shape "ResourceNameList", :type "list"})

(clojure.core/defn- ser-resource-name [input] #:http.request.field{:value input, :shape "ResourceName"})

(clojure.core/defn- ser-domain-entry-options-keys [input] #:http.request.field{:value input, :shape "DomainEntryOptionsKeys"})

(clojure.core/defn- serinteger [input] #:http.request.field{:value input, :shape "integer"})

(clojure.core/defn- ser-instance-metric-name [input] #:http.request.field{:value (clojure.core/get {:status-check-failed-system "StatusCheckFailed_System", "StatusCheckFailed" "StatusCheckFailed", "StatusCheckFailed_System" "StatusCheckFailed_System", :cpu-utilization "CPUUtilization", "NetworkOut" "NetworkOut", :network-out "NetworkOut", :network-in "NetworkIn", :status-check-failed-instance "StatusCheckFailed_Instance", "StatusCheckFailed_Instance" "StatusCheckFailed_Instance", "CPUUtilization" "CPUUtilization", "NetworkIn" "NetworkIn", :status-check-failed "StatusCheckFailed"} input), :shape "InstanceMetricName"})

(clojure.core/defn- ser-metric-statistic [input] #:http.request.field{:value (clojure.core/get {"Sum" "Sum", "Average" "Average", :maximum "Maximum", "SampleCount" "SampleCount", "Minimum" "Minimum", :sample-count "SampleCount", :minimum "Minimum", :average "Average", :sum "Sum", "Maximum" "Maximum"} input), :shape "MetricStatistic"})

(clojure.core/defn- ser-instance-entry [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-resource-name (:source-name input)) #:http.request.field{:name "sourceName", :shape "ResourceName"}) (clojure.core/into (ser-non-empty-string (:instance-type input)) #:http.request.field{:name "instanceType", :shape "NonEmptyString"}) (clojure.core/into (ser-port-info-source-type (:port-info-source input)) #:http.request.field{:name "portInfoSource", :shape "PortInfoSourceType"}) (clojure.core/into (serstring (:availability-zone input)) #:http.request.field{:name "availabilityZone", :shape "string"})], :shape "InstanceEntry", :type "structure"} (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :user-data)) #:http.request.field{:name "userData", :shape "string"}))))

(clojure.core/defn- ser-network-protocol [input] #:http.request.field{:value (clojure.core/get {"tcp" "tcp", :tcp "tcp", "all" "all", :all "all", "udp" "udp", :udp "udp"} input), :shape "NetworkProtocol"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key (input :key)) #:http.request.field{:name "key", :shape "TagKey"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value (input :value)) #:http.request.field{:name "value", :shape "TagValue"}))))

(clojure.core/defn- ser-attached-disk-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-resource-name k) #:http.request.field{:map-info "key", :shape "ResourceName"}) (clojure.core/into (ser-disk-map-list v) #:http.request.field{:map-info "value", :shape "DiskMapList"})])) input), :shape "AttachedDiskMap", :type "map"})

(clojure.core/defn- ser-domain-entry-type [input] #:http.request.field{:value input, :shape "DomainEntryType"})

(clojure.core/defn- ser-domain-name [input] #:http.request.field{:value input, :shape "DomainName"})

(clojure.core/defn- ser-load-balancer-attribute-name [input] #:http.request.field{:value (clojure.core/get {"HealthCheckPath" "HealthCheckPath", :health-check-path "HealthCheckPath", "SessionStickinessEnabled" "SessionStickinessEnabled", :session-stickiness-enabled "SessionStickinessEnabled", "SessionStickiness_LB_CookieDurationSeconds" "SessionStickiness_LB_CookieDurationSeconds", :session-stickiness-lb-cookie-duration-seconds "SessionStickiness_LB_CookieDurationSeconds"} input), :shape "LoadBalancerAttributeName"})

(clojure.core/defn- ser-instance-access-protocol [input] #:http.request.field{:value (clojure.core/get {"ssh" "ssh", :ssh "ssh", "rdp" "rdp", :rdp "rdp"} input), :shape "InstanceAccessProtocol"})

(clojure.core/defn- ser-port-info-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-port-info coll) #:http.request.field{:shape "PortInfo"}))) input), :shape "PortInfoList", :type "list"})

(clojure.core/defn- ser-domain-entry-options [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-domain-entry-options-keys k) #:http.request.field{:map-info "key", :shape "DomainEntryOptionsKeys"}) (clojure.core/into (serstring v) #:http.request.field{:map-info "value", :shape "string"})])) input), :shape "DomainEntryOptions", :type "map"})

(clojure.core/defn- req-create-instances-from-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string-list (input :instance-names)) #:http.request.field{:name "instanceNames", :shape "StringList"}) (clojure.core/into (serstring (input :availability-zone)) #:http.request.field{:name "availabilityZone", :shape "string"}) (clojure.core/into (ser-resource-name (input :instance-snapshot-name)) #:http.request.field{:name "instanceSnapshotName", :shape "ResourceName"}) (clojure.core/into (ser-non-empty-string (input :bundle-id)) #:http.request.field{:name "bundleId", :shape "NonEmptyString"})]} (clojure.core/contains? input :attached-disk-mapping) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attached-disk-map (input :attached-disk-mapping)) #:http.request.field{:name "attachedDiskMapping", :shape "AttachedDiskMap"})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :user-data)) #:http.request.field{:name "userData", :shape "string"})) (clojure.core/contains? input :key-pair-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :key-pair-name)) #:http.request.field{:name "keyPairName", :shape "ResourceName"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-create-relational-database-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :relational-database-snapshot-name)) #:http.request.field{:name "relationalDatabaseSnapshotName", :shape "ResourceName"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-attach-load-balancer-tls-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "ResourceName"})]}))

(clojure.core/defn- req-detach-disk-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-relational-database-blueprints-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-get-disk-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-snapshot-name)) #:http.request.field{:name "diskSnapshotName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-domain-entry-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-domain-name (input :domain-name)) #:http.request.field{:name "domainName", :shape "DomainName"}) (clojure.core/into (ser-domain-entry (input :domain-entry)) #:http.request.field{:name "domainEntry", :shape "DomainEntry"})]}))

(clojure.core/defn- req-get-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :key-pair-name)) #:http.request.field{:name "keyPairName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-instances-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-update-load-balancer-attribute-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-load-balancer-attribute-name (input :attribute-name)) #:http.request.field{:name "attributeName", :shape "LoadBalancerAttributeName"}) (clojure.core/into (ser-string-max-256 (input :attribute-value)) #:http.request.field{:name "attributeValue", :shape "StringMax256"})]}))

(clojure.core/defn- req-create-instances-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string-list (input :instance-names)) #:http.request.field{:name "instanceNames", :shape "StringList"}) (clojure.core/into (serstring (input :availability-zone)) #:http.request.field{:name "availabilityZone", :shape "string"}) (clojure.core/into (ser-non-empty-string (input :blueprint-id)) #:http.request.field{:name "blueprintId", :shape "NonEmptyString"}) (clojure.core/into (ser-non-empty-string (input :bundle-id)) #:http.request.field{:name "bundleId", :shape "NonEmptyString"})]} (clojure.core/contains? input :custom-image-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :custom-image-name)) #:http.request.field{:name "customImageName", :shape "ResourceName", :deprecated true})) (clojure.core/contains? input :user-data) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :user-data)) #:http.request.field{:name "userData", :shape "string"})) (clojure.core/contains? input :key-pair-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :key-pair-name)) #:http.request.field{:name "keyPairName", :shape "ResourceName"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-start-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-load-balancer-metric-data-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-load-balancer-metric-name (input :metric-name)) #:http.request.field{:name "metricName", :shape "LoadBalancerMetricName"}) (clojure.core/into (ser-metric-period (input :period)) #:http.request.field{:name "period", :shape "MetricPeriod"}) (clojure.core/into (sertimestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "timestamp"}) (clojure.core/into (sertimestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "timestamp"}) (clojure.core/into (ser-metric-unit (input :unit)) #:http.request.field{:name "unit", :shape "MetricUnit"}) (clojure.core/into (ser-metric-statistic-list (input :statistics)) #:http.request.field{:name "statistics", :shape "MetricStatisticList"})]}))

(clojure.core/defn- req-get-relational-database-events-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :duration-in-minutes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serinteger (input :duration-in-minutes)) #:http.request.field{:name "durationInMinutes", :shape "integer"})) (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-get-disk-snapshots-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-get-relational-database-snapshots-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-copy-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :source-snapshot-name)) #:http.request.field{:name "sourceSnapshotName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :target-snapshot-name)) #:http.request.field{:name "targetSnapshotName", :shape "ResourceName"}) (clojure.core/into (ser-region-name (input :source-region)) #:http.request.field{:name "sourceRegion", :shape "RegionName"})]}))

(clojure.core/defn- req-attach-static-ip-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :static-ip-name)) #:http.request.field{:name "staticIpName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :key-pair-name)) #:http.request.field{:name "keyPairName", :shape "ResourceName"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-instance-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-snapshot-name)) #:http.request.field{:name "instanceSnapshotName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-static-ips-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-import-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :key-pair-name)) #:http.request.field{:name "keyPairName", :shape "ResourceName"}) (clojure.core/into (ser-base-64 (input :public-key-base-64)) #:http.request.field{:name "publicKeyBase64", :shape "Base64"})]}))

(clojure.core/defn- req-get-load-balancer-tls-certificates-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-operations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-reboot-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]}))

(clojure.core/defn- req-allocate-static-ip-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :static-ip-name)) #:http.request.field{:name "staticIpName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-domain-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-domain-name (input :domain-name)) #:http.request.field{:name "domainName", :shape "DomainName"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-put-instance-public-ports-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-port-info-list (input :port-infos)) #:http.request.field{:name "portInfos", :shape "PortInfoList"}) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-blueprints-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :include-inactive) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :include-inactive)) #:http.request.field{:name "includeInactive", :shape "boolean"})) (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-delete-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-domains-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-delete-disk-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-relational-database-log-streams-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"}) (clojure.core/into (serstring (input :relational-database-blueprint-id)) #:http.request.field{:name "relationalDatabaseBlueprintId", :shape "string"}) (clojure.core/into (serstring (input :relational-database-bundle-id)) #:http.request.field{:name "relationalDatabaseBundleId", :shape "string"}) (clojure.core/into (serstring (input :master-database-name)) #:http.request.field{:name "masterDatabaseName", :shape "string"}) (clojure.core/into (serstring (input :master-username)) #:http.request.field{:name "masterUsername", :shape "string"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})) (clojure.core/contains? input :preferred-backup-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :preferred-backup-window)) #:http.request.field{:name "preferredBackupWindow", :shape "string"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :availability-zone)) #:http.request.field{:name "availabilityZone", :shape "string"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :publicly-accessible)) #:http.request.field{:name "publiclyAccessible", :shape "boolean"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :preferred-maintenance-window)) #:http.request.field{:name "preferredMaintenanceWindow", :shape "string"})) (clojure.core/contains? input :master-user-password) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sensitive-string (input :master-user-password)) #:http.request.field{:name "masterUserPassword", :shape "SensitiveString"}))))

(clojure.core/defn- req-get-instance-snapshots-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-stop-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :force)) #:http.request.field{:name "force", :shape "boolean"}))))

(clojure.core/defn- req-detach-static-ip-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :static-ip-name)) #:http.request.field{:name "staticIpName", :shape "ResourceName"})]}))

(clojure.core/defn- req-is-vpc-peered-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-get-load-balancer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"})]}))

(clojure.core/defn- req-delete-load-balancer-tls-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "ResourceName"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :force)) #:http.request.field{:name "force", :shape "boolean"}))))

(clojure.core/defn- req-get-relational-database-metric-data-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"}) (clojure.core/into (ser-relational-database-metric-name (input :metric-name)) #:http.request.field{:name "metricName", :shape "RelationalDatabaseMetricName"}) (clojure.core/into (ser-metric-period (input :period)) #:http.request.field{:name "period", :shape "MetricPeriod"}) (clojure.core/into (ser-iso-date (input :start-time)) #:http.request.field{:name "startTime", :shape "IsoDate"}) (clojure.core/into (ser-iso-date (input :end-time)) #:http.request.field{:name "endTime", :shape "IsoDate"}) (clojure.core/into (ser-metric-unit (input :unit)) #:http.request.field{:name "unit", :shape "MetricUnit"}) (clojure.core/into (ser-metric-statistic-list (input :statistics)) #:http.request.field{:name "statistics", :shape "MetricStatisticList"})]}))

(clojure.core/defn- req-get-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-export-snapshot-records-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-delete-domain-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-domain-name (input :domain-name)) #:http.request.field{:name "domainName", :shape "DomainName"})]}))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :resource-name)) #:http.request.field{:name "resourceName", :shape "ResourceName"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})]}))

(clojure.core/defn- req-create-cloud-formation-stack-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-entry-list (input :instances)) #:http.request.field{:name "instances", :shape "InstanceEntryList"})]}))

(clojure.core/defn- req-create-disk-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-snapshot-name)) #:http.request.field{:name "diskSnapshotName", :shape "ResourceName"})]} (clojure.core/contains? input :disk-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"})) (clojure.core/contains? input :instance-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-static-ip-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :static-ip-name)) #:http.request.field{:name "staticIpName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-regions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :include-availability-zones) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :include-availability-zones)) #:http.request.field{:name "includeAvailabilityZones", :shape "boolean"})) (clojure.core/contains? input :include-relational-database-availability-zones) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :include-relational-database-availability-zones)) #:http.request.field{:name "includeRelationalDatabaseAvailabilityZones", :shape "boolean"}))))

(clojure.core/defn- req-get-key-pairs-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-update-domain-entry-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-domain-name (input :domain-name)) #:http.request.field{:name "domainName", :shape "DomainName"}) (clojure.core/into (ser-domain-entry (input :domain-entry)) #:http.request.field{:name "domainEntry", :shape "DomainEntry"})]}))

(clojure.core/defn- req-peer-vpc-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-download-default-key-pair-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-get-relational-database-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-snapshot-name)) #:http.request.field{:name "relationalDatabaseSnapshotName", :shape "ResourceName"})]}))

(clojure.core/defn- req-delete-key-pair-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :key-pair-name)) #:http.request.field{:name "keyPairName", :shape "ResourceName"})]}))

(clojure.core/defn- req-unpeer-vpc-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-create-load-balancer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-port (input :instance-port)) #:http.request.field{:name "instancePort", :shape "Port"})]} (clojure.core/contains? input :health-check-path) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :health-check-path)) #:http.request.field{:name "healthCheckPath", :shape "string"})) (clojure.core/contains? input :certificate-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "ResourceName"})) (clojure.core/contains? input :certificate-domain-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-name (input :certificate-domain-name)) #:http.request.field{:name "certificateDomainName", :shape "DomainName"})) (clojure.core/contains? input :certificate-alternative-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-name-list (input :certificate-alternative-names)) #:http.request.field{:name "certificateAlternativeNames", :shape "DomainNameList"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-load-balancer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-load-balancers-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-detach-instances-from-load-balancer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name-list (input :instance-names)) #:http.request.field{:name "instanceNames", :shape "ResourceNameList"})]}))

(clojure.core/defn- req-get-relational-database-master-user-password-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :password-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-relational-database-password-version (input :password-version)) #:http.request.field{:name "passwordVersion", :shape "RelationalDatabasePasswordVersion"}))))

(clojure.core/defn- req-get-disk-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"})]}))

(clojure.core/defn- req-delete-domain-entry-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-domain-name (input :domain-name)) #:http.request.field{:name "domainName", :shape "DomainName"}) (clojure.core/into (ser-domain-entry (input :domain-entry)) #:http.request.field{:name "domainEntry", :shape "DomainEntry"})]}))

(clojure.core/defn- req-delete-instance-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-snapshot-name)) #:http.request.field{:name "instanceSnapshotName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-disk-from-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :disk-snapshot-name)) #:http.request.field{:name "diskSnapshotName", :shape "ResourceName"}) (clojure.core/into (ser-non-empty-string (input :availability-zone)) #:http.request.field{:name "availabilityZone", :shape "NonEmptyString"}) (clojure.core/into (serinteger (input :size-in-gb)) #:http.request.field{:name "sizeInGb", :shape "integer"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-operations-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :resource-name)) #:http.request.field{:name "resourceName", :shape "ResourceName"})]} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-get-instance-access-details-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]} (clojure.core/contains? input :protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-access-protocol (input :protocol)) #:http.request.field{:name "protocol", :shape "InstanceAccessProtocol"}))))

(clojure.core/defn- req-get-active-names-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-get-instance-state-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-attach-disk-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"}) (clojure.core/into (ser-non-empty-string (input :disk-path)) #:http.request.field{:name "diskPath", :shape "NonEmptyString"})]}))

(clojure.core/defn- req-reboot-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-bundles-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :include-inactive) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :include-inactive)) #:http.request.field{:name "includeInactive", :shape "boolean"})) (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-stop-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :relational-database-snapshot-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :relational-database-snapshot-name)) #:http.request.field{:name "relationalDatabaseSnapshotName", :shape "ResourceName"}))))

(clojure.core/defn- req-close-instance-public-ports-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-port-info (input :port-info)) #:http.request.field{:name "portInfo", :shape "PortInfo"}) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-relational-database-parameters-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-start-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-release-static-ip-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :static-ip-name)) #:http.request.field{:name "staticIpName", :shape "ResourceName"})]}))

(clojure.core/defn- req-attach-instances-to-load-balancer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name-list (input :instance-names)) #:http.request.field{:name "instanceNames", :shape "ResourceNameList"})]}))

(clojure.core/defn- req-open-instance-public-ports-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-port-info (input :port-info)) #:http.request.field{:name "portInfo", :shape "PortInfo"}) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-get-operation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-non-empty-string (input :operation-id)) #:http.request.field{:name "operationId", :shape "NonEmptyString"})]}))

(clojure.core/defn- req-get-cloud-formation-stack-records-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-get-instance-port-states-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-relational-database-from-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :source-relational-database-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :source-relational-database-name)) #:http.request.field{:name "sourceRelationalDatabaseName", :shape "ResourceName"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})) (clojure.core/contains? input :use-latest-restorable-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :use-latest-restorable-time)) #:http.request.field{:name "useLatestRestorableTime", :shape "boolean"})) (clojure.core/contains? input :restore-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iso-date (input :restore-time)) #:http.request.field{:name "restoreTime", :shape "IsoDate"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :availability-zone)) #:http.request.field{:name "availabilityZone", :shape "string"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :publicly-accessible)) #:http.request.field{:name "publiclyAccessible", :shape "boolean"})) (clojure.core/contains? input :relational-database-snapshot-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :relational-database-snapshot-name)) #:http.request.field{:name "relationalDatabaseSnapshotName", :shape "ResourceName"})) (clojure.core/contains? input :relational-database-bundle-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :relational-database-bundle-id)) #:http.request.field{:name "relationalDatabaseBundleId", :shape "string"}))))

(clojure.core/defn- req-get-disks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-create-disk-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-name)) #:http.request.field{:name "diskName", :shape "ResourceName"}) (clojure.core/into (ser-non-empty-string (input :availability-zone)) #:http.request.field{:name "availabilityZone", :shape "NonEmptyString"}) (clojure.core/into (serinteger (input :size-in-gb)) #:http.request.field{:name "sizeInGb", :shape "integer"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-relational-database-log-events-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"}) (clojure.core/into (serstring (input :log-stream-name)) #:http.request.field{:name "logStreamName", :shape "string"})]} (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iso-date (input :start-time)) #:http.request.field{:name "startTime", :shape "IsoDate"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iso-date (input :end-time)) #:http.request.field{:name "endTime", :shape "IsoDate"})) (clojure.core/contains? input :start-from-head) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :start-from-head)) #:http.request.field{:name "startFromHead", :shape "boolean"})) (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-delete-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :skip-final-snapshot) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :skip-final-snapshot)) #:http.request.field{:name "skipFinalSnapshot", :shape "boolean"})) (clojure.core/contains? input :final-relational-database-snapshot-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name (input :final-relational-database-snapshot-name)) #:http.request.field{:name "finalRelationalDatabaseSnapshotName", :shape "ResourceName"}))))

(clojure.core/defn- req-create-load-balancer-tls-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :load-balancer-name)) #:http.request.field{:name "loadBalancerName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "ResourceName"}) (clojure.core/into (ser-domain-name (input :certificate-domain-name)) #:http.request.field{:name "certificateDomainName", :shape "DomainName"})]} (clojure.core/contains? input :certificate-alternative-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-domain-name-list (input :certificate-alternative-names)) #:http.request.field{:name "certificateAlternativeNames", :shape "DomainNameList"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-instance-metric-data-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"}) (clojure.core/into (ser-instance-metric-name (input :metric-name)) #:http.request.field{:name "metricName", :shape "InstanceMetricName"}) (clojure.core/into (ser-metric-period (input :period)) #:http.request.field{:name "period", :shape "MetricPeriod"}) (clojure.core/into (sertimestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "timestamp"}) (clojure.core/into (sertimestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "timestamp"}) (clojure.core/into (ser-metric-unit (input :unit)) #:http.request.field{:name "unit", :shape "MetricUnit"}) (clojure.core/into (ser-metric-statistic-list (input :statistics)) #:http.request.field{:name "statistics", :shape "MetricStatisticList"})]}))

(clojure.core/defn- req-get-relational-database-bundles-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-export-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :source-snapshot-name)) #:http.request.field{:name "sourceSnapshotName", :shape "ResourceName"})]}))

(clojure.core/defn- req-update-relational-database-parameters-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"}) (clojure.core/into (ser-relational-database-parameter-list (input :parameters)) #:http.request.field{:name "parameters", :shape "RelationalDatabaseParameterList"})]}))

(clojure.core/defn- req-get-relational-databases-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :page-token)) #:http.request.field{:name "pageToken", :shape "string"}))))

(clojure.core/defn- req-delete-disk-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :disk-snapshot-name)) #:http.request.field{:name "diskSnapshotName", :shape "ResourceName"})]}))

(clojure.core/defn- req-create-instance-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :instance-snapshot-name)) #:http.request.field{:name "instanceSnapshotName", :shape "ResourceName"}) (clojure.core/into (ser-resource-name (input :instance-name)) #:http.request.field{:name "instanceName", :shape "ResourceName"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-domain-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-domain-name (input :domain-name)) #:http.request.field{:name "domainName", :shape "DomainName"})]}))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :resource-name)) #:http.request.field{:name "resourceName", :shape "ResourceName"}) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "tagKeys", :shape "TagKeyList"})]}))

(clojure.core/defn- req-update-relational-database-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-name)) #:http.request.field{:name "relationalDatabaseName", :shape "ResourceName"})]} (clojure.core/contains? input :rotate-master-user-password) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :rotate-master-user-password)) #:http.request.field{:name "rotateMasterUserPassword", :shape "boolean"})) (clojure.core/contains? input :preferred-backup-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :preferred-backup-window)) #:http.request.field{:name "preferredBackupWindow", :shape "string"})) (clojure.core/contains? input :enable-backup-retention) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :enable-backup-retention)) #:http.request.field{:name "enableBackupRetention", :shape "boolean"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :publicly-accessible)) #:http.request.field{:name "publiclyAccessible", :shape "boolean"})) (clojure.core/contains? input :disable-backup-retention) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :disable-backup-retention)) #:http.request.field{:name "disableBackupRetention", :shape "boolean"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :preferred-maintenance-window)) #:http.request.field{:name "preferredMaintenanceWindow", :shape "string"})) (clojure.core/contains? input :master-user-password) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sensitive-string (input :master-user-password)) #:http.request.field{:name "masterUserPassword", :shape "SensitiveString"})) (clojure.core/contains? input :apply-immediately) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :apply-immediately)) #:http.request.field{:name "applyImmediately", :shape "boolean"}))))

(clojure.core/defn- req-delete-relational-database-snapshot-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-name (input :relational-database-snapshot-name)) #:http.request.field{:name "relationalDatabaseSnapshotName", :shape "ResourceName"})]}))

(clojure.core/declare deserfloat)

(clojure.core/declare deserboolean)

(clojure.core/declare deser-disk-info)

(clojure.core/declare deser-instance-port-state)

(clojure.core/declare deser-cloud-formation-stack-record-source-info)

(clojure.core/declare deser-pending-maintenance-action)

(clojure.core/declare deser-load-balancer-tls-certificate-domain-validation-option-list)

(clojure.core/declare deser-string-list)

(clojure.core/declare deser-record-state)

(clojure.core/declare deser-load-balancer-tls-certificate-summary-list)

(clojure.core/declare deser-instance-snapshot-info)

(clojure.core/declare deser-non-empty-string)

(clojure.core/declare deser-operation-list)

(clojure.core/declare deserstring)

(clojure.core/declare deser-port-list)

(clojure.core/declare deser-pending-modified-relational-database-values)

(clojure.core/declare deser-load-balancer-tls-certificate-revocation-reason)

(clojure.core/declare deser-instance-port-state-list)

(clojure.core/declare deser-disk-snapshot)

(clojure.core/declare deser-load-balancer-tls-certificate-domain-validation-record-list)

(clojure.core/declare deser-metric-datapoint)

(clojure.core/declare deser-resource-location)

(clojure.core/declare deser-load-balancer-metric-name)

(clojure.core/declare deser-instance-access-details)

(clojure.core/declare deser-region-list)

(clojure.core/declare deser-relational-database-event)

(clojure.core/declare deser-tag-key)

(clojure.core/declare deser-static-ip-list)

(clojure.core/declare deser-metric-datapoint-list)

(clojure.core/declare deser-instance-health-reason)

(clojure.core/declare deser-port-state)

(clojure.core/declare deser-bundle-list)

(clojure.core/declare deser-instance-health-summary)

(clojure.core/declare deser-relational-database-bundle)

(clojure.core/declare deser-bundle)

(clojure.core/declare deser-operation)

(clojure.core/declare deser-key-pair-list)

(clojure.core/declare deser-load-balancer-tls-certificate-domain-validation-record)

(clojure.core/declare deser-base-64)

(clojure.core/declare desertimestamp)

(clojure.core/declare deser-load-balancer-tls-certificate)

(clojure.core/declare deser-domain-entry)

(clojure.core/declare deser-availability-zone-list)

(clojure.core/declare deser-metric-unit)

(clojure.core/declare deser-availability-zone)

(clojure.core/declare deser-cloud-formation-stack-record-source-info-list)

(clojure.core/declare deser-instance-health-state)

(clojure.core/declare deser-load-balancer-tls-certificate-failure-reason)

(clojure.core/declare deser-export-snapshot-record-list)

(clojure.core/declare deser-load-balancer-tls-certificate-domain-validation-option)

(clojure.core/declare deser-blueprint-list)

(clojure.core/declare deser-instance-networking)

(clojure.core/declare deser-relational-database-engine)

(clojure.core/declare deser-relational-database-parameter-list)

(clojure.core/declare deser-load-balancer-tls-certificate-renewal-status)

(clojure.core/declare deser-sensitive-string)

(clojure.core/declare deser-port-access-type)

(clojure.core/declare deser-region-name)

(clojure.core/declare deser-blueprint)

(clojure.core/declare deser-domain)

(clojure.core/declare deser-domain-list)

(clojure.core/declare deser-instance-hardware)

(clojure.core/declare deser-relational-database-event-list)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-relational-database-endpoint)

(clojure.core/declare deser-load-balancer-tls-certificate-renewal-summary)

(clojure.core/declare deser-relational-database-metric-name)

(clojure.core/declare deser-load-balancer-state)

(clojure.core/declare deser-load-balancer-tls-certificate-status)

(clojure.core/declare deser-export-snapshot-record-source-info)

(clojure.core/declare deser-cloud-formation-stack-record-source-type)

(clojure.core/declare deser-ip-v-6-address)

(clojure.core/declare deser-relational-database-bundle-list)

(clojure.core/declare deser-pending-maintenance-action-list)

(clojure.core/declare deser-relational-database-hardware)

(clojure.core/declare deser-disk-snapshot-info)

(clojure.core/declare deser-instance-port-info)

(clojure.core/declare deser-relational-database-parameter)

(clojure.core/declare deser-tag-value)

(clojure.core/declare deser-port)

(clojure.core/declare deser-iso-date)

(clojure.core/declare deser-disk-snapshot-list)

(clojure.core/declare deser-instance-snapshot-state)

(clojure.core/declare deser-access-direction)

(clojure.core/declare deser-load-balancer-tls-certificate-list)

(clojure.core/declare deser-blueprint-type)

(clojure.core/declare deser-load-balancer-configuration-options)

(clojure.core/declare deser-instance-platform)

(clojure.core/declare deser-disk-state)

(clojure.core/declare deser-operation-status)

(clojure.core/declare deser-resource-name)

(clojure.core/declare deser-domain-entry-options-keys)

(clojure.core/declare deser-relational-database-blueprint)

(clojure.core/declare deser-export-snapshot-record-source-type)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-log-event-list)

(clojure.core/declare deser-load-balancer-tls-certificate-summary)

(clojure.core/declare deserinteger)

(clojure.core/declare deser-instance-metric-name)

(clojure.core/declare deser-operation-type)

(clojure.core/declare deser-instance-list)

(clojure.core/declare deser-relational-database-snapshot-list)

(clojure.core/declare deserdouble)

(clojure.core/declare deser-load-balancer-protocol)

(clojure.core/declare deser-disk)

(clojure.core/declare deser-ip-address)

(clojure.core/declare deser-instance-state)

(clojure.core/declare deser-load-balancer)

(clojure.core/declare deser-disk-list)

(clojure.core/declare deser-load-balancer-tls-certificate-domain-status)

(clojure.core/declare deser-network-protocol)

(clojure.core/declare deser-static-ip)

(clojure.core/declare deser-instance-snapshot)

(clojure.core/declare deser-key-pair)

(clojure.core/declare deser-domain-entry-list)

(clojure.core/declare deser-log-event)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-monthly-transfer)

(clojure.core/declare deser-domain-entry-type)

(clojure.core/declare deser-cloud-formation-stack-record-list)

(clojure.core/declare deser-instance)

(clojure.core/declare deser-domain-name)

(clojure.core/declare deser-instance-platform-list)

(clojure.core/declare deser-instance-snapshot-list)

(clojure.core/declare deser-relational-database-blueprint-list)

(clojure.core/declare deser-relational-database-snapshot)

(clojure.core/declare deser-load-balancer-attribute-name)

(clojure.core/declare deser-disk-info-list)

(clojure.core/declare deser-instance-access-protocol)

(clojure.core/declare deser-destination-info)

(clojure.core/declare deser-disk-snapshot-state)

(clojure.core/declare deser-relational-database)

(clojure.core/declare deser-region)

(clojure.core/declare deser-instance-health-summary-list)

(clojure.core/declare deser-password-data)

(clojure.core/declare deser-instance-port-info-list)

(clojure.core/declare deser-export-snapshot-record)

(clojure.core/declare deser-load-balancer-list)

(clojure.core/declare deser-cloud-formation-stack-record)

(clojure.core/declare deser-relational-database-list)

(clojure.core/declare deser-domain-entry-options)

(clojure.core/defn- deserfloat [input] input)

(clojure.core/defn- deserboolean [input] input)

(clojure.core/defn- deser-disk-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deserstring (input "name"))) (clojure.core/contains? input "path") (clojure.core/assoc :path (deser-non-empty-string (input "path"))) (clojure.core/contains? input "sizeInGb") (clojure.core/assoc :size-in-gb (deserinteger (input "sizeInGb"))) (clojure.core/contains? input "isSystemDisk") (clojure.core/assoc :is-system-disk (deserboolean (input "isSystemDisk")))))

(clojure.core/defn- deser-instance-port-state [input] (clojure.core/cond-> {} (clojure.core/contains? input "fromPort") (clojure.core/assoc :from-port (deser-port (input "fromPort"))) (clojure.core/contains? input "toPort") (clojure.core/assoc :to-port (deser-port (input "toPort"))) (clojure.core/contains? input "protocol") (clojure.core/assoc :protocol (deser-network-protocol (input "protocol"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-port-state (input "state")))))

(clojure.core/defn- deser-cloud-formation-stack-record-source-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-cloud-formation-stack-record-source-type (input "resourceType"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-non-empty-string (input "name"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn")))))

(clojure.core/defn- deser-pending-maintenance-action [input] (clojure.core/cond-> {} (clojure.core/contains? input "action") (clojure.core/assoc :action (deser-non-empty-string (input "action"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-non-empty-string (input "description"))) (clojure.core/contains? input "currentApplyDate") (clojure.core/assoc :current-apply-date (deser-iso-date (input "currentApplyDate")))))

(clojure.core/defn- deser-load-balancer-tls-certificate-domain-validation-option-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-load-balancer-tls-certificate-domain-validation-option coll))) input))

(clojure.core/defn- deser-string-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deserstring coll))) input))

(clojure.core/defn- deser-record-state [input] (clojure.core/get {"Started" :started, "Succeeded" :succeeded, "Failed" :failed} input))

(clojure.core/defn- deser-load-balancer-tls-certificate-summary-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-load-balancer-tls-certificate-summary coll))) input))

(clojure.core/defn- deser-instance-snapshot-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "fromBundleId") (clojure.core/assoc :from-bundle-id (deser-non-empty-string (input "fromBundleId"))) (clojure.core/contains? input "fromBlueprintId") (clojure.core/assoc :from-blueprint-id (deser-non-empty-string (input "fromBlueprintId"))) (clojure.core/contains? input "fromDiskInfo") (clojure.core/assoc :from-disk-info (deser-disk-info-list (input "fromDiskInfo")))))

(clojure.core/defn- deser-non-empty-string [input] input)

(clojure.core/defn- deser-operation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-operation coll))) input))

(clojure.core/defn- deserstring [input] input)

(clojure.core/defn- deser-port-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-port coll))) input))

(clojure.core/defn- deser-pending-modified-relational-database-values [input] (clojure.core/cond-> {} (clojure.core/contains? input "masterUserPassword") (clojure.core/assoc :master-user-password (deserstring (input "masterUserPassword"))) (clojure.core/contains? input "engineVersion") (clojure.core/assoc :engine-version (deserstring (input "engineVersion"))) (clojure.core/contains? input "backupRetentionEnabled") (clojure.core/assoc :backup-retention-enabled (deserboolean (input "backupRetentionEnabled")))))

(clojure.core/defn- deser-load-balancer-tls-certificate-revocation-reason [input] (clojure.core/get {"PRIVILEGE_WITHDRAWN" :privilege-withdrawn, "CERTIFICATE_HOLD" :certificate-hold, "REMOVE_FROM_CRL" :remove-from-crl, "AFFILIATION_CHANGED" :affiliation-changed, "SUPERCEDED" :superceded, "KEY_COMPROMISE" :key-compromise, "UNSPECIFIED" :unspecified, "CA_COMPROMISE" :ca-compromise, "CESSATION_OF_OPERATION" :cessation-of-operation, "A_A_COMPROMISE" :a-a-compromise} input))

(clojure.core/defn- deser-instance-port-state-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-port-state coll))) input))

(clojure.core/defn- deser-disk-snapshot [input] (clojure.core/cond-> {} (clojure.core/contains? input "progress") (clojure.core/assoc :progress (deserstring (input "progress"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "fromInstanceName") (clojure.core/assoc :from-instance-name (deser-resource-name (input "fromInstanceName"))) (clojure.core/contains? input "sizeInGb") (clojure.core/assoc :size-in-gb (deserinteger (input "sizeInGb"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-disk-snapshot-state (input "state"))) (clojure.core/contains? input "fromInstanceArn") (clojure.core/assoc :from-instance-arn (deser-non-empty-string (input "fromInstanceArn"))) (clojure.core/contains? input "fromDiskArn") (clojure.core/assoc :from-disk-arn (deser-non-empty-string (input "fromDiskArn"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "fromDiskName") (clojure.core/assoc :from-disk-name (deser-resource-name (input "fromDiskName")))))

(clojure.core/defn- deser-load-balancer-tls-certificate-domain-validation-record-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-load-balancer-tls-certificate-domain-validation-record coll))) input))

(clojure.core/defn- deser-metric-datapoint [input] (clojure.core/cond-> {} (clojure.core/contains? input "average") (clojure.core/assoc :average (deserdouble (input "average"))) (clojure.core/contains? input "maximum") (clojure.core/assoc :maximum (deserdouble (input "maximum"))) (clojure.core/contains? input "minimum") (clojure.core/assoc :minimum (deserdouble (input "minimum"))) (clojure.core/contains? input "sampleCount") (clojure.core/assoc :sample-count (deserdouble (input "sampleCount"))) (clojure.core/contains? input "sum") (clojure.core/assoc :sum (deserdouble (input "sum"))) (clojure.core/contains? input "timestamp") (clojure.core/assoc :timestamp (desertimestamp (input "timestamp"))) (clojure.core/contains? input "unit") (clojure.core/assoc :unit (deser-metric-unit (input "unit")))))

(clojure.core/defn- deser-resource-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "availabilityZone") (clojure.core/assoc :availability-zone (deserstring (input "availabilityZone"))) (clojure.core/contains? input "regionName") (clojure.core/assoc :region-name (deser-region-name (input "regionName")))))

(clojure.core/defn- deser-load-balancer-metric-name [input] (clojure.core/get {"InstanceResponseTime" :instance-response-time, "RejectedConnectionCount" :rejected-connection-count, "HTTPCode_LB_5XX_Count" :http-code-lb-5-xx-count, "RequestCount" :request-count, "ClientTLSNegotiationErrorCount" :client-tls-negotiation-error-count, "HTTPCode_Instance_5XX_Count" :http-code-instance-5-xx-count, "HTTPCode_LB_4XX_Count" :http-code-lb-4-xx-count, "HTTPCode_Instance_2XX_Count" :http-code-instance-2-xx-count, "HealthyHostCount" :healthy-host-count, "UnhealthyHostCount" :unhealthy-host-count, "HTTPCode_Instance_3XX_Count" :http-code-instance-3-xx-count, "HTTPCode_Instance_4XX_Count" :http-code-instance-4-xx-count} input))

(clojure.core/defn- deser-instance-access-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "protocol") (clojure.core/assoc :protocol (deser-instance-access-protocol (input "protocol"))) (clojure.core/contains? input "instanceName") (clojure.core/assoc :instance-name (deser-resource-name (input "instanceName"))) (clojure.core/contains? input "passwordData") (clojure.core/assoc :password-data (deser-password-data (input "passwordData"))) (clojure.core/contains? input "username") (clojure.core/assoc :username (deserstring (input "username"))) (clojure.core/contains? input "certKey") (clojure.core/assoc :cert-key (deserstring (input "certKey"))) (clojure.core/contains? input "privateKey") (clojure.core/assoc :private-key (deserstring (input "privateKey"))) (clojure.core/contains? input "password") (clojure.core/assoc :password (deserstring (input "password"))) (clojure.core/contains? input "ipAddress") (clojure.core/assoc :ip-address (deser-ip-address (input "ipAddress"))) (clojure.core/contains? input "expiresAt") (clojure.core/assoc :expires-at (deser-iso-date (input "expiresAt")))))

(clojure.core/defn- deser-region-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-region coll))) input))

(clojure.core/defn- deser-relational-database-event [input] (clojure.core/cond-> {} (clojure.core/contains? input "resource") (clojure.core/assoc :resource (deser-resource-name (input "resource"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "message") (clojure.core/assoc :message (deserstring (input "message"))) (clojure.core/contains? input "eventCategories") (clojure.core/assoc :event-categories (deser-string-list (input "eventCategories")))))

(clojure.core/defn- deser-tag-key [input] input)

(clojure.core/defn- deser-static-ip-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-static-ip coll))) input))

(clojure.core/defn- deser-metric-datapoint-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-metric-datapoint coll))) input))

(clojure.core/defn- deser-instance-health-reason [input] (clojure.core/get {"Instance.ResponseCodeMismatch" :instance-response-code-mismatch, "Lb.InternalError" :lb-internal-error, "Instance.NotRegistered" :instance-not-registered, "Instance.FailedHealthChecks" :instance-failed-health-checks, "Instance.Timeout" :instance-timeout, "Instance.IpUnusable" :instance-ip-unusable, "Instance.NotInUse" :instance-not-in-use, "Instance.DeregistrationInProgress" :instance-deregistration-in-progress, "Lb.InitialHealthChecking" :lb-initial-health-checking, "Instance.InvalidState" :instance-invalid-state, "Lb.RegistrationInProgress" :lb-registration-in-progress} input))

(clojure.core/defn- deser-port-state [input] (clojure.core/get {"open" :open, "closed" :closed} input))

(clojure.core/defn- deser-bundle-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-bundle coll))) input))

(clojure.core/defn- deser-instance-health-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "instanceName") (clojure.core/assoc :instance-name (deser-resource-name (input "instanceName"))) (clojure.core/contains? input "instanceHealth") (clojure.core/assoc :instance-health (deser-instance-health-state (input "instanceHealth"))) (clojure.core/contains? input "instanceHealthReason") (clojure.core/assoc :instance-health-reason (deser-instance-health-reason (input "instanceHealthReason")))))

(clojure.core/defn- deser-relational-database-bundle [input] (clojure.core/cond-> {} (clojure.core/contains? input "isActive") (clojure.core/assoc :is-active (deserboolean (input "isActive"))) (clojure.core/contains? input "isEncrypted") (clojure.core/assoc :is-encrypted (deserboolean (input "isEncrypted"))) (clojure.core/contains? input "diskSizeInGb") (clojure.core/assoc :disk-size-in-gb (deserinteger (input "diskSizeInGb"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deserstring (input "name"))) (clojure.core/contains? input "bundleId") (clojure.core/assoc :bundle-id (deserstring (input "bundleId"))) (clojure.core/contains? input "ramSizeInGb") (clojure.core/assoc :ram-size-in-gb (deserfloat (input "ramSizeInGb"))) (clojure.core/contains? input "transferPerMonthInGb") (clojure.core/assoc :transfer-per-month-in-gb (deserinteger (input "transferPerMonthInGb"))) (clojure.core/contains? input "price") (clojure.core/assoc :price (deserfloat (input "price"))) (clojure.core/contains? input "cpuCount") (clojure.core/assoc :cpu-count (deserinteger (input "cpuCount")))))

(clojure.core/defn- deser-bundle [input] (clojure.core/cond-> {} (clojure.core/contains? input "isActive") (clojure.core/assoc :is-active (deserboolean (input "isActive"))) (clojure.core/contains? input "diskSizeInGb") (clojure.core/assoc :disk-size-in-gb (deserinteger (input "diskSizeInGb"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deserstring (input "name"))) (clojure.core/contains? input "power") (clojure.core/assoc :power (deserinteger (input "power"))) (clojure.core/contains? input "supportedPlatforms") (clojure.core/assoc :supported-platforms (deser-instance-platform-list (input "supportedPlatforms"))) (clojure.core/contains? input "bundleId") (clojure.core/assoc :bundle-id (deser-non-empty-string (input "bundleId"))) (clojure.core/contains? input "ramSizeInGb") (clojure.core/assoc :ram-size-in-gb (deserfloat (input "ramSizeInGb"))) (clojure.core/contains? input "instanceType") (clojure.core/assoc :instance-type (deserstring (input "instanceType"))) (clojure.core/contains? input "transferPerMonthInGb") (clojure.core/assoc :transfer-per-month-in-gb (deserinteger (input "transferPerMonthInGb"))) (clojure.core/contains? input "price") (clojure.core/assoc :price (deserfloat (input "price"))) (clojure.core/contains? input "cpuCount") (clojure.core/assoc :cpu-count (deserinteger (input "cpuCount")))))

(clojure.core/defn- deser-operation [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceName") (clojure.core/assoc :resource-name (deser-resource-name (input "resourceName"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "isTerminal") (clojure.core/assoc :is-terminal (deserboolean (input "isTerminal"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-non-empty-string (input "id"))) (clojure.core/contains? input "operationDetails") (clojure.core/assoc :operation-details (deserstring (input "operationDetails"))) (clojure.core/contains? input "operationType") (clojure.core/assoc :operation-type (deser-operation-type (input "operationType"))) (clojure.core/contains? input "errorCode") (clojure.core/assoc :error-code (deserstring (input "errorCode"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-operation-status (input "status"))) (clojure.core/contains? input "errorDetails") (clojure.core/assoc :error-details (deserstring (input "errorDetails"))) (clojure.core/contains? input "statusChangedAt") (clojure.core/assoc :status-changed-at (deser-iso-date (input "statusChangedAt"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType")))))

(clojure.core/defn- deser-key-pair-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-key-pair coll))) input))

(clojure.core/defn- deser-load-balancer-tls-certificate-domain-validation-record [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-non-empty-string (input "name"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-non-empty-string (input "type"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-non-empty-string (input "value"))) (clojure.core/contains? input "validationStatus") (clojure.core/assoc :validation-status (deser-load-balancer-tls-certificate-domain-status (input "validationStatus"))) (clojure.core/contains? input "domainName") (clojure.core/assoc :domain-name (deser-domain-name (input "domainName")))))

(clojure.core/defn- deser-base-64 [input] input)

(clojure.core/defn- desertimestamp [input] input)

(clojure.core/defn- deser-load-balancer-tls-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "notAfter") (clojure.core/assoc :not-after (deser-iso-date (input "notAfter"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "serial") (clojure.core/assoc :serial (deser-non-empty-string (input "serial"))) (clojure.core/contains? input "isAttached") (clojure.core/assoc :is-attached (deserboolean (input "isAttached"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "domainValidationRecords") (clojure.core/assoc :domain-validation-records (deser-load-balancer-tls-certificate-domain-validation-record-list (input "domainValidationRecords"))) (clojure.core/contains? input "keyAlgorithm") (clojure.core/assoc :key-algorithm (deser-non-empty-string (input "keyAlgorithm"))) (clojure.core/contains? input "issuer") (clojure.core/assoc :issuer (deser-non-empty-string (input "issuer"))) (clojure.core/contains? input "domainName") (clojure.core/assoc :domain-name (deser-domain-name (input "domainName"))) (clojure.core/contains? input "revokedAt") (clojure.core/assoc :revoked-at (deser-iso-date (input "revokedAt"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-load-balancer-tls-certificate-status (input "status"))) (clojure.core/contains? input "loadBalancerName") (clojure.core/assoc :load-balancer-name (deser-resource-name (input "loadBalancerName"))) (clojure.core/contains? input "signatureAlgorithm") (clojure.core/assoc :signature-algorithm (deser-non-empty-string (input "signatureAlgorithm"))) (clojure.core/contains? input "subject") (clojure.core/assoc :subject (deser-non-empty-string (input "subject"))) (clojure.core/contains? input "subjectAlternativeNames") (clojure.core/assoc :subject-alternative-names (deser-string-list (input "subjectAlternativeNames"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "renewalSummary") (clojure.core/assoc :renewal-summary (deser-load-balancer-tls-certificate-renewal-summary (input "renewalSummary"))) (clojure.core/contains? input "notBefore") (clojure.core/assoc :not-before (deser-iso-date (input "notBefore"))) (clojure.core/contains? input "failureReason") (clojure.core/assoc :failure-reason (deser-load-balancer-tls-certificate-failure-reason (input "failureReason"))) (clojure.core/contains? input "issuedAt") (clojure.core/assoc :issued-at (deser-iso-date (input "issuedAt"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "revocationReason") (clojure.core/assoc :revocation-reason (deser-load-balancer-tls-certificate-revocation-reason (input "revocationReason")))))

(clojure.core/defn- deser-domain-entry [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-non-empty-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-domain-name (input "name"))) (clojure.core/contains? input "target") (clojure.core/assoc :target (deserstring (input "target"))) (clojure.core/contains? input "isAlias") (clojure.core/assoc :is-alias (deserboolean (input "isAlias"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-domain-entry-type (input "type"))) (clojure.core/contains? input "options") (clojure.core/assoc :options (deser-domain-entry-options (input "options")))))

(clojure.core/defn- deser-availability-zone-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-availability-zone coll))) input))

(clojure.core/defn- deser-metric-unit [input] (clojure.core/get {"Terabytes" :terabytes, "Kilobits/Second" :kilobits-second, "Count" :count, "Bits" :bits, "Percent" :percent, "Gigabits/Second" :gigabits-second, "None" :none, "Count/Second" :count-second, "Bytes" :bytes, "Gigabytes/Second" :gigabytes-second, "Megabits/Second" :megabits-second, "Kilobytes/Second" :kilobytes-second, "Terabytes/Second" :terabytes-second, "Bits/Second" :bits-second, "Bytes/Second" :bytes-second, "Milliseconds" :milliseconds, "Kilobytes" :kilobytes, "Microseconds" :microseconds, "Terabits" :terabits, "Megabytes/Second" :megabytes-second, "Gigabytes" :gigabytes, "Gigabits" :gigabits, "Megabits" :megabits, "Kilobits" :kilobits, "Terabits/Second" :terabits-second, "Megabytes" :megabytes, "Seconds" :seconds} input))

(clojure.core/defn- deser-availability-zone [input] (clojure.core/cond-> {} (clojure.core/contains? input "zoneName") (clojure.core/assoc :zone-name (deser-non-empty-string (input "zoneName"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-non-empty-string (input "state")))))

(clojure.core/defn- deser-cloud-formation-stack-record-source-info-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cloud-formation-stack-record-source-info coll))) input))

(clojure.core/defn- deser-instance-health-state [input] (clojure.core/get {"initial" :initial, "healthy" :healthy, "unhealthy" :unhealthy, "unused" :unused, "draining" :draining, "unavailable" :unavailable} input))

(clojure.core/defn- deser-load-balancer-tls-certificate-failure-reason [input] (clojure.core/get {"NO_AVAILABLE_CONTACTS" :no-available-contacts, "ADDITIONAL_VERIFICATION_REQUIRED" :additional-verification-required, "DOMAIN_NOT_ALLOWED" :domain-not-allowed, "INVALID_PUBLIC_DOMAIN" :invalid-public-domain, "OTHER" :other} input))

(clojure.core/defn- deser-export-snapshot-record-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-export-snapshot-record coll))) input))

(clojure.core/defn- deser-load-balancer-tls-certificate-domain-validation-option [input] (clojure.core/cond-> {} (clojure.core/contains? input "domainName") (clojure.core/assoc :domain-name (deser-domain-name (input "domainName"))) (clojure.core/contains? input "validationStatus") (clojure.core/assoc :validation-status (deser-load-balancer-tls-certificate-domain-status (input "validationStatus")))))

(clojure.core/defn- deser-blueprint-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-blueprint coll))) input))

(clojure.core/defn- deser-instance-networking [input] (clojure.core/cond-> {} (clojure.core/contains? input "monthlyTransfer") (clojure.core/assoc :monthly-transfer (deser-monthly-transfer (input "monthlyTransfer"))) (clojure.core/contains? input "ports") (clojure.core/assoc :ports (deser-instance-port-info-list (input "ports")))))

(clojure.core/defn- deser-relational-database-engine [input] (clojure.core/get {"mysql" :mysql} input))

(clojure.core/defn- deser-relational-database-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-relational-database-parameter coll))) input))

(clojure.core/defn- deser-load-balancer-tls-certificate-renewal-status [input] (clojure.core/get {"PENDING_AUTO_RENEWAL" :pending-auto-renewal, "PENDING_VALIDATION" :pending-validation, "SUCCESS" :success, "FAILED" :failed} input))

(clojure.core/defn- deser-sensitive-string [input] input)

(clojure.core/defn- deser-port-access-type [input] (clojure.core/get {"Public" :public, "Private" :private} input))

(clojure.core/defn- deser-region-name [input] (clojure.core/get {"ap-northeast-1" :apnortheast-1, "eu-west-1" :euwest-1, "us-east-2" :useast-2, "ap-southeast-2" :apsoutheast-2, "ap-southeast-1" :apsoutheast-1, "ap-northeast-2" :apnortheast-2, "eu-west-3" :euwest-3, "ca-central-1" :cacentral-1, "eu-central-1" :eucentral-1, "eu-west-2" :euwest-2, "us-west-2" :uswest-2, "us-east-1" :useast-1, "us-west-1" :uswest-1, "ap-south-1" :apsouth-1} input))

(clojure.core/defn- deser-blueprint [input] (clojure.core/cond-> {} (clojure.core/contains? input "isActive") (clojure.core/assoc :is-active (deserboolean (input "isActive"))) (clojure.core/contains? input "blueprintId") (clojure.core/assoc :blueprint-id (deser-non-empty-string (input "blueprintId"))) (clojure.core/contains? input "group") (clojure.core/assoc :group (deser-non-empty-string (input "group"))) (clojure.core/contains? input "minPower") (clojure.core/assoc :min-power (deserinteger (input "minPower"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "productUrl") (clojure.core/assoc :product-url (deserstring (input "productUrl"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-blueprint-type (input "type"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deserstring (input "version"))) (clojure.core/contains? input "licenseUrl") (clojure.core/assoc :license-url (deserstring (input "licenseUrl"))) (clojure.core/contains? input "versionCode") (clojure.core/assoc :version-code (deserstring (input "versionCode"))) (clojure.core/contains? input "platform") (clojure.core/assoc :platform (deser-instance-platform (input "platform"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deserstring (input "description")))))

(clojure.core/defn- deser-domain [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "domainEntries") (clojure.core/assoc :domain-entries (deser-domain-entry-list (input "domainEntries")))))

(clojure.core/defn- deser-domain-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-domain coll))) input))

(clojure.core/defn- deser-instance-hardware [input] (clojure.core/cond-> {} (clojure.core/contains? input "cpuCount") (clojure.core/assoc :cpu-count (deserinteger (input "cpuCount"))) (clojure.core/contains? input "disks") (clojure.core/assoc :disks (deser-disk-list (input "disks"))) (clojure.core/contains? input "ramSizeInGb") (clojure.core/assoc :ram-size-in-gb (deserfloat (input "ramSizeInGb")))))

(clojure.core/defn- deser-relational-database-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-relational-database-event coll))) input))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-relational-database-endpoint [input] (clojure.core/cond-> {} (clojure.core/contains? input "port") (clojure.core/assoc :port (deserinteger (input "port"))) (clojure.core/contains? input "address") (clojure.core/assoc :address (deser-non-empty-string (input "address")))))

(clojure.core/defn- deser-load-balancer-tls-certificate-renewal-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "renewalStatus") (clojure.core/assoc :renewal-status (deser-load-balancer-tls-certificate-renewal-status (input "renewalStatus"))) (clojure.core/contains? input "domainValidationOptions") (clojure.core/assoc :domain-validation-options (deser-load-balancer-tls-certificate-domain-validation-option-list (input "domainValidationOptions")))))

(clojure.core/defn- deser-relational-database-metric-name [input] (clojure.core/get {"CPUUtilization" :cpu-utilization, "DatabaseConnections" :database-connections, "DiskQueueDepth" :disk-queue-depth, "FreeStorageSpace" :free-storage-space, "NetworkReceiveThroughput" :network-receive-throughput, "NetworkTransmitThroughput" :network-transmit-throughput} input))

(clojure.core/defn- deser-load-balancer-state [input] (clojure.core/get {"active" :active, "provisioning" :provisioning, "active_impaired" :active-impaired, "failed" :failed, "unknown" :unknown} input))

(clojure.core/defn- deser-load-balancer-tls-certificate-status [input] (clojure.core/get {"PENDING_VALIDATION" :pending-validation, "ISSUED" :issued, "INACTIVE" :inactive, "EXPIRED" :expired, "VALIDATION_TIMED_OUT" :validation-timed-out, "REVOKED" :revoked, "FAILED" :failed, "UNKNOWN" :unknown} input))

(clojure.core/defn- deser-export-snapshot-record-source-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-export-snapshot-record-source-type (input "resourceType"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-non-empty-string (input "name"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "fromResourceName") (clojure.core/assoc :from-resource-name (deser-non-empty-string (input "fromResourceName"))) (clojure.core/contains? input "fromResourceArn") (clojure.core/assoc :from-resource-arn (deser-non-empty-string (input "fromResourceArn"))) (clojure.core/contains? input "instanceSnapshotInfo") (clojure.core/assoc :instance-snapshot-info (deser-instance-snapshot-info (input "instanceSnapshotInfo"))) (clojure.core/contains? input "diskSnapshotInfo") (clojure.core/assoc :disk-snapshot-info (deser-disk-snapshot-info (input "diskSnapshotInfo")))))

(clojure.core/defn- deser-cloud-formation-stack-record-source-type [input] (clojure.core/get {"ExportSnapshotRecord" :export-snapshot-record} input))

(clojure.core/defn- deser-ip-v-6-address [input] input)

(clojure.core/defn- deser-relational-database-bundle-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-relational-database-bundle coll))) input))

(clojure.core/defn- deser-pending-maintenance-action-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-pending-maintenance-action coll))) input))

(clojure.core/defn- deser-relational-database-hardware [input] (clojure.core/cond-> {} (clojure.core/contains? input "cpuCount") (clojure.core/assoc :cpu-count (deserinteger (input "cpuCount"))) (clojure.core/contains? input "diskSizeInGb") (clojure.core/assoc :disk-size-in-gb (deserinteger (input "diskSizeInGb"))) (clojure.core/contains? input "ramSizeInGb") (clojure.core/assoc :ram-size-in-gb (deserfloat (input "ramSizeInGb")))))

(clojure.core/defn- deser-disk-snapshot-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "sizeInGb") (clojure.core/assoc :size-in-gb (deserinteger (input "sizeInGb")))))

(clojure.core/defn- deser-instance-port-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "fromPort") (clojure.core/assoc :from-port (deser-port (input "fromPort"))) (clojure.core/contains? input "toPort") (clojure.core/assoc :to-port (deser-port (input "toPort"))) (clojure.core/contains? input "protocol") (clojure.core/assoc :protocol (deser-network-protocol (input "protocol"))) (clojure.core/contains? input "accessFrom") (clojure.core/assoc :access-from (deserstring (input "accessFrom"))) (clojure.core/contains? input "accessType") (clojure.core/assoc :access-type (deser-port-access-type (input "accessType"))) (clojure.core/contains? input "commonName") (clojure.core/assoc :common-name (deserstring (input "commonName"))) (clojure.core/contains? input "accessDirection") (clojure.core/assoc :access-direction (deser-access-direction (input "accessDirection")))))

(clojure.core/defn- deser-relational-database-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "allowedValues") (clojure.core/assoc :allowed-values (deserstring (input "allowedValues"))) (clojure.core/contains? input "applyMethod") (clojure.core/assoc :apply-method (deserstring (input "applyMethod"))) (clojure.core/contains? input "applyType") (clojure.core/assoc :apply-type (deserstring (input "applyType"))) (clojure.core/contains? input "dataType") (clojure.core/assoc :data-type (deserstring (input "dataType"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deserstring (input "description"))) (clojure.core/contains? input "isModifiable") (clojure.core/assoc :is-modifiable (deserboolean (input "isModifiable"))) (clojure.core/contains? input "parameterName") (clojure.core/assoc :parameter-name (deserstring (input "parameterName"))) (clojure.core/contains? input "parameterValue") (clojure.core/assoc :parameter-value (deserstring (input "parameterValue")))))

(clojure.core/defn- deser-tag-value [input] input)

(clojure.core/defn- deser-port [input] input)

(clojure.core/defn- deser-iso-date [input] input)

(clojure.core/defn- deser-disk-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-disk-snapshot coll))) input))

(clojure.core/defn- deser-instance-snapshot-state [input] (clojure.core/get {"pending" :pending, "error" :error, "available" :available} input))

(clojure.core/defn- deser-access-direction [input] (clojure.core/get {"inbound" :inbound, "outbound" :outbound} input))

(clojure.core/defn- deser-load-balancer-tls-certificate-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-load-balancer-tls-certificate coll))) input))

(clojure.core/defn- deser-blueprint-type [input] (clojure.core/get {"os" :os, "app" :app} input))

(clojure.core/defn- deser-load-balancer-configuration-options [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-load-balancer-attribute-name k) (deserstring v)])) input))

(clojure.core/defn- deser-instance-platform [input] (clojure.core/get {"LINUX_UNIX" :linux-unix, "WINDOWS" :windows} input))

(clojure.core/defn- deser-disk-state [input] (clojure.core/get {"pending" :pending, "error" :error, "available" :available, "in-use" :inuse, "unknown" :unknown} input))

(clojure.core/defn- deser-operation-status [input] (clojure.core/get {"NotStarted" :not-started, "Started" :started, "Failed" :failed, "Completed" :completed, "Succeeded" :succeeded} input))

(clojure.core/defn- deser-resource-name [input] input)

(clojure.core/defn- deser-domain-entry-options-keys [input] input)

(clojure.core/defn- deser-relational-database-blueprint [input] (clojure.core/cond-> {} (clojure.core/contains? input "blueprintId") (clojure.core/assoc :blueprint-id (deserstring (input "blueprintId"))) (clojure.core/contains? input "engine") (clojure.core/assoc :engine (deser-relational-database-engine (input "engine"))) (clojure.core/contains? input "engineVersion") (clojure.core/assoc :engine-version (deserstring (input "engineVersion"))) (clojure.core/contains? input "engineDescription") (clojure.core/assoc :engine-description (deserstring (input "engineDescription"))) (clojure.core/contains? input "engineVersionDescription") (clojure.core/assoc :engine-version-description (deserstring (input "engineVersionDescription"))) (clojure.core/contains? input "isEngineDefault") (clojure.core/assoc :is-engine-default (deserboolean (input "isEngineDefault")))))

(clojure.core/defn- deser-export-snapshot-record-source-type [input] (clojure.core/get {"InstanceSnapshot" :instance-snapshot, "DiskSnapshot" :disk-snapshot} input))

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"DiskSnapshot" :disk-snapshot, "PeeredVpc" :peered-vpc, "LoadBalancerTlsCertificate" :load-balancer-tls-certificate, "Domain" :domain, "Disk" :disk, "LoadBalancer" :load-balancer, "StaticIp" :static-ip, "InstanceSnapshot" :instance-snapshot, "KeyPair" :key-pair, "Instance" :instance, "RelationalDatabaseSnapshot" :relational-database-snapshot, "RelationalDatabase" :relational-database, "ExportSnapshotRecord" :export-snapshot-record, "CloudFormationStackRecord" :cloud-formation-stack-record} input))

(clojure.core/defn- deser-log-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-log-event coll))) input))

(clojure.core/defn- deser-load-balancer-tls-certificate-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "isAttached") (clojure.core/assoc :is-attached (deserboolean (input "isAttached")))))

(clojure.core/defn- deserinteger [input] input)

(clojure.core/defn- deser-instance-metric-name [input] (clojure.core/get {"CPUUtilization" :cpu-utilization, "NetworkIn" :network-in, "NetworkOut" :network-out, "StatusCheckFailed" :status-check-failed, "StatusCheckFailed_Instance" :status-check-failed-instance, "StatusCheckFailed_System" :status-check-failed-system} input))

(clojure.core/defn- deser-operation-type [input] (clojure.core/get {"AttachStaticIp" :attach-static-ip, "UpdateRelationalDatabase" :update-relational-database, "StartInstance" :start-instance, "PutInstancePublicPorts" :put-instance-public-ports, "CreateInstancesFromSnapshot" :create-instances-from-snapshot, "RebootInstance" :reboot-instance, "DeleteDomainEntry" :delete-domain-entry, "DeleteRelationalDatabaseSnapshot" :delete-relational-database-snapshot, "DeleteLoadBalancer" :delete-load-balancer, "StopRelationalDatabase" :stop-relational-database, "StopInstance" :stop-instance, "AttachDisk" :attach-disk, "CreateDiskFromSnapshot" :create-disk-from-snapshot, "CreateInstanceSnapshot" :create-instance-snapshot, "UpdateDomainEntry" :update-domain-entry, "CreateRelationalDatabaseSnapshot" :create-relational-database-snapshot, "CreateRelationalDatabase" :create-relational-database, "UpdateRelationalDatabaseParameters" :update-relational-database-parameters, "AllocateStaticIp" :allocate-static-ip, "CreateLoadBalancer" :create-load-balancer, "AttachInstancesToLoadBalancer" :attach-instances-to-load-balancer, "CreateDisk" :create-disk, "UpdateLoadBalancerAttribute" :update-load-balancer-attribute, "RebootRelationalDatabase" :reboot-relational-database, "CreateRelationalDatabaseFromSnapshot" :create-relational-database-from-snapshot, "CreateDomain" :create-domain, "DeleteDisk" :delete-disk, "ReleaseStaticIp" :release-static-ip, "CreateDiskSnapshot" :create-disk-snapshot, "DetachInstancesFromLoadBalancer" :detach-instances-from-load-balancer, "DeleteInstanceSnapshot" :delete-instance-snapshot, "CreateLoadBalancerTlsCertificate" :create-load-balancer-tls-certificate, "DeleteDiskSnapshot" :delete-disk-snapshot, "StartRelationalDatabase" :start-relational-database, "CloseInstancePublicPorts" :close-instance-public-ports, "OpenInstancePublicPorts" :open-instance-public-ports, "AttachLoadBalancerTlsCertificate" :attach-load-balancer-tls-certificate, "DeleteDomain" :delete-domain, "DetachStaticIp" :detach-static-ip, "DeleteInstance" :delete-instance, "DetachDisk" :detach-disk, "DeleteLoadBalancerTlsCertificate" :delete-load-balancer-tls-certificate, "CreateInstance" :create-instance, "DeleteRelationalDatabase" :delete-relational-database} input))

(clojure.core/defn- deser-instance-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance coll))) input))

(clojure.core/defn- deser-relational-database-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-relational-database-snapshot coll))) input))

(clojure.core/defn- deserdouble [input] input)

(clojure.core/defn- deser-load-balancer-protocol [input] (clojure.core/get {"HTTP_HTTPS" :http-https, "HTTP" :http} input))

(clojure.core/defn- deser-disk [input] (clojure.core/cond-> {} (clojure.core/contains? input "isSystemDisk") (clojure.core/assoc :is-system-disk (deserboolean (input "isSystemDisk"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "isAttached") (clojure.core/assoc :is-attached (deserboolean (input "isAttached"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "path") (clojure.core/assoc :path (deserstring (input "path"))) (clojure.core/contains? input "gbInUse") (clojure.core/assoc :gb-in-use (deserinteger (input "gbInUse"))) (clojure.core/contains? input "sizeInGb") (clojure.core/assoc :size-in-gb (deserinteger (input "sizeInGb"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "attachedTo") (clojure.core/assoc :attached-to (deser-resource-name (input "attachedTo"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "iops") (clojure.core/assoc :iops (deserinteger (input "iops"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-disk-state (input "state"))) (clojure.core/contains? input "attachmentState") (clojure.core/assoc :attachment-state (deserstring (input "attachmentState"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType")))))

(clojure.core/defn- deser-ip-address [input] input)

(clojure.core/defn- deser-instance-state [input] (clojure.core/cond-> {} (clojure.core/contains? input "code") (clojure.core/assoc :code (deserinteger (input "code"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deserstring (input "name")))))

(clojure.core/defn- deser-load-balancer [input] (clojure.core/cond-> {} (clojure.core/contains? input "protocol") (clojure.core/assoc :protocol (deser-load-balancer-protocol (input "protocol"))) (clojure.core/contains? input "configurationOptions") (clojure.core/assoc :configuration-options (deser-load-balancer-configuration-options (input "configurationOptions"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "healthCheckPath") (clojure.core/assoc :health-check-path (deser-non-empty-string (input "healthCheckPath"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "instanceHealthSummary") (clojure.core/assoc :instance-health-summary (deser-instance-health-summary-list (input "instanceHealthSummary"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "instancePort") (clojure.core/assoc :instance-port (deserinteger (input "instancePort"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-load-balancer-state (input "state"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "tlsCertificateSummaries") (clojure.core/assoc :tls-certificate-summaries (deser-load-balancer-tls-certificate-summary-list (input "tlsCertificateSummaries"))) (clojure.core/contains? input "publicPorts") (clojure.core/assoc :public-ports (deser-port-list (input "publicPorts"))) (clojure.core/contains? input "dnsName") (clojure.core/assoc :dns-name (deser-non-empty-string (input "dnsName")))))

(clojure.core/defn- deser-disk-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-disk coll))) input))

(clojure.core/defn- deser-load-balancer-tls-certificate-domain-status [input] (clojure.core/get {"PENDING_VALIDATION" :pending-validation, "FAILED" :failed, "SUCCESS" :success} input))

(clojure.core/defn- deser-network-protocol [input] (clojure.core/get {"tcp" :tcp, "all" :all, "udp" :udp} input))

(clojure.core/defn- deser-static-ip [input] (clojure.core/cond-> {} (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "isAttached") (clojure.core/assoc :is-attached (deserboolean (input "isAttached"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "attachedTo") (clojure.core/assoc :attached-to (deser-resource-name (input "attachedTo"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "ipAddress") (clojure.core/assoc :ip-address (deser-ip-address (input "ipAddress")))))

(clojure.core/defn- deser-instance-snapshot [input] (clojure.core/cond-> {} (clojure.core/contains? input "progress") (clojure.core/assoc :progress (deserstring (input "progress"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "fromBlueprintId") (clojure.core/assoc :from-blueprint-id (deserstring (input "fromBlueprintId"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "fromInstanceName") (clojure.core/assoc :from-instance-name (deser-resource-name (input "fromInstanceName"))) (clojure.core/contains? input "sizeInGb") (clojure.core/assoc :size-in-gb (deserinteger (input "sizeInGb"))) (clojure.core/contains? input "fromBundleId") (clojure.core/assoc :from-bundle-id (deserstring (input "fromBundleId"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "fromAttachedDisks") (clojure.core/assoc :from-attached-disks (deser-disk-list (input "fromAttachedDisks"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-instance-snapshot-state (input "state"))) (clojure.core/contains? input "fromInstanceArn") (clojure.core/assoc :from-instance-arn (deser-non-empty-string (input "fromInstanceArn"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType")))))

(clojure.core/defn- deser-key-pair [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "fingerprint") (clojure.core/assoc :fingerprint (deser-base-64 (input "fingerprint")))))

(clojure.core/defn- deser-domain-entry-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-domain-entry coll))) input))

(clojure.core/defn- deser-log-event [input] (clojure.core/cond-> {} (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "message") (clojure.core/assoc :message (deserstring (input "message")))))

(clojure.core/defn- deser-tag [input] (clojure.core/cond-> {} (clojure.core/contains? input "key") (clojure.core/assoc :key (deser-tag-key (input "key"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-tag-value (input "value")))))

(clojure.core/defn- deser-monthly-transfer [input] (clojure.core/cond-> {} (clojure.core/contains? input "gbPerMonthAllocated") (clojure.core/assoc :gb-per-month-allocated (deserinteger (input "gbPerMonthAllocated")))))

(clojure.core/defn- deser-domain-entry-type [input] input)

(clojure.core/defn- deser-cloud-formation-stack-record-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cloud-formation-stack-record coll))) input))

(clojure.core/defn- deser-instance [input] (clojure.core/cond-> {} (clojure.core/contains? input "isStaticIp") (clojure.core/assoc :is-static-ip (deserboolean (input "isStaticIp"))) (clojure.core/contains? input "privateIpAddress") (clojure.core/assoc :private-ip-address (deser-ip-address (input "privateIpAddress"))) (clojure.core/contains? input "sshKeyName") (clojure.core/assoc :ssh-key-name (deser-resource-name (input "sshKeyName"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "blueprintId") (clojure.core/assoc :blueprint-id (deser-non-empty-string (input "blueprintId"))) (clojure.core/contains? input "username") (clojure.core/assoc :username (deser-non-empty-string (input "username"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "ipv6Address") (clojure.core/assoc :ipv-6-address (deser-ip-v-6-address (input "ipv6Address"))) (clojure.core/contains? input "hardware") (clojure.core/assoc :hardware (deser-instance-hardware (input "hardware"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "bundleId") (clojure.core/assoc :bundle-id (deser-non-empty-string (input "bundleId"))) (clojure.core/contains? input "networking") (clojure.core/assoc :networking (deser-instance-networking (input "networking"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-instance-state (input "state"))) (clojure.core/contains? input "blueprintName") (clojure.core/assoc :blueprint-name (deser-non-empty-string (input "blueprintName"))) (clojure.core/contains? input "publicIpAddress") (clojure.core/assoc :public-ip-address (deser-ip-address (input "publicIpAddress"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType")))))

(clojure.core/defn- deser-domain-name [input] input)

(clojure.core/defn- deser-instance-platform-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-platform coll))) input))

(clojure.core/defn- deser-instance-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-snapshot coll))) input))

(clojure.core/defn- deser-relational-database-blueprint-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-relational-database-blueprint coll))) input))

(clojure.core/defn- deser-relational-database-snapshot [input] (clojure.core/cond-> {} (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "fromRelationalDatabaseBlueprintId") (clojure.core/assoc :from-relational-database-blueprint-id (deserstring (input "fromRelationalDatabaseBlueprintId"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "sizeInGb") (clojure.core/assoc :size-in-gb (deserinteger (input "sizeInGb"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "fromRelationalDatabaseName") (clojure.core/assoc :from-relational-database-name (deser-non-empty-string (input "fromRelationalDatabaseName"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "engineVersion") (clojure.core/assoc :engine-version (deser-non-empty-string (input "engineVersion"))) (clojure.core/contains? input "engine") (clojure.core/assoc :engine (deser-non-empty-string (input "engine"))) (clojure.core/contains? input "fromRelationalDatabaseBundleId") (clojure.core/assoc :from-relational-database-bundle-id (deserstring (input "fromRelationalDatabaseBundleId"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-non-empty-string (input "state"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "fromRelationalDatabaseArn") (clojure.core/assoc :from-relational-database-arn (deser-non-empty-string (input "fromRelationalDatabaseArn")))))

(clojure.core/defn- deser-load-balancer-attribute-name [input] (clojure.core/get {"HealthCheckPath" :health-check-path, "SessionStickinessEnabled" :session-stickiness-enabled, "SessionStickiness_LB_CookieDurationSeconds" :session-stickiness-lb-cookie-duration-seconds} input))

(clojure.core/defn- deser-disk-info-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-disk-info coll))) input))

(clojure.core/defn- deser-instance-access-protocol [input] (clojure.core/get {"ssh" :ssh, "rdp" :rdp} input))

(clojure.core/defn- deser-destination-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-non-empty-string (input "id"))) (clojure.core/contains? input "service") (clojure.core/assoc :service (deser-non-empty-string (input "service")))))

(clojure.core/defn- deser-disk-snapshot-state [input] (clojure.core/get {"pending" :pending, "completed" :completed, "error" :error, "unknown" :unknown} input))

(clojure.core/defn- deser-relational-database [input] (clojure.core/cond-> {} (clojure.core/contains? input "pendingModifiedValues") (clojure.core/assoc :pending-modified-values (deser-pending-modified-relational-database-values (input "pendingModifiedValues"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "masterEndpoint") (clojure.core/assoc :master-endpoint (deser-relational-database-endpoint (input "masterEndpoint"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-tag-list (input "tags"))) (clojure.core/contains? input "relationalDatabaseBlueprintId") (clojure.core/assoc :relational-database-blueprint-id (deser-non-empty-string (input "relationalDatabaseBlueprintId"))) (clojure.core/contains? input "secondaryAvailabilityZone") (clojure.core/assoc :secondary-availability-zone (deserstring (input "secondaryAvailabilityZone"))) (clojure.core/contains? input "hardware") (clojure.core/assoc :hardware (deser-relational-database-hardware (input "hardware"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "preferredBackupWindow") (clojure.core/assoc :preferred-backup-window (deser-non-empty-string (input "preferredBackupWindow"))) (clojure.core/contains? input "masterDatabaseName") (clojure.core/assoc :master-database-name (deserstring (input "masterDatabaseName"))) (clojure.core/contains? input "publiclyAccessible") (clojure.core/assoc :publicly-accessible (deserboolean (input "publiclyAccessible"))) (clojure.core/contains? input "masterUsername") (clojure.core/assoc :master-username (deser-non-empty-string (input "masterUsername"))) (clojure.core/contains? input "supportCode") (clojure.core/assoc :support-code (deserstring (input "supportCode"))) (clojure.core/contains? input "engineVersion") (clojure.core/assoc :engine-version (deser-non-empty-string (input "engineVersion"))) (clojure.core/contains? input "engine") (clojure.core/assoc :engine (deser-non-empty-string (input "engine"))) (clojure.core/contains? input "pendingMaintenanceActions") (clojure.core/assoc :pending-maintenance-actions (deser-pending-maintenance-action-list (input "pendingMaintenanceActions"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-non-empty-string (input "state"))) (clojure.core/contains? input "parameterApplyStatus") (clojure.core/assoc :parameter-apply-status (deser-non-empty-string (input "parameterApplyStatus"))) (clojure.core/contains? input "backupRetentionEnabled") (clojure.core/assoc :backup-retention-enabled (deserboolean (input "backupRetentionEnabled"))) (clojure.core/contains? input "relationalDatabaseBundleId") (clojure.core/assoc :relational-database-bundle-id (deser-non-empty-string (input "relationalDatabaseBundleId"))) (clojure.core/contains? input "preferredMaintenanceWindow") (clojure.core/assoc :preferred-maintenance-window (deser-non-empty-string (input "preferredMaintenanceWindow"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "latestRestorableTime") (clojure.core/assoc :latest-restorable-time (deser-iso-date (input "latestRestorableTime")))))

(clojure.core/defn- deser-region [input] (clojure.core/cond-> {} (clojure.core/contains? input "continentCode") (clojure.core/assoc :continent-code (deserstring (input "continentCode"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deserstring (input "description"))) (clojure.core/contains? input "displayName") (clojure.core/assoc :display-name (deserstring (input "displayName"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-region-name (input "name"))) (clojure.core/contains? input "availabilityZones") (clojure.core/assoc :availability-zones (deser-availability-zone-list (input "availabilityZones"))) (clojure.core/contains? input "relationalDatabaseAvailabilityZones") (clojure.core/assoc :relational-database-availability-zones (deser-availability-zone-list (input "relationalDatabaseAvailabilityZones")))))

(clojure.core/defn- deser-instance-health-summary-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-health-summary coll))) input))

(clojure.core/defn- deser-password-data [input] (clojure.core/cond-> {} (clojure.core/contains? input "ciphertext") (clojure.core/assoc :ciphertext (deserstring (input "ciphertext"))) (clojure.core/contains? input "keyPairName") (clojure.core/assoc :key-pair-name (deser-resource-name (input "keyPairName")))))

(clojure.core/defn- deser-instance-port-info-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-port-info coll))) input))

(clojure.core/defn- deser-export-snapshot-record [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-record-state (input "state"))) (clojure.core/contains? input "sourceInfo") (clojure.core/assoc :source-info (deser-export-snapshot-record-source-info (input "sourceInfo"))) (clojure.core/contains? input "destinationInfo") (clojure.core/assoc :destination-info (deser-destination-info (input "destinationInfo")))))

(clojure.core/defn- deser-load-balancer-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-load-balancer coll))) input))

(clojure.core/defn- deser-cloud-formation-stack-record [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-resource-name (input "name"))) (clojure.core/contains? input "arn") (clojure.core/assoc :arn (deser-non-empty-string (input "arn"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-iso-date (input "createdAt"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-resource-location (input "location"))) (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "state") (clojure.core/assoc :state (deser-record-state (input "state"))) (clojure.core/contains? input "sourceInfo") (clojure.core/assoc :source-info (deser-cloud-formation-stack-record-source-info-list (input "sourceInfo"))) (clojure.core/contains? input "destinationInfo") (clojure.core/assoc :destination-info (deser-destination-info (input "destinationInfo")))))

(clojure.core/defn- deser-relational-database-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-relational-database coll))) input))

(clojure.core/defn- deser-domain-entry-options [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-domain-entry-options-keys k) (deserstring v)])) input))

(clojure.core/defn- response-get-relational-database-snapshots-result ([input] (response-get-relational-database-snapshots-result nil input)) ([resultWrapper1883206 input] (clojure.core/let [rawinput1883205 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883207 {"relationalDatabaseSnapshots" (rawinput1883205 "relationalDatabaseSnapshots"), "nextPageToken" (rawinput1883205 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883207 "relationalDatabaseSnapshots") (clojure.core/assoc :relational-database-snapshots (deser-relational-database-snapshot-list (clojure.core/get-in letvar1883207 ["relationalDatabaseSnapshots"]))) (letvar1883207 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883207 ["nextPageToken"])))))))

(clojure.core/defn- response-get-blueprints-result ([input] (response-get-blueprints-result nil input)) ([resultWrapper1883209 input] (clojure.core/let [rawinput1883208 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883210 {"blueprints" (rawinput1883208 "blueprints"), "nextPageToken" (rawinput1883208 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883210 "blueprints") (clojure.core/assoc :blueprints (deser-blueprint-list (clojure.core/get-in letvar1883210 ["blueprints"]))) (letvar1883210 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883210 ["nextPageToken"])))))))

(clojure.core/defn- response-download-default-key-pair-result ([input] (response-download-default-key-pair-result nil input)) ([resultWrapper1883212 input] (clojure.core/let [rawinput1883211 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883213 {"publicKeyBase64" (rawinput1883211 "publicKeyBase64"), "privateKeyBase64" (rawinput1883211 "privateKeyBase64")}] (clojure.core/cond-> {} (letvar1883213 "publicKeyBase64") (clojure.core/assoc :public-key-base-64 (deser-base-64 (clojure.core/get-in letvar1883213 ["publicKeyBase64"]))) (letvar1883213 "privateKeyBase64") (clojure.core/assoc :private-key-base-64 (deser-base-64 (clojure.core/get-in letvar1883213 ["privateKeyBase64"])))))))

(clojure.core/defn- response-get-operation-result ([input] (response-get-operation-result nil input)) ([resultWrapper1883215 input] (clojure.core/let [rawinput1883214 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883216 {"operation" (rawinput1883214 "operation")}] (clojure.core/cond-> {} (letvar1883216 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883216 ["operation"])))))))

(clojure.core/defn- response-get-domain-result ([input] (response-get-domain-result nil input)) ([resultWrapper1883218 input] (clojure.core/let [rawinput1883217 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883219 {"domain" (rawinput1883217 "domain")}] (clojure.core/cond-> {} (letvar1883219 "domain") (clojure.core/assoc :domain (deser-domain (clojure.core/get-in letvar1883219 ["domain"])))))))

(clojure.core/defn- response-get-relational-database-log-streams-result ([input] (response-get-relational-database-log-streams-result nil input)) ([resultWrapper1883221 input] (clojure.core/let [rawinput1883220 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883222 {"logStreams" (rawinput1883220 "logStreams")}] (clojure.core/cond-> {} (letvar1883222 "logStreams") (clojure.core/assoc :log-streams (deser-string-list (clojure.core/get-in letvar1883222 ["logStreams"])))))))

(clojure.core/defn- response-delete-domain-result ([input] (response-delete-domain-result nil input)) ([resultWrapper1883224 input] (clojure.core/let [rawinput1883223 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883225 {"operation" (rawinput1883223 "operation")}] (clojure.core/cond-> {} (letvar1883225 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883225 ["operation"])))))))

(clojure.core/defn- response-get-static-ip-result ([input] (response-get-static-ip-result nil input)) ([resultWrapper1883227 input] (clojure.core/let [rawinput1883226 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883228 {"staticIp" (rawinput1883226 "staticIp")}] (clojure.core/cond-> {} (letvar1883228 "staticIp") (clojure.core/assoc :static-ip (deser-static-ip (clojure.core/get-in letvar1883228 ["staticIp"])))))))

(clojure.core/defn- response-create-disk-result ([input] (response-create-disk-result nil input)) ([resultWrapper1883230 input] (clojure.core/let [rawinput1883229 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883231 {"operations" (rawinput1883229 "operations")}] (clojure.core/cond-> {} (letvar1883231 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883231 ["operations"])))))))

(clojure.core/defn- response-get-disks-result ([input] (response-get-disks-result nil input)) ([resultWrapper1883233 input] (clojure.core/let [rawinput1883232 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883234 {"disks" (rawinput1883232 "disks"), "nextPageToken" (rawinput1883232 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883234 "disks") (clojure.core/assoc :disks (deser-disk-list (clojure.core/get-in letvar1883234 ["disks"]))) (letvar1883234 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883234 ["nextPageToken"])))))))

(clojure.core/defn- response-detach-disk-result ([input] (response-detach-disk-result nil input)) ([resultWrapper1883236 input] (clojure.core/let [rawinput1883235 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883237 {"operations" (rawinput1883235 "operations")}] (clojure.core/cond-> {} (letvar1883237 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883237 ["operations"])))))))

(clojure.core/defn- response-delete-load-balancer-result ([input] (response-delete-load-balancer-result nil input)) ([resultWrapper1883239 input] (clojure.core/let [rawinput1883238 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883240 {"operations" (rawinput1883238 "operations")}] (clojure.core/cond-> {} (letvar1883240 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883240 ["operations"])))))))

(clojure.core/defn- response-attach-load-balancer-tls-certificate-result ([input] (response-attach-load-balancer-tls-certificate-result nil input)) ([resultWrapper1883242 input] (clojure.core/let [rawinput1883241 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883243 {"operations" (rawinput1883241 "operations")}] (clojure.core/cond-> {} (letvar1883243 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883243 ["operations"])))))))

(clojure.core/defn- response-get-bundles-result ([input] (response-get-bundles-result nil input)) ([resultWrapper1883245 input] (clojure.core/let [rawinput1883244 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883246 {"bundles" (rawinput1883244 "bundles"), "nextPageToken" (rawinput1883244 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883246 "bundles") (clojure.core/assoc :bundles (deser-bundle-list (clojure.core/get-in letvar1883246 ["bundles"]))) (letvar1883246 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883246 ["nextPageToken"])))))))

(clojure.core/defn- response-delete-instance-result ([input] (response-delete-instance-result nil input)) ([resultWrapper1883248 input] (clojure.core/let [rawinput1883247 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883249 {"operations" (rawinput1883247 "operations")}] (clojure.core/cond-> {} (letvar1883249 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883249 ["operations"])))))))

(clojure.core/defn- response-get-export-snapshot-records-result ([input] (response-get-export-snapshot-records-result nil input)) ([resultWrapper1883251 input] (clojure.core/let [rawinput1883250 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883252 {"exportSnapshotRecords" (rawinput1883250 "exportSnapshotRecords"), "nextPageToken" (rawinput1883250 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883252 "exportSnapshotRecords") (clojure.core/assoc :export-snapshot-records (deser-export-snapshot-record-list (clojure.core/get-in letvar1883252 ["exportSnapshotRecords"]))) (letvar1883252 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883252 ["nextPageToken"])))))))

(clojure.core/defn- response-create-key-pair-result ([input] (response-create-key-pair-result nil input)) ([resultWrapper1883254 input] (clojure.core/let [rawinput1883253 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883255 {"keyPair" (rawinput1883253 "keyPair"), "publicKeyBase64" (rawinput1883253 "publicKeyBase64"), "privateKeyBase64" (rawinput1883253 "privateKeyBase64"), "operation" (rawinput1883253 "operation")}] (clojure.core/cond-> {} (letvar1883255 "keyPair") (clojure.core/assoc :key-pair (deser-key-pair (clojure.core/get-in letvar1883255 ["keyPair"]))) (letvar1883255 "publicKeyBase64") (clojure.core/assoc :public-key-base-64 (deser-base-64 (clojure.core/get-in letvar1883255 ["publicKeyBase64"]))) (letvar1883255 "privateKeyBase64") (clojure.core/assoc :private-key-base-64 (deser-base-64 (clojure.core/get-in letvar1883255 ["privateKeyBase64"]))) (letvar1883255 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883255 ["operation"])))))))

(clojure.core/defn- response-detach-static-ip-result ([input] (response-detach-static-ip-result nil input)) ([resultWrapper1883257 input] (clojure.core/let [rawinput1883256 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883258 {"operations" (rawinput1883256 "operations")}] (clojure.core/cond-> {} (letvar1883258 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883258 ["operations"])))))))

(clojure.core/defn- response-get-key-pair-result ([input] (response-get-key-pair-result nil input)) ([resultWrapper1883260 input] (clojure.core/let [rawinput1883259 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883261 {"keyPair" (rawinput1883259 "keyPair")}] (clojure.core/cond-> {} (letvar1883261 "keyPair") (clojure.core/assoc :key-pair (deser-key-pair (clojure.core/get-in letvar1883261 ["keyPair"])))))))

(clojure.core/defn- response-create-load-balancer-result ([input] (response-create-load-balancer-result nil input)) ([resultWrapper1883263 input] (clojure.core/let [rawinput1883262 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883264 {"operations" (rawinput1883262 "operations")}] (clojure.core/cond-> {} (letvar1883264 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883264 ["operations"])))))))

(clojure.core/defn- response-peer-vpc-result ([input] (response-peer-vpc-result nil input)) ([resultWrapper1883266 input] (clojure.core/let [rawinput1883265 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883267 {"operation" (rawinput1883265 "operation")}] (clojure.core/cond-> {} (letvar1883267 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883267 ["operation"])))))))

(clojure.core/defn- response-delete-disk-snapshot-result ([input] (response-delete-disk-snapshot-result nil input)) ([resultWrapper1883269 input] (clojure.core/let [rawinput1883268 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883270 {"operations" (rawinput1883268 "operations")}] (clojure.core/cond-> {} (letvar1883270 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883270 ["operations"])))))))

(clojure.core/defn- response-update-load-balancer-attribute-result ([input] (response-update-load-balancer-attribute-result nil input)) ([resultWrapper1883272 input] (clojure.core/let [rawinput1883271 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883273 {"operations" (rawinput1883271 "operations")}] (clojure.core/cond-> {} (letvar1883273 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883273 ["operations"])))))))

(clojure.core/defn- response-get-load-balancer-tls-certificates-result ([input] (response-get-load-balancer-tls-certificates-result nil input)) ([resultWrapper1883275 input] (clojure.core/let [rawinput1883274 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883276 {"tlsCertificates" (rawinput1883274 "tlsCertificates")}] (clojure.core/cond-> {} (letvar1883276 "tlsCertificates") (clojure.core/assoc :tls-certificates (deser-load-balancer-tls-certificate-list (clojure.core/get-in letvar1883276 ["tlsCertificates"])))))))

(clojure.core/defn- response-get-relational-database-master-user-password-result ([input] (response-get-relational-database-master-user-password-result nil input)) ([resultWrapper1883278 input] (clojure.core/let [rawinput1883277 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883279 {"masterUserPassword" (rawinput1883277 "masterUserPassword"), "createdAt" (rawinput1883277 "createdAt")}] (clojure.core/cond-> {} (letvar1883279 "masterUserPassword") (clojure.core/assoc :master-user-password (deser-sensitive-string (clojure.core/get-in letvar1883279 ["masterUserPassword"]))) (letvar1883279 "createdAt") (clojure.core/assoc :created-at (deser-iso-date (clojure.core/get-in letvar1883279 ["createdAt"])))))))

(clojure.core/defn- response-service-exception ([input] (response-service-exception nil input)) ([resultWrapper1883281 input] (clojure.core/let [rawinput1883280 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883282 {"code" (rawinput1883280 "code"), "docs" (rawinput1883280 "docs"), "message" (rawinput1883280 "message"), "tip" (rawinput1883280 "tip")}] (clojure.core/cond-> {} (letvar1883282 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883282 ["code"]))) (letvar1883282 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883282 ["docs"]))) (letvar1883282 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883282 ["message"]))) (letvar1883282 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883282 ["tip"])))))))

(clojure.core/defn- response-get-load-balancer-metric-data-result ([input] (response-get-load-balancer-metric-data-result nil input)) ([resultWrapper1883284 input] (clojure.core/let [rawinput1883283 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883285 {"metricName" (rawinput1883283 "metricName"), "metricData" (rawinput1883283 "metricData")}] (clojure.core/cond-> {} (letvar1883285 "metricName") (clojure.core/assoc :metric-name (deser-load-balancer-metric-name (clojure.core/get-in letvar1883285 ["metricName"]))) (letvar1883285 "metricData") (clojure.core/assoc :metric-data (deser-metric-datapoint-list (clojure.core/get-in letvar1883285 ["metricData"])))))))

(clojure.core/defn- response-delete-load-balancer-tls-certificate-result ([input] (response-delete-load-balancer-tls-certificate-result nil input)) ([resultWrapper1883287 input] (clojure.core/let [rawinput1883286 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883288 {"operations" (rawinput1883286 "operations")}] (clojure.core/cond-> {} (letvar1883288 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883288 ["operations"])))))))

(clojure.core/defn- response-update-relational-database-result ([input] (response-update-relational-database-result nil input)) ([resultWrapper1883290 input] (clojure.core/let [rawinput1883289 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883291 {"operations" (rawinput1883289 "operations")}] (clojure.core/cond-> {} (letvar1883291 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883291 ["operations"])))))))

(clojure.core/defn- response-create-relational-database-result ([input] (response-create-relational-database-result nil input)) ([resultWrapper1883293 input] (clojure.core/let [rawinput1883292 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883294 {"operations" (rawinput1883292 "operations")}] (clojure.core/cond-> {} (letvar1883294 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883294 ["operations"])))))))

(clojure.core/defn- response-delete-instance-snapshot-result ([input] (response-delete-instance-snapshot-result nil input)) ([resultWrapper1883296 input] (clojure.core/let [rawinput1883295 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883297 {"operations" (rawinput1883295 "operations")}] (clojure.core/cond-> {} (letvar1883297 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883297 ["operations"])))))))

(clojure.core/defn- response-import-key-pair-result ([input] (response-import-key-pair-result nil input)) ([resultWrapper1883299 input] (clojure.core/let [rawinput1883298 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883300 {"operation" (rawinput1883298 "operation")}] (clojure.core/cond-> {} (letvar1883300 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883300 ["operation"])))))))

(clojure.core/defn- response-unpeer-vpc-result ([input] (response-unpeer-vpc-result nil input)) ([resultWrapper1883302 input] (clojure.core/let [rawinput1883301 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883303 {"operation" (rawinput1883301 "operation")}] (clojure.core/cond-> {} (letvar1883303 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883303 ["operation"])))))))

(clojure.core/defn- response-get-disk-result ([input] (response-get-disk-result nil input)) ([resultWrapper1883305 input] (clojure.core/let [rawinput1883304 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883306 {"disk" (rawinput1883304 "disk")}] (clojure.core/cond-> {} (letvar1883306 "disk") (clojure.core/assoc :disk (deser-disk (clojure.core/get-in letvar1883306 ["disk"])))))))

(clojure.core/defn- response-delete-domain-entry-result ([input] (response-delete-domain-entry-result nil input)) ([resultWrapper1883308 input] (clojure.core/let [rawinput1883307 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883309 {"operation" (rawinput1883307 "operation")}] (clojure.core/cond-> {} (letvar1883309 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883309 ["operation"])))))))

(clojure.core/defn- response-create-relational-database-snapshot-result ([input] (response-create-relational-database-snapshot-result nil input)) ([resultWrapper1883311 input] (clojure.core/let [rawinput1883310 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883312 {"operations" (rawinput1883310 "operations")}] (clojure.core/cond-> {} (letvar1883312 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883312 ["operations"])))))))

(clojure.core/defn- response-release-static-ip-result ([input] (response-release-static-ip-result nil input)) ([resultWrapper1883314 input] (clojure.core/let [rawinput1883313 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883315 {"operations" (rawinput1883313 "operations")}] (clojure.core/cond-> {} (letvar1883315 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883315 ["operations"])))))))

(clojure.core/defn- response-create-domain-result ([input] (response-create-domain-result nil input)) ([resultWrapper1883317 input] (clojure.core/let [rawinput1883316 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883318 {"operation" (rawinput1883316 "operation")}] (clojure.core/cond-> {} (letvar1883318 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883318 ["operation"])))))))

(clojure.core/defn- response-get-operations-for-resource-result ([input] (response-get-operations-for-resource-result nil input)) ([resultWrapper1883320 input] (clojure.core/let [rawinput1883319 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883321 {"operations" (rawinput1883319 "operations"), "nextPageCount" (rawinput1883319 "nextPageCount"), "nextPageToken" (rawinput1883319 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883321 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883321 ["operations"]))) (letvar1883321 "nextPageCount") (clojure.core/assoc :next-page-count (deserstring (clojure.core/get-in letvar1883321 ["nextPageCount"]))) (letvar1883321 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883321 ["nextPageToken"])))))))

(clojure.core/defn- response-get-instance-snapshots-result ([input] (response-get-instance-snapshots-result nil input)) ([resultWrapper1883323 input] (clojure.core/let [rawinput1883322 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883324 {"instanceSnapshots" (rawinput1883322 "instanceSnapshots"), "nextPageToken" (rawinput1883322 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883324 "instanceSnapshots") (clojure.core/assoc :instance-snapshots (deser-instance-snapshot-list (clojure.core/get-in letvar1883324 ["instanceSnapshots"]))) (letvar1883324 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883324 ["nextPageToken"])))))))

(clojure.core/defn- response-update-domain-entry-result ([input] (response-update-domain-entry-result nil input)) ([resultWrapper1883326 input] (clojure.core/let [rawinput1883325 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883327 {"operations" (rawinput1883325 "operations")}] (clojure.core/cond-> {} (letvar1883327 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883327 ["operations"])))))))

(clojure.core/defn- response-create-disk-from-snapshot-result ([input] (response-create-disk-from-snapshot-result nil input)) ([resultWrapper1883329 input] (clojure.core/let [rawinput1883328 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883330 {"operations" (rawinput1883328 "operations")}] (clojure.core/cond-> {} (letvar1883330 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883330 ["operations"])))))))

(clojure.core/defn- response-attach-static-ip-result ([input] (response-attach-static-ip-result nil input)) ([resultWrapper1883332 input] (clojure.core/let [rawinput1883331 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883333 {"operations" (rawinput1883331 "operations")}] (clojure.core/cond-> {} (letvar1883333 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883333 ["operations"])))))))

(clojure.core/defn- response-open-instance-public-ports-result ([input] (response-open-instance-public-ports-result nil input)) ([resultWrapper1883335 input] (clojure.core/let [rawinput1883334 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883336 {"operation" (rawinput1883334 "operation")}] (clojure.core/cond-> {} (letvar1883336 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883336 ["operation"])))))))

(clojure.core/defn- response-create-domain-entry-result ([input] (response-create-domain-entry-result nil input)) ([resultWrapper1883338 input] (clojure.core/let [rawinput1883337 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883339 {"operation" (rawinput1883337 "operation")}] (clojure.core/cond-> {} (letvar1883339 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883339 ["operation"])))))))

(clojure.core/defn- response-get-instance-port-states-result ([input] (response-get-instance-port-states-result nil input)) ([resultWrapper1883341 input] (clojure.core/let [rawinput1883340 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883342 {"portStates" (rawinput1883340 "portStates")}] (clojure.core/cond-> {} (letvar1883342 "portStates") (clojure.core/assoc :port-states (deser-instance-port-state-list (clojure.core/get-in letvar1883342 ["portStates"])))))))

(clojure.core/defn- response-delete-disk-result ([input] (response-delete-disk-result nil input)) ([resultWrapper1883344 input] (clojure.core/let [rawinput1883343 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883345 {"operations" (rawinput1883343 "operations")}] (clojure.core/cond-> {} (letvar1883345 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883345 ["operations"])))))))

(clojure.core/defn- response-get-domains-result ([input] (response-get-domains-result nil input)) ([resultWrapper1883347 input] (clojure.core/let [rawinput1883346 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883348 {"domains" (rawinput1883346 "domains"), "nextPageToken" (rawinput1883346 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883348 "domains") (clojure.core/assoc :domains (deser-domain-list (clojure.core/get-in letvar1883348 ["domains"]))) (letvar1883348 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883348 ["nextPageToken"])))))))

(clojure.core/defn- response-get-relational-database-snapshot-result ([input] (response-get-relational-database-snapshot-result nil input)) ([resultWrapper1883350 input] (clojure.core/let [rawinput1883349 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883351 {"relationalDatabaseSnapshot" (rawinput1883349 "relationalDatabaseSnapshot")}] (clojure.core/cond-> {} (letvar1883351 "relationalDatabaseSnapshot") (clojure.core/assoc :relational-database-snapshot (deser-relational-database-snapshot (clojure.core/get-in letvar1883351 ["relationalDatabaseSnapshot"])))))))

(clojure.core/defn- response-delete-relational-database-result ([input] (response-delete-relational-database-result nil input)) ([resultWrapper1883353 input] (clojure.core/let [rawinput1883352 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883354 {"operations" (rawinput1883352 "operations")}] (clojure.core/cond-> {} (letvar1883354 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883354 ["operations"])))))))

(clojure.core/defn- response-get-disk-snapshot-result ([input] (response-get-disk-snapshot-result nil input)) ([resultWrapper1883356 input] (clojure.core/let [rawinput1883355 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883357 {"diskSnapshot" (rawinput1883355 "diskSnapshot")}] (clojure.core/cond-> {} (letvar1883357 "diskSnapshot") (clojure.core/assoc :disk-snapshot (deser-disk-snapshot (clojure.core/get-in letvar1883357 ["diskSnapshot"])))))))

(clojure.core/defn- response-stop-relational-database-result ([input] (response-stop-relational-database-result nil input)) ([resultWrapper1883359 input] (clojure.core/let [rawinput1883358 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883360 {"operations" (rawinput1883358 "operations")}] (clojure.core/cond-> {} (letvar1883360 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883360 ["operations"])))))))

(clojure.core/defn- response-get-instance-snapshot-result ([input] (response-get-instance-snapshot-result nil input)) ([resultWrapper1883362 input] (clojure.core/let [rawinput1883361 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883363 {"instanceSnapshot" (rawinput1883361 "instanceSnapshot")}] (clojure.core/cond-> {} (letvar1883363 "instanceSnapshot") (clojure.core/assoc :instance-snapshot (deser-instance-snapshot (clojure.core/get-in letvar1883363 ["instanceSnapshot"])))))))

(clojure.core/defn- response-get-relational-database-events-result ([input] (response-get-relational-database-events-result nil input)) ([resultWrapper1883365 input] (clojure.core/let [rawinput1883364 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883366 {"relationalDatabaseEvents" (rawinput1883364 "relationalDatabaseEvents"), "nextPageToken" (rawinput1883364 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883366 "relationalDatabaseEvents") (clojure.core/assoc :relational-database-events (deser-relational-database-event-list (clojure.core/get-in letvar1883366 ["relationalDatabaseEvents"]))) (letvar1883366 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883366 ["nextPageToken"])))))))

(clojure.core/defn- response-get-relational-database-bundles-result ([input] (response-get-relational-database-bundles-result nil input)) ([resultWrapper1883368 input] (clojure.core/let [rawinput1883367 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883369 {"bundles" (rawinput1883367 "bundles"), "nextPageToken" (rawinput1883367 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883369 "bundles") (clojure.core/assoc :bundles (deser-relational-database-bundle-list (clojure.core/get-in letvar1883369 ["bundles"]))) (letvar1883369 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883369 ["nextPageToken"])))))))

(clojure.core/defn- response-invalid-input-exception ([input] (response-invalid-input-exception nil input)) ([resultWrapper1883371 input] (clojure.core/let [rawinput1883370 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883372 {"code" (rawinput1883370 "code"), "docs" (rawinput1883370 "docs"), "message" (rawinput1883370 "message"), "tip" (rawinput1883370 "tip")}] (clojure.core/cond-> {} (letvar1883372 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883372 ["code"]))) (letvar1883372 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883372 ["docs"]))) (letvar1883372 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883372 ["message"]))) (letvar1883372 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883372 ["tip"])))))))

(clojure.core/defn- response-get-key-pairs-result ([input] (response-get-key-pairs-result nil input)) ([resultWrapper1883374 input] (clojure.core/let [rawinput1883373 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883375 {"keyPairs" (rawinput1883373 "keyPairs"), "nextPageToken" (rawinput1883373 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883375 "keyPairs") (clojure.core/assoc :key-pairs (deser-key-pair-list (clojure.core/get-in letvar1883375 ["keyPairs"]))) (letvar1883375 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883375 ["nextPageToken"])))))))

(clojure.core/defn- response-create-load-balancer-tls-certificate-result ([input] (response-create-load-balancer-tls-certificate-result nil input)) ([resultWrapper1883377 input] (clojure.core/let [rawinput1883376 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883378 {"operations" (rawinput1883376 "operations")}] (clojure.core/cond-> {} (letvar1883378 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883378 ["operations"])))))))

(clojure.core/defn- response-get-static-ips-result ([input] (response-get-static-ips-result nil input)) ([resultWrapper1883380 input] (clojure.core/let [rawinput1883379 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883381 {"staticIps" (rawinput1883379 "staticIps"), "nextPageToken" (rawinput1883379 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883381 "staticIps") (clojure.core/assoc :static-ips (deser-static-ip-list (clojure.core/get-in letvar1883381 ["staticIps"]))) (letvar1883381 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883381 ["nextPageToken"])))))))

(clojure.core/defn- response-not-found-exception ([input] (response-not-found-exception nil input)) ([resultWrapper1883383 input] (clojure.core/let [rawinput1883382 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883384 {"code" (rawinput1883382 "code"), "docs" (rawinput1883382 "docs"), "message" (rawinput1883382 "message"), "tip" (rawinput1883382 "tip")}] (clojure.core/cond-> {} (letvar1883384 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883384 ["code"]))) (letvar1883384 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883384 ["docs"]))) (letvar1883384 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883384 ["message"]))) (letvar1883384 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883384 ["tip"])))))))

(clojure.core/defn- response-get-instance-state-result ([input] (response-get-instance-state-result nil input)) ([resultWrapper1883386 input] (clojure.core/let [rawinput1883385 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883387 {"state" (rawinput1883385 "state")}] (clojure.core/cond-> {} (letvar1883387 "state") (clojure.core/assoc :state (deser-instance-state (clojure.core/get-in letvar1883387 ["state"])))))))

(clojure.core/defn- response-access-denied-exception ([input] (response-access-denied-exception nil input)) ([resultWrapper1883389 input] (clojure.core/let [rawinput1883388 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883390 {"code" (rawinput1883388 "code"), "docs" (rawinput1883388 "docs"), "message" (rawinput1883388 "message"), "tip" (rawinput1883388 "tip")}] (clojure.core/cond-> {} (letvar1883390 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883390 ["code"]))) (letvar1883390 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883390 ["docs"]))) (letvar1883390 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883390 ["message"]))) (letvar1883390 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883390 ["tip"])))))))

(clojure.core/defn- response-get-relational-database-metric-data-result ([input] (response-get-relational-database-metric-data-result nil input)) ([resultWrapper1883392 input] (clojure.core/let [rawinput1883391 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883393 {"metricName" (rawinput1883391 "metricName"), "metricData" (rawinput1883391 "metricData")}] (clojure.core/cond-> {} (letvar1883393 "metricName") (clojure.core/assoc :metric-name (deser-relational-database-metric-name (clojure.core/get-in letvar1883393 ["metricName"]))) (letvar1883393 "metricData") (clojure.core/assoc :metric-data (deser-metric-datapoint-list (clojure.core/get-in letvar1883393 ["metricData"])))))))

(clojure.core/defn- response-get-relational-databases-result ([input] (response-get-relational-databases-result nil input)) ([resultWrapper1883395 input] (clojure.core/let [rawinput1883394 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883396 {"relationalDatabases" (rawinput1883394 "relationalDatabases"), "nextPageToken" (rawinput1883394 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883396 "relationalDatabases") (clojure.core/assoc :relational-databases (deser-relational-database-list (clojure.core/get-in letvar1883396 ["relationalDatabases"]))) (letvar1883396 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883396 ["nextPageToken"])))))))

(clojure.core/defn- response-untag-resource-result ([input] (response-untag-resource-result nil input)) ([resultWrapper1883398 input] (clojure.core/let [rawinput1883397 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883399 {"operations" (rawinput1883397 "operations")}] (clojure.core/cond-> {} (letvar1883399 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883399 ["operations"])))))))

(clojure.core/defn- response-get-relational-database-blueprints-result ([input] (response-get-relational-database-blueprints-result nil input)) ([resultWrapper1883401 input] (clojure.core/let [rawinput1883400 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883402 {"blueprints" (rawinput1883400 "blueprints"), "nextPageToken" (rawinput1883400 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883402 "blueprints") (clojure.core/assoc :blueprints (deser-relational-database-blueprint-list (clojure.core/get-in letvar1883402 ["blueprints"]))) (letvar1883402 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883402 ["nextPageToken"])))))))

(clojure.core/defn- response-close-instance-public-ports-result ([input] (response-close-instance-public-ports-result nil input)) ([resultWrapper1883404 input] (clojure.core/let [rawinput1883403 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883405 {"operation" (rawinput1883403 "operation")}] (clojure.core/cond-> {} (letvar1883405 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883405 ["operation"])))))))

(clojure.core/defn- response-get-cloud-formation-stack-records-result ([input] (response-get-cloud-formation-stack-records-result nil input)) ([resultWrapper1883407 input] (clojure.core/let [rawinput1883406 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883408 {"cloudFormationStackRecords" (rawinput1883406 "cloudFormationStackRecords"), "nextPageToken" (rawinput1883406 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883408 "cloudFormationStackRecords") (clojure.core/assoc :cloud-formation-stack-records (deser-cloud-formation-stack-record-list (clojure.core/get-in letvar1883408 ["cloudFormationStackRecords"]))) (letvar1883408 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883408 ["nextPageToken"])))))))

(clojure.core/defn- response-get-disk-snapshots-result ([input] (response-get-disk-snapshots-result nil input)) ([resultWrapper1883410 input] (clojure.core/let [rawinput1883409 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883411 {"diskSnapshots" (rawinput1883409 "diskSnapshots"), "nextPageToken" (rawinput1883409 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883411 "diskSnapshots") (clojure.core/assoc :disk-snapshots (deser-disk-snapshot-list (clojure.core/get-in letvar1883411 ["diskSnapshots"]))) (letvar1883411 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883411 ["nextPageToken"])))))))

(clojure.core/defn- response-create-instances-from-snapshot-result ([input] (response-create-instances-from-snapshot-result nil input)) ([resultWrapper1883413 input] (clojure.core/let [rawinput1883412 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883414 {"operations" (rawinput1883412 "operations")}] (clojure.core/cond-> {} (letvar1883414 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883414 ["operations"])))))))

(clojure.core/defn- response-get-relational-database-parameters-result ([input] (response-get-relational-database-parameters-result nil input)) ([resultWrapper1883416 input] (clojure.core/let [rawinput1883415 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883417 {"parameters" (rawinput1883415 "parameters"), "nextPageToken" (rawinput1883415 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883417 "parameters") (clojure.core/assoc :parameters (deser-relational-database-parameter-list (clojure.core/get-in letvar1883417 ["parameters"]))) (letvar1883417 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883417 ["nextPageToken"])))))))

(clojure.core/defn- response-attach-disk-result ([input] (response-attach-disk-result nil input)) ([resultWrapper1883419 input] (clojure.core/let [rawinput1883418 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883420 {"operations" (rawinput1883418 "operations")}] (clojure.core/cond-> {} (letvar1883420 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883420 ["operations"])))))))

(clojure.core/defn- response-create-disk-snapshot-result ([input] (response-create-disk-snapshot-result nil input)) ([resultWrapper1883422 input] (clojure.core/let [rawinput1883421 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883423 {"operations" (rawinput1883421 "operations")}] (clojure.core/cond-> {} (letvar1883423 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883423 ["operations"])))))))

(clojure.core/defn- response-create-instances-result ([input] (response-create-instances-result nil input)) ([resultWrapper1883425 input] (clojure.core/let [rawinput1883424 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883426 {"operations" (rawinput1883424 "operations")}] (clojure.core/cond-> {} (letvar1883426 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883426 ["operations"])))))))

(clojure.core/defn- response-is-vpc-peered-result ([input] (response-is-vpc-peered-result nil input)) ([resultWrapper1883428 input] (clojure.core/let [rawinput1883427 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883429 {"isPeered" (rawinput1883427 "isPeered")}] (clojure.core/cond-> {} (letvar1883429 "isPeered") (clojure.core/assoc :is-peered (deserboolean (clojure.core/get-in letvar1883429 ["isPeered"])))))))

(clojure.core/defn- response-get-instances-result ([input] (response-get-instances-result nil input)) ([resultWrapper1883431 input] (clojure.core/let [rawinput1883430 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883432 {"instances" (rawinput1883430 "instances"), "nextPageToken" (rawinput1883430 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883432 "instances") (clojure.core/assoc :instances (deser-instance-list (clojure.core/get-in letvar1883432 ["instances"]))) (letvar1883432 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883432 ["nextPageToken"])))))))

(clojure.core/defn- response-reboot-relational-database-result ([input] (response-reboot-relational-database-result nil input)) ([resultWrapper1883434 input] (clojure.core/let [rawinput1883433 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883435 {"operations" (rawinput1883433 "operations")}] (clojure.core/cond-> {} (letvar1883435 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883435 ["operations"])))))))

(clojure.core/defn- response-copy-snapshot-result ([input] (response-copy-snapshot-result nil input)) ([resultWrapper1883437 input] (clojure.core/let [rawinput1883436 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883438 {"operations" (rawinput1883436 "operations")}] (clojure.core/cond-> {} (letvar1883438 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883438 ["operations"])))))))

(clojure.core/defn- response-get-instance-result ([input] (response-get-instance-result nil input)) ([resultWrapper1883440 input] (clojure.core/let [rawinput1883439 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883441 {"instance" (rawinput1883439 "instance")}] (clojure.core/cond-> {} (letvar1883441 "instance") (clojure.core/assoc :instance (deser-instance (clojure.core/get-in letvar1883441 ["instance"])))))))

(clojure.core/defn- response-export-snapshot-result ([input] (response-export-snapshot-result nil input)) ([resultWrapper1883443 input] (clojure.core/let [rawinput1883442 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883444 {"operations" (rawinput1883442 "operations")}] (clojure.core/cond-> {} (letvar1883444 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883444 ["operations"])))))))

(clojure.core/defn- response-stop-instance-result ([input] (response-stop-instance-result nil input)) ([resultWrapper1883446 input] (clojure.core/let [rawinput1883445 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883447 {"operations" (rawinput1883445 "operations")}] (clojure.core/cond-> {} (letvar1883447 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883447 ["operations"])))))))

(clojure.core/defn- response-get-load-balancer-result ([input] (response-get-load-balancer-result nil input)) ([resultWrapper1883449 input] (clojure.core/let [rawinput1883448 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883450 {"loadBalancer" (rawinput1883448 "loadBalancer")}] (clojure.core/cond-> {} (letvar1883450 "loadBalancer") (clojure.core/assoc :load-balancer (deser-load-balancer (clojure.core/get-in letvar1883450 ["loadBalancer"])))))))

(clojure.core/defn- response-get-load-balancers-result ([input] (response-get-load-balancers-result nil input)) ([resultWrapper1883452 input] (clojure.core/let [rawinput1883451 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883453 {"loadBalancers" (rawinput1883451 "loadBalancers"), "nextPageToken" (rawinput1883451 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883453 "loadBalancers") (clojure.core/assoc :load-balancers (deser-load-balancer-list (clojure.core/get-in letvar1883453 ["loadBalancers"]))) (letvar1883453 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883453 ["nextPageToken"])))))))

(clojure.core/defn- response-reboot-instance-result ([input] (response-reboot-instance-result nil input)) ([resultWrapper1883455 input] (clojure.core/let [rawinput1883454 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883456 {"operations" (rawinput1883454 "operations")}] (clojure.core/cond-> {} (letvar1883456 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883456 ["operations"])))))))

(clojure.core/defn- response-get-operations-result ([input] (response-get-operations-result nil input)) ([resultWrapper1883458 input] (clojure.core/let [rawinput1883457 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883459 {"operations" (rawinput1883457 "operations"), "nextPageToken" (rawinput1883457 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883459 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883459 ["operations"]))) (letvar1883459 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883459 ["nextPageToken"])))))))

(clojure.core/defn- response-start-relational-database-result ([input] (response-start-relational-database-result nil input)) ([resultWrapper1883461 input] (clojure.core/let [rawinput1883460 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883462 {"operations" (rawinput1883460 "operations")}] (clojure.core/cond-> {} (letvar1883462 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883462 ["operations"])))))))

(clojure.core/defn- response-get-relational-database-result ([input] (response-get-relational-database-result nil input)) ([resultWrapper1883464 input] (clojure.core/let [rawinput1883463 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883465 {"relationalDatabase" (rawinput1883463 "relationalDatabase")}] (clojure.core/cond-> {} (letvar1883465 "relationalDatabase") (clojure.core/assoc :relational-database (deser-relational-database (clojure.core/get-in letvar1883465 ["relationalDatabase"])))))))

(clojure.core/defn- response-get-instance-access-details-result ([input] (response-get-instance-access-details-result nil input)) ([resultWrapper1883467 input] (clojure.core/let [rawinput1883466 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883468 {"accessDetails" (rawinput1883466 "accessDetails")}] (clojure.core/cond-> {} (letvar1883468 "accessDetails") (clojure.core/assoc :access-details (deser-instance-access-details (clojure.core/get-in letvar1883468 ["accessDetails"])))))))

(clojure.core/defn- response-detach-instances-from-load-balancer-result ([input] (response-detach-instances-from-load-balancer-result nil input)) ([resultWrapper1883470 input] (clojure.core/let [rawinput1883469 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883471 {"operations" (rawinput1883469 "operations")}] (clojure.core/cond-> {} (letvar1883471 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883471 ["operations"])))))))

(clojure.core/defn- response-start-instance-result ([input] (response-start-instance-result nil input)) ([resultWrapper1883473 input] (clojure.core/let [rawinput1883472 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883474 {"operations" (rawinput1883472 "operations")}] (clojure.core/cond-> {} (letvar1883474 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883474 ["operations"])))))))

(clojure.core/defn- response-delete-key-pair-result ([input] (response-delete-key-pair-result nil input)) ([resultWrapper1883476 input] (clojure.core/let [rawinput1883475 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883477 {"operation" (rawinput1883475 "operation")}] (clojure.core/cond-> {} (letvar1883477 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883477 ["operation"])))))))

(clojure.core/defn- response-delete-relational-database-snapshot-result ([input] (response-delete-relational-database-snapshot-result nil input)) ([resultWrapper1883479 input] (clojure.core/let [rawinput1883478 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883480 {"operations" (rawinput1883478 "operations")}] (clojure.core/cond-> {} (letvar1883480 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883480 ["operations"])))))))

(clojure.core/defn- response-create-cloud-formation-stack-result ([input] (response-create-cloud-formation-stack-result nil input)) ([resultWrapper1883482 input] (clojure.core/let [rawinput1883481 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883483 {"operations" (rawinput1883481 "operations")}] (clojure.core/cond-> {} (letvar1883483 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883483 ["operations"])))))))

(clojure.core/defn- response-update-relational-database-parameters-result ([input] (response-update-relational-database-parameters-result nil input)) ([resultWrapper1883485 input] (clojure.core/let [rawinput1883484 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883486 {"operations" (rawinput1883484 "operations")}] (clojure.core/cond-> {} (letvar1883486 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883486 ["operations"])))))))

(clojure.core/defn- response-attach-instances-to-load-balancer-result ([input] (response-attach-instances-to-load-balancer-result nil input)) ([resultWrapper1883488 input] (clojure.core/let [rawinput1883487 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883489 {"operations" (rawinput1883487 "operations")}] (clojure.core/cond-> {} (letvar1883489 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883489 ["operations"])))))))

(clojure.core/defn- response-create-relational-database-from-snapshot-result ([input] (response-create-relational-database-from-snapshot-result nil input)) ([resultWrapper1883491 input] (clojure.core/let [rawinput1883490 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883492 {"operations" (rawinput1883490 "operations")}] (clojure.core/cond-> {} (letvar1883492 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883492 ["operations"])))))))

(clojure.core/defn- response-operation-failure-exception ([input] (response-operation-failure-exception nil input)) ([resultWrapper1883494 input] (clojure.core/let [rawinput1883493 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883495 {"code" (rawinput1883493 "code"), "docs" (rawinput1883493 "docs"), "message" (rawinput1883493 "message"), "tip" (rawinput1883493 "tip")}] (clojure.core/cond-> {} (letvar1883495 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883495 ["code"]))) (letvar1883495 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883495 ["docs"]))) (letvar1883495 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883495 ["message"]))) (letvar1883495 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883495 ["tip"])))))))

(clojure.core/defn- response-unauthenticated-exception ([input] (response-unauthenticated-exception nil input)) ([resultWrapper1883497 input] (clojure.core/let [rawinput1883496 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883498 {"code" (rawinput1883496 "code"), "docs" (rawinput1883496 "docs"), "message" (rawinput1883496 "message"), "tip" (rawinput1883496 "tip")}] (clojure.core/cond-> {} (letvar1883498 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883498 ["code"]))) (letvar1883498 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883498 ["docs"]))) (letvar1883498 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883498 ["message"]))) (letvar1883498 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883498 ["tip"])))))))

(clojure.core/defn- response-allocate-static-ip-result ([input] (response-allocate-static-ip-result nil input)) ([resultWrapper1883500 input] (clojure.core/let [rawinput1883499 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883501 {"operations" (rawinput1883499 "operations")}] (clojure.core/cond-> {} (letvar1883501 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883501 ["operations"])))))))

(clojure.core/defn- response-get-regions-result ([input] (response-get-regions-result nil input)) ([resultWrapper1883503 input] (clojure.core/let [rawinput1883502 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883504 {"regions" (rawinput1883502 "regions")}] (clojure.core/cond-> {} (letvar1883504 "regions") (clojure.core/assoc :regions (deser-region-list (clojure.core/get-in letvar1883504 ["regions"])))))))

(clojure.core/defn- response-get-active-names-result ([input] (response-get-active-names-result nil input)) ([resultWrapper1883506 input] (clojure.core/let [rawinput1883505 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883507 {"activeNames" (rawinput1883505 "activeNames"), "nextPageToken" (rawinput1883505 "nextPageToken")}] (clojure.core/cond-> {} (letvar1883507 "activeNames") (clojure.core/assoc :active-names (deser-string-list (clojure.core/get-in letvar1883507 ["activeNames"]))) (letvar1883507 "nextPageToken") (clojure.core/assoc :next-page-token (deserstring (clojure.core/get-in letvar1883507 ["nextPageToken"])))))))

(clojure.core/defn- response-get-instance-metric-data-result ([input] (response-get-instance-metric-data-result nil input)) ([resultWrapper1883509 input] (clojure.core/let [rawinput1883508 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883510 {"metricName" (rawinput1883508 "metricName"), "metricData" (rawinput1883508 "metricData")}] (clojure.core/cond-> {} (letvar1883510 "metricName") (clojure.core/assoc :metric-name (deser-instance-metric-name (clojure.core/get-in letvar1883510 ["metricName"]))) (letvar1883510 "metricData") (clojure.core/assoc :metric-data (deser-metric-datapoint-list (clojure.core/get-in letvar1883510 ["metricData"])))))))

(clojure.core/defn- response-create-instance-snapshot-result ([input] (response-create-instance-snapshot-result nil input)) ([resultWrapper1883512 input] (clojure.core/let [rawinput1883511 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883513 {"operations" (rawinput1883511 "operations")}] (clojure.core/cond-> {} (letvar1883513 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883513 ["operations"])))))))

(clojure.core/defn- response-put-instance-public-ports-result ([input] (response-put-instance-public-ports-result nil input)) ([resultWrapper1883515 input] (clojure.core/let [rawinput1883514 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883516 {"operation" (rawinput1883514 "operation")}] (clojure.core/cond-> {} (letvar1883516 "operation") (clojure.core/assoc :operation (deser-operation (clojure.core/get-in letvar1883516 ["operation"])))))))

(clojure.core/defn- response-get-relational-database-log-events-result ([input] (response-get-relational-database-log-events-result nil input)) ([resultWrapper1883518 input] (clojure.core/let [rawinput1883517 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883519 {"resourceLogEvents" (rawinput1883517 "resourceLogEvents"), "nextBackwardToken" (rawinput1883517 "nextBackwardToken"), "nextForwardToken" (rawinput1883517 "nextForwardToken")}] (clojure.core/cond-> {} (letvar1883519 "resourceLogEvents") (clojure.core/assoc :resource-log-events (deser-log-event-list (clojure.core/get-in letvar1883519 ["resourceLogEvents"]))) (letvar1883519 "nextBackwardToken") (clojure.core/assoc :next-backward-token (deserstring (clojure.core/get-in letvar1883519 ["nextBackwardToken"]))) (letvar1883519 "nextForwardToken") (clojure.core/assoc :next-forward-token (deserstring (clojure.core/get-in letvar1883519 ["nextForwardToken"])))))))

(clojure.core/defn- response-tag-resource-result ([input] (response-tag-resource-result nil input)) ([resultWrapper1883521 input] (clojure.core/let [rawinput1883520 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883522 {"operations" (rawinput1883520 "operations")}] (clojure.core/cond-> {} (letvar1883522 "operations") (clojure.core/assoc :operations (deser-operation-list (clojure.core/get-in letvar1883522 ["operations"])))))))

(clojure.core/defn- response-account-setup-in-progress-exception ([input] (response-account-setup-in-progress-exception nil input)) ([resultWrapper1883524 input] (clojure.core/let [rawinput1883523 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1883525 {"code" (rawinput1883523 "code"), "docs" (rawinput1883523 "docs"), "message" (rawinput1883523 "message"), "tip" (rawinput1883523 "tip")}] (clojure.core/cond-> {} (letvar1883525 "code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar1883525 ["code"]))) (letvar1883525 "docs") (clojure.core/assoc :docs (deserstring (clojure.core/get-in letvar1883525 ["docs"]))) (letvar1883525 "message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar1883525 ["message"]))) (letvar1883525 "tip") (clojure.core/assoc :tip (deserstring (clojure.core/get-in letvar1883525 ["tip"])))))))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/float clojure.core/float?)

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port-info-source-type #{:closed "CLOSED" "INSTANCE" :instance :default "NONE" "DEFAULT" :none})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshots-result/relational-database-snapshots (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-snapshot-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshots-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshots-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshots-result/relational-database-snapshots :portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshots-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/instance-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/attached-disk-mapping (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/attached-disk-map))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/instance-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/user-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-instances-from-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/instance-names :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/availability-zone :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/instance-snapshot-name :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/bundle-id] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/attached-disk-mapping :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/user-data :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/key-pair-name :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-blueprints-result/blueprints (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/blueprint-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-blueprints-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-blueprints-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-blueprints-result/blueprints :portkey.aws.lightsail.-2016-11-28.get-blueprints-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-request/relational-database-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-relational-database-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-request/relational-database-name :portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-request/relational-database-snapshot-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-info/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-info/path (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-info/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-info/is-system-disk (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.disk-info/name :portkey.aws.lightsail.-2016-11-28.disk-info/path :portkey.aws.lightsail.-2016-11-28.disk-info/size-in-gb :portkey.aws.lightsail.-2016-11-28.disk-info/is-system-disk]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-load-balancer-tls-certificate-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-load-balancer-tls-certificate-request/certificate-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-load-balancer-tls-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.attach-load-balancer-tls-certificate-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.attach-load-balancer-tls-certificate-request/certificate-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-disk-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/detach-disk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.detach-disk-request/disk-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-state/from-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-state/to-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-state/protocol (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/network-protocol))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-state/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-port-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-port-state/from-port :portkey.aws.lightsail.-2016-11-28.instance-port-state/to-port :portkey.aws.lightsail.-2016-11-28.instance-port-state/protocol :portkey.aws.lightsail.-2016-11-28.instance-port-state/state]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record-source-info/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-source-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record-source-info/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record-source-info/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-source-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record-source-info/resource-type :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record-source-info/name :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record-source-info/arn]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.pending-maintenance-action/action (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.pending-maintenance-action/description (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.pending-maintenance-action/current-apply-date (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/pending-maintenance-action (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.pending-maintenance-action/action :portkey.aws.lightsail.-2016-11-28.pending-maintenance-action/description :portkey.aws.lightsail.-2016-11-28.pending-maintenance-action/current-apply-date]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.download-default-key-pair-result/public-key-base-64 (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/base-64))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.download-default-key-pair-result/private-key-base-64 (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/base-64))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/download-default-key-pair-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.download-default-key-pair-result/public-key-base-64 :portkey.aws.lightsail.-2016-11-28.download-default-key-pair-result/private-key-base-64]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-blueprints-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-blueprints-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-blueprints-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-snapshot-request/disk-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disk-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-disk-snapshot-request/disk-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-option-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-option))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/string-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/string))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-domain-entry-request/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-domain-entry-request/domain-entry (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-entry))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-domain-entry-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-domain-entry-request/domain-name :portkey.aws.lightsail.-2016-11-28.create-domain-entry-request/domain-entry] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/metric-statistic-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/metric-statistic))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/string-max-256 (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operation-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-operation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-operation-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-key-pair-request/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-key-pair-request/key-pair-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-map-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/disk-map))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-domain-result/domain (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-domain-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-domain-result/domain]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.port-info/from-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.port-info/to-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.port-info/protocol (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/network-protocol))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.port-info/from-port :portkey.aws.lightsail.-2016-11-28.port-info/to-port :portkey.aws.lightsail.-2016-11-28.port-info/protocol]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/record-state #{:started "Failed" "Succeeded" "Started" :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-streams-result/log-streams (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-streams-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-log-streams-result/log-streams]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-domain-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-domain-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-domain-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-summary-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-summary))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-static-ip-result/static-ip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/static-ip))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-static-ip-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-static-ip-result/static-ip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-disk-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-disk-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disks-result/disks (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disks-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-disks-result/disks :portkey.aws.lightsail.-2016-11-28.get-disks-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot-info/from-bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot-info/from-blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot-info/from-disk-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-info-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-snapshot-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-snapshot-info/from-bundle-id :portkey.aws.lightsail.-2016-11-28.instance-snapshot-info/from-blueprint-id :portkey.aws.lightsail.-2016-11-28.instance-snapshot-info/from-disk-info]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/non-empty-string (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #".*\S.*" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-disk-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/detach-disk-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.detach-disk-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-load-balancer-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-load-balancer-tls-certificate-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-load-balancer-tls-certificate-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.attach-load-balancer-tls-certificate-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-bundles-result/bundles (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/bundle-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-bundles-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-bundles-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-bundles-result/bundles :portkey.aws.lightsail.-2016-11-28.get-bundles-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/operation-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/operation))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instances-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instances-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instances-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-request/attribute-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-attribute-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-request/attribute-value (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-max-256))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-load-balancer-attribute-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-request/attribute-name :portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-request/attribute-value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/instance-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/custom-image-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/user-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-instances-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-instances-request/instance-names :portkey.aws.lightsail.-2016-11-28.create-instances-request/availability-zone :portkey.aws.lightsail.-2016-11-28.create-instances-request/blueprint-id :portkey.aws.lightsail.-2016-11-28.create-instances-request/bundle-id] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-instances-request/custom-image-name :portkey.aws.lightsail.-2016-11-28.create-instances-request/user-data :portkey.aws.lightsail.-2016-11-28.create-instances-request/key-pair-name :portkey.aws.lightsail.-2016-11-28.create-instances-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-instance-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-instance-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/port))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.pending-modified-relational-database-values/master-user-password (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.pending-modified-relational-database-values/engine-version (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.pending-modified-relational-database-values/backup-retention-enabled (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/pending-modified-relational-database-values (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.pending-modified-relational-database-values/master-user-password :portkey.aws.lightsail.-2016-11-28.pending-modified-relational-database-values/engine-version :portkey.aws.lightsail.-2016-11-28.pending-modified-relational-database-values/backup-retention-enabled]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.start-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/start-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.start-relational-database-request/relational-database-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-revocation-reason #{"PRIVILEGE_WITHDRAWN" :privilege-withdrawn :unspecified "CERTIFICATE_HOLD" :ca-compromise "REMOVE_FROM_CRL" "AFFILIATION_CHANGED" :remove-from-crl "SUPERCEDED" "KEY_COMPROMISE" :key-compromise :a-a-compromise :superceded "UNSPECIFIED" :cessation-of-operation "CA_COMPROMISE" "CESSATION_OF_OPERATION" "A_A_COMPROMISE" :affiliation-changed :certificate-hold})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-export-snapshot-records-result/export-snapshot-records (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/export-snapshot-record-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-export-snapshot-records-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-export-snapshot-records-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-export-snapshot-records-result/export-snapshot-records :portkey.aws.lightsail.-2016-11-28.get-export-snapshot-records-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/metric-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-metric-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/period (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-period))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/start-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/end-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/unit (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-unit))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/statistics (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-statistic-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancer-metric-data-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/metric-name :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/period :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/start-time :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/end-time :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/unit :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-request/statistics] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-port-state-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance-port-state))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-request/duration-in-minutes (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-events-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-events-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-events-request/duration-in-minutes :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/progress (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-snapshot-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-instance-arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-disk-arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.disk-snapshot/progress :portkey.aws.lightsail.-2016-11-28.disk-snapshot/arn :portkey.aws.lightsail.-2016-11-28.disk-snapshot/created-at :portkey.aws.lightsail.-2016-11-28.disk-snapshot/tags :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-instance-name :portkey.aws.lightsail.-2016-11-28.disk-snapshot/size-in-gb :portkey.aws.lightsail.-2016-11-28.disk-snapshot/name :portkey.aws.lightsail.-2016-11-28.disk-snapshot/location :portkey.aws.lightsail.-2016-11-28.disk-snapshot/support-code :portkey.aws.lightsail.-2016-11-28.disk-snapshot/state :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-instance-arn :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-disk-arn :portkey.aws.lightsail.-2016-11-28.disk-snapshot/resource-type :portkey.aws.lightsail.-2016-11-28.disk-snapshot/from-disk-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/key-pair (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/key-pair))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/public-key-base-64 (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/base-64))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/private-key-base-64 (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/base-64))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-key-pair-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-key-pair-result/key-pair :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/public-key-base-64 :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/private-key-base-64 :portkey.aws.lightsail.-2016-11-28.create-key-pair-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-entry-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance-entry))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-snapshots-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disk-snapshots-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-disk-snapshots-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-record-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-record))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshots-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshots-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshots-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-static-ip-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/detach-static-ip-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.detach-static-ip-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.metric-datapoint/average (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/double))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.metric-datapoint/maximum (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/double))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.metric-datapoint/minimum (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/double))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.metric-datapoint/sample-count (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/double))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.metric-datapoint/sum (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/double))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.metric-datapoint/unit (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-unit))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/metric-datapoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.metric-datapoint/average :portkey.aws.lightsail.-2016-11-28.metric-datapoint/maximum :portkey.aws.lightsail.-2016-11-28.metric-datapoint/minimum :portkey.aws.lightsail.-2016-11-28.metric-datapoint/sample-count :portkey.aws.lightsail.-2016-11-28.metric-datapoint/sum :portkey.aws.lightsail.-2016-11-28/timestamp :portkey.aws.lightsail.-2016-11-28.metric-datapoint/unit]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-key-pair-result/key-pair (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/key-pair))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-key-pair-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-key-pair-result/key-pair]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-load-balancer-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-load-balancer-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.resource-location/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.resource-location/region-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/region-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/resource-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.resource-location/availability-zone :portkey.aws.lightsail.-2016-11-28.resource-location/region-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.copy-snapshot-request/source-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.copy-snapshot-request/target-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.copy-snapshot-request/source-region (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/region-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/copy-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.copy-snapshot-request/source-snapshot-name :portkey.aws.lightsail.-2016-11-28.copy-snapshot-request/target-snapshot-name :portkey.aws.lightsail.-2016-11-28.copy-snapshot-request/source-region] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-metric-name #{:http-code-instance-4-xx-count "InstanceResponseTime" "RejectedConnectionCount" "HTTPCode_LB_5XX_Count" :healthy-host-count :instance-response-time :http-code-lb-4-xx-count :http-code-lb-5-xx-count "RequestCount" :http-code-instance-3-xx-count :http-code-instance-5-xx-count "ClientTLSNegotiationErrorCount" :client-tls-negotiation-error-count :http-code-instance-2-xx-count :unhealthy-host-count "HTTPCode_Instance_5XX_Count" "HTTPCode_LB_4XX_Count" "HTTPCode_Instance_2XX_Count" :rejected-connection-count "HealthyHostCount" "UnhealthyHostCount" :request-count "HTTPCode_Instance_3XX_Count" "HTTPCode_Instance_4XX_Count"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-static-ip-request/static-ip-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-static-ip-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-static-ip-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.attach-static-ip-request/static-ip-name :portkey.aws.lightsail.-2016-11-28.attach-static-ip-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.peer-vpc-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/peer-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.peer-vpc-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-disk-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-disk-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-disk-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-load-balancer-attribute-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.update-load-balancer-attribute-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-key-pair-request/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-key-pair-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-key-pair-request/key-pair-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-key-pair-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-snapshot-request/instance-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-instance-snapshot-request/instance-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-static-ips-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-static-ips-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-static-ips-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-tls-certificates-result/tls-certificates (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancer-tls-certificates-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancer-tls-certificates-result/tls-certificates]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-result/master-user-password (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/sensitive-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-result/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-master-user-password-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-result/master-user-password :portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-result/created-at]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.service-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.service-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.service-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.service-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/service-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.service-exception/code :portkey.aws.lightsail.-2016-11-28.service-exception/docs :portkey.aws.lightsail.-2016-11-28.service-exception/message :portkey.aws.lightsail.-2016-11-28.service-exception/tip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-result/metric-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-metric-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-result/metric-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-datapoint-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancer-metric-data-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-result/metric-name :portkey.aws.lightsail.-2016-11-28.get-load-balancer-metric-data-result/metric-data]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.import-key-pair-request/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.import-key-pair-request/public-key-base-64 (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/base-64))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/import-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.import-key-pair-request/key-pair-name :portkey.aws.lightsail.-2016-11-28.import-key-pair-request/public-key-base-64] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-tls-certificates-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancer-tls-certificates-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancer-tls-certificates-request/load-balancer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/protocol (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-access-protocol))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/password-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/password-data))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/username (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/cert-key (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/private-key (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/password (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/ip-address (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/ip-address))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-access-details/expires-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-access-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-access-details/protocol :portkey.aws.lightsail.-2016-11-28.instance-access-details/instance-name :portkey.aws.lightsail.-2016-11-28.instance-access-details/password-data :portkey.aws.lightsail.-2016-11-28.instance-access-details/username :portkey.aws.lightsail.-2016-11-28.instance-access-details/cert-key :portkey.aws.lightsail.-2016-11-28.instance-access-details/private-key :portkey.aws.lightsail.-2016-11-28.instance-access-details/password :portkey.aws.lightsail.-2016-11-28.instance-access-details/ip-address :portkey.aws.lightsail.-2016-11-28.instance-access-details/expires-at]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/region-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/region))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-event/resource (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-event/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-event/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-event/event-categories (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-event/resource :portkey.aws.lightsail.-2016-11-28.relational-database-event/created-at :portkey.aws.lightsail.-2016-11-28.relational-database-event/message :portkey.aws.lightsail.-2016-11-28.relational-database-event/event-categories]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-operations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-operations-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/static-ip-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/static-ip))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.reboot-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/reboot-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.reboot-relational-database-request/relational-database-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.allocate-static-ip-request/static-ip-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/allocate-static-ip-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.allocate-static-ip-request/static-ip-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/metric-datapoint-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/metric-datapoint))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-health-reason #{:lb-internal-error :instance-timeout :instance-not-in-use "Instance.ResponseCodeMismatch" "Lb.InternalError" "Instance.NotRegistered" "Instance.FailedHealthChecks" :instance-deregistration-in-progress :lb-registration-in-progress :instance-invalid-state :instance-response-code-mismatch "Instance.Timeout" :instance-not-registered "Instance.IpUnusable" "Instance.NotInUse" "Instance.DeregistrationInProgress" "Lb.InitialHealthChecking" "Instance.InvalidState" "Lb.RegistrationInProgress" :instance-ip-unusable :lb-initial-health-checking :instance-failed-health-checks})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-domain-request/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-domain-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-domain-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-domain-request/domain-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-domain-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.put-instance-public-ports-request/port-infos (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-info-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.put-instance-public-ports-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/put-instance-public-ports-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.put-instance-public-ports-request/port-infos :portkey.aws.lightsail.-2016-11-28.put-instance-public-ports-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port-state #{:open :closed "closed" "open"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/bundle-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/bundle))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-blueprints-request/include-inactive (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-blueprints-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-blueprints-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-blueprints-request/include-inactive :portkey.aws.lightsail.-2016-11-28.get-blueprints-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-tls-certificate-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-health-summary/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-health-summary/instance-health (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-health-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-health-summary/instance-health-reason (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-health-reason))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-health-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-health-summary/instance-name :portkey.aws.lightsail.-2016-11-28.instance-health-summary/instance-health :portkey.aws.lightsail.-2016-11-28.instance-health-summary/instance-health-reason]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/is-active (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/is-encrypted (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/disk-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/ram-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/float))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/transfer-per-month-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/price (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/float))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/cpu-count (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-bundle (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-bundle/is-active :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/is-encrypted :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/disk-size-in-gb :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/name :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/bundle-id :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/ram-size-in-gb :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/transfer-per-month-in-gb :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/price :portkey.aws.lightsail.-2016-11-28.relational-database-bundle/cpu-count]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.update-relational-database-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-instance-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-instance-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-instance-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/is-active (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/disk-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/power (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/supported-platforms (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-platform-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/ram-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/float))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/instance-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/transfer-per-month-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/price (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/float))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.bundle/cpu-count (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/bundle (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.bundle/is-active :portkey.aws.lightsail.-2016-11-28.bundle/disk-size-in-gb :portkey.aws.lightsail.-2016-11-28.bundle/name :portkey.aws.lightsail.-2016-11-28.bundle/power :portkey.aws.lightsail.-2016-11-28.bundle/supported-platforms :portkey.aws.lightsail.-2016-11-28.bundle/bundle-id :portkey.aws.lightsail.-2016-11-28.bundle/ram-size-in-gb :portkey.aws.lightsail.-2016-11-28.bundle/instance-type :portkey.aws.lightsail.-2016-11-28.bundle/transfer-per-month-in-gb :portkey.aws.lightsail.-2016-11-28.bundle/price :portkey.aws.lightsail.-2016-11-28.bundle/cpu-count]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.import-key-pair-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/import-key-pair-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.import-key-pair-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-instance-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-instance-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/resource-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/is-terminal (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/operation-details (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/operation-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/error-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/status (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-status))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/error-details (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/status-changed-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.operation/resource-name :portkey.aws.lightsail.-2016-11-28.operation/created-at :portkey.aws.lightsail.-2016-11-28.operation/is-terminal :portkey.aws.lightsail.-2016-11-28.operation/id :portkey.aws.lightsail.-2016-11-28.operation/operation-details :portkey.aws.lightsail.-2016-11-28.operation/operation-type :portkey.aws.lightsail.-2016-11-28.operation/error-code :portkey.aws.lightsail.-2016-11-28.operation/location :portkey.aws.lightsail.-2016-11-28.operation/status :portkey.aws.lightsail.-2016-11-28.operation/error-details :portkey.aws.lightsail.-2016-11-28.operation/status-changed-at :portkey.aws.lightsail.-2016-11-28.operation/resource-type]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/key-pair-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/key-pair))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-request/relational-database-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/value (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/validation-status (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-status))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-record (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/name :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/type :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/value :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/validation-status :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-record/domain-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/base-64 (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-domains-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-domains-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-domains-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-disk-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-disk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-disk-request/disk-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-streams-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-streams-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-log-streams-request/relational-database-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.unpeer-vpc-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/unpeer-vpc-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.unpeer-vpc-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-result/disk (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disk-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-disk-result/disk]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/not-after (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/serial (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/is-attached (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/domain-validation-records (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-record-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/key-algorithm (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/issuer (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/revoked-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/status (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-status))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/signature-algorithm (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/subject (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/subject-alternative-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/renewal-summary (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-renewal-summary))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/not-before (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/failure-reason (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-failure-reason))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/issued-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/revocation-reason (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-revocation-reason))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/not-after :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/arn :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/serial :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/is-attached :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/created-at :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/domain-validation-records :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/key-algorithm :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/issuer :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/domain-name :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/revoked-at :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/tags :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/name :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/location :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/status :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/load-balancer-name :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/signature-algorithm :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/subject :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/subject-alternative-names :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/support-code :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/renewal-summary :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/not-before :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/failure-reason :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/issued-at :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/resource-type :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate/revocation-reason]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain-entry/id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain-entry/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain-entry/target (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain-entry/is-alias (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain-entry/type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-entry-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain-entry/options (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-entry-options))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-entry (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.domain-entry/id :portkey.aws.lightsail.-2016-11-28.domain-entry/name :portkey.aws.lightsail.-2016-11-28.domain-entry/target :portkey.aws.lightsail.-2016-11-28.domain-entry/is-alias :portkey.aws.lightsail.-2016-11-28.domain-entry/type :portkey.aws.lightsail.-2016-11-28.domain-entry/options]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-domain-entry-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-domain-entry-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-domain-entry-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-relational-database-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/availability-zone-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/availability-zone))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/metric-unit #{:kilobytes-second :megabits "Terabytes" :bits-second :count-second :kilobits "Kilobits/Second" "Count" :megabytes-second "Bits" "Percent" "Gigabits/Second" :terabytes :terabits-second "None" :seconds :bits :terabits :bytes-second :kilobytes :microseconds "Count/Second" "Bytes" "Gigabytes/Second" :megabits-second "Megabits/Second" :gigabits "Kilobytes/Second" :gigabits-second :kilobits-second :megabytes "Terabytes/Second" "Bits/Second" "Bytes/Second" "Milliseconds" :count :gigabytes-second "Kilobytes" :bytes :milliseconds "Microseconds" :percent "Terabits" :gigabytes "Megabytes/Second" :terabytes-second "Gigabytes" "Gigabits" "Megabits" :none "Kilobits" "Terabits/Second" "Megabytes" "Seconds"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.availability-zone/zone-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.availability-zone/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/availability-zone (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.availability-zone/zone-name :portkey.aws.lightsail.-2016-11-28.availability-zone/state]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/metric-period (clojure.spec.alpha/int-in 60 86400))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-source-info-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-source-info))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-health-state #{"healthy" :draining :unhealthy :unavailable :unused "initial" :healthy "unhealthy" "unused" :initial "draining" "unavailable"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-failure-reason #{:no-available-contacts "INVALID_PUBLIC_DOMAIN" :other "ADDITIONAL_VERIFICATION_REQUIRED" :additional-verification-required :domain-not-allowed "OTHER" "DOMAIN_NOT_ALLOWED" :invalid-public-domain "NO_AVAILABLE_CONTACTS"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/export-snapshot-record-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/export-snapshot-record))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-option/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-option/validation-status (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-status))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-option (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-option/domain-name :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-domain-validation-option/validation-status]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/relational-database-blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/preferred-backup-window (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/master-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/publicly-accessible (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/master-username (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/relational-database-bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/master-user-password (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/sensitive-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-request/relational-database-name :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/relational-database-blueprint-id :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/relational-database-bundle-id :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/master-database-name :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/master-username] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-request/tags :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/preferred-backup-window :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/availability-zone :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/publicly-accessible :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/preferred-maintenance-window :portkey.aws.lightsail.-2016-11-28.create-relational-database-request/master-user-password]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/blueprint-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/blueprint))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-snapshots-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-snapshots-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-snapshots-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-networking/monthly-transfer (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/monthly-transfer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-networking/ports (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-port-info-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-networking (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-networking/monthly-transfer :portkey.aws.lightsail.-2016-11-28.instance-networking/ports]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-password-version #{"CURRENT" :pending "PENDING" "PREVIOUS" :previous :current})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.stop-instance-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.stop-instance-request/force (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/stop-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.stop-instance-request/instance-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.stop-instance-request/force]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-engine #{"mysql" :mysql})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-static-ip-request/static-ip-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/detach-static-ip-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.detach-static-ip-request/static-ip-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-parameter-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/relational-database-parameter))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-renewal-status #{"SUCCESS" :pending-validation :pending-auto-renewal "PENDING_AUTO_RENEWAL" :success "FAILED" "PENDING_VALIDATION" :failed})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/sensitive-string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.release-static-ip-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/release-static-ip-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.release-static-ip-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-domain-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-domain-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-domain-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/is-vpc-peered-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-result/next-page-count (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-operations-for-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-result/operations :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-result/next-page-count :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancer-request/load-balancer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-request/certificate-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-request/force (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-tls-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-request/certificate-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-load-balancer-tls-certificate-request/force]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-map/original-disk-path (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-map/new-disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.disk-map/original-disk-path :portkey.aws.lightsail.-2016-11-28.disk-map/new-disk-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-snapshots-result/instance-snapshots (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-snapshot-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-snapshots-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-snapshots-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-snapshots-result/instance-snapshots :portkey.aws.lightsail.-2016-11-28.get-instance-snapshots-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port-access-type #{"Private" :private "Public" :public})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/region-name #{:apnortheast-1 :apsouth-1 "ap-northeast-1" "eu-west-1" :euwest-3 :useast-1 :apsoutheast-2 :apnortheast-2 "us-east-2" "ap-southeast-2" "ap-southeast-1" "ap-northeast-2" "eu-west-3" :cacentral-1 "ca-central-1" "eu-central-1" :euwest-2 "eu-west-2" :uswest-1 :eucentral-1 :apsoutheast-1 "us-west-2" "us-east-1" "us-west-1" "ap-south-1" :euwest-1 :useast-2 :uswest-2})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-domain-entry-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-domain-entry-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.update-domain-entry-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/metric-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-metric-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/period (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-period))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/start-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/end-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/unit (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-unit))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/statistics (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-statistic-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-metric-data-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/relational-database-name :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/metric-name :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/period :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/start-time :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/end-time :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/unit :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-request/statistics] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-instance-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/is-active (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/group (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/min-power (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/product-url (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/blueprint-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/version (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/license-url (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/version-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/platform (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-platform))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.blueprint/description (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/blueprint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.blueprint/is-active :portkey.aws.lightsail.-2016-11-28.blueprint/blueprint-id :portkey.aws.lightsail.-2016-11-28.blueprint/group :portkey.aws.lightsail.-2016-11-28.blueprint/min-power :portkey.aws.lightsail.-2016-11-28.blueprint/name :portkey.aws.lightsail.-2016-11-28.blueprint/product-url :portkey.aws.lightsail.-2016-11-28.blueprint/type :portkey.aws.lightsail.-2016-11-28.blueprint/version :portkey.aws.lightsail.-2016-11-28.blueprint/license-url :portkey.aws.lightsail.-2016-11-28.blueprint/version-code :portkey.aws.lightsail.-2016-11-28.blueprint/platform :portkey.aws.lightsail.-2016-11-28.blueprint/description]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.domain/domain-entries (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-entry-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.domain/name :portkey.aws.lightsail.-2016-11-28.domain/arn :portkey.aws.lightsail.-2016-11-28.domain/support-code :portkey.aws.lightsail.-2016-11-28.domain/created-at :portkey.aws.lightsail.-2016-11-28.domain/location :portkey.aws.lightsail.-2016-11-28.domain/resource-type :portkey.aws.lightsail.-2016-11-28.domain/tags :portkey.aws.lightsail.-2016-11-28.domain/domain-entries]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-export-snapshot-records-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-export-snapshot-records-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-export-snapshot-records-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-name-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/domain-name))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-disk-from-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-domain-request/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-domain-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-domain-request/domain-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-static-ip-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-static-ip-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.attach-static-ip-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.tag-resource-request/resource-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.tag-resource-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.tag-resource-request/resource-name :portkey.aws.lightsail.-2016-11-28.tag-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.open-instance-public-ports-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/open-instance-public-ports-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.open-instance-public-ports-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/domain))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-hardware/cpu-count (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-hardware/disks (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-hardware/ram-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/float))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-hardware (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-hardware/cpu-count :portkey.aws.lightsail.-2016-11-28.instance-hardware/disks :portkey.aws.lightsail.-2016-11-28.instance-hardware/ram-size-in-gb]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-cloud-formation-stack-request/instances (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-entry-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-cloud-formation-stack-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-cloud-formation-stack-request/instances] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-domain-entry-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-domain-entry-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-domain-entry-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/disk-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-disk-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/disk-snapshot-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/disk-name :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/instance-name :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-event-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/relational-database-event))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-static-ip-request/static-ip-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-static-ip-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-static-ip-request/static-ip-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-port-states-result/port-states (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-port-state-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-port-states-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-port-states-result/port-states]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-regions-request/include-availability-zones (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-regions-request/include-relational-database-availability-zones (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-regions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-regions-request/include-availability-zones :portkey.aws.lightsail.-2016-11-28.get-regions-request/include-relational-database-availability-zones]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-key-pairs-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-key-pairs-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-key-pairs-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-domain-entry-request/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-domain-entry-request/domain-entry (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-entry))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-domain-entry-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.update-domain-entry-request/domain-name :portkey.aws.lightsail.-2016-11-28.update-domain-entry-request/domain-entry] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/peer-vpc-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/tag))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/download-default-key-pair-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-endpoint/port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-endpoint/address (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-endpoint/port :portkey.aws.lightsail.-2016-11-28.relational-database-endpoint/address]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-disk-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-disk-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-disk-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-renewal-summary/renewal-status (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-renewal-status))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-renewal-summary/domain-validation-options (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-validation-option-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-renewal-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-renewal-summary/renewal-status :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-renewal-summary/domain-validation-options]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshot-request/relational-database-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshot-request/relational-database-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-domains-result/domains (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-domains-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-domains-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-domains-result/domains :portkey.aws.lightsail.-2016-11-28.get-domains-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-key-pair-request/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-key-pair-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-key-pair-request/key-pair-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-metric-name #{:free-storage-space :network-receive-throughput :network-transmit-throughput "NetworkTransmitThroughput" "NetworkReceiveThroughput" :cpu-utilization "DatabaseConnections" "DiskQueueDepth" "CPUUtilization" "FreeStorageSpace" :disk-queue-depth :database-connections})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/tag-key))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/unpeer-vpc-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshot-result/relational-database-snapshot (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-snapshot))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-snapshot-result/relational-database-snapshot]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/instance-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/health-check-path (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/certificate-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/certificate-domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/certificate-alternative-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-load-balancer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/instance-port] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/health-check-path :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/certificate-name :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/certificate-domain-name :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/certificate-alternative-names :portkey.aws.lightsail.-2016-11-28.create-load-balancer-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-state #{"active_impaired" :active-impaired :unknown "failed" "provisioning" :active "unknown" :provisioning "active" :failed})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-relational-database-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-relational-database-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-status #{:inactive "UNKNOWN" :pending-validation "REVOKED" :unknown "EXPIRED" "ISSUED" :revoked "INACTIVE" "FAILED" "PENDING_VALIDATION" :expired :issued "VALIDATION_TIMED_OUT" :validation-timed-out :failed})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-snapshot-result/disk-snapshot (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-snapshot))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disk-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-disk-snapshot-result/disk-snapshot]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/export-snapshot-record-source-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/from-resource-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/from-resource-arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/instance-snapshot-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-snapshot-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/disk-snapshot-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-snapshot-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/export-snapshot-record-source-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/resource-type :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/created-at :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/name :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/arn :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/from-resource-name :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/from-resource-arn :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/instance-snapshot-info :portkey.aws.lightsail.-2016-11-28.export-snapshot-record-source-info/disk-snapshot-info]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-load-balancer-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-load-balancer-request/load-balancer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancers-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancers-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancers-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.stop-relational-database-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/stop-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.stop-relational-database-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-snapshot-result/instance-snapshot (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-snapshot))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-snapshot-result/instance-snapshot]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-source-type #{:export-snapshot-record "ExportSnapshotRecord"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-instances-from-load-balancer-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-instances-from-load-balancer-request/instance-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/detach-instances-from-load-balancer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.detach-instances-from-load-balancer-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.detach-instances-from-load-balancer-request/instance-names] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/ip-v-6-address (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"([A-F0-9]{1,4}:){7}[A-F0-9]{1,4}" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-bundle-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/relational-database-bundle))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/pending-maintenance-action-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/pending-maintenance-action))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-result/relational-database-events (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-event-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-events-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-events-result/relational-database-events :portkey.aws.lightsail.-2016-11-28.get-relational-database-events-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-hardware/cpu-count (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-hardware/disk-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-hardware/ram-size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/float))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-hardware (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-hardware/cpu-count :portkey.aws.lightsail.-2016-11-28.relational-database-hardware/disk-size-in-gb :portkey.aws.lightsail.-2016-11-28.relational-database-hardware/ram-size-in-gb]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-request/password-version (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-password-version))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-master-user-password-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-master-user-password-request/password-version]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk-snapshot-info/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-snapshot-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.disk-snapshot-info/size-in-gb]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/from-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/to-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/protocol (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/network-protocol))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/access-from (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/access-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-access-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/common-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-port-info/access-direction (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/access-direction))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-port-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-port-info/from-port :portkey.aws.lightsail.-2016-11-28.instance-port-info/to-port :portkey.aws.lightsail.-2016-11-28.instance-port-info/protocol :portkey.aws.lightsail.-2016-11-28.instance-port-info/access-from :portkey.aws.lightsail.-2016-11-28.instance-port-info/access-type :portkey.aws.lightsail.-2016-11-28.instance-port-info/common-name :portkey.aws.lightsail.-2016-11-28.instance-port-info/access-direction]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/allowed-values (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/apply-method (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/apply-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/data-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/description (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/is-modifiable (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/parameter-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/parameter-value (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-parameter/allowed-values :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/apply-method :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/apply-type :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/data-type :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/description :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/is-modifiable :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/parameter-name :portkey.aws.lightsail.-2016-11-28.relational-database-parameter/parameter-value]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-bundles-result/bundles (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-bundle-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-bundles-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-bundles-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-bundles-result/bundles :portkey.aws.lightsail.-2016-11-28.get-relational-database-bundles-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-disk-request/disk-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port (clojure.spec.alpha/int-in 0 65535))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/invalid-input-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.invalid-input-exception/code :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/docs :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/message :portkey.aws.lightsail.-2016-11-28.invalid-input-exception/tip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/iso-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/disk-snapshot))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-domain-entry-request/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-domain-entry-request/domain-entry (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-entry))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-domain-entry-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-domain-entry-request/domain-name :portkey.aws.lightsail.-2016-11-28.delete-domain-entry-request/domain-entry] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-snapshot-state #{:pending "error" :error :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/access-direction #{:outbound "outbound" "inbound" :inbound})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-key-pairs-result/key-pairs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/key-pair-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-key-pairs-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-key-pairs-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-key-pairs-result/key-pairs :portkey.aws.lightsail.-2016-11-28.get-key-pairs-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/blueprint-type #{"os" :app "app" :os})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-load-balancer-tls-certificate-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-instance-snapshot-request/instance-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-instance-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-instance-snapshot-request/instance-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/resource-name-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/resource-name))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/disk-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-disk-from-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/disk-name :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/disk-snapshot-name :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/availability-zone :portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/size-in-gb] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-disk-from-snapshot-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-static-ips-result/static-ips (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/static-ip-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-static-ips-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-static-ips-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-static-ips-result/static-ips :portkey.aws.lightsail.-2016-11-28.get-static-ips-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.not-found-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.not-found-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.not-found-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.not-found-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.not-found-exception/code :portkey.aws.lightsail.-2016-11-28.not-found-exception/docs :portkey.aws.lightsail.-2016-11-28.not-found-exception/message :portkey.aws.lightsail.-2016-11-28.not-found-exception/tip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-configuration-options (clojure.spec.alpha/map-of :portkey.aws.lightsail.-2016-11-28/load-balancer-attribute-name :portkey.aws.lightsail.-2016-11-28/string))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-platform #{:windows "LINUX_UNIX" :linux-unix "WINDOWS"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-request/resource-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-operations-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-request/resource-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-operations-for-resource-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-state #{:unknown :pending "error" "in-use" :inuse "unknown" :error :available "pending" "available"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-state-result/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-state-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-state-result/state]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/operation-status #{:started "Failed" "NotStarted" "Succeeded" :completed "Started" :not-started "Completed" :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.access-denied-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.access-denied-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.access-denied-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.access-denied-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/access-denied-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.access-denied-exception/code :portkey.aws.lightsail.-2016-11-28.access-denied-exception/docs :portkey.aws.lightsail.-2016-11-28.access-denied-exception/message :portkey.aws.lightsail.-2016-11-28.access-denied-exception/tip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/resource-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"\w[\w\-]*\w" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-access-details-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-access-details-request/protocol (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-access-protocol))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-access-details-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-instance-access-details-request/instance-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-access-details-request/protocol]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-entry-options-keys (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-result/metric-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-metric-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-result/metric-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-datapoint-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-metric-data-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-result/metric-name :portkey.aws.lightsail.-2016-11-28.get-relational-database-metric-data-result/metric-data]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-engine))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine-version (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine-description (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine-version-description (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/is-engine-default (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-blueprint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/blueprint-id :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine-version :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine-description :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/engine-version-description :portkey.aws.lightsail.-2016-11-28.relational-database-blueprint/is-engine-default]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/export-snapshot-record-source-type #{"DiskSnapshot" :disk-snapshot "InstanceSnapshot" :instance-snapshot})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-databases-result/relational-databases (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-databases-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-databases-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-databases-result/relational-databases :portkey.aws.lightsail.-2016-11-28.get-relational-databases-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.untag-resource-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/untag-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.untag-resource-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-blueprints-result/blueprints (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-blueprint-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-blueprints-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-blueprints-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-blueprints-result/blueprints :portkey.aws.lightsail.-2016-11-28.get-relational-database-blueprints-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-active-names-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-active-names-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-active-names-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-state-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-state-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-instance-state-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.close-instance-public-ports-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/close-instance-public-ports-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.close-instance-public-ports-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-cloud-formation-stack-records-result/cloud-formation-stack-records (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-cloud-formation-stack-records-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-cloud-formation-stack-records-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-cloud-formation-stack-records-result/cloud-formation-stack-records :portkey.aws.lightsail.-2016-11-28.get-cloud-formation-stack-records-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-snapshots-result/disk-snapshots (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-snapshot-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disk-snapshots-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disk-snapshots-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-disk-snapshots-result/disk-snapshots :portkey.aws.lightsail.-2016-11-28.get-disk-snapshots-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/resource-type #{:peered-vpc :disk :relational-database "DiskSnapshot" :instance :key-pair :disk-snapshot "PeeredVpc" :load-balancer-tls-certificate :load-balancer "LoadBalancerTlsCertificate" :export-snapshot-record "Domain" "Disk" "LoadBalancer" "StaticIp" "InstanceSnapshot" "KeyPair" :domain :cloud-formation-stack-record "Instance" "RelationalDatabaseSnapshot" :relational-database-snapshot :instance-snapshot "RelationalDatabase" :static-ip "ExportSnapshotRecord" "CloudFormationStackRecord"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/log-event-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/log-event))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-summary/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-summary/is-attached (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-summary/name :portkey.aws.lightsail.-2016-11-28.load-balancer-tls-certificate-summary/is-attached]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-instances-from-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-instances-from-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-result/parameters (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-parameter-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-result/parameters :portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-disk-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-disk-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.attach-disk-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-metric-name #{:status-check-failed-system "StatusCheckFailed" "StatusCheckFailed_System" :cpu-utilization "NetworkOut" :network-out :network-in :status-check-failed-instance "StatusCheckFailed_Instance" "CPUUtilization" "NetworkIn" :status-check-failed})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/operation-type #{:start-relational-database "AttachStaticIp" :create-load-balancer :update-domain-entry "UpdateRelationalDatabase" :create-instances-from-snapshot "StartInstance" "PutInstancePublicPorts" :delete-domain "CreateInstancesFromSnapshot" "RebootInstance" :attach-load-balancer-tls-certificate "DeleteDomainEntry" "DeleteRelationalDatabaseSnapshot" "DeleteLoadBalancer" :delete-load-balancer-tls-certificate "StopRelationalDatabase" :create-relational-database-snapshot :start-instance "StopInstance" :update-relational-database "AttachDisk" "CreateDiskFromSnapshot" :delete-disk "CreateInstanceSnapshot" :create-disk :delete-relational-database-snapshot :create-disk-from-snapshot :create-instance "UpdateDomainEntry" "CreateRelationalDatabaseSnapshot" "CreateRelationalDatabase" :delete-load-balancer "UpdateRelationalDatabaseParameters" :put-instance-public-ports :reboot-relational-database "AllocateStaticIp" :create-relational-database "CreateLoadBalancer" "AttachInstancesToLoadBalancer" :attach-instances-to-load-balancer "CreateDisk" "UpdateLoadBalancerAttribute" :reboot-instance :delete-instance "RebootRelationalDatabase" :allocate-static-ip "CreateRelationalDatabaseFromSnapshot" :attach-disk :detach-disk "CreateDomain" :stop-relational-database :release-static-ip "DeleteDisk" "ReleaseStaticIp" "CreateDiskSnapshot" "DetachInstancesFromLoadBalancer" "DeleteInstanceSnapshot" "CreateLoadBalancerTlsCertificate" "DeleteDiskSnapshot" :delete-disk-snapshot "StartRelationalDatabase" "CloseInstancePublicPorts" :create-load-balancer-tls-certificate :close-instance-public-ports :delete-relational-database :attach-static-ip :create-disk-snapshot :detach-instances-from-load-balancer "OpenInstancePublicPorts" :open-instance-public-ports :update-relational-database-parameters "AttachLoadBalancerTlsCertificate" "DeleteDomain" :update-load-balancer-attribute "DetachStaticIp" :delete-domain-entry :create-instance-snapshot :delete-instance-snapshot "DeleteInstance" "DetachDisk" :create-relational-database-from-snapshot :create-domain :detach-static-ip "DeleteLoadBalancerTlsCertificate" "CreateInstance" "DeleteRelationalDatabase" :stop-instance})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-disk-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-disk-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-disk-request/disk-path (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-disk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.attach-disk-request/disk-name :portkey.aws.lightsail.-2016-11-28.attach-disk-request/instance-name :portkey.aws.lightsail.-2016-11-28.attach-disk-request/disk-path] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-disk-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-disk-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.reboot-instance-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/reboot-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.reboot-instance-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/relational-database-snapshot))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instances-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-instances-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-protocol #{:http-https :http "HTTP" "HTTP_HTTPS"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.is-vpc-peered-result/is-peered (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/is-vpc-peered-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.is-vpc-peered-result/is-peered]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instances-result/instances (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instances-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instances-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instances-result/instances :portkey.aws.lightsail.-2016-11-28.get-instances-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/metric-statistic #{"Sum" "Average" :maximum "SampleCount" "Minimum" :sample-count :minimum :average :sum "Maximum"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/is-system-disk (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/is-attached (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/path (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/gb-in-use (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/attached-to (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/iops (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/attachment-state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.disk/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.disk/is-system-disk :portkey.aws.lightsail.-2016-11-28.disk/arn :portkey.aws.lightsail.-2016-11-28.disk/is-attached :portkey.aws.lightsail.-2016-11-28.disk/created-at :portkey.aws.lightsail.-2016-11-28.disk/tags :portkey.aws.lightsail.-2016-11-28.disk/path :portkey.aws.lightsail.-2016-11-28.disk/gb-in-use :portkey.aws.lightsail.-2016-11-28.disk/size-in-gb :portkey.aws.lightsail.-2016-11-28.disk/name :portkey.aws.lightsail.-2016-11-28.disk/attached-to :portkey.aws.lightsail.-2016-11-28.disk/location :portkey.aws.lightsail.-2016-11-28.disk/iops :portkey.aws.lightsail.-2016-11-28.disk/support-code :portkey.aws.lightsail.-2016-11-28.disk/state :portkey.aws.lightsail.-2016-11-28.disk/attachment-state :portkey.aws.lightsail.-2016-11-28.disk/resource-type]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-bundles-request/include-inactive (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-bundles-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-bundles-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-bundles-request/include-inactive :portkey.aws.lightsail.-2016-11-28.get-bundles-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-entry/source-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-entry/instance-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-entry/port-info-source (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-info-source-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-entry/user-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-entry/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-entry (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.instance-entry/source-name :portkey.aws.lightsail.-2016-11-28.instance-entry/instance-type :portkey.aws.lightsail.-2016-11-28.instance-entry/port-info-source :portkey.aws.lightsail.-2016-11-28.instance-entry/availability-zone] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-entry/user-data]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/ip-address (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"([0-9]{1,3}\.){3}[0-9]{1,3}" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.reboot-relational-database-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/reboot-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.reboot-relational-database-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.copy-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/copy-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.copy-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-state/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-state/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-state/code :portkey.aws.lightsail.-2016-11-28.instance-state/name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/protocol (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-protocol))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/configuration-options (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-configuration-options))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/health-check-path (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/instance-health-summary (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-health-summary-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/instance-port (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/tls-certificate-summaries (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-summary-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/public-ports (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.load-balancer/dns-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.load-balancer/protocol :portkey.aws.lightsail.-2016-11-28.load-balancer/configuration-options :portkey.aws.lightsail.-2016-11-28.load-balancer/arn :portkey.aws.lightsail.-2016-11-28.load-balancer/created-at :portkey.aws.lightsail.-2016-11-28.load-balancer/health-check-path :portkey.aws.lightsail.-2016-11-28.load-balancer/tags :portkey.aws.lightsail.-2016-11-28.load-balancer/instance-health-summary :portkey.aws.lightsail.-2016-11-28.load-balancer/name :portkey.aws.lightsail.-2016-11-28.load-balancer/location :portkey.aws.lightsail.-2016-11-28.load-balancer/instance-port :portkey.aws.lightsail.-2016-11-28.load-balancer/support-code :portkey.aws.lightsail.-2016-11-28.load-balancer/state :portkey.aws.lightsail.-2016-11-28.load-balancer/resource-type :portkey.aws.lightsail.-2016-11-28.load-balancer/tls-certificate-summaries :portkey.aws.lightsail.-2016-11-28.load-balancer/public-ports :portkey.aws.lightsail.-2016-11-28.load-balancer/dns-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.stop-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.stop-relational-database-request/relational-database-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/stop-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.stop-relational-database-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.stop-relational-database-request/relational-database-snapshot-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-result/instance (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-result/instance]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/export-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.export-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/disk))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-tls-certificate-domain-status #{"SUCCESS" :pending-validation :success "FAILED" "PENDING_VALIDATION" :failed})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/network-protocol #{:tcp "udp" :all :udp "all" "tcp"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.stop-instance-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/stop-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.stop-instance-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/is-attached (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/attached-to (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.static-ip/ip-address (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/ip-address))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/static-ip (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.static-ip/arn :portkey.aws.lightsail.-2016-11-28.static-ip/is-attached :portkey.aws.lightsail.-2016-11-28.static-ip/created-at :portkey.aws.lightsail.-2016-11-28.static-ip/name :portkey.aws.lightsail.-2016-11-28.static-ip/attached-to :portkey.aws.lightsail.-2016-11-28.static-ip/location :portkey.aws.lightsail.-2016-11-28.static-ip/support-code :portkey.aws.lightsail.-2016-11-28.static-ip/resource-type :portkey.aws.lightsail.-2016-11-28.static-ip/ip-address]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancer-result/load-balancer (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancer-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancer-result/load-balancer]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.close-instance-public-ports-request/port-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.close-instance-public-ports-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/close-instance-public-ports-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.close-instance-public-ports-request/port-info :portkey.aws.lightsail.-2016-11-28.close-instance-public-ports-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/progress (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-attached-disks (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/disk-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-snapshot-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-instance-arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance-snapshot/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance-snapshot/progress :portkey.aws.lightsail.-2016-11-28.instance-snapshot/arn :portkey.aws.lightsail.-2016-11-28.instance-snapshot/created-at :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-blueprint-id :portkey.aws.lightsail.-2016-11-28.instance-snapshot/tags :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-instance-name :portkey.aws.lightsail.-2016-11-28.instance-snapshot/size-in-gb :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-bundle-id :portkey.aws.lightsail.-2016-11-28.instance-snapshot/name :portkey.aws.lightsail.-2016-11-28.instance-snapshot/location :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-attached-disks :portkey.aws.lightsail.-2016-11-28.instance-snapshot/support-code :portkey.aws.lightsail.-2016-11-28.instance-snapshot/state :portkey.aws.lightsail.-2016-11-28.instance-snapshot/from-instance-arn :portkey.aws.lightsail.-2016-11-28.instance-snapshot/resource-type]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-parameters-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-parameters-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancers-result/load-balancers (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/load-balancer-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-load-balancers-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-load-balancers-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-load-balancers-result/load-balancers :portkey.aws.lightsail.-2016-11-28.get-load-balancers-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.start-instance-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/start-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.start-instance-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.reboot-instance-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/reboot-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.reboot-instance-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.key-pair/fingerprint (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/base-64))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/key-pair (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.key-pair/name :portkey.aws.lightsail.-2016-11-28.key-pair/arn :portkey.aws.lightsail.-2016-11-28.key-pair/support-code :portkey.aws.lightsail.-2016-11-28.key-pair/created-at :portkey.aws.lightsail.-2016-11-28.key-pair/location :portkey.aws.lightsail.-2016-11-28.key-pair/resource-type :portkey.aws.lightsail.-2016-11-28.key-pair/tags :portkey.aws.lightsail.-2016-11-28.key-pair/fingerprint]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-entry-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/domain-entry))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.log-event/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.log-event/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/log-event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.log-event/created-at :portkey.aws.lightsail.-2016-11-28.log-event/message]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.tag/key (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-key))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.tag/value (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-value))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.tag/key :portkey.aws.lightsail.-2016-11-28.tag/value]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operations-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-operations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-operations-result/operations :portkey.aws.lightsail.-2016-11-28.get-operations-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.start-relational-database-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/start-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.start-relational-database-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.release-static-ip-request/static-ip-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/release-static-ip-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.release-static-ip-request/static-ip-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-result/relational-database (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-result/relational-database]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-access-details-result/access-details (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-access-details))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-access-details-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-access-details-result/access-details]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attached-disk-map (clojure.spec.alpha/map-of :portkey.aws.lightsail.-2016-11-28/resource-name :portkey.aws.lightsail.-2016-11-28/disk-map-list))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.monthly-transfer/gb-per-month-allocated (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/monthly-transfer (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.monthly-transfer/gb-per-month-allocated]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.detach-instances-from-load-balancer-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/detach-instances-from-load-balancer-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.detach-instances-from-load-balancer-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.start-instance-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/start-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.start-instance-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-instances-to-load-balancer-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-instances-to-load-balancer-request/instance-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-instances-to-load-balancer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.attach-instances-to-load-balancer-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.attach-instances-to-load-balancer-request/instance-names] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-entry-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/is-static-ip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/private-ip-address (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/ip-address))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/ssh-key-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/username (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/ipv-6-address (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/ip-v-6-address))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/hardware (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-hardware))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/networking (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-networking))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/blueprint-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/public-ip-address (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/ip-address))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.instance/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.instance/is-static-ip :portkey.aws.lightsail.-2016-11-28.instance/private-ip-address :portkey.aws.lightsail.-2016-11-28.instance/ssh-key-name :portkey.aws.lightsail.-2016-11-28.instance/arn :portkey.aws.lightsail.-2016-11-28.instance/created-at :portkey.aws.lightsail.-2016-11-28.instance/blueprint-id :portkey.aws.lightsail.-2016-11-28.instance/username :portkey.aws.lightsail.-2016-11-28.instance/tags :portkey.aws.lightsail.-2016-11-28.instance/ipv-6-address :portkey.aws.lightsail.-2016-11-28.instance/hardware :portkey.aws.lightsail.-2016-11-28.instance/name :portkey.aws.lightsail.-2016-11-28.instance/location :portkey.aws.lightsail.-2016-11-28.instance/bundle-id :portkey.aws.lightsail.-2016-11-28.instance/networking :portkey.aws.lightsail.-2016-11-28.instance/support-code :portkey.aws.lightsail.-2016-11-28.instance/state :portkey.aws.lightsail.-2016-11-28.instance/blueprint-name :portkey.aws.lightsail.-2016-11-28.instance/public-ip-address :portkey.aws.lightsail.-2016-11-28.instance/resource-type]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.open-instance-public-ports-request/port-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/port-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.open-instance-public-ports-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/open-instance-public-ports-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.open-instance-public-ports-request/port-info :portkey.aws.lightsail.-2016-11-28.open-instance-public-ports-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-platform-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance-platform))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance-snapshot))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-operation-request/operation-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-operation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-operation-request/operation-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-cloud-formation-stack-records-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-cloud-formation-stack-records-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-cloud-formation-stack-records-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-key-pair-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-key-pair-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-key-pair-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-blueprint-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/relational-database-blueprint))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-relational-database-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-relational-database-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-relational-database-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/engine-version (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/engine (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/arn :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/created-at :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-blueprint-id :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/tags :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/size-in-gb :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/name :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/location :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-name :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/support-code :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/engine-version :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/engine :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-bundle-id :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/state :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/resource-type :portkey.aws.lightsail.-2016-11-28.relational-database-snapshot/from-relational-database-arn]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-attribute-name #{:health-check-path :session-stickiness-lb-cookie-duration-seconds :session-stickiness-enabled "SessionStickiness_LB_CookieDurationSeconds" "SessionStickinessEnabled" "HealthCheckPath"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-cloud-formation-stack-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-cloud-formation-stack-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-cloud-formation-stack-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-parameters-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-relational-database-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.update-relational-database-parameters-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-info-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/disk-info))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-port-states-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-port-states-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-instance-port-states-request/instance-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/source-relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/use-latest-restorable-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/restore-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/publicly-accessible (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/relational-database-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/relational-database-bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-relational-database-from-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/source-relational-database-name :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/tags :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/use-latest-restorable-time :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/restore-time :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/availability-zone :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/publicly-accessible :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/relational-database-snapshot-name :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-request/relational-database-bundle-id]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-disks-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-disks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-disks-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-access-protocol #{:ssh :rdp "rdp" "ssh"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.attach-instances-to-load-balancer-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/attach-instances-to-load-balancer-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.attach-instances-to-load-balancer-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-relational-database-from-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-relational-database-from-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/operation-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.operation-failure-exception/code :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/docs :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/message :portkey.aws.lightsail.-2016-11-28.operation-failure-exception/tip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.destination-info/id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.destination-info/service (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/destination-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.destination-info/id :portkey.aws.lightsail.-2016-11-28.destination-info/service]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/code :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/docs :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/message :portkey.aws.lightsail.-2016-11-28.unauthenticated-exception/tip]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-request/disk-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-request/availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-request/size-in-gb (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/integer))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-disk-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-disk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-disk-request/disk-name :portkey.aws.lightsail.-2016-11-28.create-disk-request/availability-zone :portkey.aws.lightsail.-2016-11-28.create-disk-request/size-in-gb] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-disk-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.allocate-static-ip-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/allocate-static-ip-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.allocate-static-ip-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/log-stream-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/start-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/end-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/start-from-head (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-events-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/relational-database-name :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/log-stream-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/start-time :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/end-time :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/start-from-head :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/port-info-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/port-info))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-relational-database-request/skip-final-snapshot (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-relational-database-request/final-relational-database-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-relational-database-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.delete-relational-database-request/skip-final-snapshot :portkey.aws.lightsail.-2016-11-28.delete-relational-database-request/final-relational-database-snapshot-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/load-balancer-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/certificate-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/certificate-domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/certificate-alternative-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-load-balancer-tls-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/load-balancer-name :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/certificate-name :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/certificate-domain-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/certificate-alternative-names :portkey.aws.lightsail.-2016-11-28.create-load-balancer-tls-certificate-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/metric-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-metric-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/period (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-period))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/start-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/end-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/unit (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-unit))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/statistics (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-statistic-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-metric-data-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/instance-name :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/metric-name :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/period :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/start-time :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/end-time :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/unit :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-request/statistics] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-bundles-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-bundles-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-bundles-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-regions-result/regions (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/region-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-regions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-regions-result/regions]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-active-names-result/active-names (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-active-names-result/next-page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-active-names-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-active-names-result/active-names :portkey.aws.lightsail.-2016-11-28.get-active-names-result/next-page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-request/source-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/export-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.export-snapshot-request/source-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/disk-snapshot-state #{:unknown :pending :completed "error" "completed" "unknown" :error "pending"})

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/pending-modified-values (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/pending-modified-relational-database-values))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/master-endpoint (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-endpoint))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/relational-database-blueprint-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/secondary-availability-zone (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/hardware (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-hardware))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/preferred-backup-window (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/master-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/publicly-accessible (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/master-username (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/support-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/engine-version (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/engine (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/pending-maintenance-actions (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/pending-maintenance-action-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/backup-retention-enabled (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/relational-database-bundle-id (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.relational-database/latest-restorable-time (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.relational-database/pending-modified-values :portkey.aws.lightsail.-2016-11-28.relational-database/arn :portkey.aws.lightsail.-2016-11-28.relational-database/master-endpoint :portkey.aws.lightsail.-2016-11-28.relational-database/created-at :portkey.aws.lightsail.-2016-11-28.relational-database/tags :portkey.aws.lightsail.-2016-11-28.relational-database/relational-database-blueprint-id :portkey.aws.lightsail.-2016-11-28.relational-database/secondary-availability-zone :portkey.aws.lightsail.-2016-11-28.relational-database/hardware :portkey.aws.lightsail.-2016-11-28.relational-database/name :portkey.aws.lightsail.-2016-11-28.relational-database/location :portkey.aws.lightsail.-2016-11-28.relational-database/preferred-backup-window :portkey.aws.lightsail.-2016-11-28.relational-database/master-database-name :portkey.aws.lightsail.-2016-11-28.relational-database/publicly-accessible :portkey.aws.lightsail.-2016-11-28.relational-database/master-username :portkey.aws.lightsail.-2016-11-28.relational-database/support-code :portkey.aws.lightsail.-2016-11-28.relational-database/engine-version :portkey.aws.lightsail.-2016-11-28.relational-database/engine :portkey.aws.lightsail.-2016-11-28.relational-database/pending-maintenance-actions :portkey.aws.lightsail.-2016-11-28.relational-database/state :portkey.aws.lightsail.-2016-11-28.relational-database/parameter-apply-status :portkey.aws.lightsail.-2016-11-28.relational-database/backup-retention-enabled :portkey.aws.lightsail.-2016-11-28.relational-database/relational-database-bundle-id :portkey.aws.lightsail.-2016-11-28.relational-database/preferred-maintenance-window :portkey.aws.lightsail.-2016-11-28.relational-database/resource-type :portkey.aws.lightsail.-2016-11-28.relational-database/latest-restorable-time]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-result/metric-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/instance-metric-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-result/metric-data (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/metric-datapoint-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-instance-metric-data-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-result/metric-name :portkey.aws.lightsail.-2016-11-28.get-instance-metric-data-result/metric-data]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.region/continent-code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.region/description (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.region/display-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.region/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/region-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.region/availability-zones (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.region/relational-database-availability-zones (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/region (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.region/continent-code :portkey.aws.lightsail.-2016-11-28.region/description :portkey.aws.lightsail.-2016-11-28.region/display-name :portkey.aws.lightsail.-2016-11-28.region/name :portkey.aws.lightsail.-2016-11-28.region/availability-zones :portkey.aws.lightsail.-2016-11-28.region/relational-database-availability-zones]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-parameters-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-parameters-request/parameters (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/relational-database-parameter-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-relational-database-parameters-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.update-relational-database-parameters-request/relational-database-name :portkey.aws.lightsail.-2016-11-28.update-relational-database-parameters-request/parameters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-health-summary-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance-health-summary))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.password-data/ciphertext (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.password-data/key-pair-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/password-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.password-data/ciphertext :portkey.aws.lightsail.-2016-11-28.password-data/key-pair-name]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-databases-request/page-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-databases-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-databases-request/page-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-disk-snapshot-request/disk-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-disk-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-disk-snapshot-request/disk-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-request/instance-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-request/instance-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-request/tags (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-instance-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-request/instance-snapshot-name :portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-request/instance-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-request/tags]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-domain-request/domain-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/domain-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-domain-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.get-domain-request/domain-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/create-instance-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.create-instance-snapshot-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.put-instance-public-ports-result/operation (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/put-instance-public-ports-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.put-instance-public-ports-result/operation]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/instance-port-info-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/instance-port-info))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.untag-resource-request/resource-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.untag-resource-request/resource-name :portkey.aws.lightsail.-2016-11-28.untag-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/record-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/source-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/export-snapshot-record-source-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/destination-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/destination-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/export-snapshot-record (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.export-snapshot-record/name :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/arn :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/created-at :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/location :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/resource-type :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/state :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/source-info :portkey.aws.lightsail.-2016-11-28.export-snapshot-record/destination-info]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-result/resource-log-events (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/log-event-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-result/next-backward-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-result/next-forward-token (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-events-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-result/resource-log-events :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-result/next-backward-token :portkey.aws.lightsail.-2016-11-28.get-relational-database-log-events-result/next-forward-token]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/load-balancer-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/load-balancer))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/arn (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/non-empty-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/created-at (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/iso-date))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/location (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-location))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/resource-type (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/state (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/record-state))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/source-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record-source-info-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/destination-info (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/destination-info))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/cloud-formation-stack-record (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/name :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/arn :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/created-at :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/location :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/resource-type :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/state :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/source-info :portkey.aws.lightsail.-2016-11-28.cloud-formation-stack-record/destination-info]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/relational-database-list (clojure.spec.alpha/coll-of :portkey.aws.lightsail.-2016-11-28/relational-database))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/domain-entry-options (clojure.spec.alpha/map-of :portkey.aws.lightsail.-2016-11-28/domain-entry-options-keys :portkey.aws.lightsail.-2016-11-28/string))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.tag-resource-result/operations (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/operation-list))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/tag-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.tag-resource-result/operations]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/rotate-master-user-password (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/preferred-backup-window (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/relational-database-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/enable-backup-retention (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/publicly-accessible (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/disable-backup-retention (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/master-user-password (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/sensitive-string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/apply-immediately (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/boolean))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/update-relational-database-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.update-relational-database-request/relational-database-name] :opt-un [:portkey.aws.lightsail.-2016-11-28.update-relational-database-request/rotate-master-user-password :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/preferred-backup-window :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/enable-backup-retention :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/publicly-accessible :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/disable-backup-retention :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/preferred-maintenance-window :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/master-user-password :portkey.aws.lightsail.-2016-11-28.update-relational-database-request/apply-immediately]))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.delete-relational-database-snapshot-request/relational-database-snapshot-name (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/resource-name))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/delete-relational-database-snapshot-request (clojure.spec.alpha/keys :req-un [:portkey.aws.lightsail.-2016-11-28.delete-relational-database-snapshot-request/relational-database-snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/code (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/docs (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/message (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/tip (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/string))
(clojure.spec.alpha/def :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/code :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/docs :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/message :portkey.aws.lightsail.-2016-11-28.account-setup-in-progress-exception/tip]))

(clojure.core/defn tag-resource "Adds one or more tags to the specified Amazon Lightsail resource. Each resource\ncan have a maximum of 50 tags. Each tag consists of a key and an optional value.\nTag keys must be unique per resource. For more information about tags, see the\nLightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-tags).\n The tag resource operation supports tag-based access control via request tags\nand resource tags applied to the resource identified by resourceName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([tag-resource-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/tag-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/tag-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn response-tag-resource-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/tag-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/tag-resource-result))

(clojure.core/defn attach-static-ip "Attaches a static IP address to a specific Amazon Lightsail instance." ([attach-static-ip-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-attach-static-ip-request attach-static-ip-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/attach-static-ip-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/attach-static-ip-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachStaticIp", :http.request.configuration/output-deser-fn response-attach-static-ip-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef attach-static-ip :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/attach-static-ip-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/attach-static-ip-result))

(clojure.core/defn get-relational-database-snapshot "Returns information about a specific database snapshot in Amazon Lightsail." ([get-relational-database-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-snapshot-request get-relational-database-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseSnapshot", :http.request.configuration/output-deser-fn response-get-relational-database-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshot-result))

(clojure.core/defn get-operations "Returns information about all operations.\n Results are returned from oldest to newest, up to a maximum of 200. Results can\nbe paged by making each subsequent call to GetOperations use the maximum (last)\nstatusChangedAt value from the previous request." ([] (get-operations {})) ([get-operations-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-operations-request get-operations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-operations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-operations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetOperations", :http.request.configuration/output-deser-fn response-get-operations-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-operations :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-operations-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-operations-result))

(clojure.core/defn update-relational-database "Allows the update of one or more attributes of a database in Amazon Lightsail.\n Updates are applied immediately, or in cases where the updates could result in\nan outage, are applied during the database's predefined maintenance window.\n The update relational database operation supports tag-based access control via\nresource tags applied to the resource identified by relationalDatabaseName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([update-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-relational-database-request update-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/update-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/update-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRelationalDatabase", :http.request.configuration/output-deser-fn response-update-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef update-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/update-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/update-relational-database-result))

(clojure.core/defn get-operations-for-resource "Gets operations for a specific resource (e.g., an instance or a static IP)." ([get-operations-for-resource-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-operations-for-resource-request get-operations-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-operations-for-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-operations-for-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetOperationsForResource", :http.request.configuration/output-deser-fn response-get-operations-for-resource-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-operations-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-operations-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-operations-for-resource-result))

(clojure.core/defn get-load-balancer-tls-certificates "Returns information about the TLS certificates that are associated with the\nspecified Lightsail load balancer.\n TLS is just an updated, more secure version of Secure Socket Layer (SSL).\n You can have a maximum of 2 certificates associated with a Lightsail load\nbalancer. One is active and the other is inactive." ([get-load-balancer-tls-certificates-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-load-balancer-tls-certificates-request get-load-balancer-tls-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancer-tls-certificates-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancer-tls-certificates-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLoadBalancerTlsCertificates", :http.request.configuration/output-deser-fn response-get-load-balancer-tls-certificates-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-load-balancer-tls-certificates :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-load-balancer-tls-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-load-balancer-tls-certificates-result))

(clojure.core/defn start-instance "Starts a specific Amazon Lightsail instance from a stopped state. To restart an\ninstance, use the reboot instance operation.\n When you start a stopped instance, Lightsail assigns a new public IP address to\nthe instance. To use the same IP address after stopping and starting an\ninstance, create a static IP address and attach it to the instance. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/lightsail-create-static-ip).\n The start instance operation supports tag-based access control via resource\ntags applied to the resource identified by instanceName. For more information,\nsee the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([start-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-start-instance-request start-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/start-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/start-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartInstance", :http.request.configuration/output-deser-fn response-start-instance-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef start-instance :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/start-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/start-instance-result))

(clojure.core/defn get-load-balancers "Returns information about all load balancers in an account.\n If you are describing a long list of load balancers, you can paginate the\noutput to make the list more manageable. You can use the pageToken and\nnextPageToken values to retrieve the next items in the list." ([] (get-load-balancers {})) ([get-load-balancers-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-load-balancers-request get-load-balancers-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancers-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancers-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLoadBalancers", :http.request.configuration/output-deser-fn response-get-load-balancers-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-load-balancers :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-load-balancers-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-load-balancers-result))

(clojure.core/defn delete-key-pair "Deletes a specific SSH key pair.\n The delete key pair operation supports tag-based access control via resource\ntags applied to the resource identified by keyPairName. For more information,\nsee the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-key-pair-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-key-pair-request delete-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-key-pair-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-key-pair-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteKeyPair", :http.request.configuration/output-deser-fn response-delete-key-pair-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-key-pair-result))

(clojure.core/defn put-instance-public-ports "Sets the specified open ports for an Amazon Lightsail instance, and closes all\nports for every protocol not included in the current request.\n The put instance public ports operation supports tag-based access control via\nresource tags applied to the resource identified by instanceName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([put-instance-public-ports-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-put-instance-public-ports-request put-instance-public-ports-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/put-instance-public-ports-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/put-instance-public-ports-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutInstancePublicPorts", :http.request.configuration/output-deser-fn response-put-instance-public-ports-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef put-instance-public-ports :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/put-instance-public-ports-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/put-instance-public-ports-result))

(clojure.core/defn get-static-ip "Returns information about a specific static IP." ([get-static-ip-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-static-ip-request get-static-ip-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-static-ip-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-static-ip-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetStaticIp", :http.request.configuration/output-deser-fn response-get-static-ip-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-static-ip :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-static-ip-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-static-ip-result))

(clojure.core/defn get-domain "Returns information about a specific domain recordset." ([get-domain-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-domain-request get-domain-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-domain-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-domain-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDomain", :http.request.configuration/output-deser-fn response-get-domain-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-domain :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-domain-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-domain-result))

(clojure.core/defn get-operation "Returns information about a specific operation. Operations include events such\nas when you create an instance, allocate a static IP, attach a static IP, and so\non." ([get-operation-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-operation-request get-operation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-operation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-operation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetOperation", :http.request.configuration/output-deser-fn response-get-operation-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-operation :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-operation-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-operation-result))

(clojure.core/defn get-relational-database "Returns information about a specific database in Amazon Lightsail." ([get-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-request get-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabase", :http.request.configuration/output-deser-fn response-get-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-result))

(clojure.core/defn peer-vpc "Tries to peer the Lightsail VPC with the user's default VPC." ([] (peer-vpc {})) ([peer-vpc-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-peer-vpc-request peer-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/peer-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/peer-vpc-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PeerVpc", :http.request.configuration/output-deser-fn response-peer-vpc-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef peer-vpc :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/peer-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/peer-vpc-result))

(clojure.core/defn create-instances-from-snapshot "Uses a specific snapshot as a blueprint for creating one or more new instances\nthat are based on that identical configuration.\n The create instances from snapshot operation supports tag-based access control\nvia request tags and resource tags applied to the resource identified by\ninstanceSnapshotName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-instances-from-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-instances-from-snapshot-request create-instances-from-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-instances-from-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-instances-from-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateInstancesFromSnapshot", :http.request.configuration/output-deser-fn response-create-instances-from-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-instances-from-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-instances-from-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-instances-from-snapshot-result))

(clojure.core/defn reboot-instance "Restarts a specific instance.\n The reboot instance operation supports tag-based access control via resource\ntags applied to the resource identified by instanceName. For more information,\nsee the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([reboot-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-reboot-instance-request reboot-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/reboot-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/reboot-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RebootInstance", :http.request.configuration/output-deser-fn response-reboot-instance-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef reboot-instance :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/reboot-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/reboot-instance-result))

(clojure.core/defn delete-domain-entry "Deletes a specific domain entry.\n The delete domain entry operation supports tag-based access control via\nresource tags applied to the resource identified by domainName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-domain-entry-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-domain-entry-request delete-domain-entry-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-domain-entry-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-domain-entry-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDomainEntry", :http.request.configuration/output-deser-fn response-delete-domain-entry-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-domain-entry :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-domain-entry-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-domain-entry-result))

(clojure.core/defn delete-relational-database-snapshot "Deletes a database snapshot in Amazon Lightsail.\n The delete relational database snapshot operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nrelationalDatabaseName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-relational-database-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-relational-database-snapshot-request delete-relational-database-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-relational-database-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-relational-database-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRelationalDatabaseSnapshot", :http.request.configuration/output-deser-fn response-delete-relational-database-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-relational-database-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-relational-database-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-relational-database-snapshot-result))

(clojure.core/defn delete-load-balancer "Deletes a Lightsail load balancer and all its associated SSL/TLS certificates.\nOnce the load balancer is deleted, you will need to create a new load balancer,\ncreate a new certificate, and verify domain ownership again.\n The delete load balancer operation supports tag-based access control via\nresource tags applied to the resource identified by loadBalancerName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-load-balancer-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-load-balancer-request delete-load-balancer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteLoadBalancer", :http.request.configuration/output-deser-fn response-delete-load-balancer-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-load-balancer :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-result))

(clojure.core/defn stop-relational-database "Stops a specific database that is currently running in Amazon Lightsail.\n The stop relational database operation supports tag-based access control via\nresource tags applied to the resource identified by relationalDatabaseName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([stop-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-stop-relational-database-request stop-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/stop-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/stop-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopRelationalDatabase", :http.request.configuration/output-deser-fn response-stop-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef stop-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/stop-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/stop-relational-database-result))

(clojure.core/defn stop-instance "Stops a specific Amazon Lightsail instance that is currently running.\n When you start a stopped instance, Lightsail assigns a new public IP address to\nthe instance. To use the same IP address after stopping and starting an\ninstance, create a static IP address and attach it to the instance. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/lightsail-create-static-ip).\n The stop instance operation supports tag-based access control via resource tags\napplied to the resource identified by instanceName. For more information, see\nthe Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([stop-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-stop-instance-request stop-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/stop-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/stop-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopInstance", :http.request.configuration/output-deser-fn response-stop-instance-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef stop-instance :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/stop-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/stop-instance-result))

(clojure.core/defn get-key-pair "Returns information about a specific key pair." ([get-key-pair-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-key-pair-request get-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-key-pair-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-key-pair-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetKeyPair", :http.request.configuration/output-deser-fn response-get-key-pair-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-key-pair-result))

(clojure.core/defn get-cloud-formation-stack-records "Returns the CloudFormation stack record created as a result of the create cloud\nformation stack operation.\n An AWS CloudFormation stack is used to create a new Amazon EC2 instance from an\nexported Lightsail snapshot." ([] (get-cloud-formation-stack-records {})) ([get-cloud-formation-stack-records-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-cloud-formation-stack-records-request get-cloud-formation-stack-records-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-cloud-formation-stack-records-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-cloud-formation-stack-records-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCloudFormationStackRecords", :http.request.configuration/output-deser-fn response-get-cloud-formation-stack-records-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-cloud-formation-stack-records :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-cloud-formation-stack-records-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-cloud-formation-stack-records-result))

(clojure.core/defn attach-disk "Attaches a block storage disk to a running or stopped Lightsail instance and\nexposes it to the instance with the specified disk name.\n The attach disk operation supports tag-based access control via resource tags\napplied to the resource identified by diskName. For more information, see the\nLightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([attach-disk-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-attach-disk-request attach-disk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/attach-disk-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/attach-disk-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachDisk", :http.request.configuration/output-deser-fn response-attach-disk-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef attach-disk :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/attach-disk-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/attach-disk-result))

(clojure.core/defn import-key-pair "Imports a public SSH key from a specific key pair." ([import-key-pair-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-import-key-pair-request import-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/import-key-pair-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/import-key-pair-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportKeyPair", :http.request.configuration/output-deser-fn response-import-key-pair-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef import-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/import-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/import-key-pair-result))

(clojure.core/defn get-blueprints "Returns the list of available instance images, or blueprints. You can use a\nblueprint to create a new virtual private server already running a specific\noperating system, as well as a preinstalled app or development stack. The\nsoftware each instance is running depends on the blueprint image you choose." ([] (get-blueprints {})) ([get-blueprints-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-blueprints-request get-blueprints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-blueprints-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-blueprints-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBlueprints", :http.request.configuration/output-deser-fn response-get-blueprints-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-blueprints :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-blueprints-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-blueprints-result))

(clojure.core/defn get-relational-database-bundles "Returns the list of bundles that are available in Amazon Lightsail. A bundle\ndescribes the performance specifications for a database.\n You can use a bundle ID to create a new database with explicit performance\nspecifications." ([] (get-relational-database-bundles {})) ([get-relational-database-bundles-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-bundles-request get-relational-database-bundles-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-bundles-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-bundles-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseBundles", :http.request.configuration/output-deser-fn response-get-relational-database-bundles-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-bundles :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-relational-database-bundles-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-bundles-result))

(clojure.core/defn unpeer-vpc "Attempts to unpeer the Lightsail VPC from the user's default VPC." ([] (unpeer-vpc {})) ([unpeer-vpc-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-unpeer-vpc-request unpeer-vpc-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/unpeer-vpc-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/unpeer-vpc-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UnpeerVpc", :http.request.configuration/output-deser-fn response-unpeer-vpc-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef unpeer-vpc :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/unpeer-vpc-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/unpeer-vpc-result))

(clojure.core/defn create-disk-from-snapshot "Creates a block storage disk from a disk snapshot that can be attached to a\nLightsail instance in the same Availability Zone (e.g., us-east-2a). The disk is\ncreated in the regional endpoint that you send the HTTP request to. For more\ninformation, see Regions and Availability Zones in Lightsail\n(https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail).\n The create disk from snapshot operation supports tag-based access control via\nrequest tags and resource tags applied to the resource identified by\ndiskSnapshotName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-disk-from-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-disk-from-snapshot-request create-disk-from-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-disk-from-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-disk-from-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDiskFromSnapshot", :http.request.configuration/output-deser-fn response-create-disk-from-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-disk-from-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-disk-from-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-disk-from-snapshot-result))

(clojure.core/defn create-instance-snapshot "Creates a snapshot of a specific virtual private server, or instance. You can\nuse a snapshot to create a new instance that is based on that snapshot.\n The create instance snapshot operation supports tag-based access control via\nrequest tags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-instance-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-instance-snapshot-request create-instance-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-instance-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-instance-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateInstanceSnapshot", :http.request.configuration/output-deser-fn response-create-instance-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-instance-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-instance-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-instance-snapshot-result))

(clojure.core/defn get-instance "Returns information about a specific Amazon Lightsail instance, which is a\nvirtual private server." ([get-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-request get-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstance", :http.request.configuration/output-deser-fn response-get-instance-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-result))

(clojure.core/defn get-disk "Returns information about a specific block storage disk." ([get-disk-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-disk-request get-disk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-disk-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-disk-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDisk", :http.request.configuration/output-deser-fn response-get-disk-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-disk :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-disk-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-disk-result))

(clojure.core/defn get-instance-state "Returns the state of a specific instance. Works on one instance at a time." ([get-instance-state-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-state-request get-instance-state-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-state-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-state-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstanceState", :http.request.configuration/output-deser-fn response-get-instance-state-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance-state :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-instance-state-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-state-result))

(clojure.core/defn update-domain-entry "Updates a domain recordset after it is created.\n The update domain entry operation supports tag-based access control via\nresource tags applied to the resource identified by domainName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([update-domain-entry-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-domain-entry-request update-domain-entry-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/update-domain-entry-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/update-domain-entry-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDomainEntry", :http.request.configuration/output-deser-fn response-update-domain-entry-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef update-domain-entry :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/update-domain-entry-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/update-domain-entry-result))

(clojure.core/defn create-relational-database-snapshot "Creates a snapshot of your database in Amazon Lightsail. You can use snapshots\nfor backups, to make copies of a database, and to save data before deleting a\ndatabase.\n The create relational database snapshot operation supports tag-based access\ncontrol via request tags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-relational-database-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-relational-database-snapshot-request create-relational-database-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-relational-database-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-relational-database-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRelationalDatabaseSnapshot", :http.request.configuration/output-deser-fn response-create-relational-database-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-relational-database-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-relational-database-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-relational-database-snapshot-result))

(clojure.core/defn create-relational-database "Creates a new database in Amazon Lightsail.\n The create relational database operation supports tag-based access control via\nrequest tags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-relational-database-request create-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRelationalDatabase", :http.request.configuration/output-deser-fn response-create-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-relational-database-result))

(clojure.core/defn update-relational-database-parameters "Allows the update of one or more parameters of a database in Amazon Lightsail.\n Parameter updates don't cause outages; therefore, their application is not\nsubject to the preferred maintenance window. However, there are two ways in\nwhich paramater updates are applied: dynamic or pending-reboot. Parameters\nmarked with a dynamic apply type are applied immediately. Parameters marked with\na pending-reboot apply type are applied only after the database is rebooted\nusing the reboot relational database operation.\n The update relational database parameters operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nrelationalDatabaseName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([update-relational-database-parameters-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-relational-database-parameters-request update-relational-database-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/update-relational-database-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/update-relational-database-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRelationalDatabaseParameters", :http.request.configuration/output-deser-fn response-update-relational-database-parameters-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef update-relational-database-parameters :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/update-relational-database-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/update-relational-database-parameters-result))

(clojure.core/defn get-load-balancer-metric-data "Returns information about health metrics for your Lightsail load balancer." ([get-load-balancer-metric-data-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-load-balancer-metric-data-request get-load-balancer-metric-data-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancer-metric-data-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancer-metric-data-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLoadBalancerMetricData", :http.request.configuration/output-deser-fn response-get-load-balancer-metric-data-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-load-balancer-metric-data :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-load-balancer-metric-data-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-load-balancer-metric-data-result))

(clojure.core/defn allocate-static-ip "Allocates a static IP address." ([allocate-static-ip-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-allocate-static-ip-request allocate-static-ip-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/allocate-static-ip-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/allocate-static-ip-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AllocateStaticIp", :http.request.configuration/output-deser-fn response-allocate-static-ip-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef allocate-static-ip :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/allocate-static-ip-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/allocate-static-ip-result))

(clojure.core/defn create-load-balancer "Creates a Lightsail load balancer. To learn more about deciding whether to load\nbalance your application, see Configure your Lightsail instances for load\nbalancing\n(https://lightsail.aws.amazon.com/ls/docs/how-to/article/configure-lightsail-instances-for-load-balancing).\nYou can create up to 5 load balancers per AWS Region in your account.\n When you create a load balancer, you can specify a unique name and port\nsettings. To change additional load balancer settings, use the\nUpdateLoadBalancerAttribute operation.\n The create load balancer operation supports tag-based access control via\nrequest tags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-load-balancer-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-load-balancer-request create-load-balancer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-load-balancer-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-load-balancer-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateLoadBalancer", :http.request.configuration/output-deser-fn response-create-load-balancer-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-load-balancer :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-load-balancer-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-load-balancer-result))

(clojure.core/defn attach-instances-to-load-balancer "Attaches one or more Lightsail instances to a load balancer.\n After some time, the instances are attached to the load balancer and the health\ncheck status is available.\n The attach instances to load balancer operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nloadBalancerName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([attach-instances-to-load-balancer-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-attach-instances-to-load-balancer-request attach-instances-to-load-balancer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/attach-instances-to-load-balancer-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/attach-instances-to-load-balancer-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachInstancesToLoadBalancer", :http.request.configuration/output-deser-fn response-attach-instances-to-load-balancer-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef attach-instances-to-load-balancer :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/attach-instances-to-load-balancer-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/attach-instances-to-load-balancer-result))

(clojure.core/defn export-snapshot "Exports an Amazon Lightsail instance or block storage disk snapshot to Amazon\nElastic Compute Cloud (Amazon EC2). This operation results in an export snapshot\nrecord that can be used with the create cloud formation stack operation to\ncreate new Amazon EC2 instances.\n Exported instance snapshots appear in Amazon EC2 as Amazon Machine Images\n(AMIs), and the instance system disk appears as an Amazon Elastic Block Store\n(Amazon EBS) volume. Exported disk snapshots appear in Amazon EC2 as Amazon EBS\nvolumes. Snapshots are exported to the same Amazon Web Services Region in Amazon\nEC2 as the source Lightsail snapshot.\n The export snapshot operation supports tag-based access control via resource\ntags applied to the resource identified by sourceSnapshotName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags).\n Use the get instance snapshots or get disk snapshots operations to get a list\nof snapshots that you can export to Amazon EC2." ([export-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-export-snapshot-request export-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/export-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/export-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ExportSnapshot", :http.request.configuration/output-deser-fn response-export-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef export-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/export-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/export-snapshot-result))

(clojure.core/defn get-domains "Returns a list of all domains in the user's account." ([] (get-domains {})) ([get-domains-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-domains-request get-domains-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-domains-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-domains-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDomains", :http.request.configuration/output-deser-fn response-get-domains-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-domains :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-domains-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-domains-result))

(clojure.core/defn get-relational-database-parameters "Returns all of the runtime parameters offered by the underlying database\nsoftware, or engine, for a specific database in Amazon Lightsail.\n In addition to the parameter names and values, this operation returns other\ninformation about each parameter. This information includes whether changes\nrequire a reboot, whether the parameter is modifiable, the allowed values, and\nthe data types." ([get-relational-database-parameters-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-parameters-request get-relational-database-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseParameters", :http.request.configuration/output-deser-fn response-get-relational-database-parameters-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-parameters :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-parameters-result))

(clojure.core/defn create-disk "Creates a block storage disk that can be attached to a Lightsail instance in the\nsame Availability Zone (e.g., us-east-2a). The disk is created in the regional\nendpoint that you send the HTTP request to. For more information, see Regions\nand Availability Zones in Lightsail\n(https://lightsail.aws.amazon.com/ls/docs/overview/article/understanding-regions-and-availability-zones-in-amazon-lightsail).\n The create disk operation supports tag-based access control via request tags.\nFor more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-disk-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-disk-request create-disk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-disk-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-disk-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDisk", :http.request.configuration/output-deser-fn response-create-disk-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-disk :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-disk-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-disk-result))

(clojure.core/defn update-load-balancer-attribute "Updates the specified attribute for a load balancer. You can only update one\nattribute at a time.\n The update load balancer attribute operation supports tag-based access control\nvia resource tags applied to the resource identified by loadBalancerName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([update-load-balancer-attribute-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-load-balancer-attribute-request update-load-balancer-attribute-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/update-load-balancer-attribute-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/update-load-balancer-attribute-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateLoadBalancerAttribute", :http.request.configuration/output-deser-fn response-update-load-balancer-attribute-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef update-load-balancer-attribute :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/update-load-balancer-attribute-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/update-load-balancer-attribute-result))

(clojure.core/defn create-cloud-formation-stack "Creates an AWS CloudFormation stack, which creates a new Amazon EC2 instance\nfrom an exported Amazon Lightsail snapshot. This operation results in a\nCloudFormation stack record that can be used to track the AWS CloudFormation\nstack created. Use the get cloud formation stack records operation to get a list\nof the CloudFormation stacks created.\n Wait until after your new Amazon EC2 instance is created before running the\ncreate cloud formation stack operation again with the same export snapshot\nrecord." ([create-cloud-formation-stack-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-cloud-formation-stack-request create-cloud-formation-stack-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-cloud-formation-stack-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-cloud-formation-stack-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCloudFormationStack", :http.request.configuration/output-deser-fn response-create-cloud-formation-stack-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-cloud-formation-stack :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-cloud-formation-stack-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-cloud-formation-stack-result))

(clojure.core/defn reboot-relational-database "Restarts a specific database in Amazon Lightsail.\n The reboot relational database operation supports tag-based access control via\nresource tags applied to the resource identified by relationalDatabaseName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([reboot-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-reboot-relational-database-request reboot-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/reboot-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/reboot-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RebootRelationalDatabase", :http.request.configuration/output-deser-fn response-reboot-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef reboot-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/reboot-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/reboot-relational-database-result))

(clojure.core/defn create-relational-database-from-snapshot "Creates a new database from an existing database snapshot in Amazon Lightsail.\n You can create a new database from a snapshot in if something goes wrong with\nyour original database, or to change it to a different plan, such as a high\navailability or standard plan.\n The create relational database from snapshot operation supports tag-based\naccess control via request tags and resource tags applied to the resource\nidentified by relationalDatabaseSnapshotName. For more information, see the\nLightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-relational-database-from-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-relational-database-from-snapshot-request create-relational-database-from-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-relational-database-from-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-relational-database-from-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRelationalDatabaseFromSnapshot", :http.request.configuration/output-deser-fn response-create-relational-database-from-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-relational-database-from-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-relational-database-from-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-relational-database-from-snapshot-result))

(clojure.core/defn create-domain "Creates a domain resource for the specified domain (e.g., example.com).\n The create domain operation supports tag-based access control via request tags.\nFor more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-domain-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-domain-request create-domain-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-domain-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-domain-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDomain", :http.request.configuration/output-deser-fn response-create-domain-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-domain :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-domain-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-domain-result))

(clojure.core/defn get-instance-access-details "Returns temporary SSH keys you can use to connect to a specific virtual private\nserver, or instance.\n The get instance access details operation supports tag-based access control via\nresource tags applied to the resource identified by instanceName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([get-instance-access-details-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-access-details-request get-instance-access-details-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-access-details-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-access-details-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstanceAccessDetails", :http.request.configuration/output-deser-fn response-get-instance-access-details-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance-access-details :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-instance-access-details-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-access-details-result))

(clojure.core/defn get-key-pairs "Returns information about all key pairs in the user's account." ([] (get-key-pairs {})) ([get-key-pairs-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-key-pairs-request get-key-pairs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-key-pairs-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-key-pairs-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetKeyPairs", :http.request.configuration/output-deser-fn response-get-key-pairs-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-key-pairs :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-key-pairs-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-key-pairs-result))

(clojure.core/defn get-instance-port-states "Returns the port states for a specific virtual private server, or instance." ([get-instance-port-states-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-port-states-request get-instance-port-states-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-port-states-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-port-states-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstancePortStates", :http.request.configuration/output-deser-fn response-get-instance-port-states-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance-port-states :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-instance-port-states-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-port-states-result))

(clojure.core/defn get-disks "Returns information about all block storage disks in your AWS account and\nregion.\n If you are describing a long list of disks, you can paginate the output to make\nthe list more manageable. You can use the pageToken and nextPageToken values to\nretrieve the next items in the list." ([] (get-disks {})) ([get-disks-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-disks-request get-disks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-disks-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-disks-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDisks", :http.request.configuration/output-deser-fn response-get-disks-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-disks :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-disks-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-disks-result))

(clojure.core/defn get-relational-database-log-events "Returns a list of log events for a database in Amazon Lightsail." ([get-relational-database-log-events-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-log-events-request get-relational-database-log-events-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-events-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-events-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseLogEvents", :http.request.configuration/output-deser-fn response-get-relational-database-log-events-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-log-events :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-events-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-events-result))

(clojure.core/defn delete-disk "Deletes the specified block storage disk. The disk must be in the available\nstate (not attached to a Lightsail instance).\n The disk may remain in the deleting state for several minutes.\n The delete disk operation supports tag-based access control via resource tags\napplied to the resource identified by diskName. For more information, see the\nLightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-disk-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-disk-request delete-disk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-disk-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-disk-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDisk", :http.request.configuration/output-deser-fn response-delete-disk-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-disk :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-disk-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-disk-result))

(clojure.core/defn release-static-ip "Deletes a specific static IP from your account." ([release-static-ip-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-release-static-ip-request release-static-ip-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/release-static-ip-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/release-static-ip-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReleaseStaticIp", :http.request.configuration/output-deser-fn response-release-static-ip-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef release-static-ip :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/release-static-ip-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/release-static-ip-result))

(clojure.core/defn create-disk-snapshot "Creates a snapshot of a block storage disk. You can use snapshots for backups,\nto make copies of disks, and to save data before shutting down a Lightsail\ninstance.\n You can take a snapshot of an attached disk that is in use; however, snapshots\nonly capture data that has been written to your disk at the time the snapshot\ncommand is issued. This may exclude any data that has been cached by any\napplications or the operating system. If you can pause any file systems on the\ndisk long enough to take a snapshot, your snapshot should be complete.\nNevertheless, if you cannot pause all file writes to the disk, you should\nunmount the disk from within the Lightsail instance, issue the create disk\nsnapshot command, and then remount the disk to ensure a consistent and complete\nsnapshot. You may remount and use your disk while the snapshot status is\npending.\n You can also use this operation to create a snapshot of an instance's system\nvolume. You might want to do this, for example, to recover data from the system\nvolume of a botched instance or to create a backup of the system volume like you\nwould for a block storage disk. To create a snapshot of a system volume, just\ndefine the instance name parameter when issuing the snapshot command, and a\nsnapshot of the defined instance's system volume will be created. After the\nsnapshot is available, you can create a block storage disk from the snapshot and\nattach it to a running instance to access the data on the disk.\n The create disk snapshot operation supports tag-based access control via\nrequest tags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-disk-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-disk-snapshot-request create-disk-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-disk-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-disk-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDiskSnapshot", :http.request.configuration/output-deser-fn response-create-disk-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-disk-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-disk-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-disk-snapshot-result))

(clojure.core/defn get-export-snapshot-records "Returns the export snapshot record created as a result of the export snapshot\noperation.\n An export snapshot record can be used to create a new Amazon EC2 instance and\nits related resources with the create cloud formation stack operation." ([] (get-export-snapshot-records {})) ([get-export-snapshot-records-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-export-snapshot-records-request get-export-snapshot-records-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-export-snapshot-records-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-export-snapshot-records-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetExportSnapshotRecords", :http.request.configuration/output-deser-fn response-get-export-snapshot-records-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-export-snapshot-records :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-export-snapshot-records-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-export-snapshot-records-result))

(clojure.core/defn detach-instances-from-load-balancer "Detaches the specified instances from a Lightsail load balancer.\n This operation waits until the instances are no longer needed before they are\ndetached from the load balancer.\n The detach instances from load balancer operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nloadBalancerName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([detach-instances-from-load-balancer-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-detach-instances-from-load-balancer-request detach-instances-from-load-balancer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/detach-instances-from-load-balancer-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/detach-instances-from-load-balancer-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachInstancesFromLoadBalancer", :http.request.configuration/output-deser-fn response-detach-instances-from-load-balancer-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef detach-instances-from-load-balancer :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/detach-instances-from-load-balancer-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/detach-instances-from-load-balancer-result))

(clojure.core/defn get-relational-database-snapshots "Returns information about all of your database snapshots in Amazon Lightsail." ([] (get-relational-database-snapshots {})) ([get-relational-database-snapshots-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-snapshots-request get-relational-database-snapshots-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshots-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshots-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseSnapshots", :http.request.configuration/output-deser-fn response-get-relational-database-snapshots-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-snapshots :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshots-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-snapshots-result))

(clojure.core/defn delete-instance-snapshot "Deletes a specific snapshot of a virtual private server (or instance).\n The delete instance snapshot operation supports tag-based access control via\nresource tags applied to the resource identified by instanceSnapshotName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-instance-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-instance-snapshot-request delete-instance-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-instance-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-instance-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteInstanceSnapshot", :http.request.configuration/output-deser-fn response-delete-instance-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-instance-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-instance-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-instance-snapshot-result))

(clojure.core/defn create-load-balancer-tls-certificate "Creates a Lightsail load balancer TLS certificate.\n TLS is just an updated, more secure version of Secure Socket Layer (SSL).\n The create load balancer tls certificate operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nloadBalancerName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-load-balancer-tls-certificate-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-load-balancer-tls-certificate-request create-load-balancer-tls-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-load-balancer-tls-certificate-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-load-balancer-tls-certificate-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateLoadBalancerTlsCertificate", :http.request.configuration/output-deser-fn response-create-load-balancer-tls-certificate-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-load-balancer-tls-certificate :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-load-balancer-tls-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-load-balancer-tls-certificate-result))

(clojure.core/defn delete-disk-snapshot "Deletes the specified disk snapshot.\n When you make periodic snapshots of a disk, the snapshots are incremental, and\nonly the blocks on the device that have changed since your last snapshot are\nsaved in the new snapshot. When you delete a snapshot, only the data not needed\nfor any other snapshot is removed. So regardless of which prior snapshots have\nbeen deleted, all active snapshots will have access to all the information\nneeded to restore the disk.\n The delete disk snapshot operation supports tag-based access control via\nresource tags applied to the resource identified by diskSnapshotName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-disk-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-disk-snapshot-request delete-disk-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-disk-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-disk-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDiskSnapshot", :http.request.configuration/output-deser-fn response-delete-disk-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-disk-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-disk-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-disk-snapshot-result))

(clojure.core/defn create-instances "Creates one or more Amazon Lightsail virtual private servers, or instances.\nCreate instances using active blueprints. Inactive blueprints are listed to\nsupport customers with existing instances but are not necessarily available for\nlaunch of new instances. Blueprints are marked inactive when they become\noutdated due to operating system updates or new application releases. Use the\nget blueprints operation to return a list of available blueprints.\n The create instances operation supports tag-based access control via request\ntags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-instances-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-instances-request create-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-instances-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateInstances", :http.request.configuration/output-deser-fn response-create-instances-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-instances :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-instances-result))

(clojure.core/defn get-instance-snapshot "Returns information about a specific instance snapshot." ([get-instance-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-snapshot-request get-instance-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstanceSnapshot", :http.request.configuration/output-deser-fn response-get-instance-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-instance-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-snapshot-result))

(clojure.core/defn start-relational-database "Starts a specific database from a stopped state in Amazon Lightsail. To restart\na database, use the reboot relational database operation.\n The start relational database operation supports tag-based access control via\nresource tags applied to the resource identified by relationalDatabaseName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([start-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-start-relational-database-request start-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/start-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/start-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartRelationalDatabase", :http.request.configuration/output-deser-fn response-start-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef start-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/start-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/start-relational-database-result))

(clojure.core/defn close-instance-public-ports "Closes the public ports on a specific Amazon Lightsail instance.\n The close instance public ports operation supports tag-based access control via\nresource tags applied to the resource identified by instanceName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([close-instance-public-ports-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-close-instance-public-ports-request close-instance-public-ports-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/close-instance-public-ports-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/close-instance-public-ports-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CloseInstancePublicPorts", :http.request.configuration/output-deser-fn response-close-instance-public-ports-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef close-instance-public-ports :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/close-instance-public-ports-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/close-instance-public-ports-result))

(clojure.core/defn copy-snapshot "Copies an instance or disk snapshot from one AWS Region to another in Amazon\nLightsail." ([copy-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-copy-snapshot-request copy-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/copy-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/copy-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CopySnapshot", :http.request.configuration/output-deser-fn response-copy-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef copy-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/copy-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/copy-snapshot-result))

(clojure.core/defn get-relational-database-metric-data "Returns the data points of the specified metric for a database in Amazon\nLightsail." ([get-relational-database-metric-data-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-metric-data-request get-relational-database-metric-data-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-metric-data-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-metric-data-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseMetricData", :http.request.configuration/output-deser-fn response-get-relational-database-metric-data-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-metric-data :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-metric-data-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-metric-data-result))

(clojure.core/defn get-disk-snapshots "Returns information about all block storage disk snapshots in your AWS account\nand region.\n If you are describing a long list of disk snapshots, you can paginate the\noutput to make the list more manageable. You can use the pageToken and\nnextPageToken values to retrieve the next items in the list." ([] (get-disk-snapshots {})) ([get-disk-snapshots-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-disk-snapshots-request get-disk-snapshots-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-disk-snapshots-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-disk-snapshots-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDiskSnapshots", :http.request.configuration/output-deser-fn response-get-disk-snapshots-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-disk-snapshots :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-disk-snapshots-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-disk-snapshots-result))

(clojure.core/defn get-disk-snapshot "Returns information about a specific block storage disk snapshot." ([get-disk-snapshot-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-disk-snapshot-request get-disk-snapshot-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-disk-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-disk-snapshot-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDiskSnapshot", :http.request.configuration/output-deser-fn response-get-disk-snapshot-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-disk-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-disk-snapshot-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-disk-snapshot-result))

(clojure.core/defn untag-resource "Deletes the specified set of tag keys and their values from the specified Amazon\nLightsail resource.\n The untag resource operation supports tag-based access control via request tags\nand resource tags applied to the resource identified by resourceName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([untag-resource-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/untag-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/untag-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn response-untag-resource-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/untag-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/untag-resource-result))

(clojure.core/defn get-relational-database-blueprints "Returns a list of available database blueprints in Amazon Lightsail. A blueprint\ndescribes the major engine version of a database.\n You can use a blueprint ID to create a new database that runs a specific\ndatabase engine." ([] (get-relational-database-blueprints {})) ([get-relational-database-blueprints-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-blueprints-request get-relational-database-blueprints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-blueprints-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-blueprints-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseBlueprints", :http.request.configuration/output-deser-fn response-get-relational-database-blueprints-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-blueprints :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-relational-database-blueprints-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-blueprints-result))

(clojure.core/defn get-static-ips "Returns information about all static IPs in the user's account." ([] (get-static-ips {})) ([get-static-ips-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-static-ips-request get-static-ips-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-static-ips-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-static-ips-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetStaticIps", :http.request.configuration/output-deser-fn response-get-static-ips-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-static-ips :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-static-ips-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-static-ips-result))

(clojure.core/defn open-instance-public-ports "Adds public ports to an Amazon Lightsail instance.\n The open instance public ports operation supports tag-based access control via\nresource tags applied to the resource identified by instanceName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([open-instance-public-ports-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-open-instance-public-ports-request open-instance-public-ports-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/open-instance-public-ports-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/open-instance-public-ports-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "OpenInstancePublicPorts", :http.request.configuration/output-deser-fn response-open-instance-public-ports-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef open-instance-public-ports :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/open-instance-public-ports-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/open-instance-public-ports-result))

(clojure.core/defn get-bundles "Returns the list of bundles that are available for purchase. A bundle describes\nthe specs for your virtual private server (or instance)." ([] (get-bundles {})) ([get-bundles-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-bundles-request get-bundles-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-bundles-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-bundles-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBundles", :http.request.configuration/output-deser-fn response-get-bundles-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-bundles :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-bundles-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-bundles-result))

(clojure.core/defn attach-load-balancer-tls-certificate "Attaches a Transport Layer Security (TLS) certificate to your load balancer. TLS\nis just an updated, more secure version of Secure Socket Layer (SSL).\n Once you create and validate your certificate, you can attach it to your load\nbalancer. You can also use this API to rotate the certificates on your account.\nUse the AttachLoadBalancerTlsCertificate operation with the non-attached\ncertificate, and it will replace the existing one and become the attached\ncertificate.\n The attach load balancer tls certificate operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nloadBalancerName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([attach-load-balancer-tls-certificate-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-attach-load-balancer-tls-certificate-request attach-load-balancer-tls-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/attach-load-balancer-tls-certificate-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/attach-load-balancer-tls-certificate-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachLoadBalancerTlsCertificate", :http.request.configuration/output-deser-fn response-attach-load-balancer-tls-certificate-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef attach-load-balancer-tls-certificate :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/attach-load-balancer-tls-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/attach-load-balancer-tls-certificate-result))

(clojure.core/defn delete-domain "Deletes the specified domain recordset and all of its domain records.\n The delete domain operation supports tag-based access control via resource tags\napplied to the resource identified by domainName. For more information, see the\nLightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-domain-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-domain-request delete-domain-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-domain-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-domain-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDomain", :http.request.configuration/output-deser-fn response-delete-domain-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-domain :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-domain-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-domain-result))

(clojure.core/defn get-instances "Returns information about all Amazon Lightsail virtual private servers, or\ninstances." ([] (get-instances {})) ([get-instances-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instances-request get-instances-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instances-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instances-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstances", :http.request.configuration/output-deser-fn response-get-instances-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instances :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-instances-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instances-result))

(clojure.core/defn detach-static-ip "Detaches a static IP from the Amazon Lightsail instance to which it is attached." ([detach-static-ip-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-detach-static-ip-request detach-static-ip-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/detach-static-ip-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/detach-static-ip-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachStaticIp", :http.request.configuration/output-deser-fn response-detach-static-ip-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef detach-static-ip :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/detach-static-ip-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/detach-static-ip-result))

(clojure.core/defn get-regions "Returns a list of all valid regions for Amazon Lightsail. Use the include\navailability zones parameter to also return the Availability Zones in a region." ([] (get-regions {})) ([get-regions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-regions-request get-regions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-regions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-regions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRegions", :http.request.configuration/output-deser-fn response-get-regions-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-regions :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-regions-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-regions-result))

(clojure.core/defn get-relational-database-master-user-password "Returns the current, previous, or pending versions of the master user password\nfor a Lightsail database.\n The asdf operation GetRelationalDatabaseMasterUserPassword supports tag-based\naccess control via resource tags applied to the resource identified by\nrelationalDatabaseName." ([get-relational-database-master-user-password-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-master-user-password-request get-relational-database-master-user-password-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-master-user-password-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-master-user-password-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseMasterUserPassword", :http.request.configuration/output-deser-fn response-get-relational-database-master-user-password-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-master-user-password :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-master-user-password-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-master-user-password-result))

(clojure.core/defn get-relational-databases "Returns information about all of your databases in Amazon Lightsail." ([] (get-relational-databases {})) ([get-relational-databases-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-databases-request get-relational-databases-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-databases-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-databases-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabases", :http.request.configuration/output-deser-fn response-get-relational-databases-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-databases :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-relational-databases-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-databases-result))

(clojure.core/defn delete-instance "Deletes a specific Amazon Lightsail virtual private server, or instance.\n The delete instance operation supports tag-based access control via resource\ntags applied to the resource identified by instanceName. For more information,\nsee the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-instance-request delete-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteInstance", :http.request.configuration/output-deser-fn response-delete-instance-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-instance :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-instance-result))

(clojure.core/defn get-instance-snapshots "Returns all instance snapshots for the user's account." ([] (get-instance-snapshots {})) ([get-instance-snapshots-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-snapshots-request get-instance-snapshots-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-snapshots-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-snapshots-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstanceSnapshots", :http.request.configuration/output-deser-fn response-get-instance-snapshots-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance-snapshots :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-instance-snapshots-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-snapshots-result))

(clojure.core/defn detach-disk "Detaches a stopped block storage disk from a Lightsail instance. Make sure to\nunmount any file systems on the device within your operating system before\nstopping the instance and detaching the disk.\n The detach disk operation supports tag-based access control via resource tags\napplied to the resource identified by diskName. For more information, see the\nLightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([detach-disk-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-detach-disk-request detach-disk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/detach-disk-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/detach-disk-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachDisk", :http.request.configuration/output-deser-fn response-detach-disk-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef detach-disk :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/detach-disk-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/detach-disk-result))

(clojure.core/defn get-relational-database-events "Returns a list of events for a specific database in Amazon Lightsail." ([get-relational-database-events-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-events-request get-relational-database-events-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-events-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-events-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseEvents", :http.request.configuration/output-deser-fn response-get-relational-database-events-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-events :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-events-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-events-result))

(clojure.core/defn download-default-key-pair "Downloads the default SSH key pair from the user's account." ([] (download-default-key-pair {})) ([download-default-key-pair-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-download-default-key-pair-request download-default-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/download-default-key-pair-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/download-default-key-pair-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DownloadDefaultKeyPair", :http.request.configuration/output-deser-fn response-download-default-key-pair-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef download-default-key-pair :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/download-default-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/download-default-key-pair-result))

(clojure.core/defn get-active-names "Returns the names of all active (not deleted) resources." ([] (get-active-names {})) ([get-active-names-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-active-names-request get-active-names-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-active-names-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-active-names-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetActiveNames", :http.request.configuration/output-deser-fn response-get-active-names-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-active-names :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/get-active-names-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-active-names-result))

(clojure.core/defn get-instance-metric-data "Returns the data points for the specified Amazon Lightsail instance metric,\ngiven an instance name." ([get-instance-metric-data-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-instance-metric-data-request get-instance-metric-data-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-instance-metric-data-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-instance-metric-data-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInstanceMetricData", :http.request.configuration/output-deser-fn response-get-instance-metric-data-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-instance-metric-data :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-instance-metric-data-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-instance-metric-data-result))

(clojure.core/defn get-relational-database-log-streams "Returns a list of available log streams for a specific database in Amazon\nLightsail." ([get-relational-database-log-streams-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-relational-database-log-streams-request get-relational-database-log-streams-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-streams-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-streams-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRelationalDatabaseLogStreams", :http.request.configuration/output-deser-fn response-get-relational-database-log-streams-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-relational-database-log-streams :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-streams-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-relational-database-log-streams-result))

(clojure.core/defn is-vpc-peered "Returns a Boolean value indicating whether your Lightsail VPC is peered." ([] (is-vpc-peered {})) ([is-vpc-peered-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-is-vpc-peered-request is-vpc-peered-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/is-vpc-peered-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/is-vpc-peered-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "IsVpcPeered", :http.request.configuration/output-deser-fn response-is-vpc-peered-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef is-vpc-peered :args (clojure.spec.alpha/? :portkey.aws.lightsail.-2016-11-28/is-vpc-peered-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/is-vpc-peered-result))

(clojure.core/defn delete-load-balancer-tls-certificate "Deletes an SSL/TLS certificate associated with a Lightsail load balancer.\n The delete load balancer tls certificate operation supports tag-based access\ncontrol via resource tags applied to the resource identified by\nloadBalancerName. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-load-balancer-tls-certificate-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-load-balancer-tls-certificate-request delete-load-balancer-tls-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-tls-certificate-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-tls-certificate-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteLoadBalancerTlsCertificate", :http.request.configuration/output-deser-fn response-delete-load-balancer-tls-certificate-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-load-balancer-tls-certificate :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-tls-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-load-balancer-tls-certificate-result))

(clojure.core/defn create-key-pair "Creates an SSH key pair.\n The create key pair operation supports tag-based access control via request\ntags. For more information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-key-pair-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-key-pair-request create-key-pair-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-key-pair-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-key-pair-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateKeyPair", :http.request.configuration/output-deser-fn response-create-key-pair-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-key-pair :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-key-pair-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-key-pair-result))

(clojure.core/defn delete-relational-database "Deletes a database in Amazon Lightsail.\n The delete relational database operation supports tag-based access control via\nresource tags applied to the resource identified by relationalDatabaseName. For\nmore information, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([delete-relational-database-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-relational-database-request delete-relational-database-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/delete-relational-database-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/delete-relational-database-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRelationalDatabase", :http.request.configuration/output-deser-fn response-delete-relational-database-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef delete-relational-database :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/delete-relational-database-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/delete-relational-database-result))

(clojure.core/defn get-load-balancer "Returns information about the specified Lightsail load balancer." ([get-load-balancer-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-load-balancer-request get-load-balancer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancer-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/get-load-balancer-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLoadBalancer", :http.request.configuration/output-deser-fn response-get-load-balancer-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef get-load-balancer :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/get-load-balancer-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/get-load-balancer-result))

(clojure.core/defn create-domain-entry "Creates one of the following entry records associated with the domain: A record,\nCNAME record, TXT record, or MX record.\n The create domain entry operation supports tag-based access control via\nresource tags applied to the resource identified by domainName. For more\ninformation, see the Lightsail Dev Guide\n(https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-controlling-access-using-tags)." ([create-domain-entry-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-domain-entry-request create-domain-entry-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.lightsail.-2016-11-28/endpoints, :http.request.configuration/target-prefix "Lightsail_20161128", :http.request.spec/output-spec :portkey.aws.lightsail.-2016-11-28/create-domain-entry-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2016-11-28", :http.request.configuration/service-id "Lightsail", :http.request.spec/input-spec :portkey.aws.lightsail.-2016-11-28/create-domain-entry-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDomainEntry", :http.request.configuration/output-deser-fn response-create-domain-entry-result, :http.request.spec/error-spec {"ServiceException" :portkey.aws.lightsail.-2016-11-28/service-exception, "InvalidInputException" :portkey.aws.lightsail.-2016-11-28/invalid-input-exception, "NotFoundException" :portkey.aws.lightsail.-2016-11-28/not-found-exception, "OperationFailureException" :portkey.aws.lightsail.-2016-11-28/operation-failure-exception, "AccessDeniedException" :portkey.aws.lightsail.-2016-11-28/access-denied-exception, "AccountSetupInProgressException" :portkey.aws.lightsail.-2016-11-28/account-setup-in-progress-exception, "UnauthenticatedException" :portkey.aws.lightsail.-2016-11-28/unauthenticated-exception}})))))
(clojure.spec.alpha/fdef create-domain-entry :args (clojure.spec.alpha/tuple :portkey.aws.lightsail.-2016-11-28/create-domain-entry-request) :ret (clojure.spec.alpha/and :portkey.aws.lightsail.-2016-11-28/create-domain-entry-result))
