(ns portkey.aws.ssm (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "ssm", :region "us-gov-east-1"},
    :ssl-common-name "ssm.us-gov-east-1.amazonaws.com",
    :endpoint "https://ssm.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope {:service "ssm", :region "ap-northeast-1"},
    :ssl-common-name "ssm.ap-northeast-1.amazonaws.com",
    :endpoint "https://ssm.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "ssm", :region "eu-west-1"},
    :ssl-common-name "ssm.eu-west-1.amazonaws.com",
    :endpoint "https://ssm.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "ssm", :region "us-east-2"},
    :ssl-common-name "ssm.us-east-2.amazonaws.com",
    :endpoint "https://ssm.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "ssm", :region "ap-southeast-2"},
    :ssl-common-name "ssm.ap-southeast-2.amazonaws.com",
    :endpoint "https://ssm.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "ssm", :region "cn-north-1"},
    :ssl-common-name "ssm.cn-north-1.amazonaws.com.cn",
    :endpoint "https://ssm.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "ssm", :region "sa-east-1"},
    :ssl-common-name "ssm.sa-east-1.amazonaws.com",
    :endpoint "https://ssm.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "ssm", :region "ap-southeast-1"},
    :ssl-common-name "ssm.ap-southeast-1.amazonaws.com",
    :endpoint "https://ssm.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "ssm", :region "cn-northwest-1"},
    :ssl-common-name "ssm.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://ssm.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "ssm", :region "ap-northeast-2"},
    :ssl-common-name "ssm.ap-northeast-2.amazonaws.com",
    :endpoint "https://ssm.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "ssm", :region "eu-west-3"},
    :ssl-common-name "ssm.eu-west-3.amazonaws.com",
    :endpoint "https://ssm.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "ssm", :region "ca-central-1"},
    :ssl-common-name "ssm.ca-central-1.amazonaws.com",
    :endpoint "https://ssm.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "ssm", :region "eu-central-1"},
    :ssl-common-name "ssm.eu-central-1.amazonaws.com",
    :endpoint "https://ssm.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "ssm", :region "eu-west-2"},
    :ssl-common-name "ssm.eu-west-2.amazonaws.com",
    :endpoint "https://ssm.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "ssm", :region "us-gov-west-1"},
    :ssl-common-name "ssm.us-gov-west-1.amazonaws.com",
    :endpoint "https://ssm.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "ssm", :region "us-west-2"},
    :ssl-common-name "ssm.us-west-2.amazonaws.com",
    :endpoint "https://ssm.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "ssm", :region "us-east-1"},
    :ssl-common-name "ssm.us-east-1.amazonaws.com",
    :endpoint "https://ssm.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "ssm", :region "us-west-1"},
    :ssl-common-name "ssm.us-west-1.amazonaws.com",
    :endpoint "https://ssm.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "ssm", :region "ap-south-1"},
    :ssl-common-name "ssm.ap-south-1.amazonaws.com",
    :endpoint "https://ssm.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "ssm", :region "eu-north-1"},
    :ssl-common-name "ssm.eu-north-1.amazonaws.com",
    :endpoint "https://ssm.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-parameter-string-filter-value)

(clojure.core/declare ser-attachments-source-list)

(clojure.core/declare ser-target-map)

(clojure.core/declare ser-instance-information-filter-value-set)

(clojure.core/declare ser-instance-id-list)

(clojure.core/declare ser-automation-parameter-key)

(clojure.core/declare ser-automation-execution-filter-value)

(clojure.core/declare ser-dry-run)

(clojure.core/declare ser-approve-after-days)

(clojure.core/declare ser-string-list)

(clojure.core/declare ser-maintenance-window-run-command-parameters)

(clojure.core/declare ser-automation-execution-filter-key)

(clojure.core/declare ser-parameter-value-list)

(clojure.core/declare ser-command-filter-value)

(clojure.core/declare ser-document-content)

(clojure.core/declare ser-inventory-filter-value-list)

(clojure.core/declare ser-association-version)

(clojure.core/declare ser-target-maps)

(clojure.core/declare ser-service-role)

(clojure.core/declare ser-maintenance-window-enabled)

(clojure.core/declare ser-maintenance-window-name)

(clojure.core/declare ser-instance-id)

(clojure.core/declare ser-instance-information-filter-list)

(clojure.core/declare ser-compliance-item-entry-list)

(clojure.core/declare ser-maintenance-window-search-max-results)

(clojure.core/declare ser-step-execution-filter)

(clojure.core/declare ser-patch-group)

(clojure.core/declare ser-compliance-item-entry)

(clojure.core/declare ser-patch-filter)

(clojure.core/declare ser-notification-event)

(clojure.core/declare ser-instance-information-filter)

(clojure.core/declare ser-inventory-aggregator)

(clojure.core/declare ser-document-version-name)

(clojure.core/declare ser-parameter-name)

(clojure.core/declare ser-patch-orchestrator-filter)

(clojure.core/declare ser-parameter-type)

(clojure.core/declare ser-inventory-query-operator-type)

(clojure.core/declare ser-parameter-string-filter)

(clojure.core/declare ser-s-3-region)

(clojure.core/declare ser-instance-patch-state-filter-value)

(clojure.core/declare ser-document-filter-key)

(clojure.core/declare ser-comment)

(clojure.core/declare ser-compliance-resource-type)

(clojure.core/declare ser-association-id-list)

(clojure.core/declare ser-document-key-values-filter-list)

(clojure.core/declare ser-patch-source)

(clojure.core/declare ser-compliance-string-filter-list)

(clojure.core/declare ser-instance-information-filter-value)

(clojure.core/declare ser-instance-information-string-filter-list)

(clojure.core/declare ser-command-max-results)

(clojure.core/declare ser-parameter-label-list)

(clojure.core/declare ser-association-execution-filter)

(clojure.core/declare ser-inventory-filter)

(clojure.core/declare ser-inventory-item-type-name-filter)

(clojure.core/declare ser-maintenance-window-filter-values)

(clojure.core/declare ser-get-parameters-by-path-max-results)

(clojure.core/declare ser-session-id)

(clojure.core/declare ser-ps-parameter-version)

(clojure.core/declare ser-account-id-list)

(clojure.core/declare ser-session-max-results)

(clojure.core/declare ser-maintenance-window-execution-task-id)

(clojure.core/declare ser-patch-orchestrator-filter-list)

(clojure.core/declare ser-maintenance-window-cutoff)

(clojure.core/declare ser-timeout-seconds)

(clojure.core/declare ser-resource-data-sync-s-3-region)

(clojure.core/declare ser-attribute-name)

(clojure.core/declare ser-parameters-filter)

(clojure.core/declare ser-status-additional-info)

(clojure.core/declare ser-parameter-string-filter-list)

(clojure.core/declare ser-resource-data-sync-awskms-key-arn)

(clojure.core/declare ser-association-execution-filter-value)

(clojure.core/declare ser-status-message)

(clojure.core/declare ser-patch-orchestrator-filter-value)

(clojure.core/declare ser-patch-rule)

(clojure.core/declare ser-execution-mode)

(clojure.core/declare ser-inventory-item-content-hash)

(clojure.core/declare ser-patch-orchestrator-filter-key)

(clojure.core/declare ser-key-list)

(clojure.core/declare ser-inventory-item-entry)

(clojure.core/declare ser-cloud-watch-log-group-name)

(clojure.core/declare ser-parameters)

(clojure.core/declare ser-inventory-filter-value)

(clojure.core/declare ser-association-execution-id)

(clojure.core/declare ser-resource-data-sync-s-3-format)

(clojure.core/declare ser-attachments-source-key)

(clojure.core/declare ser-document-type)

(clojure.core/declare ser-parameters-filter-value)

(clojure.core/declare ser-association-id)

(clojure.core/declare ser-get-inventory-schema-max-results)

(clojure.core/declare ser-automation-execution-filter-list)

(clojure.core/declare ser-session-filter-list)

(clojure.core/declare ser-parameters-filter-key)

(clojure.core/declare ser-inventory-group)

(clojure.core/declare ser-compliance-item-title)

(clojure.core/declare ser-document-key-values-filter-values)

(clojure.core/declare ser-document-key-values-filter)

(clojure.core/declare ser-tag-key)

(clojure.core/declare ser-parameter-name-list)

(clojure.core/declare ser-target-type)

(clojure.core/declare ser-resource-data-sync-s-3-prefix)

(clojure.core/declare ser-notification-config)

(clojure.core/declare ser-s-3-bucket-name)

(clojure.core/declare ser-document-hash)

(clojure.core/declare ser-inventory-filter-list)

(clojure.core/declare ser-association-execution-targets-filter-list)

(clojure.core/declare ser-parameters-filter-value-list)

(clojure.core/declare ser-iam-role)

(clojure.core/declare ser-compliance-severity)

(clojure.core/declare ser-session-state)

(clojure.core/declare ser-notification-type)

(clojure.core/declare ser-maintenance-window-lambda-payload)

(clojure.core/declare ser-result-attribute)

(clojure.core/declare ser-maintenance-window-task-arn)

(clojure.core/declare ser-maintenance-window-lambda-qualifier)

(clojure.core/declare ser-target-map-key)

(clojure.core/declare ser-association-status)

(clojure.core/declare ser-target-locations)

(clojure.core/declare ser-association-filter-key)

(clojure.core/declare ser-inventory-schema-delete-option)

(clojure.core/declare ser-maintenance-window-task-parameters)

(clojure.core/declare ser-next-token)

(clojure.core/declare ser-session-manager-parameter-value-list)

(clojure.core/declare ser-resource-data-sync-s-3-destination)

(clojure.core/declare ser-aggregator-schema-only)

(clojure.core/declare ser-cloud-watch-output-config)

(clojure.core/declare ser-parameter-string-query-option)

(clojure.core/declare ser-patch-baseline-max-results)

(clojure.core/declare ser-default-instance-name)

(clojure.core/declare ser-instance-information-filter-key)

(clojure.core/declare ser-maintenance-window-task-parameter-name)

(clojure.core/declare ser-session-target)

(clojure.core/declare ser-expiration-date)

(clojure.core/declare ser-maintenance-window-task-priority)

(clojure.core/declare ser-document-arn)

(clojure.core/declare ser-patch-id)

(clojure.core/declare ser-max-concurrency)

(clojure.core/declare ser-resource-id)

(clojure.core/declare ser-maintenance-window-task-id)

(clojure.core/declare ser-maintenance-window-filter)

(clojure.core/declare ser-patch-action)

(clojure.core/declare ser-stop-type)

(clojure.core/declare ser-regions)

(clojure.core/declare ser-step-execution-filter-value)

(clojure.core/declare ser-patch-compliance-max-results)

(clojure.core/declare ser-instance-patch-state-filter-values)

(clojure.core/declare ser-signal-type)

(clojure.core/declare ser-compliance-item-id)

(clojure.core/declare ser-association-filter-value)

(clojure.core/declare ser-cloud-watch-output-enabled)

(clojure.core/declare ser-document-filter-value)

(clojure.core/declare ser-parameter-label)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-compliance-string-filter)

(clojure.core/declare ser-compliance-type-name)

(clojure.core/declare ser-patch-id-list)

(clojure.core/declare ser-document-key-values-filter-value)

(clojure.core/declare ser-logging-info)

(clojure.core/declare ser-ps-parameter-value)

(clojure.core/declare ser-patch-filter-group)

(clojure.core/declare ser-instance-patch-state-filter)

(clojure.core/declare ser-command-plugin-name)

(clojure.core/declare ser-attribute-value)

(clojure.core/declare ser-maintenance-window-execution-task-invocation-id)

(clojure.core/declare ser-parameter-key-id)

(clojure.core/declare ser-automation-parameter-map)

(clojure.core/declare ser-step-execution-filter-value-list)

(clojure.core/declare ser-document-filter-list)

(clojure.core/declare ser-patch-rule-group)

(clojure.core/declare ser-inventory-item-list)

(clojure.core/declare ser-accounts)

(clojure.core/declare ser-maintenance-window-filter-list)

(clojure.core/declare ser-service-setting-value)

(clojure.core/declare ser-association-filter-list)

(clojure.core/declare ser-max-errors)

(clojure.core/declare ser-parameter-string-filter-key)

(clojure.core/declare ser-inventory-item-schema-version)

(clojure.core/declare ser-compliance-status)

(clojure.core/declare ser-parameter-string-filter-value-list)

(clojure.core/declare ser-account)

(clojure.core/declare ser-compliance-execution-summary)

(clojure.core/declare ser-attachments-source-values)

(clojure.core/declare ser-attachments-source)

(clojure.core/declare ser-allowed-pattern)

(clojure.core/declare ser-tag-value)

(clojure.core/declare ser-compliance-string-filter-key)

(clojure.core/declare ser-inventory-filter-key)

(clojure.core/declare ser-command-filter-key)

(clojure.core/declare ser-patch-source-product-list)

(clojure.core/declare ser-baseline-id)

(clojure.core/declare ser-inventory-group-name)

(clojure.core/declare ser-maintenance-window-target-id)

(clojure.core/declare ser-association-execution-filter-key)

(clojure.core/declare ser-managed-instance-id)

(clojure.core/declare ser-compliance-string-filter-value-list)

(clojure.core/declare ser-maintenance-window-id)

(clojure.core/declare ser-session-manager-parameter-name)

(clojure.core/declare ser-patch-orchestrator-filter-values)

(clojure.core/declare ser-attachments-source-value)

(clojure.core/declare ser-instance-patch-state-filter-list)

(clojure.core/declare ser-automation-target-parameter-name)

(clojure.core/declare ser-compliance-execution-id)

(clojure.core/declare ser-maintenance-window-description)

(clojure.core/declare ser-association-name)

(clojure.core/declare ser-maintenance-window-lambda-client-context)

(clojure.core/declare ser-effective-instance-association-max-results)

(clojure.core/declare ser-step-execution-filter-list)

(clojure.core/declare ser-string)

(clojure.core/declare ser-parameter-description)

(clojure.core/declare ser-automation-execution-filter)

(clojure.core/declare ser-inventory-item-content-context)

(clojure.core/declare ser-account-id)

(clojure.core/declare ser-instance-patch-state-filter-key)

(clojure.core/declare ser-create-association-batch-request-entry)

(clojure.core/declare ser-automation-execution-filter-value-list)

(clojure.core/declare ser-patch-filter-key)

(clojure.core/declare ser-maintenance-window-lambda-parameters)

(clojure.core/declare ser-patch-source-list)

(clojure.core/declare ser-target-location)

(clojure.core/declare ser-maintenance-window-max-results)

(clojure.core/declare ser-notification-arn)

(clojure.core/declare ser-instance-information-string-filter)

(clojure.core/declare ser-maintenance-window-step-functions-input)

(clojure.core/declare ser-activation-id)

(clojure.core/declare ser-inventory-aggregator-expression)

(clojure.core/declare ser-document-format)

(clojure.core/declare ser-targets)

(clojure.core/declare ser-patch-compliance-level)

(clojure.core/declare ser-patch-source-configuration)

(clojure.core/declare ser-target-map-value)

(clojure.core/declare ser-compliance-resource-type-list)

(clojure.core/declare ser-association-execution-targets-filter-value)

(clojure.core/declare ser-parameters-filter-list)

(clojure.core/declare ser-execution-role-name)

(clojure.core/declare ser-baseline-name)

(clojure.core/declare ser-maintenance-window-step-functions-name)

(clojure.core/declare ser-compliance-resource-id)

(clojure.core/declare ser-association-execution-filter-list)

(clojure.core/declare ser-resource-data-sync-s-3-bucket-name)

(clojure.core/declare ser-maintenance-window-duration-hours)

(clojure.core/declare ser-s-3-key-prefix)

(clojure.core/declare ser-inventory-aggregator-list)

(clojure.core/declare ser-compliance-execution-type)

(clojure.core/declare ser-idempotency-token)

(clojure.core/declare ser-document-permission-type)

(clojure.core/declare ser-schedule-expression)

(clojure.core/declare ser-resource-type-for-tagging)

(clojure.core/declare ser-document-version-number)

(clojure.core/declare ser-command-id)

(clojure.core/declare ser-patch-source-name)

(clojure.core/declare ser-inventory-item-entry-list)

(clojure.core/declare ser-association-status-name)

(clojure.core/declare ser-command-filter)

(clojure.core/declare ser-session-filter-value)

(clojure.core/declare ser-maintenance-window-filter-value)

(clojure.core/declare ser-resource-data-sync-name)

(clojure.core/declare ser-patch-rule-list)

(clojure.core/declare ser-owner-information)

(clojure.core/declare ser-describe-activations-filter-list)

(clojure.core/declare ser-maintenance-window-string-date-time)

(clojure.core/declare ser-describe-activations-filter)

(clojure.core/declare ser-service-setting-id)

(clojure.core/declare ser-s-3-output-location)

(clojure.core/declare ser-automation-parameter-value)

(clojure.core/declare ser-patch-filter-value-list)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-create-association-batch-request-entries)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-maintenance-window-schedule)

(clojure.core/declare ser-inventory-item-type-name)

(clojure.core/declare ser-result-attribute-list)

(clojure.core/declare ser-document-key-values-filter-key)

(clojure.core/declare ser-maintenance-window-task-invocation-parameters)

(clojure.core/declare ser-step-execution-filter-key)

(clojure.core/declare ser-document-name)

(clojure.core/declare ser-compliance-item-content-hash)

(clojure.core/declare ser-maintenance-window-step-functions-parameters)

(clojure.core/declare ser-patch-filter-value)

(clojure.core/declare ser-maintenance-window-task-type)

(clojure.core/declare ser-maintenance-window-allow-unassociated-targets)

(clojure.core/declare ser-session-manager-parameters)

(clojure.core/declare ser-inventory-item)

(clojure.core/declare ser-command-filter-list)

(clojure.core/declare ser-inventory-group-list)

(clojure.core/declare ser-document-version)

(clojure.core/declare ser-target)

(clojure.core/declare ser-document-hash-type)

(clojure.core/declare ser-session-filter-key)

(clojure.core/declare ser-maintenance-window-filter-key)

(clojure.core/declare ser-document-filter)

(clojure.core/declare ser-session-manager-parameter-value)

(clojure.core/declare ser-describe-activations-filter-keys)

(clojure.core/declare ser-maintenance-window-timezone)

(clojure.core/declare ser-association-compliance-severity)

(clojure.core/declare ser-activation-description)

(clojure.core/declare ser-is-sub-type-schema)

(clojure.core/declare ser-compliance-filter-value)

(clojure.core/declare ser-ps-parameter-name)

(clojure.core/declare ser-instance-association-output-location)

(clojure.core/declare ser-session-filter)

(clojure.core/declare ser-maintenance-window-automation-parameters)

(clojure.core/declare ser-compliance-resource-id-list)

(clojure.core/declare ser-inventory-item-capture-time)

(clojure.core/declare ser-association-execution-targets-filter)

(clojure.core/declare ser-baseline-description)

(clojure.core/declare ser-maintenance-window-execution-id)

(clojure.core/declare ser-compliance-query-operator-type)

(clojure.core/declare ser-automation-execution-id)

(clojure.core/declare ser-target-value)

(clojure.core/declare ser-patch-filter-list)

(clojure.core/declare ser-inventory-deletion-id)

(clojure.core/declare ser-region)

(clojure.core/declare ser-patch-source-product)

(clojure.core/declare ser-instance-patch-state-operator-type)

(clojure.core/declare ser-maintenance-window-task-parameter-value-expression)

(clojure.core/declare ser-target-map-value-list)

(clojure.core/declare ser-target-key)

(clojure.core/declare ser-automation-parameter-value-list)

(clojure.core/declare ser-compliance-item-details)

(clojure.core/declare ser-maintenance-window-task-parameter-value-list)

(clojure.core/declare ser-instance-information-string-filter-key)

(clojure.core/declare ser-max-results-ec-2-compatible)

(clojure.core/declare ser-association-execution-targets-filter-key)

(clojure.core/declare ser-operating-system)

(clojure.core/declare ser-association-filter)

(clojure.core/declare ser-client-token)

(clojure.core/declare ser-notification-event-list)

(clojure.core/declare ser-snapshot-id)

(clojure.core/declare ser-registration-limit)

(clojure.core/declare ser-parameter-value)

(clojure.core/declare ser-association-filter-operator-type)

(clojure.core/declare ser-date-time)

(clojure.core/declare ser-target-values)

(clojure.core/declare ser-maintenance-window-task-parameter-value)

(clojure.core/declare ser-boolean)

(clojure.core/declare ser-maintenance-window-resource-type)

(clojure.core/defn- ser-parameter-string-filter-value [input] #:http.request.field{:value input, :shape "ParameterStringFilterValue"})

(clojure.core/defn- ser-attachments-source-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-attachments-source coll) #:http.request.field{:shape "AttachmentsSource"}))) input), :shape "AttachmentsSourceList", :type "list", :max 1, :min 0})

(clojure.core/defn- ser-target-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-target-map-key k) #:http.request.field{:map-info "key", :shape "TargetMapKey"}) (clojure.core/into (ser-target-map-value-list v) #:http.request.field{:map-info "value", :shape "TargetMapValueList"})])) input), :shape "TargetMap", :type "map", :max 20, :min 1})

(clojure.core/defn- ser-instance-information-filter-value-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-information-filter-value coll) #:http.request.field{:shape "InstanceInformationFilterValue"}))) input), :shape "InstanceInformationFilterValueSet", :type "list", :max 100, :min 1})

(clojure.core/defn- ser-instance-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-id coll) #:http.request.field{:shape "InstanceId"}))) input), :shape "InstanceIdList", :type "list", :max 50, :min 0})

(clojure.core/defn- ser-automation-parameter-key [input] #:http.request.field{:value input, :shape "AutomationParameterKey"})

(clojure.core/defn- ser-automation-execution-filter-value [input] #:http.request.field{:value input, :shape "AutomationExecutionFilterValue"})

(clojure.core/defn- ser-dry-run [input] #:http.request.field{:value input, :shape "DryRun"})

(clojure.core/defn- ser-approve-after-days [input] #:http.request.field{:value input, :shape "ApproveAfterDays"})

(clojure.core/defn- ser-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "StringList", :type "list"})

(clojure.core/defn- ser-maintenance-window-run-command-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowRunCommandParameters", :type "structure"} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "Comment", :shape "Comment"})) (clojure.core/contains? input :timeout-seconds) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-seconds (input :timeout-seconds)) #:http.request.field{:name "TimeoutSeconds", :shape "TimeoutSeconds", :box true})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :output-s-3-bucket-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket-name (input :output-s-3-bucket-name)) #:http.request.field{:name "OutputS3BucketName", :shape "S3BucketName"})) (clojure.core/contains? input :notification-config) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-config (input :notification-config)) #:http.request.field{:name "NotificationConfig", :shape "NotificationConfig"})) (clojure.core/contains? input :document-hash) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash (input :document-hash)) #:http.request.field{:name "DocumentHash", :shape "DocumentHash"})) (clojure.core/contains? input :output-s-3-key-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :output-s-3-key-prefix)) #:http.request.field{:name "OutputS3KeyPrefix", :shape "S3KeyPrefix"})) (clojure.core/contains? input :document-hash-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash-type (input :document-hash-type)) #:http.request.field{:name "DocumentHashType", :shape "DocumentHashType"}))))

(clojure.core/defn- ser-automation-execution-filter-key [input] #:http.request.field{:value (clojure.core/get {"AutomationType" "AutomationType", "StartTimeBefore" "StartTimeBefore", "ParentExecutionId" "ParentExecutionId", :automation-type "AutomationType", :document-name-prefix "DocumentNamePrefix", :parent-execution-id "ParentExecutionId", :start-time-before "StartTimeBefore", "StartTimeAfter" "StartTimeAfter", "CurrentAction" "CurrentAction", :execution-status "ExecutionStatus", "ExecutionId" "ExecutionId", :current-action "CurrentAction", :execution-id "ExecutionId", "ExecutionStatus" "ExecutionStatus", "DocumentNamePrefix" "DocumentNamePrefix", :start-time-after "StartTimeAfter"} input), :shape "AutomationExecutionFilterKey"})

(clojure.core/defn- ser-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-value coll) #:http.request.field{:shape "ParameterValue"}))) input), :shape "ParameterValueList", :type "list"})

(clojure.core/defn- ser-command-filter-value [input] #:http.request.field{:value input, :shape "CommandFilterValue"})

(clojure.core/defn- ser-document-content [input] #:http.request.field{:value input, :shape "DocumentContent"})

(clojure.core/defn- ser-inventory-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-filter-value coll) #:http.request.field{:shape "InventoryFilterValue"}))) input), :shape "InventoryFilterValueList", :type "list", :max 40, :min 1})

(clojure.core/defn- ser-association-version [input] #:http.request.field{:value input, :shape "AssociationVersion"})

(clojure.core/defn- ser-target-maps [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-map coll) #:http.request.field{:shape "TargetMap"}))) input), :shape "TargetMaps", :type "list", :max 300, :min 0})

(clojure.core/defn- ser-service-role [input] #:http.request.field{:value input, :shape "ServiceRole"})

(clojure.core/defn- ser-maintenance-window-enabled [input] #:http.request.field{:value input, :shape "MaintenanceWindowEnabled"})

(clojure.core/defn- ser-maintenance-window-name [input] #:http.request.field{:value input, :shape "MaintenanceWindowName"})

(clojure.core/defn- ser-instance-id [input] #:http.request.field{:value input, :shape "InstanceId"})

(clojure.core/defn- ser-instance-information-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-information-filter coll) #:http.request.field{:shape "InstanceInformationFilter"}))) input), :shape "InstanceInformationFilterList", :type "list", :min 0})

(clojure.core/defn- ser-compliance-item-entry-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-item-entry coll) #:http.request.field{:shape "ComplianceItemEntry"}))) input), :shape "ComplianceItemEntryList", :type "list", :max 10000, :min 0})

(clojure.core/defn- ser-maintenance-window-search-max-results [input] #:http.request.field{:value input, :shape "MaintenanceWindowSearchMaxResults"})

(clojure.core/defn- ser-step-execution-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-step-execution-filter-key (:key input)) #:http.request.field{:name "Key", :shape "StepExecutionFilterKey"}) (clojure.core/into (ser-step-execution-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "StepExecutionFilterValueList"})], :shape "StepExecutionFilter", :type "structure"}))

(clojure.core/defn- ser-patch-group [input] #:http.request.field{:value input, :shape "PatchGroup"})

(clojure.core/defn- ser-compliance-item-entry [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-compliance-severity (:severity input)) #:http.request.field{:name "Severity", :shape "ComplianceSeverity"}) (clojure.core/into (ser-compliance-status (:status input)) #:http.request.field{:name "Status", :shape "ComplianceStatus"})], :shape "ComplianceItemEntry", :type "structure"} (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-id (input :id)) #:http.request.field{:name "Id", :shape "ComplianceItemId"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-title (input :title)) #:http.request.field{:name "Title", :shape "ComplianceItemTitle"})) (clojure.core/contains? input :details) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-details (input :details)) #:http.request.field{:name "Details", :shape "ComplianceItemDetails"}))))

(clojure.core/defn- ser-patch-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-filter-key (:key input)) #:http.request.field{:name "Key", :shape "PatchFilterKey"}) (clojure.core/into (ser-patch-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "PatchFilterValueList"})], :shape "PatchFilter", :type "structure"}))

(clojure.core/defn- ser-notification-event [input] #:http.request.field{:value (clojure.core/get {:timed-out "TimedOut", "Failed" "Failed", "Cancelled" "Cancelled", :in-progress "InProgress", "TimedOut" "TimedOut", :all "All", "Success" "Success", :cancelled "Cancelled", :success "Success", "InProgress" "InProgress", "All" "All", :failed "Failed"} input), :shape "NotificationEvent"})

(clojure.core/defn- ser-instance-information-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-instance-information-filter-key (:key input)) #:http.request.field{:name "key", :shape "InstanceInformationFilterKey"}) (clojure.core/into (ser-instance-information-filter-value-set (:value-set input)) #:http.request.field{:name "valueSet", :shape "InstanceInformationFilterValueSet"})], :shape "InstanceInformationFilter", :type "structure"}))

(clojure.core/defn- ser-inventory-aggregator [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InventoryAggregator", :type "structure"} (clojure.core/contains? input :expression) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-aggregator-expression (input :expression)) #:http.request.field{:name "Expression", :shape "InventoryAggregatorExpression"})) (clojure.core/contains? input :aggregators) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-aggregator-list (input :aggregators)) #:http.request.field{:name "Aggregators", :shape "InventoryAggregatorList"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-group-list (input :groups)) #:http.request.field{:name "Groups", :shape "InventoryGroupList"}))))

(clojure.core/defn- ser-document-version-name [input] #:http.request.field{:value input, :shape "DocumentVersionName"})

(clojure.core/defn- ser-parameter-name [input] #:http.request.field{:value input, :shape "ParameterName"})

(clojure.core/defn- ser-patch-orchestrator-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PatchOrchestratorFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-key (input :key)) #:http.request.field{:name "Key", :shape "PatchOrchestratorFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-values (input :values)) #:http.request.field{:name "Values", :shape "PatchOrchestratorFilterValues"}))))

(clojure.core/defn- ser-parameter-type [input] #:http.request.field{:value (clojure.core/get {"String" "String", :string "String", "StringList" "StringList", :string-list "StringList", "SecureString" "SecureString", :secure-string "SecureString"} input), :shape "ParameterType"})

(clojure.core/defn- ser-inventory-query-operator-type [input] #:http.request.field{:value (clojure.core/get {:exists "Exists", "NotEqual" "NotEqual", :less-than "LessThan", "BeginWith" "BeginWith", "Exists" "Exists", "Equal" "Equal", "LessThan" "LessThan", :greater-than "GreaterThan", "GreaterThan" "GreaterThan", :not-equal "NotEqual", :begin-with "BeginWith", :equal "Equal"} input), :shape "InventoryQueryOperatorType"})

(clojure.core/defn- ser-parameter-string-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-parameter-string-filter-key (:key input)) #:http.request.field{:name "Key", :shape "ParameterStringFilterKey"})], :shape "ParameterStringFilter", :type "structure"} (clojure.core/contains? input :option) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-query-option (input :option)) #:http.request.field{:name "Option", :shape "ParameterStringQueryOption"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-filter-value-list (input :values)) #:http.request.field{:name "Values", :shape "ParameterStringFilterValueList"}))))

(clojure.core/defn- ser-s-3-region [input] #:http.request.field{:value input, :shape "S3Region"})

(clojure.core/defn- ser-instance-patch-state-filter-value [input] #:http.request.field{:value input, :shape "InstancePatchStateFilterValue"})

(clojure.core/defn- ser-document-filter-key [input] #:http.request.field{:value (clojure.core/get {"Name" "Name", :name "Name", "Owner" "Owner", :owner "Owner", "PlatformTypes" "PlatformTypes", :platform-types "PlatformTypes", "DocumentType" "DocumentType", :document-type "DocumentType"} input), :shape "DocumentFilterKey"})

(clojure.core/defn- ser-comment [input] #:http.request.field{:value input, :shape "Comment"})

(clojure.core/defn- ser-compliance-resource-type [input] #:http.request.field{:value input, :shape "ComplianceResourceType"})

(clojure.core/defn- ser-association-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-id coll) #:http.request.field{:shape "AssociationId"}))) input), :shape "AssociationIdList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-document-key-values-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-document-key-values-filter coll) #:http.request.field{:shape "DocumentKeyValuesFilter"}))) input), :shape "DocumentKeyValuesFilterList", :type "list", :max 6, :min 0})

(clojure.core/defn- ser-patch-source [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-source-name (:name input)) #:http.request.field{:name "Name", :shape "PatchSourceName"}) (clojure.core/into (ser-patch-source-product-list (:products input)) #:http.request.field{:name "Products", :shape "PatchSourceProductList"}) (clojure.core/into (ser-patch-source-configuration (:configuration input)) #:http.request.field{:name "Configuration", :shape "PatchSourceConfiguration"})], :shape "PatchSource", :type "structure"}))

(clojure.core/defn- ser-compliance-string-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-string-filter coll) #:http.request.field{:shape "ComplianceStringFilter"}))) input), :shape "ComplianceStringFilterList", :type "list"})

(clojure.core/defn- ser-instance-information-filter-value [input] #:http.request.field{:value input, :shape "InstanceInformationFilterValue"})

(clojure.core/defn- ser-instance-information-string-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-information-string-filter coll) #:http.request.field{:shape "InstanceInformationStringFilter"}))) input), :shape "InstanceInformationStringFilterList", :type "list", :min 0})

(clojure.core/defn- ser-command-max-results [input] #:http.request.field{:value input, :shape "CommandMaxResults"})

(clojure.core/defn- ser-parameter-label-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-label coll) #:http.request.field{:shape "ParameterLabel"}))) input), :shape "ParameterLabelList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-association-execution-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-association-execution-filter-key (:key input)) #:http.request.field{:name "Key", :shape "AssociationExecutionFilterKey"}) (clojure.core/into (ser-association-execution-filter-value (:value input)) #:http.request.field{:name "Value", :shape "AssociationExecutionFilterValue"}) (clojure.core/into (ser-association-filter-operator-type (:type input)) #:http.request.field{:name "Type", :shape "AssociationFilterOperatorType"})], :shape "AssociationExecutionFilter", :type "structure"}))

(clojure.core/defn- ser-inventory-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-filter-key (:key input)) #:http.request.field{:name "Key", :shape "InventoryFilterKey"}) (clojure.core/into (ser-inventory-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "InventoryFilterValueList"})], :shape "InventoryFilter", :type "structure"} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-query-operator-type (input :type)) #:http.request.field{:name "Type", :shape "InventoryQueryOperatorType"}))))

(clojure.core/defn- ser-inventory-item-type-name-filter [input] #:http.request.field{:value input, :shape "InventoryItemTypeNameFilter"})

(clojure.core/defn- ser-maintenance-window-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-maintenance-window-filter-value coll) #:http.request.field{:shape "MaintenanceWindowFilterValue"}))) input), :shape "MaintenanceWindowFilterValues", :type "list"})

(clojure.core/defn- ser-get-parameters-by-path-max-results [input] #:http.request.field{:value input, :shape "GetParametersByPathMaxResults"})

(clojure.core/defn- ser-session-id [input] #:http.request.field{:value input, :shape "SessionId"})

(clojure.core/defn- ser-ps-parameter-version [input] #:http.request.field{:value input, :shape "PSParameterVersion"})

(clojure.core/defn- ser-account-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-account-id coll) #:http.request.field{:shape "AccountId"}))) input), :shape "AccountIdList", :type "list", :max 20})

(clojure.core/defn- ser-session-max-results [input] #:http.request.field{:value input, :shape "SessionMaxResults"})

(clojure.core/defn- ser-maintenance-window-execution-task-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowExecutionTaskId"})

(clojure.core/defn- ser-patch-orchestrator-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-orchestrator-filter coll) #:http.request.field{:shape "PatchOrchestratorFilter"}))) input), :shape "PatchOrchestratorFilterList", :type "list", :max 5, :min 0})

(clojure.core/defn- ser-maintenance-window-cutoff [input] #:http.request.field{:value input, :shape "MaintenanceWindowCutoff"})

(clojure.core/defn- ser-timeout-seconds [input] #:http.request.field{:value input, :shape "TimeoutSeconds"})

(clojure.core/defn- ser-resource-data-sync-s-3-region [input] #:http.request.field{:value input, :shape "ResourceDataSyncS3Region"})

(clojure.core/defn- ser-attribute-name [input] #:http.request.field{:value input, :shape "AttributeName"})

(clojure.core/defn- ser-parameters-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-parameters-filter-key (:key input)) #:http.request.field{:name "Key", :shape "ParametersFilterKey"}) (clojure.core/into (ser-parameters-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "ParametersFilterValueList"})], :shape "ParametersFilter", :type "structure"}))

(clojure.core/defn- ser-status-additional-info [input] #:http.request.field{:value input, :shape "StatusAdditionalInfo"})

(clojure.core/defn- ser-parameter-string-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-string-filter coll) #:http.request.field{:shape "ParameterStringFilter"}))) input), :shape "ParameterStringFilterList", :type "list"})

(clojure.core/defn- ser-resource-data-sync-awskms-key-arn [input] #:http.request.field{:value input, :shape "ResourceDataSyncAWSKMSKeyARN"})

(clojure.core/defn- ser-association-execution-filter-value [input] #:http.request.field{:value input, :shape "AssociationExecutionFilterValue"})

(clojure.core/defn- ser-status-message [input] #:http.request.field{:value input, :shape "StatusMessage"})

(clojure.core/defn- ser-patch-orchestrator-filter-value [input] #:http.request.field{:value input, :shape "PatchOrchestratorFilterValue"})

(clojure.core/defn- ser-patch-rule [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-filter-group (:patch-filter-group input)) #:http.request.field{:name "PatchFilterGroup", :shape "PatchFilterGroup"}) (clojure.core/into (ser-approve-after-days (:approve-after-days input)) #:http.request.field{:name "ApproveAfterDays", :shape "ApproveAfterDays", :box true})], :shape "PatchRule", :type "structure"} (clojure.core/contains? input :compliance-level) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-level (input :compliance-level)) #:http.request.field{:name "ComplianceLevel", :shape "PatchComplianceLevel"})) (clojure.core/contains? input :enable-non-security) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enable-non-security)) #:http.request.field{:name "EnableNonSecurity", :shape "Boolean", :box true}))))

(clojure.core/defn- ser-execution-mode [input] #:http.request.field{:value (clojure.core/get {"Auto" "Auto", :auto "Auto", "Interactive" "Interactive", :interactive "Interactive"} input), :shape "ExecutionMode"})

(clojure.core/defn- ser-inventory-item-content-hash [input] #:http.request.field{:value input, :shape "InventoryItemContentHash"})

(clojure.core/defn- ser-patch-orchestrator-filter-key [input] #:http.request.field{:value input, :shape "PatchOrchestratorFilterKey"})

(clojure.core/defn- ser-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag-key coll) #:http.request.field{:shape "TagKey"}))) input), :shape "KeyList", :type "list"})

(clojure.core/defn- ser-inventory-item-entry [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "InventoryItemEntry", :type "map", :max 50, :min 0})

(clojure.core/defn- ser-cloud-watch-log-group-name [input] #:http.request.field{:value input, :shape "CloudWatchLogGroupName"})

(clojure.core/defn- ser-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-parameter-name k) #:http.request.field{:map-info "key", :shape "ParameterName"}) (clojure.core/into (ser-parameter-value-list v) #:http.request.field{:map-info "value", :shape "ParameterValueList"})])) input), :shape "Parameters", :type "map"})

(clojure.core/defn- ser-inventory-filter-value [input] #:http.request.field{:value input, :shape "InventoryFilterValue"})

(clojure.core/defn- ser-association-execution-id [input] #:http.request.field{:value input, :shape "AssociationExecutionId"})

(clojure.core/defn- ser-resource-data-sync-s-3-format [input] #:http.request.field{:value (clojure.core/get {"JsonSerDe" "JsonSerDe", :json-ser-de "JsonSerDe"} input), :shape "ResourceDataSyncS3Format"})

(clojure.core/defn- ser-attachments-source-key [input] #:http.request.field{:value (clojure.core/get {"SourceUrl" "SourceUrl", :source-url "SourceUrl"} input), :shape "AttachmentsSourceKey"})

(clojure.core/defn- ser-document-type [input] #:http.request.field{:value (clojure.core/get {"Automation" "Automation", :package "Package", "Package" "Package", :command "Command", :policy "Policy", "Command" "Command", :automation "Automation", "Policy" "Policy", "Session" "Session", :session "Session"} input), :shape "DocumentType"})

(clojure.core/defn- ser-parameters-filter-value [input] #:http.request.field{:value input, :shape "ParametersFilterValue"})

(clojure.core/defn- ser-association-id [input] #:http.request.field{:value input, :shape "AssociationId"})

(clojure.core/defn- ser-get-inventory-schema-max-results [input] #:http.request.field{:value input, :shape "GetInventorySchemaMaxResults"})

(clojure.core/defn- ser-automation-execution-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-automation-execution-filter coll) #:http.request.field{:shape "AutomationExecutionFilter"}))) input), :shape "AutomationExecutionFilterList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-session-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-session-filter coll) #:http.request.field{:shape "SessionFilter"}))) input), :shape "SessionFilterList", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-parameters-filter-key [input] #:http.request.field{:value (clojure.core/get {"Name" "Name", :name "Name", "Type" "Type", :type "Type", "KeyId" "KeyId", :key-id "KeyId"} input), :shape "ParametersFilterKey"})

(clojure.core/defn- ser-inventory-group [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-group-name (:name input)) #:http.request.field{:name "Name", :shape "InventoryGroupName"}) (clojure.core/into (ser-inventory-filter-list (:filters input)) #:http.request.field{:name "Filters", :shape "InventoryFilterList"})], :shape "InventoryGroup", :type "structure"}))

(clojure.core/defn- ser-compliance-item-title [input] #:http.request.field{:value input, :shape "ComplianceItemTitle"})

(clojure.core/defn- ser-document-key-values-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-document-key-values-filter-value coll) #:http.request.field{:shape "DocumentKeyValuesFilterValue"}))) input), :shape "DocumentKeyValuesFilterValues", :type "list"})

(clojure.core/defn- ser-document-key-values-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DocumentKeyValuesFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-key-values-filter-key (input :key)) #:http.request.field{:name "Key", :shape "DocumentKeyValuesFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-key-values-filter-values (input :values)) #:http.request.field{:name "Values", :shape "DocumentKeyValuesFilterValues"}))))

(clojure.core/defn- ser-tag-key [input] #:http.request.field{:value input, :shape "TagKey"})

(clojure.core/defn- ser-parameter-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ps-parameter-name coll) #:http.request.field{:shape "PSParameterName"}))) input), :shape "ParameterNameList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-target-type [input] #:http.request.field{:value input, :shape "TargetType"})

(clojure.core/defn- ser-resource-data-sync-s-3-prefix [input] #:http.request.field{:value input, :shape "ResourceDataSyncS3Prefix"})

(clojure.core/defn- ser-notification-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NotificationConfig", :type "structure"} (clojure.core/contains? input :notification-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-arn (input :notification-arn)) #:http.request.field{:name "NotificationArn", :shape "NotificationArn"})) (clojure.core/contains? input :notification-events) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-event-list (input :notification-events)) #:http.request.field{:name "NotificationEvents", :shape "NotificationEventList"})) (clojure.core/contains? input :notification-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-type (input :notification-type)) #:http.request.field{:name "NotificationType", :shape "NotificationType"}))))

(clojure.core/defn- ser-s-3-bucket-name [input] #:http.request.field{:value input, :shape "S3BucketName"})

(clojure.core/defn- ser-document-hash [input] #:http.request.field{:value input, :shape "DocumentHash"})

(clojure.core/defn- ser-inventory-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-filter coll) #:http.request.field{:shape "InventoryFilter"}))) input), :shape "InventoryFilterList", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-association-execution-targets-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-execution-targets-filter coll) #:http.request.field{:shape "AssociationExecutionTargetsFilter"}))) input), :shape "AssociationExecutionTargetsFilterList", :type "list", :min 1})

(clojure.core/defn- ser-parameters-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameters-filter-value coll) #:http.request.field{:shape "ParametersFilterValue"}))) input), :shape "ParametersFilterValueList", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-iam-role [input] #:http.request.field{:value input, :shape "IamRole"})

(clojure.core/defn- ser-compliance-severity [input] #:http.request.field{:value (clojure.core/get {"INFORMATIONAL" "INFORMATIONAL", :unspecified "UNSPECIFIED", "CRITICAL" "CRITICAL", :medium "MEDIUM", "LOW" "LOW", :high "HIGH", :critical "CRITICAL", "HIGH" "HIGH", :low "LOW", "UNSPECIFIED" "UNSPECIFIED", :informational "INFORMATIONAL", "MEDIUM" "MEDIUM"} input), :shape "ComplianceSeverity"})

(clojure.core/defn- ser-session-state [input] #:http.request.field{:value (clojure.core/get {"Active" "Active", :active "Active", "History" "History", :history "History"} input), :shape "SessionState"})

(clojure.core/defn- ser-notification-type [input] #:http.request.field{:value (clojure.core/get {"Command" "Command", :command "Command", "Invocation" "Invocation", :invocation "Invocation"} input), :shape "NotificationType"})

(clojure.core/defn- ser-maintenance-window-lambda-payload [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "MaintenanceWindowLambdaPayload"})

(clojure.core/defn- ser-result-attribute [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-item-type-name (:type-name input)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"})], :shape "ResultAttribute", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-task-arn [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskArn"})

(clojure.core/defn- ser-maintenance-window-lambda-qualifier [input] #:http.request.field{:value input, :shape "MaintenanceWindowLambdaQualifier"})

(clojure.core/defn- ser-target-map-key [input] #:http.request.field{:value input, :shape "TargetMapKey"})

(clojure.core/defn- ser-association-status [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-date-time (:date input)) #:http.request.field{:name "Date", :shape "DateTime"}) (clojure.core/into (ser-association-status-name (:name input)) #:http.request.field{:name "Name", :shape "AssociationStatusName"}) (clojure.core/into (ser-status-message (:message input)) #:http.request.field{:name "Message", :shape "StatusMessage"})], :shape "AssociationStatus", :type "structure"} (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-status-additional-info (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "StatusAdditionalInfo"}))))

(clojure.core/defn- ser-target-locations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-location coll) #:http.request.field{:shape "TargetLocation"}))) input), :shape "TargetLocations", :type "list", :max 100, :min 1})

(clojure.core/defn- ser-association-filter-key [input] #:http.request.field{:value (clojure.core/get {"InstanceId" "InstanceId", :association-id "AssociationId", "AssociationId" "AssociationId", :name "Name", :association-name "AssociationName", :instance-id "InstanceId", "LastExecutedBefore" "LastExecutedBefore", "AssociationName" "AssociationName", :association-status-name "AssociationStatusName", "AssociationStatusName" "AssociationStatusName", :last-executed-after "LastExecutedAfter", "Name" "Name", :last-executed-before "LastExecutedBefore", "LastExecutedAfter" "LastExecutedAfter"} input), :shape "AssociationFilterKey"})

(clojure.core/defn- ser-inventory-schema-delete-option [input] #:http.request.field{:value (clojure.core/get {"DisableSchema" "DisableSchema", :disable-schema "DisableSchema", "DeleteSchema" "DeleteSchema", :delete-schema "DeleteSchema"} input), :shape "InventorySchemaDeleteOption"})

(clojure.core/defn- ser-maintenance-window-task-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-maintenance-window-task-parameter-name k) #:http.request.field{:map-info "key", :shape "MaintenanceWindowTaskParameterName"}) (clojure.core/into (ser-maintenance-window-task-parameter-value-expression v) #:http.request.field{:map-info "value", :shape "MaintenanceWindowTaskParameterValueExpression"})])) input), :shape "MaintenanceWindowTaskParameters", :type "map", :sensitive true})

(clojure.core/defn- ser-next-token [input] #:http.request.field{:value input, :shape "NextToken"})

(clojure.core/defn- ser-session-manager-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-session-manager-parameter-value coll) #:http.request.field{:shape "SessionManagerParameterValue"}))) input), :shape "SessionManagerParameterValueList", :type "list"})

(clojure.core/defn- ser-resource-data-sync-s-3-destination [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-resource-data-sync-s-3-bucket-name (:bucket-name input)) #:http.request.field{:name "BucketName", :shape "ResourceDataSyncS3BucketName"}) (clojure.core/into (ser-resource-data-sync-s-3-format (:sync-format input)) #:http.request.field{:name "SyncFormat", :shape "ResourceDataSyncS3Format"}) (clojure.core/into (ser-resource-data-sync-s-3-region (:region input)) #:http.request.field{:name "Region", :shape "ResourceDataSyncS3Region"})], :shape "ResourceDataSyncS3Destination", :type "structure"} (clojure.core/contains? input :prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-data-sync-s-3-prefix (input :prefix)) #:http.request.field{:name "Prefix", :shape "ResourceDataSyncS3Prefix"})) (clojure.core/contains? input :awskms-key-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-data-sync-awskms-key-arn (input :awskms-key-arn)) #:http.request.field{:name "AWSKMSKeyARN", :shape "ResourceDataSyncAWSKMSKeyARN"}))))

(clojure.core/defn- ser-aggregator-schema-only [input] #:http.request.field{:value input, :shape "AggregatorSchemaOnly"})

(clojure.core/defn- ser-cloud-watch-output-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CloudWatchOutputConfig", :type "structure"} (clojure.core/contains? input :cloud-watch-log-group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloud-watch-log-group-name (input :cloud-watch-log-group-name)) #:http.request.field{:name "CloudWatchLogGroupName", :shape "CloudWatchLogGroupName"})) (clojure.core/contains? input :cloud-watch-output-enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloud-watch-output-enabled (input :cloud-watch-output-enabled)) #:http.request.field{:name "CloudWatchOutputEnabled", :shape "CloudWatchOutputEnabled"}))))

(clojure.core/defn- ser-parameter-string-query-option [input] #:http.request.field{:value input, :shape "ParameterStringQueryOption"})

(clojure.core/defn- ser-patch-baseline-max-results [input] #:http.request.field{:value input, :shape "PatchBaselineMaxResults"})

(clojure.core/defn- ser-default-instance-name [input] #:http.request.field{:value input, :shape "DefaultInstanceName"})

(clojure.core/defn- ser-instance-information-filter-key [input] #:http.request.field{:value (clojure.core/get {"InstanceIds" "InstanceIds", "ActivationIds" "ActivationIds", :platform-types "PlatformTypes", :iam-role "IamRole", "PingStatus" "PingStatus", "IamRole" "IamRole", "AgentVersion" "AgentVersion", "AssociationStatus" "AssociationStatus", :association-status "AssociationStatus", "ResourceType" "ResourceType", :instance-ids "InstanceIds", "PlatformTypes" "PlatformTypes", :resource-type "ResourceType", :agent-version "AgentVersion", :activation-ids "ActivationIds", :ping-status "PingStatus"} input), :shape "InstanceInformationFilterKey"})

(clojure.core/defn- ser-maintenance-window-task-parameter-name [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskParameterName"})

(clojure.core/defn- ser-session-target [input] #:http.request.field{:value input, :shape "SessionTarget"})

(clojure.core/defn- ser-expiration-date [input] #:http.request.field{:value input, :shape "ExpirationDate"})

(clojure.core/defn- ser-maintenance-window-task-priority [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskPriority"})

(clojure.core/defn- ser-document-arn [input] #:http.request.field{:value input, :shape "DocumentARN"})

(clojure.core/defn- ser-patch-id [input] #:http.request.field{:value input, :shape "PatchId"})

(clojure.core/defn- ser-max-concurrency [input] #:http.request.field{:value input, :shape "MaxConcurrency"})

(clojure.core/defn- ser-resource-id [input] #:http.request.field{:value input, :shape "ResourceId"})

(clojure.core/defn- ser-maintenance-window-task-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskId"})

(clojure.core/defn- ser-maintenance-window-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-key (input :key)) #:http.request.field{:name "Key", :shape "MaintenanceWindowFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-values (input :values)) #:http.request.field{:name "Values", :shape "MaintenanceWindowFilterValues"}))))

(clojure.core/defn- ser-patch-action [input] #:http.request.field{:value (clojure.core/get {"ALLOW_AS_DEPENDENCY" "ALLOW_AS_DEPENDENCY", :allow-as-dependency "ALLOW_AS_DEPENDENCY", "BLOCK" "BLOCK", :block "BLOCK"} input), :shape "PatchAction"})

(clojure.core/defn- ser-stop-type [input] #:http.request.field{:value (clojure.core/get {"Complete" "Complete", :complete "Complete", "Cancel" "Cancel", :cancel "Cancel"} input), :shape "StopType"})

(clojure.core/defn- ser-regions [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-region coll) #:http.request.field{:shape "Region"}))) input), :shape "Regions", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-step-execution-filter-value [input] #:http.request.field{:value input, :shape "StepExecutionFilterValue"})

(clojure.core/defn- ser-patch-compliance-max-results [input] #:http.request.field{:value input, :shape "PatchComplianceMaxResults"})

(clojure.core/defn- ser-instance-patch-state-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-patch-state-filter-value coll) #:http.request.field{:shape "InstancePatchStateFilterValue"}))) input), :shape "InstancePatchStateFilterValues", :type "list", :max 1, :min 1})

(clojure.core/defn- ser-signal-type [input] #:http.request.field{:value (clojure.core/get {:stop-step "StopStep", :approve "Approve", "Resume" "Resume", "StopStep" "StopStep", "StartStep" "StartStep", "Approve" "Approve", :reject "Reject", :resume "Resume", :start-step "StartStep", "Reject" "Reject"} input), :shape "SignalType"})

(clojure.core/defn- ser-compliance-item-id [input] #:http.request.field{:value input, :shape "ComplianceItemId"})

(clojure.core/defn- ser-association-filter-value [input] #:http.request.field{:value input, :shape "AssociationFilterValue"})

(clojure.core/defn- ser-cloud-watch-output-enabled [input] #:http.request.field{:value input, :shape "CloudWatchOutputEnabled"})

(clojure.core/defn- ser-document-filter-value [input] #:http.request.field{:value input, :shape "DocumentFilterValue"})

(clojure.core/defn- ser-parameter-label [input] #:http.request.field{:value input, :shape "ParameterLabel"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag"}))) input), :shape "TagList", :type "list", :max 1000})

(clojure.core/defn- ser-compliance-string-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ComplianceStringFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-key (input :key)) #:http.request.field{:name "Key", :shape "ComplianceStringFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-value-list (input :values)) #:http.request.field{:name "Values", :shape "ComplianceStringFilterValueList"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-query-operator-type (input :type)) #:http.request.field{:name "Type", :shape "ComplianceQueryOperatorType"}))))

(clojure.core/defn- ser-compliance-type-name [input] #:http.request.field{:value input, :shape "ComplianceTypeName"})

(clojure.core/defn- ser-patch-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-id coll) #:http.request.field{:shape "PatchId"}))) input), :shape "PatchIdList", :type "list", :max 50, :min 0})

(clojure.core/defn- ser-document-key-values-filter-value [input] #:http.request.field{:value input, :shape "DocumentKeyValuesFilterValue"})

(clojure.core/defn- ser-logging-info [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-s-3-bucket-name (:s-3-bucket-name input)) #:http.request.field{:name "S3BucketName", :shape "S3BucketName"}) (clojure.core/into (ser-s-3-region (:s-3-region input)) #:http.request.field{:name "S3Region", :shape "S3Region"})], :shape "LoggingInfo", :type "structure"} (clojure.core/contains? input :s-3-key-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :s-3-key-prefix)) #:http.request.field{:name "S3KeyPrefix", :shape "S3KeyPrefix"}))))

(clojure.core/defn- ser-ps-parameter-value [input] #:http.request.field{:value input, :shape "PSParameterValue"})

(clojure.core/defn- ser-patch-filter-group [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-filter-list (:patch-filters input)) #:http.request.field{:name "PatchFilters", :shape "PatchFilterList"})], :shape "PatchFilterGroup", :type "structure"}))

(clojure.core/defn- ser-instance-patch-state-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-instance-patch-state-filter-key (:key input)) #:http.request.field{:name "Key", :shape "InstancePatchStateFilterKey"}) (clojure.core/into (ser-instance-patch-state-filter-values (:values input)) #:http.request.field{:name "Values", :shape "InstancePatchStateFilterValues"}) (clojure.core/into (ser-instance-patch-state-operator-type (:type input)) #:http.request.field{:name "Type", :shape "InstancePatchStateOperatorType"})], :shape "InstancePatchStateFilter", :type "structure"}))

(clojure.core/defn- ser-command-plugin-name [input] #:http.request.field{:value input, :shape "CommandPluginName"})

(clojure.core/defn- ser-attribute-value [input] #:http.request.field{:value input, :shape "AttributeValue"})

(clojure.core/defn- ser-maintenance-window-execution-task-invocation-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowExecutionTaskInvocationId"})

(clojure.core/defn- ser-parameter-key-id [input] #:http.request.field{:value input, :shape "ParameterKeyId"})

(clojure.core/defn- ser-automation-parameter-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-automation-parameter-key k) #:http.request.field{:map-info "key", :shape "AutomationParameterKey"}) (clojure.core/into (ser-automation-parameter-value-list v) #:http.request.field{:map-info "value", :shape "AutomationParameterValueList"})])) input), :shape "AutomationParameterMap", :type "map", :max 200, :min 1})

(clojure.core/defn- ser-step-execution-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-step-execution-filter-value coll) #:http.request.field{:shape "StepExecutionFilterValue"}))) input), :shape "StepExecutionFilterValueList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-document-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-document-filter coll) #:http.request.field{:shape "DocumentFilter"}))) input), :shape "DocumentFilterList", :type "list", :min 1})

(clojure.core/defn- ser-patch-rule-group [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-rule-list (:patch-rules input)) #:http.request.field{:name "PatchRules", :shape "PatchRuleList"})], :shape "PatchRuleGroup", :type "structure"}))

(clojure.core/defn- ser-inventory-item-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-item coll) #:http.request.field{:shape "InventoryItem"}))) input), :shape "InventoryItemList", :type "list", :max 30, :min 1})

(clojure.core/defn- ser-accounts [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-account coll) #:http.request.field{:shape "Account"}))) input), :shape "Accounts", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-maintenance-window-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-maintenance-window-filter coll) #:http.request.field{:shape "MaintenanceWindowFilter"}))) input), :shape "MaintenanceWindowFilterList", :type "list", :max 5, :min 0})

(clojure.core/defn- ser-service-setting-value [input] #:http.request.field{:value input, :shape "ServiceSettingValue"})

(clojure.core/defn- ser-association-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-filter coll) #:http.request.field{:shape "AssociationFilter"}))) input), :shape "AssociationFilterList", :type "list", :min 1})

(clojure.core/defn- ser-max-errors [input] #:http.request.field{:value input, :shape "MaxErrors"})

(clojure.core/defn- ser-parameter-string-filter-key [input] #:http.request.field{:value input, :shape "ParameterStringFilterKey"})

(clojure.core/defn- ser-inventory-item-schema-version [input] #:http.request.field{:value input, :shape "InventoryItemSchemaVersion"})

(clojure.core/defn- ser-compliance-status [input] #:http.request.field{:value (clojure.core/get {"COMPLIANT" "COMPLIANT", :compliant "COMPLIANT", "NON_COMPLIANT" "NON_COMPLIANT", :non-compliant "NON_COMPLIANT"} input), :shape "ComplianceStatus"})

(clojure.core/defn- ser-parameter-string-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-string-filter-value coll) #:http.request.field{:shape "ParameterStringFilterValue"}))) input), :shape "ParameterStringFilterValueList", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-account [input] #:http.request.field{:value input, :shape "Account"})

(clojure.core/defn- ser-compliance-execution-summary [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-date-time (:execution-time input)) #:http.request.field{:name "ExecutionTime", :shape "DateTime"})], :shape "ComplianceExecutionSummary", :type "structure"} (clojure.core/contains? input :execution-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-execution-id (input :execution-id)) #:http.request.field{:name "ExecutionId", :shape "ComplianceExecutionId"})) (clojure.core/contains? input :execution-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-execution-type (input :execution-type)) #:http.request.field{:name "ExecutionType", :shape "ComplianceExecutionType"}))))

(clojure.core/defn- ser-attachments-source-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-attachments-source-value coll) #:http.request.field{:shape "AttachmentsSourceValue"}))) input), :shape "AttachmentsSourceValues", :type "list", :max 1, :min 1})

(clojure.core/defn- ser-attachments-source [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttachmentsSource", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-key (input :key)) #:http.request.field{:name "Key", :shape "AttachmentsSourceKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-values (input :values)) #:http.request.field{:name "Values", :shape "AttachmentsSourceValues"}))))

(clojure.core/defn- ser-allowed-pattern [input] #:http.request.field{:value input, :shape "AllowedPattern"})

(clojure.core/defn- ser-tag-value [input] #:http.request.field{:value input, :shape "TagValue"})

(clojure.core/defn- ser-compliance-string-filter-key [input] #:http.request.field{:value input, :shape "ComplianceStringFilterKey"})

(clojure.core/defn- ser-inventory-filter-key [input] #:http.request.field{:value input, :shape "InventoryFilterKey"})

(clojure.core/defn- ser-command-filter-key [input] #:http.request.field{:value (clojure.core/get {"InvokedBefore" "InvokedBefore", :document-name "DocumentName", "InvokedAfter" "InvokedAfter", "ExecutionStage" "ExecutionStage", "Status" "Status", :invoked-before "InvokedBefore", :invoked-after "InvokedAfter", :status "Status", "DocumentName" "DocumentName", :execution-stage "ExecutionStage"} input), :shape "CommandFilterKey"})

(clojure.core/defn- ser-patch-source-product-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-source-product coll) #:http.request.field{:shape "PatchSourceProduct"}))) input), :shape "PatchSourceProductList", :type "list", :max 20, :min 1})

(clojure.core/defn- ser-baseline-id [input] #:http.request.field{:value input, :shape "BaselineId"})

(clojure.core/defn- ser-inventory-group-name [input] #:http.request.field{:value input, :shape "InventoryGroupName"})

(clojure.core/defn- ser-maintenance-window-target-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowTargetId"})

(clojure.core/defn- ser-association-execution-filter-key [input] #:http.request.field{:value (clojure.core/get {"ExecutionId" "ExecutionId", :execution-id "ExecutionId", "Status" "Status", :status "Status", "CreatedTime" "CreatedTime", :created-time "CreatedTime"} input), :shape "AssociationExecutionFilterKey"})

(clojure.core/defn- ser-managed-instance-id [input] #:http.request.field{:value input, :shape "ManagedInstanceId"})

(clojure.core/defn- ser-compliance-string-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-filter-value coll) #:http.request.field{:shape "ComplianceFilterValue"}))) input), :shape "ComplianceStringFilterValueList", :type "list", :max 20, :min 1})

(clojure.core/defn- ser-maintenance-window-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowId"})

(clojure.core/defn- ser-session-manager-parameter-name [input] #:http.request.field{:value input, :shape "SessionManagerParameterName"})

(clojure.core/defn- ser-patch-orchestrator-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-orchestrator-filter-value coll) #:http.request.field{:shape "PatchOrchestratorFilterValue"}))) input), :shape "PatchOrchestratorFilterValues", :type "list"})

(clojure.core/defn- ser-attachments-source-value [input] #:http.request.field{:value input, :shape "AttachmentsSourceValue"})

(clojure.core/defn- ser-instance-patch-state-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-patch-state-filter coll) #:http.request.field{:shape "InstancePatchStateFilter"}))) input), :shape "InstancePatchStateFilterList", :type "list", :max 4, :min 0})

(clojure.core/defn- ser-automation-target-parameter-name [input] #:http.request.field{:value input, :shape "AutomationTargetParameterName"})

(clojure.core/defn- ser-compliance-execution-id [input] #:http.request.field{:value input, :shape "ComplianceExecutionId"})

(clojure.core/defn- ser-maintenance-window-description [input] #:http.request.field{:value input, :shape "MaintenanceWindowDescription"})

(clojure.core/defn- ser-association-name [input] #:http.request.field{:value input, :shape "AssociationName"})

(clojure.core/defn- ser-maintenance-window-lambda-client-context [input] #:http.request.field{:value input, :shape "MaintenanceWindowLambdaClientContext"})

(clojure.core/defn- ser-effective-instance-association-max-results [input] #:http.request.field{:value input, :shape "EffectiveInstanceAssociationMaxResults"})

(clojure.core/defn- ser-step-execution-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-step-execution-filter coll) #:http.request.field{:shape "StepExecutionFilter"}))) input), :shape "StepExecutionFilterList", :type "list", :max 6, :min 1})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-parameter-description [input] #:http.request.field{:value input, :shape "ParameterDescription"})

(clojure.core/defn- ser-automation-execution-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-automation-execution-filter-key (:key input)) #:http.request.field{:name "Key", :shape "AutomationExecutionFilterKey"}) (clojure.core/into (ser-automation-execution-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "AutomationExecutionFilterValueList"})], :shape "AutomationExecutionFilter", :type "structure"}))

(clojure.core/defn- ser-inventory-item-content-context [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "InventoryItemContentContext", :type "map", :max 50, :min 0})

(clojure.core/defn- ser-account-id [input] #:http.request.field{:value input, :shape "AccountId"})

(clojure.core/defn- ser-instance-patch-state-filter-key [input] #:http.request.field{:value input, :shape "InstancePatchStateFilterKey"})

(clojure.core/defn- ser-create-association-batch-request-entry [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-document-arn (:name input)) #:http.request.field{:name "Name", :shape "DocumentARN"})], :shape "CreateAssociationBatchRequestEntry", :type "structure"} (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :compliance-severity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-compliance-severity (input :compliance-severity)) #:http.request.field{:name "ComplianceSeverity", :shape "AssociationComplianceSeverity"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :automation-target-parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-target-parameter-name (input :automation-target-parameter-name)) #:http.request.field{:name "AutomationTargetParameterName", :shape "AutomationTargetParameterName"})) (clojure.core/contains? input :association-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-name (input :association-name)) #:http.request.field{:name "AssociationName", :shape "AssociationName"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "ScheduleExpression"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :output-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-association-output-location (input :output-location)) #:http.request.field{:name "OutputLocation", :shape "InstanceAssociationOutputLocation"}))))

(clojure.core/defn- ser-automation-execution-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-automation-execution-filter-value coll) #:http.request.field{:shape "AutomationExecutionFilterValue"}))) input), :shape "AutomationExecutionFilterValueList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-patch-filter-key [input] #:http.request.field{:value (clojure.core/get {"PATCH_ID" "PATCH_ID", "CLASSIFICATION" "CLASSIFICATION", :section "SECTION", "SEVERITY" "SEVERITY", :classification "CLASSIFICATION", "MSRC_SEVERITY" "MSRC_SEVERITY", "SECTION" "SECTION", :product "PRODUCT", :priority "PRIORITY", :patch-id "PATCH_ID", :severity "SEVERITY", "PRODUCT" "PRODUCT", :msrc-severity "MSRC_SEVERITY", "PRIORITY" "PRIORITY"} input), :shape "PatchFilterKey"})

(clojure.core/defn- ser-maintenance-window-lambda-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowLambdaParameters", :type "structure"} (clojure.core/contains? input :client-context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-client-context (input :client-context)) #:http.request.field{:name "ClientContext", :shape "MaintenanceWindowLambdaClientContext"})) (clojure.core/contains? input :qualifier) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-qualifier (input :qualifier)) #:http.request.field{:name "Qualifier", :shape "MaintenanceWindowLambdaQualifier"})) (clojure.core/contains? input :payload) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-payload (input :payload)) #:http.request.field{:name "Payload", :shape "MaintenanceWindowLambdaPayload"}))))

(clojure.core/defn- ser-patch-source-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-source coll) #:http.request.field{:shape "PatchSource"}))) input), :shape "PatchSourceList", :type "list", :max 20, :min 0})

(clojure.core/defn- ser-target-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TargetLocation", :type "structure"} (clojure.core/contains? input :accounts) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-accounts (input :accounts)) #:http.request.field{:name "Accounts", :shape "Accounts"})) (clojure.core/contains? input :regions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-regions (input :regions)) #:http.request.field{:name "Regions", :shape "Regions"})) (clojure.core/contains? input :target-location-max-concurrency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :target-location-max-concurrency)) #:http.request.field{:name "TargetLocationMaxConcurrency", :shape "MaxConcurrency", :box true})) (clojure.core/contains? input :target-location-max-errors) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :target-location-max-errors)) #:http.request.field{:name "TargetLocationMaxErrors", :shape "MaxErrors", :box true})) (clojure.core/contains? input :execution-role-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-role-name (input :execution-role-name)) #:http.request.field{:name "ExecutionRoleName", :shape "ExecutionRoleName", :box true}))))

(clojure.core/defn- ser-maintenance-window-max-results [input] #:http.request.field{:value input, :shape "MaintenanceWindowMaxResults"})

(clojure.core/defn- ser-notification-arn [input] #:http.request.field{:value input, :shape "NotificationArn"})

(clojure.core/defn- ser-instance-information-string-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-instance-information-string-filter-key (:key input)) #:http.request.field{:name "Key", :shape "InstanceInformationStringFilterKey"}) (clojure.core/into (ser-instance-information-filter-value-set (:values input)) #:http.request.field{:name "Values", :shape "InstanceInformationFilterValueSet"})], :shape "InstanceInformationStringFilter", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-step-functions-input [input] #:http.request.field{:value input, :shape "MaintenanceWindowStepFunctionsInput"})

(clojure.core/defn- ser-activation-id [input] #:http.request.field{:value input, :shape "ActivationId"})

(clojure.core/defn- ser-inventory-aggregator-expression [input] #:http.request.field{:value input, :shape "InventoryAggregatorExpression"})

(clojure.core/defn- ser-document-format [input] #:http.request.field{:value (clojure.core/get {"YAML" "YAML", :yaml "YAML", "JSON" "JSON", :json "JSON"} input), :shape "DocumentFormat"})

(clojure.core/defn- ser-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target coll) #:http.request.field{:shape "Target"}))) input), :shape "Targets", :type "list", :max 5, :min 0})

(clojure.core/defn- ser-patch-compliance-level [input] #:http.request.field{:value (clojure.core/get {"INFORMATIONAL" "INFORMATIONAL", :unspecified "UNSPECIFIED", "CRITICAL" "CRITICAL", :medium "MEDIUM", "LOW" "LOW", :high "HIGH", :critical "CRITICAL", "HIGH" "HIGH", :low "LOW", "UNSPECIFIED" "UNSPECIFIED", :informational "INFORMATIONAL", "MEDIUM" "MEDIUM"} input), :shape "PatchComplianceLevel"})

(clojure.core/defn- ser-patch-source-configuration [input] #:http.request.field{:value input, :shape "PatchSourceConfiguration"})

(clojure.core/defn- ser-target-map-value [input] #:http.request.field{:value input, :shape "TargetMapValue"})

(clojure.core/defn- ser-compliance-resource-type-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-resource-type coll) #:http.request.field{:shape "ComplianceResourceType"}))) input), :shape "ComplianceResourceTypeList", :type "list", :min 1})

(clojure.core/defn- ser-association-execution-targets-filter-value [input] #:http.request.field{:value input, :shape "AssociationExecutionTargetsFilterValue"})

(clojure.core/defn- ser-parameters-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameters-filter coll) #:http.request.field{:shape "ParametersFilter"}))) input), :shape "ParametersFilterList", :type "list"})

(clojure.core/defn- ser-execution-role-name [input] #:http.request.field{:value input, :shape "ExecutionRoleName"})

(clojure.core/defn- ser-baseline-name [input] #:http.request.field{:value input, :shape "BaselineName"})

(clojure.core/defn- ser-maintenance-window-step-functions-name [input] #:http.request.field{:value input, :shape "MaintenanceWindowStepFunctionsName"})

(clojure.core/defn- ser-compliance-resource-id [input] #:http.request.field{:value input, :shape "ComplianceResourceId"})

(clojure.core/defn- ser-association-execution-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-execution-filter coll) #:http.request.field{:shape "AssociationExecutionFilter"}))) input), :shape "AssociationExecutionFilterList", :type "list", :min 1})

(clojure.core/defn- ser-resource-data-sync-s-3-bucket-name [input] #:http.request.field{:value input, :shape "ResourceDataSyncS3BucketName"})

(clojure.core/defn- ser-maintenance-window-duration-hours [input] #:http.request.field{:value input, :shape "MaintenanceWindowDurationHours"})

(clojure.core/defn- ser-s-3-key-prefix [input] #:http.request.field{:value input, :shape "S3KeyPrefix"})

(clojure.core/defn- ser-inventory-aggregator-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-aggregator coll) #:http.request.field{:shape "InventoryAggregator"}))) input), :shape "InventoryAggregatorList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-compliance-execution-type [input] #:http.request.field{:value input, :shape "ComplianceExecutionType"})

(clojure.core/defn- ser-idempotency-token [input] #:http.request.field{:value input, :shape "IdempotencyToken"})

(clojure.core/defn- ser-document-permission-type [input] #:http.request.field{:value (clojure.core/get {"Share" "Share", :share "Share"} input), :shape "DocumentPermissionType"})

(clojure.core/defn- ser-schedule-expression [input] #:http.request.field{:value input, :shape "ScheduleExpression"})

(clojure.core/defn- ser-resource-type-for-tagging [input] #:http.request.field{:value (clojure.core/get {:managed-instance "ManagedInstance", :maintenance-window "MaintenanceWindow", "PatchBaseline" "PatchBaseline", "MaintenanceWindow" "MaintenanceWindow", :document "Document", "Parameter" "Parameter", :patch-baseline "PatchBaseline", "Document" "Document", "ManagedInstance" "ManagedInstance", :parameter "Parameter"} input), :shape "ResourceTypeForTagging"})

(clojure.core/defn- ser-document-version-number [input] #:http.request.field{:value input, :shape "DocumentVersionNumber"})

(clojure.core/defn- ser-command-id [input] #:http.request.field{:value input, :shape "CommandId"})

(clojure.core/defn- ser-patch-source-name [input] #:http.request.field{:value input, :shape "PatchSourceName"})

(clojure.core/defn- ser-inventory-item-entry-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-item-entry coll) #:http.request.field{:shape "InventoryItemEntry"}))) input), :shape "InventoryItemEntryList", :type "list", :max 10000, :min 0})

(clojure.core/defn- ser-association-status-name [input] #:http.request.field{:value (clojure.core/get {"Pending" "Pending", :pending "Pending", "Success" "Success", :success "Success", "Failed" "Failed", :failed "Failed"} input), :shape "AssociationStatusName"})

(clojure.core/defn- ser-command-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-command-filter-key (:key input)) #:http.request.field{:name "key", :shape "CommandFilterKey"}) (clojure.core/into (ser-command-filter-value (:value input)) #:http.request.field{:name "value", :shape "CommandFilterValue"})], :shape "CommandFilter", :type "structure"}))

(clojure.core/defn- ser-session-filter-value [input] #:http.request.field{:value input, :shape "SessionFilterValue"})

(clojure.core/defn- ser-maintenance-window-filter-value [input] #:http.request.field{:value input, :shape "MaintenanceWindowFilterValue"})

(clojure.core/defn- ser-resource-data-sync-name [input] #:http.request.field{:value input, :shape "ResourceDataSyncName"})

(clojure.core/defn- ser-patch-rule-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-rule coll) #:http.request.field{:shape "PatchRule"}))) input), :shape "PatchRuleList", :type "list", :max 10, :min 0})

(clojure.core/defn- ser-owner-information [input] #:http.request.field{:value input, :shape "OwnerInformation"})

(clojure.core/defn- ser-describe-activations-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-describe-activations-filter coll) #:http.request.field{:shape "DescribeActivationsFilter"}))) input), :shape "DescribeActivationsFilterList", :type "list"})

(clojure.core/defn- ser-maintenance-window-string-date-time [input] #:http.request.field{:value input, :shape "MaintenanceWindowStringDateTime"})

(clojure.core/defn- ser-describe-activations-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DescribeActivationsFilter", :type "structure"} (clojure.core/contains? input :filter-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-activations-filter-keys (input :filter-key)) #:http.request.field{:name "FilterKey", :shape "DescribeActivationsFilterKeys"})) (clojure.core/contains? input :filter-values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string-list (input :filter-values)) #:http.request.field{:name "FilterValues", :shape "StringList"}))))

(clojure.core/defn- ser-service-setting-id [input] #:http.request.field{:value input, :shape "ServiceSettingId"})

(clojure.core/defn- ser-s-3-output-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3OutputLocation", :type "structure"} (clojure.core/contains? input :output-s-3-region) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-region (input :output-s-3-region)) #:http.request.field{:name "OutputS3Region", :shape "S3Region"})) (clojure.core/contains? input :output-s-3-bucket-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket-name (input :output-s-3-bucket-name)) #:http.request.field{:name "OutputS3BucketName", :shape "S3BucketName"})) (clojure.core/contains? input :output-s-3-key-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :output-s-3-key-prefix)) #:http.request.field{:name "OutputS3KeyPrefix", :shape "S3KeyPrefix"}))))

(clojure.core/defn- ser-automation-parameter-value [input] #:http.request.field{:value input, :shape "AutomationParameterValue"})

(clojure.core/defn- ser-patch-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-filter-value coll) #:http.request.field{:shape "PatchFilterValue"}))) input), :shape "PatchFilterValueList", :type "list", :max 20, :min 1})

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-create-association-batch-request-entries [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-create-association-batch-request-entry coll) #:http.request.field{:shape "CreateAssociationBatchRequestEntry"}))) input), :shape "CreateAssociationBatchRequestEntries", :type "list", :min 1})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-tag-key (:key input)) #:http.request.field{:name "Key", :shape "TagKey"}) (clojure.core/into (ser-tag-value (:value input)) #:http.request.field{:name "Value", :shape "TagValue"})], :shape "Tag", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-schedule [input] #:http.request.field{:value input, :shape "MaintenanceWindowSchedule"})

(clojure.core/defn- ser-inventory-item-type-name [input] #:http.request.field{:value input, :shape "InventoryItemTypeName"})

(clojure.core/defn- ser-result-attribute-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-result-attribute coll) #:http.request.field{:shape "ResultAttribute"}))) input), :shape "ResultAttributeList", :type "list", :max 1, :min 1})

(clojure.core/defn- ser-document-key-values-filter-key [input] #:http.request.field{:value input, :shape "DocumentKeyValuesFilterKey"})

(clojure.core/defn- ser-maintenance-window-task-invocation-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowTaskInvocationParameters", :type "structure"} (clojure.core/contains? input :run-command) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-run-command-parameters (input :run-command)) #:http.request.field{:name "RunCommand", :shape "MaintenanceWindowRunCommandParameters"})) (clojure.core/contains? input :automation) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-automation-parameters (input :automation)) #:http.request.field{:name "Automation", :shape "MaintenanceWindowAutomationParameters"})) (clojure.core/contains? input :step-functions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-step-functions-parameters (input :step-functions)) #:http.request.field{:name "StepFunctions", :shape "MaintenanceWindowStepFunctionsParameters"})) (clojure.core/contains? input :lambda) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-parameters (input :lambda)) #:http.request.field{:name "Lambda", :shape "MaintenanceWindowLambdaParameters"}))))

(clojure.core/defn- ser-step-execution-filter-key [input] #:http.request.field{:value (clojure.core/get {:step-execution-status "StepExecutionStatus", "StartTimeBefore" "StartTimeBefore", "StepExecutionStatus" "StepExecutionStatus", "StepExecutionId" "StepExecutionId", :step-execution-id "StepExecutionId", :start-time-before "StartTimeBefore", "StartTimeAfter" "StartTimeAfter", :step-name "StepName", "StepName" "StepName", :action "Action", "Action" "Action", :start-time-after "StartTimeAfter"} input), :shape "StepExecutionFilterKey"})

(clojure.core/defn- ser-document-name [input] #:http.request.field{:value input, :shape "DocumentName"})

(clojure.core/defn- ser-compliance-item-content-hash [input] #:http.request.field{:value input, :shape "ComplianceItemContentHash"})

(clojure.core/defn- ser-maintenance-window-step-functions-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowStepFunctionsParameters", :type "structure"} (clojure.core/contains? input :input) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-step-functions-input (input :input)) #:http.request.field{:name "Input", :shape "MaintenanceWindowStepFunctionsInput"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-step-functions-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowStepFunctionsName"}))))

(clojure.core/defn- ser-patch-filter-value [input] #:http.request.field{:value input, :shape "PatchFilterValue"})

(clojure.core/defn- ser-maintenance-window-task-type [input] #:http.request.field{:value (clojure.core/get {"RUN_COMMAND" "RUN_COMMAND", :run-command "RUN_COMMAND", "AUTOMATION" "AUTOMATION", :automation "AUTOMATION", "STEP_FUNCTIONS" "STEP_FUNCTIONS", :step-functions "STEP_FUNCTIONS", "LAMBDA" "LAMBDA", :lambda "LAMBDA"} input), :shape "MaintenanceWindowTaskType"})

(clojure.core/defn- ser-maintenance-window-allow-unassociated-targets [input] #:http.request.field{:value input, :shape "MaintenanceWindowAllowUnassociatedTargets"})

(clojure.core/defn- ser-session-manager-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-session-manager-parameter-name k) #:http.request.field{:map-info "key", :shape "SessionManagerParameterName"}) (clojure.core/into (ser-session-manager-parameter-value-list v) #:http.request.field{:map-info "value", :shape "SessionManagerParameterValueList"})])) input), :shape "SessionManagerParameters", :type "map"})

(clojure.core/defn- ser-inventory-item [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-item-type-name (:type-name input)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"}) (clojure.core/into (ser-inventory-item-schema-version (:schema-version input)) #:http.request.field{:name "SchemaVersion", :shape "InventoryItemSchemaVersion"}) (clojure.core/into (ser-inventory-item-capture-time (:capture-time input)) #:http.request.field{:name "CaptureTime", :shape "InventoryItemCaptureTime"})], :shape "InventoryItem", :type "structure"} (clojure.core/contains? input :content-hash) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-content-hash (input :content-hash)) #:http.request.field{:name "ContentHash", :shape "InventoryItemContentHash"})) (clojure.core/contains? input :content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-entry-list (input :content)) #:http.request.field{:name "Content", :shape "InventoryItemEntryList"})) (clojure.core/contains? input :context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-content-context (input :context)) #:http.request.field{:name "Context", :shape "InventoryItemContentContext"}))))

(clojure.core/defn- ser-command-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-command-filter coll) #:http.request.field{:shape "CommandFilter"}))) input), :shape "CommandFilterList", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-inventory-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-group coll) #:http.request.field{:shape "InventoryGroup"}))) input), :shape "InventoryGroupList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-document-version [input] #:http.request.field{:value input, :shape "DocumentVersion"})

(clojure.core/defn- ser-target [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Target", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-key (input :key)) #:http.request.field{:name "Key", :shape "TargetKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-values (input :values)) #:http.request.field{:name "Values", :shape "TargetValues"}))))

(clojure.core/defn- ser-document-hash-type [input] #:http.request.field{:value (clojure.core/get {"Sha256" "Sha256", :sha-256 "Sha256", "Sha1" "Sha1", :sha-1 "Sha1"} input), :shape "DocumentHashType"})

(clojure.core/defn- ser-session-filter-key [input] #:http.request.field{:value (clojure.core/get {"InvokedBefore" "InvokedBefore", "InvokedAfter" "InvokedAfter", "Status" "Status", :invoked-before "InvokedBefore", :invoked-after "InvokedAfter", :status "Status", "Owner" "Owner", :target "Target", "Target" "Target", :owner "Owner"} input), :shape "SessionFilterKey"})

(clojure.core/defn- ser-maintenance-window-filter-key [input] #:http.request.field{:value input, :shape "MaintenanceWindowFilterKey"})

(clojure.core/defn- ser-document-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-document-filter-key (:key input)) #:http.request.field{:name "key", :shape "DocumentFilterKey"}) (clojure.core/into (ser-document-filter-value (:value input)) #:http.request.field{:name "value", :shape "DocumentFilterValue"})], :shape "DocumentFilter", :type "structure"}))

(clojure.core/defn- ser-session-manager-parameter-value [input] #:http.request.field{:value input, :shape "SessionManagerParameterValue"})

(clojure.core/defn- ser-describe-activations-filter-keys [input] #:http.request.field{:value (clojure.core/get {"ActivationIds" "ActivationIds", :activation-ids "ActivationIds", "DefaultInstanceName" "DefaultInstanceName", :default-instance-name "DefaultInstanceName", "IamRole" "IamRole", :iam-role "IamRole"} input), :shape "DescribeActivationsFilterKeys"})

(clojure.core/defn- ser-maintenance-window-timezone [input] #:http.request.field{:value input, :shape "MaintenanceWindowTimezone"})

(clojure.core/defn- ser-association-compliance-severity [input] #:http.request.field{:value (clojure.core/get {:unspecified "UNSPECIFIED", "CRITICAL" "CRITICAL", :medium "MEDIUM", "LOW" "LOW", :high "HIGH", :critical "CRITICAL", "HIGH" "HIGH", :low "LOW", "UNSPECIFIED" "UNSPECIFIED", "MEDIUM" "MEDIUM"} input), :shape "AssociationComplianceSeverity"})

(clojure.core/defn- ser-activation-description [input] #:http.request.field{:value input, :shape "ActivationDescription"})

(clojure.core/defn- ser-is-sub-type-schema [input] #:http.request.field{:value input, :shape "IsSubTypeSchema"})

(clojure.core/defn- ser-compliance-filter-value [input] #:http.request.field{:value input, :shape "ComplianceFilterValue"})

(clojure.core/defn- ser-ps-parameter-name [input] #:http.request.field{:value input, :shape "PSParameterName"})

(clojure.core/defn- ser-instance-association-output-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceAssociationOutputLocation", :type "structure"} (clojure.core/contains? input :s-3-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-output-location (input :s-3-location)) #:http.request.field{:name "S3Location", :shape "S3OutputLocation"}))))

(clojure.core/defn- ser-session-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-session-filter-key (:key input)) #:http.request.field{:name "key", :shape "SessionFilterKey"}) (clojure.core/into (ser-session-filter-value (:value input)) #:http.request.field{:name "value", :shape "SessionFilterValue"})], :shape "SessionFilter", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-automation-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowAutomationParameters", :type "structure"} (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-map (input :parameters)) #:http.request.field{:name "Parameters", :shape "AutomationParameterMap"}))))

(clojure.core/defn- ser-compliance-resource-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-resource-id coll) #:http.request.field{:shape "ComplianceResourceId"}))) input), :shape "ComplianceResourceIdList", :type "list", :min 1})

(clojure.core/defn- ser-inventory-item-capture-time [input] #:http.request.field{:value input, :shape "InventoryItemCaptureTime"})

(clojure.core/defn- ser-association-execution-targets-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-association-execution-targets-filter-key (:key input)) #:http.request.field{:name "Key", :shape "AssociationExecutionTargetsFilterKey"}) (clojure.core/into (ser-association-execution-targets-filter-value (:value input)) #:http.request.field{:name "Value", :shape "AssociationExecutionTargetsFilterValue"})], :shape "AssociationExecutionTargetsFilter", :type "structure"}))

(clojure.core/defn- ser-baseline-description [input] #:http.request.field{:value input, :shape "BaselineDescription"})

(clojure.core/defn- ser-maintenance-window-execution-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowExecutionId"})

(clojure.core/defn- ser-compliance-query-operator-type [input] #:http.request.field{:value (clojure.core/get {"BEGIN_WITH" "BEGIN_WITH", "GREATER_THAN" "GREATER_THAN", :less-than "LESS_THAN", :greater-than "GREATER_THAN", "LESS_THAN" "LESS_THAN", :not-equal "NOT_EQUAL", :begin-with "BEGIN_WITH", "EQUAL" "EQUAL", :equal "EQUAL", "NOT_EQUAL" "NOT_EQUAL"} input), :shape "ComplianceQueryOperatorType"})

(clojure.core/defn- ser-automation-execution-id [input] #:http.request.field{:value input, :shape "AutomationExecutionId"})

(clojure.core/defn- ser-target-value [input] #:http.request.field{:value input, :shape "TargetValue"})

(clojure.core/defn- ser-patch-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-filter coll) #:http.request.field{:shape "PatchFilter"}))) input), :shape "PatchFilterList", :type "list", :max 4, :min 0})

(clojure.core/defn- ser-inventory-deletion-id [input] #:http.request.field{:value input, :shape "InventoryDeletionId"})

(clojure.core/defn- ser-region [input] #:http.request.field{:value input, :shape "Region"})

(clojure.core/defn- ser-patch-source-product [input] #:http.request.field{:value input, :shape "PatchSourceProduct"})

(clojure.core/defn- ser-instance-patch-state-operator-type [input] #:http.request.field{:value (clojure.core/get {"Equal" "Equal", :equal "Equal", "NotEqual" "NotEqual", :not-equal "NotEqual", "LessThan" "LessThan", :less-than "LessThan", "GreaterThan" "GreaterThan", :greater-than "GreaterThan"} input), :shape "InstancePatchStateOperatorType"})

(clojure.core/defn- ser-maintenance-window-task-parameter-value-expression [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowTaskParameterValueExpression", :type "structure", :sensitive true} (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-parameter-value-list (input :values)) #:http.request.field{:name "Values", :shape "MaintenanceWindowTaskParameterValueList"}))))

(clojure.core/defn- ser-target-map-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-map-value coll) #:http.request.field{:shape "TargetMapValue"}))) input), :shape "TargetMapValueList", :type "list", :max 25, :min 0})

(clojure.core/defn- ser-target-key [input] #:http.request.field{:value input, :shape "TargetKey"})

(clojure.core/defn- ser-automation-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-automation-parameter-value coll) #:http.request.field{:shape "AutomationParameterValue"}))) input), :shape "AutomationParameterValueList", :type "list", :max 10, :min 0})

(clojure.core/defn- ser-compliance-item-details [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "ComplianceItemDetails", :type "map"})

(clojure.core/defn- ser-maintenance-window-task-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-maintenance-window-task-parameter-value coll) #:http.request.field{:shape "MaintenanceWindowTaskParameterValue"}))) input), :shape "MaintenanceWindowTaskParameterValueList", :type "list", :sensitive true})

(clojure.core/defn- ser-instance-information-string-filter-key [input] #:http.request.field{:value input, :shape "InstanceInformationStringFilterKey"})

(clojure.core/defn- ser-max-results-ec-2-compatible [input] #:http.request.field{:value input, :shape "MaxResultsEC2Compatible"})

(clojure.core/defn- ser-association-execution-targets-filter-key [input] #:http.request.field{:value (clojure.core/get {"Status" "Status", :status "Status", "ResourceId" "ResourceId", :resource-id "ResourceId", "ResourceType" "ResourceType", :resource-type "ResourceType"} input), :shape "AssociationExecutionTargetsFilterKey"})

(clojure.core/defn- ser-operating-system [input] #:http.request.field{:value (clojure.core/get {"AMAZON_LINUX_2" "AMAZON_LINUX_2", :windows "WINDOWS", "WINDOWS" "WINDOWS", "CENTOS" "CENTOS", :amazon-linux-2 "AMAZON_LINUX_2", :suse "SUSE", :centos "CENTOS", "REDHAT_ENTERPRISE_LINUX" "REDHAT_ENTERPRISE_LINUX", "AMAZON_LINUX" "AMAZON_LINUX", "UBUNTU" "UBUNTU", "SUSE" "SUSE", :redhat-enterprise-linux "REDHAT_ENTERPRISE_LINUX", :amazon-linux "AMAZON_LINUX", :ubuntu "UBUNTU"} input), :shape "OperatingSystem"})

(clojure.core/defn- ser-association-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-association-filter-key (:key input)) #:http.request.field{:name "key", :shape "AssociationFilterKey"}) (clojure.core/into (ser-association-filter-value (:value input)) #:http.request.field{:name "value", :shape "AssociationFilterValue"})], :shape "AssociationFilter", :type "structure"}))

(clojure.core/defn- ser-client-token [input] #:http.request.field{:value input, :shape "ClientToken"})

(clojure.core/defn- ser-notification-event-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-notification-event coll) #:http.request.field{:shape "NotificationEvent"}))) input), :shape "NotificationEventList", :type "list"})

(clojure.core/defn- ser-snapshot-id [input] #:http.request.field{:value input, :shape "SnapshotId"})

(clojure.core/defn- ser-registration-limit [input] #:http.request.field{:value input, :shape "RegistrationLimit"})

(clojure.core/defn- ser-parameter-value [input] #:http.request.field{:value input, :shape "ParameterValue"})

(clojure.core/defn- ser-association-filter-operator-type [input] #:http.request.field{:value (clojure.core/get {"EQUAL" "EQUAL", :equal "EQUAL", "LESS_THAN" "LESS_THAN", :less-than "LESS_THAN", "GREATER_THAN" "GREATER_THAN", :greater-than "GREATER_THAN"} input), :shape "AssociationFilterOperatorType"})

(clojure.core/defn- ser-date-time [input] #:http.request.field{:value input, :shape "DateTime"})

(clojure.core/defn- ser-target-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-value coll) #:http.request.field{:shape "TargetValue"}))) input), :shape "TargetValues", :type "list", :max 50, :min 0})

(clojure.core/defn- ser-maintenance-window-task-parameter-value [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskParameterValue"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- ser-maintenance-window-resource-type [input] #:http.request.field{:value (clojure.core/get {"INSTANCE" "INSTANCE", :instance "INSTANCE"} input), :shape "MaintenanceWindowResourceType"})

(clojure.core/defn- req-update-maintenance-window-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-task-id (input :window-task-id)) #:http.request.field{:name "WindowTaskId", :shape "MaintenanceWindowTaskId"})]} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-priority (input :priority)) #:http.request.field{:name "Priority", :shape "MaintenanceWindowTaskPriority", :box true})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :logging-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-logging-info (input :logging-info)) #:http.request.field{:name "LoggingInfo", :shape "LoggingInfo"})) (clojure.core/contains? input :task-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-arn (input :task-arn)) #:http.request.field{:name "TaskArn", :shape "MaintenanceWindowTaskArn"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :task-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-parameters (input :task-parameters)) #:http.request.field{:name "TaskParameters", :shape "MaintenanceWindowTaskParameters"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :task-invocation-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-invocation-parameters (input :task-invocation-parameters)) #:http.request.field{:name "TaskInvocationParameters", :shape "MaintenanceWindowTaskInvocationParameters"}))))

(clojure.core/defn- req-get-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]}))

(clojure.core/defn- req-get-deployable-patch-snapshot-for-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-snapshot-id (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "SnapshotId"})]}))

(clojure.core/defn- req-describe-association-execution-targets-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"}) (clojure.core/into (ser-association-execution-id (input :execution-id)) #:http.request.field{:name "ExecutionId", :shape "AssociationExecutionId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-execution-targets-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "AssociationExecutionTargetsFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-maintenance-window-executions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-register-task-with-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"}) (clojure.core/into (ser-maintenance-window-task-arn (input :task-arn)) #:http.request.field{:name "TaskArn", :shape "MaintenanceWindowTaskArn"}) (clojure.core/into (ser-maintenance-window-task-type (input :task-type)) #:http.request.field{:name "TaskType", :shape "MaintenanceWindowTaskType"}) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"}) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})]} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-priority (input :priority)) #:http.request.field{:name "Priority", :shape "MaintenanceWindowTaskPriority", :box true})) (clojure.core/contains? input :logging-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-logging-info (input :logging-info)) #:http.request.field{:name "LoggingInfo", :shape "LoggingInfo"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :task-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-parameters (input :task-parameters)) #:http.request.field{:name "TaskParameters", :shape "MaintenanceWindowTaskParameters"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :task-invocation-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-invocation-parameters (input :task-invocation-parameters)) #:http.request.field{:name "TaskInvocationParameters", :shape "MaintenanceWindowTaskInvocationParameters"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-start-session-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-target (input :target)) #:http.request.field{:name "Target", :shape "SessionTarget"})]} (clojure.core/contains? input :document-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :document-name)) #:http.request.field{:name "DocumentName", :shape "DocumentARN"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-manager-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "SessionManagerParameters"}))))

(clojure.core/defn- req-list-documents-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :document-filter-list) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-filter-list (input :document-filter-list)) #:http.request.field{:name "DocumentFilterList", :shape "DocumentFilterList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-key-values-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "DocumentKeyValuesFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-parameter-history-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"})]} (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-connection-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-target (input :target)) #:http.request.field{:name "Target", :shape "SessionTarget"})]}))

(clojure.core/defn- req-get-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})]} (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :document-format) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-format (input :document-format)) #:http.request.field{:name "DocumentFormat", :shape "DocumentFormat"}))))

(clojure.core/defn- req-get-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]}))

(clojure.core/defn- req-describe-maintenance-window-execution-tasks-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-maintenance-window-execution-task-invocation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"}) (clojure.core/into (ser-maintenance-window-execution-task-id (input :task-id)) #:http.request.field{:name "TaskId", :shape "MaintenanceWindowExecutionTaskId"}) (clojure.core/into (ser-maintenance-window-execution-task-invocation-id (input :invocation-id)) #:http.request.field{:name "InvocationId", :shape "MaintenanceWindowExecutionTaskInvocationId"})]}))

(clojure.core/defn- req-send-automation-signal-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"}) (clojure.core/into (ser-signal-type (input :signal-type)) #:http.request.field{:name "SignalType", :shape "SignalType"})]} (clojure.core/contains? input :payload) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-map (input :payload)) #:http.request.field{:name "Payload", :shape "AutomationParameterMap"}))))

(clojure.core/defn- req-describe-maintenance-window-schedule-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :window-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "MaintenanceWindowResourceType"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-search-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowSearchMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-deregister-managed-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-managed-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "ManagedInstanceId"})]}))

(clojure.core/defn- req-cancel-command-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"})]} (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdList"}))))

(clojure.core/defn- req-register-default-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]}))

(clojure.core/defn- req-describe-effective-patches-for-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-list-tags-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-type-for-tagging (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceTypeForTagging"}) (clojure.core/into (ser-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceId"})]}))

(clojure.core/defn- req-describe-maintenance-window-execution-task-invocations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"}) (clojure.core/into (ser-maintenance-window-execution-task-id (input :task-id)) #:http.request.field{:name "TaskId", :shape "MaintenanceWindowExecutionTaskId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-service-setting-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-service-setting-id (input :setting-id)) #:http.request.field{:name "SettingId", :shape "ServiceSettingId"})]}))

(clojure.core/defn- req-list-compliance-summaries-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ComplianceStringFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-label-parameter-version-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"}) (clojure.core/into (ser-parameter-label-list (input :labels)) #:http.request.field{:name "Labels", :shape "ParameterLabelList"})]} (clojure.core/contains? input :parameter-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ps-parameter-version (input :parameter-version)) #:http.request.field{:name "ParameterVersion", :shape "PSParameterVersion", :box true}))))

(clojure.core/defn- req-describe-patch-group-state-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]}))

(clojure.core/defn- req-get-parameter-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"})]} (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true}))))

(clojure.core/defn- req-describe-maintenance-window-targets-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-update-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :allow-unassociated-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-allow-unassociated-targets (input :allow-unassociated-targets)) #:http.request.field{:name "AllowUnassociatedTargets", :shape "MaintenanceWindowAllowUnassociatedTargets", :box true})) (clojure.core/contains? input :end-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :end-date)) #:http.request.field{:name "EndDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-enabled (input :enabled)) #:http.request.field{:name "Enabled", :shape "MaintenanceWindowEnabled", :box true})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-duration-hours (input :duration)) #:http.request.field{:name "Duration", :shape "MaintenanceWindowDurationHours", :box true})) (clojure.core/contains? input :cutoff) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-cutoff (input :cutoff)) #:http.request.field{:name "Cutoff", :shape "MaintenanceWindowCutoff", :box true})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true})) (clojure.core/contains? input :schedule) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-schedule (input :schedule)) #:http.request.field{:name "Schedule", :shape "MaintenanceWindowSchedule"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :start-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :start-date)) #:http.request.field{:name "StartDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :schedule-timezone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-timezone (input :schedule-timezone)) #:http.request.field{:name "ScheduleTimezone", :shape "MaintenanceWindowTimezone"}))))

(clojure.core/defn- req-create-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-content (input :content)) #:http.request.field{:name "Content", :shape "DocumentContent"}) (clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]} (clojure.core/contains? input :attachments) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-list (input :attachments)) #:http.request.field{:name "Attachments", :shape "AttachmentsSourceList"})) (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"})) (clojure.core/contains? input :document-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-type (input :document-type)) #:http.request.field{:name "DocumentType", :shape "DocumentType"})) (clojure.core/contains? input :document-format) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-format (input :document-format)) #:http.request.field{:name "DocumentFormat", :shape "DocumentFormat"})) (clojure.core/contains? input :target-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-type (input :target-type)) #:http.request.field{:name "TargetType", :shape "TargetType"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-resource-data-sync-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-data-sync-name (input :sync-name)) #:http.request.field{:name "SyncName", :shape "ResourceDataSyncName"})]}))

(clojure.core/defn- req-deregister-task-from-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-task-id (input :window-task-id)) #:http.request.field{:name "WindowTaskId", :shape "MaintenanceWindowTaskId"})]}))

(clojure.core/defn- req-describe-maintenance-windows-for-target-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"}) (clojure.core/into (ser-maintenance-window-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "MaintenanceWindowResourceType"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-search-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowSearchMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-create-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"}) (clojure.core/into (ser-maintenance-window-schedule (input :schedule)) #:http.request.field{:name "Schedule", :shape "MaintenanceWindowSchedule"}) (clojure.core/into (ser-maintenance-window-duration-hours (input :duration)) #:http.request.field{:name "Duration", :shape "MaintenanceWindowDurationHours"}) (clojure.core/into (ser-maintenance-window-cutoff (input :cutoff)) #:http.request.field{:name "Cutoff", :shape "MaintenanceWindowCutoff"}) (clojure.core/into (ser-maintenance-window-allow-unassociated-targets (input :allow-unassociated-targets)) #:http.request.field{:name "AllowUnassociatedTargets", :shape "MaintenanceWindowAllowUnassociatedTargets"})]} (clojure.core/contains? input :end-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :end-date)) #:http.request.field{:name "EndDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true})) (clojure.core/contains? input :start-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :start-date)) #:http.request.field{:name "StartDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :schedule-timezone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-timezone (input :schedule-timezone)) #:http.request.field{:name "ScheduleTimezone", :shape "MaintenanceWindowTimezone"}))))

(clojure.core/defn- req-describe-document-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"}) (clojure.core/into (ser-document-permission-type (input :permission-type)) #:http.request.field{:name "PermissionType", :shape "DocumentPermissionType"})]}))

(clojure.core/defn- req-describe-maintenance-window-tasks-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-list-resource-compliance-summaries-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ComplianceStringFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-update-association-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"}) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-association-status (input :association-status)) #:http.request.field{:name "AssociationStatus", :shape "AssociationStatus"})]}))

(clojure.core/defn- req-describe-parameters-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ParametersFilterList"})) (clojure.core/contains? input :parameter-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-filter-list (input :parameter-filters)) #:http.request.field{:name "ParameterFilters", :shape "ParameterStringFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-deregister-patch-baseline-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"}) (clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]}))

(clojure.core/defn- req-list-association-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-cancel-maintenance-window-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"})]}))

(clojure.core/defn- req-delete-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]}))

(clojure.core/defn- req-list-inventory-entries-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-inventory-item-type-name (input :type-name)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InventoryFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-list-associations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :association-filter-list) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-filter-list (input :association-filter-list)) #:http.request.field{:name "AssociationFilterList", :shape "AssociationFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-start-automation-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :document-name)) #:http.request.field{:name "DocumentName", :shape "DocumentARN"})]} (clojure.core/contains? input :target-maps) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-maps (input :target-maps)) #:http.request.field{:name "TargetMaps", :shape "TargetMaps"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-map (input :parameters)) #:http.request.field{:name "Parameters", :shape "AutomationParameterMap"})) (clojure.core/contains? input :target-locations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-locations (input :target-locations)) #:http.request.field{:name "TargetLocations", :shape "TargetLocations", :box true})) (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-mode (input :mode)) #:http.request.field{:name "Mode", :shape "ExecutionMode"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion", :box true})) (clojure.core/contains? input :target-parameter-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-key (input :target-parameter-name)) #:http.request.field{:name "TargetParameterName", :shape "AutomationParameterKey"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-idempotency-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "IdempotencyToken"}))))

(clojure.core/defn- req-describe-inventory-deletions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :deletion-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-deletion-id (input :deletion-id)) #:http.request.field{:name "DeletionId", :shape "InventoryDeletionId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-describe-association-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :association-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})) (clojure.core/contains? input :association-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-version (input :association-version)) #:http.request.field{:name "AssociationVersion", :shape "AssociationVersion"}))))

(clojure.core/defn- req-describe-instance-patches-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchComplianceMaxResults", :box true}))))

(clojure.core/defn- req-create-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})]} (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :compliance-severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-compliance-severity (input :compliance-severity)) #:http.request.field{:name "ComplianceSeverity", :shape "AssociationComplianceSeverity"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :automation-target-parameter-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-target-parameter-name (input :automation-target-parameter-name)) #:http.request.field{:name "AutomationTargetParameterName", :shape "AutomationTargetParameterName"})) (clojure.core/contains? input :association-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-name (input :association-name)) #:http.request.field{:name "AssociationName", :shape "AssociationName"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "ScheduleExpression"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :output-location) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-association-output-location (input :output-location)) #:http.request.field{:name "OutputLocation", :shape "InstanceAssociationOutputLocation"}))))

(clojure.core/defn- req-describe-automation-step-executions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-step-execution-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "StepExecutionFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :reverse-order) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reverse-order)) #:http.request.field{:name "ReverseOrder", :shape "Boolean", :box true}))))

(clojure.core/defn- req-put-compliance-items-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-compliance-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ComplianceResourceId"}) (clojure.core/into (ser-compliance-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ComplianceResourceType"}) (clojure.core/into (ser-compliance-type-name (input :compliance-type)) #:http.request.field{:name "ComplianceType", :shape "ComplianceTypeName"}) (clojure.core/into (ser-compliance-execution-summary (input :execution-summary)) #:http.request.field{:name "ExecutionSummary", :shape "ComplianceExecutionSummary"}) (clojure.core/into (ser-compliance-item-entry-list (input :items)) #:http.request.field{:name "Items", :shape "ComplianceItemEntryList"})]} (clojure.core/contains? input :item-content-hash) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-content-hash (input :item-content-hash)) #:http.request.field{:name "ItemContentHash", :shape "ComplianceItemContentHash"}))))

(clojure.core/defn- req-update-document-default-version-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"}) (clojure.core/into (ser-document-version-number (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersionNumber"})]}))

(clojure.core/defn- req-update-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]} (clojure.core/contains? input :rejected-patches-action) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-action (input :rejected-patches-action)) #:http.request.field{:name "RejectedPatchesAction", :shape "PatchAction"})) (clojure.core/contains? input :global-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-filter-group (input :global-filters)) #:http.request.field{:name "GlobalFilters", :shape "PatchFilterGroup"})) (clojure.core/contains? input :approved-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :approved-patches)) #:http.request.field{:name "ApprovedPatches", :shape "PatchIdList"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baseline-description (input :description)) #:http.request.field{:name "Description", :shape "BaselineDescription"})) (clojure.core/contains? input :approved-patches-enable-non-security) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :approved-patches-enable-non-security)) #:http.request.field{:name "ApprovedPatchesEnableNonSecurity", :shape "Boolean", :box true})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true})) (clojure.core/contains? input :approval-rules) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-rule-group (input :approval-rules)) #:http.request.field{:name "ApprovalRules", :shape "PatchRuleGroup"})) (clojure.core/contains? input :approved-patches-compliance-level) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-level (input :approved-patches-compliance-level)) #:http.request.field{:name "ApprovedPatchesComplianceLevel", :shape "PatchComplianceLevel"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baseline-name (input :name)) #:http.request.field{:name "Name", :shape "BaselineName"})) (clojure.core/contains? input :sources) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-source-list (input :sources)) #:http.request.field{:name "Sources", :shape "PatchSourceList"})) (clojure.core/contains? input :rejected-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :rejected-patches)) #:http.request.field{:name "RejectedPatches", :shape "PatchIdList"}))))

(clojure.core/defn- req-update-managed-instance-role-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-managed-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "ManagedInstanceId"}) (clojure.core/into (ser-iam-role (input :iam-role)) #:http.request.field{:name "IamRole", :shape "IamRole"})]}))

(clojure.core/defn- req-list-document-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-modify-document-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"}) (clojure.core/into (ser-document-permission-type (input :permission-type)) #:http.request.field{:name "PermissionType", :shape "DocumentPermissionType"})]} (clojure.core/contains? input :account-ids-to-add) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-account-id-list (input :account-ids-to-add)) #:http.request.field{:name "AccountIdsToAdd", :shape "AccountIdList"})) (clojure.core/contains? input :account-ids-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-account-id-list (input :account-ids-to-remove)) #:http.request.field{:name "AccountIdsToRemove", :shape "AccountIdList"}))))

(clojure.core/defn- req-list-resource-data-sync-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-get-parameters-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-parameter-name-list (input :names)) #:http.request.field{:name "Names", :shape "ParameterNameList"})]} (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true}))))

(clojure.core/defn- req-put-parameter-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"}) (clojure.core/into (ser-ps-parameter-value (input :value)) #:http.request.field{:name "Value", :shape "PSParameterValue"}) (clojure.core/into (ser-parameter-type (input :type)) #:http.request.field{:name "Type", :shape "ParameterType"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-description (input :description)) #:http.request.field{:name "Description", :shape "ParameterDescription"})) (clojure.core/contains? input :key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-key-id (input :key-id)) #:http.request.field{:name "KeyId", :shape "ParameterKeyId"})) (clojure.core/contains? input :overwrite) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :overwrite)) #:http.request.field{:name "Overwrite", :shape "Boolean", :box true})) (clojure.core/contains? input :allowed-pattern) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allowed-pattern (input :allowed-pattern)) #:http.request.field{:name "AllowedPattern", :shape "AllowedPattern"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-sessions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-state (input :state)) #:http.request.field{:name "State", :shape "SessionState"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "SessionMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "SessionFilterList"}))))

(clojure.core/defn- req-deregister-target-from-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-target-id (input :window-target-id)) #:http.request.field{:name "WindowTargetId", :shape "MaintenanceWindowTargetId"})]} (clojure.core/contains? input :safe) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :safe)) #:http.request.field{:name "Safe", :shape "Boolean", :box true}))))

(clojure.core/defn- req-list-commands-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :command-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "CommandMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "CommandFilterList"}))))

(clojure.core/defn- req-get-automation-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"})]}))

(clojure.core/defn- req-get-command-invocation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"}) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :plugin-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-plugin-name (input :plugin-name)) #:http.request.field{:name "PluginName", :shape "CommandPluginName"}))))

(clojure.core/defn- req-update-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-content (input :content)) #:http.request.field{:name "Content", :shape "DocumentContent"}) (clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]} (clojure.core/contains? input :attachments) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-list (input :attachments)) #:http.request.field{:name "Attachments", :shape "AttachmentsSourceList"})) (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :document-format) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-format (input :document-format)) #:http.request.field{:name "DocumentFormat", :shape "DocumentFormat"})) (clojure.core/contains? input :target-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-type (input :target-type)) #:http.request.field{:name "TargetType", :shape "TargetType"}))))

(clojure.core/defn- req-delete-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]}))

(clojure.core/defn- req-list-command-invocations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :command-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "CommandMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "CommandFilterList"})) (clojure.core/contains? input :details) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :details)) #:http.request.field{:name "Details", :shape "Boolean"}))))

(clojure.core/defn- req-describe-automation-executions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-execution-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "AutomationExecutionFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-update-service-setting-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-service-setting-id (input :setting-id)) #:http.request.field{:name "SettingId", :shape "ServiceSettingId"}) (clojure.core/into (ser-service-setting-value (input :setting-value)) #:http.request.field{:name "SettingValue", :shape "ServiceSettingValue"})]}))

(clojure.core/defn- req-create-resource-data-sync-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-data-sync-name (input :sync-name)) #:http.request.field{:name "SyncName", :shape "ResourceDataSyncName"}) (clojure.core/into (ser-resource-data-sync-s-3-destination (input :s-3-destination)) #:http.request.field{:name "S3Destination", :shape "ResourceDataSyncS3Destination"})]}))

(clojure.core/defn- req-describe-instance-information-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :instance-information-filter-list) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-information-filter-list (input :instance-information-filter-list)) #:http.request.field{:name "InstanceInformationFilterList", :shape "InstanceInformationFilterList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-information-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InstanceInformationStringFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results-ec-2-compatible (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResultsEC2Compatible", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-maintenance-windows-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-reset-service-setting-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-service-setting-id (input :setting-id)) #:http.request.field{:name "SettingId", :shape "ServiceSettingId"})]}))

(clojure.core/defn- req-delete-activation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-activation-id (input :activation-id)) #:http.request.field{:name "ActivationId", :shape "ActivationId"})]}))

(clojure.core/defn- req-stop-automation-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"})]} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stop-type (input :type)) #:http.request.field{:name "Type", :shape "StopType"}))))

(clojure.core/defn- req-describe-activations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-activations-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "DescribeActivationsFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-delete-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]}))

(clojure.core/defn- req-get-maintenance-window-execution-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"}) (clojure.core/into (ser-maintenance-window-execution-task-id (input :task-id)) #:http.request.field{:name "TaskId", :shape "MaintenanceWindowExecutionTaskId"})]}))

(clojure.core/defn- req-delete-parameter-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"})]}))

(clojure.core/defn- req-delete-inventory-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-inventory-item-type-name (input :type-name)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"})]} (clojure.core/contains? input :schema-delete-option) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-schema-delete-option (input :schema-delete-option)) #:http.request.field{:name "SchemaDeleteOption", :shape "InventorySchemaDeleteOption"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dry-run (input :dry-run)) #:http.request.field{:name "DryRun", :shape "DryRun"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-describe-effective-instance-associations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-effective-instance-association-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "EffectiveInstanceAssociationMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-inventory-schema-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :type-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-type-name-filter (input :type-name)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeNameFilter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-get-inventory-schema-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "GetInventorySchemaMaxResults", :box true})) (clojure.core/contains? input :aggregator) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aggregator-schema-only (input :aggregator)) #:http.request.field{:name "Aggregator", :shape "AggregatorSchemaOnly"})) (clojure.core/contains? input :sub-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-is-sub-type-schema (input :sub-type)) #:http.request.field{:name "SubType", :shape "IsSubTypeSchema", :box true}))))

(clojure.core/defn- req-update-maintenance-window-target-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-target-id (input :window-target-id)) #:http.request.field{:name "WindowTargetId", :shape "MaintenanceWindowTargetId"})]} (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :owner-information) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-information (input :owner-information)) #:http.request.field{:name "OwnerInformation", :shape "OwnerInformation"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true}))))

(clojure.core/defn- req-register-patch-baseline-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"}) (clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]}))

(clojure.core/defn- req-remove-tags-from-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-type-for-tagging (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceTypeForTagging"}) (clojure.core/into (ser-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceId"}) (clojure.core/into (ser-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "KeyList"})]}))

(clojure.core/defn- req-describe-instance-patch-states-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdList"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchComplianceMaxResults", :box true}))))

(clojure.core/defn- req-create-association-batch-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-create-association-batch-request-entries (input :entries)) #:http.request.field{:name "Entries", :shape "CreateAssociationBatchRequestEntries"})]}))

(clojure.core/defn- req-describe-instance-patch-states-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-patch-state-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InstancePatchStateFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchComplianceMaxResults", :box true}))))

(clojure.core/defn- req-send-command-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :document-name)) #:http.request.field{:name "DocumentName", :shape "DocumentARN"})]} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdList"})) (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "Comment", :shape "Comment"})) (clojure.core/contains? input :timeout-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-seconds (input :timeout-seconds)) #:http.request.field{:name "TimeoutSeconds", :shape "TimeoutSeconds", :box true})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :output-s-3-bucket-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket-name (input :output-s-3-bucket-name)) #:http.request.field{:name "OutputS3BucketName", :shape "S3BucketName"})) (clojure.core/contains? input :notification-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-config (input :notification-config)) #:http.request.field{:name "NotificationConfig", :shape "NotificationConfig"})) (clojure.core/contains? input :document-hash) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash (input :document-hash)) #:http.request.field{:name "DocumentHash", :shape "DocumentHash"})) (clojure.core/contains? input :cloud-watch-output-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloud-watch-output-config (input :cloud-watch-output-config)) #:http.request.field{:name "CloudWatchOutputConfig", :shape "CloudWatchOutputConfig"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :output-s-3-key-prefix) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :output-s-3-key-prefix)) #:http.request.field{:name "OutputS3KeyPrefix", :shape "S3KeyPrefix"})) (clojure.core/contains? input :output-s-3-region) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-region (input :output-s-3-region)) #:http.request.field{:name "OutputS3Region", :shape "S3Region"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :document-hash-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash-type (input :document-hash-type)) #:http.request.field{:name "DocumentHashType", :shape "DocumentHashType"}))))

(clojure.core/defn- req-get-inventory-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InventoryFilterList"})) (clojure.core/contains? input :aggregators) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-aggregator-list (input :aggregators)) #:http.request.field{:name "Aggregators", :shape "InventoryAggregatorList"})) (clojure.core/contains? input :result-attributes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-result-attribute-list (input :result-attributes)) #:http.request.field{:name "ResultAttributes", :shape "ResultAttributeList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-update-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})]} (clojure.core/contains? input :association-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-version (input :association-version)) #:http.request.field{:name "AssociationVersion", :shape "AssociationVersion"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :compliance-severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-compliance-severity (input :compliance-severity)) #:http.request.field{:name "ComplianceSeverity", :shape "AssociationComplianceSeverity"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :automation-target-parameter-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-target-parameter-name (input :automation-target-parameter-name)) #:http.request.field{:name "AutomationTargetParameterName", :shape "AutomationTargetParameterName"})) (clojure.core/contains? input :association-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-name (input :association-name)) #:http.request.field{:name "AssociationName", :shape "AssociationName"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "ScheduleExpression"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})) (clojure.core/contains? input :output-location) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-association-output-location (input :output-location)) #:http.request.field{:name "OutputLocation", :shape "InstanceAssociationOutputLocation"}))))

(clojure.core/defn- req-get-maintenance-window-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"})]}))

(clojure.core/defn- req-list-compliance-items-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ComplianceStringFilterList"})) (clojure.core/contains? input :resource-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-resource-id-list (input :resource-ids)) #:http.request.field{:name "ResourceIds", :shape "ComplianceResourceIdList"})) (clojure.core/contains? input :resource-types) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-resource-type-list (input :resource-types)) #:http.request.field{:name "ResourceTypes", :shape "ComplianceResourceTypeList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-start-associations-once-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id-list (input :association-ids)) #:http.request.field{:name "AssociationIds", :shape "AssociationIdList"})]}))

(clojure.core/defn- req-get-patch-baseline-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]} (clojure.core/contains? input :operating-system) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operating-system (input :operating-system)) #:http.request.field{:name "OperatingSystem", :shape "OperatingSystem"}))))

(clojure.core/defn- req-delete-association-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :association-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"}))))

(clojure.core/defn- req-register-target-with-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "MaintenanceWindowResourceType"}) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})]} (clojure.core/contains? input :owner-information) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-information (input :owner-information)) #:http.request.field{:name "OwnerInformation", :shape "OwnerInformation"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-delete-parameters-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-parameter-name-list (input :names)) #:http.request.field{:name "Names", :shape "ParameterNameList"})]}))

(clojure.core/defn- req-create-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-name (input :name)) #:http.request.field{:name "Name", :shape "BaselineName"})]} (clojure.core/contains? input :rejected-patches-action) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-action (input :rejected-patches-action)) #:http.request.field{:name "RejectedPatchesAction", :shape "PatchAction"})) (clojure.core/contains? input :global-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-filter-group (input :global-filters)) #:http.request.field{:name "GlobalFilters", :shape "PatchFilterGroup"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :approved-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :approved-patches)) #:http.request.field{:name "ApprovedPatches", :shape "PatchIdList"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baseline-description (input :description)) #:http.request.field{:name "Description", :shape "BaselineDescription"})) (clojure.core/contains? input :approved-patches-enable-non-security) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :approved-patches-enable-non-security)) #:http.request.field{:name "ApprovedPatchesEnableNonSecurity", :shape "Boolean", :box true})) (clojure.core/contains? input :approval-rules) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-rule-group (input :approval-rules)) #:http.request.field{:name "ApprovalRules", :shape "PatchRuleGroup"})) (clojure.core/contains? input :approved-patches-compliance-level) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-level (input :approved-patches-compliance-level)) #:http.request.field{:name "ApprovedPatchesComplianceLevel", :shape "PatchComplianceLevel"})) (clojure.core/contains? input :sources) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-source-list (input :sources)) #:http.request.field{:name "Sources", :shape "PatchSourceList"})) (clojure.core/contains? input :operating-system) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operating-system (input :operating-system)) #:http.request.field{:name "OperatingSystem", :shape "OperatingSystem"})) (clojure.core/contains? input :rejected-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :rejected-patches)) #:http.request.field{:name "RejectedPatches", :shape "PatchIdList"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-describe-patch-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-maintenance-window-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-task-id (input :window-task-id)) #:http.request.field{:name "WindowTaskId", :shape "MaintenanceWindowTaskId"})]}))

(clojure.core/defn- req-describe-available-patches-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-terminate-session-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-id (input :session-id)) #:http.request.field{:name "SessionId", :shape "SessionId"})]}))

(clojure.core/defn- req-describe-instance-associations-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-patch-baselines-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-add-tags-to-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-type-for-tagging (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceTypeForTagging"}) (clojure.core/into (ser-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceId"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})]}))

(clojure.core/defn- req-put-inventory-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-inventory-item-list (input :items)) #:http.request.field{:name "Items", :shape "InventoryItemList"})]}))

(clojure.core/defn- req-resume-session-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-id (input :session-id)) #:http.request.field{:name "SessionId", :shape "SessionId"})]}))

(clojure.core/defn- req-describe-association-executions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-execution-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "AssociationExecutionFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-parameters-by-path-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :path)) #:http.request.field{:name "Path", :shape "PSParameterName"})]} (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :recursive)) #:http.request.field{:name "Recursive", :shape "Boolean", :box true})) (clojure.core/contains? input :parameter-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-filter-list (input :parameter-filters)) #:http.request.field{:name "ParameterFilters", :shape "ParameterStringFilterList"})) (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-get-parameters-by-path-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "GetParametersByPathMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-default-patch-baseline-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :operating-system) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operating-system (input :operating-system)) #:http.request.field{:name "OperatingSystem", :shape "OperatingSystem"}))))

(clojure.core/defn- req-create-activation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-iam-role (input :iam-role)) #:http.request.field{:name "IamRole", :shape "IamRole"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-activation-description (input :description)) #:http.request.field{:name "Description", :shape "ActivationDescription"})) (clojure.core/contains? input :default-instance-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-instance-name (input :default-instance-name)) #:http.request.field{:name "DefaultInstanceName", :shape "DefaultInstanceName"})) (clojure.core/contains? input :registration-limit) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registration-limit (input :registration-limit)) #:http.request.field{:name "RegistrationLimit", :shape "RegistrationLimit", :box true})) (clojure.core/contains? input :expiration-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-expiration-date (input :expiration-date)) #:http.request.field{:name "ExpirationDate", :shape "ExpirationDate"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})]} (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"}))))

(clojure.core/declare deser-string-date-time)

(clojure.core/declare deser-parameter-history)

(clojure.core/declare deser-inventory-result-entity)

(clojure.core/declare deser-target-map)

(clojure.core/declare deser-command-plugin-output)

(clojure.core/declare deser-non-compliant-summary)

(clojure.core/declare deser-association-resource-id)

(clojure.core/declare deser-patch-compliance-data-list)

(clojure.core/declare deser-instance-id-list)

(clojure.core/declare deser-automation-parameter-key)

(clojure.core/declare deser-approve-after-days)

(clojure.core/declare deser-maintenance-window-run-command-parameters)

(clojure.core/declare deser-association-version-list)

(clojure.core/declare deser-attachment-information)

(clojure.core/declare deser-output-source-id)

(clojure.core/declare deser-parameter-value-list)

(clojure.core/declare deser-document-content)

(clojure.core/declare deser-automation-type)

(clojure.core/declare deser-association-version)

(clojure.core/declare deser-maintenance-window-execution-task-execution-id)

(clojure.core/declare deser-maintenance-window-task)

(clojure.core/declare deser-target-maps)

(clojure.core/declare deser-command-invocation-list)

(clojure.core/declare deser-association-list)

(clojure.core/declare deser-patch-severity)

(clojure.core/declare deser-automation-execution-metadata-list)

(clojure.core/declare deser-document-version-info)

(clojure.core/declare deser-service-role)

(clojure.core/declare deser-maintenance-window-enabled)

(clojure.core/declare deser-maintenance-window-name)

(clojure.core/declare deser-association-description-list)

(clojure.core/declare deser-command-status)

(clojure.core/declare deser-instance-id)

(clojure.core/declare deser-document-status-information)

(clojure.core/declare deser-inventory-type-display-name)

(clojure.core/declare deser-patch-group)

(clojure.core/declare deser-automation-action-name)

(clojure.core/declare deser-patch-group-list)

(clojure.core/declare deser-patch-filter)

(clojure.core/declare deser-notification-event)

(clojure.core/declare deser-association-executions-list)

(clojure.core/declare deser-document-version-name)

(clojure.core/declare deser-instance-association-status-infos)

(clojure.core/declare deser-parameter-name)

(clojure.core/declare deser-patch-baseline-identity-list)

(clojure.core/declare deser-parameter-type)

(clojure.core/declare deser-s-3-region)

(clojure.core/declare deser-patch-classification)

(clojure.core/declare deser-comment)

(clojure.core/declare deser-command-invocation-status)

(clojure.core/declare deser-last-resource-data-sync-message)

(clojure.core/declare deser-compliance-resource-type)

(clojure.core/declare deser-patch-source)

(clojure.core/declare deser-document-identifier)

(clojure.core/declare deser-association-resource-type)

(clojure.core/declare deser-parameter-label-list)

(clojure.core/declare deser-session-id)

(clojure.core/declare deser-progress-counters)

(clojure.core/declare deser-ps-parameter-version)

(clojure.core/declare deser-account-id-list)

(clojure.core/declare deser-maintenance-window-execution-task-identity-list)

(clojure.core/declare deser-maintenance-window-execution-task-id)

(clojure.core/declare deser-maintenance-window-cutoff)

(clojure.core/declare deser-timeout-seconds)

(clojure.core/declare deser-resource-data-sync-s-3-region)

(clojure.core/declare deser-delivery-timed-out-count)

(clojure.core/declare deser-compliance-summary-item-list)

(clojure.core/declare deser-attribute-name)

(clojure.core/declare deser-step-execution)

(clojure.core/declare deser-product)

(clojure.core/declare deser-patch-installed-count)

(clojure.core/declare deser-status-additional-info)

(clojure.core/declare deser-completed-count)

(clojure.core/declare deser-resource-data-sync-awskms-key-arn)

(clojure.core/declare deser-instance-count)

(clojure.core/declare deser-put-inventory-message)

(clojure.core/declare deser-last-resource-data-sync-status)

(clojure.core/declare deser-error-count)

(clojure.core/declare deser-status-message)

(clojure.core/declare deser-patch-rule)

(clojure.core/declare deser-execution-mode)

(clojure.core/declare deser-inventory-item-content-hash)

(clojure.core/declare deser-maintenance-window-execution-status)

(clojure.core/declare deser-output-source)

(clojure.core/declare deser-inventory-item-entry)

(clojure.core/declare deser-parameter-metadata)

(clojure.core/declare deser-association-execution-targets-list)

(clojure.core/declare deser-command-plugin)

(clojure.core/declare deser-cloud-watch-log-group-name)

(clojure.core/declare deser-parameters)

(clojure.core/declare deser-response-code)

(clojure.core/declare deser-association-execution-id)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-identity-list)

(clojure.core/declare deser-instance-association-output-url)

(clojure.core/declare deser-resource-data-sync-s-3-format)

(clojure.core/declare deser-document-type)

(clojure.core/declare deser-association-execution)

(clojure.core/declare deser-document-parameter)

(clojure.core/declare deser-association-id)

(clojure.core/declare deser-severity-summary)

(clojure.core/declare deser-maintenance-window-identity-for-target)

(clojure.core/declare deser-patch-deployment-status)

(clojure.core/declare deser-automation-execution)

(clojure.core/declare deser-patch-content-url)

(clojure.core/declare deser-compliance-item-title)

(clojure.core/declare deser-tag-key)

(clojure.core/declare deser-instance-association-list)

(clojure.core/declare deser-maintenance-window-execution-list)

(clojure.core/declare deser-platform-type)

(clojure.core/declare deser-parameter-name-list)

(clojure.core/declare deser-instance-aggregated-association-overview)

(clojure.core/declare deser-target-type)

(clojure.core/declare deser-resource-data-sync-s-3-prefix)

(clojure.core/declare deser-notification-config)

(clojure.core/declare deser-automation-execution-metadata)

(clojure.core/declare deser-s-3-bucket-name)

(clojure.core/declare deser-ping-status)

(clojure.core/declare deser-inventory-deletion-summary-items)

(clojure.core/declare deser-compliance-item-list)

(clojure.core/declare deser-document-hash)

(clojure.core/declare deser-inventory-result-entity-list)

(clojure.core/declare deser-inventory-item-schema)

(clojure.core/declare deser-iam-role)

(clojure.core/declare deser-compliance-severity)

(clojure.core/declare deser-notification-type)

(clojure.core/declare deser-inventory-deletion-status-item)

(clojure.core/declare deser-maintenance-window-lambda-payload)

(clojure.core/declare deser-maintenance-window-task-arn)

(clojure.core/declare deser-maintenance-window-lambda-qualifier)

(clojure.core/declare deser-patch-compliance-data)

(clojure.core/declare deser-target-map-key)

(clojure.core/declare deser-inventory-deletions-list)

(clojure.core/declare deser-patch-msrc-number)

(clojure.core/declare deser-patch-missing-count)

(clojure.core/declare deser-scheduled-window-execution)

(clojure.core/declare deser-association-status)

(clojure.core/declare deser-document-parameter-name)

(clojure.core/declare deser-attachment-hash)

(clojure.core/declare deser-document-parameter-descrption)

(clojure.core/declare deser-snapshot-download-url)

(clojure.core/declare deser-inventory-item-attribute-name)

(clojure.core/declare deser-target-locations)

(clojure.core/declare deser-patch-installed-rejected-count)

(clojure.core/declare deser-status-details)

(clojure.core/declare deser-maintenance-window-task-parameters)

(clojure.core/declare deser-patch-baseline-identity)

(clojure.core/declare deser-next-token)

(clojure.core/declare deser-standard-output-content)

(clojure.core/declare deser-resource-data-sync-s-3-destination)

(clojure.core/declare deser-agent-error-code)

(clojure.core/declare deser-document-owner)

(clojure.core/declare deser-cloud-watch-output-config)

(clojure.core/declare deser-document-parameter-list)

(clojure.core/declare deser-document-sha-1)

(clojure.core/declare deser-connection-status)

(clojure.core/declare deser-document-version-list)

(clojure.core/declare deser-parameter-metadata-list)

(clojure.core/declare deser-default-instance-name)

(clojure.core/declare deser-maintenance-window-task-parameter-name)

(clojure.core/declare deser-session-target)

(clojure.core/declare deser-session-owner)

(clojure.core/declare deser-expiration-date)

(clojure.core/declare deser-maintenance-window-task-priority)

(clojure.core/declare deser-session-status)

(clojure.core/declare deser-document-arn)

(clojure.core/declare deser-inventory-result-entity-id)

(clojure.core/declare deser-patch-id)

(clojure.core/declare deser-effective-patch)

(clojure.core/declare deser-max-concurrency)

(clojure.core/declare deser-maintenance-window-task-id)

(clojure.core/declare deser-resolved-targets)

(clojure.core/declare deser-instance-patch-states-list)

(clojure.core/declare deser-inventory-deletion-start-time)

(clojure.core/declare deser-patch-action)

(clojure.core/declare deser-command-invocation)

(clojure.core/declare deser-compliant-summary)

(clojure.core/declare deser-regions)

(clojure.core/declare deser-session-details)

(clojure.core/declare deser-compliance-item-id)

(clojure.core/declare deser-resource-data-sync-item)

(clojure.core/declare deser-cloud-watch-output-enabled)

(clojure.core/declare deser-parameter-list)

(clojure.core/declare deser-parameter-label)

(clojure.core/declare deser-association-description)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-document-description)

(clojure.core/declare deser-maintenance-window-target)

(clojure.core/declare deser-inventory-deletion-last-status-update-time)

(clojure.core/declare deser-compliance-type-name)

(clojure.core/declare deser-patch-id-list)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-parameters)

(clojure.core/declare deser-logging-info)

(clojure.core/declare deser-ps-parameter-value)

(clojure.core/declare deser-attachment-content)

(clojure.core/declare deser-patch-filter-group)

(clojure.core/declare deser-instance-information)

(clojure.core/declare deser-maintenance-window-task-list)

(clojure.core/declare deser-status-name)

(clojure.core/declare deser-inventory-result-item)

(clojure.core/declare deser-command-plugin-name)

(clojure.core/declare deser-content-length)

(clojure.core/declare deser-attribute-value)

(clojure.core/declare deser-session-manager-output-url)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-id)

(clojure.core/declare deser-inventory-deletion-summary)

(clojure.core/declare deser-parameter-key-id)

(clojure.core/declare deser-automation-parameter-map)

(clojure.core/declare deser-association-overview)

(clojure.core/declare deser-resource-compliance-summary-item)

(clojure.core/declare deser-patch-rule-group)

(clojure.core/declare deser-maintenance-window-target-list)

(clojure.core/declare deser-command-plugin-list)

(clojure.core/declare deser-accounts)

(clojure.core/declare deser-parameter-history-list)

(clojure.core/declare deser-service-setting-value)

(clojure.core/declare deser-registrations-count)

(clojure.core/declare deser-max-errors)

(clojure.core/declare deser-inventory-item-attribute-list)

(clojure.core/declare deser-inventory-item-schema-version)

(clojure.core/declare deser-compliance-status)

(clojure.core/declare deser-inventory-deletion-status)

(clojure.core/declare deser-account)

(clojure.core/declare deser-compliance-execution-summary)

(clojure.core/declare deser-url)

(clojure.core/declare deser-invocation-trace-output)

(clojure.core/declare deser-stream-url)

(clojure.core/declare deser-allowed-pattern)

(clojure.core/declare deser-tag-value)

(clojure.core/declare deser-valid-next-step)

(clojure.core/declare deser-patch-msrc-severity)

(clojure.core/declare deser-document-default-version-description)

(clojure.core/declare deser-default-baseline)

(clojure.core/declare deser-instance-tag-name)

(clojure.core/declare deser-total-count)

(clojure.core/declare deser-batch-error-message)

(clojure.core/declare deser-patch-source-product-list)

(clojure.core/declare deser-baseline-id)

(clojure.core/declare deser-patch-not-applicable-count)

(clojure.core/declare deser-maintenance-window-target-id)

(clojure.core/declare deser-failure-details)

(clojure.core/declare deser-patch-product)

(clojure.core/declare deser-ip-address)

(clojure.core/declare deser-maintenance-window-id)

(clojure.core/declare deser-created-date)

(clojure.core/declare deser-patch-status)

(clojure.core/declare deser-normal-string-map)

(clojure.core/declare deser-automation-target-parameter-name)

(clojure.core/declare deser-patch-vendor)

(clojure.core/declare deser-compliance-execution-id)

(clojure.core/declare deser-maintenance-window-description)

(clojure.core/declare deser-association-name)

(clojure.core/declare deser-maintenance-window-lambda-client-context)

(clojure.core/declare deser-maintenance-window-execution)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-last-successful-resource-data-sync-time)

(clojure.core/declare deser-string)

(clojure.core/declare deser-parameter)

(clojure.core/declare deser-parameter-description)

(clojure.core/declare deser-patch-installed-other-count)

(clojure.core/declare deser-account-id)

(clojure.core/declare deser-inventory-item-schema-result-list)

(clojure.core/declare deser-resource-compliance-summary-item-list)

(clojure.core/declare deser-maintenance-window-task-target-id)

(clojure.core/declare deser-create-association-batch-request-entry)

(clojure.core/declare deser-patch-description)

(clojure.core/declare deser-patch-filter-key)

(clojure.core/declare deser-attachment-name)

(clojure.core/declare deser-patch-failed-count)

(clojure.core/declare deser-maintenance-window-lambda-parameters)

(clojure.core/declare deser-automation-execution-status)

(clojure.core/declare deser-document-schema-version)

(clojure.core/declare deser-attachment-information-list)

(clojure.core/declare deser-patch-source-list)

(clojure.core/declare deser-target-location)

(clojure.core/declare deser-notification-arn)

(clojure.core/declare deser-resource-data-sync-created-time)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-maintenance-window-step-functions-input)

(clojure.core/declare deser-activation-id)

(clojure.core/declare deser-document-parameter-default-value)

(clojure.core/declare deser-document-format)

(clojure.core/declare deser-targets)

(clojure.core/declare deser-patch-compliance-level)

(clojure.core/declare deser-patch-list)

(clojure.core/declare deser-patch-source-configuration)

(clojure.core/declare deser-target-map-value)

(clojure.core/declare deser-document-status)

(clojure.core/declare deser-description-in-document)

(clojure.core/declare deser-command)

(clojure.core/declare deser-target-parameter-list)

(clojure.core/declare deser-instances-count)

(clojure.core/declare deser-patch-group-patch-baseline-mapping-list)

(clojure.core/declare deser-resource-count)

(clojure.core/declare deser-execution-role-name)

(clojure.core/declare deser-baseline-name)

(clojure.core/declare deser-session-manager-s-3-output-url)

(clojure.core/declare deser-attachment-hash-type)

(clojure.core/declare deser-attachment-url)

(clojure.core/declare deser-activation)

(clojure.core/declare deser-maintenance-window-step-functions-name)

(clojure.core/declare deser-compliance-resource-id)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-identity)

(clojure.core/declare deser-resource-data-sync-s-3-bucket-name)

(clojure.core/declare deser-maintenance-window-duration-hours)

(clojure.core/declare deser-platform-type-list)

(clojure.core/declare deser-s-3-key-prefix)

(clojure.core/declare deser-session-manager-cloud-watch-output-url)

(clojure.core/declare deser-compliance-execution-type)

(clojure.core/declare deser-effective-patch-list)

(clojure.core/declare deser-schedule-expression)

(clojure.core/declare deser-failed-create-association)

(clojure.core/declare deser-resource-data-sync-item-list)

(clojure.core/declare deser-command-list)

(clojure.core/declare deser-command-id)

(clojure.core/declare deser-association-version-info)

(clojure.core/declare deser-instance-association)

(clojure.core/declare deser-long)

(clojure.core/declare deser-s-3-output-url)

(clojure.core/declare deser-install-override-list)

(clojure.core/declare deser-activation-code)

(clojure.core/declare deser-patch-source-name)

(clojure.core/declare deser-inventory-item-entry-list)

(clojure.core/declare deser-instance-association-status-info)

(clojure.core/declare deser-association-status-name)

(clojure.core/declare deser-inventory-result-item-map)

(clojure.core/declare deser-remaining-count)

(clojure.core/declare deser-resource-data-sync-name)

(clojure.core/declare deser-patch-rule-list)

(clojure.core/declare deser-owner-information)

(clojure.core/declare deser-session-list)

(clojure.core/declare deser-maintenance-window-string-date-time)

(clojure.core/declare deser-service-setting-id)

(clojure.core/declare deser-s-3-output-location)

(clojure.core/declare deser-fault)

(clojure.core/declare deser-maintenance-window-identity-list)

(clojure.core/declare deser-automation-parameter-value)

(clojure.core/declare deser-patch-filter-value-list)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-maintenance-window-schedule)

(clojure.core/declare deser-version)

(clojure.core/declare deser-inventory-item-type-name)

(clojure.core/declare deser-patch-compliance-data-state)

(clojure.core/declare deser-maintenance-window-task-invocation-parameters)

(clojure.core/declare deser-document-name)

(clojure.core/declare deser-ps-parameter-selector)

(clojure.core/declare deser-maintenance-window-step-functions-parameters)

(clojure.core/declare deser-inventory-result-item-key)

(clojure.core/declare deser-maintenance-windows-for-target-list)

(clojure.core/declare deser-patch-filter-value)

(clojure.core/declare deser-maintenance-window-task-type)

(clojure.core/declare deser-output-source-type)

(clojure.core/declare deser-maintenance-window-allow-unassociated-targets)

(clojure.core/declare deser-maintenance-window-execution-status-details)

(clojure.core/declare deser-maintenance-window-task-parameters-list)

(clojure.core/declare deser-document-version)

(clojure.core/declare deser-target)

(clojure.core/declare deser-scheduled-window-execution-list)

(clojure.core/declare deser-document-hash-type)

(clojure.core/declare deser-valid-next-step-list)

(clojure.core/declare deser-maintenance-window-execution-task-id-list)

(clojure.core/declare deser-association-execution-target)

(clojure.core/declare deser-instance-association-execution-summary)

(clojure.core/declare deser-instance-patch-state)

(clojure.core/declare deser-association)

(clojure.core/declare deser-patch-product-family)

(clojure.core/declare deser-document-parameter-type)

(clojure.core/declare deser-resource-count-by-status)

(clojure.core/declare deser-service-setting)

(clojure.core/declare deser-compliance-summary-item)

(clojure.core/declare deser-command-plugin-status)

(clojure.core/declare deser-maintenance-window-timezone)

(clojure.core/declare deser-patch-title)

(clojure.core/declare deser-association-compliance-severity)

(clojure.core/declare deser-session)

(clojure.core/declare deser-activation-description)

(clojure.core/declare deser-ps-parameter-name)

(clojure.core/declare deser-activation-list)

(clojure.core/declare deser-instance-association-output-location)

(clojure.core/declare deser-maintenance-window-automation-parameters)

(clojure.core/declare deser-association-status-aggregated-count)

(clojure.core/declare deser-patch-language)

(clojure.core/declare deser-attachment-content-list)

(clojure.core/declare deser-inventory-item-capture-time)

(clojure.core/declare deser-maintenance-window-execution-task-identity)

(clojure.core/declare deser-failed-create-association-list)

(clojure.core/declare deser-baseline-description)

(clojure.core/declare deser-maintenance-window-execution-id)

(clojure.core/declare deser-automation-execution-id)

(clojure.core/declare deser-target-value)

(clojure.core/declare deser-compliance-summary-count)

(clojure.core/declare deser-patch-filter-list)

(clojure.core/declare deser-inventory-deletion-id)

(clojure.core/declare deser-region)

(clojure.core/declare deser-token-value)

(clojure.core/declare deser-inventory-item-attribute)

(clojure.core/declare deser-patch-source-product)

(clojure.core/declare deser-computer-name)

(clojure.core/declare deser-maintenance-window-task-parameter-value-expression)

(clojure.core/declare deser-target-map-value-list)

(clojure.core/declare deser-target-key)

(clojure.core/declare deser-inventory-deletion-summary-item)

(clojure.core/declare deser-automation-parameter-value-list)

(clojure.core/declare deser-compliance-item-details)

(clojure.core/declare deser-maintenance-window-task-parameter-value-list)

(clojure.core/declare deser-last-resource-data-sync-time)

(clojure.core/declare deser-patch)

(clojure.core/declare deser-patch-group-patch-baseline-mapping)

(clojure.core/declare deser-instance-information-list)

(clojure.core/declare deser-compliance-item)

(clojure.core/declare deser-operating-system)

(clojure.core/declare deser-document-identifier-list)

(clojure.core/declare deser-notification-event-list)

(clojure.core/declare deser-step-execution-list)

(clojure.core/declare deser-instance-association-status-aggregated-count)

(clojure.core/declare deser-maintenance-window-identity)

(clojure.core/declare deser-snapshot-id)

(clojure.core/declare deser-registration-limit)

(clojure.core/declare deser-parameter-value)

(clojure.core/declare deser-standard-error-content)

(clojure.core/declare deser-date-time)

(clojure.core/declare deser-patch-operation-type)

(clojure.core/declare deser-target-values)

(clojure.core/declare deser-patch-kb-number)

(clojure.core/declare deser-inventory-attribute-data-type)

(clojure.core/declare deser-instance-patch-state-list)

(clojure.core/declare deser-target-count)

(clojure.core/declare deser-maintenance-window-task-parameter-value)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-inventory-deletion-last-status-message)

(clojure.core/declare deser-maintenance-window-resource-type)

(clojure.core/defn- deser-string-date-time [input] input)

(clojure.core/defn- deser-parameter-history [input] (clojure.core/cond-> {} (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-parameter-type (input "Type"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "KeyId") (clojure.core/assoc :key-id (deser-parameter-key-id (input "KeyId"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-ps-parameter-value (input "Value"))) (clojure.core/contains? input "AllowedPattern") (clojure.core/assoc :allowed-pattern (deser-allowed-pattern (input "AllowedPattern"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-parameter-description (input "Description"))) (clojure.core/contains? input "Labels") (clojure.core/assoc :labels (deser-parameter-label-list (input "Labels"))) (clojure.core/contains? input "LastModifiedUser") (clojure.core/assoc :last-modified-user (deser-string (input "LastModifiedUser"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-ps-parameter-version (input "Version"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-ps-parameter-name (input "Name")))))

(clojure.core/defn- deser-inventory-result-entity [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-inventory-result-entity-id (input "Id"))) (clojure.core/contains? input "Data") (clojure.core/assoc :data (deser-inventory-result-item-map (input "Data")))))

(clojure.core/defn- deser-target-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-target-map-key k) (deser-target-map-value-list v)])) input))

(clojure.core/defn- deser-command-plugin-output [input] input)

(clojure.core/defn- deser-non-compliant-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "NonCompliantCount") (clojure.core/assoc :non-compliant-count (deser-compliance-summary-count (input "NonCompliantCount"))) (clojure.core/contains? input "SeveritySummary") (clojure.core/assoc :severity-summary (deser-severity-summary (input "SeveritySummary")))))

(clojure.core/defn- deser-association-resource-id [input] input)

(clojure.core/defn- deser-patch-compliance-data-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-compliance-data coll))) input))

(clojure.core/defn- deser-instance-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-id coll))) input))

(clojure.core/defn- deser-automation-parameter-key [input] input)

(clojure.core/defn- deser-approve-after-days [input] input)

(clojure.core/defn- deser-maintenance-window-run-command-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (input "ServiceRoleArn"))) (clojure.core/contains? input "Comment") (clojure.core/assoc :comment (deser-comment (input "Comment"))) (clojure.core/contains? input "TimeoutSeconds") (clojure.core/assoc :timeout-seconds (deser-timeout-seconds (input "TimeoutSeconds"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "NotificationConfig") (clojure.core/assoc :notification-config (deser-notification-config (input "NotificationConfig"))) (clojure.core/contains? input "DocumentHash") (clojure.core/assoc :document-hash (deser-document-hash (input "DocumentHash"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix"))) (clojure.core/contains? input "DocumentHashType") (clojure.core/assoc :document-hash-type (deser-document-hash-type (input "DocumentHashType")))))

(clojure.core/defn- deser-association-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-version-info coll))) input))

(clojure.core/defn- deser-attachment-information [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-attachment-name (input "Name")))))

(clojure.core/defn- deser-output-source-id [input] input)

(clojure.core/defn- deser-parameter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-value coll))) input))

(clojure.core/defn- deser-document-content [input] input)

(clojure.core/defn- deser-automation-type [input] (clojure.core/get {"CrossAccount" :cross-account, "Local" :local} input))

(clojure.core/defn- deser-association-version [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-execution-id [input] input)

(clojure.core/defn- deser-maintenance-window-task [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (input "ServiceRoleArn"))) (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-maintenance-window-task-type (input "Type"))) (clojure.core/contains? input "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (input "Priority"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "LoggingInfo") (clojure.core/assoc :logging-info (deser-logging-info (input "LoggingInfo"))) (clojure.core/contains? input "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (input "TaskArn"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-maintenance-window-description (input "Description"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (input "WindowTaskId"))) (clojure.core/contains? input "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters (input "TaskParameters"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name")))))

(clojure.core/defn- deser-target-maps [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-map coll))) input))

(clojure.core/defn- deser-command-invocation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-command-invocation coll))) input))

(clojure.core/defn- deser-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association coll))) input))

(clojure.core/defn- deser-patch-severity [input] input)

(clojure.core/defn- deser-automation-execution-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-automation-execution-metadata coll))) input))

(clojure.core/defn- deser-document-version-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-name (input "Name"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (input "VersionName"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (input "CreatedDate"))) (clojure.core/contains? input "IsDefaultVersion") (clojure.core/assoc :is-default-version (deser-boolean (input "IsDefaultVersion"))) (clojure.core/contains? input "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (input "DocumentFormat"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-document-status (input "Status"))) (clojure.core/contains? input "StatusInformation") (clojure.core/assoc :status-information (deser-document-status-information (input "StatusInformation")))))

(clojure.core/defn- deser-service-role [input] input)

(clojure.core/defn- deser-maintenance-window-enabled [input] input)

(clojure.core/defn- deser-maintenance-window-name [input] input)

(clojure.core/defn- deser-association-description-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-description coll))) input))

(clojure.core/defn- deser-command-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Success" :success, "Cancelled" :cancelled, "Failed" :failed, "TimedOut" :timed-out, "Cancelling" :cancelling} input))

(clojure.core/defn- deser-instance-id [input] input)

(clojure.core/defn- deser-document-status-information [input] input)

(clojure.core/defn- deser-inventory-type-display-name [input] input)

(clojure.core/defn- deser-patch-group [input] input)

(clojure.core/defn- deser-automation-action-name [input] input)

(clojure.core/defn- deser-patch-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-group coll))) input))

(clojure.core/defn- deser-patch-filter [input] (clojure.core/cond-> {:key (deser-patch-filter-key (input "Key")), :values (deser-patch-filter-value-list (input "Values"))}))

(clojure.core/defn- deser-notification-event [input] (clojure.core/get {"All" :all, "InProgress" :in-progress, "Success" :success, "TimedOut" :timed-out, "Cancelled" :cancelled, "Failed" :failed} input))

(clojure.core/defn- deser-association-executions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-execution coll))) input))

(clojure.core/defn- deser-document-version-name [input] input)

(clojure.core/defn- deser-instance-association-status-infos [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-association-status-info coll))) input))

(clojure.core/defn- deser-parameter-name [input] input)

(clojure.core/defn- deser-patch-baseline-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-baseline-identity coll))) input))

(clojure.core/defn- deser-parameter-type [input] (clojure.core/get {"String" :string, "StringList" :string-list, "SecureString" :secure-string} input))

(clojure.core/defn- deser-s-3-region [input] input)

(clojure.core/defn- deser-patch-classification [input] input)

(clojure.core/defn- deser-comment [input] input)

(clojure.core/defn- deser-command-invocation-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Delayed" :delayed, "Success" :success, "Cancelled" :cancelled, "TimedOut" :timed-out, "Failed" :failed, "Cancelling" :cancelling} input))

(clojure.core/defn- deser-last-resource-data-sync-message [input] input)

(clojure.core/defn- deser-compliance-resource-type [input] input)

(clojure.core/defn- deser-patch-source [input] (clojure.core/cond-> {:name (deser-patch-source-name (input "Name")), :products (deser-patch-source-product-list (input "Products")), :configuration (deser-patch-source-configuration (input "Configuration"))}))

(clojure.core/defn- deser-document-identifier [input] (clojure.core/cond-> {} (clojure.core/contains? input "SchemaVersion") (clojure.core/assoc :schema-version (deser-document-schema-version (input "SchemaVersion"))) (clojure.core/contains? input "DocumentType") (clojure.core/assoc :document-type (deser-document-type (input "DocumentType"))) (clojure.core/contains? input "TargetType") (clojure.core/assoc :target-type (deser-target-type (input "TargetType"))) (clojure.core/contains? input "Tags") (clojure.core/assoc :tags (deser-tag-list (input "Tags"))) (clojure.core/contains? input "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (input "DocumentFormat"))) (clojure.core/contains? input "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (input "VersionName"))) (clojure.core/contains? input "PlatformTypes") (clojure.core/assoc :platform-types (deser-platform-type-list (input "PlatformTypes"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-document-owner (input "Owner"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name")))))

(clojure.core/defn- deser-association-resource-type [input] input)

(clojure.core/defn- deser-parameter-label-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-label coll))) input))

(clojure.core/defn- deser-session-id [input] input)

(clojure.core/defn- deser-progress-counters [input] (clojure.core/cond-> {} (clojure.core/contains? input "TotalSteps") (clojure.core/assoc :total-steps (deser-integer (input "TotalSteps"))) (clojure.core/contains? input "SuccessSteps") (clojure.core/assoc :success-steps (deser-integer (input "SuccessSteps"))) (clojure.core/contains? input "FailedSteps") (clojure.core/assoc :failed-steps (deser-integer (input "FailedSteps"))) (clojure.core/contains? input "CancelledSteps") (clojure.core/assoc :cancelled-steps (deser-integer (input "CancelledSteps"))) (clojure.core/contains? input "TimedOutSteps") (clojure.core/assoc :timed-out-steps (deser-integer (input "TimedOutSteps")))))

(clojure.core/defn- deser-ps-parameter-version [input] input)

(clojure.core/defn- deser-account-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-id coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution-task-identity coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-id [input] input)

(clojure.core/defn- deser-maintenance-window-cutoff [input] input)

(clojure.core/defn- deser-timeout-seconds [input] input)

(clojure.core/defn- deser-resource-data-sync-s-3-region [input] input)

(clojure.core/defn- deser-delivery-timed-out-count [input] input)

(clojure.core/defn- deser-compliance-summary-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-compliance-summary-item coll))) input))

(clojure.core/defn- deser-attribute-name [input] input)

(clojure.core/defn- deser-step-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "TimeoutSeconds") (clojure.core/assoc :timeout-seconds (deser-long (input "TimeoutSeconds"))) (clojure.core/contains? input "ResponseCode") (clojure.core/assoc :response-code (deser-string (input "ResponseCode"))) (clojure.core/contains? input "StepExecutionId") (clojure.core/assoc :step-execution-id (deser-string (input "StepExecutionId"))) (clojure.core/contains? input "ValidNextSteps") (clojure.core/assoc :valid-next-steps (deser-valid-next-step-list (input "ValidNextSteps"))) (clojure.core/contains? input "Outputs") (clojure.core/assoc :outputs (deser-automation-parameter-map (input "Outputs"))) (clojure.core/contains? input "Response") (clojure.core/assoc :response (deser-string (input "Response"))) (clojure.core/contains? input "FailureMessage") (clojure.core/assoc :failure-message (deser-string (input "FailureMessage"))) (clojure.core/contains? input "Inputs") (clojure.core/assoc :inputs (deser-normal-string-map (input "Inputs"))) (clojure.core/contains? input "NextStep") (clojure.core/assoc :next-step (deser-string (input "NextStep"))) (clojure.core/contains? input "FailureDetails") (clojure.core/assoc :failure-details (deser-failure-details (input "FailureDetails"))) (clojure.core/contains? input "StepStatus") (clojure.core/assoc :step-status (deser-automation-execution-status (input "StepStatus"))) (clojure.core/contains? input "TargetLocation") (clojure.core/assoc :target-location (deser-target-location (input "TargetLocation"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "IsCritical") (clojure.core/assoc :is-critical (deser-boolean (input "IsCritical"))) (clojure.core/contains? input "StepName") (clojure.core/assoc :step-name (deser-string (input "StepName"))) (clojure.core/contains? input "OverriddenParameters") (clojure.core/assoc :overridden-parameters (deser-automation-parameter-map (input "OverriddenParameters"))) (clojure.core/contains? input "OnFailure") (clojure.core/assoc :on-failure (deser-string (input "OnFailure"))) (clojure.core/contains? input "ExecutionEndTime") (clojure.core/assoc :execution-end-time (deser-date-time (input "ExecutionEndTime"))) (clojure.core/contains? input "ExecutionStartTime") (clojure.core/assoc :execution-start-time (deser-date-time (input "ExecutionStartTime"))) (clojure.core/contains? input "Action") (clojure.core/assoc :action (deser-automation-action-name (input "Action"))) (clojure.core/contains? input "IsEnd") (clojure.core/assoc :is-end (deser-boolean (input "IsEnd"))) (clojure.core/contains? input "MaxAttempts") (clojure.core/assoc :max-attempts (deser-integer (input "MaxAttempts")))))

(clojure.core/defn- deser-product [input] input)

(clojure.core/defn- deser-patch-installed-count [input] input)

(clojure.core/defn- deser-status-additional-info [input] input)

(clojure.core/defn- deser-completed-count [input] input)

(clojure.core/defn- deser-resource-data-sync-awskms-key-arn [input] input)

(clojure.core/defn- deser-instance-count [input] input)

(clojure.core/defn- deser-put-inventory-message [input] input)

(clojure.core/defn- deser-last-resource-data-sync-status [input] (clojure.core/get {"Successful" :successful, "Failed" :failed, "InProgress" :in-progress} input))

(clojure.core/defn- deser-error-count [input] input)

(clojure.core/defn- deser-status-message [input] input)

(clojure.core/defn- deser-patch-rule [input] (clojure.core/cond-> {:patch-filter-group (deser-patch-filter-group (input "PatchFilterGroup")), :approve-after-days (deser-approve-after-days (input "ApproveAfterDays"))} (clojure.core/contains? input "ComplianceLevel") (clojure.core/assoc :compliance-level (deser-patch-compliance-level (input "ComplianceLevel"))) (clojure.core/contains? input "EnableNonSecurity") (clojure.core/assoc :enable-non-security (deser-boolean (input "EnableNonSecurity")))))

(clojure.core/defn- deser-execution-mode [input] (clojure.core/get {"Auto" :auto, "Interactive" :interactive} input))

(clojure.core/defn- deser-inventory-item-content-hash [input] input)

(clojure.core/defn- deser-maintenance-window-execution-status [input] (clojure.core/get {"PENDING" :pending, "IN_PROGRESS" :in-progress, "SUCCESS" :success, "FAILED" :failed, "TIMED_OUT" :timed-out, "CANCELLING" :cancelling, "CANCELLED" :cancelled, "SKIPPED_OVERLAPPING" :skipped-overlapping} input))

(clojure.core/defn- deser-output-source [input] (clojure.core/cond-> {} (clojure.core/contains? input "OutputSourceId") (clojure.core/assoc :output-source-id (deser-output-source-id (input "OutputSourceId"))) (clojure.core/contains? input "OutputSourceType") (clojure.core/assoc :output-source-type (deser-output-source-type (input "OutputSourceType")))))

(clojure.core/defn- deser-inventory-item-entry [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-name k) (deser-attribute-value v)])) input))

(clojure.core/defn- deser-parameter-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-ps-parameter-name (input "Name"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-parameter-type (input "Type"))) (clojure.core/contains? input "KeyId") (clojure.core/assoc :key-id (deser-parameter-key-id (input "KeyId"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "LastModifiedUser") (clojure.core/assoc :last-modified-user (deser-string (input "LastModifiedUser"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-parameter-description (input "Description"))) (clojure.core/contains? input "AllowedPattern") (clojure.core/assoc :allowed-pattern (deser-allowed-pattern (input "AllowedPattern"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-ps-parameter-version (input "Version")))))

(clojure.core/defn- deser-association-execution-targets-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-execution-target coll))) input))

(clojure.core/defn- deser-command-plugin [input] (clojure.core/cond-> {} (clojure.core/contains? input "ResponseFinishDateTime") (clojure.core/assoc :response-finish-date-time (deser-date-time (input "ResponseFinishDateTime"))) (clojure.core/contains? input "ResponseCode") (clojure.core/assoc :response-code (deser-response-code (input "ResponseCode"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-command-plugin-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (input "StatusDetails"))) (clojure.core/contains? input "StandardOutputUrl") (clojure.core/assoc :standard-output-url (deser-url (input "StandardOutputUrl"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix"))) (clojure.core/contains? input "OutputS3Region") (clojure.core/assoc :output-s-3-region (deser-s-3-region (input "OutputS3Region"))) (clojure.core/contains? input "Output") (clojure.core/assoc :output (deser-command-plugin-output (input "Output"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-command-plugin-name (input "Name"))) (clojure.core/contains? input "StandardErrorUrl") (clojure.core/assoc :standard-error-url (deser-url (input "StandardErrorUrl"))) (clojure.core/contains? input "ResponseStartDateTime") (clojure.core/assoc :response-start-date-time (deser-date-time (input "ResponseStartDateTime")))))

(clojure.core/defn- deser-cloud-watch-log-group-name [input] input)

(clojure.core/defn- deser-parameters [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-parameter-name k) (deser-parameter-value-list v)])) input))

(clojure.core/defn- deser-response-code [input] input)

(clojure.core/defn- deser-association-execution-id [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution-task-invocation-identity coll))) input))

(clojure.core/defn- deser-instance-association-output-url [input] (clojure.core/cond-> {} (clojure.core/contains? input "S3OutputUrl") (clojure.core/assoc :s-3-output-url (deser-s-3-output-url (input "S3OutputUrl")))))

(clojure.core/defn- deser-resource-data-sync-s-3-format [input] (clojure.core/get {"JsonSerDe" :json-ser-de} input))

(clojure.core/defn- deser-document-type [input] (clojure.core/get {"Command" :command, "Policy" :policy, "Automation" :automation, "Session" :session, "Package" :package} input))

(clojure.core/defn- deser-association-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-association-execution-id (input "ExecutionId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "CreatedTime") (clojure.core/assoc :created-time (deser-date-time (input "CreatedTime"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "ResourceCountByStatus") (clojure.core/assoc :resource-count-by-status (deser-resource-count-by-status (input "ResourceCountByStatus")))))

(clojure.core/defn- deser-document-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-parameter-name (input "Name"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-document-parameter-type (input "Type"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-document-parameter-descrption (input "Description"))) (clojure.core/contains? input "DefaultValue") (clojure.core/assoc :default-value (deser-document-parameter-default-value (input "DefaultValue")))))

(clojure.core/defn- deser-association-id [input] input)

(clojure.core/defn- deser-severity-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "CriticalCount") (clojure.core/assoc :critical-count (deser-compliance-summary-count (input "CriticalCount"))) (clojure.core/contains? input "HighCount") (clojure.core/assoc :high-count (deser-compliance-summary-count (input "HighCount"))) (clojure.core/contains? input "MediumCount") (clojure.core/assoc :medium-count (deser-compliance-summary-count (input "MediumCount"))) (clojure.core/contains? input "LowCount") (clojure.core/assoc :low-count (deser-compliance-summary-count (input "LowCount"))) (clojure.core/contains? input "InformationalCount") (clojure.core/assoc :informational-count (deser-compliance-summary-count (input "InformationalCount"))) (clojure.core/contains? input "UnspecifiedCount") (clojure.core/assoc :unspecified-count (deser-compliance-summary-count (input "UnspecifiedCount")))))

(clojure.core/defn- deser-maintenance-window-identity-for-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name")))))

(clojure.core/defn- deser-patch-deployment-status [input] (clojure.core/get {"APPROVED" :approved, "PENDING_APPROVAL" :pending-approval, "EXPLICIT_APPROVED" :explicit-approved, "EXPLICIT_REJECTED" :explicit-rejected} input))

(clojure.core/defn- deser-automation-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "TargetMaps") (clojure.core/assoc :target-maps (deser-target-maps (input "TargetMaps"))) (clojure.core/contains? input "ProgressCounters") (clojure.core/assoc :progress-counters (deser-progress-counters (input "ProgressCounters"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-automation-parameter-map (input "Parameters"))) (clojure.core/contains? input "ParentAutomationExecutionId") (clojure.core/assoc :parent-automation-execution-id (deser-automation-execution-id (input "ParentAutomationExecutionId"))) (clojure.core/contains? input "CurrentStepName") (clojure.core/assoc :current-step-name (deser-string (input "CurrentStepName"))) (clojure.core/contains? input "ExecutedBy") (clojure.core/assoc :executed-by (deser-string (input "ExecutedBy"))) (clojure.core/contains? input "CurrentAction") (clojure.core/assoc :current-action (deser-string (input "CurrentAction"))) (clojure.core/contains? input "TargetLocations") (clojure.core/assoc :target-locations (deser-target-locations (input "TargetLocations"))) (clojure.core/contains? input "Mode") (clojure.core/assoc :mode (deser-execution-mode (input "Mode"))) (clojure.core/contains? input "Outputs") (clojure.core/assoc :outputs (deser-automation-parameter-map (input "Outputs"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "ResolvedTargets") (clojure.core/assoc :resolved-targets (deser-resolved-targets (input "ResolvedTargets"))) (clojure.core/contains? input "FailureMessage") (clojure.core/assoc :failure-message (deser-string (input "FailureMessage"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "StepExecutions") (clojure.core/assoc :step-executions (deser-step-execution-list (input "StepExecutions"))) (clojure.core/contains? input "AutomationExecutionStatus") (clojure.core/assoc :automation-execution-status (deser-automation-execution-status (input "AutomationExecutionStatus"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Target") (clojure.core/assoc :target (deser-string (input "Target"))) (clojure.core/contains? input "TargetParameterName") (clojure.core/assoc :target-parameter-name (deser-automation-parameter-key (input "TargetParameterName"))) (clojure.core/contains? input "ExecutionEndTime") (clojure.core/assoc :execution-end-time (deser-date-time (input "ExecutionEndTime"))) (clojure.core/contains? input "ExecutionStartTime") (clojure.core/assoc :execution-start-time (deser-date-time (input "ExecutionStartTime"))) (clojure.core/contains? input "AutomationExecutionId") (clojure.core/assoc :automation-execution-id (deser-automation-execution-id (input "AutomationExecutionId"))) (clojure.core/contains? input "StepExecutionsTruncated") (clojure.core/assoc :step-executions-truncated (deser-boolean (input "StepExecutionsTruncated")))))

(clojure.core/defn- deser-patch-content-url [input] input)

(clojure.core/defn- deser-compliance-item-title [input] input)

(clojure.core/defn- deser-tag-key [input] input)

(clojure.core/defn- deser-instance-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-association coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution coll))) input))

(clojure.core/defn- deser-platform-type [input] (clojure.core/get {"Windows" :windows, "Linux" :linux} input))

(clojure.core/defn- deser-parameter-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ps-parameter-name coll))) input))

(clojure.core/defn- deser-instance-aggregated-association-overview [input] (clojure.core/cond-> {} (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "InstanceAssociationStatusAggregatedCount") (clojure.core/assoc :instance-association-status-aggregated-count (deser-instance-association-status-aggregated-count (input "InstanceAssociationStatusAggregatedCount")))))

(clojure.core/defn- deser-target-type [input] input)

(clojure.core/defn- deser-resource-data-sync-s-3-prefix [input] input)

(clojure.core/defn- deser-notification-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "NotificationArn") (clojure.core/assoc :notification-arn (deser-notification-arn (input "NotificationArn"))) (clojure.core/contains? input "NotificationEvents") (clojure.core/assoc :notification-events (deser-notification-event-list (input "NotificationEvents"))) (clojure.core/contains? input "NotificationType") (clojure.core/assoc :notification-type (deser-notification-type (input "NotificationType")))))

(clojure.core/defn- deser-automation-execution-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "AutomationType") (clojure.core/assoc :automation-type (deser-automation-type (input "AutomationType"))) (clojure.core/contains? input "TargetMaps") (clojure.core/assoc :target-maps (deser-target-maps (input "TargetMaps"))) (clojure.core/contains? input "LogFile") (clojure.core/assoc :log-file (deser-string (input "LogFile"))) (clojure.core/contains? input "ParentAutomationExecutionId") (clojure.core/assoc :parent-automation-execution-id (deser-automation-execution-id (input "ParentAutomationExecutionId"))) (clojure.core/contains? input "CurrentStepName") (clojure.core/assoc :current-step-name (deser-string (input "CurrentStepName"))) (clojure.core/contains? input "ExecutedBy") (clojure.core/assoc :executed-by (deser-string (input "ExecutedBy"))) (clojure.core/contains? input "CurrentAction") (clojure.core/assoc :current-action (deser-string (input "CurrentAction"))) (clojure.core/contains? input "Mode") (clojure.core/assoc :mode (deser-execution-mode (input "Mode"))) (clojure.core/contains? input "Outputs") (clojure.core/assoc :outputs (deser-automation-parameter-map (input "Outputs"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "ResolvedTargets") (clojure.core/assoc :resolved-targets (deser-resolved-targets (input "ResolvedTargets"))) (clojure.core/contains? input "FailureMessage") (clojure.core/assoc :failure-message (deser-string (input "FailureMessage"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "AutomationExecutionStatus") (clojure.core/assoc :automation-execution-status (deser-automation-execution-status (input "AutomationExecutionStatus"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Target") (clojure.core/assoc :target (deser-string (input "Target"))) (clojure.core/contains? input "TargetParameterName") (clojure.core/assoc :target-parameter-name (deser-automation-parameter-key (input "TargetParameterName"))) (clojure.core/contains? input "ExecutionEndTime") (clojure.core/assoc :execution-end-time (deser-date-time (input "ExecutionEndTime"))) (clojure.core/contains? input "ExecutionStartTime") (clojure.core/assoc :execution-start-time (deser-date-time (input "ExecutionStartTime"))) (clojure.core/contains? input "AutomationExecutionId") (clojure.core/assoc :automation-execution-id (deser-automation-execution-id (input "AutomationExecutionId")))))

(clojure.core/defn- deser-s-3-bucket-name [input] input)

(clojure.core/defn- deser-ping-status [input] (clojure.core/get {"Online" :online, "ConnectionLost" :connection-lost, "Inactive" :inactive} input))

(clojure.core/defn- deser-inventory-deletion-summary-items [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-deletion-summary-item coll))) input))

(clojure.core/defn- deser-compliance-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-compliance-item coll))) input))

(clojure.core/defn- deser-document-hash [input] input)

(clojure.core/defn- deser-inventory-result-entity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-result-entity coll))) input))

(clojure.core/defn- deser-inventory-item-schema [input] (clojure.core/cond-> {:type-name (deser-inventory-item-type-name (input "TypeName")), :attributes (deser-inventory-item-attribute-list (input "Attributes"))} (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-inventory-item-schema-version (input "Version"))) (clojure.core/contains? input "DisplayName") (clojure.core/assoc :display-name (deser-inventory-type-display-name (input "DisplayName")))))

(clojure.core/defn- deser-iam-role [input] input)

(clojure.core/defn- deser-compliance-severity [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low, "INFORMATIONAL" :informational, "UNSPECIFIED" :unspecified} input))

(clojure.core/defn- deser-notification-type [input] (clojure.core/get {"Command" :command, "Invocation" :invocation} input))

(clojure.core/defn- deser-inventory-deletion-status-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "DeletionId") (clojure.core/assoc :deletion-id (deser-inventory-deletion-id (input "DeletionId"))) (clojure.core/contains? input "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (input "TypeName"))) (clojure.core/contains? input "DeletionStartTime") (clojure.core/assoc :deletion-start-time (deser-inventory-deletion-start-time (input "DeletionStartTime"))) (clojure.core/contains? input "LastStatus") (clojure.core/assoc :last-status (deser-inventory-deletion-status (input "LastStatus"))) (clojure.core/contains? input "LastStatusMessage") (clojure.core/assoc :last-status-message (deser-inventory-deletion-last-status-message (input "LastStatusMessage"))) (clojure.core/contains? input "DeletionSummary") (clojure.core/assoc :deletion-summary (deser-inventory-deletion-summary (input "DeletionSummary"))) (clojure.core/contains? input "LastStatusUpdateTime") (clojure.core/assoc :last-status-update-time (deser-inventory-deletion-last-status-update-time (input "LastStatusUpdateTime")))))

(clojure.core/defn- deser-maintenance-window-lambda-payload [input] (portkey.aws/base64-decode input))

(clojure.core/defn- deser-maintenance-window-task-arn [input] input)

(clojure.core/defn- deser-maintenance-window-lambda-qualifier [input] input)

(clojure.core/defn- deser-patch-compliance-data [input] (clojure.core/cond-> {:title (deser-patch-title (input "Title")), :kb-id (deser-patch-kb-number (input "KBId")), :classification (deser-patch-classification (input "Classification")), :severity (deser-patch-severity (input "Severity")), :state (deser-patch-compliance-data-state (input "State")), :installed-time (deser-date-time (input "InstalledTime"))}))

(clojure.core/defn- deser-target-map-key [input] input)

(clojure.core/defn- deser-inventory-deletions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-deletion-status-item coll))) input))

(clojure.core/defn- deser-patch-msrc-number [input] input)

(clojure.core/defn- deser-patch-missing-count [input] input)

(clojure.core/defn- deser-scheduled-window-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name"))) (clojure.core/contains? input "ExecutionTime") (clojure.core/assoc :execution-time (deser-maintenance-window-string-date-time (input "ExecutionTime")))))

(clojure.core/defn- deser-association-status [input] (clojure.core/cond-> {:date (deser-date-time (input "Date")), :name (deser-association-status-name (input "Name")), :message (deser-status-message (input "Message"))} (clojure.core/contains? input "AdditionalInfo") (clojure.core/assoc :additional-info (deser-status-additional-info (input "AdditionalInfo")))))

(clojure.core/defn- deser-document-parameter-name [input] input)

(clojure.core/defn- deser-attachment-hash [input] input)

(clojure.core/defn- deser-document-parameter-descrption [input] input)

(clojure.core/defn- deser-snapshot-download-url [input] input)

(clojure.core/defn- deser-inventory-item-attribute-name [input] input)

(clojure.core/defn- deser-target-locations [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-location coll))) input))

(clojure.core/defn- deser-patch-installed-rejected-count [input] input)

(clojure.core/defn- deser-status-details [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameters [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-maintenance-window-task-parameter-name k) (deser-maintenance-window-task-parameter-value-expression v)])) input))

(clojure.core/defn- deser-patch-baseline-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (input "BaselineId"))) (clojure.core/contains? input "BaselineName") (clojure.core/assoc :baseline-name (deser-baseline-name (input "BaselineName"))) (clojure.core/contains? input "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (input "OperatingSystem"))) (clojure.core/contains? input "BaselineDescription") (clojure.core/assoc :baseline-description (deser-baseline-description (input "BaselineDescription"))) (clojure.core/contains? input "DefaultBaseline") (clojure.core/assoc :default-baseline (deser-default-baseline (input "DefaultBaseline")))))

(clojure.core/defn- deser-next-token [input] input)

(clojure.core/defn- deser-standard-output-content [input] input)

(clojure.core/defn- deser-resource-data-sync-s-3-destination [input] (clojure.core/cond-> {:bucket-name (deser-resource-data-sync-s-3-bucket-name (input "BucketName")), :sync-format (deser-resource-data-sync-s-3-format (input "SyncFormat")), :region (deser-resource-data-sync-s-3-region (input "Region"))} (clojure.core/contains? input "Prefix") (clojure.core/assoc :prefix (deser-resource-data-sync-s-3-prefix (input "Prefix"))) (clojure.core/contains? input "AWSKMSKeyARN") (clojure.core/assoc :awskms-key-arn (deser-resource-data-sync-awskms-key-arn (input "AWSKMSKeyARN")))))

(clojure.core/defn- deser-agent-error-code [input] input)

(clojure.core/defn- deser-document-owner [input] input)

(clojure.core/defn- deser-cloud-watch-output-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "CloudWatchLogGroupName") (clojure.core/assoc :cloud-watch-log-group-name (deser-cloud-watch-log-group-name (input "CloudWatchLogGroupName"))) (clojure.core/contains? input "CloudWatchOutputEnabled") (clojure.core/assoc :cloud-watch-output-enabled (deser-cloud-watch-output-enabled (input "CloudWatchOutputEnabled")))))

(clojure.core/defn- deser-document-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-parameter coll))) input))

(clojure.core/defn- deser-document-sha-1 [input] input)

(clojure.core/defn- deser-connection-status [input] (clojure.core/get {"Connected" :connected, "NotConnected" :not-connected} input))

(clojure.core/defn- deser-document-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-version-info coll))) input))

(clojure.core/defn- deser-parameter-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-metadata coll))) input))

(clojure.core/defn- deser-default-instance-name [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameter-name [input] input)

(clojure.core/defn- deser-session-target [input] input)

(clojure.core/defn- deser-session-owner [input] input)

(clojure.core/defn- deser-expiration-date [input] input)

(clojure.core/defn- deser-maintenance-window-task-priority [input] input)

(clojure.core/defn- deser-session-status [input] (clojure.core/get {"Connected" :connected, "Connecting" :connecting, "Disconnected" :disconnected, "Terminated" :terminated, "Terminating" :terminating, "Failed" :failed} input))

(clojure.core/defn- deser-document-arn [input] input)

(clojure.core/defn- deser-inventory-result-entity-id [input] input)

(clojure.core/defn- deser-patch-id [input] input)

(clojure.core/defn- deser-effective-patch [input] (clojure.core/cond-> {} (clojure.core/contains? input "Patch") (clojure.core/assoc :patch (deser-patch (input "Patch"))) (clojure.core/contains? input "PatchStatus") (clojure.core/assoc :patch-status (deser-patch-status (input "PatchStatus")))))

(clojure.core/defn- deser-max-concurrency [input] input)

(clojure.core/defn- deser-maintenance-window-task-id [input] input)

(clojure.core/defn- deser-resolved-targets [input] (clojure.core/cond-> {} (clojure.core/contains? input "ParameterValues") (clojure.core/assoc :parameter-values (deser-target-parameter-list (input "ParameterValues"))) (clojure.core/contains? input "Truncated") (clojure.core/assoc :truncated (deser-boolean (input "Truncated")))))

(clojure.core/defn- deser-instance-patch-states-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-patch-state coll))) input))

(clojure.core/defn- deser-inventory-deletion-start-time [input] input)

(clojure.core/defn- deser-patch-action [input] (clojure.core/get {"ALLOW_AS_DEPENDENCY" :allow-as-dependency, "BLOCK" :block} input))

(clojure.core/defn- deser-command-invocation [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRole") (clojure.core/assoc :service-role (deser-service-role (input "ServiceRole"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "Comment") (clojure.core/assoc :comment (deser-comment (input "Comment"))) (clojure.core/contains? input "NotificationConfig") (clojure.core/assoc :notification-config (deser-notification-config (input "NotificationConfig"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-command-invocation-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (input "StatusDetails"))) (clojure.core/contains? input "CloudWatchOutputConfig") (clojure.core/assoc :cloud-watch-output-config (deser-cloud-watch-output-config (input "CloudWatchOutputConfig"))) (clojure.core/contains? input "CommandPlugins") (clojure.core/assoc :command-plugins (deser-command-plugin-list (input "CommandPlugins"))) (clojure.core/contains? input "InstanceName") (clojure.core/assoc :instance-name (deser-instance-tag-name (input "InstanceName"))) (clojure.core/contains? input "RequestedDateTime") (clojure.core/assoc :requested-date-time (deser-date-time (input "RequestedDateTime"))) (clojure.core/contains? input "StandardOutputUrl") (clojure.core/assoc :standard-output-url (deser-url (input "StandardOutputUrl"))) (clojure.core/contains? input "TraceOutput") (clojure.core/assoc :trace-output (deser-invocation-trace-output (input "TraceOutput"))) (clojure.core/contains? input "CommandId") (clojure.core/assoc :command-id (deser-command-id (input "CommandId"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "StandardErrorUrl") (clojure.core/assoc :standard-error-url (deser-url (input "StandardErrorUrl")))))

(clojure.core/defn- deser-compliant-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "CompliantCount") (clojure.core/assoc :compliant-count (deser-compliance-summary-count (input "CompliantCount"))) (clojure.core/contains? input "SeveritySummary") (clojure.core/assoc :severity-summary (deser-severity-summary (input "SeveritySummary")))))

(clojure.core/defn- deser-regions [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-region coll))) input))

(clojure.core/defn- deser-session-details [input] input)

(clojure.core/defn- deser-compliance-item-id [input] input)

(clojure.core/defn- deser-resource-data-sync-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "SyncName") (clojure.core/assoc :sync-name (deser-resource-data-sync-name (input "SyncName"))) (clojure.core/contains? input "S3Destination") (clojure.core/assoc :s-3-destination (deser-resource-data-sync-s-3-destination (input "S3Destination"))) (clojure.core/contains? input "LastSyncTime") (clojure.core/assoc :last-sync-time (deser-last-resource-data-sync-time (input "LastSyncTime"))) (clojure.core/contains? input "LastSuccessfulSyncTime") (clojure.core/assoc :last-successful-sync-time (deser-last-successful-resource-data-sync-time (input "LastSuccessfulSyncTime"))) (clojure.core/contains? input "LastStatus") (clojure.core/assoc :last-status (deser-last-resource-data-sync-status (input "LastStatus"))) (clojure.core/contains? input "SyncCreatedTime") (clojure.core/assoc :sync-created-time (deser-resource-data-sync-created-time (input "SyncCreatedTime"))) (clojure.core/contains? input "LastSyncStatusMessage") (clojure.core/assoc :last-sync-status-message (deser-last-resource-data-sync-message (input "LastSyncStatusMessage")))))

(clojure.core/defn- deser-cloud-watch-output-enabled [input] input)

(clojure.core/defn- deser-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter coll))) input))

(clojure.core/defn- deser-parameter-label [input] input)

(clojure.core/defn- deser-association-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "LastUpdateAssociationDate") (clojure.core/assoc :last-update-association-date (deser-date-time (input "LastUpdateAssociationDate"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "ComplianceSeverity") (clojure.core/assoc :compliance-severity (deser-association-compliance-severity (input "ComplianceSeverity"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-association-status (input "Status"))) (clojure.core/contains? input "Overview") (clojure.core/assoc :overview (deser-association-overview (input "Overview"))) (clojure.core/contains? input "Date") (clojure.core/assoc :date (deser-date-time (input "Date"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "AutomationTargetParameterName") (clojure.core/assoc :automation-target-parameter-name (deser-automation-target-parameter-name (input "AutomationTargetParameterName"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "LastSuccessfulExecutionDate") (clojure.core/assoc :last-successful-execution-date (deser-date-time (input "LastSuccessfulExecutionDate"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name"))) (clojure.core/contains? input "OutputLocation") (clojure.core/assoc :output-location (deser-instance-association-output-location (input "OutputLocation")))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-document-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "SchemaVersion") (clojure.core/assoc :schema-version (deser-document-schema-version (input "SchemaVersion"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-document-parameter-list (input "Parameters"))) (clojure.core/contains? input "DocumentType") (clojure.core/assoc :document-type (deser-document-type (input "DocumentType"))) (clojure.core/contains? input "TargetType") (clojure.core/assoc :target-type (deser-target-type (input "TargetType"))) (clojure.core/contains? input "Tags") (clojure.core/assoc :tags (deser-tag-list (input "Tags"))) (clojure.core/contains? input "Hash") (clojure.core/assoc :hash (deser-document-hash (input "Hash"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-document-status (input "Status"))) (clojure.core/contains? input "StatusInformation") (clojure.core/assoc :status-information (deser-document-status-information (input "StatusInformation"))) (clojure.core/contains? input "AttachmentsInformation") (clojure.core/assoc :attachments-information (deser-attachment-information-list (input "AttachmentsInformation"))) (clojure.core/contains? input "DefaultVersion") (clojure.core/assoc :default-version (deser-document-version (input "DefaultVersion"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-description-in-document (input "Description"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (input "CreatedDate"))) (clojure.core/contains? input "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (input "DocumentFormat"))) (clojure.core/contains? input "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (input "VersionName"))) (clojure.core/contains? input "PlatformTypes") (clojure.core/assoc :platform-types (deser-platform-type-list (input "PlatformTypes"))) (clojure.core/contains? input "LatestVersion") (clojure.core/assoc :latest-version (deser-document-version (input "LatestVersion"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-document-owner (input "Owner"))) (clojure.core/contains? input "HashType") (clojure.core/assoc :hash-type (deser-document-hash-type (input "HashType"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name"))) (clojure.core/contains? input "Sha1") (clojure.core/assoc :sha-1 (deser-document-sha-1 (input "Sha1")))))

(clojure.core/defn- deser-maintenance-window-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (input "WindowTargetId"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-maintenance-window-resource-type (input "ResourceType"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (input "OwnerInformation"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-maintenance-window-description (input "Description")))))

(clojure.core/defn- deser-inventory-deletion-last-status-update-time [input] input)

(clojure.core/defn- deser-compliance-type-name [input] input)

(clojure.core/defn- deser-patch-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-id coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-parameters [input] input)

(clojure.core/defn- deser-logging-info [input] (clojure.core/cond-> {:s-3-bucket-name (deser-s-3-bucket-name (input "S3BucketName")), :s-3-region (deser-s-3-region (input "S3Region"))} (clojure.core/contains? input "S3KeyPrefix") (clojure.core/assoc :s-3-key-prefix (deser-s-3-key-prefix (input "S3KeyPrefix")))))

(clojure.core/defn- deser-ps-parameter-value [input] input)

(clojure.core/defn- deser-attachment-content [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-attachment-name (input "Name"))) (clojure.core/contains? input "Size") (clojure.core/assoc :size (deser-content-length (input "Size"))) (clojure.core/contains? input "Hash") (clojure.core/assoc :hash (deser-attachment-hash (input "Hash"))) (clojure.core/contains? input "HashType") (clojure.core/assoc :hash-type (deser-attachment-hash-type (input "HashType"))) (clojure.core/contains? input "Url") (clojure.core/assoc :url (deser-attachment-url (input "Url")))))

(clojure.core/defn- deser-patch-filter-group [input] (clojure.core/cond-> {:patch-filters (deser-patch-filter-list (input "PatchFilters"))}))

(clojure.core/defn- deser-instance-information [input] (clojure.core/cond-> {} (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "PlatformName") (clojure.core/assoc :platform-name (deser-string (input "PlatformName"))) (clojure.core/contains? input "PlatformType") (clojure.core/assoc :platform-type (deser-platform-type (input "PlatformType"))) (clojure.core/contains? input "PingStatus") (clojure.core/assoc :ping-status (deser-ping-status (input "PingStatus"))) (clojure.core/contains? input "IamRole") (clojure.core/assoc :iam-role (deser-iam-role (input "IamRole"))) (clojure.core/contains? input "AgentVersion") (clojure.core/assoc :agent-version (deser-version (input "AgentVersion"))) (clojure.core/contains? input "AssociationStatus") (clojure.core/assoc :association-status (deser-status-name (input "AssociationStatus"))) (clojure.core/contains? input "LastSuccessfulAssociationExecutionDate") (clojure.core/assoc :last-successful-association-execution-date (deser-date-time (input "LastSuccessfulAssociationExecutionDate"))) (clojure.core/contains? input "LastPingDateTime") (clojure.core/assoc :last-ping-date-time (deser-date-time (input "LastPingDateTime"))) (clojure.core/contains? input "AssociationOverview") (clojure.core/assoc :association-overview (deser-instance-aggregated-association-overview (input "AssociationOverview"))) (clojure.core/contains? input "IsLatestVersion") (clojure.core/assoc :is-latest-version (deser-boolean (input "IsLatestVersion"))) (clojure.core/contains? input "IPAddress") (clojure.core/assoc :ip-address (deser-ip-address (input "IPAddress"))) (clojure.core/contains? input "PlatformVersion") (clojure.core/assoc :platform-version (deser-string (input "PlatformVersion"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "ResourceType"))) (clojure.core/contains? input "ActivationId") (clojure.core/assoc :activation-id (deser-activation-id (input "ActivationId"))) (clojure.core/contains? input "LastAssociationExecutionDate") (clojure.core/assoc :last-association-execution-date (deser-date-time (input "LastAssociationExecutionDate"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-string (input "Name"))) (clojure.core/contains? input "RegistrationDate") (clojure.core/assoc :registration-date (deser-date-time (input "RegistrationDate"))) (clojure.core/contains? input "ComputerName") (clojure.core/assoc :computer-name (deser-computer-name (input "ComputerName")))))

(clojure.core/defn- deser-maintenance-window-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-task coll))) input))

(clojure.core/defn- deser-status-name [input] input)

(clojure.core/defn- deser-inventory-result-item [input] (clojure.core/cond-> {:type-name (deser-inventory-item-type-name (input "TypeName")), :schema-version (deser-inventory-item-schema-version (input "SchemaVersion")), :content (deser-inventory-item-entry-list (input "Content"))} (clojure.core/contains? input "CaptureTime") (clojure.core/assoc :capture-time (deser-inventory-item-capture-time (input "CaptureTime"))) (clojure.core/contains? input "ContentHash") (clojure.core/assoc :content-hash (deser-inventory-item-content-hash (input "ContentHash")))))

(clojure.core/defn- deser-command-plugin-name [input] input)

(clojure.core/defn- deser-content-length [input] input)

(clojure.core/defn- deser-attribute-value [input] input)

(clojure.core/defn- deser-session-manager-output-url [input] (clojure.core/cond-> {} (clojure.core/contains? input "S3OutputUrl") (clojure.core/assoc :s-3-output-url (deser-session-manager-s-3-output-url (input "S3OutputUrl"))) (clojure.core/contains? input "CloudWatchOutputUrl") (clojure.core/assoc :cloud-watch-output-url (deser-session-manager-cloud-watch-output-url (input "CloudWatchOutputUrl")))))

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-id [input] input)

(clojure.core/defn- deser-inventory-deletion-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "TotalCount") (clojure.core/assoc :total-count (deser-total-count (input "TotalCount"))) (clojure.core/contains? input "RemainingCount") (clojure.core/assoc :remaining-count (deser-remaining-count (input "RemainingCount"))) (clojure.core/contains? input "SummaryItems") (clojure.core/assoc :summary-items (deser-inventory-deletion-summary-items (input "SummaryItems")))))

(clojure.core/defn- deser-parameter-key-id [input] input)

(clojure.core/defn- deser-automation-parameter-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-automation-parameter-key k) (deser-automation-parameter-value-list v)])) input))

(clojure.core/defn- deser-association-overview [input] (clojure.core/cond-> {} (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "AssociationStatusAggregatedCount") (clojure.core/assoc :association-status-aggregated-count (deser-association-status-aggregated-count (input "AssociationStatusAggregatedCount")))))

(clojure.core/defn- deser-resource-compliance-summary-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "ComplianceType") (clojure.core/assoc :compliance-type (deser-compliance-type-name (input "ComplianceType"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-compliance-resource-type (input "ResourceType"))) (clojure.core/contains? input "ResourceId") (clojure.core/assoc :resource-id (deser-compliance-resource-id (input "ResourceId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-compliance-status (input "Status"))) (clojure.core/contains? input "OverallSeverity") (clojure.core/assoc :overall-severity (deser-compliance-severity (input "OverallSeverity"))) (clojure.core/contains? input "ExecutionSummary") (clojure.core/assoc :execution-summary (deser-compliance-execution-summary (input "ExecutionSummary"))) (clojure.core/contains? input "CompliantSummary") (clojure.core/assoc :compliant-summary (deser-compliant-summary (input "CompliantSummary"))) (clojure.core/contains? input "NonCompliantSummary") (clojure.core/assoc :non-compliant-summary (deser-non-compliant-summary (input "NonCompliantSummary")))))

(clojure.core/defn- deser-patch-rule-group [input] (clojure.core/cond-> {:patch-rules (deser-patch-rule-list (input "PatchRules"))}))

(clojure.core/defn- deser-maintenance-window-target-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-target coll))) input))

(clojure.core/defn- deser-command-plugin-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-command-plugin coll))) input))

(clojure.core/defn- deser-accounts [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account coll))) input))

(clojure.core/defn- deser-parameter-history-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-history coll))) input))

(clojure.core/defn- deser-service-setting-value [input] input)

(clojure.core/defn- deser-registrations-count [input] input)

(clojure.core/defn- deser-max-errors [input] input)

(clojure.core/defn- deser-inventory-item-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-item-attribute coll))) input))

(clojure.core/defn- deser-inventory-item-schema-version [input] input)

(clojure.core/defn- deser-compliance-status [input] (clojure.core/get {"COMPLIANT" :compliant, "NON_COMPLIANT" :non-compliant} input))

(clojure.core/defn- deser-inventory-deletion-status [input] (clojure.core/get {"InProgress" :in-progress, "Complete" :complete} input))

(clojure.core/defn- deser-account [input] input)

(clojure.core/defn- deser-compliance-execution-summary [input] (clojure.core/cond-> {:execution-time (deser-date-time (input "ExecutionTime"))} (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-compliance-execution-id (input "ExecutionId"))) (clojure.core/contains? input "ExecutionType") (clojure.core/assoc :execution-type (deser-compliance-execution-type (input "ExecutionType")))))

(clojure.core/defn- deser-url [input] input)

(clojure.core/defn- deser-invocation-trace-output [input] input)

(clojure.core/defn- deser-stream-url [input] input)

(clojure.core/defn- deser-allowed-pattern [input] input)

(clojure.core/defn- deser-tag-value [input] input)

(clojure.core/defn- deser-valid-next-step [input] input)

(clojure.core/defn- deser-patch-msrc-severity [input] input)

(clojure.core/defn- deser-document-default-version-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-name (input "Name"))) (clojure.core/contains? input "DefaultVersion") (clojure.core/assoc :default-version (deser-document-version (input "DefaultVersion"))) (clojure.core/contains? input "DefaultVersionName") (clojure.core/assoc :default-version-name (deser-document-version-name (input "DefaultVersionName")))))

(clojure.core/defn- deser-default-baseline [input] input)

(clojure.core/defn- deser-instance-tag-name [input] input)

(clojure.core/defn- deser-total-count [input] input)

(clojure.core/defn- deser-batch-error-message [input] input)

(clojure.core/defn- deser-patch-source-product-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-source-product coll))) input))

(clojure.core/defn- deser-baseline-id [input] input)

(clojure.core/defn- deser-patch-not-applicable-count [input] input)

(clojure.core/defn- deser-maintenance-window-target-id [input] input)

(clojure.core/defn- deser-failure-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "FailureStage") (clojure.core/assoc :failure-stage (deser-string (input "FailureStage"))) (clojure.core/contains? input "FailureType") (clojure.core/assoc :failure-type (deser-string (input "FailureType"))) (clojure.core/contains? input "Details") (clojure.core/assoc :details (deser-automation-parameter-map (input "Details")))))

(clojure.core/defn- deser-patch-product [input] input)

(clojure.core/defn- deser-ip-address [input] input)

(clojure.core/defn- deser-maintenance-window-id [input] input)

(clojure.core/defn- deser-created-date [input] input)

(clojure.core/defn- deser-patch-status [input] (clojure.core/cond-> {} (clojure.core/contains? input "DeploymentStatus") (clojure.core/assoc :deployment-status (deser-patch-deployment-status (input "DeploymentStatus"))) (clojure.core/contains? input "ComplianceLevel") (clojure.core/assoc :compliance-level (deser-patch-compliance-level (input "ComplianceLevel"))) (clojure.core/contains? input "ApprovalDate") (clojure.core/assoc :approval-date (deser-date-time (input "ApprovalDate")))))

(clojure.core/defn- deser-normal-string-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-automation-target-parameter-name [input] input)

(clojure.core/defn- deser-patch-vendor [input] input)

(clojure.core/defn- deser-compliance-execution-id [input] input)

(clojure.core/defn- deser-maintenance-window-description [input] input)

(clojure.core/defn- deser-association-name [input] input)

(clojure.core/defn- deser-maintenance-window-lambda-client-context [input] input)

(clojure.core/defn- deser-maintenance-window-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (input "WindowExecutionId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (input "StatusDetails"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-date-time (input "StartTime"))) (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-date-time (input "EndTime")))))

(clojure.core/defn- deser-integer [input] input)

(clojure.core/defn- deser-last-successful-resource-data-sync-time [input] input)

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-ps-parameter-name (input "Name"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-parameter-type (input "Type"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-ps-parameter-value (input "Value"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-ps-parameter-version (input "Version"))) (clojure.core/contains? input "Selector") (clojure.core/assoc :selector (deser-ps-parameter-selector (input "Selector"))) (clojure.core/contains? input "SourceResult") (clojure.core/assoc :source-result (deser-string (input "SourceResult"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "ARN") (clojure.core/assoc :arn (deser-string (input "ARN")))))

(clojure.core/defn- deser-parameter-description [input] input)

(clojure.core/defn- deser-patch-installed-other-count [input] input)

(clojure.core/defn- deser-account-id [input] input)

(clojure.core/defn- deser-inventory-item-schema-result-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-item-schema coll))) input))

(clojure.core/defn- deser-resource-compliance-summary-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource-compliance-summary-item coll))) input))

(clojure.core/defn- deser-maintenance-window-task-target-id [input] input)

(clojure.core/defn- deser-create-association-batch-request-entry [input] (clojure.core/cond-> {:name (deser-document-arn (input "Name"))} (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "ComplianceSeverity") (clojure.core/assoc :compliance-severity (deser-association-compliance-severity (input "ComplianceSeverity"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "AutomationTargetParameterName") (clojure.core/assoc :automation-target-parameter-name (deser-automation-target-parameter-name (input "AutomationTargetParameterName"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "OutputLocation") (clojure.core/assoc :output-location (deser-instance-association-output-location (input "OutputLocation")))))

(clojure.core/defn- deser-patch-description [input] input)

(clojure.core/defn- deser-patch-filter-key [input] (clojure.core/get {"PRODUCT" :product, "CLASSIFICATION" :classification, "MSRC_SEVERITY" :msrc-severity, "PATCH_ID" :patch-id, "SECTION" :section, "PRIORITY" :priority, "SEVERITY" :severity} input))

(clojure.core/defn- deser-attachment-name [input] input)

(clojure.core/defn- deser-patch-failed-count [input] input)

(clojure.core/defn- deser-maintenance-window-lambda-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "ClientContext") (clojure.core/assoc :client-context (deser-maintenance-window-lambda-client-context (input "ClientContext"))) (clojure.core/contains? input "Qualifier") (clojure.core/assoc :qualifier (deser-maintenance-window-lambda-qualifier (input "Qualifier"))) (clojure.core/contains? input "Payload") (clojure.core/assoc :payload (deser-maintenance-window-lambda-payload (input "Payload")))))

(clojure.core/defn- deser-automation-execution-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Waiting" :waiting, "Success" :success, "TimedOut" :timed-out, "Cancelling" :cancelling, "Cancelled" :cancelled, "Failed" :failed} input))

(clojure.core/defn- deser-document-schema-version [input] input)

(clojure.core/defn- deser-attachment-information-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attachment-information coll))) input))

(clojure.core/defn- deser-patch-source-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-source coll))) input))

(clojure.core/defn- deser-target-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "Accounts") (clojure.core/assoc :accounts (deser-accounts (input "Accounts"))) (clojure.core/contains? input "Regions") (clojure.core/assoc :regions (deser-regions (input "Regions"))) (clojure.core/contains? input "TargetLocationMaxConcurrency") (clojure.core/assoc :target-location-max-concurrency (deser-max-concurrency (input "TargetLocationMaxConcurrency"))) (clojure.core/contains? input "TargetLocationMaxErrors") (clojure.core/assoc :target-location-max-errors (deser-max-errors (input "TargetLocationMaxErrors"))) (clojure.core/contains? input "ExecutionRoleName") (clojure.core/assoc :execution-role-name (deser-execution-role-name (input "ExecutionRoleName")))))

(clojure.core/defn- deser-notification-arn [input] input)

(clojure.core/defn- deser-resource-data-sync-created-time [input] input)

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"ManagedInstance" :managed-instance, "Document" :document, "EC2Instance" :ec-2-instance} input))

(clojure.core/defn- deser-maintenance-window-step-functions-input [input] input)

(clojure.core/defn- deser-activation-id [input] input)

(clojure.core/defn- deser-document-parameter-default-value [input] input)

(clojure.core/defn- deser-document-format [input] (clojure.core/get {"YAML" :yaml, "JSON" :json} input))

(clojure.core/defn- deser-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target coll))) input))

(clojure.core/defn- deser-patch-compliance-level [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low, "INFORMATIONAL" :informational, "UNSPECIFIED" :unspecified} input))

(clojure.core/defn- deser-patch-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch coll))) input))

(clojure.core/defn- deser-patch-source-configuration [input] input)

(clojure.core/defn- deser-target-map-value [input] input)

(clojure.core/defn- deser-document-status [input] (clojure.core/get {"Creating" :creating, "Active" :active, "Updating" :updating, "Deleting" :deleting, "Failed" :failed} input))

(clojure.core/defn- deser-description-in-document [input] input)

(clojure.core/defn- deser-command [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRole") (clojure.core/assoc :service-role (deser-service-role (input "ServiceRole"))) (clojure.core/contains? input "InstanceIds") (clojure.core/assoc :instance-ids (deser-instance-id-list (input "InstanceIds"))) (clojure.core/contains? input "Comment") (clojure.core/assoc :comment (deser-comment (input "Comment"))) (clojure.core/contains? input "DeliveryTimedOutCount") (clojure.core/assoc :delivery-timed-out-count (deser-delivery-timed-out-count (input "DeliveryTimedOutCount"))) (clojure.core/contains? input "CompletedCount") (clojure.core/assoc :completed-count (deser-completed-count (input "CompletedCount"))) (clojure.core/contains? input "ErrorCount") (clojure.core/assoc :error-count (deser-error-count (input "ErrorCount"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "NotificationConfig") (clojure.core/assoc :notification-config (deser-notification-config (input "NotificationConfig"))) (clojure.core/contains? input "ExpiresAfter") (clojure.core/assoc :expires-after (deser-date-time (input "ExpiresAfter"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-command-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (input "StatusDetails"))) (clojure.core/contains? input "CloudWatchOutputConfig") (clojure.core/assoc :cloud-watch-output-config (deser-cloud-watch-output-config (input "CloudWatchOutputConfig"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "RequestedDateTime") (clojure.core/assoc :requested-date-time (deser-date-time (input "RequestedDateTime"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "CommandId") (clojure.core/assoc :command-id (deser-command-id (input "CommandId"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix"))) (clojure.core/contains? input "OutputS3Region") (clojure.core/assoc :output-s-3-region (deser-s-3-region (input "OutputS3Region"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "TargetCount") (clojure.core/assoc :target-count (deser-target-count (input "TargetCount")))))

(clojure.core/defn- deser-target-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-value coll))) input))

(clojure.core/defn- deser-instances-count [input] input)

(clojure.core/defn- deser-patch-group-patch-baseline-mapping-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-group-patch-baseline-mapping coll))) input))

(clojure.core/defn- deser-resource-count [input] input)

(clojure.core/defn- deser-execution-role-name [input] input)

(clojure.core/defn- deser-baseline-name [input] input)

(clojure.core/defn- deser-session-manager-s-3-output-url [input] input)

(clojure.core/defn- deser-attachment-hash-type [input] (clojure.core/get {"Sha256" :sha-256} input))

(clojure.core/defn- deser-attachment-url [input] input)

(clojure.core/defn- deser-activation [input] (clojure.core/cond-> {} (clojure.core/contains? input "Tags") (clojure.core/assoc :tags (deser-tag-list (input "Tags"))) (clojure.core/contains? input "IamRole") (clojure.core/assoc :iam-role (deser-iam-role (input "IamRole"))) (clojure.core/contains? input "DefaultInstanceName") (clojure.core/assoc :default-instance-name (deser-default-instance-name (input "DefaultInstanceName"))) (clojure.core/contains? input "ExpirationDate") (clojure.core/assoc :expiration-date (deser-expiration-date (input "ExpirationDate"))) (clojure.core/contains? input "Expired") (clojure.core/assoc :expired (deser-boolean (input "Expired"))) (clojure.core/contains? input "RegistrationsCount") (clojure.core/assoc :registrations-count (deser-registrations-count (input "RegistrationsCount"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-activation-description (input "Description"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-created-date (input "CreatedDate"))) (clojure.core/contains? input "ActivationId") (clojure.core/assoc :activation-id (deser-activation-id (input "ActivationId"))) (clojure.core/contains? input "RegistrationLimit") (clojure.core/assoc :registration-limit (deser-registration-limit (input "RegistrationLimit")))))

(clojure.core/defn- deser-maintenance-window-step-functions-name [input] input)

(clojure.core/defn- deser-compliance-resource-id [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (input "TaskExecutionId"))) (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-date-time (input "EndTime"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-date-time (input "StartTime"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-maintenance-window-execution-task-invocation-parameters (input "Parameters"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (input "StatusDetails"))) (clojure.core/contains? input "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (input "WindowExecutionId"))) (clojure.core/contains? input "InvocationId") (clojure.core/assoc :invocation-id (deser-maintenance-window-execution-task-invocation-id (input "InvocationId"))) (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-maintenance-window-execution-task-execution-id (input "ExecutionId"))) (clojure.core/contains? input "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-task-target-id (input "WindowTargetId"))) (clojure.core/contains? input "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (input "TaskType"))) (clojure.core/contains? input "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (input "OwnerInformation")))))

(clojure.core/defn- deser-resource-data-sync-s-3-bucket-name [input] input)

(clojure.core/defn- deser-maintenance-window-duration-hours [input] input)

(clojure.core/defn- deser-platform-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-platform-type coll))) input))

(clojure.core/defn- deser-s-3-key-prefix [input] input)

(clojure.core/defn- deser-session-manager-cloud-watch-output-url [input] input)

(clojure.core/defn- deser-compliance-execution-type [input] input)

(clojure.core/defn- deser-effective-patch-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-effective-patch coll))) input))

(clojure.core/defn- deser-schedule-expression [input] input)

(clojure.core/defn- deser-failed-create-association [input] (clojure.core/cond-> {} (clojure.core/contains? input "Entry") (clojure.core/assoc :entry (deser-create-association-batch-request-entry (input "Entry"))) (clojure.core/contains? input "Message") (clojure.core/assoc :message (deser-batch-error-message (input "Message"))) (clojure.core/contains? input "Fault") (clojure.core/assoc :fault (deser-fault (input "Fault")))))

(clojure.core/defn- deser-resource-data-sync-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource-data-sync-item coll))) input))

(clojure.core/defn- deser-command-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-command coll))) input))

(clojure.core/defn- deser-command-id [input] input)

(clojure.core/defn- deser-association-version-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "ComplianceSeverity") (clojure.core/assoc :compliance-severity (deser-association-compliance-severity (input "ComplianceSeverity"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (input "CreatedDate"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name"))) (clojure.core/contains? input "OutputLocation") (clojure.core/assoc :output-location (deser-instance-association-output-location (input "OutputLocation")))))

(clojure.core/defn- deser-instance-association [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "Content") (clojure.core/assoc :content (deser-document-content (input "Content"))) (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion")))))

(clojure.core/defn- deser-long [input] input)

(clojure.core/defn- deser-s-3-output-url [input] (clojure.core/cond-> {} (clojure.core/contains? input "OutputUrl") (clojure.core/assoc :output-url (deser-url (input "OutputUrl")))))

(clojure.core/defn- deser-install-override-list [input] input)

(clojure.core/defn- deser-activation-code [input] input)

(clojure.core/defn- deser-patch-source-name [input] input)

(clojure.core/defn- deser-inventory-item-entry-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-item-entry coll))) input))

(clojure.core/defn- deser-instance-association-status-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "ExecutionDate") (clojure.core/assoc :execution-date (deser-date-time (input "ExecutionDate"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "OutputUrl") (clojure.core/assoc :output-url (deser-instance-association-output-url (input "OutputUrl"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "ErrorCode") (clojure.core/assoc :error-code (deser-agent-error-code (input "ErrorCode"))) (clojure.core/contains? input "ExecutionSummary") (clojure.core/assoc :execution-summary (deser-instance-association-execution-summary (input "ExecutionSummary"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name")))))

(clojure.core/defn- deser-association-status-name [input] (clojure.core/get {"Pending" :pending, "Success" :success, "Failed" :failed} input))

(clojure.core/defn- deser-inventory-result-item-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-inventory-result-item-key k) (deser-inventory-result-item v)])) input))

(clojure.core/defn- deser-remaining-count [input] input)

(clojure.core/defn- deser-resource-data-sync-name [input] input)

(clojure.core/defn- deser-patch-rule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-rule coll))) input))

(clojure.core/defn- deser-owner-information [input] input)

(clojure.core/defn- deser-session-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-session coll))) input))

(clojure.core/defn- deser-maintenance-window-string-date-time [input] input)

(clojure.core/defn- deser-service-setting-id [input] input)

(clojure.core/defn- deser-s-3-output-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "OutputS3Region") (clojure.core/assoc :output-s-3-region (deser-s-3-region (input "OutputS3Region"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix")))))

(clojure.core/defn- deser-fault [input] (clojure.core/get {"Client" :client, "Server" :server, "Unknown" :unknown} input))

(clojure.core/defn- deser-maintenance-window-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-identity coll))) input))

(clojure.core/defn- deser-automation-parameter-value [input] input)

(clojure.core/defn- deser-patch-filter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-filter-value coll))) input))

(clojure.core/defn- deser-tag [input] (clojure.core/cond-> {:key (deser-tag-key (input "Key")), :value (deser-tag-value (input "Value"))}))

(clojure.core/defn- deser-maintenance-window-schedule [input] input)

(clojure.core/defn- deser-version [input] input)

(clojure.core/defn- deser-inventory-item-type-name [input] input)

(clojure.core/defn- deser-patch-compliance-data-state [input] (clojure.core/get {"INSTALLED" :installed, "INSTALLED_OTHER" :installed-other, "INSTALLED_REJECTED" :installed-rejected, "MISSING" :missing, "NOT_APPLICABLE" :not-applicable, "FAILED" :failed} input))

(clojure.core/defn- deser-maintenance-window-task-invocation-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "RunCommand") (clojure.core/assoc :run-command (deser-maintenance-window-run-command-parameters (input "RunCommand"))) (clojure.core/contains? input "Automation") (clojure.core/assoc :automation (deser-maintenance-window-automation-parameters (input "Automation"))) (clojure.core/contains? input "StepFunctions") (clojure.core/assoc :step-functions (deser-maintenance-window-step-functions-parameters (input "StepFunctions"))) (clojure.core/contains? input "Lambda") (clojure.core/assoc :lambda (deser-maintenance-window-lambda-parameters (input "Lambda")))))

(clojure.core/defn- deser-document-name [input] input)

(clojure.core/defn- deser-ps-parameter-selector [input] input)

(clojure.core/defn- deser-maintenance-window-step-functions-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "Input") (clojure.core/assoc :input (deser-maintenance-window-step-functions-input (input "Input"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-step-functions-name (input "Name")))))

(clojure.core/defn- deser-inventory-result-item-key [input] input)

(clojure.core/defn- deser-maintenance-windows-for-target-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-identity-for-target coll))) input))

(clojure.core/defn- deser-patch-filter-value [input] input)

(clojure.core/defn- deser-maintenance-window-task-type [input] (clojure.core/get {"RUN_COMMAND" :run-command, "AUTOMATION" :automation, "STEP_FUNCTIONS" :step-functions, "LAMBDA" :lambda} input))

(clojure.core/defn- deser-output-source-type [input] input)

(clojure.core/defn- deser-maintenance-window-allow-unassociated-targets [input] input)

(clojure.core/defn- deser-maintenance-window-execution-status-details [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameters-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-task-parameters coll))) input))

(clojure.core/defn- deser-document-version [input] input)

(clojure.core/defn- deser-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "Key") (clojure.core/assoc :key (deser-target-key (input "Key"))) (clojure.core/contains? input "Values") (clojure.core/assoc :values (deser-target-values (input "Values")))))

(clojure.core/defn- deser-scheduled-window-execution-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-window-execution coll))) input))

(clojure.core/defn- deser-document-hash-type [input] (clojure.core/get {"Sha256" :sha-256, "Sha1" :sha-1} input))

(clojure.core/defn- deser-valid-next-step-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-valid-next-step coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution-task-id coll))) input))

(clojure.core/defn- deser-association-execution-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "OutputSource") (clojure.core/assoc :output-source (deser-output-source (input "OutputSource"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "ResourceId") (clojure.core/assoc :resource-id (deser-association-resource-id (input "ResourceId"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-association-execution-id (input "ExecutionId"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-association-resource-type (input "ResourceType"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus")))))

(clojure.core/defn- deser-instance-association-execution-summary [input] input)

(clojure.core/defn- deser-instance-patch-state [input] (clojure.core/cond-> {:instance-id (deser-instance-id (input "InstanceId")), :patch-group (deser-patch-group (input "PatchGroup")), :baseline-id (deser-baseline-id (input "BaselineId")), :operation-start-time (deser-date-time (input "OperationStartTime")), :operation-end-time (deser-date-time (input "OperationEndTime")), :operation (deser-patch-operation-type (input "Operation"))} (clojure.core/contains? input "FailedCount") (clojure.core/assoc :failed-count (deser-patch-failed-count (input "FailedCount"))) (clojure.core/contains? input "InstalledOtherCount") (clojure.core/assoc :installed-other-count (deser-patch-installed-other-count (input "InstalledOtherCount"))) (clojure.core/contains? input "NotApplicableCount") (clojure.core/assoc :not-applicable-count (deser-patch-not-applicable-count (input "NotApplicableCount"))) (clojure.core/contains? input "InstallOverrideList") (clojure.core/assoc :install-override-list (deser-install-override-list (input "InstallOverrideList"))) (clojure.core/contains? input "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (input "OwnerInformation"))) (clojure.core/contains? input "InstalledCount") (clojure.core/assoc :installed-count (deser-patch-installed-count (input "InstalledCount"))) (clojure.core/contains? input "InstalledRejectedCount") (clojure.core/assoc :installed-rejected-count (deser-patch-installed-rejected-count (input "InstalledRejectedCount"))) (clojure.core/contains? input "MissingCount") (clojure.core/assoc :missing-count (deser-patch-missing-count (input "MissingCount"))) (clojure.core/contains? input "SnapshotId") (clojure.core/assoc :snapshot-id (deser-snapshot-id (input "SnapshotId")))))

(clojure.core/defn- deser-association [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "Overview") (clojure.core/assoc :overview (deser-association-overview (input "Overview"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name")))))

(clojure.core/defn- deser-patch-product-family [input] input)

(clojure.core/defn- deser-document-parameter-type [input] (clojure.core/get {"String" :string, "StringList" :string-list} input))

(clojure.core/defn- deser-resource-count-by-status [input] input)

(clojure.core/defn- deser-service-setting [input] (clojure.core/cond-> {} (clojure.core/contains? input "SettingId") (clojure.core/assoc :setting-id (deser-service-setting-id (input "SettingId"))) (clojure.core/contains? input "SettingValue") (clojure.core/assoc :setting-value (deser-service-setting-value (input "SettingValue"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "LastModifiedUser") (clojure.core/assoc :last-modified-user (deser-string (input "LastModifiedUser"))) (clojure.core/contains? input "ARN") (clojure.core/assoc :arn (deser-string (input "ARN"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-string (input "Status")))))

(clojure.core/defn- deser-compliance-summary-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "ComplianceType") (clojure.core/assoc :compliance-type (deser-compliance-type-name (input "ComplianceType"))) (clojure.core/contains? input "CompliantSummary") (clojure.core/assoc :compliant-summary (deser-compliant-summary (input "CompliantSummary"))) (clojure.core/contains? input "NonCompliantSummary") (clojure.core/assoc :non-compliant-summary (deser-non-compliant-summary (input "NonCompliantSummary")))))

(clojure.core/defn- deser-command-plugin-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Success" :success, "TimedOut" :timed-out, "Cancelled" :cancelled, "Failed" :failed} input))

(clojure.core/defn- deser-maintenance-window-timezone [input] input)

(clojure.core/defn- deser-patch-title [input] input)

(clojure.core/defn- deser-association-compliance-severity [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low, "UNSPECIFIED" :unspecified} input))

(clojure.core/defn- deser-session [input] (clojure.core/cond-> {} (clojure.core/contains? input "SessionId") (clojure.core/assoc :session-id (deser-session-id (input "SessionId"))) (clojure.core/contains? input "Details") (clojure.core/assoc :details (deser-session-details (input "Details"))) (clojure.core/contains? input "EndDate") (clojure.core/assoc :end-date (deser-date-time (input "EndDate"))) (clojure.core/contains? input "OutputUrl") (clojure.core/assoc :output-url (deser-session-manager-output-url (input "OutputUrl"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-session-status (input "Status"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-session-owner (input "Owner"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "Target") (clojure.core/assoc :target (deser-session-target (input "Target"))) (clojure.core/contains? input "StartDate") (clojure.core/assoc :start-date (deser-date-time (input "StartDate")))))

(clojure.core/defn- deser-activation-description [input] input)

(clojure.core/defn- deser-ps-parameter-name [input] input)

(clojure.core/defn- deser-activation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-activation coll))) input))

(clojure.core/defn- deser-instance-association-output-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "S3Location") (clojure.core/assoc :s-3-location (deser-s-3-output-location (input "S3Location")))))

(clojure.core/defn- deser-maintenance-window-automation-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-automation-parameter-map (input "Parameters")))))

(clojure.core/defn- deser-association-status-aggregated-count [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-status-name k) (deser-instance-count v)])) input))

(clojure.core/defn- deser-patch-language [input] input)

(clojure.core/defn- deser-attachment-content-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attachment-content coll))) input))

(clojure.core/defn- deser-inventory-item-capture-time [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (input "WindowExecutionId"))) (clojure.core/contains? input "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (input "TaskExecutionId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (input "StatusDetails"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-date-time (input "StartTime"))) (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-date-time (input "EndTime"))) (clojure.core/contains? input "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (input "TaskArn"))) (clojure.core/contains? input "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (input "TaskType")))))

(clojure.core/defn- deser-failed-create-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-failed-create-association coll))) input))

(clojure.core/defn- deser-baseline-description [input] input)

(clojure.core/defn- deser-maintenance-window-execution-id [input] input)

(clojure.core/defn- deser-automation-execution-id [input] input)

(clojure.core/defn- deser-target-value [input] input)

(clojure.core/defn- deser-compliance-summary-count [input] input)

(clojure.core/defn- deser-patch-filter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-filter coll))) input))

(clojure.core/defn- deser-inventory-deletion-id [input] input)

(clojure.core/defn- deser-region [input] input)

(clojure.core/defn- deser-token-value [input] input)

(clojure.core/defn- deser-inventory-item-attribute [input] (clojure.core/cond-> {:name (deser-inventory-item-attribute-name (input "Name")), :data-type (deser-inventory-attribute-data-type (input "DataType"))}))

(clojure.core/defn- deser-patch-source-product [input] input)

(clojure.core/defn- deser-computer-name [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameter-value-expression [input] (clojure.core/cond-> {} (clojure.core/contains? input "Values") (clojure.core/assoc :values (deser-maintenance-window-task-parameter-value-list (input "Values")))))

(clojure.core/defn- deser-target-map-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-map-value coll))) input))

(clojure.core/defn- deser-target-key [input] input)

(clojure.core/defn- deser-inventory-deletion-summary-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-inventory-item-schema-version (input "Version"))) (clojure.core/contains? input "Count") (clojure.core/assoc :count (deser-resource-count (input "Count"))) (clojure.core/contains? input "RemainingCount") (clojure.core/assoc :remaining-count (deser-remaining-count (input "RemainingCount")))))

(clojure.core/defn- deser-automation-parameter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-automation-parameter-value coll))) input))

(clojure.core/defn- deser-compliance-item-details [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-name k) (deser-attribute-value v)])) input))

(clojure.core/defn- deser-maintenance-window-task-parameter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-task-parameter-value coll))) input))

(clojure.core/defn- deser-last-resource-data-sync-time [input] input)

(clojure.core/defn- deser-patch [input] (clojure.core/cond-> {} (clojure.core/contains? input "KbNumber") (clojure.core/assoc :kb-number (deser-patch-kb-number (input "KbNumber"))) (clojure.core/contains? input "Product") (clojure.core/assoc :product (deser-patch-product (input "Product"))) (clojure.core/contains? input "MsrcNumber") (clojure.core/assoc :msrc-number (deser-patch-msrc-number (input "MsrcNumber"))) (clojure.core/contains? input "Title") (clojure.core/assoc :title (deser-patch-title (input "Title"))) (clojure.core/contains? input "MsrcSeverity") (clojure.core/assoc :msrc-severity (deser-patch-msrc-severity (input "MsrcSeverity"))) (clojure.core/contains? input "ProductFamily") (clojure.core/assoc :product-family (deser-patch-product-family (input "ProductFamily"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-patch-description (input "Description"))) (clojure.core/contains? input "ReleaseDate") (clojure.core/assoc :release-date (deser-date-time (input "ReleaseDate"))) (clojure.core/contains? input "Classification") (clojure.core/assoc :classification (deser-patch-classification (input "Classification"))) (clojure.core/contains? input "ContentUrl") (clojure.core/assoc :content-url (deser-patch-content-url (input "ContentUrl"))) (clojure.core/contains? input "Language") (clojure.core/assoc :language (deser-patch-language (input "Language"))) (clojure.core/contains? input "Vendor") (clojure.core/assoc :vendor (deser-patch-vendor (input "Vendor"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-patch-id (input "Id")))))

(clojure.core/defn- deser-patch-group-patch-baseline-mapping [input] (clojure.core/cond-> {} (clojure.core/contains? input "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (input "PatchGroup"))) (clojure.core/contains? input "BaselineIdentity") (clojure.core/assoc :baseline-identity (deser-patch-baseline-identity (input "BaselineIdentity")))))

(clojure.core/defn- deser-instance-information-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-information coll))) input))

(clojure.core/defn- deser-compliance-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "Severity") (clojure.core/assoc :severity (deser-compliance-severity (input "Severity"))) (clojure.core/contains? input "Details") (clojure.core/assoc :details (deser-compliance-item-details (input "Details"))) (clojure.core/contains? input "Title") (clojure.core/assoc :title (deser-compliance-item-title (input "Title"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-compliance-status (input "Status"))) (clojure.core/contains? input "ResourceId") (clojure.core/assoc :resource-id (deser-compliance-resource-id (input "ResourceId"))) (clojure.core/contains? input "ExecutionSummary") (clojure.core/assoc :execution-summary (deser-compliance-execution-summary (input "ExecutionSummary"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-compliance-resource-type (input "ResourceType"))) (clojure.core/contains? input "ComplianceType") (clojure.core/assoc :compliance-type (deser-compliance-type-name (input "ComplianceType"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-compliance-item-id (input "Id")))))

(clojure.core/defn- deser-operating-system [input] (clojure.core/get {"WINDOWS" :windows, "AMAZON_LINUX" :amazon-linux, "AMAZON_LINUX_2" :amazon-linux-2, "UBUNTU" :ubuntu, "REDHAT_ENTERPRISE_LINUX" :redhat-enterprise-linux, "SUSE" :suse, "CENTOS" :centos} input))

(clojure.core/defn- deser-document-identifier-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-identifier coll))) input))

(clojure.core/defn- deser-notification-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-notification-event coll))) input))

(clojure.core/defn- deser-step-execution-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-step-execution coll))) input))

(clojure.core/defn- deser-instance-association-status-aggregated-count [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-status-name k) (deser-instance-count v)])) input))

(clojure.core/defn- deser-maintenance-window-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "EndDate") (clojure.core/assoc :end-date (deser-maintenance-window-string-date-time (input "EndDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-maintenance-window-enabled (input "Enabled"))) (clojure.core/contains? input "NextExecutionTime") (clojure.core/assoc :next-execution-time (deser-maintenance-window-string-date-time (input "NextExecutionTime"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-maintenance-window-description (input "Description"))) (clojure.core/contains? input "Duration") (clojure.core/assoc :duration (deser-maintenance-window-duration-hours (input "Duration"))) (clojure.core/contains? input "Cutoff") (clojure.core/assoc :cutoff (deser-maintenance-window-cutoff (input "Cutoff"))) (clojure.core/contains? input "Schedule") (clojure.core/assoc :schedule (deser-maintenance-window-schedule (input "Schedule"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name"))) (clojure.core/contains? input "StartDate") (clojure.core/assoc :start-date (deser-maintenance-window-string-date-time (input "StartDate"))) (clojure.core/contains? input "ScheduleTimezone") (clojure.core/assoc :schedule-timezone (deser-maintenance-window-timezone (input "ScheduleTimezone")))))

(clojure.core/defn- deser-snapshot-id [input] input)

(clojure.core/defn- deser-registration-limit [input] input)

(clojure.core/defn- deser-parameter-value [input] input)

(clojure.core/defn- deser-standard-error-content [input] input)

(clojure.core/defn- deser-date-time [input] input)

(clojure.core/defn- deser-patch-operation-type [input] (clojure.core/get {"Scan" :scan, "Install" :install} input))

(clojure.core/defn- deser-target-values [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-value coll))) input))

(clojure.core/defn- deser-patch-kb-number [input] input)

(clojure.core/defn- deser-inventory-attribute-data-type [input] (clojure.core/get {"string" :string, "number" :number} input))

(clojure.core/defn- deser-instance-patch-state-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-patch-state coll))) input))

(clojure.core/defn- deser-target-count [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameter-value [input] input)

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- deser-inventory-deletion-last-status-message [input] input)

(clojure.core/defn- deser-maintenance-window-resource-type [input] (clojure.core/get {"INSTANCE" :instance} input))

(clojure.core/defn- response-invalid-delete-inventory-parameters-exception ([input] (response-invalid-delete-inventory-parameters-exception nil input)) ([resultWrapper2059961 input] (clojure.core/let [rawinput2059960 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059962 {"Message" (rawinput2059960 "Message")}] (clojure.core/cond-> {} (letvar2059962 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059962 ["Message"])))))))

(clojure.core/defn- response-list-tags-for-resource-result ([input] (response-list-tags-for-resource-result nil input)) ([resultWrapper2059964 input] (clojure.core/let [rawinput2059963 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059965 {"TagList" (rawinput2059963 "TagList")}] (clojure.core/cond-> {} (letvar2059965 "TagList") (clojure.core/assoc :tag-list (deser-tag-list (clojure.core/get-in letvar2059965 ["TagList"])))))))

(clojure.core/defn- response-invalid-automation-status-update-exception ([input] (response-invalid-automation-status-update-exception nil input)) ([resultWrapper2059967 input] (clojure.core/let [rawinput2059966 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059968 {"Message" (rawinput2059966 "Message")}] (clojure.core/cond-> {} (letvar2059968 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059968 ["Message"])))))))

(clojure.core/defn- response-automation-step-not-found-exception ([input] (response-automation-step-not-found-exception nil input)) ([resultWrapper2059970 input] (clojure.core/let [rawinput2059969 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059971 {"Message" (rawinput2059969 "Message")}] (clojure.core/cond-> {} (letvar2059971 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059971 ["Message"])))))))

(clojure.core/defn- response-stop-automation-execution-result ([input] (response-stop-automation-execution-result nil input)) ([resultWrapper2059973 input] (clojure.core/let [rawinput2059972 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059974 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-association-result ([input] (response-create-association-result nil input)) ([resultWrapper2059976 input] (clojure.core/let [rawinput2059975 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059977 {"AssociationDescription" (rawinput2059975 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2059977 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2059977 ["AssociationDescription"])))))))

(clojure.core/defn- response-compliance-type-count-limit-exceeded-exception ([input] (response-compliance-type-count-limit-exceeded-exception nil input)) ([resultWrapper2059979 input] (clojure.core/let [rawinput2059978 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059980 {"Message" (rawinput2059978 "Message")}] (clojure.core/cond-> {} (letvar2059980 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059980 ["Message"])))))))

(clojure.core/defn- response-describe-maintenance-windows-result ([input] (response-describe-maintenance-windows-result nil input)) ([resultWrapper2059982 input] (clojure.core/let [rawinput2059981 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059983 {"WindowIdentities" (rawinput2059981 "WindowIdentities"), "NextToken" (rawinput2059981 "NextToken")}] (clojure.core/cond-> {} (letvar2059983 "WindowIdentities") (clojure.core/assoc :window-identities (deser-maintenance-window-identity-list (clojure.core/get-in letvar2059983 ["WindowIdentities"]))) (letvar2059983 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2059983 ["NextToken"])))))))

(clojure.core/defn- response-invalid-activation ([input] (response-invalid-activation nil input)) ([resultWrapper2059985 input] (clojure.core/let [rawinput2059984 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059986 {"Message" (rawinput2059984 "Message")}] (clojure.core/cond-> {} (letvar2059986 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059986 ["Message"])))))))

(clojure.core/defn- response-invalid-document-content ([input] (response-invalid-document-content nil input)) ([resultWrapper2059988 input] (clojure.core/let [rawinput2059987 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059989 {"Message" (rawinput2059987 "Message")}] (clojure.core/cond-> {} (letvar2059989 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059989 ["Message"])))))))

(clojure.core/defn- response-automation-definition-not-found-exception ([input] (response-automation-definition-not-found-exception nil input)) ([resultWrapper2059991 input] (clojure.core/let [rawinput2059990 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059992 {"Message" (rawinput2059990 "Message")}] (clojure.core/cond-> {} (letvar2059992 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2059992 ["Message"])))))))

(clojure.core/defn- response-get-parameter-result ([input] (response-get-parameter-result nil input)) ([resultWrapper2059994 input] (clojure.core/let [rawinput2059993 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059995 {"Parameter" (rawinput2059993 "Parameter")}] (clojure.core/cond-> {} (letvar2059995 "Parameter") (clojure.core/assoc :parameter (deser-parameter (clojure.core/get-in letvar2059995 ["Parameter"])))))))

(clojure.core/defn- response-label-parameter-version-result ([input] (response-label-parameter-version-result nil input)) ([resultWrapper2059997 input] (clojure.core/let [rawinput2059996 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2059998 {"InvalidLabels" (rawinput2059996 "InvalidLabels")}] (clojure.core/cond-> {} (letvar2059998 "InvalidLabels") (clojure.core/assoc :invalid-labels (deser-parameter-label-list (clojure.core/get-in letvar2059998 ["InvalidLabels"])))))))

(clojure.core/defn- response-describe-available-patches-result ([input] (response-describe-available-patches-result nil input)) ([resultWrapper2060000 input] (clojure.core/let [rawinput2059999 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060001 {"Patches" (rawinput2059999 "Patches"), "NextToken" (rawinput2059999 "NextToken")}] (clojure.core/cond-> {} (letvar2060001 "Patches") (clojure.core/assoc :patches (deser-patch-list (clojure.core/get-in letvar2060001 ["Patches"]))) (letvar2060001 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060001 ["NextToken"])))))))

(clojure.core/defn- response-list-documents-result ([input] (response-list-documents-result nil input)) ([resultWrapper2060003 input] (clojure.core/let [rawinput2060002 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060004 {"DocumentIdentifiers" (rawinput2060002 "DocumentIdentifiers"), "NextToken" (rawinput2060002 "NextToken")}] (clojure.core/cond-> {} (letvar2060004 "DocumentIdentifiers") (clojure.core/assoc :document-identifiers (deser-document-identifier-list (clojure.core/get-in letvar2060004 ["DocumentIdentifiers"]))) (letvar2060004 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060004 ["NextToken"])))))))

(clojure.core/defn- response-update-association-result ([input] (response-update-association-result nil input)) ([resultWrapper2060006 input] (clojure.core/let [rawinput2060005 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060007 {"AssociationDescription" (rawinput2060005 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2060007 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2060007 ["AssociationDescription"])))))))

(clojure.core/defn- response-already-exists-exception ([input] (response-already-exists-exception nil input)) ([resultWrapper2060009 input] (clojure.core/let [rawinput2060008 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060010 {"Message" (rawinput2060008 "Message")}] (clojure.core/cond-> {} (letvar2060010 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060010 ["Message"])))))))

(clojure.core/defn- response-max-document-size-exceeded ([input] (response-max-document-size-exceeded nil input)) ([resultWrapper2060012 input] (clojure.core/let [rawinput2060011 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060013 {"Message" (rawinput2060011 "Message")}] (clojure.core/cond-> {} (letvar2060013 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060013 ["Message"])))))))

(clojure.core/defn- response-put-parameter-result ([input] (response-put-parameter-result nil input)) ([resultWrapper2060015 input] (clojure.core/let [rawinput2060014 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060016 {"Version" (rawinput2060014 "Version")}] (clojure.core/cond-> {} (letvar2060016 "Version") (clojure.core/assoc :version (deser-ps-parameter-version (clojure.core/get-in letvar2060016 ["Version"])))))))

(clojure.core/defn- response-invalid-automation-execution-parameters-exception ([input] (response-invalid-automation-execution-parameters-exception nil input)) ([resultWrapper2060018 input] (clojure.core/let [rawinput2060017 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060019 {"Message" (rawinput2060017 "Message")}] (clojure.core/cond-> {} (letvar2060019 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060019 ["Message"])))))))

(clojure.core/defn- response-describe-automation-step-executions-result ([input] (response-describe-automation-step-executions-result nil input)) ([resultWrapper2060021 input] (clojure.core/let [rawinput2060020 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060022 {"StepExecutions" (rawinput2060020 "StepExecutions"), "NextToken" (rawinput2060020 "NextToken")}] (clojure.core/cond-> {} (letvar2060022 "StepExecutions") (clojure.core/assoc :step-executions (deser-step-execution-list (clojure.core/get-in letvar2060022 ["StepExecutions"]))) (letvar2060022 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060022 ["NextToken"])))))))

(clojure.core/defn- response-invalid-schedule ([input] (response-invalid-schedule nil input)) ([resultWrapper2060024 input] (clojure.core/let [rawinput2060023 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060025 {"Message" (rawinput2060023 "Message")}] (clojure.core/cond-> {} (letvar2060025 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060025 ["Message"])))))))

(clojure.core/defn- response-association-limit-exceeded ([input] (response-association-limit-exceeded nil input)) ([resultWrapper2060027 input] (clojure.core/let [rawinput2060026 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060028 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-maintenance-window-execution-task-invocation-result ([input] (response-get-maintenance-window-execution-task-invocation-result nil input)) ([resultWrapper2060030 input] (clojure.core/let [rawinput2060029 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060031 {"TaskExecutionId" (rawinput2060029 "TaskExecutionId"), "EndTime" (rawinput2060029 "EndTime"), "StartTime" (rawinput2060029 "StartTime"), "Parameters" (rawinput2060029 "Parameters"), "Status" (rawinput2060029 "Status"), "StatusDetails" (rawinput2060029 "StatusDetails"), "WindowExecutionId" (rawinput2060029 "WindowExecutionId"), "InvocationId" (rawinput2060029 "InvocationId"), "ExecutionId" (rawinput2060029 "ExecutionId"), "WindowTargetId" (rawinput2060029 "WindowTargetId"), "TaskType" (rawinput2060029 "TaskType"), "OwnerInformation" (rawinput2060029 "OwnerInformation")}] (clojure.core/cond-> {} (letvar2060031 "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (clojure.core/get-in letvar2060031 ["TaskExecutionId"]))) (letvar2060031 "EndTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar2060031 ["EndTime"]))) (letvar2060031 "StartTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar2060031 ["StartTime"]))) (letvar2060031 "Parameters") (clojure.core/assoc :parameters (deser-maintenance-window-execution-task-invocation-parameters (clojure.core/get-in letvar2060031 ["Parameters"]))) (letvar2060031 "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (clojure.core/get-in letvar2060031 ["Status"]))) (letvar2060031 "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (clojure.core/get-in letvar2060031 ["StatusDetails"]))) (letvar2060031 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2060031 ["WindowExecutionId"]))) (letvar2060031 "InvocationId") (clojure.core/assoc :invocation-id (deser-maintenance-window-execution-task-invocation-id (clojure.core/get-in letvar2060031 ["InvocationId"]))) (letvar2060031 "ExecutionId") (clojure.core/assoc :execution-id (deser-maintenance-window-execution-task-execution-id (clojure.core/get-in letvar2060031 ["ExecutionId"]))) (letvar2060031 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-task-target-id (clojure.core/get-in letvar2060031 ["WindowTargetId"]))) (letvar2060031 "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (clojure.core/get-in letvar2060031 ["TaskType"]))) (letvar2060031 "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (clojure.core/get-in letvar2060031 ["OwnerInformation"])))))))

(clojure.core/defn- response-too-many-tags-error ([input] (response-too-many-tags-error nil input)) ([resultWrapper2060033 input] (clojure.core/let [rawinput2060032 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060034 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-command-invocations-result ([input] (response-list-command-invocations-result nil input)) ([resultWrapper2060036 input] (clojure.core/let [rawinput2060035 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060037 {"CommandInvocations" (rawinput2060035 "CommandInvocations"), "NextToken" (rawinput2060035 "NextToken")}] (clojure.core/cond-> {} (letvar2060037 "CommandInvocations") (clojure.core/assoc :command-invocations (deser-command-invocation-list (clojure.core/get-in letvar2060037 ["CommandInvocations"]))) (letvar2060037 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060037 ["NextToken"])))))))

(clojure.core/defn- response-hierarchy-type-mismatch-exception ([input] (response-hierarchy-type-mismatch-exception nil input)) ([resultWrapper2060039 input] (clojure.core/let [rawinput2060038 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060040 {"message" (rawinput2060038 "message")}] (clojure.core/cond-> {} (letvar2060040 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060040 ["message"])))))))

(clojure.core/defn- response-update-service-setting-result ([input] (response-update-service-setting-result nil input)) ([resultWrapper2060042 input] (clojure.core/let [rawinput2060041 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060043 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-activation-id ([input] (response-invalid-activation-id nil input)) ([resultWrapper2060045 input] (clojure.core/let [rawinput2060044 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060046 {"Message" (rawinput2060044 "Message")}] (clojure.core/cond-> {} (letvar2060046 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060046 ["Message"])))))))

(clojure.core/defn- response-association-execution-does-not-exist ([input] (response-association-execution-does-not-exist nil input)) ([resultWrapper2060048 input] (clojure.core/let [rawinput2060047 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060049 {"Message" (rawinput2060047 "Message")}] (clojure.core/cond-> {} (letvar2060049 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060049 ["Message"])))))))

(clojure.core/defn- response-create-activation-result ([input] (response-create-activation-result nil input)) ([resultWrapper2060051 input] (clojure.core/let [rawinput2060050 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060052 {"ActivationId" (rawinput2060050 "ActivationId"), "ActivationCode" (rawinput2060050 "ActivationCode")}] (clojure.core/cond-> {} (letvar2060052 "ActivationId") (clojure.core/assoc :activation-id (deser-activation-id (clojure.core/get-in letvar2060052 ["ActivationId"]))) (letvar2060052 "ActivationCode") (clojure.core/assoc :activation-code (deser-activation-code (clojure.core/get-in letvar2060052 ["ActivationCode"])))))))

(clojure.core/defn- response-resource-data-sync-invalid-configuration-exception ([input] (response-resource-data-sync-invalid-configuration-exception nil input)) ([resultWrapper2060054 input] (clojure.core/let [rawinput2060053 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060055 {"Message" (rawinput2060053 "Message")}] (clojure.core/cond-> {} (letvar2060055 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060055 ["Message"])))))))

(clojure.core/defn- response-invalid-option-exception ([input] (response-invalid-option-exception nil input)) ([resultWrapper2060057 input] (clojure.core/let [rawinput2060056 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060058 {"Message" (rawinput2060056 "Message")}] (clojure.core/cond-> {} (letvar2060058 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060058 ["Message"])))))))

(clojure.core/defn- response-get-inventory-result ([input] (response-get-inventory-result nil input)) ([resultWrapper2060060 input] (clojure.core/let [rawinput2060059 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060061 {"Entities" (rawinput2060059 "Entities"), "NextToken" (rawinput2060059 "NextToken")}] (clojure.core/cond-> {} (letvar2060061 "Entities") (clojure.core/assoc :entities (deser-inventory-result-entity-list (clojure.core/get-in letvar2060061 ["Entities"]))) (letvar2060061 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060061 ["NextToken"])))))))

(clojure.core/defn- response-list-inventory-entries-result ([input] (response-list-inventory-entries-result nil input)) ([resultWrapper2060063 input] (clojure.core/let [rawinput2060062 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060064 {"TypeName" (rawinput2060062 "TypeName"), "InstanceId" (rawinput2060062 "InstanceId"), "SchemaVersion" (rawinput2060062 "SchemaVersion"), "CaptureTime" (rawinput2060062 "CaptureTime"), "Entries" (rawinput2060062 "Entries"), "NextToken" (rawinput2060062 "NextToken")}] (clojure.core/cond-> {} (letvar2060064 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2060064 ["TypeName"]))) (letvar2060064 "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (clojure.core/get-in letvar2060064 ["InstanceId"]))) (letvar2060064 "SchemaVersion") (clojure.core/assoc :schema-version (deser-inventory-item-schema-version (clojure.core/get-in letvar2060064 ["SchemaVersion"]))) (letvar2060064 "CaptureTime") (clojure.core/assoc :capture-time (deser-inventory-item-capture-time (clojure.core/get-in letvar2060064 ["CaptureTime"]))) (letvar2060064 "Entries") (clojure.core/assoc :entries (deser-inventory-item-entry-list (clojure.core/get-in letvar2060064 ["Entries"]))) (letvar2060064 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060064 ["NextToken"])))))))

(clojure.core/defn- response-delete-document-result ([input] (response-delete-document-result nil input)) ([resultWrapper2060066 input] (clojure.core/let [rawinput2060065 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060067 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-target-not-connected ([input] (response-target-not-connected nil input)) ([resultWrapper2060069 input] (clojure.core/let [rawinput2060068 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060070 {"Message" (rawinput2060068 "Message")}] (clojure.core/cond-> {} (letvar2060070 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060070 ["Message"])))))))

(clojure.core/defn- response-parameter-not-found ([input] (response-parameter-not-found nil input)) ([resultWrapper2060072 input] (clojure.core/let [rawinput2060071 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060073 {"message" (rawinput2060071 "message")}] (clojure.core/cond-> {} (letvar2060073 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060073 ["message"])))))))

(clojure.core/defn- response-list-compliance-items-result ([input] (response-list-compliance-items-result nil input)) ([resultWrapper2060075 input] (clojure.core/let [rawinput2060074 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060076 {"ComplianceItems" (rawinput2060074 "ComplianceItems"), "NextToken" (rawinput2060074 "NextToken")}] (clojure.core/cond-> {} (letvar2060076 "ComplianceItems") (clojure.core/assoc :compliance-items (deser-compliance-item-list (clojure.core/get-in letvar2060076 ["ComplianceItems"]))) (letvar2060076 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060076 ["NextToken"])))))))

(clojure.core/defn- response-document-limit-exceeded ([input] (response-document-limit-exceeded nil input)) ([resultWrapper2060078 input] (clojure.core/let [rawinput2060077 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060079 {"Message" (rawinput2060077 "Message")}] (clojure.core/cond-> {} (letvar2060079 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060079 ["Message"])))))))

(clojure.core/defn- response-get-maintenance-window-execution-result ([input] (response-get-maintenance-window-execution-result nil input)) ([resultWrapper2060081 input] (clojure.core/let [rawinput2060080 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060082 {"WindowExecutionId" (rawinput2060080 "WindowExecutionId"), "TaskIds" (rawinput2060080 "TaskIds"), "Status" (rawinput2060080 "Status"), "StatusDetails" (rawinput2060080 "StatusDetails"), "StartTime" (rawinput2060080 "StartTime"), "EndTime" (rawinput2060080 "EndTime")}] (clojure.core/cond-> {} (letvar2060082 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2060082 ["WindowExecutionId"]))) (letvar2060082 "TaskIds") (clojure.core/assoc :task-ids (deser-maintenance-window-execution-task-id-list (clojure.core/get-in letvar2060082 ["TaskIds"]))) (letvar2060082 "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (clojure.core/get-in letvar2060082 ["Status"]))) (letvar2060082 "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (clojure.core/get-in letvar2060082 ["StatusDetails"]))) (letvar2060082 "StartTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar2060082 ["StartTime"]))) (letvar2060082 "EndTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar2060082 ["EndTime"])))))))

(clojure.core/defn- response-invalid-filter-option ([input] (response-invalid-filter-option nil input)) ([resultWrapper2060084 input] (clojure.core/let [rawinput2060083 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060085 {"message" (rawinput2060083 "message")}] (clojure.core/cond-> {} (letvar2060085 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060085 ["message"])))))))

(clojure.core/defn- response-terminate-session-response ([input] (response-terminate-session-response nil input)) ([resultWrapper2060087 input] (clojure.core/let [rawinput2060086 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060088 {"SessionId" (rawinput2060086 "SessionId")}] (clojure.core/cond-> {} (letvar2060088 "SessionId") (clojure.core/assoc :session-id (deser-session-id (clojure.core/get-in letvar2060088 ["SessionId"])))))))

(clojure.core/defn- response-duplicate-instance-id ([input] (response-duplicate-instance-id nil input)) ([resultWrapper2060090 input] (clojure.core/let [rawinput2060089 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060091 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-maintenance-window-task-result ([input] (response-get-maintenance-window-task-result nil input)) ([resultWrapper2060093 input] (clojure.core/let [rawinput2060092 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060094 {"ServiceRoleArn" (rawinput2060092 "ServiceRoleArn"), "WindowId" (rawinput2060092 "WindowId"), "Priority" (rawinput2060092 "Priority"), "MaxConcurrency" (rawinput2060092 "MaxConcurrency"), "LoggingInfo" (rawinput2060092 "LoggingInfo"), "TaskArn" (rawinput2060092 "TaskArn"), "MaxErrors" (rawinput2060092 "MaxErrors"), "Description" (rawinput2060092 "Description"), "Targets" (rawinput2060092 "Targets"), "TaskType" (rawinput2060092 "TaskType"), "WindowTaskId" (rawinput2060092 "WindowTaskId"), "TaskParameters" (rawinput2060092 "TaskParameters"), "Name" (rawinput2060092 "Name"), "TaskInvocationParameters" (rawinput2060092 "TaskInvocationParameters")}] (clojure.core/cond-> {} (letvar2060094 "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (clojure.core/get-in letvar2060094 ["ServiceRoleArn"]))) (letvar2060094 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060094 ["WindowId"]))) (letvar2060094 "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (clojure.core/get-in letvar2060094 ["Priority"]))) (letvar2060094 "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (clojure.core/get-in letvar2060094 ["MaxConcurrency"]))) (letvar2060094 "LoggingInfo") (clojure.core/assoc :logging-info (deser-logging-info (clojure.core/get-in letvar2060094 ["LoggingInfo"]))) (letvar2060094 "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (clojure.core/get-in letvar2060094 ["TaskArn"]))) (letvar2060094 "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (clojure.core/get-in letvar2060094 ["MaxErrors"]))) (letvar2060094 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2060094 ["Description"]))) (letvar2060094 "Targets") (clojure.core/assoc :targets (deser-targets (clojure.core/get-in letvar2060094 ["Targets"]))) (letvar2060094 "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (clojure.core/get-in letvar2060094 ["TaskType"]))) (letvar2060094 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2060094 ["WindowTaskId"]))) (letvar2060094 "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters (clojure.core/get-in letvar2060094 ["TaskParameters"]))) (letvar2060094 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2060094 ["Name"]))) (letvar2060094 "TaskInvocationParameters") (clojure.core/assoc :task-invocation-parameters (deser-maintenance-window-task-invocation-parameters (clojure.core/get-in letvar2060094 ["TaskInvocationParameters"])))))))

(clojure.core/defn- response-invalid-resource-id ([input] (response-invalid-resource-id nil input)) ([resultWrapper2060096 input] (clojure.core/let [rawinput2060095 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060097 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-too-many-updates ([input] (response-too-many-updates nil input)) ([resultWrapper2060099 input] (clojure.core/let [rawinput2060098 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060100 {"Message" (rawinput2060098 "Message")}] (clojure.core/cond-> {} (letvar2060100 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060100 ["Message"])))))))

(clojure.core/defn- response-invalid-type-name-exception ([input] (response-invalid-type-name-exception nil input)) ([resultWrapper2060102 input] (clojure.core/let [rawinput2060101 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060103 {"Message" (rawinput2060101 "Message")}] (clojure.core/cond-> {} (letvar2060103 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060103 ["Message"])))))))

(clojure.core/defn- response-unsupported-parameter-type ([input] (response-unsupported-parameter-type nil input)) ([resultWrapper2060105 input] (clojure.core/let [rawinput2060104 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060106 {"message" (rawinput2060104 "message")}] (clojure.core/cond-> {} (letvar2060106 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060106 ["message"])))))))

(clojure.core/defn- response-put-compliance-items-result ([input] (response-put-compliance-items-result nil input)) ([resultWrapper2060108 input] (clojure.core/let [rawinput2060107 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060109 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-patch-baseline-result ([input] (response-delete-patch-baseline-result nil input)) ([resultWrapper2060111 input] (clojure.core/let [rawinput2060110 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060112 {"BaselineId" (rawinput2060110 "BaselineId")}] (clojure.core/cond-> {} (letvar2060112 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060112 ["BaselineId"])))))))

(clojure.core/defn- response-item-content-mismatch-exception ([input] (response-item-content-mismatch-exception nil input)) ([resultWrapper2060114 input] (clojure.core/let [rawinput2060113 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060115 {"TypeName" (rawinput2060113 "TypeName"), "Message" (rawinput2060113 "Message")}] (clojure.core/cond-> {} (letvar2060115 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2060115 ["TypeName"]))) (letvar2060115 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060115 ["Message"])))))))

(clojure.core/defn- response-document-permission-limit ([input] (response-document-permission-limit nil input)) ([resultWrapper2060117 input] (clojure.core/let [rawinput2060116 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060118 {"Message" (rawinput2060116 "Message")}] (clojure.core/cond-> {} (letvar2060118 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060118 ["Message"])))))))

(clojure.core/defn- response-hierarchy-level-limit-exceeded-exception ([input] (response-hierarchy-level-limit-exceeded-exception nil input)) ([resultWrapper2060120 input] (clojure.core/let [rawinput2060119 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060121 {"message" (rawinput2060119 "message")}] (clojure.core/cond-> {} (letvar2060121 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060121 ["message"])))))))

(clojure.core/defn- response-delete-association-result ([input] (response-delete-association-result nil input)) ([resultWrapper2060123 input] (clojure.core/let [rawinput2060122 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060124 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-maintenance-windows-for-target-result ([input] (response-describe-maintenance-windows-for-target-result nil input)) ([resultWrapper2060126 input] (clojure.core/let [rawinput2060125 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060127 {"WindowIdentities" (rawinput2060125 "WindowIdentities"), "NextToken" (rawinput2060125 "NextToken")}] (clojure.core/cond-> {} (letvar2060127 "WindowIdentities") (clojure.core/assoc :window-identities (deser-maintenance-windows-for-target-list (clojure.core/get-in letvar2060127 ["WindowIdentities"]))) (letvar2060127 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060127 ["NextToken"])))))))

(clojure.core/defn- response-unsupported-inventory-item-context-exception ([input] (response-unsupported-inventory-item-context-exception nil input)) ([resultWrapper2060129 input] (clojure.core/let [rawinput2060128 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060130 {"TypeName" (rawinput2060128 "TypeName"), "Message" (rawinput2060128 "Message")}] (clojure.core/cond-> {} (letvar2060130 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2060130 ["TypeName"]))) (letvar2060130 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060130 ["Message"])))))))

(clojure.core/defn- response-cancel-maintenance-window-execution-result ([input] (response-cancel-maintenance-window-execution-result nil input)) ([resultWrapper2060132 input] (clojure.core/let [rawinput2060131 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060133 {"WindowExecutionId" (rawinput2060131 "WindowExecutionId")}] (clojure.core/cond-> {} (letvar2060133 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2060133 ["WindowExecutionId"])))))))

(clojure.core/defn- response-create-association-batch-result ([input] (response-create-association-batch-result nil input)) ([resultWrapper2060135 input] (clojure.core/let [rawinput2060134 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060136 {"Successful" (rawinput2060134 "Successful"), "Failed" (rawinput2060134 "Failed")}] (clojure.core/cond-> {} (letvar2060136 "Successful") (clojure.core/assoc :successful (deser-association-description-list (clojure.core/get-in letvar2060136 ["Successful"]))) (letvar2060136 "Failed") (clojure.core/assoc :failed (deser-failed-create-association-list (clojure.core/get-in letvar2060136 ["Failed"])))))))

(clojure.core/defn- response-get-parameters-result ([input] (response-get-parameters-result nil input)) ([resultWrapper2060138 input] (clojure.core/let [rawinput2060137 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060139 {"Parameters" (rawinput2060137 "Parameters"), "InvalidParameters" (rawinput2060137 "InvalidParameters")}] (clojure.core/cond-> {} (letvar2060139 "Parameters") (clojure.core/assoc :parameters (deser-parameter-list (clojure.core/get-in letvar2060139 ["Parameters"]))) (letvar2060139 "InvalidParameters") (clojure.core/assoc :invalid-parameters (deser-parameter-name-list (clojure.core/get-in letvar2060139 ["InvalidParameters"])))))))

(clojure.core/defn- response-invalid-filter ([input] (response-invalid-filter nil input)) ([resultWrapper2060141 input] (clojure.core/let [rawinput2060140 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060142 {"Message" (rawinput2060140 "Message")}] (clojure.core/cond-> {} (letvar2060142 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060142 ["Message"])))))))

(clojure.core/defn- response-get-maintenance-window-result ([input] (response-get-maintenance-window-result nil input)) ([resultWrapper2060144 input] (clojure.core/let [rawinput2060143 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060145 {"WindowId" (rawinput2060143 "WindowId"), "AllowUnassociatedTargets" (rawinput2060143 "AllowUnassociatedTargets"), "EndDate" (rawinput2060143 "EndDate"), "Enabled" (rawinput2060143 "Enabled"), "NextExecutionTime" (rawinput2060143 "NextExecutionTime"), "Description" (rawinput2060143 "Description"), "Duration" (rawinput2060143 "Duration"), "CreatedDate" (rawinput2060143 "CreatedDate"), "Cutoff" (rawinput2060143 "Cutoff"), "ModifiedDate" (rawinput2060143 "ModifiedDate"), "Schedule" (rawinput2060143 "Schedule"), "Name" (rawinput2060143 "Name"), "StartDate" (rawinput2060143 "StartDate"), "ScheduleTimezone" (rawinput2060143 "ScheduleTimezone")}] (clojure.core/cond-> {} (letvar2060145 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060145 ["WindowId"]))) (letvar2060145 "AllowUnassociatedTargets") (clojure.core/assoc :allow-unassociated-targets (deser-maintenance-window-allow-unassociated-targets (clojure.core/get-in letvar2060145 ["AllowUnassociatedTargets"]))) (letvar2060145 "EndDate") (clojure.core/assoc :end-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2060145 ["EndDate"]))) (letvar2060145 "Enabled") (clojure.core/assoc :enabled (deser-maintenance-window-enabled (clojure.core/get-in letvar2060145 ["Enabled"]))) (letvar2060145 "NextExecutionTime") (clojure.core/assoc :next-execution-time (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2060145 ["NextExecutionTime"]))) (letvar2060145 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2060145 ["Description"]))) (letvar2060145 "Duration") (clojure.core/assoc :duration (deser-maintenance-window-duration-hours (clojure.core/get-in letvar2060145 ["Duration"]))) (letvar2060145 "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (clojure.core/get-in letvar2060145 ["CreatedDate"]))) (letvar2060145 "Cutoff") (clojure.core/assoc :cutoff (deser-maintenance-window-cutoff (clojure.core/get-in letvar2060145 ["Cutoff"]))) (letvar2060145 "ModifiedDate") (clojure.core/assoc :modified-date (deser-date-time (clojure.core/get-in letvar2060145 ["ModifiedDate"]))) (letvar2060145 "Schedule") (clojure.core/assoc :schedule (deser-maintenance-window-schedule (clojure.core/get-in letvar2060145 ["Schedule"]))) (letvar2060145 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2060145 ["Name"]))) (letvar2060145 "StartDate") (clojure.core/assoc :start-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2060145 ["StartDate"]))) (letvar2060145 "ScheduleTimezone") (clojure.core/assoc :schedule-timezone (deser-maintenance-window-timezone (clojure.core/get-in letvar2060145 ["ScheduleTimezone"])))))))

(clojure.core/defn- response-total-size-limit-exceeded-exception ([input] (response-total-size-limit-exceeded-exception nil input)) ([resultWrapper2060147 input] (clojure.core/let [rawinput2060146 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060148 {"Message" (rawinput2060146 "Message")}] (clojure.core/cond-> {} (letvar2060148 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060148 ["Message"])))))))

(clojure.core/defn- response-target-in-use-exception ([input] (response-target-in-use-exception nil input)) ([resultWrapper2060150 input] (clojure.core/let [rawinput2060149 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060151 {"Message" (rawinput2060149 "Message")}] (clojure.core/cond-> {} (letvar2060151 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060151 ["Message"])))))))

(clojure.core/defn- response-resource-in-use-exception ([input] (response-resource-in-use-exception nil input)) ([resultWrapper2060153 input] (clojure.core/let [rawinput2060152 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060154 {"Message" (rawinput2060152 "Message")}] (clojure.core/cond-> {} (letvar2060154 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060154 ["Message"])))))))

(clojure.core/defn- response-reset-service-setting-result ([input] (response-reset-service-setting-result nil input)) ([resultWrapper2060156 input] (clojure.core/let [rawinput2060155 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060157 {"ServiceSetting" (rawinput2060155 "ServiceSetting")}] (clojure.core/cond-> {} (letvar2060157 "ServiceSetting") (clojure.core/assoc :service-setting (deser-service-setting (clojure.core/get-in letvar2060157 ["ServiceSetting"])))))))

(clojure.core/defn- response-invalid-deletion-id-exception ([input] (response-invalid-deletion-id-exception nil input)) ([resultWrapper2060159 input] (clojure.core/let [rawinput2060158 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060160 {"Message" (rawinput2060158 "Message")}] (clojure.core/cond-> {} (letvar2060160 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060160 ["Message"])))))))

(clojure.core/defn- response-describe-association-result ([input] (response-describe-association-result nil input)) ([resultWrapper2060162 input] (clojure.core/let [rawinput2060161 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060163 {"AssociationDescription" (rawinput2060161 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2060163 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2060163 ["AssociationDescription"])))))))

(clojure.core/defn- response-describe-maintenance-window-executions-result ([input] (response-describe-maintenance-window-executions-result nil input)) ([resultWrapper2060165 input] (clojure.core/let [rawinput2060164 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060166 {"WindowExecutions" (rawinput2060164 "WindowExecutions"), "NextToken" (rawinput2060164 "NextToken")}] (clojure.core/cond-> {} (letvar2060166 "WindowExecutions") (clojure.core/assoc :window-executions (deser-maintenance-window-execution-list (clojure.core/get-in letvar2060166 ["WindowExecutions"]))) (letvar2060166 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060166 ["NextToken"])))))))

(clojure.core/defn- response-register-patch-baseline-for-patch-group-result ([input] (response-register-patch-baseline-for-patch-group-result nil input)) ([resultWrapper2060168 input] (clojure.core/let [rawinput2060167 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060169 {"BaselineId" (rawinput2060167 "BaselineId"), "PatchGroup" (rawinput2060167 "PatchGroup")}] (clojure.core/cond-> {} (letvar2060169 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060169 ["BaselineId"]))) (letvar2060169 "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (clojure.core/get-in letvar2060169 ["PatchGroup"])))))))

(clojure.core/defn- response-idempotent-parameter-mismatch ([input] (response-idempotent-parameter-mismatch nil input)) ([resultWrapper2060171 input] (clojure.core/let [rawinput2060170 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060172 {"Message" (rawinput2060170 "Message")}] (clojure.core/cond-> {} (letvar2060172 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060172 ["Message"])))))))

(clojure.core/defn- response-invalid-resource-type ([input] (response-invalid-resource-type nil input)) ([resultWrapper2060174 input] (clojure.core/let [rawinput2060173 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060175 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-automation-execution-result ([input] (response-start-automation-execution-result nil input)) ([resultWrapper2060177 input] (clojure.core/let [rawinput2060176 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060178 {"AutomationExecutionId" (rawinput2060176 "AutomationExecutionId")}] (clojure.core/cond-> {} (letvar2060178 "AutomationExecutionId") (clojure.core/assoc :automation-execution-id (deser-automation-execution-id (clojure.core/get-in letvar2060178 ["AutomationExecutionId"])))))))

(clojure.core/defn- response-describe-instance-associations-status-result ([input] (response-describe-instance-associations-status-result nil input)) ([resultWrapper2060180 input] (clojure.core/let [rawinput2060179 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060181 {"InstanceAssociationStatusInfos" (rawinput2060179 "InstanceAssociationStatusInfos"), "NextToken" (rawinput2060179 "NextToken")}] (clojure.core/cond-> {} (letvar2060181 "InstanceAssociationStatusInfos") (clojure.core/assoc :instance-association-status-infos (deser-instance-association-status-infos (clojure.core/get-in letvar2060181 ["InstanceAssociationStatusInfos"]))) (letvar2060181 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060181 ["NextToken"])))))))

(clojure.core/defn- response-create-resource-data-sync-result ([input] (response-create-resource-data-sync-result nil input)) ([resultWrapper2060183 input] (clojure.core/let [rawinput2060182 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060184 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-association-already-exists ([input] (response-association-already-exists nil input)) ([resultWrapper2060186 input] (clojure.core/let [rawinput2060185 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060187 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-associations-once-result ([input] (response-start-associations-once-result nil input)) ([resultWrapper2060189 input] (clojure.core/let [rawinput2060188 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060190 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-maintenance-window-task-result ([input] (response-update-maintenance-window-task-result nil input)) ([resultWrapper2060192 input] (clojure.core/let [rawinput2060191 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060193 {"ServiceRoleArn" (rawinput2060191 "ServiceRoleArn"), "WindowId" (rawinput2060191 "WindowId"), "Priority" (rawinput2060191 "Priority"), "MaxConcurrency" (rawinput2060191 "MaxConcurrency"), "LoggingInfo" (rawinput2060191 "LoggingInfo"), "TaskArn" (rawinput2060191 "TaskArn"), "MaxErrors" (rawinput2060191 "MaxErrors"), "Description" (rawinput2060191 "Description"), "Targets" (rawinput2060191 "Targets"), "WindowTaskId" (rawinput2060191 "WindowTaskId"), "TaskParameters" (rawinput2060191 "TaskParameters"), "Name" (rawinput2060191 "Name"), "TaskInvocationParameters" (rawinput2060191 "TaskInvocationParameters")}] (clojure.core/cond-> {} (letvar2060193 "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (clojure.core/get-in letvar2060193 ["ServiceRoleArn"]))) (letvar2060193 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060193 ["WindowId"]))) (letvar2060193 "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (clojure.core/get-in letvar2060193 ["Priority"]))) (letvar2060193 "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (clojure.core/get-in letvar2060193 ["MaxConcurrency"]))) (letvar2060193 "LoggingInfo") (clojure.core/assoc :logging-info (deser-logging-info (clojure.core/get-in letvar2060193 ["LoggingInfo"]))) (letvar2060193 "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (clojure.core/get-in letvar2060193 ["TaskArn"]))) (letvar2060193 "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (clojure.core/get-in letvar2060193 ["MaxErrors"]))) (letvar2060193 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2060193 ["Description"]))) (letvar2060193 "Targets") (clojure.core/assoc :targets (deser-targets (clojure.core/get-in letvar2060193 ["Targets"]))) (letvar2060193 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2060193 ["WindowTaskId"]))) (letvar2060193 "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters (clojure.core/get-in letvar2060193 ["TaskParameters"]))) (letvar2060193 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2060193 ["Name"]))) (letvar2060193 "TaskInvocationParameters") (clojure.core/assoc :task-invocation-parameters (deser-maintenance-window-task-invocation-parameters (clojure.core/get-in letvar2060193 ["TaskInvocationParameters"])))))))

(clojure.core/defn- response-describe-instance-patch-states-for-patch-group-result ([input] (response-describe-instance-patch-states-for-patch-group-result nil input)) ([resultWrapper2060195 input] (clojure.core/let [rawinput2060194 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060196 {"InstancePatchStates" (rawinput2060194 "InstancePatchStates"), "NextToken" (rawinput2060194 "NextToken")}] (clojure.core/cond-> {} (letvar2060196 "InstancePatchStates") (clojure.core/assoc :instance-patch-states (deser-instance-patch-states-list (clojure.core/get-in letvar2060196 ["InstancePatchStates"]))) (letvar2060196 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060196 ["NextToken"])))))))

(clojure.core/defn- response-parameter-already-exists ([input] (response-parameter-already-exists nil input)) ([resultWrapper2060198 input] (clojure.core/let [rawinput2060197 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060199 {"message" (rawinput2060197 "message")}] (clojure.core/cond-> {} (letvar2060199 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060199 ["message"])))))))

(clojure.core/defn- response-list-compliance-summaries-result ([input] (response-list-compliance-summaries-result nil input)) ([resultWrapper2060201 input] (clojure.core/let [rawinput2060200 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060202 {"ComplianceSummaryItems" (rawinput2060200 "ComplianceSummaryItems"), "NextToken" (rawinput2060200 "NextToken")}] (clojure.core/cond-> {} (letvar2060202 "ComplianceSummaryItems") (clojure.core/assoc :compliance-summary-items (deser-compliance-summary-item-list (clojure.core/get-in letvar2060202 ["ComplianceSummaryItems"]))) (letvar2060202 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060202 ["NextToken"])))))))

(clojure.core/defn- response-invalid-instance-information-filter-value ([input] (response-invalid-instance-information-filter-value nil input)) ([resultWrapper2060204 input] (clojure.core/let [rawinput2060203 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060205 {"message" (rawinput2060203 "message")}] (clojure.core/cond-> {} (letvar2060205 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060205 ["message"])))))))

(clojure.core/defn- response-update-document-default-version-result ([input] (response-update-document-default-version-result nil input)) ([resultWrapper2060207 input] (clojure.core/let [rawinput2060206 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060208 {"Description" (rawinput2060206 "Description")}] (clojure.core/cond-> {} (letvar2060208 "Description") (clojure.core/assoc :description (deser-document-default-version-description (clojure.core/get-in letvar2060208 ["Description"])))))))

(clojure.core/defn- response-register-target-with-maintenance-window-result ([input] (response-register-target-with-maintenance-window-result nil input)) ([resultWrapper2060210 input] (clojure.core/let [rawinput2060209 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060211 {"WindowTargetId" (rawinput2060209 "WindowTargetId")}] (clojure.core/cond-> {} (letvar2060211 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (clojure.core/get-in letvar2060211 ["WindowTargetId"])))))))

(clojure.core/defn- response-does-not-exist-exception ([input] (response-does-not-exist-exception nil input)) ([resultWrapper2060213 input] (clojure.core/let [rawinput2060212 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060214 {"Message" (rawinput2060212 "Message")}] (clojure.core/cond-> {} (letvar2060214 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060214 ["Message"])))))))

(clojure.core/defn- response-parameter-limit-exceeded ([input] (response-parameter-limit-exceeded nil input)) ([resultWrapper2060216 input] (clojure.core/let [rawinput2060215 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060217 {"message" (rawinput2060215 "message")}] (clojure.core/cond-> {} (letvar2060217 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060217 ["message"])))))))

(clojure.core/defn- response-unsupported-platform-type ([input] (response-unsupported-platform-type nil input)) ([resultWrapper2060219 input] (clojure.core/let [rawinput2060218 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060220 {"Message" (rawinput2060218 "Message")}] (clojure.core/cond-> {} (letvar2060220 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060220 ["Message"])))))))

(clojure.core/defn- response-describe-instance-patches-result ([input] (response-describe-instance-patches-result nil input)) ([resultWrapper2060222 input] (clojure.core/let [rawinput2060221 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060223 {"Patches" (rawinput2060221 "Patches"), "NextToken" (rawinput2060221 "NextToken")}] (clojure.core/cond-> {} (letvar2060223 "Patches") (clojure.core/assoc :patches (deser-patch-compliance-data-list (clojure.core/get-in letvar2060223 ["Patches"]))) (letvar2060223 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060223 ["NextToken"])))))))

(clojure.core/defn- response-status-unchanged ([input] (response-status-unchanged nil input)) ([resultWrapper2060225 input] (clojure.core/let [rawinput2060224 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060226 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-command-id ([input] (response-invalid-command-id nil input)) ([resultWrapper2060228 input] (clojure.core/let [rawinput2060227 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060229 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cancel-command-result ([input] (response-cancel-command-result nil input)) ([resultWrapper2060231 input] (clojure.core/let [rawinput2060230 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060232 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-maintenance-window-result ([input] (response-create-maintenance-window-result nil input)) ([resultWrapper2060234 input] (clojure.core/let [rawinput2060233 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060235 {"WindowId" (rawinput2060233 "WindowId")}] (clojure.core/cond-> {} (letvar2060235 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060235 ["WindowId"])))))))

(clojure.core/defn- response-automation-execution-not-found-exception ([input] (response-automation-execution-not-found-exception nil input)) ([resultWrapper2060237 input] (clojure.core/let [rawinput2060236 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060238 {"Message" (rawinput2060236 "Message")}] (clojure.core/cond-> {} (letvar2060238 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060238 ["Message"])))))))

(clojure.core/defn- response-invalid-document ([input] (response-invalid-document nil input)) ([resultWrapper2060240 input] (clojure.core/let [rawinput2060239 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060241 {"Message" (rawinput2060239 "Message")}] (clojure.core/cond-> {} (letvar2060241 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060241 ["Message"])))))))

(clojure.core/defn- response-update-association-status-result ([input] (response-update-association-status-result nil input)) ([resultWrapper2060243 input] (clojure.core/let [rawinput2060242 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060244 {"AssociationDescription" (rawinput2060242 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2060244 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2060244 ["AssociationDescription"])))))))

(clojure.core/defn- response-parameter-pattern-mismatch-exception ([input] (response-parameter-pattern-mismatch-exception nil input)) ([resultWrapper2060246 input] (clojure.core/let [rawinput2060245 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060247 {"message" (rawinput2060245 "message")}] (clojure.core/cond-> {} (letvar2060247 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060247 ["message"])))))))

(clojure.core/defn- response-invalid-result-attribute-exception ([input] (response-invalid-result-attribute-exception nil input)) ([resultWrapper2060249 input] (clojure.core/let [rawinput2060248 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060250 {"Message" (rawinput2060248 "Message")}] (clojure.core/cond-> {} (letvar2060250 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060250 ["Message"])))))))

(clojure.core/defn- response-describe-patch-group-state-result ([input] (response-describe-patch-group-state-result nil input)) ([resultWrapper2060252 input] (clojure.core/let [rawinput2060251 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060253 {"Instances" (rawinput2060251 "Instances"), "InstancesWithInstalledPatches" (rawinput2060251 "InstancesWithInstalledPatches"), "InstancesWithInstalledOtherPatches" (rawinput2060251 "InstancesWithInstalledOtherPatches"), "InstancesWithInstalledRejectedPatches" (rawinput2060251 "InstancesWithInstalledRejectedPatches"), "InstancesWithMissingPatches" (rawinput2060251 "InstancesWithMissingPatches"), "InstancesWithFailedPatches" (rawinput2060251 "InstancesWithFailedPatches"), "InstancesWithNotApplicablePatches" (rawinput2060251 "InstancesWithNotApplicablePatches")}] (clojure.core/cond-> {} (letvar2060253 "Instances") (clojure.core/assoc :instances (deser-integer (clojure.core/get-in letvar2060253 ["Instances"]))) (letvar2060253 "InstancesWithInstalledPatches") (clojure.core/assoc :instances-with-installed-patches (deser-integer (clojure.core/get-in letvar2060253 ["InstancesWithInstalledPatches"]))) (letvar2060253 "InstancesWithInstalledOtherPatches") (clojure.core/assoc :instances-with-installed-other-patches (deser-integer (clojure.core/get-in letvar2060253 ["InstancesWithInstalledOtherPatches"]))) (letvar2060253 "InstancesWithInstalledRejectedPatches") (clojure.core/assoc :instances-with-installed-rejected-patches (deser-instances-count (clojure.core/get-in letvar2060253 ["InstancesWithInstalledRejectedPatches"]))) (letvar2060253 "InstancesWithMissingPatches") (clojure.core/assoc :instances-with-missing-patches (deser-integer (clojure.core/get-in letvar2060253 ["InstancesWithMissingPatches"]))) (letvar2060253 "InstancesWithFailedPatches") (clojure.core/assoc :instances-with-failed-patches (deser-integer (clojure.core/get-in letvar2060253 ["InstancesWithFailedPatches"]))) (letvar2060253 "InstancesWithNotApplicablePatches") (clojure.core/assoc :instances-with-not-applicable-patches (deser-integer (clojure.core/get-in letvar2060253 ["InstancesWithNotApplicablePatches"])))))))

(clojure.core/defn- response-list-commands-result ([input] (response-list-commands-result nil input)) ([resultWrapper2060255 input] (clojure.core/let [rawinput2060254 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060256 {"Commands" (rawinput2060254 "Commands"), "NextToken" (rawinput2060254 "NextToken")}] (clojure.core/cond-> {} (letvar2060256 "Commands") (clojure.core/assoc :commands (deser-command-list (clojure.core/get-in letvar2060256 ["Commands"]))) (letvar2060256 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060256 ["NextToken"])))))))

(clojure.core/defn- response-create-patch-baseline-result ([input] (response-create-patch-baseline-result nil input)) ([resultWrapper2060258 input] (clojure.core/let [rawinput2060257 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060259 {"BaselineId" (rawinput2060257 "BaselineId")}] (clojure.core/cond-> {} (letvar2060259 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060259 ["BaselineId"])))))))

(clojure.core/defn- response-list-associations-result ([input] (response-list-associations-result nil input)) ([resultWrapper2060261 input] (clojure.core/let [rawinput2060260 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060262 {"Associations" (rawinput2060260 "Associations"), "NextToken" (rawinput2060260 "NextToken")}] (clojure.core/cond-> {} (letvar2060262 "Associations") (clojure.core/assoc :associations (deser-association-list (clojure.core/get-in letvar2060262 ["Associations"]))) (letvar2060262 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060262 ["NextToken"])))))))

(clojure.core/defn- response-get-automation-execution-result ([input] (response-get-automation-execution-result nil input)) ([resultWrapper2060264 input] (clojure.core/let [rawinput2060263 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060265 {"AutomationExecution" (rawinput2060263 "AutomationExecution")}] (clojure.core/cond-> {} (letvar2060265 "AutomationExecution") (clojure.core/assoc :automation-execution (deser-automation-execution (clojure.core/get-in letvar2060265 ["AutomationExecution"])))))))

(clojure.core/defn- response-get-parameters-by-path-result ([input] (response-get-parameters-by-path-result nil input)) ([resultWrapper2060267 input] (clojure.core/let [rawinput2060266 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060268 {"Parameters" (rawinput2060266 "Parameters"), "NextToken" (rawinput2060266 "NextToken")}] (clojure.core/cond-> {} (letvar2060268 "Parameters") (clojure.core/assoc :parameters (deser-parameter-list (clojure.core/get-in letvar2060268 ["Parameters"]))) (letvar2060268 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060268 ["NextToken"])))))))

(clojure.core/defn- response-delete-resource-data-sync-result ([input] (response-delete-resource-data-sync-result nil input)) ([resultWrapper2060270 input] (clojure.core/let [rawinput2060269 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060271 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-association-executions-result ([input] (response-describe-association-executions-result nil input)) ([resultWrapper2060273 input] (clojure.core/let [rawinput2060272 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060274 {"AssociationExecutions" (rawinput2060272 "AssociationExecutions"), "NextToken" (rawinput2060272 "NextToken")}] (clojure.core/cond-> {} (letvar2060274 "AssociationExecutions") (clojure.core/assoc :association-executions (deser-association-executions-list (clojure.core/get-in letvar2060274 ["AssociationExecutions"]))) (letvar2060274 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060274 ["NextToken"])))))))

(clojure.core/defn- response-association-does-not-exist ([input] (response-association-does-not-exist nil input)) ([resultWrapper2060276 input] (clojure.core/let [rawinput2060275 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060277 {"Message" (rawinput2060275 "Message")}] (clojure.core/cond-> {} (letvar2060277 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060277 ["Message"])))))))

(clojure.core/defn- response-send-automation-signal-result ([input] (response-send-automation-signal-result nil input)) ([resultWrapper2060279 input] (clojure.core/let [rawinput2060278 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060280 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-document-version ([input] (response-invalid-document-version nil input)) ([resultWrapper2060282 input] (clojure.core/let [rawinput2060281 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060283 {"Message" (rawinput2060281 "Message")}] (clojure.core/cond-> {} (letvar2060283 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060283 ["Message"])))))))

(clojure.core/defn- response-invalid-plugin-name ([input] (response-invalid-plugin-name nil input)) ([resultWrapper2060285 input] (clojure.core/let [rawinput2060284 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060286 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-document-result ([input] (response-create-document-result nil input)) ([resultWrapper2060288 input] (clojure.core/let [rawinput2060287 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060289 {"DocumentDescription" (rawinput2060287 "DocumentDescription")}] (clojure.core/cond-> {} (letvar2060289 "DocumentDescription") (clojure.core/assoc :document-description (deser-document-description (clojure.core/get-in letvar2060289 ["DocumentDescription"])))))))

(clojure.core/defn- response-custom-schema-count-limit-exceeded-exception ([input] (response-custom-schema-count-limit-exceeded-exception nil input)) ([resultWrapper2060291 input] (clojure.core/let [rawinput2060290 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060292 {"Message" (rawinput2060290 "Message")}] (clojure.core/cond-> {} (letvar2060292 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060292 ["Message"])))))))

(clojure.core/defn- response-invalid-document-operation ([input] (response-invalid-document-operation nil input)) ([resultWrapper2060294 input] (clojure.core/let [rawinput2060293 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060295 {"Message" (rawinput2060293 "Message")}] (clojure.core/cond-> {} (letvar2060295 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060295 ["Message"])))))))

(clojure.core/defn- response-duplicate-document-content ([input] (response-duplicate-document-content nil input)) ([resultWrapper2060297 input] (clojure.core/let [rawinput2060296 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060298 {"Message" (rawinput2060296 "Message")}] (clojure.core/cond-> {} (letvar2060298 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060298 ["Message"])))))))

(clojure.core/defn- response-delete-activation-result ([input] (response-delete-activation-result nil input)) ([resultWrapper2060300 input] (clojure.core/let [rawinput2060299 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060301 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-inventory-schema-result ([input] (response-get-inventory-schema-result nil input)) ([resultWrapper2060303 input] (clojure.core/let [rawinput2060302 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060304 {"Schemas" (rawinput2060302 "Schemas"), "NextToken" (rawinput2060302 "NextToken")}] (clojure.core/cond-> {} (letvar2060304 "Schemas") (clojure.core/assoc :schemas (deser-inventory-item-schema-result-list (clojure.core/get-in letvar2060304 ["Schemas"]))) (letvar2060304 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060304 ["NextToken"])))))))

(clojure.core/defn- response-put-inventory-result ([input] (response-put-inventory-result nil input)) ([resultWrapper2060306 input] (clojure.core/let [rawinput2060305 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060307 {"Message" (rawinput2060305 "Message")}] (clojure.core/cond-> {} (letvar2060307 "Message") (clojure.core/assoc :message (deser-put-inventory-message (clojure.core/get-in letvar2060307 ["Message"])))))))

(clojure.core/defn- response-update-document-result ([input] (response-update-document-result nil input)) ([resultWrapper2060309 input] (clojure.core/let [rawinput2060308 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060310 {"DocumentDescription" (rawinput2060308 "DocumentDescription")}] (clojure.core/cond-> {} (letvar2060310 "DocumentDescription") (clojure.core/assoc :document-description (deser-document-description (clojure.core/get-in letvar2060310 ["DocumentDescription"])))))))

(clojure.core/defn- response-get-connection-status-response ([input] (response-get-connection-status-response nil input)) ([resultWrapper2060312 input] (clojure.core/let [rawinput2060311 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060313 {"Target" (rawinput2060311 "Target"), "Status" (rawinput2060311 "Status")}] (clojure.core/cond-> {} (letvar2060313 "Target") (clojure.core/assoc :target (deser-session-target (clojure.core/get-in letvar2060313 ["Target"]))) (letvar2060313 "Status") (clojure.core/assoc :status (deser-connection-status (clojure.core/get-in letvar2060313 ["Status"])))))))

(clojure.core/defn- response-describe-instance-patch-states-result ([input] (response-describe-instance-patch-states-result nil input)) ([resultWrapper2060315 input] (clojure.core/let [rawinput2060314 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060316 {"InstancePatchStates" (rawinput2060314 "InstancePatchStates"), "NextToken" (rawinput2060314 "NextToken")}] (clojure.core/cond-> {} (letvar2060316 "InstancePatchStates") (clojure.core/assoc :instance-patch-states (deser-instance-patch-state-list (clojure.core/get-in letvar2060316 ["InstancePatchStates"]))) (letvar2060316 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060316 ["NextToken"])))))))

(clojure.core/defn- response-get-patch-baseline-for-patch-group-result ([input] (response-get-patch-baseline-for-patch-group-result nil input)) ([resultWrapper2060318 input] (clojure.core/let [rawinput2060317 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060319 {"BaselineId" (rawinput2060317 "BaselineId"), "PatchGroup" (rawinput2060317 "PatchGroup"), "OperatingSystem" (rawinput2060317 "OperatingSystem")}] (clojure.core/cond-> {} (letvar2060319 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060319 ["BaselineId"]))) (letvar2060319 "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (clojure.core/get-in letvar2060319 ["PatchGroup"]))) (letvar2060319 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2060319 ["OperatingSystem"])))))))

(clojure.core/defn- response-update-maintenance-window-result ([input] (response-update-maintenance-window-result nil input)) ([resultWrapper2060321 input] (clojure.core/let [rawinput2060320 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060322 {"WindowId" (rawinput2060320 "WindowId"), "AllowUnassociatedTargets" (rawinput2060320 "AllowUnassociatedTargets"), "EndDate" (rawinput2060320 "EndDate"), "Enabled" (rawinput2060320 "Enabled"), "Description" (rawinput2060320 "Description"), "Duration" (rawinput2060320 "Duration"), "Cutoff" (rawinput2060320 "Cutoff"), "Schedule" (rawinput2060320 "Schedule"), "Name" (rawinput2060320 "Name"), "StartDate" (rawinput2060320 "StartDate"), "ScheduleTimezone" (rawinput2060320 "ScheduleTimezone")}] (clojure.core/cond-> {} (letvar2060322 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060322 ["WindowId"]))) (letvar2060322 "AllowUnassociatedTargets") (clojure.core/assoc :allow-unassociated-targets (deser-maintenance-window-allow-unassociated-targets (clojure.core/get-in letvar2060322 ["AllowUnassociatedTargets"]))) (letvar2060322 "EndDate") (clojure.core/assoc :end-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2060322 ["EndDate"]))) (letvar2060322 "Enabled") (clojure.core/assoc :enabled (deser-maintenance-window-enabled (clojure.core/get-in letvar2060322 ["Enabled"]))) (letvar2060322 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2060322 ["Description"]))) (letvar2060322 "Duration") (clojure.core/assoc :duration (deser-maintenance-window-duration-hours (clojure.core/get-in letvar2060322 ["Duration"]))) (letvar2060322 "Cutoff") (clojure.core/assoc :cutoff (deser-maintenance-window-cutoff (clojure.core/get-in letvar2060322 ["Cutoff"]))) (letvar2060322 "Schedule") (clojure.core/assoc :schedule (deser-maintenance-window-schedule (clojure.core/get-in letvar2060322 ["Schedule"]))) (letvar2060322 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2060322 ["Name"]))) (letvar2060322 "StartDate") (clojure.core/assoc :start-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2060322 ["StartDate"]))) (letvar2060322 "ScheduleTimezone") (clojure.core/assoc :schedule-timezone (deser-maintenance-window-timezone (clojure.core/get-in letvar2060322 ["ScheduleTimezone"])))))))

(clojure.core/defn- response-start-session-response ([input] (response-start-session-response nil input)) ([resultWrapper2060324 input] (clojure.core/let [rawinput2060323 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060325 {"SessionId" (rawinput2060323 "SessionId"), "TokenValue" (rawinput2060323 "TokenValue"), "StreamUrl" (rawinput2060323 "StreamUrl")}] (clojure.core/cond-> {} (letvar2060325 "SessionId") (clojure.core/assoc :session-id (deser-session-id (clojure.core/get-in letvar2060325 ["SessionId"]))) (letvar2060325 "TokenValue") (clojure.core/assoc :token-value (deser-token-value (clojure.core/get-in letvar2060325 ["TokenValue"]))) (letvar2060325 "StreamUrl") (clojure.core/assoc :stream-url (deser-stream-url (clojure.core/get-in letvar2060325 ["StreamUrl"])))))))

(clojure.core/defn- response-delete-inventory-result ([input] (response-delete-inventory-result nil input)) ([resultWrapper2060327 input] (clojure.core/let [rawinput2060326 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060328 {"DeletionId" (rawinput2060326 "DeletionId"), "TypeName" (rawinput2060326 "TypeName"), "DeletionSummary" (rawinput2060326 "DeletionSummary")}] (clojure.core/cond-> {} (letvar2060328 "DeletionId") (clojure.core/assoc :deletion-id (deser-inventory-deletion-id (clojure.core/get-in letvar2060328 ["DeletionId"]))) (letvar2060328 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2060328 ["TypeName"]))) (letvar2060328 "DeletionSummary") (clojure.core/assoc :deletion-summary (deser-inventory-deletion-summary (clojure.core/get-in letvar2060328 ["DeletionSummary"])))))))

(clojure.core/defn- response-describe-automation-executions-result ([input] (response-describe-automation-executions-result nil input)) ([resultWrapper2060330 input] (clojure.core/let [rawinput2060329 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060331 {"AutomationExecutionMetadataList" (rawinput2060329 "AutomationExecutionMetadataList"), "NextToken" (rawinput2060329 "NextToken")}] (clojure.core/cond-> {} (letvar2060331 "AutomationExecutionMetadataList") (clojure.core/assoc :automation-execution-metadata-list (deser-automation-execution-metadata-list (clojure.core/get-in letvar2060331 ["AutomationExecutionMetadataList"]))) (letvar2060331 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060331 ["NextToken"])))))))

(clojure.core/defn- response-parameter-version-label-limit-exceeded ([input] (response-parameter-version-label-limit-exceeded nil input)) ([resultWrapper2060333 input] (clojure.core/let [rawinput2060332 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060334 {"message" (rawinput2060332 "message")}] (clojure.core/cond-> {} (letvar2060334 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060334 ["message"])))))))

(clojure.core/defn- response-automation-definition-version-not-found-exception ([input] (response-automation-definition-version-not-found-exception nil input)) ([resultWrapper2060336 input] (clojure.core/let [rawinput2060335 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060337 {"Message" (rawinput2060335 "Message")}] (clojure.core/cond-> {} (letvar2060337 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060337 ["Message"])))))))

(clojure.core/defn- response-deregister-target-from-maintenance-window-result ([input] (response-deregister-target-from-maintenance-window-result nil input)) ([resultWrapper2060339 input] (clojure.core/let [rawinput2060338 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060340 {"WindowId" (rawinput2060338 "WindowId"), "WindowTargetId" (rawinput2060338 "WindowTargetId")}] (clojure.core/cond-> {} (letvar2060340 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060340 ["WindowId"]))) (letvar2060340 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (clojure.core/get-in letvar2060340 ["WindowTargetId"])))))))

(clojure.core/defn- response-update-patch-baseline-result ([input] (response-update-patch-baseline-result nil input)) ([resultWrapper2060342 input] (clojure.core/let [rawinput2060341 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060343 {"RejectedPatchesAction" (rawinput2060341 "RejectedPatchesAction"), "GlobalFilters" (rawinput2060341 "GlobalFilters"), "ApprovedPatches" (rawinput2060341 "ApprovedPatches"), "Description" (rawinput2060341 "Description"), "ApprovedPatchesEnableNonSecurity" (rawinput2060341 "ApprovedPatchesEnableNonSecurity"), "BaselineId" (rawinput2060341 "BaselineId"), "CreatedDate" (rawinput2060341 "CreatedDate"), "ModifiedDate" (rawinput2060341 "ModifiedDate"), "ApprovalRules" (rawinput2060341 "ApprovalRules"), "ApprovedPatchesComplianceLevel" (rawinput2060341 "ApprovedPatchesComplianceLevel"), "Name" (rawinput2060341 "Name"), "Sources" (rawinput2060341 "Sources"), "OperatingSystem" (rawinput2060341 "OperatingSystem"), "RejectedPatches" (rawinput2060341 "RejectedPatches")}] (clojure.core/cond-> {} (letvar2060343 "RejectedPatchesAction") (clojure.core/assoc :rejected-patches-action (deser-patch-action (clojure.core/get-in letvar2060343 ["RejectedPatchesAction"]))) (letvar2060343 "GlobalFilters") (clojure.core/assoc :global-filters (deser-patch-filter-group (clojure.core/get-in letvar2060343 ["GlobalFilters"]))) (letvar2060343 "ApprovedPatches") (clojure.core/assoc :approved-patches (deser-patch-id-list (clojure.core/get-in letvar2060343 ["ApprovedPatches"]))) (letvar2060343 "Description") (clojure.core/assoc :description (deser-baseline-description (clojure.core/get-in letvar2060343 ["Description"]))) (letvar2060343 "ApprovedPatchesEnableNonSecurity") (clojure.core/assoc :approved-patches-enable-non-security (deser-boolean (clojure.core/get-in letvar2060343 ["ApprovedPatchesEnableNonSecurity"]))) (letvar2060343 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060343 ["BaselineId"]))) (letvar2060343 "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (clojure.core/get-in letvar2060343 ["CreatedDate"]))) (letvar2060343 "ModifiedDate") (clojure.core/assoc :modified-date (deser-date-time (clojure.core/get-in letvar2060343 ["ModifiedDate"]))) (letvar2060343 "ApprovalRules") (clojure.core/assoc :approval-rules (deser-patch-rule-group (clojure.core/get-in letvar2060343 ["ApprovalRules"]))) (letvar2060343 "ApprovedPatchesComplianceLevel") (clojure.core/assoc :approved-patches-compliance-level (deser-patch-compliance-level (clojure.core/get-in letvar2060343 ["ApprovedPatchesComplianceLevel"]))) (letvar2060343 "Name") (clojure.core/assoc :name (deser-baseline-name (clojure.core/get-in letvar2060343 ["Name"]))) (letvar2060343 "Sources") (clojure.core/assoc :sources (deser-patch-source-list (clojure.core/get-in letvar2060343 ["Sources"]))) (letvar2060343 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2060343 ["OperatingSystem"]))) (letvar2060343 "RejectedPatches") (clojure.core/assoc :rejected-patches (deser-patch-id-list (clojure.core/get-in letvar2060343 ["RejectedPatches"])))))))

(clojure.core/defn- response-describe-maintenance-window-targets-result ([input] (response-describe-maintenance-window-targets-result nil input)) ([resultWrapper2060345 input] (clojure.core/let [rawinput2060344 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060346 {"Targets" (rawinput2060344 "Targets"), "NextToken" (rawinput2060344 "NextToken")}] (clojure.core/cond-> {} (letvar2060346 "Targets") (clojure.core/assoc :targets (deser-maintenance-window-target-list (clojure.core/get-in letvar2060346 ["Targets"]))) (letvar2060346 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060346 ["NextToken"])))))))

(clojure.core/defn- response-describe-maintenance-window-tasks-result ([input] (response-describe-maintenance-window-tasks-result nil input)) ([resultWrapper2060348 input] (clojure.core/let [rawinput2060347 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060349 {"Tasks" (rawinput2060347 "Tasks"), "NextToken" (rawinput2060347 "NextToken")}] (clojure.core/cond-> {} (letvar2060349 "Tasks") (clojure.core/assoc :tasks (deser-maintenance-window-task-list (clojure.core/get-in letvar2060349 ["Tasks"]))) (letvar2060349 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060349 ["NextToken"])))))))

(clojure.core/defn- response-invalid-parameters ([input] (response-invalid-parameters nil input)) ([resultWrapper2060351 input] (clojure.core/let [rawinput2060350 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060352 {"Message" (rawinput2060350 "Message")}] (clojure.core/cond-> {} (letvar2060352 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060352 ["Message"])))))))

(clojure.core/defn- response-describe-association-execution-targets-result ([input] (response-describe-association-execution-targets-result nil input)) ([resultWrapper2060354 input] (clojure.core/let [rawinput2060353 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060355 {"AssociationExecutionTargets" (rawinput2060353 "AssociationExecutionTargets"), "NextToken" (rawinput2060353 "NextToken")}] (clojure.core/cond-> {} (letvar2060355 "AssociationExecutionTargets") (clojure.core/assoc :association-execution-targets (deser-association-execution-targets-list (clojure.core/get-in letvar2060355 ["AssociationExecutionTargets"]))) (letvar2060355 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060355 ["NextToken"])))))))

(clojure.core/defn- response-get-patch-baseline-result ([input] (response-get-patch-baseline-result nil input)) ([resultWrapper2060357 input] (clojure.core/let [rawinput2060356 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060358 {"RejectedPatchesAction" (rawinput2060356 "RejectedPatchesAction"), "GlobalFilters" (rawinput2060356 "GlobalFilters"), "ApprovedPatches" (rawinput2060356 "ApprovedPatches"), "Description" (rawinput2060356 "Description"), "ApprovedPatchesEnableNonSecurity" (rawinput2060356 "ApprovedPatchesEnableNonSecurity"), "BaselineId" (rawinput2060356 "BaselineId"), "CreatedDate" (rawinput2060356 "CreatedDate"), "PatchGroups" (rawinput2060356 "PatchGroups"), "ModifiedDate" (rawinput2060356 "ModifiedDate"), "ApprovalRules" (rawinput2060356 "ApprovalRules"), "ApprovedPatchesComplianceLevel" (rawinput2060356 "ApprovedPatchesComplianceLevel"), "Name" (rawinput2060356 "Name"), "Sources" (rawinput2060356 "Sources"), "OperatingSystem" (rawinput2060356 "OperatingSystem"), "RejectedPatches" (rawinput2060356 "RejectedPatches")}] (clojure.core/cond-> {} (letvar2060358 "RejectedPatchesAction") (clojure.core/assoc :rejected-patches-action (deser-patch-action (clojure.core/get-in letvar2060358 ["RejectedPatchesAction"]))) (letvar2060358 "GlobalFilters") (clojure.core/assoc :global-filters (deser-patch-filter-group (clojure.core/get-in letvar2060358 ["GlobalFilters"]))) (letvar2060358 "ApprovedPatches") (clojure.core/assoc :approved-patches (deser-patch-id-list (clojure.core/get-in letvar2060358 ["ApprovedPatches"]))) (letvar2060358 "Description") (clojure.core/assoc :description (deser-baseline-description (clojure.core/get-in letvar2060358 ["Description"]))) (letvar2060358 "ApprovedPatchesEnableNonSecurity") (clojure.core/assoc :approved-patches-enable-non-security (deser-boolean (clojure.core/get-in letvar2060358 ["ApprovedPatchesEnableNonSecurity"]))) (letvar2060358 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060358 ["BaselineId"]))) (letvar2060358 "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (clojure.core/get-in letvar2060358 ["CreatedDate"]))) (letvar2060358 "PatchGroups") (clojure.core/assoc :patch-groups (deser-patch-group-list (clojure.core/get-in letvar2060358 ["PatchGroups"]))) (letvar2060358 "ModifiedDate") (clojure.core/assoc :modified-date (deser-date-time (clojure.core/get-in letvar2060358 ["ModifiedDate"]))) (letvar2060358 "ApprovalRules") (clojure.core/assoc :approval-rules (deser-patch-rule-group (clojure.core/get-in letvar2060358 ["ApprovalRules"]))) (letvar2060358 "ApprovedPatchesComplianceLevel") (clojure.core/assoc :approved-patches-compliance-level (deser-patch-compliance-level (clojure.core/get-in letvar2060358 ["ApprovedPatchesComplianceLevel"]))) (letvar2060358 "Name") (clojure.core/assoc :name (deser-baseline-name (clojure.core/get-in letvar2060358 ["Name"]))) (letvar2060358 "Sources") (clojure.core/assoc :sources (deser-patch-source-list (clojure.core/get-in letvar2060358 ["Sources"]))) (letvar2060358 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2060358 ["OperatingSystem"]))) (letvar2060358 "RejectedPatches") (clojure.core/assoc :rejected-patches (deser-patch-id-list (clojure.core/get-in letvar2060358 ["RejectedPatches"])))))))

(clojure.core/defn- response-deregister-task-from-maintenance-window-result ([input] (response-deregister-task-from-maintenance-window-result nil input)) ([resultWrapper2060360 input] (clojure.core/let [rawinput2060359 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060361 {"WindowId" (rawinput2060359 "WindowId"), "WindowTaskId" (rawinput2060359 "WindowTaskId")}] (clojure.core/cond-> {} (letvar2060361 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060361 ["WindowId"]))) (letvar2060361 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2060361 ["WindowTaskId"])))))))

(clojure.core/defn- response-unsupported-inventory-schema-version-exception ([input] (response-unsupported-inventory-schema-version-exception nil input)) ([resultWrapper2060363 input] (clojure.core/let [rawinput2060362 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060364 {"Message" (rawinput2060362 "Message")}] (clojure.core/cond-> {} (letvar2060364 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060364 ["Message"])))))))

(clojure.core/defn- response-invalid-item-content-exception ([input] (response-invalid-item-content-exception nil input)) ([resultWrapper2060366 input] (clojure.core/let [rawinput2060365 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060367 {"TypeName" (rawinput2060365 "TypeName"), "Message" (rawinput2060365 "Message")}] (clojure.core/cond-> {} (letvar2060367 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2060367 ["TypeName"]))) (letvar2060367 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060367 ["Message"])))))))

(clojure.core/defn- response-invalid-filter-key ([input] (response-invalid-filter-key nil input)) ([resultWrapper2060369 input] (clojure.core/let [rawinput2060368 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060370 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-notification-config ([input] (response-invalid-notification-config nil input)) ([resultWrapper2060372 input] (clojure.core/let [rawinput2060371 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060373 {"Message" (rawinput2060371 "Message")}] (clojure.core/cond-> {} (letvar2060373 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060373 ["Message"])))))))

(clojure.core/defn- response-describe-document-permission-response ([input] (response-describe-document-permission-response nil input)) ([resultWrapper2060375 input] (clojure.core/let [rawinput2060374 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060376 {"AccountIds" (rawinput2060374 "AccountIds")}] (clojure.core/cond-> {} (letvar2060376 "AccountIds") (clojure.core/assoc :account-ids (deser-account-id-list (clojure.core/get-in letvar2060376 ["AccountIds"])))))))

(clojure.core/defn- response-unsupported-operating-system ([input] (response-unsupported-operating-system nil input)) ([resultWrapper2060378 input] (clojure.core/let [rawinput2060377 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060379 {"Message" (rawinput2060377 "Message")}] (clojure.core/cond-> {} (letvar2060379 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060379 ["Message"])))))))

(clojure.core/defn- response-get-default-patch-baseline-result ([input] (response-get-default-patch-baseline-result nil input)) ([resultWrapper2060381 input] (clojure.core/let [rawinput2060380 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060382 {"BaselineId" (rawinput2060380 "BaselineId"), "OperatingSystem" (rawinput2060380 "OperatingSystem")}] (clojure.core/cond-> {} (letvar2060382 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060382 ["BaselineId"]))) (letvar2060382 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2060382 ["OperatingSystem"])))))))

(clojure.core/defn- response-describe-patch-groups-result ([input] (response-describe-patch-groups-result nil input)) ([resultWrapper2060384 input] (clojure.core/let [rawinput2060383 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060385 {"Mappings" (rawinput2060383 "Mappings"), "NextToken" (rawinput2060383 "NextToken")}] (clojure.core/cond-> {} (letvar2060385 "Mappings") (clojure.core/assoc :mappings (deser-patch-group-patch-baseline-mapping-list (clojure.core/get-in letvar2060385 ["Mappings"]))) (letvar2060385 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060385 ["NextToken"])))))))

(clojure.core/defn- response-remove-tags-from-resource-result ([input] (response-remove-tags-from-resource-result nil input)) ([resultWrapper2060387 input] (clojure.core/let [rawinput2060386 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060388 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-parameter-result ([input] (response-delete-parameter-result nil input)) ([resultWrapper2060390 input] (clojure.core/let [rawinput2060389 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060391 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-filter-value ([input] (response-invalid-filter-value nil input)) ([resultWrapper2060393 input] (clojure.core/let [rawinput2060392 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060394 {"Message" (rawinput2060392 "Message")}] (clojure.core/cond-> {} (letvar2060394 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060394 ["Message"])))))))

(clojure.core/defn- response-invalid-key-id ([input] (response-invalid-key-id nil input)) ([resultWrapper2060396 input] (clojure.core/let [rawinput2060395 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060397 {"message" (rawinput2060395 "message")}] (clojure.core/cond-> {} (letvar2060397 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060397 ["message"])))))))

(clojure.core/defn- response-describe-maintenance-window-execution-task-invocations-result ([input] (response-describe-maintenance-window-execution-task-invocations-result nil input)) ([resultWrapper2060399 input] (clojure.core/let [rawinput2060398 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060400 {"WindowExecutionTaskInvocationIdentities" (rawinput2060398 "WindowExecutionTaskInvocationIdentities"), "NextToken" (rawinput2060398 "NextToken")}] (clojure.core/cond-> {} (letvar2060400 "WindowExecutionTaskInvocationIdentities") (clojure.core/assoc :window-execution-task-invocation-identities (deser-maintenance-window-execution-task-invocation-identity-list (clojure.core/get-in letvar2060400 ["WindowExecutionTaskInvocationIdentities"]))) (letvar2060400 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060400 ["NextToken"])))))))

(clojure.core/defn- response-parameter-max-version-limit-exceeded ([input] (response-parameter-max-version-limit-exceeded nil input)) ([resultWrapper2060402 input] (clojure.core/let [rawinput2060401 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060403 {"message" (rawinput2060401 "message")}] (clojure.core/cond-> {} (letvar2060403 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060403 ["message"])))))))

(clojure.core/defn- response-feature-not-available-exception ([input] (response-feature-not-available-exception nil input)) ([resultWrapper2060405 input] (clojure.core/let [rawinput2060404 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060406 {"Message" (rawinput2060404 "Message")}] (clojure.core/cond-> {} (letvar2060406 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060406 ["Message"])))))))

(clojure.core/defn- response-invalid-automation-signal-exception ([input] (response-invalid-automation-signal-exception nil input)) ([resultWrapper2060408 input] (clojure.core/let [rawinput2060407 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060409 {"Message" (rawinput2060407 "Message")}] (clojure.core/cond-> {} (letvar2060409 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060409 ["Message"])))))))

(clojure.core/defn- response-describe-effective-patches-for-patch-baseline-result ([input] (response-describe-effective-patches-for-patch-baseline-result nil input)) ([resultWrapper2060411 input] (clojure.core/let [rawinput2060410 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060412 {"EffectivePatches" (rawinput2060410 "EffectivePatches"), "NextToken" (rawinput2060410 "NextToken")}] (clojure.core/cond-> {} (letvar2060412 "EffectivePatches") (clojure.core/assoc :effective-patches (deser-effective-patch-list (clojure.core/get-in letvar2060412 ["EffectivePatches"]))) (letvar2060412 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060412 ["NextToken"])))))))

(clojure.core/defn- response-resource-data-sync-count-exceeded-exception ([input] (response-resource-data-sync-count-exceeded-exception nil input)) ([resultWrapper2060414 input] (clojure.core/let [rawinput2060413 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060415 {"Message" (rawinput2060413 "Message")}] (clojure.core/cond-> {} (letvar2060415 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060415 ["Message"])))))))

(clojure.core/defn- response-list-resource-data-sync-result ([input] (response-list-resource-data-sync-result nil input)) ([resultWrapper2060417 input] (clojure.core/let [rawinput2060416 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060418 {"ResourceDataSyncItems" (rawinput2060416 "ResourceDataSyncItems"), "NextToken" (rawinput2060416 "NextToken")}] (clojure.core/cond-> {} (letvar2060418 "ResourceDataSyncItems") (clojure.core/assoc :resource-data-sync-items (deser-resource-data-sync-item-list (clojure.core/get-in letvar2060418 ["ResourceDataSyncItems"]))) (letvar2060418 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060418 ["NextToken"])))))))

(clojure.core/defn- response-describe-document-result ([input] (response-describe-document-result nil input)) ([resultWrapper2060420 input] (clojure.core/let [rawinput2060419 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060421 {"Document" (rawinput2060419 "Document")}] (clojure.core/cond-> {} (letvar2060421 "Document") (clojure.core/assoc :document (deser-document-description (clojure.core/get-in letvar2060421 ["Document"])))))))

(clojure.core/defn- response-describe-sessions-response ([input] (response-describe-sessions-response nil input)) ([resultWrapper2060423 input] (clojure.core/let [rawinput2060422 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060424 {"Sessions" (rawinput2060422 "Sessions"), "NextToken" (rawinput2060422 "NextToken")}] (clojure.core/cond-> {} (letvar2060424 "Sessions") (clojure.core/assoc :sessions (deser-session-list (clojure.core/get-in letvar2060424 ["Sessions"]))) (letvar2060424 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060424 ["NextToken"])))))))

(clojure.core/defn- response-resource-limit-exceeded-exception ([input] (response-resource-limit-exceeded-exception nil input)) ([resultWrapper2060426 input] (clojure.core/let [rawinput2060425 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060427 {"Message" (rawinput2060425 "Message")}] (clojure.core/cond-> {} (letvar2060427 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060427 ["Message"])))))))

(clojure.core/defn- response-invalid-inventory-item-context-exception ([input] (response-invalid-inventory-item-context-exception nil input)) ([resultWrapper2060429 input] (clojure.core/let [rawinput2060428 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060430 {"Message" (rawinput2060428 "Message")}] (clojure.core/cond-> {} (letvar2060430 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060430 ["Message"])))))))

(clojure.core/defn- response-get-document-result ([input] (response-get-document-result nil input)) ([resultWrapper2060432 input] (clojure.core/let [rawinput2060431 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060433 {"DocumentType" (rawinput2060431 "DocumentType"), "Status" (rawinput2060431 "Status"), "StatusInformation" (rawinput2060431 "StatusInformation"), "Content" (rawinput2060431 "Content"), "DocumentFormat" (rawinput2060431 "DocumentFormat"), "VersionName" (rawinput2060431 "VersionName"), "AttachmentsContent" (rawinput2060431 "AttachmentsContent"), "DocumentVersion" (rawinput2060431 "DocumentVersion"), "Name" (rawinput2060431 "Name")}] (clojure.core/cond-> {} (letvar2060433 "DocumentType") (clojure.core/assoc :document-type (deser-document-type (clojure.core/get-in letvar2060433 ["DocumentType"]))) (letvar2060433 "Status") (clojure.core/assoc :status (deser-document-status (clojure.core/get-in letvar2060433 ["Status"]))) (letvar2060433 "StatusInformation") (clojure.core/assoc :status-information (deser-document-status-information (clojure.core/get-in letvar2060433 ["StatusInformation"]))) (letvar2060433 "Content") (clojure.core/assoc :content (deser-document-content (clojure.core/get-in letvar2060433 ["Content"]))) (letvar2060433 "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (clojure.core/get-in letvar2060433 ["DocumentFormat"]))) (letvar2060433 "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (clojure.core/get-in letvar2060433 ["VersionName"]))) (letvar2060433 "AttachmentsContent") (clojure.core/assoc :attachments-content (deser-attachment-content-list (clojure.core/get-in letvar2060433 ["AttachmentsContent"]))) (letvar2060433 "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (clojure.core/get-in letvar2060433 ["DocumentVersion"]))) (letvar2060433 "Name") (clojure.core/assoc :name (deser-document-arn (clojure.core/get-in letvar2060433 ["Name"])))))))

(clojure.core/defn- response-duplicate-document-version-name ([input] (response-duplicate-document-version-name nil input)) ([resultWrapper2060435 input] (clojure.core/let [rawinput2060434 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060436 {"Message" (rawinput2060434 "Message")}] (clojure.core/cond-> {} (letvar2060436 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060436 ["Message"])))))))

(clojure.core/defn- response-association-version-limit-exceeded ([input] (response-association-version-limit-exceeded nil input)) ([resultWrapper2060438 input] (clojure.core/let [rawinput2060437 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060439 {"Message" (rawinput2060437 "Message")}] (clojure.core/cond-> {} (letvar2060439 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060439 ["Message"])))))))

(clojure.core/defn- response-list-association-versions-result ([input] (response-list-association-versions-result nil input)) ([resultWrapper2060441 input] (clojure.core/let [rawinput2060440 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060442 {"AssociationVersions" (rawinput2060440 "AssociationVersions"), "NextToken" (rawinput2060440 "NextToken")}] (clojure.core/cond-> {} (letvar2060442 "AssociationVersions") (clojure.core/assoc :association-versions (deser-association-version-list (clojure.core/get-in letvar2060442 ["AssociationVersions"]))) (letvar2060442 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060442 ["NextToken"])))))))

(clojure.core/defn- response-resume-session-response ([input] (response-resume-session-response nil input)) ([resultWrapper2060444 input] (clojure.core/let [rawinput2060443 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060445 {"SessionId" (rawinput2060443 "SessionId"), "TokenValue" (rawinput2060443 "TokenValue"), "StreamUrl" (rawinput2060443 "StreamUrl")}] (clojure.core/cond-> {} (letvar2060445 "SessionId") (clojure.core/assoc :session-id (deser-session-id (clojure.core/get-in letvar2060445 ["SessionId"]))) (letvar2060445 "TokenValue") (clojure.core/assoc :token-value (deser-token-value (clojure.core/get-in letvar2060445 ["TokenValue"]))) (letvar2060445 "StreamUrl") (clojure.core/assoc :stream-url (deser-stream-url (clojure.core/get-in letvar2060445 ["StreamUrl"])))))))

(clojure.core/defn- response-invalid-target ([input] (response-invalid-target nil input)) ([resultWrapper2060447 input] (clojure.core/let [rawinput2060446 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060448 {"Message" (rawinput2060446 "Message")}] (clojure.core/cond-> {} (letvar2060448 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060448 ["Message"])))))))

(clojure.core/defn- response-describe-activations-result ([input] (response-describe-activations-result nil input)) ([resultWrapper2060450 input] (clojure.core/let [rawinput2060449 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060451 {"ActivationList" (rawinput2060449 "ActivationList"), "NextToken" (rawinput2060449 "NextToken")}] (clojure.core/cond-> {} (letvar2060451 "ActivationList") (clojure.core/assoc :activation-list (deser-activation-list (clojure.core/get-in letvar2060451 ["ActivationList"]))) (letvar2060451 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060451 ["NextToken"])))))))

(clojure.core/defn- response-invalid-association-version ([input] (response-invalid-association-version nil input)) ([resultWrapper2060453 input] (clojure.core/let [rawinput2060452 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060454 {"Message" (rawinput2060452 "Message")}] (clojure.core/cond-> {} (letvar2060454 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060454 ["Message"])))))))

(clojure.core/defn- response-invalid-inventory-request-exception ([input] (response-invalid-inventory-request-exception nil input)) ([resultWrapper2060456 input] (clojure.core/let [rawinput2060455 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060457 {"Message" (rawinput2060455 "Message")}] (clojure.core/cond-> {} (letvar2060457 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060457 ["Message"])))))))

(clojure.core/defn- response-sub-type-count-limit-exceeded-exception ([input] (response-sub-type-count-limit-exceeded-exception nil input)) ([resultWrapper2060459 input] (clojure.core/let [rawinput2060458 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060460 {"Message" (rawinput2060458 "Message")}] (clojure.core/cond-> {} (letvar2060460 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060460 ["Message"])))))))

(clojure.core/defn- response-associated-instances ([input] (response-associated-instances nil input)) ([resultWrapper2060462 input] (clojure.core/let [rawinput2060461 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060463 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-output-folder ([input] (response-invalid-output-folder nil input)) ([resultWrapper2060465 input] (clojure.core/let [rawinput2060464 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060466 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-resource-compliance-summaries-result ([input] (response-list-resource-compliance-summaries-result nil input)) ([resultWrapper2060468 input] (clojure.core/let [rawinput2060467 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060469 {"ResourceComplianceSummaryItems" (rawinput2060467 "ResourceComplianceSummaryItems"), "NextToken" (rawinput2060467 "NextToken")}] (clojure.core/cond-> {} (letvar2060469 "ResourceComplianceSummaryItems") (clojure.core/assoc :resource-compliance-summary-items (deser-resource-compliance-summary-item-list (clojure.core/get-in letvar2060469 ["ResourceComplianceSummaryItems"]))) (letvar2060469 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060469 ["NextToken"])))))))

(clojure.core/defn- response-invalid-role ([input] (response-invalid-role nil input)) ([resultWrapper2060471 input] (clojure.core/let [rawinput2060470 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060472 {"Message" (rawinput2060470 "Message")}] (clojure.core/cond-> {} (letvar2060472 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060472 ["Message"])))))))

(clojure.core/defn- response-invalid-association ([input] (response-invalid-association nil input)) ([resultWrapper2060474 input] (clojure.core/let [rawinput2060473 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060475 {"Message" (rawinput2060473 "Message")}] (clojure.core/cond-> {} (letvar2060475 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060475 ["Message"])))))))

(clojure.core/defn- response-describe-parameters-result ([input] (response-describe-parameters-result nil input)) ([resultWrapper2060477 input] (clojure.core/let [rawinput2060476 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060478 {"Parameters" (rawinput2060476 "Parameters"), "NextToken" (rawinput2060476 "NextToken")}] (clojure.core/cond-> {} (letvar2060478 "Parameters") (clojure.core/assoc :parameters (deser-parameter-metadata-list (clojure.core/get-in letvar2060478 ["Parameters"]))) (letvar2060478 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060478 ["NextToken"])))))))

(clojure.core/defn- response-resource-data-sync-already-exists-exception ([input] (response-resource-data-sync-already-exists-exception nil input)) ([resultWrapper2060480 input] (clojure.core/let [rawinput2060479 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060481 {"SyncName" (rawinput2060479 "SyncName")}] (clojure.core/cond-> {} (letvar2060481 "SyncName") (clojure.core/assoc :sync-name (deser-resource-data-sync-name (clojure.core/get-in letvar2060481 ["SyncName"])))))))

(clojure.core/defn- response-update-maintenance-window-target-result ([input] (response-update-maintenance-window-target-result nil input)) ([resultWrapper2060483 input] (clojure.core/let [rawinput2060482 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060484 {"WindowId" (rawinput2060482 "WindowId"), "WindowTargetId" (rawinput2060482 "WindowTargetId"), "Targets" (rawinput2060482 "Targets"), "OwnerInformation" (rawinput2060482 "OwnerInformation"), "Name" (rawinput2060482 "Name"), "Description" (rawinput2060482 "Description")}] (clojure.core/cond-> {} (letvar2060484 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060484 ["WindowId"]))) (letvar2060484 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (clojure.core/get-in letvar2060484 ["WindowTargetId"]))) (letvar2060484 "Targets") (clojure.core/assoc :targets (deser-targets (clojure.core/get-in letvar2060484 ["Targets"]))) (letvar2060484 "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (clojure.core/get-in letvar2060484 ["OwnerInformation"]))) (letvar2060484 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2060484 ["Name"]))) (letvar2060484 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2060484 ["Description"])))))))

(clojure.core/defn- response-invalid-inventory-group-exception ([input] (response-invalid-inventory-group-exception nil input)) ([resultWrapper2060486 input] (clojure.core/let [rawinput2060485 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060487 {"Message" (rawinput2060485 "Message")}] (clojure.core/cond-> {} (letvar2060487 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060487 ["Message"])))))))

(clojure.core/defn- response-invalid-allowed-pattern-exception ([input] (response-invalid-allowed-pattern-exception nil input)) ([resultWrapper2060489 input] (clojure.core/let [rawinput2060488 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060490 {"message" (rawinput2060488 "message")}] (clojure.core/cond-> {} (letvar2060490 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060490 ["message"])))))))

(clojure.core/defn- response-invalid-aggregator-exception ([input] (response-invalid-aggregator-exception nil input)) ([resultWrapper2060492 input] (clojure.core/let [rawinput2060491 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060493 {"Message" (rawinput2060491 "Message")}] (clojure.core/cond-> {} (letvar2060493 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060493 ["Message"])))))))

(clojure.core/defn- response-get-service-setting-result ([input] (response-get-service-setting-result nil input)) ([resultWrapper2060495 input] (clojure.core/let [rawinput2060494 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060496 {"ServiceSetting" (rawinput2060494 "ServiceSetting")}] (clojure.core/cond-> {} (letvar2060496 "ServiceSetting") (clojure.core/assoc :service-setting (deser-service-setting (clojure.core/get-in letvar2060496 ["ServiceSetting"])))))))

(clojure.core/defn- response-invocation-does-not-exist ([input] (response-invocation-does-not-exist nil input)) ([resultWrapper2060498 input] (clojure.core/let [rawinput2060497 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060499 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-patch-baselines-result ([input] (response-describe-patch-baselines-result nil input)) ([resultWrapper2060501 input] (clojure.core/let [rawinput2060500 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060502 {"BaselineIdentities" (rawinput2060500 "BaselineIdentities"), "NextToken" (rawinput2060500 "NextToken")}] (clojure.core/cond-> {} (letvar2060502 "BaselineIdentities") (clojure.core/assoc :baseline-identities (deser-patch-baseline-identity-list (clojure.core/get-in letvar2060502 ["BaselineIdentities"]))) (letvar2060502 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060502 ["NextToken"])))))))

(clojure.core/defn- response-internal-server-error ([input] (response-internal-server-error nil input)) ([resultWrapper2060504 input] (clojure.core/let [rawinput2060503 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060505 {"Message" (rawinput2060503 "Message")}] (clojure.core/cond-> {} (letvar2060505 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060505 ["Message"])))))))

(clojure.core/defn- response-delete-maintenance-window-result ([input] (response-delete-maintenance-window-result nil input)) ([resultWrapper2060507 input] (clojure.core/let [rawinput2060506 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060508 {"WindowId" (rawinput2060506 "WindowId")}] (clojure.core/cond-> {} (letvar2060508 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2060508 ["WindowId"])))))))

(clojure.core/defn- response-describe-maintenance-window-execution-tasks-result ([input] (response-describe-maintenance-window-execution-tasks-result nil input)) ([resultWrapper2060510 input] (clojure.core/let [rawinput2060509 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060511 {"WindowExecutionTaskIdentities" (rawinput2060509 "WindowExecutionTaskIdentities"), "NextToken" (rawinput2060509 "NextToken")}] (clojure.core/cond-> {} (letvar2060511 "WindowExecutionTaskIdentities") (clojure.core/assoc :window-execution-task-identities (deser-maintenance-window-execution-task-identity-list (clojure.core/get-in letvar2060511 ["WindowExecutionTaskIdentities"]))) (letvar2060511 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060511 ["NextToken"])))))))

(clojure.core/defn- response-get-parameter-history-result ([input] (response-get-parameter-history-result nil input)) ([resultWrapper2060513 input] (clojure.core/let [rawinput2060512 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060514 {"Parameters" (rawinput2060512 "Parameters"), "NextToken" (rawinput2060512 "NextToken")}] (clojure.core/cond-> {} (letvar2060514 "Parameters") (clojure.core/assoc :parameters (deser-parameter-history-list (clojure.core/get-in letvar2060514 ["Parameters"]))) (letvar2060514 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060514 ["NextToken"])))))))

(clojure.core/defn- response-service-setting-not-found ([input] (response-service-setting-not-found nil input)) ([resultWrapper2060516 input] (clojure.core/let [rawinput2060515 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060517 {"Message" (rawinput2060515 "Message")}] (clojure.core/cond-> {} (letvar2060517 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060517 ["Message"])))))))

(clojure.core/defn- response-describe-maintenance-window-schedule-result ([input] (response-describe-maintenance-window-schedule-result nil input)) ([resultWrapper2060519 input] (clojure.core/let [rawinput2060518 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060520 {"ScheduledWindowExecutions" (rawinput2060518 "ScheduledWindowExecutions"), "NextToken" (rawinput2060518 "NextToken")}] (clojure.core/cond-> {} (letvar2060520 "ScheduledWindowExecutions") (clojure.core/assoc :scheduled-window-executions (deser-scheduled-window-execution-list (clojure.core/get-in letvar2060520 ["ScheduledWindowExecutions"]))) (letvar2060520 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060520 ["NextToken"])))))))

(clojure.core/defn- response-describe-instance-information-result ([input] (response-describe-instance-information-result nil input)) ([resultWrapper2060522 input] (clojure.core/let [rawinput2060521 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060523 {"InstanceInformationList" (rawinput2060521 "InstanceInformationList"), "NextToken" (rawinput2060521 "NextToken")}] (clojure.core/cond-> {} (letvar2060523 "InstanceInformationList") (clojure.core/assoc :instance-information-list (deser-instance-information-list (clojure.core/get-in letvar2060523 ["InstanceInformationList"]))) (letvar2060523 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060523 ["NextToken"])))))))

(clojure.core/defn- response-invalid-instance-id ([input] (response-invalid-instance-id nil input)) ([resultWrapper2060525 input] (clojure.core/let [rawinput2060524 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060526 {"Message" (rawinput2060524 "Message")}] (clojure.core/cond-> {} (letvar2060526 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060526 ["Message"])))))))

(clojure.core/defn- response-invalid-permission-type ([input] (response-invalid-permission-type nil input)) ([resultWrapper2060528 input] (clojure.core/let [rawinput2060527 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060529 {"Message" (rawinput2060527 "Message")}] (clojure.core/cond-> {} (letvar2060529 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060529 ["Message"])))))))

(clojure.core/defn- response-invalid-update ([input] (response-invalid-update nil input)) ([resultWrapper2060531 input] (clojure.core/let [rawinput2060530 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060532 {"Message" (rawinput2060530 "Message")}] (clojure.core/cond-> {} (letvar2060532 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060532 ["Message"])))))))

(clojure.core/defn- response-invalid-output-location ([input] (response-invalid-output-location nil input)) ([resultWrapper2060534 input] (clojure.core/let [rawinput2060533 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060535 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-deregister-managed-instance-result ([input] (response-deregister-managed-instance-result nil input)) ([resultWrapper2060537 input] (clojure.core/let [rawinput2060536 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060538 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-effective-instance-associations-result ([input] (response-describe-effective-instance-associations-result nil input)) ([resultWrapper2060540 input] (clojure.core/let [rawinput2060539 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060541 {"Associations" (rawinput2060539 "Associations"), "NextToken" (rawinput2060539 "NextToken")}] (clojure.core/cond-> {} (letvar2060541 "Associations") (clojure.core/assoc :associations (deser-instance-association-list (clojure.core/get-in letvar2060541 ["Associations"]))) (letvar2060541 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060541 ["NextToken"])))))))

(clojure.core/defn- response-get-command-invocation-result ([input] (response-get-command-invocation-result nil input)) ([resultWrapper2060543 input] (clojure.core/let [rawinput2060542 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060544 {"InstanceId" (rawinput2060542 "InstanceId"), "ExecutionStartDateTime" (rawinput2060542 "ExecutionStartDateTime"), "Comment" (rawinput2060542 "Comment"), "PluginName" (rawinput2060542 "PluginName"), "ExecutionElapsedTime" (rawinput2060542 "ExecutionElapsedTime"), "ResponseCode" (rawinput2060542 "ResponseCode"), "Status" (rawinput2060542 "Status"), "StatusDetails" (rawinput2060542 "StatusDetails"), "StandardOutputContent" (rawinput2060542 "StandardOutputContent"), "CloudWatchOutputConfig" (rawinput2060542 "CloudWatchOutputConfig"), "StandardOutputUrl" (rawinput2060542 "StandardOutputUrl"), "CommandId" (rawinput2060542 "CommandId"), "ExecutionEndDateTime" (rawinput2060542 "ExecutionEndDateTime"), "DocumentName" (rawinput2060542 "DocumentName"), "DocumentVersion" (rawinput2060542 "DocumentVersion"), "StandardErrorUrl" (rawinput2060542 "StandardErrorUrl"), "StandardErrorContent" (rawinput2060542 "StandardErrorContent")}] (clojure.core/cond-> {} (letvar2060544 "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (clojure.core/get-in letvar2060544 ["InstanceId"]))) (letvar2060544 "ExecutionStartDateTime") (clojure.core/assoc :execution-start-date-time (deser-string-date-time (clojure.core/get-in letvar2060544 ["ExecutionStartDateTime"]))) (letvar2060544 "Comment") (clojure.core/assoc :comment (deser-comment (clojure.core/get-in letvar2060544 ["Comment"]))) (letvar2060544 "PluginName") (clojure.core/assoc :plugin-name (deser-command-plugin-name (clojure.core/get-in letvar2060544 ["PluginName"]))) (letvar2060544 "ExecutionElapsedTime") (clojure.core/assoc :execution-elapsed-time (deser-string-date-time (clojure.core/get-in letvar2060544 ["ExecutionElapsedTime"]))) (letvar2060544 "ResponseCode") (clojure.core/assoc :response-code (deser-response-code (clojure.core/get-in letvar2060544 ["ResponseCode"]))) (letvar2060544 "Status") (clojure.core/assoc :status (deser-command-invocation-status (clojure.core/get-in letvar2060544 ["Status"]))) (letvar2060544 "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (clojure.core/get-in letvar2060544 ["StatusDetails"]))) (letvar2060544 "StandardOutputContent") (clojure.core/assoc :standard-output-content (deser-standard-output-content (clojure.core/get-in letvar2060544 ["StandardOutputContent"]))) (letvar2060544 "CloudWatchOutputConfig") (clojure.core/assoc :cloud-watch-output-config (deser-cloud-watch-output-config (clojure.core/get-in letvar2060544 ["CloudWatchOutputConfig"]))) (letvar2060544 "StandardOutputUrl") (clojure.core/assoc :standard-output-url (deser-url (clojure.core/get-in letvar2060544 ["StandardOutputUrl"]))) (letvar2060544 "CommandId") (clojure.core/assoc :command-id (deser-command-id (clojure.core/get-in letvar2060544 ["CommandId"]))) (letvar2060544 "ExecutionEndDateTime") (clojure.core/assoc :execution-end-date-time (deser-string-date-time (clojure.core/get-in letvar2060544 ["ExecutionEndDateTime"]))) (letvar2060544 "DocumentName") (clojure.core/assoc :document-name (deser-document-name (clojure.core/get-in letvar2060544 ["DocumentName"]))) (letvar2060544 "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (clojure.core/get-in letvar2060544 ["DocumentVersion"]))) (letvar2060544 "StandardErrorUrl") (clojure.core/assoc :standard-error-url (deser-url (clojure.core/get-in letvar2060544 ["StandardErrorUrl"]))) (letvar2060544 "StandardErrorContent") (clojure.core/assoc :standard-error-content (deser-standard-error-content (clojure.core/get-in letvar2060544 ["StandardErrorContent"])))))))

(clojure.core/defn- response-document-version-limit-exceeded ([input] (response-document-version-limit-exceeded nil input)) ([resultWrapper2060546 input] (clojure.core/let [rawinput2060545 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060547 {"Message" (rawinput2060545 "Message")}] (clojure.core/cond-> {} (letvar2060547 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060547 ["Message"])))))))

(clojure.core/defn- response-register-task-with-maintenance-window-result ([input] (response-register-task-with-maintenance-window-result nil input)) ([resultWrapper2060549 input] (clojure.core/let [rawinput2060548 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060550 {"WindowTaskId" (rawinput2060548 "WindowTaskId")}] (clojure.core/cond-> {} (letvar2060550 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2060550 ["WindowTaskId"])))))))

(clojure.core/defn- response-document-already-exists ([input] (response-document-already-exists nil input)) ([resultWrapper2060552 input] (clojure.core/let [rawinput2060551 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060553 {"Message" (rawinput2060551 "Message")}] (clojure.core/cond-> {} (letvar2060553 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060553 ["Message"])))))))

(clojure.core/defn- response-register-default-patch-baseline-result ([input] (response-register-default-patch-baseline-result nil input)) ([resultWrapper2060555 input] (clojure.core/let [rawinput2060554 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060556 {"BaselineId" (rawinput2060554 "BaselineId")}] (clojure.core/cond-> {} (letvar2060556 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060556 ["BaselineId"])))))))

(clojure.core/defn- response-automation-execution-limit-exceeded-exception ([input] (response-automation-execution-limit-exceeded-exception nil input)) ([resultWrapper2060558 input] (clojure.core/let [rawinput2060557 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060559 {"Message" (rawinput2060557 "Message")}] (clojure.core/cond-> {} (letvar2060559 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060559 ["Message"])))))))

(clojure.core/defn- response-describe-inventory-deletions-result ([input] (response-describe-inventory-deletions-result nil input)) ([resultWrapper2060561 input] (clojure.core/let [rawinput2060560 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060562 {"InventoryDeletions" (rawinput2060560 "InventoryDeletions"), "NextToken" (rawinput2060560 "NextToken")}] (clojure.core/cond-> {} (letvar2060562 "InventoryDeletions") (clojure.core/assoc :inventory-deletions (deser-inventory-deletions-list (clojure.core/get-in letvar2060562 ["InventoryDeletions"]))) (letvar2060562 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060562 ["NextToken"])))))))

(clojure.core/defn- response-get-deployable-patch-snapshot-for-instance-result ([input] (response-get-deployable-patch-snapshot-for-instance-result nil input)) ([resultWrapper2060564 input] (clojure.core/let [rawinput2060563 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060565 {"InstanceId" (rawinput2060563 "InstanceId"), "SnapshotId" (rawinput2060563 "SnapshotId"), "SnapshotDownloadUrl" (rawinput2060563 "SnapshotDownloadUrl"), "Product" (rawinput2060563 "Product")}] (clojure.core/cond-> {} (letvar2060565 "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (clojure.core/get-in letvar2060565 ["InstanceId"]))) (letvar2060565 "SnapshotId") (clojure.core/assoc :snapshot-id (deser-snapshot-id (clojure.core/get-in letvar2060565 ["SnapshotId"]))) (letvar2060565 "SnapshotDownloadUrl") (clojure.core/assoc :snapshot-download-url (deser-snapshot-download-url (clojure.core/get-in letvar2060565 ["SnapshotDownloadUrl"]))) (letvar2060565 "Product") (clojure.core/assoc :product (deser-product (clojure.core/get-in letvar2060565 ["Product"])))))))

(clojure.core/defn- response-send-command-result ([input] (response-send-command-result nil input)) ([resultWrapper2060567 input] (clojure.core/let [rawinput2060566 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060568 {"Command" (rawinput2060566 "Command")}] (clojure.core/cond-> {} (letvar2060568 "Command") (clojure.core/assoc :command (deser-command (clojure.core/get-in letvar2060568 ["Command"])))))))

(clojure.core/defn- response-get-maintenance-window-execution-task-result ([input] (response-get-maintenance-window-execution-task-result nil input)) ([resultWrapper2060570 input] (clojure.core/let [rawinput2060569 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060571 {"TaskExecutionId" (rawinput2060569 "TaskExecutionId"), "ServiceRole" (rawinput2060569 "ServiceRole"), "EndTime" (rawinput2060569 "EndTime"), "Type" (rawinput2060569 "Type"), "StartTime" (rawinput2060569 "StartTime"), "Status" (rawinput2060569 "Status"), "StatusDetails" (rawinput2060569 "StatusDetails"), "Priority" (rawinput2060569 "Priority"), "MaxConcurrency" (rawinput2060569 "MaxConcurrency"), "WindowExecutionId" (rawinput2060569 "WindowExecutionId"), "TaskArn" (rawinput2060569 "TaskArn"), "MaxErrors" (rawinput2060569 "MaxErrors"), "TaskParameters" (rawinput2060569 "TaskParameters")}] (clojure.core/cond-> {} (letvar2060571 "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (clojure.core/get-in letvar2060571 ["TaskExecutionId"]))) (letvar2060571 "ServiceRole") (clojure.core/assoc :service-role (deser-service-role (clojure.core/get-in letvar2060571 ["ServiceRole"]))) (letvar2060571 "EndTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar2060571 ["EndTime"]))) (letvar2060571 "Type") (clojure.core/assoc :type (deser-maintenance-window-task-type (clojure.core/get-in letvar2060571 ["Type"]))) (letvar2060571 "StartTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar2060571 ["StartTime"]))) (letvar2060571 "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (clojure.core/get-in letvar2060571 ["Status"]))) (letvar2060571 "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (clojure.core/get-in letvar2060571 ["StatusDetails"]))) (letvar2060571 "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (clojure.core/get-in letvar2060571 ["Priority"]))) (letvar2060571 "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (clojure.core/get-in letvar2060571 ["MaxConcurrency"]))) (letvar2060571 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2060571 ["WindowExecutionId"]))) (letvar2060571 "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (clojure.core/get-in letvar2060571 ["TaskArn"]))) (letvar2060571 "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (clojure.core/get-in letvar2060571 ["MaxErrors"]))) (letvar2060571 "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters-list (clojure.core/get-in letvar2060571 ["TaskParameters"])))))))

(clojure.core/defn- response-item-size-limit-exceeded-exception ([input] (response-item-size-limit-exceeded-exception nil input)) ([resultWrapper2060573 input] (clojure.core/let [rawinput2060572 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060574 {"TypeName" (rawinput2060572 "TypeName"), "Message" (rawinput2060572 "Message")}] (clojure.core/cond-> {} (letvar2060574 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2060574 ["TypeName"]))) (letvar2060574 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060574 ["Message"])))))))

(clojure.core/defn- response-list-document-versions-result ([input] (response-list-document-versions-result nil input)) ([resultWrapper2060576 input] (clojure.core/let [rawinput2060575 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060577 {"DocumentVersions" (rawinput2060575 "DocumentVersions"), "NextToken" (rawinput2060575 "NextToken")}] (clojure.core/cond-> {} (letvar2060577 "DocumentVersions") (clojure.core/assoc :document-versions (deser-document-version-list (clojure.core/get-in letvar2060577 ["DocumentVersions"]))) (letvar2060577 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2060577 ["NextToken"])))))))

(clojure.core/defn- response-deregister-patch-baseline-for-patch-group-result ([input] (response-deregister-patch-baseline-for-patch-group-result nil input)) ([resultWrapper2060579 input] (clojure.core/let [rawinput2060578 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060580 {"BaselineId" (rawinput2060578 "BaselineId"), "PatchGroup" (rawinput2060578 "PatchGroup")}] (clojure.core/cond-> {} (letvar2060580 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2060580 ["BaselineId"]))) (letvar2060580 "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (clojure.core/get-in letvar2060580 ["PatchGroup"])))))))

(clojure.core/defn- response-invalid-next-token ([input] (response-invalid-next-token nil input)) ([resultWrapper2060582 input] (clojure.core/let [rawinput2060581 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060583 {"Message" (rawinput2060581 "Message")}] (clojure.core/cond-> {} (letvar2060583 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060583 ["Message"])))))))

(clojure.core/defn- response-update-managed-instance-role-result ([input] (response-update-managed-instance-role-result nil input)) ([resultWrapper2060585 input] (clojure.core/let [rawinput2060584 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060586 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-add-tags-to-resource-result ([input] (response-add-tags-to-resource-result nil input)) ([resultWrapper2060588 input] (clojure.core/let [rawinput2060587 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060589 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-document-schema-version ([input] (response-invalid-document-schema-version nil input)) ([resultWrapper2060591 input] (clojure.core/let [rawinput2060590 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060592 {"Message" (rawinput2060590 "Message")}] (clojure.core/cond-> {} (letvar2060592 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060592 ["Message"])))))))

(clojure.core/defn- response-modify-document-permission-response ([input] (response-modify-document-permission-response nil input)) ([resultWrapper2060594 input] (clojure.core/let [rawinput2060593 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060595 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-parameter-version-not-found ([input] (response-parameter-version-not-found nil input)) ([resultWrapper2060597 input] (clojure.core/let [rawinput2060596 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060598 {"message" (rawinput2060596 "message")}] (clojure.core/cond-> {} (letvar2060598 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2060598 ["message"])))))))

(clojure.core/defn- response-delete-parameters-result ([input] (response-delete-parameters-result nil input)) ([resultWrapper2060600 input] (clojure.core/let [rawinput2060599 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060601 {"DeletedParameters" (rawinput2060599 "DeletedParameters"), "InvalidParameters" (rawinput2060599 "InvalidParameters")}] (clojure.core/cond-> {} (letvar2060601 "DeletedParameters") (clojure.core/assoc :deleted-parameters (deser-parameter-name-list (clojure.core/get-in letvar2060601 ["DeletedParameters"]))) (letvar2060601 "InvalidParameters") (clojure.core/assoc :invalid-parameters (deser-parameter-name-list (clojure.core/get-in letvar2060601 ["InvalidParameters"])))))))

(clojure.core/defn- response-resource-data-sync-not-found-exception ([input] (response-resource-data-sync-not-found-exception nil input)) ([resultWrapper2060603 input] (clojure.core/let [rawinput2060602 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2060604 {"SyncName" (rawinput2060602 "SyncName")}] (clojure.core/cond-> {} (letvar2060604 "SyncName") (clojure.core/assoc :sync-name (deser-resource-data-sync-name (clojure.core/get-in letvar2060604 ["SyncName"])))))))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-string-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-delete-inventory-parameters-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-delete-inventory-parameters-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-delete-inventory-parameters-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/list-tags-for-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/tag-list]))

(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/priority (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/replace (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-request/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm/update-maintenance-window-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-maintenance-window-task-request/window-id :portkey.aws.ssm.update-maintenance-window-task-request/window-task-id] :opt-un [:portkey.aws.ssm.update-maintenance-window-task-request/service-role-arn :portkey.aws.ssm.update-maintenance-window-task-request/priority :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/logging-info :portkey.aws.ssm.update-maintenance-window-task-request/task-arn :portkey.aws.ssm/max-errors :portkey.aws.ssm.update-maintenance-window-task-request/description :portkey.aws.ssm.update-maintenance-window-task-request/replace :portkey.aws.ssm/targets :portkey.aws.ssm.update-maintenance-window-task-request/task-parameters :portkey.aws.ssm.update-maintenance-window-task-request/name :portkey.aws.ssm.update-maintenance-window-task-request/task-invocation-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-automation-status-update-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-automation-status-update-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-automation-status-update-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/string-date-time (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([\-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d(?!:))?)?(\17[0-5]\d([\.,]\d)?)?([zZ]|([\-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-step-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-step-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.automation-step-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/type (clojure.spec.alpha/and :portkey.aws.ssm/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/key-id (clojure.spec.alpha/and :portkey.aws.ssm/parameter-key-id))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/value (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/description (clojure.spec.alpha/and :portkey.aws.ssm/parameter-description))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/labels (clojure.spec.alpha/and :portkey.aws.ssm/parameter-label-list))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/last-modified-user (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/version (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-history/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-history (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-history/type :portkey.aws.ssm.parameter-history/last-modified-date :portkey.aws.ssm.parameter-history/key-id :portkey.aws.ssm.parameter-history/value :portkey.aws.ssm/allowed-pattern :portkey.aws.ssm.parameter-history/description :portkey.aws.ssm.parameter-history/labels :portkey.aws.ssm.parameter-history/last-modified-user :portkey.aws.ssm.parameter-history/version :portkey.aws.ssm.parameter-history/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/attachments-source-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/attachments-source :min-count 0 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm/get-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/stop-automation-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-entity/id (clojure.spec.alpha/and :portkey.aws.ssm/inventory-result-entity-id))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-entity/data (clojure.spec.alpha/and :portkey.aws.ssm/inventory-result-item-map))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-result-entity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.inventory-result-entity/id :portkey.aws.ssm.inventory-result-entity/data]))

(clojure.spec.alpha/def :portkey.aws.ssm/target-map (clojure.spec.alpha/map-of :portkey.aws.ssm/target-map-key :portkey.aws.ssm/target-map-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm/create-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm/command-plugin-output (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 2500))))

(clojure.spec.alpha/def :portkey.aws.ssm.compliance-type-count-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/compliance-type-count-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.compliance-type-count-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.non-compliant-summary/non-compliant-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm/non-compliant-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.non-compliant-summary/non-compliant-count :portkey.aws.ssm/severity-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-deployable-patch-snapshot-for-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm/snapshot-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/association-resource-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-compliance-data-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-compliance-data))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-windows-result/window-identities (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-windows-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-windows-result/window-identities :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-association-execution-targets-request/execution-id (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-association-execution-targets-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-targets-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-association-execution-targets-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/association-id :portkey.aws.ssm.describe-association-execution-targets-request/execution-id] :opt-un [:portkey.aws.ssm.describe-association-execution-targets-request/filters :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-filter-value-set (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-information-filter-value :min-count 1 :max-count 100))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-id :min-count 0 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-parameter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 30))))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 150))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-activation/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-activation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-activation/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/dry-run clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm/approve-after-days (clojure.spec.alpha/int-in 0 100))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-executions-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-executions-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-executions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-maintenance-window-executions-request/window-id] :opt-un [:portkey.aws.ssm.describe-maintenance-window-executions-request/filters :portkey.aws.ssm.describe-maintenance-window-executions-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/string-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/string))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-document-content/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-document-content (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-document-content/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-run-command-parameters/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-run-command-parameters/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-run-command-parameters/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-run-command-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-run-command-parameters/service-role-arn :portkey.aws.ssm/comment :portkey.aws.ssm/timeout-seconds :portkey.aws.ssm/parameters :portkey.aws.ssm.maintenance-window-run-command-parameters/output-s-3-bucket-name :portkey.aws.ssm/notification-config :portkey.aws.ssm/document-hash :portkey.aws.ssm.maintenance-window-run-command-parameters/output-s-3-key-prefix :portkey.aws.ssm/document-hash-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-definition-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-definition-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.automation-definition-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/priority (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/task-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-request/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm/register-task-with-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.register-task-with-maintenance-window-request/window-id :portkey.aws.ssm/targets :portkey.aws.ssm.register-task-with-maintenance-window-request/task-arn :portkey.aws.ssm.register-task-with-maintenance-window-request/task-type :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors] :opt-un [:portkey.aws.ssm.register-task-with-maintenance-window-request/service-role-arn :portkey.aws.ssm.register-task-with-maintenance-window-request/priority :portkey.aws.ssm/logging-info :portkey.aws.ssm.register-task-with-maintenance-window-request/description :portkey.aws.ssm.register-task-with-maintenance-window-request/task-parameters :portkey.aws.ssm.register-task-with-maintenance-window-request/name :portkey.aws.ssm.register-task-with-maintenance-window-request/task-invocation-parameters :portkey.aws.ssm/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-version-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-version-info :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.attachment-information/name (clojure.spec.alpha/and :portkey.aws.ssm/attachment-name))
(clojure.spec.alpha/def :portkey.aws.ssm/attachment-information (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.attachment-information/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-filter-key #{"AutomationType" "StartTimeBefore" "ParentExecutionId" :automation-type :document-name-prefix :parent-execution-id :start-time-before "StartTimeAfter" "CurrentAction" :execution-status "ExecutionId" :current-action :execution-id "ExecutionStatus" "DocumentNamePrefix" :start-time-after})

(clojure.spec.alpha/def :portkey.aws.ssm/output-source-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm/get-parameter-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/parameter]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.label-parameter-version-result/invalid-labels (clojure.spec.alpha/and :portkey.aws.ssm/parameter-label-list))
(clojure.spec.alpha/def :portkey.aws.ssm/label-parameter-version-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.label-parameter-version-result/invalid-labels]))

(clojure.spec.alpha/def :portkey.aws.ssm/command-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm/document-content (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-available-patches-result/patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-available-patches-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-available-patches-result/patches :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-type #{:cross-account "Local" :local "CrossAccount"})

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-filter-value :min-count 1 :max-count 40))

(clojure.spec.alpha/def :portkey.aws.ssm/association-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"([$]LATEST)|([1-9][0-9]*)" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-execution-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/priority (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-task/service-role-arn :portkey.aws.ssm.maintenance-window-task/window-id :portkey.aws.ssm.maintenance-window-task/type :portkey.aws.ssm.maintenance-window-task/priority :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/logging-info :portkey.aws.ssm.maintenance-window-task/task-arn :portkey.aws.ssm/max-errors :portkey.aws.ssm.maintenance-window-task/description :portkey.aws.ssm/targets :portkey.aws.ssm.maintenance-window-task/window-task-id :portkey.aws.ssm.maintenance-window-task/task-parameters :portkey.aws.ssm.maintenance-window-task/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/target-maps (clojure.spec.alpha/coll-of :portkey.aws.ssm/target-map :min-count 0 :max-count 300))

(clojure.spec.alpha/def :portkey.aws.ssm/command-invocation-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/command-invocation))

(clojure.spec.alpha/def :portkey.aws.ssm/association-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-severity (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/automation-execution-metadata))

(clojure.spec.alpha/def :portkey.aws.ssm.document-version-info/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.document-version-info/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.document-version-info/created-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.document-version-info/is-default-version (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.document-version-info/status (clojure.spec.alpha/and :portkey.aws.ssm/document-status))
(clojure.spec.alpha/def :portkey.aws.ssm.document-version-info/status-information (clojure.spec.alpha/and :portkey.aws.ssm/document-status-information))
(clojure.spec.alpha/def :portkey.aws.ssm/document-version-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-version-info/name :portkey.aws.ssm/document-version :portkey.aws.ssm.document-version-info/version-name :portkey.aws.ssm.document-version-info/created-date :portkey.aws.ssm.document-version-info/is-default-version :portkey.aws.ssm/document-format :portkey.aws.ssm.document-version-info/status :portkey.aws.ssm.document-version-info/status-information]))

(clojure.spec.alpha/def :portkey.aws.ssm/service-role (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-enabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.list-documents-result/document-identifiers (clojure.spec.alpha/and :portkey.aws.ssm/document-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-documents-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-documents-result/document-identifiers :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 3 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/association-description-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-description))

(clojure.spec.alpha/def :portkey.aws.ssm/command-status #{:timed-out "Failed" "Cancelled" :in-progress "Cancelling" :pending "TimedOut" "Success" :cancelled :success "InProgress" :cancelling "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm/instance-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"(^i-(\w{8}|\w{17})$)|(^mi-\w{17}$)" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-information-filter :min-count 0))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-entry-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-item-entry :min-count 0 :max-count 10000))

(clojure.spec.alpha/def :portkey.aws.ssm.start-session-request/target (clojure.spec.alpha/and :portkey.aws.ssm/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.start-session-request/document-name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.start-session-request/parameters (clojure.spec.alpha/and :portkey.aws.ssm/session-manager-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm/start-session-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.start-session-request/target] :opt-un [:portkey.aws.ssm.start-session-request/document-name :portkey.aws.ssm.start-session-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm/update-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-status-information (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.list-documents-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/document-key-values-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-documents-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/document-filter-list :portkey.aws.ssm.list-documents-request/filters :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-search-max-results (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.ssm.step-execution-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/step-execution-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/step-execution-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm/step-execution-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.step-execution-filter/key :portkey.aws.ssm.step-execution-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.already-exists-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-type-display-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-group (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameter-history-request/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameter-history-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameter-history-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-parameter-history-request/name] :opt-un [:portkey.aws.ssm.get-parameter-history-request/with-decryption :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.max-document-size-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/max-document-size-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.max-document-size-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-result/version (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm/put-parameter-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.put-parameter-result/version]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-connection-status-request/target (clojure.spec.alpha/and :portkey.aws.ssm/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm/get-connection-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-connection-status-request/target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-action-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^aws:[a-zA-Z]{3,25}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-automation-execution-parameters-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-automation-execution-parameters-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-automation-execution-parameters-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-group-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-group))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-automation-step-executions-result/step-executions (clojure.spec.alpha/and :portkey.aws.ssm/step-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-automation-step-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-automation-step-executions-result/step-executions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item-entry/id (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-id))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item-entry/title (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-title))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item-entry/severity (clojure.spec.alpha/and :portkey.aws.ssm/compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item-entry/status (clojure.spec.alpha/and :portkey.aws.ssm/compliance-status))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item-entry/details (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-details))
(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-entry (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.compliance-item-entry/severity :portkey.aws.ssm.compliance-item-entry/status] :opt-un [:portkey.aws.ssm.compliance-item-entry/id :portkey.aws.ssm.compliance-item-entry/title :portkey.aws.ssm.compliance-item-entry/details]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-schedule/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-schedule/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.patch-filter/key :portkey.aws.ssm.patch-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/association-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/notification-event #{:timed-out "Failed" "Cancelled" :in-progress "TimedOut" :all "Success" :cancelled :success "InProgress" "All" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/status (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/status-details (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/invocation-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-invocation-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/task-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-execution-task-invocation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/task-execution-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/end-time :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/start-time :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/parameters :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/status :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/status-details :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/window-execution-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/invocation-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/execution-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/window-target-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-result/task-type :portkey.aws.ssm/owner-information]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.get-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm/get-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-document-request/name] :opt-un [:portkey.aws.ssm.get-document-request/version-name :portkey.aws.ssm/document-version :portkey.aws.ssm/document-format]))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-information-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/instance-information-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information-filter/value-set (clojure.spec.alpha/and :portkey.aws.ssm/instance-information-filter-value-set))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.instance-information-filter/key :portkey.aws.ssm.instance-information-filter/value-set] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/association-executions-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-execution))

(clojure.spec.alpha/def :portkey.aws.ssm/too-many-tags-error (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-aggregator/expression (clojure.spec.alpha/and :portkey.aws.ssm/inventory-aggregator-expression))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-aggregator/aggregators (clojure.spec.alpha/and :portkey.aws.ssm/inventory-aggregator-list))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-aggregator/groups (clojure.spec.alpha/and :portkey.aws.ssm/inventory-group-list))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-aggregator (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.inventory-aggregator/expression :portkey.aws.ssm.inventory-aggregator/aggregators :portkey.aws.ssm.inventory-aggregator/groups]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-command-invocations-result/command-invocations (clojure.spec.alpha/and :portkey.aws.ssm/command-invocation-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-command-invocations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-command-invocations-result/command-invocations :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-version-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{1,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-maintenance-window-request/window-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-status-infos (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-association-status-info))

(clojure.spec.alpha/def :portkey.aws.ssm.hierarchy-type-mismatch-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/hierarchy-type-mismatch-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.hierarchy-type-mismatch-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-orchestrator-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-orchestrator-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-orchestrator-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.patch-orchestrator-filter/key :portkey.aws.ssm.patch-orchestrator-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm/update-service-setting-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-baseline-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-baseline-identity))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-activation-id/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-activation-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-activation-id/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-type #{"StringList" :string-list :string "String" :secure-string "SecureString"})

(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-does-not-exist/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-does-not-exist (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.association-execution-does-not-exist/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-query-operator-type #{:exists "NotEqual" :less-than "BeginWith" "Exists" "Equal" "LessThan" :greater-than "GreaterThan" :not-equal :begin-with :equal})

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-string-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/parameter-string-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-string-filter/option (clojure.spec.alpha/and :portkey.aws.ssm/parameter-string-query-option))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-string-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/parameter-string-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-string-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.parameter-string-filter/key] :opt-un [:portkey.aws.ssm.parameter-string-filter/option :portkey.aws.ssm.parameter-string-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm/create-activation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/activation-id :portkey.aws.ssm/activation-code]))

(clojure.spec.alpha/def :portkey.aws.ssm/s-3-region (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 3 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 20))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-classification (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-invalid-configuration-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-invalid-configuration-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-data-sync-invalid-configuration-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-tasks-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-execution-tasks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-maintenance-window-execution-tasks-request/window-execution-id] :opt-un [:portkey.aws.ssm.describe-maintenance-window-execution-tasks-request/filters :portkey.aws.ssm.describe-maintenance-window-execution-tasks-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-request/task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-request/invocation-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-invocation-id))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-execution-task-invocation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-maintenance-window-execution-task-invocation-request/window-execution-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-request/task-id :portkey.aws.ssm.get-maintenance-window-execution-task-invocation-request/invocation-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-filter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-option-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-option-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-option-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-result/entities (clojure.spec.alpha/and :portkey.aws.ssm/inventory-result-entity-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-inventory-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-inventory-result/entities :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-filter-key #{:platform-types "DocumentType" :name :document-type "PlatformTypes" "Owner" "Name" :owner})

(clojure.spec.alpha/def :portkey.aws.ssm.list-inventory-entries-result/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.list-inventory-entries-result/schema-version (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.list-inventory-entries-result/capture-time (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-capture-time))
(clojure.spec.alpha/def :portkey.aws.ssm.list-inventory-entries-result/entries (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-inventory-entries-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-inventory-entries-result/type-name :portkey.aws.ssm/instance-id :portkey.aws.ssm.list-inventory-entries-result/schema-version :portkey.aws.ssm.list-inventory-entries-result/capture-time :portkey.aws.ssm.list-inventory-entries-result/entries :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/comment (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm/command-invocation-status #{:timed-out "Failed" "Cancelled" :delayed :in-progress "Cancelling" :pending "TimedOut" "Success" :cancelled "Delayed" :success "InProgress" :cancelling "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm/last-resource-data-sync-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-resource-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm/association-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-id :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm/document-key-values-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/document-key-values-filter :min-count 0 :max-count 6))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-document-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.target-not-connected/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/target-not-connected (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.target-not-connected/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-source/name (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-name))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-source/products (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-product-list))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-source/configuration (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-configuration))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-source (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.patch-source/name :portkey.aws.ssm.patch-source/products :portkey.aws.ssm.patch-source/configuration] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-string-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-string-filter))

(clojure.spec.alpha/def :portkey.aws.ssm.send-automation-signal-request/payload (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm/send-automation-signal-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/automation-execution-id :portkey.aws.ssm/signal-type] :opt-un [:portkey.aws.ssm.send-automation-signal-request/payload]))

(clojure.spec.alpha/def :portkey.aws.ssm.document-identifier/schema-version (clojure.spec.alpha/and :portkey.aws.ssm/document-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.document-identifier/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.document-identifier/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.document-identifier/platform-types (clojure.spec.alpha/and :portkey.aws.ssm/platform-type-list))
(clojure.spec.alpha/def :portkey.aws.ssm.document-identifier/owner (clojure.spec.alpha/and :portkey.aws.ssm/document-owner))
(clojure.spec.alpha/def :portkey.aws.ssm.document-identifier/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/document-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-identifier/schema-version :portkey.aws.ssm/document-type :portkey.aws.ssm/target-type :portkey.aws.ssm.document-identifier/tags :portkey.aws.ssm/document-format :portkey.aws.ssm.document-identifier/version-name :portkey.aws.ssm.document-identifier/platform-types :portkey.aws.ssm.document-identifier/owner :portkey.aws.ssm/document-version :portkey.aws.ssm.document-identifier/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-string-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-information-string-filter :min-count 0))

(clojure.spec.alpha/def :portkey.aws.ssm/command-max-results (clojure.spec.alpha/int-in 1 50))

(clojure.spec.alpha/def :portkey.aws.ssm/association-resource-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-schedule-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-schedule-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-schedule-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-schedule-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-search-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-schedule-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-schedule-request/window-id :portkey.aws.ssm/targets :portkey.aws.ssm.describe-maintenance-window-schedule-request/resource-type :portkey.aws.ssm.describe-maintenance-window-schedule-request/filters :portkey.aws.ssm.describe-maintenance-window-schedule-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-label-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-label :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.deregister-managed-instance-request/instance-id (clojure.spec.alpha/and :portkey.aws.ssm/managed-instance-id))
(clojure.spec.alpha/def :portkey.aws.ssm/deregister-managed-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.deregister-managed-instance-request/instance-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-filter/value (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-filter/type (clojure.spec.alpha/and :portkey.aws.ssm/association-filter-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.association-execution-filter/key :portkey.aws.ssm.association-execution-filter/value :portkey.aws.ssm.association-execution-filter/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/inventory-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/inventory-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-filter/type (clojure.spec.alpha/and :portkey.aws.ssm/inventory-query-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.inventory-filter/key :portkey.aws.ssm.inventory-filter/values] :opt-un [:portkey.aws.ssm.inventory-filter/type]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-type-name-filter (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-filter-value))

(clojure.spec.alpha/def :portkey.aws.ssm/get-parameters-by-path-max-results (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-not-found/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-not-found (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-not-found/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/session-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 96))))

(clojure.spec.alpha/def :portkey.aws.ssm.progress-counters/total-steps (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.progress-counters/success-steps (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.progress-counters/failed-steps (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.progress-counters/cancelled-steps (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.progress-counters/timed-out-steps (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm/progress-counters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.progress-counters/total-steps :portkey.aws.ssm.progress-counters/success-steps :portkey.aws.ssm.progress-counters/failed-steps :portkey.aws.ssm.progress-counters/cancelled-steps :portkey.aws.ssm.progress-counters/timed-out-steps]))

(clojure.spec.alpha/def :portkey.aws.ssm/ps-parameter-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/account-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/account-id :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm/session-max-results (clojure.spec.alpha/int-in 1 200))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-execution-task-identity))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-orchestrator-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-orchestrator-filter :min-count 0 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.cancel-command-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/cancel-command-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/command-id] :opt-un [:portkey.aws.ssm.cancel-command-request/instance-ids]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-cutoff (clojure.spec.alpha/int-in 0 23))

(clojure.spec.alpha/def :portkey.aws.ssm/timeout-seconds (clojure.spec.alpha/int-in 30 2592000))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-s-3-region (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.list-compliance-items-result/compliance-items (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-compliance-items-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-compliance-items-result/compliance-items :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/delivery-timed-out-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-summary-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-summary-item))

(clojure.spec.alpha/def :portkey.aws.ssm/attribute-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/timeout-seconds (clojure.spec.alpha/and :portkey.aws.ssm/long))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/response-code (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/step-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/valid-next-steps (clojure.spec.alpha/and :portkey.aws.ssm/valid-next-step-list))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/outputs (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/response (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/failure-message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/inputs (clojure.spec.alpha/and :portkey.aws.ssm/normal-string-map))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/next-step (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/step-status (clojure.spec.alpha/and :portkey.aws.ssm/automation-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/is-critical (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/step-name (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/overridden-parameters (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/on-failure (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/execution-end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/execution-start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/action (clojure.spec.alpha/and :portkey.aws.ssm/automation-action-name))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/is-end (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.step-execution/max-attempts (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm/step-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.step-execution/timeout-seconds :portkey.aws.ssm.step-execution/response-code :portkey.aws.ssm.step-execution/step-execution-id :portkey.aws.ssm.step-execution/valid-next-steps :portkey.aws.ssm.step-execution/outputs :portkey.aws.ssm.step-execution/response :portkey.aws.ssm.step-execution/failure-message :portkey.aws.ssm.step-execution/inputs :portkey.aws.ssm.step-execution/next-step :portkey.aws.ssm/failure-details :portkey.aws.ssm.step-execution/step-status :portkey.aws.ssm/target-location :portkey.aws.ssm/targets :portkey.aws.ssm.step-execution/is-critical :portkey.aws.ssm.step-execution/step-name :portkey.aws.ssm.step-execution/overridden-parameters :portkey.aws.ssm.step-execution/on-failure :portkey.aws.ssm.step-execution/execution-end-time :portkey.aws.ssm.step-execution/execution-start-time :portkey.aws.ssm.step-execution/action :portkey.aws.ssm.step-execution/is-end :portkey.aws.ssm.step-execution/max-attempts]))

(clojure.spec.alpha/def :portkey.aws.ssm/product (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-installed-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.parameters-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/parameters-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.parameters-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/parameters-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm/parameters-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.parameters-filter/key :portkey.aws.ssm.parameters-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/status-additional-info (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm/completed-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-string-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-string-filter))

(clojure.spec.alpha/def :portkey.aws.ssm/register-default-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.document-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/document-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-awskms-key-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 512)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"arn:.*" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-result/task-ids (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-result/status (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-result/status-details (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-result/start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-result/end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-maintenance-window-execution-result/window-execution-id :portkey.aws.ssm.get-maintenance-window-execution-result/task-ids :portkey.aws.ssm.get-maintenance-window-execution-result/status :portkey.aws.ssm.get-maintenance-window-execution-result/status-details :portkey.aws.ssm.get-maintenance-window-execution-result/start-time :portkey.aws.ssm.get-maintenance-window-execution-result/end-time]))

(clojure.spec.alpha/def :portkey.aws.ssm/put-inventory-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/last-resource-data-sync-status #{"Failed" :in-progress :successful "InProgress" "Successful" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm/error-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm/status-message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-orchestrator-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-filter-option/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-filter-option (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-filter-option/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-effective-patches-for-patch-baseline-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-effective-patches-for-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id] :opt-un [:portkey.aws.ssm.describe-effective-patches-for-patch-baseline-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/terminate-session-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/session-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-rule/compliance-level (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-rule/enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-rule (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/patch-filter-group :portkey.aws.ssm/approve-after-days] :opt-un [:portkey.aws.ssm.patch-rule/compliance-level :portkey.aws.ssm.patch-rule/enable-non-security]))

(clojure.spec.alpha/def :portkey.aws.ssm/execution-mode #{:interactive "Interactive" "Auto" :auto})

(clojure.spec.alpha/def :portkey.aws.ssm.list-tags-for-resource-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/resource-type-for-tagging))
(clojure.spec.alpha/def :portkey.aws.ssm/list-tags-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.list-tags-for-resource-request/resource-type :portkey.aws.ssm/resource-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-content-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm/duplicate-instance-id (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-orchestrator-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/priority (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/task-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-result/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-maintenance-window-task-result/service-role-arn :portkey.aws.ssm.get-maintenance-window-task-result/window-id :portkey.aws.ssm.get-maintenance-window-task-result/priority :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/logging-info :portkey.aws.ssm.get-maintenance-window-task-result/task-arn :portkey.aws.ssm/max-errors :portkey.aws.ssm.get-maintenance-window-task-result/description :portkey.aws.ssm/targets :portkey.aws.ssm.get-maintenance-window-task-result/task-type :portkey.aws.ssm.get-maintenance-window-task-result/window-task-id :portkey.aws.ssm.get-maintenance-window-task-result/task-parameters :portkey.aws.ssm.get-maintenance-window-task-result/name :portkey.aws.ssm.get-maintenance-window-task-result/task-invocation-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-status #{"SUCCESS" :timed-out "IN_PROGRESS" "TIMED_OUT" :in-progress "CANCELLING" :skipped-overlapping :pending "SKIPPED_OVERLAPPING" "PENDING" :cancelled :success "FAILED" "CANCELLED" :cancelling :failed})

(clojure.spec.alpha/def :portkey.aws.ssm/key-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/tag-key))

(clojure.spec.alpha/def :portkey.aws.ssm/output-source (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/output-source-id :portkey.aws.ssm/output-source-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-execution-task-invocations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/window-execution-id :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/task-id] :opt-un [:portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/filters :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-service-setting-request/setting-id (clojure.spec.alpha/and :portkey.aws.ssm/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm/get-service-setting-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-service-setting-request/setting-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-entry (clojure.spec.alpha/map-of :portkey.aws.ssm/attribute-name :portkey.aws.ssm/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/type (clojure.spec.alpha/and :portkey.aws.ssm/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/key-id (clojure.spec.alpha/and :portkey.aws.ssm/parameter-key-id))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/last-modified-user (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/description (clojure.spec.alpha/and :portkey.aws.ssm/parameter-description))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter-metadata/version (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-metadata/name :portkey.aws.ssm.parameter-metadata/type :portkey.aws.ssm.parameter-metadata/key-id :portkey.aws.ssm.parameter-metadata/last-modified-date :portkey.aws.ssm.parameter-metadata/last-modified-user :portkey.aws.ssm.parameter-metadata/description :portkey.aws.ssm/allowed-pattern :portkey.aws.ssm.parameter-metadata/version]))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-resource-id (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.too-many-updates/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/too-many-updates (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.too-many-updates/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-compliance-summaries-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/compliance-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-compliance-summaries-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-compliance-summaries-request/filters :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-targets-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-execution-target))

(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/response-finish-date-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/status (clojure.spec.alpha/and :portkey.aws.ssm/command-plugin-status))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/standard-output-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/output (clojure.spec.alpha/and :portkey.aws.ssm/command-plugin-output))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/name (clojure.spec.alpha/and :portkey.aws.ssm/command-plugin-name))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/standard-error-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm.command-plugin/response-start-date-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/command-plugin (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.command-plugin/response-finish-date-time :portkey.aws.ssm/response-code :portkey.aws.ssm.command-plugin/output-s-3-bucket-name :portkey.aws.ssm.command-plugin/status :portkey.aws.ssm/status-details :portkey.aws.ssm.command-plugin/standard-output-url :portkey.aws.ssm.command-plugin/output-s-3-key-prefix :portkey.aws.ssm.command-plugin/output-s-3-region :portkey.aws.ssm.command-plugin/output :portkey.aws.ssm.command-plugin/name :portkey.aws.ssm.command-plugin/standard-error-url :portkey.aws.ssm.command-plugin/response-start-date-time]))

(clojure.spec.alpha/def :portkey.aws.ssm/cloud-watch-log-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 512)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"[\.\-_/#A-Za-z0-9]+" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/parameters (clojure.spec.alpha/map-of :portkey.aws.ssm/parameter-name :portkey.aws.ssm/parameter-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-filter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/response-code clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.label-parameter-version-request/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.label-parameter-version-request/parameter-version (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.label-parameter-version-request/labels (clojure.spec.alpha/and :portkey.aws.ssm/parameter-label-list))
(clojure.spec.alpha/def :portkey.aws.ssm/label-parameter-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.label-parameter-version-request/name :portkey.aws.ssm.label-parameter-version-request/labels] :opt-un [:portkey.aws.ssm.label-parameter-version-request/parameter-version]))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-patch-group-state-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/patch-group] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameter-request/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameter-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameter-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-parameter-request/name] :opt-un [:portkey.aws.ssm.get-parameter-request/with-decryption]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-type-name-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-type-name-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-type-name-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-invocation-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-execution-task-invocation-identity))

(clojure.spec.alpha/def :portkey.aws.ssm.unsupported-parameter-type/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/unsupported-parameter-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.unsupported-parameter-type/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-output-url (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/s-3-output-url]))

(clojure.spec.alpha/def :portkey.aws.ssm/put-compliance-items-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-s-3-format #{"JsonSerDe" :json-ser-de})

(clojure.spec.alpha/def :portkey.aws.ssm/attachments-source-key #{:source-url "SourceUrl"})

(clojure.spec.alpha/def :portkey.aws.ssm/document-type #{"Automation" :package "Package" :command :policy "Command" :automation "Policy" "Session" :session})

(clojure.spec.alpha/def :portkey.aws.ssm.item-content-mismatch-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.item-content-mismatch-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/item-content-mismatch-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.item-content-mismatch-exception/type-name :portkey.aws.ssm.item-content-mismatch-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameters-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.association-execution/execution-id (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution/status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution/created-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/association-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-id :portkey.aws.ssm/association-version :portkey.aws.ssm.association-execution/execution-id :portkey.aws.ssm.association-execution/status :portkey.aws.ssm.association-execution/detailed-status :portkey.aws.ssm.association-execution/created-time :portkey.aws.ssm.association-execution/last-execution-date :portkey.aws.ssm/resource-count-by-status]))

(clojure.spec.alpha/def :portkey.aws.ssm.document-parameter/name (clojure.spec.alpha/and :portkey.aws.ssm/document-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.document-parameter/type (clojure.spec.alpha/and :portkey.aws.ssm/document-parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.document-parameter/description (clojure.spec.alpha/and :portkey.aws.ssm/document-parameter-descrption))
(clojure.spec.alpha/def :portkey.aws.ssm.document-parameter/default-value (clojure.spec.alpha/and :portkey.aws.ssm/document-parameter-default-value))
(clojure.spec.alpha/def :portkey.aws.ssm/document-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-parameter/name :portkey.aws.ssm.document-parameter/type :portkey.aws.ssm.document-parameter/description :portkey.aws.ssm.document-parameter/default-value]))

(clojure.spec.alpha/def :portkey.aws.ssm.document-permission-limit/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/document-permission-limit (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-permission-limit/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.severity-summary/critical-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.severity-summary/high-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.severity-summary/medium-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.severity-summary/low-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.severity-summary/informational-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.severity-summary/unspecified-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm/severity-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.severity-summary/critical-count :portkey.aws.ssm.severity-summary/high-count :portkey.aws.ssm.severity-summary/medium-count :portkey.aws.ssm.severity-summary/low-count :portkey.aws.ssm.severity-summary/informational-count :portkey.aws.ssm.severity-summary/unspecified-count]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-inventory-schema-max-results (clojure.spec.alpha/int-in 50 200))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/automation-execution-filter :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.hierarchy-level-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/hierarchy-level-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.hierarchy-level-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity-for-target/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity-for-target/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-identity-for-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-identity-for-target/window-id :portkey.aws.ssm.maintenance-window-identity-for-target/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-deployment-status #{:explicit-approved :explicit-rejected :approved :pending-approval "APPROVED" "PENDING_APPROVAL" "EXPLICIT_APPROVED" "EXPLICIT_REJECTED"})

(clojure.spec.alpha/def :portkey.aws.ssm/session-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/session-filter :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/parameters (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/parent-automation-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/automation-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/current-step-name (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/executed-by (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/current-action (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/mode (clojure.spec.alpha/and :portkey.aws.ssm/execution-mode))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/outputs (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/failure-message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/step-executions (clojure.spec.alpha/and :portkey.aws.ssm/step-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/target (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/target-parameter-name (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/execution-end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/execution-start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution/step-executions-truncated (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/target-maps :portkey.aws.ssm/progress-counters :portkey.aws.ssm.automation-execution/parameters :portkey.aws.ssm.automation-execution/parent-automation-execution-id :portkey.aws.ssm.automation-execution/current-step-name :portkey.aws.ssm.automation-execution/executed-by :portkey.aws.ssm.automation-execution/current-action :portkey.aws.ssm/target-locations :portkey.aws.ssm.automation-execution/mode :portkey.aws.ssm.automation-execution/outputs :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/resolved-targets :portkey.aws.ssm.automation-execution/failure-message :portkey.aws.ssm/max-errors :portkey.aws.ssm.automation-execution/step-executions :portkey.aws.ssm/automation-execution-status :portkey.aws.ssm/targets :portkey.aws.ssm/document-name :portkey.aws.ssm/document-version :portkey.aws.ssm.automation-execution/target :portkey.aws.ssm.automation-execution/target-parameter-name :portkey.aws.ssm.automation-execution/execution-end-time :portkey.aws.ssm.automation-execution/execution-start-time :portkey.aws.ssm/automation-execution-id :portkey.aws.ssm.automation-execution/step-executions-truncated]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-content-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-association-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-windows-for-target-result/window-identities (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-windows-for-target-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-windows-for-target-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-windows-for-target-result/window-identities :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameters-filter-key #{"Type" :key-id :name "KeyId" :type "Name"})

(clojure.spec.alpha/def :portkey.aws.ssm.unsupported-inventory-item-context-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.unsupported-inventory-item-context-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/unsupported-inventory-item-context-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.unsupported-inventory-item-context-exception/type-name :portkey.aws.ssm.unsupported-inventory-item-context-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.cancel-maintenance-window-execution-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm/cancel-maintenance-window-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.cancel-maintenance-window-execution-result/window-execution-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.create-association-batch-result/successful (clojure.spec.alpha/and :portkey.aws.ssm/association-description-list))
(clojure.spec.alpha/def :portkey.aws.ssm.create-association-batch-result/failed (clojure.spec.alpha/and :portkey.aws.ssm/failed-create-association-list))
(clojure.spec.alpha/def :portkey.aws.ssm/create-association-batch-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.create-association-batch-result/successful :portkey.aws.ssm.create-association-batch-result/failed]))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-group/name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-group-name))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-group/filters (clojure.spec.alpha/and :portkey.aws.ssm/inventory-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-group (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.inventory-group/name :portkey.aws.ssm.inventory-group/filters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-title (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 500))))

(clojure.spec.alpha/def :portkey.aws.ssm/document-key-values-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm/document-key-values-filter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.document-key-values-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/document-key-values-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.document-key-values-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/document-key-values-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm/document-key-values-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-key-values-filter/key :portkey.aws.ssm.document-key-values-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-targets-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-targets-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-targets-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-targets-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-maintenance-window-targets-request/window-id] :opt-un [:portkey.aws.ssm.describe-maintenance-window-targets-request/filters :portkey.aws.ssm.describe-maintenance-window-targets-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/end-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/enabled (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/duration (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/cutoff (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/replace (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/schedule (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/start-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-request/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm/update-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-maintenance-window-request/window-id] :opt-un [:portkey.aws.ssm.update-maintenance-window-request/allow-unassociated-targets :portkey.aws.ssm.update-maintenance-window-request/end-date :portkey.aws.ssm.update-maintenance-window-request/enabled :portkey.aws.ssm.update-maintenance-window-request/description :portkey.aws.ssm.update-maintenance-window-request/duration :portkey.aws.ssm.update-maintenance-window-request/cutoff :portkey.aws.ssm.update-maintenance-window-request/replace :portkey.aws.ssm.update-maintenance-window-request/schedule :portkey.aws.ssm.update-maintenance-window-request/name :portkey.aws.ssm.update-maintenance-window-request/start-date :portkey.aws.ssm.update-maintenance-window-request/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-result/invalid-parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-parameters-result/parameters :portkey.aws.ssm.get-parameters-result/invalid-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm/tag-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-filter/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-filter/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-association))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-execution))

(clojure.spec.alpha/def :portkey.aws.ssm/platform-type #{:windows "Windows" "Linux" :linux})

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-name-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/ps-parameter-name :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-aggregated-association-overview/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-aggregated-association-overview (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.instance-aggregated-association-overview/detailed-status :portkey.aws.ssm/instance-association-status-aggregated-count]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/end-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/enabled (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/next-execution-time (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/duration (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/created-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/cutoff (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/schedule (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/start-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-result/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-maintenance-window-result/window-id :portkey.aws.ssm.get-maintenance-window-result/allow-unassociated-targets :portkey.aws.ssm.get-maintenance-window-result/end-date :portkey.aws.ssm.get-maintenance-window-result/enabled :portkey.aws.ssm.get-maintenance-window-result/next-execution-time :portkey.aws.ssm.get-maintenance-window-result/description :portkey.aws.ssm.get-maintenance-window-result/duration :portkey.aws.ssm.get-maintenance-window-result/created-date :portkey.aws.ssm.get-maintenance-window-result/cutoff :portkey.aws.ssm.get-maintenance-window-result/modified-date :portkey.aws.ssm.get-maintenance-window-result/schedule :portkey.aws.ssm.get-maintenance-window-result/name :portkey.aws.ssm.get-maintenance-window-result/start-date :portkey.aws.ssm.get-maintenance-window-result/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm/target-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 200)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^\/[\w\.\-\:\/]*$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.create-document-request/content (clojure.spec.alpha/and :portkey.aws.ssm/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.create-document-request/attachments (clojure.spec.alpha/and :portkey.aws.ssm/attachments-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.create-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.create-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.create-document-request/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm/create-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-document-request/content :portkey.aws.ssm.create-document-request/name] :opt-un [:portkey.aws.ssm.create-document-request/attachments :portkey.aws.ssm.create-document-request/version-name :portkey.aws.ssm/document-type :portkey.aws.ssm/document-format :portkey.aws.ssm/target-type :portkey.aws.ssm.create-document-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-s-3-prefix (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.delete-resource-data-sync-request/sync-name (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-resource-data-sync-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.delete-resource-data-sync-request/sync-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.deregister-task-from-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.deregister-task-from-maintenance-window-request/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm/deregister-task-from-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.deregister-task-from-maintenance-window-request/window-id :portkey.aws.ssm.deregister-task-from-maintenance-window-request/window-task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.total-size-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/total-size-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.total-size-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.target-in-use-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/target-in-use-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.target-in-use-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-in-use-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-in-use-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-in-use-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/reset-service-setting-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/service-setting]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-deletion-id-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-deletion-id-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-deletion-id-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.notification-config/notification-events (clojure.spec.alpha/and :portkey.aws.ssm/notification-event-list))
(clojure.spec.alpha/def :portkey.aws.ssm/notification-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/notification-arn :portkey.aws.ssm.notification-config/notification-events :portkey.aws.ssm/notification-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/log-file (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/parent-automation-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/automation-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/current-step-name (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/executed-by (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/current-action (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/mode (clojure.spec.alpha/and :portkey.aws.ssm/execution-mode))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/outputs (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/failure-message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/target (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/target-parameter-name (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/execution-end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-metadata/execution-start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/automation-type :portkey.aws.ssm/target-maps :portkey.aws.ssm.automation-execution-metadata/log-file :portkey.aws.ssm.automation-execution-metadata/parent-automation-execution-id :portkey.aws.ssm.automation-execution-metadata/current-step-name :portkey.aws.ssm.automation-execution-metadata/executed-by :portkey.aws.ssm.automation-execution-metadata/current-action :portkey.aws.ssm.automation-execution-metadata/mode :portkey.aws.ssm.automation-execution-metadata/outputs :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/resolved-targets :portkey.aws.ssm.automation-execution-metadata/failure-message :portkey.aws.ssm/max-errors :portkey.aws.ssm/automation-execution-status :portkey.aws.ssm/targets :portkey.aws.ssm/document-name :portkey.aws.ssm/document-version :portkey.aws.ssm.automation-execution-metadata/target :portkey.aws.ssm.automation-execution-metadata/target-parameter-name :portkey.aws.ssm.automation-execution-metadata/execution-end-time :portkey.aws.ssm.automation-execution-metadata/execution-start-time :portkey.aws.ssm/automation-execution-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/s-3-bucket-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 3 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 63))))

(clojure.spec.alpha/def :portkey.aws.ssm/ping-status #{:inactive "Inactive" "ConnectionLost" :online :connection-lost "Online"})

(clojure.spec.alpha/def :portkey.aws.ssm/describe-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-summary-items (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-deletion-summary-item))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-item))

(clojure.spec.alpha/def :portkey.aws.ssm/document-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-windows-for-target-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-windows-for-target-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-search-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-windows-for-target-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/targets :portkey.aws.ssm.describe-maintenance-windows-for-target-request/resource-type] :opt-un [:portkey.aws.ssm.describe-maintenance-windows-for-target-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-result-entity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-result-entity))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-filter :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-executions-result/window-executions (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-executions-result/window-executions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-targets-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-execution-targets-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm/parameters-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameters-filter-value :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item-schema/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item-schema/version (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item-schema/attributes (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-attribute-list))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item-schema/display-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-type-display-name))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-schema (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.inventory-item-schema/type-name :portkey.aws.ssm.inventory-item-schema/attributes] :opt-un [:portkey.aws.ssm.inventory-item-schema/version :portkey.aws.ssm.inventory-item-schema/display-name]))

(clojure.spec.alpha/def :portkey.aws.ssm/iam-role (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/end-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/duration (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/cutoff (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/schedule (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/start-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-request/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm/create-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-maintenance-window-request/name :portkey.aws.ssm.create-maintenance-window-request/schedule :portkey.aws.ssm.create-maintenance-window-request/duration :portkey.aws.ssm.create-maintenance-window-request/cutoff :portkey.aws.ssm.create-maintenance-window-request/allow-unassociated-targets] :opt-un [:portkey.aws.ssm.create-maintenance-window-request/end-date :portkey.aws.ssm.create-maintenance-window-request/tags :portkey.aws.ssm.create-maintenance-window-request/description :portkey.aws.ssm/client-token :portkey.aws.ssm.create-maintenance-window-request/start-date :portkey.aws.ssm.create-maintenance-window-request/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-severity #{"INFORMATIONAL" :unspecified "CRITICAL" :medium "LOW" :high :critical "HIGH" :low "UNSPECIFIED" :informational "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.ssm/session-state #{"Active" :history "History" :active})

(clojure.spec.alpha/def :portkey.aws.ssm/register-patch-baseline-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/patch-group]))

(clojure.spec.alpha/def :portkey.aws.ssm/notification-type #{:command :invocation "Command" "Invocation"})

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/deletion-id (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-id))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/deletion-start-time (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-start-time))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/last-status (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-status))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/last-status-message (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-last-status-message))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/deletion-summary (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-status-item/last-status-update-time (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-last-status-update-time))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-status-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.inventory-deletion-status-item/deletion-id :portkey.aws.ssm.inventory-deletion-status-item/type-name :portkey.aws.ssm.inventory-deletion-status-item/deletion-start-time :portkey.aws.ssm.inventory-deletion-status-item/last-status :portkey.aws.ssm.inventory-deletion-status-item/last-status-message :portkey.aws.ssm.inventory-deletion-status-item/deletion-summary :portkey.aws.ssm.inventory-deletion-status-item/last-status-update-time]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-lambda-payload clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.ssm.result-attribute/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm/result-attribute (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.result-attribute/type-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1600))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-lambda-qualifier (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-compliance-data/title (clojure.spec.alpha/and :portkey.aws.ssm/patch-title))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-compliance-data/kb-id (clojure.spec.alpha/and :portkey.aws.ssm/patch-kb-number))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-compliance-data/classification (clojure.spec.alpha/and :portkey.aws.ssm/patch-classification))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-compliance-data/severity (clojure.spec.alpha/and :portkey.aws.ssm/patch-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-compliance-data/state (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-data-state))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-compliance-data/installed-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-compliance-data (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.patch-compliance-data/title :portkey.aws.ssm.patch-compliance-data/kb-id :portkey.aws.ssm.patch-compliance-data/classification :portkey.aws.ssm.patch-compliance-data/severity :portkey.aws.ssm.patch-compliance-data/state :portkey.aws.ssm.patch-compliance-data/installed-time] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/target-map-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletions-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-deletion-status-item))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-msrc-number (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.idempotent-parameter-mismatch/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/idempotent-parameter-mismatch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.idempotent-parameter-mismatch/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-missing-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.scheduled-window-execution/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.scheduled-window-execution/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.scheduled-window-execution/execution-time (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/scheduled-window-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.scheduled-window-execution/window-id :portkey.aws.ssm.scheduled-window-execution/name :portkey.aws.ssm.scheduled-window-execution/execution-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.association-status/date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-status/name (clojure.spec.alpha/and :portkey.aws.ssm/association-status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.association-status/message (clojure.spec.alpha/and :portkey.aws.ssm/status-message))
(clojure.spec.alpha/def :portkey.aws.ssm.association-status/additional-info (clojure.spec.alpha/and :portkey.aws.ssm/status-additional-info))
(clojure.spec.alpha/def :portkey.aws.ssm/association-status (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.association-status/date :portkey.aws.ssm.association-status/name :portkey.aws.ssm.association-status/message] :opt-un [:portkey.aws.ssm.association-status/additional-info]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-parameter-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-resource-type (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-document-permission-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-document-permission-request/permission-type (clojure.spec.alpha/and :portkey.aws.ssm/document-permission-type))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-document-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-document-permission-request/name :portkey.aws.ssm.describe-document-permission-request/permission-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/attachment-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm/start-automation-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/automation-execution-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-parameter-descrption (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-associations-status-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/instance-association-status-infos :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/snapshot-download-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/create-resource-data-sync-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-tasks-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-tasks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-maintenance-window-tasks-request/window-id] :opt-un [:portkey.aws.ssm.describe-maintenance-window-tasks-request/filters :portkey.aws.ssm.describe-maintenance-window-tasks-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-resource-compliance-summaries-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/compliance-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-resource-compliance-summaries-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-resource-compliance-summaries-request/filters :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-already-exists (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-attribute-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.update-association-status-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/update-association-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-association-status-request/name :portkey.aws.ssm/instance-id :portkey.aws.ssm/association-status] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/target-locations (clojure.spec.alpha/coll-of :portkey.aws.ssm/target-location :min-count 1 :max-count 100))

(clojure.spec.alpha/def :portkey.aws.ssm/start-associations-once-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-parameters-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/parameters-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-parameters-request/parameter-filters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-parameters-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-parameters-request/filters :portkey.aws.ssm.describe-parameters-request/parameter-filters :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/deregister-patch-baseline-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/patch-group] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/priority (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-task-result/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm/update-maintenance-window-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.update-maintenance-window-task-result/service-role-arn :portkey.aws.ssm.update-maintenance-window-task-result/window-id :portkey.aws.ssm.update-maintenance-window-task-result/priority :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/logging-info :portkey.aws.ssm.update-maintenance-window-task-result/task-arn :portkey.aws.ssm/max-errors :portkey.aws.ssm.update-maintenance-window-task-result/description :portkey.aws.ssm/targets :portkey.aws.ssm.update-maintenance-window-task-result/window-task-id :portkey.aws.ssm.update-maintenance-window-task-result/task-parameters :portkey.aws.ssm.update-maintenance-window-task-result/name :portkey.aws.ssm.update-maintenance-window-task-result/task-invocation-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-filter-key #{"InstanceId" :association-id "AssociationId" :name :association-name :instance-id "LastExecutedBefore" "AssociationName" :association-status-name "AssociationStatusName" :last-executed-after "Name" :last-executed-before "LastExecutedAfter"})

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patch-states-for-patch-group-result/instance-patch-states (clojure.spec.alpha/and :portkey.aws.ssm/instance-patch-states-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-patch-states-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-instance-patch-states-for-patch-group-result/instance-patch-states :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-installed-rejected-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/status-details (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-already-exists/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-already-exists (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-already-exists/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-compliance-summaries-result/compliance-summary-items (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-compliance-summaries-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-compliance-summaries-result/compliance-summary-items :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-schema-delete-option #{:delete-schema "DeleteSchema" "DisableSchema" :disable-schema})

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-parameters (clojure.spec.alpha/map-of :portkey.aws.ssm/maintenance-window-task-parameter-name :portkey.aws.ssm/maintenance-window-task-parameter-value-expression))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-baseline-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/baseline-name :portkey.aws.ssm/operating-system :portkey.aws.ssm/baseline-description :portkey.aws.ssm/default-baseline]))

(clojure.spec.alpha/def :portkey.aws.ssm/list-association-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/association-id] :opt-un [:portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/next-token (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/standard-output-content (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 24000))))

(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/session-manager-parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-s-3-destination/bucket-name (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-s-3-destination/prefix (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-s-3-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-s-3-destination/sync-format (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-s-3-format))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-s-3-destination/region (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-s-3-destination/awskms-key-arn (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-awskms-key-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-s-3-destination (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.resource-data-sync-s-3-destination/bucket-name :portkey.aws.ssm.resource-data-sync-s-3-destination/sync-format :portkey.aws.ssm.resource-data-sync-s-3-destination/region] :opt-un [:portkey.aws.ssm.resource-data-sync-s-3-destination/prefix :portkey.aws.ssm.resource-data-sync-s-3-destination/awskms-key-arn]))

(clojure.spec.alpha/def :portkey.aws.ssm/agent-error-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 10))))

(clojure.spec.alpha/def :portkey.aws.ssm/document-owner (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/aggregator-schema-only clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-instance-information-filter-value/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-instance-information-filter-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-instance-information-filter-value/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/cloud-watch-output-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/cloud-watch-log-group-name :portkey.aws.ssm/cloud-watch-output-enabled]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-parameter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/document-parameter))

(clojure.spec.alpha/def :portkey.aws.ssm/document-sha-1 (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.cancel-maintenance-window-execution-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm/cancel-maintenance-window-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.cancel-maintenance-window-execution-request/window-execution-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-string-query-option (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 10))))

(clojure.spec.alpha/def :portkey.aws.ssm/connection-status #{:not-connected "Connected" :connected "NotConnected"})

(clojure.spec.alpha/def :portkey.aws.ssm/patch-baseline-max-results (clojure.spec.alpha/int-in 1 100))

(clojure.spec.alpha/def :portkey.aws.ssm/document-version-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/document-version-info :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.update-document-default-version-result/description (clojure.spec.alpha/and :portkey.aws.ssm/document-default-version-description))
(clojure.spec.alpha/def :portkey.aws.ssm/update-document-default-version-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.update-document-default-version-result/description]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-metadata))

(clojure.spec.alpha/def :portkey.aws.ssm/default-instance-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-filter-key #{"InstanceIds" "ActivationIds" :platform-types :iam-role "PingStatus" "IamRole" "AgentVersion" "AssociationStatus" :association-status "ResourceType" :instance-ids "PlatformTypes" :resource-type :agent-version :activation-ids :ping-status})

(clojure.spec.alpha/def :portkey.aws.ssm.register-target-with-maintenance-window-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm/register-target-with-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.register-target-with-maintenance-window-result/window-target-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm.does-not-exist-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/does-not-exist-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.does-not-exist-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/session-target (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/session-owner (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm/expiration-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.delete-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.delete-maintenance-window-request/window-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-priority (clojure.spec.alpha/int-in 0 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.ssm/session-status #{"Failed" "Connected" :disconnected :connecting :connected "Disconnected" :terminating "Connecting" "Terminating" :terminated "Terminated" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm/document-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.:/]{3,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.list-inventory-entries-request/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.list-inventory-entries-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/inventory-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-inventory-entries-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm.list-inventory-entries-request/type-name] :opt-un [:portkey.aws.ssm.list-inventory-entries-request/filters :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.unsupported-platform-type/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/unsupported-platform-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.unsupported-platform-type/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-result-entity-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm/effective-patch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/patch :portkey.aws.ssm/patch-status]))

(clojure.spec.alpha/def :portkey.aws.ssm/max-concurrency (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 7)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([1-9][0-9]*|[1-9][0-9]%|[1-9]%|100%)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patches-result/patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-data-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-patches-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-instance-patches-result/patches :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-filter/key :portkey.aws.ssm.maintenance-window-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.resolved-targets/parameter-values (clojure.spec.alpha/and :portkey.aws.ssm/target-parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.resolved-targets/truncated (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/resolved-targets (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resolved-targets/parameter-values :portkey.aws.ssm.resolved-targets/truncated]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-states-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-patch-state :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-start-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm/patch-action #{:block "BLOCK" "ALLOW_AS_DEPENDENCY" :allow-as-dependency})

(clojure.spec.alpha/def :portkey.aws.ssm/status-unchanged (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/status (clojure.spec.alpha/and :portkey.aws.ssm/command-invocation-status))
(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/command-plugins (clojure.spec.alpha/and :portkey.aws.ssm/command-plugin-list))
(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/instance-name (clojure.spec.alpha/and :portkey.aws.ssm/instance-tag-name))
(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/requested-date-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/standard-output-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/trace-output (clojure.spec.alpha/and :portkey.aws.ssm/invocation-trace-output))
(clojure.spec.alpha/def :portkey.aws.ssm.command-invocation/standard-error-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm/command-invocation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/service-role :portkey.aws.ssm/instance-id :portkey.aws.ssm/comment :portkey.aws.ssm/notification-config :portkey.aws.ssm.command-invocation/status :portkey.aws.ssm/status-details :portkey.aws.ssm/cloud-watch-output-config :portkey.aws.ssm.command-invocation/command-plugins :portkey.aws.ssm.command-invocation/instance-name :portkey.aws.ssm.command-invocation/requested-date-time :portkey.aws.ssm.command-invocation/standard-output-url :portkey.aws.ssm.command-invocation/trace-output :portkey.aws.ssm/command-id :portkey.aws.ssm/document-name :portkey.aws.ssm/document-version :portkey.aws.ssm.command-invocation/standard-error-url]))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-command-id (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/stop-type #{"Cancel" "Complete" :cancel :complete})

(clojure.spec.alpha/def :portkey.aws.ssm.compliant-summary/compliant-count (clojure.spec.alpha/and :portkey.aws.ssm/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm/compliant-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.compliant-summary/compliant-count :portkey.aws.ssm/severity-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm/list-associations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-filter-list :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/regions (clojure.spec.alpha/coll-of :portkey.aws.ssm/region :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm/cancel-command-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.start-automation-execution-request/parameters (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.start-automation-execution-request/mode (clojure.spec.alpha/and :portkey.aws.ssm/execution-mode))
(clojure.spec.alpha/def :portkey.aws.ssm.start-automation-execution-request/document-name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.start-automation-execution-request/target-parameter-name (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.start-automation-execution-request/client-token (clojure.spec.alpha/and :portkey.aws.ssm/idempotency-token))
(clojure.spec.alpha/def :portkey.aws.ssm/start-automation-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.start-automation-execution-request/document-name] :opt-un [:portkey.aws.ssm/target-maps :portkey.aws.ssm.start-automation-execution-request/parameters :portkey.aws.ssm/target-locations :portkey.aws.ssm.start-automation-execution-request/mode :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm/targets :portkey.aws.ssm/document-version :portkey.aws.ssm.start-automation-execution-request/target-parameter-name :portkey.aws.ssm.start-automation-execution-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.create-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm/create-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.create-maintenance-window-result/window-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/step-execution-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 150))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-compliance-max-results (clojure.spec.alpha/int-in 10 100))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-inventory-deletions-request/deletion-id (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-id))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-inventory-deletions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-inventory-deletions-request/deletion-id :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-patch-state-filter-value :min-count 1 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.automation-execution-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-association-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-association-request/name :portkey.aws.ssm/instance-id :portkey.aws.ssm/association-id :portkey.aws.ssm/association-version]))

(clojure.spec.alpha/def :portkey.aws.ssm/signal-type #{:stop-step :approve "Resume" "StopStep" "StartStep" "Approve" :reject :resume :start-step "Reject"})

(clojure.spec.alpha/def :portkey.aws.ssm/session-details (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/sync-name (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/s-3-destination (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-s-3-destination))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/last-sync-time (clojure.spec.alpha/and :portkey.aws.ssm/last-resource-data-sync-time))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/last-successful-sync-time (clojure.spec.alpha/and :portkey.aws.ssm/last-successful-resource-data-sync-time))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/last-status (clojure.spec.alpha/and :portkey.aws.ssm/last-resource-data-sync-status))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/sync-created-time (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-created-time))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-item/last-sync-status-message (clojure.spec.alpha/and :portkey.aws.ssm/last-resource-data-sync-message))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-data-sync-item/sync-name :portkey.aws.ssm.resource-data-sync-item/s-3-destination :portkey.aws.ssm.resource-data-sync-item/last-sync-time :portkey.aws.ssm.resource-data-sync-item/last-successful-sync-time :portkey.aws.ssm.resource-data-sync-item/last-status :portkey.aws.ssm.resource-data-sync-item/sync-created-time :portkey.aws.ssm.resource-data-sync-item/last-sync-status-message]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm/cloud-watch-output-enabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patches-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patches-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-patches-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id] :opt-un [:portkey.aws.ssm.describe-instance-patches-request/filters :portkey.aws.ssm/next-token :portkey.aws.ssm.describe-instance-patches-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-document/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-document (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-document/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/update-association-status-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-pattern-mismatch-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-pattern-mismatch-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-pattern-mismatch-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-result-attribute-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-result-attribute-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-result-attribute-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-label (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances-with-installed-patches (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances-with-installed-other-patches (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances-with-installed-rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm/instances-count))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances-with-missing-patches (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances-with-failed-patches (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-group-state-result/instances-with-not-applicable-patches (clojure.spec.alpha/and :portkey.aws.ssm/integer))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-patch-group-state-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-patch-group-state-result/instances :portkey.aws.ssm.describe-patch-group-state-result/instances-with-installed-patches :portkey.aws.ssm.describe-patch-group-state-result/instances-with-installed-other-patches :portkey.aws.ssm.describe-patch-group-state-result/instances-with-installed-rejected-patches :portkey.aws.ssm.describe-patch-group-state-result/instances-with-missing-patches :portkey.aws.ssm.describe-patch-group-state-result/instances-with-failed-patches :portkey.aws.ssm.describe-patch-group-state-result/instances-with-not-applicable-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm.association-description/last-update-association-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/status (clojure.spec.alpha/and :portkey.aws.ssm/association-status))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/overview (clojure.spec.alpha/and :portkey.aws.ssm/association-overview))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/last-successful-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.association-description/output-location (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm/association-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-version :portkey.aws.ssm/instance-id :portkey.aws.ssm.association-description/last-update-association-date :portkey.aws.ssm/parameters :portkey.aws.ssm/association-id :portkey.aws.ssm.association-description/compliance-severity :portkey.aws.ssm.association-description/status :portkey.aws.ssm.association-description/overview :portkey.aws.ssm.association-description/date :portkey.aws.ssm/max-concurrency :portkey.aws.ssm.association-description/last-execution-date :portkey.aws.ssm/max-errors :portkey.aws.ssm/automation-target-parameter-name :portkey.aws.ssm/association-name :portkey.aws.ssm/targets :portkey.aws.ssm.association-description/last-successful-execution-date :portkey.aws.ssm/schedule-expression :portkey.aws.ssm/document-version :portkey.aws.ssm.association-description/name :portkey.aws.ssm.association-description/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-commands-result/commands (clojure.spec.alpha/and :portkey.aws.ssm/command-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-commands-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-commands-result/commands :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/tag-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/tag :max-count 1000))

(clojure.spec.alpha/def :portkey.aws.ssm/create-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.document-description/schema-version (clojure.spec.alpha/and :portkey.aws.ssm/document-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/parameters (clojure.spec.alpha/and :portkey.aws.ssm/document-parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/hash (clojure.spec.alpha/and :portkey.aws.ssm/document-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/status (clojure.spec.alpha/and :portkey.aws.ssm/document-status))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/status-information (clojure.spec.alpha/and :portkey.aws.ssm/document-status-information))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/attachments-information (clojure.spec.alpha/and :portkey.aws.ssm/attachment-information-list))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/default-version (clojure.spec.alpha/and :portkey.aws.ssm/document-version))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/description (clojure.spec.alpha/and :portkey.aws.ssm/description-in-document))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/created-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/platform-types (clojure.spec.alpha/and :portkey.aws.ssm/platform-type-list))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/latest-version (clojure.spec.alpha/and :portkey.aws.ssm/document-version))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/owner (clojure.spec.alpha/and :portkey.aws.ssm/document-owner))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/hash-type (clojure.spec.alpha/and :portkey.aws.ssm/document-hash-type))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.document-description/sha-1 (clojure.spec.alpha/and :portkey.aws.ssm/document-sha-1))
(clojure.spec.alpha/def :portkey.aws.ssm/document-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-description/schema-version :portkey.aws.ssm.document-description/parameters :portkey.aws.ssm/document-type :portkey.aws.ssm/target-type :portkey.aws.ssm.document-description/tags :portkey.aws.ssm.document-description/hash :portkey.aws.ssm.document-description/status :portkey.aws.ssm.document-description/status-information :portkey.aws.ssm.document-description/attachments-information :portkey.aws.ssm.document-description/default-version :portkey.aws.ssm.document-description/description :portkey.aws.ssm.document-description/created-date :portkey.aws.ssm/document-format :portkey.aws.ssm.document-description/version-name :portkey.aws.ssm.document-description/platform-types :portkey.aws.ssm.document-description/latest-version :portkey.aws.ssm.document-description/owner :portkey.aws.ssm.document-description/hash-type :portkey.aws.ssm/document-version :portkey.aws.ssm.document-description/name :portkey.aws.ssm.document-description/sha-1]))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-target/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-target/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-target/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-target/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-target/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-target/window-id :portkey.aws.ssm.maintenance-window-target/window-target-id :portkey.aws.ssm.maintenance-window-target/resource-type :portkey.aws.ssm/targets :portkey.aws.ssm/owner-information :portkey.aws.ssm.maintenance-window-target/name :portkey.aws.ssm.maintenance-window-target/description]))

(clojure.spec.alpha/def :portkey.aws.ssm.compliance-string-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/compliance-string-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-string-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/compliance-string-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-string-filter/type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-query-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm/compliance-string-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.compliance-string-filter/key :portkey.aws.ssm.compliance-string-filter/values :portkey.aws.ssm.compliance-string-filter/type]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-last-status-update-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"[A-Za-z0-9_\-]\w+|Custom:[a-zA-Z0-9_\-]\w+" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-id :min-count 0 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.create-association-request/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.create-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.create-association-request/output-location (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm/create-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-association-request/name] :opt-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm/parameters :portkey.aws.ssm.create-association-request/compliance-severity :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm/automation-target-parameter-name :portkey.aws.ssm/association-name :portkey.aws.ssm/targets :portkey.aws.ssm/schedule-expression :portkey.aws.ssm/document-version :portkey.aws.ssm.create-association-request/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-automation-step-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/step-execution-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-automation-step-executions-request/reverse-order (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-automation-step-executions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/automation-execution-id] :opt-un [:portkey.aws.ssm.describe-automation-step-executions-request/filters :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results :portkey.aws.ssm.describe-automation-step-executions-request/reverse-order]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-invocation-parameters (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.put-compliance-items-request/resource-id (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.put-compliance-items-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.put-compliance-items-request/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.put-compliance-items-request/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm/compliance-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.put-compliance-items-request/items (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm.put-compliance-items-request/item-content-hash (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-content-hash))
(clojure.spec.alpha/def :portkey.aws.ssm/put-compliance-items-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.put-compliance-items-request/resource-id :portkey.aws.ssm.put-compliance-items-request/resource-type :portkey.aws.ssm.put-compliance-items-request/compliance-type :portkey.aws.ssm.put-compliance-items-request/execution-summary :portkey.aws.ssm.put-compliance-items-request/items] :opt-un [:portkey.aws.ssm.put-compliance-items-request/item-content-hash]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-key-values-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.list-associations-result/associations (clojure.spec.alpha/and :portkey.aws.ssm/association-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-associations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-associations-result/associations :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-automation-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/automation-execution]))

(clojure.spec.alpha/def :portkey.aws.ssm/logging-info (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/s-3-bucket-name :portkey.aws.ssm/s-3-region] :opt-un [:portkey.aws.ssm/s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.ssm/ps-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-by-path-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameters-by-path-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-parameters-by-path-result/parameters :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-resource-data-sync-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-association-executions-result/association-executions (clojure.spec.alpha/and :portkey.aws.ssm/association-executions-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-association-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-association-executions-result/association-executions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.association-does-not-exist/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/association-does-not-exist (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.association-does-not-exist/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.attachment-content/name (clojure.spec.alpha/and :portkey.aws.ssm/attachment-name))
(clojure.spec.alpha/def :portkey.aws.ssm.attachment-content/size (clojure.spec.alpha/and :portkey.aws.ssm/content-length))
(clojure.spec.alpha/def :portkey.aws.ssm.attachment-content/hash (clojure.spec.alpha/and :portkey.aws.ssm/attachment-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.attachment-content/hash-type (clojure.spec.alpha/and :portkey.aws.ssm/attachment-hash-type))
(clojure.spec.alpha/def :portkey.aws.ssm.attachment-content/url (clojure.spec.alpha/and :portkey.aws.ssm/attachment-url))
(clojure.spec.alpha/def :portkey.aws.ssm/attachment-content (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.attachment-content/name :portkey.aws.ssm.attachment-content/size :portkey.aws.ssm.attachment-content/hash :portkey.aws.ssm.attachment-content/hash-type :portkey.aws.ssm.attachment-content/url]))

(clojure.spec.alpha/def :portkey.aws.ssm/send-automation-signal-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-document-version/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-document-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-document-version/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-filter-group/patch-filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-filter-group (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.patch-filter-group/patch-filters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/platform-name (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/agent-version (clojure.spec.alpha/and :portkey.aws.ssm/version))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/association-status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/last-successful-association-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/last-ping-date-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/association-overview (clojure.spec.alpha/and :portkey.aws.ssm/instance-aggregated-association-overview))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/is-latest-version (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/platform-version (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/last-association-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/name (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information/registration-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-information (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm.instance-information/platform-name :portkey.aws.ssm/platform-type :portkey.aws.ssm/ping-status :portkey.aws.ssm/iam-role :portkey.aws.ssm.instance-information/agent-version :portkey.aws.ssm.instance-information/association-status :portkey.aws.ssm.instance-information/last-successful-association-execution-date :portkey.aws.ssm.instance-information/last-ping-date-time :portkey.aws.ssm.instance-information/association-overview :portkey.aws.ssm.instance-information/is-latest-version :portkey.aws.ssm/ip-address :portkey.aws.ssm.instance-information/platform-version :portkey.aws.ssm/resource-type :portkey.aws.ssm/activation-id :portkey.aws.ssm.instance-information/last-association-execution-date :portkey.aws.ssm.instance-information/name :portkey.aws.ssm.instance-information/registration-date :portkey.aws.ssm/computer-name]))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-plugin-name (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-task))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/instance-patch-state-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/instance-patch-state-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state-filter/type (clojure.spec.alpha/and :portkey.aws.ssm/instance-patch-state-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.instance-patch-state-filter/key :portkey.aws.ssm.instance-patch-state-filter/values :portkey.aws.ssm.instance-patch-state-filter/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/status-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/create-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/document-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-item/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-item/schema-version (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-item/capture-time (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-capture-time))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-item/content-hash (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-content-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-result-item/content (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-result-item (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.inventory-result-item/type-name :portkey.aws.ssm.inventory-result-item/schema-version :portkey.aws.ssm.inventory-result-item/content] :opt-un [:portkey.aws.ssm.inventory-result-item/capture-time :portkey.aws.ssm.inventory-result-item/content-hash]))

(clojure.spec.alpha/def :portkey.aws.ssm/command-plugin-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 4 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm/content-length clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.update-document-default-version-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-document-default-version-request/document-version (clojure.spec.alpha/and :portkey.aws.ssm/document-version-number))
(clojure.spec.alpha/def :portkey.aws.ssm/update-document-default-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-document-default-version-request/name :portkey.aws.ssm.update-document-default-version-request/document-version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/global-filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/description (clojure.spec.alpha/and :portkey.aws.ssm/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/replace (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/name (clojure.spec.alpha/and :portkey.aws.ssm/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/sources (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-request/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/update-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id] :opt-un [:portkey.aws.ssm.update-patch-baseline-request/rejected-patches-action :portkey.aws.ssm.update-patch-baseline-request/global-filters :portkey.aws.ssm.update-patch-baseline-request/approved-patches :portkey.aws.ssm.update-patch-baseline-request/description :portkey.aws.ssm.update-patch-baseline-request/approved-patches-enable-non-security :portkey.aws.ssm.update-patch-baseline-request/replace :portkey.aws.ssm.update-patch-baseline-request/approval-rules :portkey.aws.ssm.update-patch-baseline-request/approved-patches-compliance-level :portkey.aws.ssm.update-patch-baseline-request/name :portkey.aws.ssm.update-patch-baseline-request/sources :portkey.aws.ssm.update-patch-baseline-request/rejected-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm/attribute-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm.session-manager-output-url/s-3-output-url (clojure.spec.alpha/and :portkey.aws.ssm/session-manager-s-3-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.session-manager-output-url/cloud-watch-output-url (clojure.spec.alpha/and :portkey.aws.ssm/session-manager-cloud-watch-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-output-url (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.session-manager-output-url/s-3-output-url :portkey.aws.ssm.session-manager-output-url/cloud-watch-output-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.custom-schema-count-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/custom-schema-count-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.custom-schema-count-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-invocation-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-summary/summary-items (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-summary-items))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/total-count :portkey.aws.ssm/remaining-count :portkey.aws.ssm.inventory-deletion-summary/summary-items]))

(clojure.spec.alpha/def :portkey.aws.ssm.update-managed-instance-role-request/instance-id (clojure.spec.alpha/and :portkey.aws.ssm/managed-instance-id))
(clojure.spec.alpha/def :portkey.aws.ssm/update-managed-instance-role-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-managed-instance-role-request/instance-id :portkey.aws.ssm/iam-role] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-key-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([a-zA-Z0-9:/_-]+)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-parameter-map (clojure.spec.alpha/map-of :portkey.aws.ssm/automation-parameter-key :portkey.aws.ssm/automation-parameter-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-document-operation/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-document-operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-document-operation/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/step-execution-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/step-execution-filter-value :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.association-overview/status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.association-overview/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm/association-overview (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.association-overview/status :portkey.aws.ssm.association-overview/detailed-status :portkey.aws.ssm/association-status-aggregated-count]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/document-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.duplicate-document-content/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/duplicate-document-content (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.duplicate-document-content/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-document-versions-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm/list-document-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.list-document-versions-request/name] :opt-un [:portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-compliance-summary-item/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-compliance-summary-item/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-compliance-summary-item/resource-id (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-compliance-summary-item/status (clojure.spec.alpha/and :portkey.aws.ssm/compliance-status))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-compliance-summary-item/overall-severity (clojure.spec.alpha/and :portkey.aws.ssm/compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.resource-compliance-summary-item/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm/compliance-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-compliance-summary-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-compliance-summary-item/compliance-type :portkey.aws.ssm.resource-compliance-summary-item/resource-type :portkey.aws.ssm.resource-compliance-summary-item/resource-id :portkey.aws.ssm.resource-compliance-summary-item/status :portkey.aws.ssm.resource-compliance-summary-item/overall-severity :portkey.aws.ssm.resource-compliance-summary-item/execution-summary :portkey.aws.ssm/compliant-summary :portkey.aws.ssm/non-compliant-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-rule-group/patch-rules (clojure.spec.alpha/and :portkey.aws.ssm/patch-rule-list))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-rule-group (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.patch-rule-group/patch-rules] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-activation-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-target-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-target))

(clojure.spec.alpha/def :portkey.aws.ssm.modify-document-permission-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.modify-document-permission-request/permission-type (clojure.spec.alpha/and :portkey.aws.ssm/document-permission-type))
(clojure.spec.alpha/def :portkey.aws.ssm.modify-document-permission-request/account-ids-to-add (clojure.spec.alpha/and :portkey.aws.ssm/account-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.modify-document-permission-request/account-ids-to-remove (clojure.spec.alpha/and :portkey.aws.ssm/account-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/modify-document-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.modify-document-permission-request/name :portkey.aws.ssm.modify-document-permission-request/permission-type] :opt-un [:portkey.aws.ssm.modify-document-permission-request/account-ids-to-add :portkey.aws.ssm.modify-document-permission-request/account-ids-to-remove]))

(clojure.spec.alpha/def :portkey.aws.ssm/command-plugin-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/command-plugin))

(clojure.spec.alpha/def :portkey.aws.ssm/list-resource-data-sync-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-request/names (clojure.spec.alpha/and :portkey.aws.ssm/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameters-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-parameters-request/names] :opt-un [:portkey.aws.ssm.get-parameters-request/with-decryption]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-item :min-count 1 :max-count 30))

(clojure.spec.alpha/def :portkey.aws.ssm/accounts (clojure.spec.alpha/coll-of :portkey.aws.ssm/account :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-schema-result/schemas (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-schema-result-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-inventory-schema-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-inventory-schema-result/schemas :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/description (clojure.spec.alpha/and :portkey.aws.ssm/parameter-description))
(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/value (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/type (clojure.spec.alpha/and :portkey.aws.ssm/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/key-id (clojure.spec.alpha/and :portkey.aws.ssm/parameter-key-id))
(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/overwrite (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.put-parameter-request/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm/put-parameter-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.put-parameter-request/name :portkey.aws.ssm.put-parameter-request/value :portkey.aws.ssm.put-parameter-request/type] :opt-un [:portkey.aws.ssm.put-parameter-request/description :portkey.aws.ssm.put-parameter-request/key-id :portkey.aws.ssm.put-parameter-request/overwrite :portkey.aws.ssm/allowed-pattern :portkey.aws.ssm.put-parameter-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-history-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-history))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-filter :min-count 0 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm/service-setting-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm/association-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-sessions-request/state (clojure.spec.alpha/and :portkey.aws.ssm/session-state))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-sessions-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/session-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-sessions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/session-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-sessions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-sessions-request/state] :opt-un [:portkey.aws.ssm.describe-sessions-request/max-results :portkey.aws.ssm/next-token :portkey.aws.ssm.describe-sessions-request/filters]))

(clojure.spec.alpha/def :portkey.aws.ssm.put-inventory-result/message (clojure.spec.alpha/and :portkey.aws.ssm/put-inventory-message))
(clojure.spec.alpha/def :portkey.aws.ssm/put-inventory-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.put-inventory-result/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/registrations-count (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.ssm.deregister-target-from-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.deregister-target-from-maintenance-window-request/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.deregister-target-from-maintenance-window-request/safe (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/deregister-target-from-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.deregister-target-from-maintenance-window-request/window-id :portkey.aws.ssm.deregister-target-from-maintenance-window-request/window-target-id] :opt-un [:portkey.aws.ssm.deregister-target-from-maintenance-window-request/safe]))

(clojure.spec.alpha/def :portkey.aws.ssm/update-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/document-description]))

(clojure.spec.alpha/def :portkey.aws.ssm/max-errors (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 7)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([1-9][0-9]*|[0]|[1-9][0-9]%|[0-9]%|100%)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-item-attribute :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-string-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 132)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"tag:.+|Name|Type|KeyId|Path|Label" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-schema-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([0-9]{1,6})(\.[0-9]{1,6})$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.list-commands-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/command-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.list-commands-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/command-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-commands-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/command-id :portkey.aws.ssm/instance-id :portkey.aws.ssm.list-commands-request/max-results :portkey.aws.ssm/next-token :portkey.aws.ssm.list-commands-request/filters]))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-status #{"NON_COMPLIANT" "COMPLIANT" :compliant :non-compliant})

(clojure.spec.alpha/def :portkey.aws.ssm.get-connection-status-response/target (clojure.spec.alpha/and :portkey.aws.ssm/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.get-connection-status-response/status (clojure.spec.alpha/and :portkey.aws.ssm/connection-status))
(clojure.spec.alpha/def :portkey.aws.ssm/get-connection-status-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-connection-status-response/target :portkey.aws.ssm.get-connection-status-response/status]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-automation-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/automation-execution-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-request/plugin-name (clojure.spec.alpha/and :portkey.aws.ssm/command-plugin-name))
(clojure.spec.alpha/def :portkey.aws.ssm/get-command-invocation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/command-id :portkey.aws.ssm/instance-id] :opt-un [:portkey.aws.ssm.get-command-invocation-request/plugin-name]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-string-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-string-filter-value :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.update-document-request/content (clojure.spec.alpha/and :portkey.aws.ssm/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.update-document-request/attachments (clojure.spec.alpha/and :portkey.aws.ssm/attachments-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.update-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm/update-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-document-request/content :portkey.aws.ssm.update-document-request/name] :opt-un [:portkey.aws.ssm.update-document-request/attachments :portkey.aws.ssm.update-document-request/version-name :portkey.aws.ssm/document-version :portkey.aws.ssm/document-format :portkey.aws.ssm/target-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patch-states-result/instance-patch-states (clojure.spec.alpha/and :portkey.aws.ssm/instance-patch-state-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-patch-states-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-instance-patch-states-result/instance-patch-states :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-status #{:in-progress "InProgress" "Complete" :complete})

(clojure.spec.alpha/def :portkey.aws.ssm/account (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/get-patch-baseline-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/patch-group :portkey.aws.ssm/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm.compliance-execution-summary/execution-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-execution-summary/execution-id (clojure.spec.alpha/and :portkey.aws.ssm/compliance-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-execution-summary/execution-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-execution-type))
(clojure.spec.alpha/def :portkey.aws.ssm/compliance-execution-summary (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.compliance-execution-summary/execution-time] :opt-un [:portkey.aws.ssm.compliance-execution-summary/execution-id :portkey.aws.ssm.compliance-execution-summary/execution-type]))

(clojure.spec.alpha/def :portkey.aws.ssm/attachments-source-values (clojure.spec.alpha/coll-of :portkey.aws.ssm/attachments-source-value :min-count 1 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm/url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/invocation-trace-output (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 2500))))

(clojure.spec.alpha/def :portkey.aws.ssm/stream-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.attachments-source/key (clojure.spec.alpha/and :portkey.aws.ssm/attachments-source-key))
(clojure.spec.alpha/def :portkey.aws.ssm.attachments-source/values (clojure.spec.alpha/and :portkey.aws.ssm/attachments-source-values))
(clojure.spec.alpha/def :portkey.aws.ssm/attachments-source (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.attachments-source/key :portkey.aws.ssm.attachments-source/values]))

(clojure.spec.alpha/def :portkey.aws.ssm/allowed-pattern (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm/tag-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/valid-next-step (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 65535))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-msrc-severity (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.list-command-invocations-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/command-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.list-command-invocations-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/command-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.list-command-invocations-request/details (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/list-command-invocations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/command-id :portkey.aws.ssm/instance-id :portkey.aws.ssm.list-command-invocations-request/max-results :portkey.aws.ssm/next-token :portkey.aws.ssm.list-command-invocations-request/filters :portkey.aws.ssm.list-command-invocations-request/details]))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-string-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.document-default-version-description/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.document-default-version-description/default-version (clojure.spec.alpha/and :portkey.aws.ssm/document-version))
(clojure.spec.alpha/def :portkey.aws.ssm.document-default-version-description/default-version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm/document-default-version-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-default-version-description/name :portkey.aws.ssm.document-default-version-description/default-version :portkey.aws.ssm.document-default-version-description/default-version-name]))

(clojure.spec.alpha/def :portkey.aws.ssm/default-baseline clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/end-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/enabled (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/duration (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/cutoff (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/schedule (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/start-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-result/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm/update-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.update-maintenance-window-result/window-id :portkey.aws.ssm.update-maintenance-window-result/allow-unassociated-targets :portkey.aws.ssm.update-maintenance-window-result/end-date :portkey.aws.ssm.update-maintenance-window-result/enabled :portkey.aws.ssm.update-maintenance-window-result/description :portkey.aws.ssm.update-maintenance-window-result/duration :portkey.aws.ssm.update-maintenance-window-result/cutoff :portkey.aws.ssm.update-maintenance-window-result/schedule :portkey.aws.ssm.update-maintenance-window-result/name :portkey.aws.ssm.update-maintenance-window-result/start-date :portkey.aws.ssm.update-maintenance-window-result/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm/start-session-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/session-id :portkey.aws.ssm/token-value :portkey.aws.ssm/stream-url]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-tag-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm/command-filter-key #{"InvokedBefore" :document-name "InvokedAfter" "ExecutionStage" "Status" :invoked-before :invoked-after :status "DocumentName" :execution-stage})

(clojure.spec.alpha/def :portkey.aws.ssm.delete-inventory-result/deletion-id (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-id))
(clojure.spec.alpha/def :portkey.aws.ssm.delete-inventory-result/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.delete-inventory-result/deletion-summary (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletion-summary))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-inventory-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.delete-inventory-result/deletion-id :portkey.aws.ssm.delete-inventory-result/type-name :portkey.aws.ssm.delete-inventory-result/deletion-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm/total-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/batch-error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-source-product-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-source-product :min-count 1 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm/baseline-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 20 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-:/]{20,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-automation-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/automation-execution-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-automation-executions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-automation-executions-request/filters :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-automation-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/automation-execution-metadata-list :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-version-label-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-version-label-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-version-label-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-definition-version-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-definition-version-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.automation-definition-version-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.deregister-target-from-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.deregister-target-from-maintenance-window-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm/deregister-target-from-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.deregister-target-from-maintenance-window-result/window-id :portkey.aws.ssm.deregister-target-from-maintenance-window-result/window-target-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.update-service-setting-request/setting-id (clojure.spec.alpha/and :portkey.aws.ssm/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-service-setting-request/setting-value (clojure.spec.alpha/and :portkey.aws.ssm/service-setting-value))
(clojure.spec.alpha/def :portkey.aws.ssm/update-service-setting-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-service-setting-request/setting-id :portkey.aws.ssm.update-service-setting-request/setting-value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-not-applicable-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-target-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.failure-details/failure-stage (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.failure-details/failure-type (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.failure-details/details (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm/failure-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.failure-details/failure-stage :portkey.aws.ssm.failure-details/failure-type :portkey.aws.ssm.failure-details/details]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-product (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-filter-key #{"Status" "CreatedTime" "ExecutionId" :status :execution-id :created-time})

(clojure.spec.alpha/def :portkey.aws.ssm/ip-address (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 46))))

(clojure.spec.alpha/def :portkey.aws.ssm/managed-instance-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^mi-[0-9a-f]{17}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-string-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-filter-value :min-count 1 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/global-filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/description (clojure.spec.alpha/and :portkey.aws.ssm/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/created-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/name (clojure.spec.alpha/and :portkey.aws.ssm/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/sources (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.update-patch-baseline-result/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/update-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.update-patch-baseline-result/rejected-patches-action :portkey.aws.ssm.update-patch-baseline-result/global-filters :portkey.aws.ssm.update-patch-baseline-result/approved-patches :portkey.aws.ssm.update-patch-baseline-result/description :portkey.aws.ssm.update-patch-baseline-result/approved-patches-enable-non-security :portkey.aws.ssm/baseline-id :portkey.aws.ssm.update-patch-baseline-result/created-date :portkey.aws.ssm.update-patch-baseline-result/modified-date :portkey.aws.ssm.update-patch-baseline-result/approval-rules :portkey.aws.ssm.update-patch-baseline-result/approved-patches-compliance-level :portkey.aws.ssm.update-patch-baseline-result/name :portkey.aws.ssm.update-patch-baseline-result/sources :portkey.aws.ssm/operating-system :portkey.aws.ssm.update-patch-baseline-result/rejected-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 20 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 20)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^mw-[0-9a-f]{17}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-targets-result/targets (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-targets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-targets-result/targets :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-orchestrator-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-orchestrator-filter-value))

(clojure.spec.alpha/def :portkey.aws.ssm/created-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.patch-status/deployment-status (clojure.spec.alpha/and :portkey.aws.ssm/patch-deployment-status))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-status/compliance-level (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.patch-status/approval-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.patch-status/deployment-status :portkey.aws.ssm.patch-status/compliance-level :portkey.aws.ssm.patch-status/approval-date]))

(clojure.spec.alpha/def :portkey.aws.ssm/normal-string-map (clojure.spec.alpha/map-of :portkey.aws.ssm/string :portkey.aws.ssm/string))

(clojure.spec.alpha/def :portkey.aws.ssm/attachments-source-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-tasks-result/tasks (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-tasks-result/tasks :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-patch-state-filter :min-count 0 :max-count 4))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-parameters/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-parameters/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-target-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-vendor (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm/association-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-lambda-client-context (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 8000))))

(clojure.spec.alpha/def :portkey.aws.ssm/effective-instance-association-max-results (clojure.spec.alpha/int-in 1 5))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution/status (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution/status-details (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution/start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution/end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-execution/window-id :portkey.aws.ssm.maintenance-window-execution/window-execution-id :portkey.aws.ssm.maintenance-window-execution/status :portkey.aws.ssm.maintenance-window-execution/status-details :portkey.aws.ssm.maintenance-window-execution/start-time :portkey.aws.ssm.maintenance-window-execution/end-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-association-execution-targets-result/association-execution-targets (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-targets-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-association-execution-targets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-association-execution-targets-result/association-execution-targets :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.create-resource-data-sync-request/sync-name (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.create-resource-data-sync-request/s-3-destination (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-s-3-destination))
(clojure.spec.alpha/def :portkey.aws.ssm/create-resource-data-sync-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-resource-data-sync-request/sync-name :portkey.aws.ssm.create-resource-data-sync-request/s-3-destination] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/last-successful-resource-data-sync-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm/step-execution-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/step-execution-filter :min-count 1 :max-count 6))

(clojure.spec.alpha/def :portkey.aws.ssm/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-information-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/instance-information-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-information-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/max-results-ec-2-compatible))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-information-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/instance-information-filter-list :portkey.aws.ssm.describe-instance-information-request/filters :portkey.aws.ssm.describe-instance-information-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/global-filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/description (clojure.spec.alpha/and :portkey.aws.ssm/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/created-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/patch-groups (clojure.spec.alpha/and :portkey.aws.ssm/patch-group-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/name (clojure.spec.alpha/and :portkey.aws.ssm/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/sources (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-patch-baseline-result/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-patch-baseline-result/rejected-patches-action :portkey.aws.ssm.get-patch-baseline-result/global-filters :portkey.aws.ssm.get-patch-baseline-result/approved-patches :portkey.aws.ssm.get-patch-baseline-result/description :portkey.aws.ssm.get-patch-baseline-result/approved-patches-enable-non-security :portkey.aws.ssm/baseline-id :portkey.aws.ssm.get-patch-baseline-result/created-date :portkey.aws.ssm.get-patch-baseline-result/patch-groups :portkey.aws.ssm.get-patch-baseline-result/modified-date :portkey.aws.ssm.get-patch-baseline-result/approval-rules :portkey.aws.ssm.get-patch-baseline-result/approved-patches-compliance-level :portkey.aws.ssm.get-patch-baseline-result/name :portkey.aws.ssm.get-patch-baseline-result/sources :portkey.aws.ssm/operating-system :portkey.aws.ssm.get-patch-baseline-result/rejected-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm.deregister-task-from-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.deregister-task-from-maintenance-window-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm/deregister-task-from-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.deregister-task-from-maintenance-window-result/window-id :portkey.aws.ssm.deregister-task-from-maintenance-window-result/window-task-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/type (clojure.spec.alpha/and :portkey.aws.ssm/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/value (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/version (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/selector (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-selector))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/source-result (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.parameter/arn (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter/name :portkey.aws.ssm.parameter/type :portkey.aws.ssm.parameter/value :portkey.aws.ssm.parameter/version :portkey.aws.ssm.parameter/selector :portkey.aws.ssm.parameter/source-result :portkey.aws.ssm.parameter/last-modified-date :portkey.aws.ssm.parameter/arn]))

(clojure.spec.alpha/def :portkey.aws.ssm.unsupported-inventory-schema-version-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/unsupported-inventory-schema-version-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.unsupported-inventory-schema-version-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/automation-execution-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/automation-execution-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.automation-execution-filter/key :portkey.aws.ssm.automation-execution-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-installed-other-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-content-context (clojure.spec.alpha/map-of :portkey.aws.ssm/attribute-name :portkey.aws.ssm/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ssm/account-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"(?i)all|[0-9]{12}" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-schema-result-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-item-schema))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-item-content-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.invalid-item-content-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-item-content-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-item-content-exception/type-name :portkey.aws.ssm.invalid-item-content-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-compliance-summary-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/resource-compliance-summary-item))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-filter-key (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-windows-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-windows-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-windows-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-windows-request/filters :portkey.aws.ssm.describe-maintenance-windows-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-target-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm.create-association-batch-request-entry/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.create-association-batch-request-entry/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.create-association-batch-request-entry/output-location (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm/create-association-batch-request-entry (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-association-batch-request-entry/name] :opt-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm/parameters :portkey.aws.ssm.create-association-batch-request-entry/compliance-severity :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm/automation-target-parameter-name :portkey.aws.ssm/association-name :portkey.aws.ssm/targets :portkey.aws.ssm/schedule-expression :portkey.aws.ssm/document-version :portkey.aws.ssm.create-association-batch-request-entry/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/automation-execution-filter-value :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-description (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-filter-key #{"PATCH_ID" "CLASSIFICATION" :section "SEVERITY" :classification "MSRC_SEVERITY" "SECTION" :product :priority :patch-id :severity "PRODUCT" :msrc-severity "PRIORITY"})

(clojure.spec.alpha/def :portkey.aws.ssm/attachment-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-failed-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-lambda-parameters/client-context (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-lambda-client-context))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-lambda-parameters/qualifier (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-lambda-qualifier))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-lambda-parameters/payload (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-lambda-payload))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-lambda-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-lambda-parameters/client-context :portkey.aws.ssm.maintenance-window-lambda-parameters/qualifier :portkey.aws.ssm.maintenance-window-lambda-parameters/payload]))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-status #{:timed-out "Failed" "Cancelled" :in-progress "Cancelling" :pending "TimedOut" "Success" :waiting :cancelled :success "InProgress" "Waiting" :cancelling "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.reset-service-setting-request/setting-id (clojure.spec.alpha/and :portkey.aws.ssm/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm/reset-service-setting-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.reset-service-setting-request/setting-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-notification-config/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-notification-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-notification-config/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-schema-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"([0-9]+)\.([0-9]+)" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/attachment-information-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/attachment-information))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-source-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-source :min-count 0 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.target-location/target-location-max-concurrency (clojure.spec.alpha/and :portkey.aws.ssm/max-concurrency))
(clojure.spec.alpha/def :portkey.aws.ssm.target-location/target-location-max-errors (clojure.spec.alpha/and :portkey.aws.ssm/max-errors))
(clojure.spec.alpha/def :portkey.aws.ssm/target-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/accounts :portkey.aws.ssm/regions :portkey.aws.ssm.target-location/target-location-max-concurrency :portkey.aws.ssm.target-location/target-location-max-errors :portkey.aws.ssm/execution-role-name]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-max-results (clojure.spec.alpha/int-in 10 100))

(clojure.spec.alpha/def :portkey.aws.ssm/notification-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-document-permission-response/account-ids (clojure.spec.alpha/and :portkey.aws.ssm/account-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-document-permission-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-document-permission-response/account-ids]))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-activation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/activation-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-created-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.unsupported-operating-system/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/unsupported-operating-system (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.unsupported-operating-system/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-default-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-information-string-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/instance-information-string-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-information-string-filter/values (clojure.spec.alpha/and :portkey.aws.ssm/instance-information-filter-value-set))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-string-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.instance-information-string-filter/key :portkey.aws.ssm.instance-information-string-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-type #{:managed-instance "EC2Instance" :document "Document" "ManagedInstance" :ec-2-instance})

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-step-functions-input (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm/activation-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/document-parameter-default-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-aggregator-expression (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1000))))

(clojure.spec.alpha/def :portkey.aws.ssm/document-format #{"YAML" :yaml "JSON" :json})

(clojure.spec.alpha/def :portkey.aws.ssm/targets (clojure.spec.alpha/coll-of :portkey.aws.ssm/target :min-count 0 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-groups-result/mappings (clojure.spec.alpha/and :portkey.aws.ssm/patch-group-patch-baseline-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-patch-groups-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-patch-groups-result/mappings :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-compliance-level #{"INFORMATIONAL" :unspecified "CRITICAL" :medium "LOW" :high :critical "HIGH" :low "UNSPECIFIED" :informational "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.ssm/patch-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-source-configuration (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.ssm/target-map-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.stop-automation-execution-request/type (clojure.spec.alpha/and :portkey.aws.ssm/stop-type))
(clojure.spec.alpha/def :portkey.aws.ssm/stop-automation-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/automation-execution-id] :opt-un [:portkey.aws.ssm.stop-automation-execution-request/type]))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-resource-type-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-resource-type :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm/document-status #{"Failed" "Active" "Creating" :creating :deleting "Deleting" :active :updating "Updating" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.describe-activations-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/describe-activations-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-activations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-activations-request/filters :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/description-in-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/remove-tags-from-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.command/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.command/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.command/expires-after (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.command/status (clojure.spec.alpha/and :portkey.aws.ssm/command-status))
(clojure.spec.alpha/def :portkey.aws.ssm.command/requested-date-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.command/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.command/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm/command (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/service-role :portkey.aws.ssm.command/instance-ids :portkey.aws.ssm/comment :portkey.aws.ssm/delivery-timed-out-count :portkey.aws.ssm/completed-count :portkey.aws.ssm/error-count :portkey.aws.ssm/parameters :portkey.aws.ssm.command/output-s-3-bucket-name :portkey.aws.ssm/notification-config :portkey.aws.ssm.command/expires-after :portkey.aws.ssm.command/status :portkey.aws.ssm/status-details :portkey.aws.ssm/cloud-watch-output-config :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm.command/requested-date-time :portkey.aws.ssm/targets :portkey.aws.ssm/command-id :portkey.aws.ssm.command/output-s-3-key-prefix :portkey.aws.ssm.command/output-s-3-region :portkey.aws.ssm/document-name :portkey.aws.ssm/document-version :portkey.aws.ssm/target-count]))

(clojure.spec.alpha/def :portkey.aws.ssm/delete-parameter-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-targets-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm/target-parameter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm/instances-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-filter-value/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-filter-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-filter-value/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-group-patch-baseline-mapping-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-group-patch-baseline-mapping))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-key-id/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-key-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-key-id/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-result/window-execution-task-invocation-identities (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-invocation-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-execution-task-invocations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-execution-task-invocations-result/window-execution-task-invocation-identities :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/parameters-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/parameters-filter))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.delete-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.delete-document-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/execution-role-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm/baseline-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 3 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-s-3-output-url (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 2083))))

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-max-version-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-max-version-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-max-version-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/attachment-hash-type #{"Sha256" :sha-256})

(clojure.spec.alpha/def :portkey.aws.ssm/attachment-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.activation/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.activation/expired (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.activation/description (clojure.spec.alpha/and :portkey.aws.ssm/activation-description))
(clojure.spec.alpha/def :portkey.aws.ssm/activation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.activation/tags :portkey.aws.ssm/iam-role :portkey.aws.ssm/default-instance-name :portkey.aws.ssm/expiration-date :portkey.aws.ssm.activation/expired :portkey.aws.ssm/registrations-count :portkey.aws.ssm.activation/description :portkey.aws.ssm/created-date :portkey.aws.ssm/activation-id :portkey.aws.ssm/registration-limit]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-request/task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-execution-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-maintenance-window-execution-task-request/window-execution-id :portkey.aws.ssm.get-maintenance-window-execution-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-step-functions-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 80))))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-resource-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/association-execution-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.feature-not-available-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/feature-not-available-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.feature-not-available-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.delete-parameter-request/name (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-parameter-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.delete-parameter-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/status (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/status-details (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/invocation-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-invocation-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/task-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-invocation-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/task-execution-id :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/end-time :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/start-time :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/parameters :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/status :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/status-details :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/window-execution-id :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/invocation-id :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/execution-id :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/window-target-id :portkey.aws.ssm.maintenance-window-execution-task-invocation-identity/task-type :portkey.aws.ssm/owner-information]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-s-3-bucket-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-duration-hours (clojure.spec.alpha/int-in 1 24))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-automation-signal-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-automation-signal-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-automation-signal-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.delete-inventory-request/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.delete-inventory-request/schema-delete-option (clojure.spec.alpha/and :portkey.aws.ssm/inventory-schema-delete-option))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-inventory-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.delete-inventory-request/type-name] :opt-un [:portkey.aws.ssm.delete-inventory-request/schema-delete-option :portkey.aws.ssm/dry-run :portkey.aws.ssm/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-effective-instance-associations-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/effective-instance-association-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-effective-instance-associations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id] :opt-un [:portkey.aws.ssm.describe-effective-instance-associations-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/platform-type-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/platform-type))

(clojure.spec.alpha/def :portkey.aws.ssm/s-3-key-prefix (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 500))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-effective-patches-for-patch-baseline-result/effective-patches (clojure.spec.alpha/and :portkey.aws.ssm/effective-patch-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-effective-patches-for-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-effective-patches-for-patch-baseline-result/effective-patches :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-aggregator-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-aggregator :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-schema-request/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name-filter))
(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-schema-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/get-inventory-schema-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-schema-request/aggregator (clojure.spec.alpha/and :portkey.aws.ssm/aggregator-schema-only))
(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-schema-request/sub-type (clojure.spec.alpha/and :portkey.aws.ssm/is-sub-type-schema))
(clojure.spec.alpha/def :portkey.aws.ssm/get-inventory-schema-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-inventory-schema-request/type-name :portkey.aws.ssm/next-token :portkey.aws.ssm.get-inventory-schema-request/max-results :portkey.aws.ssm.get-inventory-schema-request/aggregator :portkey.aws.ssm.get-inventory-schema-request/sub-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-request/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-request/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-request/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-request/replace (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm/update-maintenance-window-target-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.update-maintenance-window-target-request/window-id :portkey.aws.ssm.update-maintenance-window-target-request/window-target-id] :opt-un [:portkey.aws.ssm/targets :portkey.aws.ssm/owner-information :portkey.aws.ssm.update-maintenance-window-target-request/name :portkey.aws.ssm.update-maintenance-window-target-request/description :portkey.aws.ssm.update-maintenance-window-target-request/replace]))

(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-cloud-watch-output-url (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 2083))))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-execution-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-count-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-count-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-data-sync-count-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/effective-patch-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/effective-patch))

(clojure.spec.alpha/def :portkey.aws.ssm/idempotency-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/document-permission-type #{"Share" :share})

(clojure.spec.alpha/def :portkey.aws.ssm/schedule-expression (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.list-resource-data-sync-result/resource-data-sync-items (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-resource-data-sync-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-resource-data-sync-result/resource-data-sync-items :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-type-for-tagging #{:managed-instance :maintenance-window "PatchBaseline" "MaintenanceWindow" :document "Parameter" :patch-baseline "Document" "ManagedInstance" :parameter})

(clojure.spec.alpha/def :portkey.aws.ssm.describe-document-result/document (clojure.spec.alpha/and :portkey.aws.ssm/document-description))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-document-result/document]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-version-number (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"(^[1-9][0-9]*$)" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.failed-create-association/entry (clojure.spec.alpha/and :portkey.aws.ssm/create-association-batch-request-entry))
(clojure.spec.alpha/def :portkey.aws.ssm.failed-create-association/message (clojure.spec.alpha/and :portkey.aws.ssm/batch-error-message))
(clojure.spec.alpha/def :portkey.aws.ssm/failed-create-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.failed-create-association/entry :portkey.aws.ssm.failed-create-association/message :portkey.aws.ssm/fault]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-sessions-response/sessions (clojure.spec.alpha/and :portkey.aws.ssm/session-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-sessions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-sessions-response/sessions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-inventory-item-context-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-inventory-item-context-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-inventory-item-context-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/resource-data-sync-item))

(clojure.spec.alpha/def :portkey.aws.ssm/command-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/command))

(clojure.spec.alpha/def :portkey.aws.ssm/register-patch-baseline-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/patch-group] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/command-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-document-result/status (clojure.spec.alpha/and :portkey.aws.ssm/document-status))
(clojure.spec.alpha/def :portkey.aws.ssm.get-document-result/status-information (clojure.spec.alpha/and :portkey.aws.ssm/document-status-information))
(clojure.spec.alpha/def :portkey.aws.ssm.get-document-result/content (clojure.spec.alpha/and :portkey.aws.ssm/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.get-document-result/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-document-result/attachments-content (clojure.spec.alpha/and :portkey.aws.ssm/attachment-content-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-document-result/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/get-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/document-type :portkey.aws.ssm.get-document-result/status :portkey.aws.ssm.get-document-result/status-information :portkey.aws.ssm.get-document-result/content :portkey.aws.ssm/document-format :portkey.aws.ssm.get-document-result/version-name :portkey.aws.ssm.get-document-result/attachments-content :portkey.aws.ssm/document-version :portkey.aws.ssm.get-document-result/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.association-version-info/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.association-version-info/created-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-version-info/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.association-version-info/output-location (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm/association-version-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-version :portkey.aws.ssm/parameters :portkey.aws.ssm/association-id :portkey.aws.ssm.association-version-info/compliance-severity :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm.association-version-info/created-date :portkey.aws.ssm/association-name :portkey.aws.ssm/targets :portkey.aws.ssm/schedule-expression :portkey.aws.ssm/document-version :portkey.aws.ssm.association-version-info/name :portkey.aws.ssm.association-version-info/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-association/content (clojure.spec.alpha/and :portkey.aws.ssm/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-id :portkey.aws.ssm/instance-id :portkey.aws.ssm.instance-association/content :portkey.aws.ssm/association-version]))

(clojure.spec.alpha/def :portkey.aws.ssm/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.remove-tags-from-resource-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/resource-type-for-tagging))
(clojure.spec.alpha/def :portkey.aws.ssm.remove-tags-from-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.ssm/key-list))
(clojure.spec.alpha/def :portkey.aws.ssm/remove-tags-from-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.remove-tags-from-resource-request/resource-type :portkey.aws.ssm/resource-id :portkey.aws.ssm.remove-tags-from-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.duplicate-document-version-name/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/duplicate-document-version-name (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.duplicate-document-version-name/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.s-3-output-url/output-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm/s-3-output-url (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.s-3-output-url/output-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.association-version-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/association-version-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.association-version-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/install-override-list (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^https://.+$|^s3://([^/]+)/(.*?([^/]+))$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patch-states-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patch-states-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-patch-states-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-instance-patch-states-request/instance-ids] :opt-un [:portkey.aws.ssm/next-token :portkey.aws.ssm.describe-instance-patch-states-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/activation-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 20 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 250))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-source-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,50}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-entry-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-item-entry :min-count 0 :max-count 10000))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/output-url (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/error-code (clojure.spec.alpha/and :portkey.aws.ssm/agent-error-code))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-status-info/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-status-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-version :portkey.aws.ssm.instance-association-status-info/execution-date :portkey.aws.ssm/instance-id :portkey.aws.ssm/association-id :portkey.aws.ssm.instance-association-status-info/output-url :portkey.aws.ssm.instance-association-status-info/status :portkey.aws.ssm.instance-association-status-info/error-code :portkey.aws.ssm.instance-association-status-info/execution-summary :portkey.aws.ssm/association-name :portkey.aws.ssm.instance-association-status-info/detailed-status :portkey.aws.ssm/document-version :portkey.aws.ssm.instance-association-status-info/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-status-name #{"Failed" :pending "Success" :success "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.command-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/command-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.command-filter/value (clojure.spec.alpha/and :portkey.aws.ssm/command-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm/command-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.command-filter/key :portkey.aws.ssm.command-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-result-item-map (clojure.spec.alpha/map-of :portkey.aws.ssm/inventory-result-item-key :portkey.aws.ssm/inventory-result-item))

(clojure.spec.alpha/def :portkey.aws.ssm.list-association-versions-result/association-versions (clojure.spec.alpha/and :portkey.aws.ssm/association-version-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-association-versions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-association-versions-result/association-versions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/resume-session-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/session-id :portkey.aws.ssm/token-value :portkey.aws.ssm/stream-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.create-association-batch-request/entries (clojure.spec.alpha/and :portkey.aws.ssm/create-association-batch-request-entries))
(clojure.spec.alpha/def :portkey.aws.ssm/create-association-batch-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-association-batch-request/entries] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/session-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-target/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-target/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-activations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/activation-list :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-association-version/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-association-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-association-version/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/remaining-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-inventory-request-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-inventory-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-inventory-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-rule-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-rule :min-count 0 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm/owner-information (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-activations-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/describe-activations-filter))

(clojure.spec.alpha/def :portkey.aws.ssm/session-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/session))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-string-date-time (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-activations-filter/filter-key (clojure.spec.alpha/and :portkey.aws.ssm/describe-activations-filter-keys))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-activations-filter/filter-values (clojure.spec.alpha/and :portkey.aws.ssm/string-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-activations-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-activations-filter/filter-key :portkey.aws.ssm.describe-activations-filter/filter-values]))

(clojure.spec.alpha/def :portkey.aws.ssm.sub-type-count-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/sub-type-count-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.sub-type-count-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/associated-instances (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patch-states-for-patch-group-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/instance-patch-state-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-instance-patch-states-for-patch-group-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-patch-states-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/patch-group] :opt-un [:portkey.aws.ssm.describe-instance-patch-states-for-patch-group-request/filters :portkey.aws.ssm/next-token :portkey.aws.ssm.describe-instance-patch-states-for-patch-group-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-output-folder (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.list-resource-compliance-summaries-result/resource-compliance-summary-items (clojure.spec.alpha/and :portkey.aws.ssm/resource-compliance-summary-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-resource-compliance-summaries-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-resource-compliance-summaries-result/resource-compliance-summary-items :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-role/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-role (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-role/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/service-setting-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1000))))

(clojure.spec.alpha/def :portkey.aws.ssm.s-3-output-location/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.s-3-output-location/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.s-3-output-location/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm/s-3-output-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.s-3-output-location/output-s-3-region :portkey.aws.ssm.s-3-output-location/output-s-3-bucket-name :portkey.aws.ssm.s-3-output-location/output-s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.ssm/fault #{:unknown :server :client "Unknown" "Server" "Client"})

(clojure.spec.alpha/def :portkey.aws.ssm.send-command-request/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.send-command-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.send-command-request/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.send-command-request/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.send-command-request/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.send-command-request/document-name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/send-command-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.send-command-request/document-name] :opt-un [:portkey.aws.ssm.send-command-request/service-role-arn :portkey.aws.ssm.send-command-request/instance-ids :portkey.aws.ssm/comment :portkey.aws.ssm/timeout-seconds :portkey.aws.ssm/parameters :portkey.aws.ssm.send-command-request/output-s-3-bucket-name :portkey.aws.ssm/notification-config :portkey.aws.ssm/document-hash :portkey.aws.ssm/cloud-watch-output-config :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm/targets :portkey.aws.ssm.send-command-request/output-s-3-key-prefix :portkey.aws.ssm.send-command-request/output-s-3-region :portkey.aws.ssm/document-version :portkey.aws.ssm/document-hash-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-association/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-association/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-identity))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-filter-value :min-count 1 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm/max-results (clojure.spec.alpha/int-in 1 50))

(clojure.spec.alpha/def :portkey.aws.ssm/create-association-batch-request-entries (clojure.spec.alpha/coll-of :portkey.aws.ssm/create-association-batch-request-entry :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.tag/key (clojure.spec.alpha/and :portkey.aws.ssm/tag-key))
(clojure.spec.alpha/def :portkey.aws.ssm.tag/value (clojure.spec.alpha/and :portkey.aws.ssm/tag-value))
(clojure.spec.alpha/def :portkey.aws.ssm/tag (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.tag/key :portkey.aws.ssm.tag/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/inventory-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-request/aggregators (clojure.spec.alpha/and :portkey.aws.ssm/inventory-aggregator-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-inventory-request/result-attributes (clojure.spec.alpha/and :portkey.aws.ssm/result-attribute-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-inventory-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-inventory-request/filters :portkey.aws.ssm.get-inventory-request/aggregators :portkey.aws.ssm.get-inventory-request/result-attributes :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-schedule (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm/version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9]{1,6}(\.[0-9]{1,6}){2,3}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 100)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^(AWS|Custom):.*$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/result-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/result-attribute :min-count 1 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.update-association-request/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.update-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.update-association-request/output-location (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm/update-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/association-id] :opt-un [:portkey.aws.ssm/association-version :portkey.aws.ssm/parameters :portkey.aws.ssm.update-association-request/compliance-severity :portkey.aws.ssm/max-concurrency :portkey.aws.ssm/max-errors :portkey.aws.ssm/automation-target-parameter-name :portkey.aws.ssm/association-name :portkey.aws.ssm/targets :portkey.aws.ssm/schedule-expression :portkey.aws.ssm/document-version :portkey.aws.ssm.update-association-request/name :portkey.aws.ssm.update-association-request/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-key-values-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-parameters-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-metadata-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-parameters-result/parameters :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-compliance-data-state #{"INSTALLED_REJECTED" :not-applicable "INSTALLED_OTHER" "NOT_APPLICABLE" "INSTALLED" "FAILED" :missing "MISSING" :installed-rejected :installed :installed-other :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-already-exists-exception/sync-name (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-data-sync-already-exists-exception/sync-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-maintenance-window-execution-request/window-execution-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task-invocation-parameters/run-command (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-run-command-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task-invocation-parameters/automation (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-automation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task-invocation-parameters/step-functions (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-step-functions-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task-invocation-parameters/lambda (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-lambda-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-invocation-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-task-invocation-parameters/run-command :portkey.aws.ssm.maintenance-window-task-invocation-parameters/automation :portkey.aws.ssm.maintenance-window-task-invocation-parameters/step-functions :portkey.aws.ssm.maintenance-window-task-invocation-parameters/lambda]))

(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-result/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.update-maintenance-window-target-result/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm/update-maintenance-window-target-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.update-maintenance-window-target-result/window-id :portkey.aws.ssm.update-maintenance-window-target-result/window-target-id :portkey.aws.ssm/targets :portkey.aws.ssm/owner-information :portkey.aws.ssm.update-maintenance-window-target-result/name :portkey.aws.ssm.update-maintenance-window-target-result/description]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-inventory-group-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-inventory-group-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-inventory-group-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-allowed-pattern-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-allowed-pattern-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-allowed-pattern-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-compliance-items-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/compliance-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.list-compliance-items-request/resource-ids (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.list-compliance-items-request/resource-types (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-type-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-compliance-items-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-compliance-items-request/filters :portkey.aws.ssm.list-compliance-items-request/resource-ids :portkey.aws.ssm.list-compliance-items-request/resource-types :portkey.aws.ssm/next-token :portkey.aws.ssm/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm/step-execution-filter-key #{:step-execution-status "StartTimeBefore" "StepExecutionStatus" "StepExecutionId" :step-execution-id :start-time-before "StartTimeAfter" :step-name "StepName" :action "Action" :start-time-after})

(clojure.spec.alpha/def :portkey.aws.ssm/document-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.start-associations-once-request/association-ids (clojure.spec.alpha/and :portkey.aws.ssm/association-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/start-associations-once-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.start-associations-once-request/association-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-content-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm/ps-parameter-selector (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-step-functions-parameters/input (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-step-functions-input))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-step-functions-parameters/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-step-functions-name))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-step-functions-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-step-functions-parameters/input :portkey.aws.ssm.maintenance-window-step-functions-parameters/name]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-result-item-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-windows-for-target-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-identity-for-target))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-aggregator-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-aggregator-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-aggregator-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-patch-baseline-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/patch-group] :opt-un [:portkey.aws.ssm/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-service-setting-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/service-setting]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-type #{:lambda :step-functions "LAMBDA" :run-command "RUN_COMMAND" :automation "STEP_FUNCTIONS" "AUTOMATION"})

(clojure.spec.alpha/def :portkey.aws.ssm/output-source-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-allow-unassociated-targets clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm/invocation-does-not-exist (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-parameters (clojure.spec.alpha/map-of :portkey.aws.ssm/session-manager-parameter-name :portkey.aws.ssm/session-manager-parameter-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item/schema-version (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item/capture-time (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-capture-time))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item/content-hash (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-content-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item/content (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item/context (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-content-context))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.inventory-item/type-name :portkey.aws.ssm.inventory-item/schema-version :portkey.aws.ssm.inventory-item/capture-time] :opt-un [:portkey.aws.ssm.inventory-item/content-hash :portkey.aws.ssm.inventory-item/content :portkey.aws.ssm.inventory-item/context]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-status-details (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 250))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-baselines-result/baseline-identities (clojure.spec.alpha/and :portkey.aws.ssm/patch-baseline-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-patch-baselines-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-patch-baselines-result/baseline-identities :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/command-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/command-filter :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-group-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/inventory-group :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-parameters-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-task-parameters))

(clojure.spec.alpha/def :portkey.aws.ssm/document-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"([$]LATEST|[$]DEFAULT|^[1-9][0-9]*$)" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.target/key (clojure.spec.alpha/and :portkey.aws.ssm/target-key))
(clojure.spec.alpha/def :portkey.aws.ssm.target/values (clojure.spec.alpha/and :portkey.aws.ssm/target-values))
(clojure.spec.alpha/def :portkey.aws.ssm/target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.target/key :portkey.aws.ssm.target/values]))

(clojure.spec.alpha/def :portkey.aws.ssm/scheduled-window-execution-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/scheduled-window-execution))

(clojure.spec.alpha/def :portkey.aws.ssm.internal-server-error/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/internal-server-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.internal-server-error/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-hash-type #{:sha-1 "Sha256" :sha-256 "Sha1"})

(clojure.spec.alpha/def :portkey.aws.ssm.delete-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.delete-maintenance-window-result/window-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/valid-next-step-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/valid-next-step))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-execution-task-id))

(clojure.spec.alpha/def :portkey.aws.ssm/session-filter-key #{"InvokedBefore" "InvokedAfter" "Status" :invoked-before :invoked-after :status "Owner" :target "Target" :owner})

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.document-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/document-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.document-filter/value (clojure.spec.alpha/and :portkey.aws.ssm/document-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm/document-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.document-filter/key :portkey.aws.ssm.document-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-target/status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-target/resource-id (clojure.spec.alpha/and :portkey.aws.ssm/association-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-target/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-target/execution-id (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-target/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/association-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-target/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-version :portkey.aws.ssm/output-source :portkey.aws.ssm/association-id :portkey.aws.ssm.association-execution-target/status :portkey.aws.ssm.association-execution-target/resource-id :portkey.aws.ssm.association-execution-target/last-execution-date :portkey.aws.ssm.association-execution-target/execution-id :portkey.aws.ssm.association-execution-target/resource-type :portkey.aws.ssm.association-execution-target/detailed-status]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-execution-summary (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.ssm.delete-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-association-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.delete-association-request/name :portkey.aws.ssm/instance-id :portkey.aws.ssm/association-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/failed-count (clojure.spec.alpha/and :portkey.aws.ssm/patch-failed-count))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/operation (clojure.spec.alpha/and :portkey.aws.ssm/patch-operation-type))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/installed-other-count (clojure.spec.alpha/and :portkey.aws.ssm/patch-installed-other-count))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/operation-start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/not-applicable-count (clojure.spec.alpha/and :portkey.aws.ssm/patch-not-applicable-count))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/operation-end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/installed-count (clojure.spec.alpha/and :portkey.aws.ssm/patch-installed-count))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/installed-rejected-count (clojure.spec.alpha/and :portkey.aws.ssm/patch-installed-rejected-count))
(clojure.spec.alpha/def :portkey.aws.ssm.instance-patch-state/missing-count (clojure.spec.alpha/and :portkey.aws.ssm/patch-missing-count))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm/patch-group :portkey.aws.ssm/baseline-id :portkey.aws.ssm.instance-patch-state/operation-start-time :portkey.aws.ssm.instance-patch-state/operation-end-time :portkey.aws.ssm.instance-patch-state/operation] :opt-un [:portkey.aws.ssm.instance-patch-state/failed-count :portkey.aws.ssm.instance-patch-state/installed-other-count :portkey.aws.ssm.instance-patch-state/not-applicable-count :portkey.aws.ssm/install-override-list :portkey.aws.ssm/owner-information :portkey.aws.ssm.instance-patch-state/installed-count :portkey.aws.ssm.instance-patch-state/installed-rejected-count :portkey.aws.ssm.instance-patch-state/missing-count :portkey.aws.ssm/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.register-target-with-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.register-target-with-maintenance-window-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.register-target-with-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.register-target-with-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm/register-target-with-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.register-target-with-maintenance-window-request/window-id :portkey.aws.ssm.register-target-with-maintenance-window-request/resource-type :portkey.aws.ssm/targets] :opt-un [:portkey.aws.ssm/owner-information :portkey.aws.ssm.register-target-with-maintenance-window-request/name :portkey.aws.ssm.register-target-with-maintenance-window-request/description :portkey.aws.ssm/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.association/overview (clojure.spec.alpha/and :portkey.aws.ssm/association-overview))
(clojure.spec.alpha/def :portkey.aws.ssm.association/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.association/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm/association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/association-version :portkey.aws.ssm/instance-id :portkey.aws.ssm/association-id :portkey.aws.ssm.association/overview :portkey.aws.ssm.association/last-execution-date :portkey.aws.ssm/association-name :portkey.aws.ssm/targets :portkey.aws.ssm/schedule-expression :portkey.aws.ssm/document-version :portkey.aws.ssm.association/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.delete-parameters-request/names (clojure.spec.alpha/and :portkey.aws.ssm/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-parameters-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.delete-parameters-request/names] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/session-manager-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 65535))))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-product-family (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/global-filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/description (clojure.spec.alpha/and :portkey.aws.ssm/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/name (clojure.spec.alpha/and :portkey.aws.ssm/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/sources (clojure.spec.alpha/and :portkey.aws.ssm/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.create-patch-baseline-request/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm/create-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.create-patch-baseline-request/name] :opt-un [:portkey.aws.ssm.create-patch-baseline-request/rejected-patches-action :portkey.aws.ssm.create-patch-baseline-request/global-filters :portkey.aws.ssm.create-patch-baseline-request/tags :portkey.aws.ssm.create-patch-baseline-request/approved-patches :portkey.aws.ssm.create-patch-baseline-request/description :portkey.aws.ssm.create-patch-baseline-request/approved-patches-enable-non-security :portkey.aws.ssm.create-patch-baseline-request/approval-rules :portkey.aws.ssm.create-patch-baseline-request/approved-patches-compliance-level :portkey.aws.ssm.create-patch-baseline-request/sources :portkey.aws.ssm/operating-system :portkey.aws.ssm.create-patch-baseline-request/rejected-patches :portkey.aws.ssm/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-parameter-type #{"StringList" :string-list :string "String"})

(clojure.spec.alpha/def :portkey.aws.ssm/describe-activations-filter-keys #{"ActivationIds" :iam-role :default-instance-name "IamRole" "DefaultInstanceName" :activation-ids})

(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-groups-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-patch-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-patch-groups-request/max-results :portkey.aws.ssm.describe-patch-groups-request/filters :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-task-request/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-maintenance-window-task-request/window-id :portkey.aws.ssm.get-maintenance-window-task-request/window-task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/resource-count-by-status (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.service-setting/setting-id (clojure.spec.alpha/and :portkey.aws.ssm/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm.service-setting/setting-value (clojure.spec.alpha/and :portkey.aws.ssm/service-setting-value))
(clojure.spec.alpha/def :portkey.aws.ssm.service-setting/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.service-setting/last-modified-user (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.service-setting/arn (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm.service-setting/status (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/service-setting (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.service-setting/setting-id :portkey.aws.ssm.service-setting/setting-value :portkey.aws.ssm.service-setting/last-modified-date :portkey.aws.ssm.service-setting/last-modified-user :portkey.aws.ssm.service-setting/arn :portkey.aws.ssm.service-setting/status]))

(clojure.spec.alpha/def :portkey.aws.ssm.compliance-summary-item/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm/compliance-summary-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.compliance-summary-item/compliance-type :portkey.aws.ssm/compliant-summary :portkey.aws.ssm/non-compliant-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-execution-tasks-result/window-execution-task-identities (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-execution-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-execution-tasks-result/window-execution-task-identities :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-available-patches-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-available-patches-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-available-patches-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-available-patches-request/filters :portkey.aws.ssm.describe-available-patches-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/terminate-session-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/session-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/command-plugin-status #{:timed-out "Failed" "Cancelled" :in-progress :pending "TimedOut" "Success" :cancelled :success "InProgress" "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameter-history-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-history-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameter-history-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-parameter-history-result/parameters :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-timezone (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-title (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/association-compliance-severity #{:unspecified "CRITICAL" :medium "LOW" :high :critical "HIGH" :low "UNSPECIFIED" "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.ssm.session/details (clojure.spec.alpha/and :portkey.aws.ssm/session-details))
(clojure.spec.alpha/def :portkey.aws.ssm.session/end-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.session/output-url (clojure.spec.alpha/and :portkey.aws.ssm/session-manager-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.session/status (clojure.spec.alpha/and :portkey.aws.ssm/session-status))
(clojure.spec.alpha/def :portkey.aws.ssm.session/owner (clojure.spec.alpha/and :portkey.aws.ssm/session-owner))
(clojure.spec.alpha/def :portkey.aws.ssm.session/target (clojure.spec.alpha/and :portkey.aws.ssm/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.session/start-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm/session (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/session-id :portkey.aws.ssm.session/details :portkey.aws.ssm.session/end-date :portkey.aws.ssm.session/output-url :portkey.aws.ssm.session/status :portkey.aws.ssm.session/owner :portkey.aws.ssm/document-name :portkey.aws.ssm.session/target :portkey.aws.ssm.session/start-date]))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-associations-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id] :opt-un [:portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/activation-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-baselines-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-patch-baselines-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-patch-baselines-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-patch-baselines-request/filters :portkey.aws.ssm.describe-patch-baselines-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/is-sub-type-schema clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.service-setting-not-found/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/service-setting-not-found (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.service-setting-not-found/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-filter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-maintenance-window-schedule-result/scheduled-window-executions (clojure.spec.alpha/and :portkey.aws.ssm/scheduled-window-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-maintenance-window-schedule-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-maintenance-window-schedule-result/scheduled-window-executions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/describe-instance-information-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/instance-information-list :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/ps-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.ssm/activation-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/activation))

(clojure.spec.alpha/def :portkey.aws.ssm.instance-association-output-location/s-3-location (clojure.spec.alpha/and :portkey.aws.ssm/s-3-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-output-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.instance-association-output-location/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.session-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/session-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.session-filter/value (clojure.spec.alpha/and :portkey.aws.ssm/session-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm/session-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.session-filter/key :portkey.aws.ssm.session-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.add-tags-to-resource-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/resource-type-for-tagging))
(clojure.spec.alpha/def :portkey.aws.ssm.add-tags-to-resource-request/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm/add-tags-to-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.add-tags-to-resource-request/resource-type :portkey.aws.ssm/resource-id :portkey.aws.ssm.add-tags-to-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-automation-parameters/parameters (clojure.spec.alpha/and :portkey.aws.ssm/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-automation-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/document-version :portkey.aws.ssm.maintenance-window-automation-parameters/parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-resource-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/compliance-resource-id :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-instance-id/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-instance-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-instance-id/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/association-status-aggregated-count (clojure.spec.alpha/map-of :portkey.aws.ssm/status-name :portkey.aws.ssm/instance-count))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-language (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/attachment-content-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/attachment-content))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-capture-time (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^(20)[0-9][0-9]-(0[1-9]|1[012])-([12][0-9]|3[01]|0[1-9])(T)(2[0-3]|[0-1][0-9])(:[0-5][0-9])(:[0-5][0-9])(Z)$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-permission-type/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-permission-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-permission-type/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-update/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-update (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-update/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.put-inventory-request/items (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm/put-inventory-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm.put-inventory-request/items] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/status (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/status-details (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-execution-task-identity/task-type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-task-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-execution-task-identity/window-execution-id :portkey.aws.ssm.maintenance-window-execution-task-identity/task-execution-id :portkey.aws.ssm.maintenance-window-execution-task-identity/status :portkey.aws.ssm.maintenance-window-execution-task-identity/status-details :portkey.aws.ssm.maintenance-window-execution-task-identity/start-time :portkey.aws.ssm.maintenance-window-execution-task-identity/end-time :portkey.aws.ssm.maintenance-window-execution-task-identity/task-arn :portkey.aws.ssm.maintenance-window-execution-task-identity/task-type]))

(clojure.spec.alpha/def :portkey.aws.ssm/failed-create-association-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/failed-create-association))

(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-targets-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-targets-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.association-execution-targets-filter/value (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-targets-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-targets-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.association-execution-targets-filter/key :portkey.aws.ssm.association-execution-targets-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/baseline-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm/invalid-output-location (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/resume-session-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/session-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/deregister-managed-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-effective-instance-associations-result/associations (clojure.spec.alpha/and :portkey.aws.ssm/instance-association-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-effective-instance-associations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-effective-instance-associations-result/associations :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-query-operator-type #{"BEGIN_WITH" "GREATER_THAN" :less-than :greater-than "LESS_THAN" :not-equal :begin-with "EQUAL" :equal "NOT_EQUAL"})

(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm/target-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-summary-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/execution-start-date-time (clojure.spec.alpha/and :portkey.aws.ssm/string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/plugin-name (clojure.spec.alpha/and :portkey.aws.ssm/command-plugin-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/execution-elapsed-time (clojure.spec.alpha/and :portkey.aws.ssm/string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/status (clojure.spec.alpha/and :portkey.aws.ssm/command-invocation-status))
(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/standard-output-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/execution-end-date-time (clojure.spec.alpha/and :portkey.aws.ssm/string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-command-invocation-result/standard-error-url (clojure.spec.alpha/and :portkey.aws.ssm/url))
(clojure.spec.alpha/def :portkey.aws.ssm/get-command-invocation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm.get-command-invocation-result/execution-start-date-time :portkey.aws.ssm/comment :portkey.aws.ssm.get-command-invocation-result/plugin-name :portkey.aws.ssm.get-command-invocation-result/execution-elapsed-time :portkey.aws.ssm/response-code :portkey.aws.ssm.get-command-invocation-result/status :portkey.aws.ssm/status-details :portkey.aws.ssm/standard-output-content :portkey.aws.ssm/cloud-watch-output-config :portkey.aws.ssm.get-command-invocation-result/standard-output-url :portkey.aws.ssm/command-id :portkey.aws.ssm.get-command-invocation-result/execution-end-date-time :portkey.aws.ssm/document-name :portkey.aws.ssm/document-version :portkey.aws.ssm.get-command-invocation-result/standard-error-url :portkey.aws.ssm/standard-error-content]))

(clojure.spec.alpha/def :portkey.aws.ssm.document-version-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/document-version-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-version-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.register-task-with-maintenance-window-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm/register-task-with-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.register-task-with-maintenance-window-result/window-task-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.document-already-exists/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/document-already-exists (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.document-already-exists/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/register-default-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id]))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/patch-filter :min-count 0 :max-count 4))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/region (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/token-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 0 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 300))))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item-attribute/name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-item-attribute/data-type (clojure.spec.alpha/and :portkey.aws.ssm/inventory-attribute-data-type))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-item-attribute (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.inventory-item-attribute/name :portkey.aws.ssm.inventory-item-attribute/data-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-source-product (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm/computer-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-operator-type #{"NotEqual" :less-than "Equal" "LessThan" :greater-than "GreaterThan" :not-equal :equal})

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-task-parameter-value-expression/values (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-parameter-value-expression (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-task-parameter-value-expression/values]))

(clojure.spec.alpha/def :portkey.aws.ssm/target-map-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/target-map-value :min-count 0 :max-count 25))

(clojure.spec.alpha/def :portkey.aws.ssm.automation-execution-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/automation-execution-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.automation-execution-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/target-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 128)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[\p{L}\p{Z}\p{N}_.:/=\-@]*$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-inventory-deletions-result/inventory-deletions (clojure.spec.alpha/and :portkey.aws.ssm/inventory-deletions-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-inventory-deletions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.describe-inventory-deletions-result/inventory-deletions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/get-deployable-patch-snapshot-for-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/instance-id :portkey.aws.ssm/snapshot-id :portkey.aws.ssm/snapshot-download-url :portkey.aws.ssm/product]))

(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-summary-item/version (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.inventory-deletion-summary-item/count (clojure.spec.alpha/and :portkey.aws.ssm/resource-count))
(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-summary-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.inventory-deletion-summary-item/version :portkey.aws.ssm.inventory-deletion-summary-item/count :portkey.aws.ssm/remaining-count]))

(clojure.spec.alpha/def :portkey.aws.ssm/send-command-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/command]))

(clojure.spec.alpha/def :portkey.aws.ssm/automation-parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/automation-parameter-value :min-count 0 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item-details (clojure.spec.alpha/map-of :portkey.aws.ssm/attribute-name :portkey.aws.ssm/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/maintenance-window-task-parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-string-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/end-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/type (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/start-time (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/status (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/status-details (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/priority (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/task-arn (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.get-maintenance-window-execution-task-result/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-task-parameters-list))
(clojure.spec.alpha/def :portkey.aws.ssm/get-maintenance-window-execution-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.get-maintenance-window-execution-task-result/task-execution-id :portkey.aws.ssm/service-role :portkey.aws.ssm.get-maintenance-window-execution-task-result/end-time :portkey.aws.ssm.get-maintenance-window-execution-task-result/type :portkey.aws.ssm.get-maintenance-window-execution-task-result/start-time :portkey.aws.ssm.get-maintenance-window-execution-task-result/status :portkey.aws.ssm.get-maintenance-window-execution-task-result/status-details :portkey.aws.ssm.get-maintenance-window-execution-task-result/priority :portkey.aws.ssm/max-concurrency :portkey.aws.ssm.get-maintenance-window-execution-task-result/window-execution-id :portkey.aws.ssm.get-maintenance-window-execution-task-result/task-arn :portkey.aws.ssm/max-errors :portkey.aws.ssm.get-maintenance-window-execution-task-result/task-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.item-size-limit-exceeded-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.item-size-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/item-size-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.item-size-limit-exceeded-exception/type-name :portkey.aws.ssm.item-size-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/last-resource-data-sync-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.patch/kb-number (clojure.spec.alpha/and :portkey.aws.ssm/patch-kb-number))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/product (clojure.spec.alpha/and :portkey.aws.ssm/patch-product))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/msrc-number (clojure.spec.alpha/and :portkey.aws.ssm/patch-msrc-number))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/title (clojure.spec.alpha/and :portkey.aws.ssm/patch-title))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/msrc-severity (clojure.spec.alpha/and :portkey.aws.ssm/patch-msrc-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/product-family (clojure.spec.alpha/and :portkey.aws.ssm/patch-product-family))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/description (clojure.spec.alpha/and :portkey.aws.ssm/patch-description))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/release-date (clojure.spec.alpha/and :portkey.aws.ssm/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/classification (clojure.spec.alpha/and :portkey.aws.ssm/patch-classification))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/content-url (clojure.spec.alpha/and :portkey.aws.ssm/patch-content-url))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/language (clojure.spec.alpha/and :portkey.aws.ssm/patch-language))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/vendor (clojure.spec.alpha/and :portkey.aws.ssm/patch-vendor))
(clojure.spec.alpha/def :portkey.aws.ssm.patch/id (clojure.spec.alpha/and :portkey.aws.ssm/patch-id))
(clojure.spec.alpha/def :portkey.aws.ssm/patch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.patch/kb-number :portkey.aws.ssm.patch/product :portkey.aws.ssm.patch/msrc-number :portkey.aws.ssm.patch/title :portkey.aws.ssm.patch/msrc-severity :portkey.aws.ssm.patch/product-family :portkey.aws.ssm.patch/description :portkey.aws.ssm.patch/release-date :portkey.aws.ssm.patch/classification :portkey.aws.ssm.patch/content-url :portkey.aws.ssm.patch/language :portkey.aws.ssm.patch/vendor :portkey.aws.ssm.patch/id]))

(clojure.spec.alpha/def :portkey.aws.ssm.list-document-versions-result/document-versions (clojure.spec.alpha/and :portkey.aws.ssm/document-version-list))
(clojure.spec.alpha/def :portkey.aws.ssm/list-document-versions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.list-document-versions-result/document-versions :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/max-results-ec-2-compatible (clojure.spec.alpha/int-in 5 50))

(clojure.spec.alpha/def :portkey.aws.ssm/association-execution-targets-filter-key #{:resource-id "Status" "ResourceId" :status "ResourceType" :resource-type})

(clojure.spec.alpha/def :portkey.aws.ssm/deregister-patch-baseline-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/baseline-id :portkey.aws.ssm/patch-group]))

(clojure.spec.alpha/def :portkey.aws.ssm.patch-group-patch-baseline-mapping/baseline-identity (clojure.spec.alpha/and :portkey.aws.ssm/patch-baseline-identity))
(clojure.spec.alpha/def :portkey.aws.ssm/patch-group-patch-baseline-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/patch-group :portkey.aws.ssm.patch-group-patch-baseline-mapping/baseline-identity]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-information-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-information))

(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/severity (clojure.spec.alpha/and :portkey.aws.ssm/compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/details (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-details))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/title (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-title))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/status (clojure.spec.alpha/and :portkey.aws.ssm/compliance-status))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/resource-id (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm/compliance-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/resource-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.compliance-item/id (clojure.spec.alpha/and :portkey.aws.ssm/compliance-item-id))
(clojure.spec.alpha/def :portkey.aws.ssm/compliance-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.compliance-item/severity :portkey.aws.ssm.compliance-item/details :portkey.aws.ssm.compliance-item/title :portkey.aws.ssm.compliance-item/status :portkey.aws.ssm.compliance-item/resource-id :portkey.aws.ssm.compliance-item/execution-summary :portkey.aws.ssm.compliance-item/resource-type :portkey.aws.ssm.compliance-item/compliance-type :portkey.aws.ssm.compliance-item/id]))

(clojure.spec.alpha/def :portkey.aws.ssm/operating-system #{"AMAZON_LINUX_2" :windows "WINDOWS" "CENTOS" :amazon-linux-2 :suse :centos "REDHAT_ENTERPRISE_LINUX" "AMAZON_LINUX" "UBUNTU" "SUSE" :redhat-enterprise-linux :amazon-linux :ubuntu})

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-next-token/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-next-token (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-next-token/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/document-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/document-identifier))

(clojure.spec.alpha/def :portkey.aws.ssm.association-filter/key (clojure.spec.alpha/and :portkey.aws.ssm/association-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.association-filter/value (clojure.spec.alpha/and :portkey.aws.ssm/association-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm/association-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.association-filter/key :portkey.aws.ssm.association-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/client-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm/update-managed-instance-role-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-association-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm/association-execution-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-association-executions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/association-id] :opt-un [:portkey.aws.ssm.describe-association-executions-request/filters :portkey.aws.ssm/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/notification-event-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/notification-event))

(clojure.spec.alpha/def :portkey.aws.ssm/step-execution-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/step-execution))

(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-by-path-request/path (clojure.spec.alpha/and :portkey.aws.ssm/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-by-path-request/recursive (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-by-path-request/parameter-filters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-by-path-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.get-parameters-by-path-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm/get-parameters-by-path-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm/get-parameters-by-path-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.get-parameters-by-path-request/path] :opt-un [:portkey.aws.ssm.get-parameters-by-path-request/recursive :portkey.aws.ssm.get-parameters-by-path-request/parameter-filters :portkey.aws.ssm.get-parameters-by-path-request/with-decryption :portkey.aws.ssm.get-parameters-by-path-request/max-results :portkey.aws.ssm/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm/instance-association-status-aggregated-count (clojure.spec.alpha/map-of :portkey.aws.ssm/status-name :portkey.aws.ssm/instance-count))

(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/window-id (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/end-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/enabled (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/next-execution-time (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/description (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/duration (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/cutoff (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/schedule (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/name (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/start-date (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.maintenance-window-identity/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.maintenance-window-identity/window-id :portkey.aws.ssm.maintenance-window-identity/end-date :portkey.aws.ssm.maintenance-window-identity/enabled :portkey.aws.ssm.maintenance-window-identity/next-execution-time :portkey.aws.ssm.maintenance-window-identity/description :portkey.aws.ssm.maintenance-window-identity/duration :portkey.aws.ssm.maintenance-window-identity/cutoff :portkey.aws.ssm.maintenance-window-identity/schedule :portkey.aws.ssm.maintenance-window-identity/name :portkey.aws.ssm.maintenance-window-identity/start-date :portkey.aws.ssm.maintenance-window-identity/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm/snapshot-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 36 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 36)) (clojure.core/fn [s__1410940__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$" s__1410940__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm/get-default-patch-baseline-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm/registration-limit (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.ssm/parameter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/add-tags-to-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.create-activation-request/description (clojure.spec.alpha/and :portkey.aws.ssm/activation-description))
(clojure.spec.alpha/def :portkey.aws.ssm.create-activation-request/tags (clojure.spec.alpha/and :portkey.aws.ssm/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm/create-activation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm/iam-role] :opt-un [:portkey.aws.ssm.create-activation-request/description :portkey.aws.ssm/default-instance-name :portkey.aws.ssm/registration-limit :portkey.aws.ssm/expiration-date :portkey.aws.ssm.create-activation-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ssm.invalid-document-schema-version/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/invalid-document-schema-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.invalid-document-schema-version/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/standard-error-content (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 8000))))

(clojure.spec.alpha/def :portkey.aws.ssm/modify-document-permission-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm/association-filter-operator-type #{"GREATER_THAN" :less-than :greater-than "LESS_THAN" "EQUAL" :equal})

(clojure.spec.alpha/def :portkey.aws.ssm/date-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm/patch-operation-type #{:install "Scan" "Install" :scan})

(clojure.spec.alpha/def :portkey.aws.ssm.parameter-version-not-found/message (clojure.spec.alpha/and :portkey.aws.ssm/string))
(clojure.spec.alpha/def :portkey.aws.ssm/parameter-version-not-found (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.parameter-version-not-found/message]))

(clojure.spec.alpha/def :portkey.aws.ssm/target-values (clojure.spec.alpha/coll-of :portkey.aws.ssm/target-value :min-count 0 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm/patch-kb-number (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-attribute-data-type #{"string" :number :string "number"})

(clojure.spec.alpha/def :portkey.aws.ssm/instance-patch-state-list (clojure.spec.alpha/coll-of :portkey.aws.ssm/instance-patch-state))

(clojure.spec.alpha/def :portkey.aws.ssm/target-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-task-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1410938__auto__] (clojure.core/<= 1 (clojure.core/count s__1410938__auto__))) (clojure.core/fn [s__1410939__auto__] (clojure.core/< (clojure.core/count s__1410939__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.delete-parameters-result/deleted-parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.delete-parameters-result/invalid-parameters (clojure.spec.alpha/and :portkey.aws.ssm/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm/delete-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.delete-parameters-result/deleted-parameters :portkey.aws.ssm.delete-parameters-result/invalid-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm/inventory-deletion-last-status-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.describe-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.describe-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm/describe-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.describe-document-request/name] :opt-un [:portkey.aws.ssm/document-version :portkey.aws.ssm.describe-document-request/version-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.resource-data-sync-not-found-exception/sync-name (clojure.spec.alpha/and :portkey.aws.ssm/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm/resource-data-sync-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.resource-data-sync-not-found-exception/sync-name]))

(clojure.spec.alpha/def :portkey.aws.ssm/maintenance-window-resource-type #{"INSTANCE" :instance})

(clojure.core/defn cancel-maintenance-window-execution "Stops a Maintenance Window execution that is already in progress and cancels any\ntasks in the window that have not already starting running. (Tasks already in\nprogress will continue to completion.)" ([cancel-maintenance-window-execution-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-cancel-maintenance-window-execution-request cancel-maintenance-window-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/cancel-maintenance-window-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/cancel-maintenance-window-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelMaintenanceWindowExecution", :http.request.configuration/output-deser-fn response-cancel-maintenance-window-execution-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception}})))))
(clojure.spec.alpha/fdef cancel-maintenance-window-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm/cancel-maintenance-window-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/cancel-maintenance-window-execution-result))

(clojure.core/defn update-maintenance-window-task "Modifies a task assigned to a Maintenance Window. You can't change the task\ntype, but you can change the following values:\n * TaskARN. For example, you can change a RUN_COMMAND task from\nAWS-RunPowerShellScript to AWS-RunShellScript.\n * ServiceRoleArn\n * TaskInvocationParameters\n * Priority\n * MaxConcurrency\n * MaxErrors\n If a parameter is null, then the corresponding field is not modified. Also, if\nyou set Replace to true, then all fields required by the\nRegisterTaskWithMaintenanceWindow action are required for this request. Optional\nfields that aren't specified are set to null." ([update-maintenance-window-task-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-maintenance-window-task-request update-maintenance-window-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-maintenance-window-task-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-maintenance-window-task-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMaintenanceWindowTask", :http.request.configuration/output-deser-fn response-update-maintenance-window-task-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef update-maintenance-window-task :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-maintenance-window-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-maintenance-window-task-result))

(clojure.core/defn delete-activation "Deletes an activation. You are not required to delete an activation. If you\ndelete an activation, you can no longer use it to register additional managed\ninstances. Deleting an activation does not de-register managed instances. You\nmust manually de-register managed instances." ([delete-activation-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-activation-request delete-activation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-activation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-activation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteActivation", :http.request.configuration/output-deser-fn response-delete-activation-result, :http.request.spec/error-spec {"InvalidActivationId" :portkey.aws.ssm/invalid-activation-id, "InvalidActivation" :portkey.aws.ssm/invalid-activation, "InternalServerError" :portkey.aws.ssm/internal-server-error, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef delete-activation :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-activation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-activation-result))

(clojure.core/defn describe-patch-group-state "Returns high-level aggregated patch compliance state for a patch group." ([describe-patch-group-state-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-patch-group-state-request describe-patch-group-state-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-patch-group-state-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-patch-group-state-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePatchGroupState", :http.request.configuration/output-deser-fn response-describe-patch-group-state-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-patch-group-state :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-patch-group-state-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-patch-group-state-result))

(clojure.core/defn cancel-command "Attempts to cancel the command specified by the Command ID. There is no\nguarantee that the command will be terminated and the underlying process\nstopped." ([cancel-command-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-cancel-command-request cancel-command-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/cancel-command-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/cancel-command-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelCommand", :http.request.configuration/output-deser-fn response-cancel-command-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidCommandId" :portkey.aws.ssm/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "DuplicateInstanceId" :portkey.aws.ssm/duplicate-instance-id}})))))
(clojure.spec.alpha/fdef cancel-command :args (clojure.spec.alpha/tuple :portkey.aws.ssm/cancel-command-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/cancel-command-result))

(clojure.core/defn describe-document "Describes the specified Systems Manager document." ([describe-document-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-document-request describe-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDocument", :http.request.configuration/output-deser-fn response-describe-document-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version}})))))
(clojure.spec.alpha/fdef describe-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-document-result))

(clojure.core/defn get-default-patch-baseline "Retrieves the default patch baseline. Note that Systems Manager supports\ncreating multiple default patch baselines. For example, you can create a default\npatch baseline for each operating system.\n If you do not specify an operating system value, the default patch baseline for\nWindows is returned." ([] (get-default-patch-baseline {})) ([get-default-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-default-patch-baseline-request get-default-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-default-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-default-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDefaultPatchBaseline", :http.request.configuration/output-deser-fn response-get-default-patch-baseline-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-default-patch-baseline :args (clojure.spec.alpha/? :portkey.aws.ssm/get-default-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-default-patch-baseline-result))

(clojure.core/defn describe-inventory-deletions "Describes a specific delete inventory operation." ([] (describe-inventory-deletions {})) ([describe-inventory-deletions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-inventory-deletions-request describe-inventory-deletions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-inventory-deletions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-inventory-deletions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInventoryDeletions", :http.request.configuration/output-deser-fn response-describe-inventory-deletions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDeletionIdException" :portkey.aws.ssm/invalid-deletion-id-exception, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-inventory-deletions :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-inventory-deletions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-inventory-deletions-result))

(clojure.core/defn get-maintenance-window-task "Lists the tasks in a Maintenance Window." ([get-maintenance-window-task-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-maintenance-window-task-request get-maintenance-window-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-maintenance-window-task-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-maintenance-window-task-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowTask", :http.request.configuration/output-deser-fn response-get-maintenance-window-task-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-task :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-maintenance-window-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-maintenance-window-task-result))

(clojure.core/defn register-default-patch-baseline "Defines the default patch baseline." ([register-default-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-register-default-patch-baseline-request register-default-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/register-default-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/register-default-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterDefaultPatchBaseline", :http.request.configuration/output-deser-fn response-register-default-patch-baseline-result, :http.request.spec/error-spec {"InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef register-default-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm/register-default-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/register-default-patch-baseline-result))

(clojure.core/defn put-inventory "Bulk update custom inventory items on one more instance. The request adds an\ninventory item, if it doesn't already exist, or updates an inventory item, if it\ndoes exist." ([put-inventory-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-put-inventory-request put-inventory-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/put-inventory-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/put-inventory-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutInventory", :http.request.configuration/output-deser-fn response-put-inventory-result, :http.request.spec/error-spec {"InvalidTypeNameException" :portkey.aws.ssm/invalid-type-name-exception, "ItemContentMismatchException" :portkey.aws.ssm/item-content-mismatch-exception, "UnsupportedInventoryItemContextException" :portkey.aws.ssm/unsupported-inventory-item-context-exception, "TotalSizeLimitExceededException" :portkey.aws.ssm/total-size-limit-exceeded-exception, "CustomSchemaCountLimitExceededException" :portkey.aws.ssm/custom-schema-count-limit-exceeded-exception, "UnsupportedInventorySchemaVersionException" :portkey.aws.ssm/unsupported-inventory-schema-version-exception, "InvalidItemContentException" :portkey.aws.ssm/invalid-item-content-exception, "InvalidInventoryItemContextException" :portkey.aws.ssm/invalid-inventory-item-context-exception, "SubTypeCountLimitExceededException" :portkey.aws.ssm/sub-type-count-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "ItemSizeLimitExceededException" :portkey.aws.ssm/item-size-limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef put-inventory :args (clojure.spec.alpha/tuple :portkey.aws.ssm/put-inventory-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/put-inventory-result))

(clojure.core/defn send-automation-signal "Sends a signal to an Automation execution to change the current behavior or\nstatus of the execution." ([send-automation-signal-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-send-automation-signal-request send-automation-signal-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/send-automation-signal-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/send-automation-signal-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SendAutomationSignal", :http.request.configuration/output-deser-fn response-send-automation-signal-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm/automation-execution-not-found-exception, "AutomationStepNotFoundException" :portkey.aws.ssm/automation-step-not-found-exception, "InvalidAutomationSignalException" :portkey.aws.ssm/invalid-automation-signal-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef send-automation-signal :args (clojure.spec.alpha/tuple :portkey.aws.ssm/send-automation-signal-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/send-automation-signal-result))

(clojure.core/defn get-document "Gets the contents of the specified Systems Manager document." ([get-document-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-document-request get-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocument", :http.request.configuration/output-deser-fn response-get-document-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version}})))))
(clojure.spec.alpha/fdef get-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-document-result))

(clojure.core/defn describe-maintenance-windows "Retrieves the Maintenance Windows in an AWS account." ([] (describe-maintenance-windows {})) ([describe-maintenance-windows-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-windows-request describe-maintenance-windows-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-windows-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-windows-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindows", :http.request.configuration/output-deser-fn response-describe-maintenance-windows-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-windows :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-maintenance-windows-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-windows-result))

(clojure.core/defn put-compliance-items "Registers a compliance type and other compliance details on a designated\nresource. This action lets you register custom compliance details with a\nresource. This call overwrites existing compliance information on the resource,\nso you must provide a full list of compliance items each time that you send the\nrequest.\n ComplianceType can be one of the following:\n * ExecutionId: The execution ID when the patch, association, or custom\ncompliance item was applied.\n * ExecutionType: Specify patch, association, or Custom:string.\n * ExecutionTime. The time the patch, association, or custom compliance item was\napplied to the instance.\n * Id: The patch, association, or custom compliance ID.\n * Title: A title.\n * Status: The status of the compliance item. For example, approved for patches,\nor Failed for associations.\n * Severity: A patch severity. For example, critical.\n * DocumentName: A SSM document name. For example, AWS-RunPatchBaseline.\n * DocumentVersion: An SSM document version number. For example, 4.\n * Classification: A patch classification. For example, security updates.\n * PatchBaselineId: A patch baseline ID.\n * PatchSeverity: A patch severity. For example, Critical.\n * PatchState: A patch state. For example, InstancesWithFailedPatches.\n * PatchGroup: The name of a patch group.\n * InstalledTime: The time the association, patch, or custom compliance item was\napplied to the resource. Specify the time by using the following format:\nyyyy-MM-dd'T'HH:mm:ss'Z'" ([put-compliance-items-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-put-compliance-items-request put-compliance-items-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/put-compliance-items-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/put-compliance-items-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutComplianceItems", :http.request.configuration/output-deser-fn response-put-compliance-items-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidItemContentException" :portkey.aws.ssm/invalid-item-content-exception, "TotalSizeLimitExceededException" :portkey.aws.ssm/total-size-limit-exceeded-exception, "ItemSizeLimitExceededException" :portkey.aws.ssm/item-size-limit-exceeded-exception, "ComplianceTypeCountLimitExceededException" :portkey.aws.ssm/compliance-type-count-limit-exceeded-exception, "InvalidResourceType" :portkey.aws.ssm/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id}})))))
(clojure.spec.alpha/fdef put-compliance-items :args (clojure.spec.alpha/tuple :portkey.aws.ssm/put-compliance-items-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/put-compliance-items-result))

(clojure.core/defn update-service-setting " ServiceSetting is an account-level setting for an AWS service. This setting\ndefines how a user interacts with or uses a service or a feature of a service.\nFor example, if an AWS service charges money to the account based on feature or\nservice usage, then the AWS service team might create a default setting of\n\"false\". This means the user can't use this feature unless they change the\nsetting to \"true\" and intentionally opt in for a paid feature.\n Services map a SettingId object to a setting value. AWS services teams define\nthe default value for a SettingId. You can't create a new SettingId, but you can\noverwrite the default value if you have the ssm:UpdateServiceSetting permission\nfor the setting. Use the GetServiceSetting API action to view the current value.\nOr, use the ResetServiceSetting to change the value back to the original value\ndefined by the AWS service team.\n Update the service setting for the account." ([update-service-setting-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-service-setting-request update-service-setting-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-service-setting-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-service-setting-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateServiceSetting", :http.request.configuration/output-deser-fn response-update-service-setting-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ServiceSettingNotFound" :portkey.aws.ssm/service-setting-not-found, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef update-service-setting :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-service-setting-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-service-setting-result))

(clojure.core/defn describe-patch-baselines "Lists the patch baselines in your AWS account." ([] (describe-patch-baselines {})) ([describe-patch-baselines-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-patch-baselines-request describe-patch-baselines-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-patch-baselines-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-patch-baselines-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePatchBaselines", :http.request.configuration/output-deser-fn response-describe-patch-baselines-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-patch-baselines :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-patch-baselines-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-patch-baselines-result))

(clojure.core/defn get-parameters-by-path "Retrieve parameters in a specific hierarchy. For more information, see Working\nwith Systems Manager Parameters\n(http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-working.html)\nin the AWS Systems Manager User Guide.\n Request results are returned on a best-effort basis. If you specify MaxResults\nin the request, the response includes information up to the limit specified. The\nnumber of items returned, however, can be between zero and the value of\nMaxResults. If the service reaches an internal limit while processing the\nresults, it stops the operation and returns the matching values up to that point\nand a NextToken. You can specify the NextToken in a subsequent call to get the\nnext set of results.\n This API action doesn't support filtering by tags." ([get-parameters-by-path-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-parameters-by-path-request get-parameters-by-path-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-parameters-by-path-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-parameters-by-path-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParametersByPath", :http.request.configuration/output-deser-fn response-get-parameters-by-path-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidFilterOption" :portkey.aws.ssm/invalid-filter-option, "InvalidFilterValue" :portkey.aws.ssm/invalid-filter-value, "InvalidKeyId" :portkey.aws.ssm/invalid-key-id, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef get-parameters-by-path :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-parameters-by-path-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-parameters-by-path-result))

(clojure.core/defn get-deployable-patch-snapshot-for-instance "Retrieves the current snapshot for the patch baseline the instance uses. This\nAPI is primarily used by the AWS-RunPatchBaseline Systems Manager document." ([get-deployable-patch-snapshot-for-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-deployable-patch-snapshot-for-instance-request get-deployable-patch-snapshot-for-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-deployable-patch-snapshot-for-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-deployable-patch-snapshot-for-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDeployablePatchSnapshotForInstance", :http.request.configuration/output-deser-fn response-get-deployable-patch-snapshot-for-instance-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "UnsupportedOperatingSystem" :portkey.aws.ssm/unsupported-operating-system}})))))
(clojure.spec.alpha/fdef get-deployable-patch-snapshot-for-instance :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-deployable-patch-snapshot-for-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-deployable-patch-snapshot-for-instance-result))

(clojure.core/defn get-maintenance-window "Retrieves a Maintenance Window." ([get-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-maintenance-window-request get-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindow", :http.request.configuration/output-deser-fn response-get-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-maintenance-window-result))

(clojure.core/defn create-association-batch "Associates the specified Systems Manager document with the specified instances\nor targets.\n When you associate a document with one or more instances using instance IDs or\ntags, SSM Agent running on the instance processes the document and configures\nthe instance as specified.\n If you associate a document with an instance that already has an associated\ndocument, the system returns the AssociationAlreadyExists exception." ([create-association-batch-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-association-batch-request create-association-batch-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-association-batch-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-association-batch-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAssociationBatch", :http.request.configuration/output-deser-fn response-create-association-batch-result, :http.request.spec/error-spec {"InvalidSchedule" :portkey.aws.ssm/invalid-schedule, "AssociationLimitExceeded" :portkey.aws.ssm/association-limit-exceeded, "DuplicateInstanceId" :portkey.aws.ssm/duplicate-instance-id, "UnsupportedPlatformType" :portkey.aws.ssm/unsupported-platform-type, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version, "InvalidParameters" :portkey.aws.ssm/invalid-parameters, "InvalidTarget" :portkey.aws.ssm/invalid-target, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidOutputLocation" :portkey.aws.ssm/invalid-output-location}})))))
(clojure.spec.alpha/fdef create-association-batch :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-association-batch-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-association-batch-result))

(clojure.core/defn describe-maintenance-window-tasks "Lists the tasks in a Maintenance Window." ([describe-maintenance-window-tasks-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-window-tasks-request describe-maintenance-window-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-window-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-window-tasks-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowTasks", :http.request.configuration/output-deser-fn response-describe-maintenance-window-tasks-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-tasks :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-maintenance-window-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-window-tasks-result))

(clojure.core/defn register-task-with-maintenance-window "Adds a new task to a Maintenance Window." ([register-task-with-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-register-task-with-maintenance-window-request register-task-with-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/register-task-with-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/register-task-with-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterTaskWithMaintenanceWindow", :http.request.configuration/output-deser-fn response-register-task-with-maintenance-window-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm/idempotent-parameter-mismatch, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "ResourceLimitExceededException" :portkey.aws.ssm/resource-limit-exceeded-exception, "FeatureNotAvailableException" :portkey.aws.ssm/feature-not-available-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef register-task-with-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/register-task-with-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/register-task-with-maintenance-window-result))

(clojure.core/defn deregister-patch-baseline-for-patch-group "Removes a patch group from a patch baseline." ([deregister-patch-baseline-for-patch-group-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-deregister-patch-baseline-for-patch-group-request deregister-patch-baseline-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/deregister-patch-baseline-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/deregister-patch-baseline-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterPatchBaselineForPatchGroup", :http.request.configuration/output-deser-fn response-deregister-patch-baseline-for-patch-group-result, :http.request.spec/error-spec {"InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef deregister-patch-baseline-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm/deregister-patch-baseline-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/deregister-patch-baseline-for-patch-group-result))

(clojure.core/defn list-commands "Lists the commands requested by users of the AWS account." ([] (list-commands {})) ([list-commands-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-commands-request list-commands-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-commands-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-commands-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCommands", :http.request.configuration/output-deser-fn response-list-commands-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidCommandId" :portkey.aws.ssm/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-commands :args (clojure.spec.alpha/? :portkey.aws.ssm/list-commands-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-commands-result))

(clojure.core/defn update-patch-baseline "Modifies an existing patch baseline. Fields not specified in the request are\nleft unchanged.\n For information about valid key and value pairs in PatchFilters for each\nsupported operating system type, see PatchFilter\n(http://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html)." ([update-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-patch-baseline-request update-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdatePatchBaseline", :http.request.configuration/output-deser-fn response-update-patch-baseline-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef update-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-patch-baseline-result))

(clojure.core/defn update-maintenance-window-target "Modifies the target of an existing Maintenance Window. You can't change the\ntarget type, but you can change the following:\n The target from being an ID target to a Tag target, or a Tag target to an ID\ntarget.\n IDs for an ID target.\n Tags for a Tag target.\n Owner.\n Name.\n Description.\n If a parameter is null, then the corresponding field is not modified." ([update-maintenance-window-target-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-maintenance-window-target-request update-maintenance-window-target-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-maintenance-window-target-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-maintenance-window-target-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMaintenanceWindowTarget", :http.request.configuration/output-deser-fn response-update-maintenance-window-target-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef update-maintenance-window-target :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-maintenance-window-target-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-maintenance-window-target-result))

(clojure.core/defn delete-resource-data-sync "Deletes a Resource Data Sync configuration. After the configuration is deleted,\nchanges to inventory data on managed instances are no longer synced with the\ntarget Amazon S3 bucket. Deleting a sync configuration does not delete data in\nthe target Amazon S3 bucket." ([delete-resource-data-sync-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-resource-data-sync-request delete-resource-data-sync-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-resource-data-sync-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-resource-data-sync-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteResourceDataSync", :http.request.configuration/output-deser-fn response-delete-resource-data-sync-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ResourceDataSyncNotFoundException" :portkey.aws.ssm/resource-data-sync-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-resource-data-sync :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-resource-data-sync-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-resource-data-sync-result))

(clojure.core/defn describe-maintenance-window-schedule "Retrieves information about upcoming executions of a Maintenance Window." ([] (describe-maintenance-window-schedule {})) ([describe-maintenance-window-schedule-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-window-schedule-request describe-maintenance-window-schedule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-window-schedule-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-window-schedule-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowSchedule", :http.request.configuration/output-deser-fn response-describe-maintenance-window-schedule-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-schedule :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-maintenance-window-schedule-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-window-schedule-result))

(clojure.core/defn deregister-task-from-maintenance-window "Removes a task from a Maintenance Window." ([deregister-task-from-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-deregister-task-from-maintenance-window-request deregister-task-from-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/deregister-task-from-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/deregister-task-from-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterTaskFromMaintenanceWindow", :http.request.configuration/output-deser-fn response-deregister-task-from-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef deregister-task-from-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/deregister-task-from-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/deregister-task-from-maintenance-window-result))

(clojure.core/defn get-parameter-history "Query a list of all parameters used by the AWS account." ([get-parameter-history-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-parameter-history-request get-parameter-history-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-parameter-history-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-parameter-history-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParameterHistory", :http.request.configuration/output-deser-fn response-get-parameter-history-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ParameterNotFound" :portkey.aws.ssm/parameter-not-found, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InvalidKeyId" :portkey.aws.ssm/invalid-key-id}})))))
(clojure.spec.alpha/fdef get-parameter-history :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-parameter-history-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-parameter-history-result))

(clojure.core/defn start-session "Initiates a connection to a target (for example, an instance) for a Session\nManager session. Returns a URL and token that can be used to open a WebSocket\nconnection for sending input and receiving outputs.\n AWS CLI usage: start-session is an interactive command that requires the\nSession Manager plugin to be installed on the client machine making the call.\nFor information, see Install the Session Manager Plugin for the AWS CLI\n(http://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html)\nin the AWS Systems Manager User Guide." ([start-session-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-start-session-request start-session-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/start-session-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/start-session-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartSession", :http.request.configuration/output-deser-fn response-start-session-response, :http.request.spec/error-spec {"InvalidDocument" :portkey.aws.ssm/invalid-document, "TargetNotConnected" :portkey.aws.ssm/target-not-connected, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef start-session :args (clojure.spec.alpha/tuple :portkey.aws.ssm/start-session-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/start-session-response))

(clojure.core/defn list-association-versions "Retrieves all versions of an association for a specific association ID." ([list-association-versions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-association-versions-request list-association-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-association-versions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-association-versions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAssociationVersions", :http.request.configuration/output-deser-fn response-list-association-versions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist}})))))
(clojure.spec.alpha/fdef list-association-versions :args (clojure.spec.alpha/tuple :portkey.aws.ssm/list-association-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-association-versions-result))

(clojure.core/defn list-tags-for-resource "Returns a list of the tags assigned to the specified resource." ([list-tags-for-resource-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-tags-for-resource-request list-tags-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-tags-for-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-tags-for-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-list-tags-for-resource-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.ssm/list-tags-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-tags-for-resource-result))

(clojure.core/defn create-document "Creates a Systems Manager document.\n After you create a document, you can use CreateAssociation to associate it with\none or more running instances." ([create-document-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-document-request create-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDocument", :http.request.configuration/output-deser-fn response-create-document-result, :http.request.spec/error-spec {"DocumentAlreadyExists" :portkey.aws.ssm/document-already-exists, "MaxDocumentSizeExceeded" :portkey.aws.ssm/max-document-size-exceeded, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocumentContent" :portkey.aws.ssm/invalid-document-content, "DocumentLimitExceeded" :portkey.aws.ssm/document-limit-exceeded, "InvalidDocumentSchemaVersion" :portkey.aws.ssm/invalid-document-schema-version}})))))
(clojure.spec.alpha/fdef create-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-document-result))

(clojure.core/defn list-resource-data-sync "Lists your resource data sync configurations. Includes information about the\nlast time a sync attempted to start, the last sync status, and the last time a\nsync successfully completed.\n The number of sync configurations might be too large to return using a single\ncall to ListResourceDataSync. You can limit the number of sync configurations\nreturned by using the MaxResults parameter. To determine whether there are more\nsync configurations to list, check the value of NextToken in the output. If\nthere are more sync configurations to list, you can request them by specifying\nthe NextToken returned in the call to the parameter of a subsequent call." ([] (list-resource-data-sync {})) ([list-resource-data-sync-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-resource-data-sync-request list-resource-data-sync-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-resource-data-sync-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-resource-data-sync-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListResourceDataSync", :http.request.configuration/output-deser-fn response-list-resource-data-sync-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-resource-data-sync :args (clojure.spec.alpha/? :portkey.aws.ssm/list-resource-data-sync-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-resource-data-sync-result))

(clojure.core/defn describe-association "Describes the association for the specified target or instance. If you created\nthe association by using the Targets parameter, then you must retrieve the\nassociation by using the association ID. If you created the association by\nspecifying an instance ID and a Systems Manager document, then you retrieve the\nassociation by specifying the document name and the instance ID." ([] (describe-association {})) ([describe-association-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-association-request describe-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAssociation", :http.request.configuration/output-deser-fn response-describe-association-result, :http.request.spec/error-spec {"AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist, "InvalidAssociationVersion" :portkey.aws.ssm/invalid-association-version, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id}})))))
(clojure.spec.alpha/fdef describe-association :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-association-result))

(clojure.core/defn describe-automation-executions "Provides details about all active and terminated Automation executions." ([] (describe-automation-executions {})) ([describe-automation-executions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-automation-executions-request describe-automation-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-automation-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-automation-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAutomationExecutions", :http.request.configuration/output-deser-fn response-describe-automation-executions-result, :http.request.spec/error-spec {"InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidFilterValue" :portkey.aws.ssm/invalid-filter-value, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-automation-executions :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-automation-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-automation-executions-result))

(clojure.core/defn get-parameter "Get information about a parameter by using the parameter name. Don't confuse\nthis API action with the GetParameters API action." ([get-parameter-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-parameter-request get-parameter-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-parameter-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-parameter-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParameter", :http.request.configuration/output-deser-fn response-get-parameter-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidKeyId" :portkey.aws.ssm/invalid-key-id, "ParameterNotFound" :portkey.aws.ssm/parameter-not-found, "ParameterVersionNotFound" :portkey.aws.ssm/parameter-version-not-found}})))))
(clojure.spec.alpha/fdef get-parameter :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-parameter-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-parameter-result))

(clojure.core/defn start-associations-once "Use this API action to execute an association immediately and only one time.\nThis action can be helpful when troubleshooting associations." ([start-associations-once-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-start-associations-once-request start-associations-once-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/start-associations-once-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/start-associations-once-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartAssociationsOnce", :http.request.configuration/output-deser-fn response-start-associations-once-result, :http.request.spec/error-spec {"InvalidAssociation" :portkey.aws.ssm/invalid-association, "AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist}})))))
(clojure.spec.alpha/fdef start-associations-once :args (clojure.spec.alpha/tuple :portkey.aws.ssm/start-associations-once-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/start-associations-once-result))

(clojure.core/defn update-document-default-version "Set the default version of a document." ([update-document-default-version-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-document-default-version-request update-document-default-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-document-default-version-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-document-default-version-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentDefaultVersion", :http.request.configuration/output-deser-fn response-update-document-default-version-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version, "InvalidDocumentSchemaVersion" :portkey.aws.ssm/invalid-document-schema-version}})))))
(clojure.spec.alpha/fdef update-document-default-version :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-document-default-version-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-document-default-version-result))

(clojure.core/defn update-association "Updates an association. You can update the association name and version, the\ndocument version, schedule, parameters, and Amazon S3 output." ([update-association-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-association-request update-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAssociation", :http.request.configuration/output-deser-fn response-update-association-result, :http.request.spec/error-spec {"InvalidSchedule" :portkey.aws.ssm/invalid-schedule, "TooManyUpdates" :portkey.aws.ssm/too-many-updates, "InvalidDocument" :portkey.aws.ssm/invalid-document, "AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version, "InvalidParameters" :portkey.aws.ssm/invalid-parameters, "AssociationVersionLimitExceeded" :portkey.aws.ssm/association-version-limit-exceeded, "InvalidTarget" :portkey.aws.ssm/invalid-target, "InvalidAssociationVersion" :portkey.aws.ssm/invalid-association-version, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidUpdate" :portkey.aws.ssm/invalid-update, "InvalidOutputLocation" :portkey.aws.ssm/invalid-output-location}})))))
(clojure.spec.alpha/fdef update-association :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-association-result))

(clojure.core/defn get-maintenance-window-execution-task-invocation "Retrieves a task invocation. A task invocation is a specific task executing on a\nspecific target. Maintenance Windows report status for all invocations." ([get-maintenance-window-execution-task-invocation-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-maintenance-window-execution-task-invocation-request get-maintenance-window-execution-task-invocation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-maintenance-window-execution-task-invocation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-maintenance-window-execution-task-invocation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowExecutionTaskInvocation", :http.request.configuration/output-deser-fn response-get-maintenance-window-execution-task-invocation-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-execution-task-invocation :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-maintenance-window-execution-task-invocation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-maintenance-window-execution-task-invocation-result))

(clojure.core/defn send-command "Executes commands on one or more managed instances." ([send-command-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-send-command-request send-command-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/send-command-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/send-command-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SendCommand", :http.request.configuration/output-deser-fn response-send-command-result, :http.request.spec/error-spec {"MaxDocumentSizeExceeded" :portkey.aws.ssm/max-document-size-exceeded, "DuplicateInstanceId" :portkey.aws.ssm/duplicate-instance-id, "UnsupportedPlatformType" :portkey.aws.ssm/unsupported-platform-type, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version, "InvalidParameters" :portkey.aws.ssm/invalid-parameters, "InvalidNotificationConfig" :portkey.aws.ssm/invalid-notification-config, "InvalidOutputFolder" :portkey.aws.ssm/invalid-output-folder, "InvalidRole" :portkey.aws.ssm/invalid-role, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id}})))))
(clojure.spec.alpha/fdef send-command :args (clojure.spec.alpha/tuple :portkey.aws.ssm/send-command-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/send-command-result))

(clojure.core/defn describe-parameters "Get information about a parameter.\n Request results are returned on a best-effort basis. If you specify MaxResults\nin the request, the response includes information up to the limit specified. The\nnumber of items returned, however, can be between zero and the value of\nMaxResults. If the service reaches an internal limit while processing the\nresults, it stops the operation and returns the matching values up to that point\nand a NextToken. You can specify the NextToken in a subsequent call to get the\nnext set of results." ([] (describe-parameters {})) ([describe-parameters-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-parameters-request describe-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeParameters", :http.request.configuration/output-deser-fn response-describe-parameters-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidFilterOption" :portkey.aws.ssm/invalid-filter-option, "InvalidFilterValue" :portkey.aws.ssm/invalid-filter-value, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-parameters :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-parameters-result))

(clojure.core/defn resume-session "Reconnects a session to an instance after it has been disconnected. Connections\ncan be resumed for disconnected sessions, but not terminated sessions.\n This command is primarily for use by client machines to automatically reconnect\nduring intermittent network issues. It is not intended for any other use." ([resume-session-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-resume-session-request resume-session-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/resume-session-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/resume-session-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResumeSession", :http.request.configuration/output-deser-fn response-resume-session-response, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef resume-session :args (clojure.spec.alpha/tuple :portkey.aws.ssm/resume-session-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/resume-session-response))

(clojure.core/defn update-managed-instance-role "Assigns or changes an Amazon Identity and Access Management (IAM) role to the\nmanaged instance." ([update-managed-instance-role-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-managed-instance-role-request update-managed-instance-role-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-managed-instance-role-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-managed-instance-role-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateManagedInstanceRole", :http.request.configuration/output-deser-fn response-update-managed-instance-role-result, :http.request.spec/error-spec {"InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef update-managed-instance-role :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-managed-instance-role-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-managed-instance-role-result))

(clojure.core/defn create-activation "Registers your on-premises server or virtual machine with Amazon EC2 so that you\ncan manage these resources using Run Command. An on-premises server or virtual\nmachine that has been registered with EC2 is called a managed instance. For more\ninformation about activations, see Setting Up Systems Manager in Hybrid\nEnvironments\n(http://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances.html)." ([create-activation-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-activation-request create-activation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-activation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-activation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateActivation", :http.request.configuration/output-deser-fn response-create-activation-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef create-activation :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-activation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-activation-result))

(clojure.core/defn list-document-versions "List all versions for a document." ([list-document-versions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-document-versions-request list-document-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-document-versions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-document-versions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListDocumentVersions", :http.request.configuration/output-deser-fn response-list-document-versions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InvalidDocument" :portkey.aws.ssm/invalid-document}})))))
(clojure.spec.alpha/fdef list-document-versions :args (clojure.spec.alpha/tuple :portkey.aws.ssm/list-document-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-document-versions-result))

(clojure.core/defn reset-service-setting " ServiceSetting is an account-level setting for an AWS service. This setting\ndefines how a user interacts with or uses a service or a feature of a service.\nFor example, if an AWS service charges money to the account based on feature or\nservice usage, then the AWS service team might create a default setting of\n\"false\". This means the user can't use this feature unless they change the\nsetting to \"true\" and intentionally opt in for a paid feature.\n Services map a SettingId object to a setting value. AWS services teams define\nthe default value for a SettingId. You can't create a new SettingId, but you can\noverwrite the default value if you have the ssm:UpdateServiceSetting permission\nfor the setting. Use the GetServiceSetting API action to view the current value.\nUse the UpdateServiceSetting API action to change the default setting.\n Reset the service setting for the account to the default value as provisioned\nby the AWS service team." ([reset-service-setting-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-reset-service-setting-request reset-service-setting-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/reset-service-setting-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/reset-service-setting-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetServiceSetting", :http.request.configuration/output-deser-fn response-reset-service-setting-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ServiceSettingNotFound" :portkey.aws.ssm/service-setting-not-found, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef reset-service-setting :args (clojure.spec.alpha/tuple :portkey.aws.ssm/reset-service-setting-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/reset-service-setting-result))

(clojure.core/defn describe-effective-instance-associations "All associations for the instance(s)." ([describe-effective-instance-associations-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-effective-instance-associations-request describe-effective-instance-associations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-effective-instance-associations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-effective-instance-associations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEffectiveInstanceAssociations", :http.request.configuration/output-deser-fn response-describe-effective-instance-associations-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-effective-instance-associations :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-effective-instance-associations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-effective-instance-associations-result))

(clojure.core/defn describe-maintenance-windows-for-target "Retrieves information about the Maintenance Windows targets or tasks that an\ninstance is associated with." ([describe-maintenance-windows-for-target-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-windows-for-target-request describe-maintenance-windows-for-target-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-windows-for-target-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-windows-for-target-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowsForTarget", :http.request.configuration/output-deser-fn response-describe-maintenance-windows-for-target-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-windows-for-target :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-maintenance-windows-for-target-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-windows-for-target-result))

(clojure.core/defn modify-document-permission "Shares a Systems Manager document publicly or privately. If you share a document\nprivately, you must specify the AWS user account IDs for those people who can\nuse the document. If you share a document publicly, you must specify All as the\naccount ID." ([modify-document-permission-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-modify-document-permission-request modify-document-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/modify-document-permission-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/modify-document-permission-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyDocumentPermission", :http.request.configuration/output-deser-fn response-modify-document-permission-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidPermissionType" :portkey.aws.ssm/invalid-permission-type, "DocumentPermissionLimit" :portkey.aws.ssm/document-permission-limit, "DocumentLimitExceeded" :portkey.aws.ssm/document-limit-exceeded}})))))
(clojure.spec.alpha/fdef modify-document-permission :args (clojure.spec.alpha/tuple :portkey.aws.ssm/modify-document-permission-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/modify-document-permission-response))

(clojure.core/defn get-maintenance-window-execution-task "Retrieves the details about a specific task executed as part of a Maintenance\nWindow execution." ([get-maintenance-window-execution-task-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-maintenance-window-execution-task-request get-maintenance-window-execution-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-maintenance-window-execution-task-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-maintenance-window-execution-task-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowExecutionTask", :http.request.configuration/output-deser-fn response-get-maintenance-window-execution-task-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-execution-task :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-maintenance-window-execution-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-maintenance-window-execution-task-result))

(clojure.core/defn describe-association-execution-targets "Use this API action to view information about a specific execution of a specific\nassociation." ([describe-association-execution-targets-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-association-execution-targets-request describe-association-execution-targets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-association-execution-targets-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-association-execution-targets-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAssociationExecutionTargets", :http.request.configuration/output-deser-fn response-describe-association-execution-targets-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "AssociationExecutionDoesNotExist" :portkey.aws.ssm/association-execution-does-not-exist}})))))
(clojure.spec.alpha/fdef describe-association-execution-targets :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-association-execution-targets-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-association-execution-targets-result))

(clojure.core/defn delete-inventory "Delete a custom inventory type, or the data associated with a custom Inventory\ntype. Deleting a custom inventory type is also referred to as deleting a custom\ninventory schema." ([delete-inventory-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-inventory-request delete-inventory-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-inventory-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-inventory-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteInventory", :http.request.configuration/output-deser-fn response-delete-inventory-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidTypeNameException" :portkey.aws.ssm/invalid-type-name-exception, "InvalidOptionException" :portkey.aws.ssm/invalid-option-exception, "InvalidDeleteInventoryParametersException" :portkey.aws.ssm/invalid-delete-inventory-parameters-exception, "InvalidInventoryRequestException" :portkey.aws.ssm/invalid-inventory-request-exception}})))))
(clojure.spec.alpha/fdef delete-inventory :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-inventory-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-inventory-result))

(clojure.core/defn list-resource-compliance-summaries "Returns a resource-level summary count. The summary includes information about\ncompliant and non-compliant statuses and detailed compliance-item severity\ncounts, according to the filter criteria you specify." ([] (list-resource-compliance-summaries {})) ([list-resource-compliance-summaries-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-resource-compliance-summaries-request list-resource-compliance-summaries-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-resource-compliance-summaries-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-resource-compliance-summaries-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListResourceComplianceSummaries", :http.request.configuration/output-deser-fn response-list-resource-compliance-summaries-result, :http.request.spec/error-spec {"InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef list-resource-compliance-summaries :args (clojure.spec.alpha/? :portkey.aws.ssm/list-resource-compliance-summaries-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-resource-compliance-summaries-result))

(clojure.core/defn get-patch-baseline-for-patch-group "Retrieves the patch baseline that should be used for the specified patch group." ([get-patch-baseline-for-patch-group-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-patch-baseline-for-patch-group-request get-patch-baseline-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-patch-baseline-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-patch-baseline-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPatchBaselineForPatchGroup", :http.request.configuration/output-deser-fn response-get-patch-baseline-for-patch-group-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-patch-baseline-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-patch-baseline-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-patch-baseline-for-patch-group-result))

(clojure.core/defn get-service-setting " ServiceSetting is an account-level setting for an AWS service. This setting\ndefines how a user interacts with or uses a service or a feature of a service.\nFor example, if an AWS service charges money to the account based on feature or\nservice usage, then the AWS service team might create a default setting of\n\"false\". This means the user can't use this feature unless they change the\nsetting to \"true\" and intentionally opt in for a paid feature.\n Services map a SettingId object to a setting value. AWS services teams define\nthe default value for a SettingId. You can't create a new SettingId, but you can\noverwrite the default value if you have the ssm:UpdateServiceSetting permission\nfor the setting. Use the UpdateServiceSetting API action to change the default\nsetting. Or use the ResetServiceSetting to change the value back to the original\nvalue defined by the AWS service team.\n Query the current service setting for the account." ([get-service-setting-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-service-setting-request get-service-setting-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-service-setting-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-service-setting-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetServiceSetting", :http.request.configuration/output-deser-fn response-get-service-setting-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ServiceSettingNotFound" :portkey.aws.ssm/service-setting-not-found}})))))
(clojure.spec.alpha/fdef get-service-setting :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-service-setting-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-service-setting-result))

(clojure.core/defn get-maintenance-window-execution "Retrieves details about a specific task executed as part of a Maintenance Window\nexecution." ([get-maintenance-window-execution-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-maintenance-window-execution-request get-maintenance-window-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-maintenance-window-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-maintenance-window-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowExecution", :http.request.configuration/output-deser-fn response-get-maintenance-window-execution-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-maintenance-window-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-maintenance-window-execution-result))

(clojure.core/defn delete-parameters "Delete a list of parameters. This API is used to delete parameters by using the\nAmazon EC2 console." ([delete-parameters-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-parameters-request delete-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteParameters", :http.request.configuration/output-deser-fn response-delete-parameters-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef delete-parameters :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-parameters-result))

(clojure.core/defn create-association "Associates the specified Systems Manager document with the specified instances\nor targets.\n When you associate a document with one or more instances using instance IDs or\ntags, SSM Agent running on the instance processes the document and configures\nthe instance as specified.\n If you associate a document with an instance that already has an associated\ndocument, the system returns the AssociationAlreadyExists exception." ([create-association-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-association-request create-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAssociation", :http.request.configuration/output-deser-fn response-create-association-result, :http.request.spec/error-spec {"InvalidSchedule" :portkey.aws.ssm/invalid-schedule, "AssociationLimitExceeded" :portkey.aws.ssm/association-limit-exceeded, "AssociationAlreadyExists" :portkey.aws.ssm/association-already-exists, "UnsupportedPlatformType" :portkey.aws.ssm/unsupported-platform-type, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version, "InvalidParameters" :portkey.aws.ssm/invalid-parameters, "InvalidTarget" :portkey.aws.ssm/invalid-target, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidOutputLocation" :portkey.aws.ssm/invalid-output-location}})))))
(clojure.spec.alpha/fdef create-association :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-association-result))

(clojure.core/defn list-compliance-items "For a specified resource ID, this API action returns a list of compliance\nstatuses for different resource types. Currently, you can only specify one\nresource ID per call. List results depend on the criteria specified in the\nfilter." ([] (list-compliance-items {})) ([list-compliance-items-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-compliance-items-request list-compliance-items-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-compliance-items-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-compliance-items-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListComplianceItems", :http.request.configuration/output-deser-fn response-list-compliance-items-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-compliance-items :args (clojure.spec.alpha/? :portkey.aws.ssm/list-compliance-items-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-compliance-items-result))

(clojure.core/defn list-documents "Describes one or more of your Systems Manager documents." ([] (list-documents {})) ([list-documents-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-documents-request list-documents-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-documents-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-documents-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListDocuments", :http.request.configuration/output-deser-fn response-list-documents-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key}})))))
(clojure.spec.alpha/fdef list-documents :args (clojure.spec.alpha/? :portkey.aws.ssm/list-documents-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-documents-result))

(clojure.core/defn describe-instance-patch-states-for-patch-group "Retrieves the high-level patch state for the instances in the specified patch\ngroup." ([describe-instance-patch-states-for-patch-group-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-instance-patch-states-for-patch-group-request describe-instance-patch-states-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-instance-patch-states-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-instance-patch-states-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstancePatchStatesForPatchGroup", :http.request.configuration/output-deser-fn response-describe-instance-patch-states-for-patch-group-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-patch-states-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-instance-patch-states-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-instance-patch-states-for-patch-group-result))

(clojure.core/defn delete-association "Disassociates the specified Systems Manager document from the specified\ninstance.\n When you disassociate a document from an instance, it does not change the\nconfiguration of the instance. To change the configuration state of an instance\nafter you disassociate a document, you must create a new document with the\ndesired configuration and associate it with the instance." ([] (delete-association {})) ([delete-association-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-association-request delete-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAssociation", :http.request.configuration/output-deser-fn response-delete-association-result, :http.request.spec/error-spec {"AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist, "InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef delete-association :args (clojure.spec.alpha/? :portkey.aws.ssm/delete-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-association-result))

(clojure.core/defn get-parameters "Get details of a parameter. Don't confuse this API action with the GetParameter\nAPI action." ([get-parameters-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-parameters-request get-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParameters", :http.request.configuration/output-deser-fn response-get-parameters-result, :http.request.spec/error-spec {"InvalidKeyId" :portkey.aws.ssm/invalid-key-id, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-parameters :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-parameters-result))

(clojure.core/defn update-association-status "Updates the status of the Systems Manager document associated with the specified\ninstance." ([update-association-status-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-association-status-request update-association-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-association-status-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-association-status-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAssociationStatus", :http.request.configuration/output-deser-fn response-update-association-status-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidDocument" :portkey.aws.ssm/invalid-document, "AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist, "StatusUnchanged" :portkey.aws.ssm/status-unchanged, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef update-association-status :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-association-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-association-status-result))

(clojure.core/defn get-command-invocation "Returns detailed information about command execution for an invocation or\nplugin." ([get-command-invocation-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-command-invocation-request get-command-invocation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-command-invocation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-command-invocation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCommandInvocation", :http.request.configuration/output-deser-fn response-get-command-invocation-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidCommandId" :portkey.aws.ssm/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidPluginName" :portkey.aws.ssm/invalid-plugin-name, "InvocationDoesNotExist" :portkey.aws.ssm/invocation-does-not-exist}})))))
(clojure.spec.alpha/fdef get-command-invocation :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-command-invocation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-command-invocation-result))

(clojure.core/defn describe-automation-step-executions "Information about all active and terminated step executions in an Automation\nworkflow." ([describe-automation-step-executions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-automation-step-executions-request describe-automation-step-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-automation-step-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-automation-step-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAutomationStepExecutions", :http.request.configuration/output-deser-fn response-describe-automation-step-executions-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm/automation-execution-not-found-exception, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidFilterValue" :portkey.aws.ssm/invalid-filter-value, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-automation-step-executions :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-automation-step-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-automation-step-executions-result))

(clojure.core/defn update-maintenance-window "Updates an existing Maintenance Window. Only specified parameters are modified." ([update-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-maintenance-window-request update-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMaintenanceWindow", :http.request.configuration/output-deser-fn response-update-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef update-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-maintenance-window-result))

(clojure.core/defn describe-instance-information "Describes one or more of your instances. You can use this to get information\nabout instances like the operating system platform, the SSM Agent version\n(Linux), status etc. If you specify one or more instance IDs, it returns\ninformation for those instances. If you do not specify instance IDs, it returns\ninformation for all your instances. If you specify an instance ID that is not\nvalid or an instance that you do not own, you receive an error.\n The IamRole field for this API action is the Amazon Identity and Access\nManagement (IAM) role assigned to on-premises instances. This call does not\nreturn the IAM role for Amazon EC2 instances." ([] (describe-instance-information {})) ([describe-instance-information-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-instance-information-request describe-instance-information-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-instance-information-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-instance-information-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceInformation", :http.request.configuration/output-deser-fn response-describe-instance-information-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InvalidInstanceInformationFilterValue" :portkey.aws.ssm/invalid-instance-information-filter-value, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key}})))))
(clojure.spec.alpha/fdef describe-instance-information :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-instance-information-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-instance-information-result))

(clojure.core/defn describe-maintenance-window-execution-tasks "For a given Maintenance Window execution, lists the tasks that were executed." ([describe-maintenance-window-execution-tasks-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-window-execution-tasks-request describe-maintenance-window-execution-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-window-execution-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-window-execution-tasks-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowExecutionTasks", :http.request.configuration/output-deser-fn response-describe-maintenance-window-execution-tasks-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-execution-tasks :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-maintenance-window-execution-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-window-execution-tasks-result))

(clojure.core/defn describe-activations "Details about the activation, including: the date and time the activation was\ncreated, the expiration date, the IAM role assigned to the instances in the\nactivation, and the number of instances activated by this registration." ([] (describe-activations {})) ([describe-activations-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-activations-request describe-activations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-activations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-activations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeActivations", :http.request.configuration/output-deser-fn response-describe-activations-result, :http.request.spec/error-spec {"InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-activations :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-activations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-activations-result))

(clojure.core/defn list-associations "Lists the associations for the specified Systems Manager document or instance." ([] (list-associations {})) ([list-associations-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-associations-request list-associations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-associations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-associations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAssociations", :http.request.configuration/output-deser-fn response-list-associations-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-associations :args (clojure.spec.alpha/? :portkey.aws.ssm/list-associations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-associations-result))

(clojure.core/defn deregister-managed-instance "Removes the server or virtual machine from the list of registered servers. You\ncan reregister the instance again at any time. If you don't plan to use Run\nCommand on the server, we suggest uninstalling SSM Agent first." ([deregister-managed-instance-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-deregister-managed-instance-request deregister-managed-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/deregister-managed-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/deregister-managed-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterManagedInstance", :http.request.configuration/output-deser-fn response-deregister-managed-instance-result, :http.request.spec/error-spec {"InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef deregister-managed-instance :args (clojure.spec.alpha/tuple :portkey.aws.ssm/deregister-managed-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/deregister-managed-instance-result))

(clojure.core/defn deregister-target-from-maintenance-window "Removes a target from a Maintenance Window." ([deregister-target-from-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-deregister-target-from-maintenance-window-request deregister-target-from-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/deregister-target-from-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/deregister-target-from-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterTargetFromMaintenanceWindow", :http.request.configuration/output-deser-fn response-deregister-target-from-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error, "TargetInUseException" :portkey.aws.ssm/target-in-use-exception}})))))
(clojure.spec.alpha/fdef deregister-target-from-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/deregister-target-from-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/deregister-target-from-maintenance-window-result))

(clojure.core/defn describe-sessions "Retrieves a list of all active sessions (both connected and disconnected) or\nterminated sessions from the past 30 days." ([describe-sessions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-sessions-request describe-sessions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-sessions-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-sessions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSessions", :http.request.configuration/output-deser-fn response-describe-sessions-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-sessions :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-sessions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-sessions-response))

(clojure.core/defn stop-automation-execution "Stop an Automation that is currently executing." ([stop-automation-execution-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-stop-automation-execution-request stop-automation-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/stop-automation-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/stop-automation-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopAutomationExecution", :http.request.configuration/output-deser-fn response-stop-automation-execution-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm/automation-execution-not-found-exception, "InvalidAutomationStatusUpdateException" :portkey.aws.ssm/invalid-automation-status-update-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef stop-automation-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm/stop-automation-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/stop-automation-execution-result))

(clojure.core/defn start-automation-execution "Initiates execution of an Automation document." ([start-automation-execution-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-start-automation-execution-request start-automation-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/start-automation-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/start-automation-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartAutomationExecution", :http.request.configuration/output-deser-fn response-start-automation-execution-result, :http.request.spec/error-spec {"AutomationDefinitionNotFoundException" :portkey.aws.ssm/automation-definition-not-found-exception, "InvalidAutomationExecutionParametersException" :portkey.aws.ssm/invalid-automation-execution-parameters-exception, "AutomationExecutionLimitExceededException" :portkey.aws.ssm/automation-execution-limit-exceeded-exception, "AutomationDefinitionVersionNotFoundException" :portkey.aws.ssm/automation-definition-version-not-found-exception, "IdempotentParameterMismatch" :portkey.aws.ssm/idempotent-parameter-mismatch, "InvalidTarget" :portkey.aws.ssm/invalid-target, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef start-automation-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm/start-automation-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/start-automation-execution-result))

(clojure.core/defn get-connection-status "Retrieves the Session Manager connection status for an instance to determine\nwhether it is connected and ready to receive Session Manager connections." ([get-connection-status-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-connection-status-request get-connection-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-connection-status-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-connection-status-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetConnectionStatus", :http.request.configuration/output-deser-fn response-get-connection-status-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-connection-status :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-connection-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-connection-status-response))

(clojure.core/defn describe-instance-patch-states "Retrieves the high-level patch state of one or more instances." ([describe-instance-patch-states-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-instance-patch-states-request describe-instance-patch-states-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-instance-patch-states-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-instance-patch-states-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstancePatchStates", :http.request.configuration/output-deser-fn response-describe-instance-patch-states-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-patch-states :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-instance-patch-states-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-instance-patch-states-result))

(clojure.core/defn update-document "The document you want to update." ([update-document-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-update-document-request update-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/update-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/update-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocument", :http.request.configuration/output-deser-fn response-update-document-result, :http.request.spec/error-spec {"InvalidDocumentContent" :portkey.aws.ssm/invalid-document-content, "MaxDocumentSizeExceeded" :portkey.aws.ssm/max-document-size-exceeded, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm/invalid-document-version, "InvalidDocumentOperation" :portkey.aws.ssm/invalid-document-operation, "DuplicateDocumentContent" :portkey.aws.ssm/duplicate-document-content, "DuplicateDocumentVersionName" :portkey.aws.ssm/duplicate-document-version-name, "InternalServerError" :portkey.aws.ssm/internal-server-error, "DocumentVersionLimitExceeded" :portkey.aws.ssm/document-version-limit-exceeded, "InvalidDocumentSchemaVersion" :portkey.aws.ssm/invalid-document-schema-version}})))))
(clojure.spec.alpha/fdef update-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm/update-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/update-document-result))

(clojure.core/defn describe-available-patches "Lists all patches that could possibly be included in a patch baseline." ([] (describe-available-patches {})) ([describe-available-patches-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-available-patches-request describe-available-patches-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-available-patches-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-available-patches-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAvailablePatches", :http.request.configuration/output-deser-fn response-describe-available-patches-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-available-patches :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-available-patches-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-available-patches-result))

(clojure.core/defn register-patch-baseline-for-patch-group "Registers a patch baseline for a patch group." ([register-patch-baseline-for-patch-group-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-register-patch-baseline-for-patch-group-request register-patch-baseline-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/register-patch-baseline-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/register-patch-baseline-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterPatchBaselineForPatchGroup", :http.request.configuration/output-deser-fn response-register-patch-baseline-for-patch-group-result, :http.request.spec/error-spec {"AlreadyExistsException" :portkey.aws.ssm/already-exists-exception, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "ResourceLimitExceededException" :portkey.aws.ssm/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef register-patch-baseline-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm/register-patch-baseline-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/register-patch-baseline-for-patch-group-result))

(clojure.core/defn create-patch-baseline "Creates a patch baseline.\n For information about valid key and value pairs in PatchFilters for each\nsupported operating system type, see PatchFilter\n(http://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html)." ([create-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-patch-baseline-request create-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePatchBaseline", :http.request.configuration/output-deser-fn response-create-patch-baseline-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm/idempotent-parameter-mismatch, "ResourceLimitExceededException" :portkey.aws.ssm/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef create-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-patch-baseline-result))

(clojure.core/defn describe-effective-patches-for-patch-baseline "Retrieves the current effective patches (the patch and the approval state) for\nthe specified patch baseline. Note that this API applies only to Windows patch\nbaselines." ([describe-effective-patches-for-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-effective-patches-for-patch-baseline-request describe-effective-patches-for-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-effective-patches-for-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-effective-patches-for-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEffectivePatchesForPatchBaseline", :http.request.configuration/output-deser-fn response-describe-effective-patches-for-patch-baseline-result, :http.request.spec/error-spec {"InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "UnsupportedOperatingSystem" :portkey.aws.ssm/unsupported-operating-system, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-effective-patches-for-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-effective-patches-for-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-effective-patches-for-patch-baseline-result))

(clojure.core/defn describe-maintenance-window-executions "Lists the executions of a Maintenance Window. This includes information about\nwhen the Maintenance Window was scheduled to be active, and information about\ntasks registered and run with the Maintenance Window." ([describe-maintenance-window-executions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-window-executions-request describe-maintenance-window-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-window-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-window-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowExecutions", :http.request.configuration/output-deser-fn response-describe-maintenance-window-executions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-executions :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-maintenance-window-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-window-executions-result))

(clojure.core/defn create-resource-data-sync "Creates a resource data sync configuration to a single bucket in Amazon S3. This\nis an asynchronous operation that returns immediately. After a successful\ninitial sync is completed, the system continuously syncs data to the Amazon S3\nbucket. To check the status of the sync, use the ListResourceDataSync.\n By default, data is not encrypted in Amazon S3. We strongly recommend that you\nenable encryption in Amazon S3 to ensure secure data storage. We also recommend\nthat you secure access to the Amazon S3 bucket by creating a restrictive bucket\npolicy. For more information, see Configuring Resource Data Sync for Inventory\n(http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-datasync.html)\nin the AWS Systems Manager User Guide." ([create-resource-data-sync-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-resource-data-sync-request create-resource-data-sync-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-resource-data-sync-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-resource-data-sync-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateResourceDataSync", :http.request.configuration/output-deser-fn response-create-resource-data-sync-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ResourceDataSyncCountExceededException" :portkey.aws.ssm/resource-data-sync-count-exceeded-exception, "ResourceDataSyncAlreadyExistsException" :portkey.aws.ssm/resource-data-sync-already-exists-exception, "ResourceDataSyncInvalidConfigurationException" :portkey.aws.ssm/resource-data-sync-invalid-configuration-exception}})))))
(clojure.spec.alpha/fdef create-resource-data-sync :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-resource-data-sync-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-resource-data-sync-result))

(clojure.core/defn delete-document "Deletes the Systems Manager document and all instance associations to the\ndocument.\n Before you delete the document, we recommend that you use DeleteAssociation to\ndisassociate all instances that are associated with the document." ([delete-document-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-document-request delete-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocument", :http.request.configuration/output-deser-fn response-delete-document-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidDocumentOperation" :portkey.aws.ssm/invalid-document-operation, "AssociatedInstances" :portkey.aws.ssm/associated-instances}})))))
(clojure.spec.alpha/fdef delete-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-document-result))

(clojure.core/defn delete-patch-baseline "Deletes a patch baseline." ([delete-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-patch-baseline-request delete-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePatchBaseline", :http.request.configuration/output-deser-fn response-delete-patch-baseline-result, :http.request.spec/error-spec {"ResourceInUseException" :portkey.aws.ssm/resource-in-use-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef delete-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-patch-baseline-result))

(clojure.core/defn remove-tags-from-resource "Removes all tags from the specified resource." ([remove-tags-from-resource-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-remove-tags-from-resource-request remove-tags-from-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/remove-tags-from-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/remove-tags-from-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveTagsFromResource", :http.request.configuration/output-deser-fn response-remove-tags-from-resource-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "InternalServerError" :portkey.aws.ssm/internal-server-error, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef remove-tags-from-resource :args (clojure.spec.alpha/tuple :portkey.aws.ssm/remove-tags-from-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/remove-tags-from-resource-result))

(clojure.core/defn describe-document-permission "Describes the permissions for a Systems Manager document. If you created the\ndocument, you are the owner. If a document is shared, it can either be shared\nprivately (by specifying a user's AWS account ID) or publicly (All)." ([describe-document-permission-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-document-permission-request describe-document-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-document-permission-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-document-permission-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDocumentPermission", :http.request.configuration/output-deser-fn response-describe-document-permission-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidDocument" :portkey.aws.ssm/invalid-document, "InvalidPermissionType" :portkey.aws.ssm/invalid-permission-type}})))))
(clojure.spec.alpha/fdef describe-document-permission :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-document-permission-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-document-permission-response))

(clojure.core/defn delete-maintenance-window "Deletes a Maintenance Window." ([delete-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-maintenance-window-request delete-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteMaintenanceWindow", :http.request.configuration/output-deser-fn response-delete-maintenance-window-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef delete-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-maintenance-window-result))

(clojure.core/defn get-automation-execution "Get detailed information about a particular Automation execution." ([get-automation-execution-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-automation-execution-request get-automation-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-automation-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-automation-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAutomationExecution", :http.request.configuration/output-deser-fn response-get-automation-execution-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm/automation-execution-not-found-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-automation-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-automation-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-automation-execution-result))

(clojure.core/defn create-maintenance-window "Creates a new Maintenance Window." ([create-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-create-maintenance-window-request create-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/create-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/create-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateMaintenanceWindow", :http.request.configuration/output-deser-fn response-create-maintenance-window-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm/idempotent-parameter-mismatch, "ResourceLimitExceededException" :portkey.aws.ssm/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef create-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/create-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/create-maintenance-window-result))

(clojure.core/defn describe-maintenance-window-targets "Lists the targets registered with the Maintenance Window." ([describe-maintenance-window-targets-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-window-targets-request describe-maintenance-window-targets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-window-targets-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-window-targets-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowTargets", :http.request.configuration/output-deser-fn response-describe-maintenance-window-targets-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-targets :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-maintenance-window-targets-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-window-targets-result))

(clojure.core/defn describe-patch-groups "Lists all patch groups that have been registered with patch baselines." ([] (describe-patch-groups {})) ([describe-patch-groups-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-patch-groups-request describe-patch-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-patch-groups-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-patch-groups-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePatchGroups", :http.request.configuration/output-deser-fn response-describe-patch-groups-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-patch-groups :args (clojure.spec.alpha/? :portkey.aws.ssm/describe-patch-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-patch-groups-result))

(clojure.core/defn list-inventory-entries "A list of inventory items returned by the request." ([list-inventory-entries-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-inventory-entries-request list-inventory-entries-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-inventory-entries-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-inventory-entries-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListInventoryEntries", :http.request.configuration/output-deser-fn response-list-inventory-entries-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidTypeNameException" :portkey.aws.ssm/invalid-type-name-exception, "InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-inventory-entries :args (clojure.spec.alpha/tuple :portkey.aws.ssm/list-inventory-entries-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-inventory-entries-result))

(clojure.core/defn delete-parameter "Delete a parameter from the system." ([delete-parameter-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-delete-parameter-request delete-parameter-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/delete-parameter-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/delete-parameter-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteParameter", :http.request.configuration/output-deser-fn response-delete-parameter-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "ParameterNotFound" :portkey.aws.ssm/parameter-not-found}})))))
(clojure.spec.alpha/fdef delete-parameter :args (clojure.spec.alpha/tuple :portkey.aws.ssm/delete-parameter-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/delete-parameter-result))

(clojure.core/defn put-parameter "Add a parameter to the system." ([put-parameter-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-put-parameter-request put-parameter-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/put-parameter-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/put-parameter-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutParameter", :http.request.configuration/output-deser-fn response-put-parameter-result, :http.request.spec/error-spec {"HierarchyTypeMismatchException" :portkey.aws.ssm/hierarchy-type-mismatch-exception, "TooManyUpdates" :portkey.aws.ssm/too-many-updates, "UnsupportedParameterType" :portkey.aws.ssm/unsupported-parameter-type, "HierarchyLevelLimitExceededException" :portkey.aws.ssm/hierarchy-level-limit-exceeded-exception, "ParameterAlreadyExists" :portkey.aws.ssm/parameter-already-exists, "ParameterLimitExceeded" :portkey.aws.ssm/parameter-limit-exceeded, "ParameterPatternMismatchException" :portkey.aws.ssm/parameter-pattern-mismatch-exception, "InvalidKeyId" :portkey.aws.ssm/invalid-key-id, "ParameterMaxVersionLimitExceeded" :portkey.aws.ssm/parameter-max-version-limit-exceeded, "InvalidAllowedPatternException" :portkey.aws.ssm/invalid-allowed-pattern-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef put-parameter :args (clojure.spec.alpha/tuple :portkey.aws.ssm/put-parameter-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/put-parameter-result))

(clojure.core/defn describe-maintenance-window-execution-task-invocations "Retrieves the individual task executions (one per target) for a particular task\nexecuted as part of a Maintenance Window execution." ([describe-maintenance-window-execution-task-invocations-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-maintenance-window-execution-task-invocations-request describe-maintenance-window-execution-task-invocations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-maintenance-window-execution-task-invocations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-maintenance-window-execution-task-invocations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowExecutionTaskInvocations", :http.request.configuration/output-deser-fn response-describe-maintenance-window-execution-task-invocations-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-execution-task-invocations :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-maintenance-window-execution-task-invocations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-maintenance-window-execution-task-invocations-result))

(clojure.core/defn register-target-with-maintenance-window "Registers a target with a Maintenance Window." ([register-target-with-maintenance-window-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-register-target-with-maintenance-window-request register-target-with-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/register-target-with-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/register-target-with-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterTargetWithMaintenanceWindow", :http.request.configuration/output-deser-fn response-register-target-with-maintenance-window-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm/idempotent-parameter-mismatch, "DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "ResourceLimitExceededException" :portkey.aws.ssm/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef register-target-with-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm/register-target-with-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/register-target-with-maintenance-window-result))

(clojure.core/defn label-parameter-version "A parameter label is a user-defined alias to help you manage different versions\nof a parameter. When you modify a parameter, Systems Manager automatically saves\na new version and increments the version number by one. A label can help you\nremember the purpose of a parameter when there are multiple versions.\n Parameter labels have the following requirements and restrictions.\n * A version of a parameter can have a maximum of 10 labels.\n * You can't attach the same label to different versions of the same parameter.\nFor example, if version 1 has the label Production, then you can't attach\nProduction to version 2.\n * You can move a label from one version of a parameter to another.\n * You can't create a label when you create a new parameter. You must attach a\nlabel to a specific version of a parameter.\n * You can't delete a parameter label. If you no longer want to use a parameter\nlabel, then you must move it to a different version of a parameter.\n * A label can have a maximum of 100 characters.\n * Labels can contain letters (case sensitive), numbers, periods (.), hyphens\n(-), or underscores (_).\n * Labels can't begin with a number, \"aws,\" or \"ssm\" (not case sensitive). If a\nlabel fails to meet these requirements, then the label is not associated with a\nparameter and the system displays it in the list of InvalidLabels." ([label-parameter-version-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-label-parameter-version-request label-parameter-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/label-parameter-version-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/label-parameter-version-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "LabelParameterVersion", :http.request.configuration/output-deser-fn response-label-parameter-version-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "TooManyUpdates" :portkey.aws.ssm/too-many-updates, "ParameterNotFound" :portkey.aws.ssm/parameter-not-found, "ParameterVersionNotFound" :portkey.aws.ssm/parameter-version-not-found, "ParameterVersionLabelLimitExceeded" :portkey.aws.ssm/parameter-version-label-limit-exceeded}})))))
(clojure.spec.alpha/fdef label-parameter-version :args (clojure.spec.alpha/tuple :portkey.aws.ssm/label-parameter-version-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/label-parameter-version-result))

(clojure.core/defn get-patch-baseline "Retrieves information about a patch baseline." ([get-patch-baseline-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-patch-baseline-request get-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPatchBaseline", :http.request.configuration/output-deser-fn response-get-patch-baseline-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef get-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm/get-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-patch-baseline-result))

(clojure.core/defn list-compliance-summaries "Returns a summary count of compliant and non-compliant resources for a\ncompliance type. For example, this call can return State Manager associations,\npatches, or custom compliance types according to the filter criteria that you\nspecify." ([] (list-compliance-summaries {})) ([list-compliance-summaries-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-compliance-summaries-request list-compliance-summaries-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-compliance-summaries-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-compliance-summaries-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListComplianceSummaries", :http.request.configuration/output-deser-fn response-list-compliance-summaries-result, :http.request.spec/error-spec {"InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef list-compliance-summaries :args (clojure.spec.alpha/? :portkey.aws.ssm/list-compliance-summaries-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-compliance-summaries-result))

(clojure.core/defn get-inventory "Query inventory information." ([] (get-inventory {})) ([get-inventory-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-inventory-request get-inventory-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-inventory-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-inventory-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInventory", :http.request.configuration/output-deser-fn response-get-inventory-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidInventoryGroupException" :portkey.aws.ssm/invalid-inventory-group-exception, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token, "InvalidTypeNameException" :portkey.aws.ssm/invalid-type-name-exception, "InvalidAggregatorException" :portkey.aws.ssm/invalid-aggregator-exception, "InvalidResultAttributeException" :portkey.aws.ssm/invalid-result-attribute-exception}})))))
(clojure.spec.alpha/fdef get-inventory :args (clojure.spec.alpha/? :portkey.aws.ssm/get-inventory-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-inventory-result))

(clojure.core/defn add-tags-to-resource "Adds or overwrites one or more tags for the specified resource. Tags are\nmetadata that you can assign to your documents, managed instances, Maintenance\nWindows, Parameter Store parameters, and patch baselines. Tags enable you to\ncategorize your resources in different ways, for example, by purpose, owner, or\nenvironment. Each tag consists of a key and an optional value, both of which you\ndefine. For example, you could define a set of tags for your account's managed\ninstances that helps you track each instance's owner and stack level. For\nexample: Key=Owner and Value=DbAdmin, SysAdmin, or Dev. Or Key=Stack and\nValue=Production, Pre-Production, or Test.\n Each resource can have a maximum of 50 tags.\n We recommend that you devise a set of tag keys that meets your needs for each\nresource type. Using a consistent set of tag keys makes it easier for you to\nmanage your resources. You can search and filter the resources based on the tags\nyou add. Tags don't have any semantic meaning to Amazon EC2 and are interpreted\nstrictly as a string of characters.\n For more information about tags, see Tagging Your Amazon EC2 Resources\n(http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the\nAmazon EC2 User Guide." ([add-tags-to-resource-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-add-tags-to-resource-request add-tags-to-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/add-tags-to-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/add-tags-to-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddTagsToResource", :http.request.configuration/output-deser-fn response-add-tags-to-resource-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm/invalid-resource-id, "InternalServerError" :portkey.aws.ssm/internal-server-error, "TooManyTagsError" :portkey.aws.ssm/too-many-tags-error, "TooManyUpdates" :portkey.aws.ssm/too-many-updates}})))))
(clojure.spec.alpha/fdef add-tags-to-resource :args (clojure.spec.alpha/tuple :portkey.aws.ssm/add-tags-to-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/add-tags-to-resource-result))

(clojure.core/defn describe-instance-associations-status "The status of the associations for the instance(s)." ([describe-instance-associations-status-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-instance-associations-status-request describe-instance-associations-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-instance-associations-status-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-instance-associations-status-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceAssociationsStatus", :http.request.configuration/output-deser-fn response-describe-instance-associations-status-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-associations-status :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-instance-associations-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-instance-associations-status-result))

(clojure.core/defn terminate-session "Permanently ends a session and closes the data connection between the Session\nManager client and SSM Agent on the instance. A terminated session cannot be\nresumed." ([terminate-session-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-terminate-session-request terminate-session-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/terminate-session-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/terminate-session-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TerminateSession", :http.request.configuration/output-deser-fn response-terminate-session-response, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm/internal-server-error}})))))
(clojure.spec.alpha/fdef terminate-session :args (clojure.spec.alpha/tuple :portkey.aws.ssm/terminate-session-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/terminate-session-response))

(clojure.core/defn list-command-invocations "An invocation is copy of a command sent to a specific instance. A command can\napply to one or more instances. A command invocation applies to one instance.\nFor example, if a user executes SendCommand against three instances, then a\ncommand invocation is created for each requested instance ID.\nListCommandInvocations provide status about command execution." ([] (list-command-invocations {})) ([list-command-invocations-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-list-command-invocations-request list-command-invocations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/list-command-invocations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/list-command-invocations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCommandInvocations", :http.request.configuration/output-deser-fn response-list-command-invocations-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidCommandId" :portkey.aws.ssm/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidFilterKey" :portkey.aws.ssm/invalid-filter-key, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-command-invocations :args (clojure.spec.alpha/? :portkey.aws.ssm/list-command-invocations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/list-command-invocations-result))

(clojure.core/defn get-inventory-schema "Return a list of inventory type names for the account, or return a list of\nattribute names for a specific Inventory item type." ([] (get-inventory-schema {})) ([get-inventory-schema-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-get-inventory-schema-request get-inventory-schema-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/get-inventory-schema-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/get-inventory-schema-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInventorySchema", :http.request.configuration/output-deser-fn response-get-inventory-schema-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidTypeNameException" :portkey.aws.ssm/invalid-type-name-exception, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef get-inventory-schema :args (clojure.spec.alpha/? :portkey.aws.ssm/get-inventory-schema-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/get-inventory-schema-result))

(clojure.core/defn describe-association-executions "Use this API action to view all executions for a specific association ID." ([describe-association-executions-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-association-executions-request describe-association-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-association-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-association-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAssociationExecutions", :http.request.configuration/output-deser-fn response-describe-association-executions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "AssociationDoesNotExist" :portkey.aws.ssm/association-does-not-exist, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-association-executions :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-association-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-association-executions-result))

(clojure.core/defn describe-instance-patches "Retrieves information about the patches on the specified instance and their\nstate relative to the patch baseline being used for the instance." ([describe-instance-patches-requestinput] (clojure.core/let [request-function-result__1411981__auto__ (req-describe-instance-patches-request describe-instance-patches-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1411981__auto__ {:http.request.configuration/endpoints portkey.aws.ssm/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm/describe-instance-patches-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm/describe-instance-patches-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstancePatches", :http.request.configuration/output-deser-fn response-describe-instance-patches-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm/invalid-instance-id, "InvalidFilter" :portkey.aws.ssm/invalid-filter, "InvalidNextToken" :portkey.aws.ssm/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-patches :args (clojure.spec.alpha/tuple :portkey.aws.ssm/describe-instance-patches-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm/describe-instance-patches-result))
