(ns portkey.aws.ssm.-2014-11-06 (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "ssm", :region "us-gov-east-1"},
    :ssl-common-name "ssm.us-gov-east-1.amazonaws.com",
    :endpoint "https://ssm.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope {:service "ssm", :region "ap-northeast-1"},
    :ssl-common-name "ssm.ap-northeast-1.amazonaws.com",
    :endpoint "https://ssm.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "ssm", :region "eu-west-1"},
    :ssl-common-name "ssm.eu-west-1.amazonaws.com",
    :endpoint "https://ssm.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "ssm", :region "us-east-2"},
    :ssl-common-name "ssm.us-east-2.amazonaws.com",
    :endpoint "https://ssm.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "ssm", :region "ap-southeast-2"},
    :ssl-common-name "ssm.ap-southeast-2.amazonaws.com",
    :endpoint "https://ssm.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "ssm", :region "cn-north-1"},
    :ssl-common-name "ssm.cn-north-1.amazonaws.com.cn",
    :endpoint "https://ssm.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "ssm", :region "sa-east-1"},
    :ssl-common-name "ssm.sa-east-1.amazonaws.com",
    :endpoint "https://ssm.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "ssm", :region "ap-southeast-1"},
    :ssl-common-name "ssm.ap-southeast-1.amazonaws.com",
    :endpoint "https://ssm.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "ssm", :region "cn-northwest-1"},
    :ssl-common-name "ssm.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://ssm.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "ssm", :region "ap-northeast-2"},
    :ssl-common-name "ssm.ap-northeast-2.amazonaws.com",
    :endpoint "https://ssm.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "ssm", :region "eu-west-3"},
    :ssl-common-name "ssm.eu-west-3.amazonaws.com",
    :endpoint "https://ssm.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "ssm", :region "ca-central-1"},
    :ssl-common-name "ssm.ca-central-1.amazonaws.com",
    :endpoint "https://ssm.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "ssm", :region "eu-central-1"},
    :ssl-common-name "ssm.eu-central-1.amazonaws.com",
    :endpoint "https://ssm.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "ssm", :region "eu-west-2"},
    :ssl-common-name "ssm.eu-west-2.amazonaws.com",
    :endpoint "https://ssm.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "ssm", :region "us-gov-west-1"},
    :ssl-common-name "ssm.us-gov-west-1.amazonaws.com",
    :endpoint "https://ssm.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "ssm", :region "us-west-2"},
    :ssl-common-name "ssm.us-west-2.amazonaws.com",
    :endpoint "https://ssm.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "ssm", :region "us-east-1"},
    :ssl-common-name "ssm.us-east-1.amazonaws.com",
    :endpoint "https://ssm.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "ssm", :region "us-west-1"},
    :ssl-common-name "ssm.us-west-1.amazonaws.com",
    :endpoint "https://ssm.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "ssm", :region "ap-south-1"},
    :ssl-common-name "ssm.ap-south-1.amazonaws.com",
    :endpoint "https://ssm.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "ssm", :region "eu-north-1"},
    :ssl-common-name "ssm.eu-north-1.amazonaws.com",
    :endpoint "https://ssm.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-parameter-string-filter-value)

(clojure.core/declare ser-attachments-source-list)

(clojure.core/declare ser-target-map)

(clojure.core/declare ser-instance-information-filter-value-set)

(clojure.core/declare ser-instance-id-list)

(clojure.core/declare ser-automation-parameter-key)

(clojure.core/declare ser-automation-execution-filter-value)

(clojure.core/declare ser-dry-run)

(clojure.core/declare ser-approve-after-days)

(clojure.core/declare ser-string-list)

(clojure.core/declare ser-maintenance-window-run-command-parameters)

(clojure.core/declare ser-automation-execution-filter-key)

(clojure.core/declare ser-parameter-value-list)

(clojure.core/declare ser-command-filter-value)

(clojure.core/declare ser-document-content)

(clojure.core/declare ser-inventory-filter-value-list)

(clojure.core/declare ser-association-version)

(clojure.core/declare ser-target-maps)

(clojure.core/declare ser-service-role)

(clojure.core/declare ser-maintenance-window-enabled)

(clojure.core/declare ser-maintenance-window-name)

(clojure.core/declare ser-instance-id)

(clojure.core/declare ser-instance-information-filter-list)

(clojure.core/declare ser-compliance-item-entry-list)

(clojure.core/declare ser-maintenance-window-search-max-results)

(clojure.core/declare ser-step-execution-filter)

(clojure.core/declare ser-patch-group)

(clojure.core/declare ser-compliance-item-entry)

(clojure.core/declare ser-patch-filter)

(clojure.core/declare ser-notification-event)

(clojure.core/declare ser-instance-information-filter)

(clojure.core/declare ser-inventory-aggregator)

(clojure.core/declare ser-document-version-name)

(clojure.core/declare ser-parameter-name)

(clojure.core/declare ser-patch-orchestrator-filter)

(clojure.core/declare ser-parameter-type)

(clojure.core/declare ser-inventory-query-operator-type)

(clojure.core/declare ser-parameter-string-filter)

(clojure.core/declare ser-s-3-region)

(clojure.core/declare ser-instance-patch-state-filter-value)

(clojure.core/declare ser-document-filter-key)

(clojure.core/declare ser-comment)

(clojure.core/declare ser-compliance-resource-type)

(clojure.core/declare ser-association-id-list)

(clojure.core/declare ser-document-key-values-filter-list)

(clojure.core/declare ser-patch-source)

(clojure.core/declare ser-compliance-string-filter-list)

(clojure.core/declare ser-instance-information-filter-value)

(clojure.core/declare ser-instance-information-string-filter-list)

(clojure.core/declare ser-command-max-results)

(clojure.core/declare ser-parameter-label-list)

(clojure.core/declare ser-association-execution-filter)

(clojure.core/declare ser-inventory-filter)

(clojure.core/declare ser-inventory-item-type-name-filter)

(clojure.core/declare ser-maintenance-window-filter-values)

(clojure.core/declare ser-get-parameters-by-path-max-results)

(clojure.core/declare ser-session-id)

(clojure.core/declare ser-ps-parameter-version)

(clojure.core/declare ser-account-id-list)

(clojure.core/declare ser-session-max-results)

(clojure.core/declare ser-maintenance-window-execution-task-id)

(clojure.core/declare ser-patch-orchestrator-filter-list)

(clojure.core/declare ser-maintenance-window-cutoff)

(clojure.core/declare ser-timeout-seconds)

(clojure.core/declare ser-resource-data-sync-s-3-region)

(clojure.core/declare ser-attribute-name)

(clojure.core/declare ser-parameters-filter)

(clojure.core/declare ser-status-additional-info)

(clojure.core/declare ser-parameter-string-filter-list)

(clojure.core/declare ser-resource-data-sync-awskms-key-arn)

(clojure.core/declare ser-association-execution-filter-value)

(clojure.core/declare ser-status-message)

(clojure.core/declare ser-patch-orchestrator-filter-value)

(clojure.core/declare ser-patch-rule)

(clojure.core/declare ser-execution-mode)

(clojure.core/declare ser-inventory-item-content-hash)

(clojure.core/declare ser-patch-orchestrator-filter-key)

(clojure.core/declare ser-key-list)

(clojure.core/declare ser-inventory-item-entry)

(clojure.core/declare ser-cloud-watch-log-group-name)

(clojure.core/declare ser-parameters)

(clojure.core/declare ser-inventory-filter-value)

(clojure.core/declare ser-association-execution-id)

(clojure.core/declare ser-resource-data-sync-s-3-format)

(clojure.core/declare ser-attachments-source-key)

(clojure.core/declare ser-document-type)

(clojure.core/declare ser-parameters-filter-value)

(clojure.core/declare ser-association-id)

(clojure.core/declare ser-get-inventory-schema-max-results)

(clojure.core/declare ser-automation-execution-filter-list)

(clojure.core/declare ser-session-filter-list)

(clojure.core/declare ser-parameters-filter-key)

(clojure.core/declare ser-inventory-group)

(clojure.core/declare ser-compliance-item-title)

(clojure.core/declare ser-document-key-values-filter-values)

(clojure.core/declare ser-document-key-values-filter)

(clojure.core/declare ser-tag-key)

(clojure.core/declare ser-parameter-name-list)

(clojure.core/declare ser-target-type)

(clojure.core/declare ser-resource-data-sync-s-3-prefix)

(clojure.core/declare ser-notification-config)

(clojure.core/declare ser-s-3-bucket-name)

(clojure.core/declare ser-document-hash)

(clojure.core/declare ser-inventory-filter-list)

(clojure.core/declare ser-association-execution-targets-filter-list)

(clojure.core/declare ser-parameters-filter-value-list)

(clojure.core/declare ser-iam-role)

(clojure.core/declare ser-compliance-severity)

(clojure.core/declare ser-session-state)

(clojure.core/declare ser-notification-type)

(clojure.core/declare ser-maintenance-window-lambda-payload)

(clojure.core/declare ser-result-attribute)

(clojure.core/declare ser-maintenance-window-task-arn)

(clojure.core/declare ser-maintenance-window-lambda-qualifier)

(clojure.core/declare ser-target-map-key)

(clojure.core/declare ser-association-status)

(clojure.core/declare ser-target-locations)

(clojure.core/declare ser-association-filter-key)

(clojure.core/declare ser-inventory-schema-delete-option)

(clojure.core/declare ser-maintenance-window-task-parameters)

(clojure.core/declare ser-next-token)

(clojure.core/declare ser-session-manager-parameter-value-list)

(clojure.core/declare ser-resource-data-sync-s-3-destination)

(clojure.core/declare ser-aggregator-schema-only)

(clojure.core/declare ser-cloud-watch-output-config)

(clojure.core/declare ser-parameter-string-query-option)

(clojure.core/declare ser-patch-baseline-max-results)

(clojure.core/declare ser-default-instance-name)

(clojure.core/declare ser-instance-information-filter-key)

(clojure.core/declare ser-maintenance-window-task-parameter-name)

(clojure.core/declare ser-session-target)

(clojure.core/declare ser-expiration-date)

(clojure.core/declare ser-maintenance-window-task-priority)

(clojure.core/declare ser-document-arn)

(clojure.core/declare ser-patch-id)

(clojure.core/declare ser-max-concurrency)

(clojure.core/declare ser-resource-id)

(clojure.core/declare ser-maintenance-window-task-id)

(clojure.core/declare ser-maintenance-window-filter)

(clojure.core/declare ser-patch-action)

(clojure.core/declare ser-stop-type)

(clojure.core/declare ser-regions)

(clojure.core/declare ser-step-execution-filter-value)

(clojure.core/declare ser-patch-compliance-max-results)

(clojure.core/declare ser-instance-patch-state-filter-values)

(clojure.core/declare ser-signal-type)

(clojure.core/declare ser-compliance-item-id)

(clojure.core/declare ser-association-filter-value)

(clojure.core/declare ser-cloud-watch-output-enabled)

(clojure.core/declare ser-document-filter-value)

(clojure.core/declare ser-parameter-label)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-compliance-string-filter)

(clojure.core/declare ser-compliance-type-name)

(clojure.core/declare ser-patch-id-list)

(clojure.core/declare ser-document-key-values-filter-value)

(clojure.core/declare ser-logging-info)

(clojure.core/declare ser-ps-parameter-value)

(clojure.core/declare ser-patch-filter-group)

(clojure.core/declare ser-instance-patch-state-filter)

(clojure.core/declare ser-command-plugin-name)

(clojure.core/declare ser-attribute-value)

(clojure.core/declare ser-maintenance-window-execution-task-invocation-id)

(clojure.core/declare ser-parameter-key-id)

(clojure.core/declare ser-automation-parameter-map)

(clojure.core/declare ser-step-execution-filter-value-list)

(clojure.core/declare ser-document-filter-list)

(clojure.core/declare ser-patch-rule-group)

(clojure.core/declare ser-inventory-item-list)

(clojure.core/declare ser-accounts)

(clojure.core/declare ser-maintenance-window-filter-list)

(clojure.core/declare ser-service-setting-value)

(clojure.core/declare ser-association-filter-list)

(clojure.core/declare ser-max-errors)

(clojure.core/declare ser-parameter-string-filter-key)

(clojure.core/declare ser-inventory-item-schema-version)

(clojure.core/declare ser-compliance-status)

(clojure.core/declare ser-parameter-string-filter-value-list)

(clojure.core/declare ser-account)

(clojure.core/declare ser-compliance-execution-summary)

(clojure.core/declare ser-attachments-source-values)

(clojure.core/declare ser-attachments-source)

(clojure.core/declare ser-allowed-pattern)

(clojure.core/declare ser-tag-value)

(clojure.core/declare ser-compliance-string-filter-key)

(clojure.core/declare ser-inventory-filter-key)

(clojure.core/declare ser-command-filter-key)

(clojure.core/declare ser-patch-source-product-list)

(clojure.core/declare ser-baseline-id)

(clojure.core/declare ser-inventory-group-name)

(clojure.core/declare ser-maintenance-window-target-id)

(clojure.core/declare ser-association-execution-filter-key)

(clojure.core/declare ser-managed-instance-id)

(clojure.core/declare ser-compliance-string-filter-value-list)

(clojure.core/declare ser-maintenance-window-id)

(clojure.core/declare ser-session-manager-parameter-name)

(clojure.core/declare ser-patch-orchestrator-filter-values)

(clojure.core/declare ser-attachments-source-value)

(clojure.core/declare ser-instance-patch-state-filter-list)

(clojure.core/declare ser-automation-target-parameter-name)

(clojure.core/declare ser-compliance-execution-id)

(clojure.core/declare ser-maintenance-window-description)

(clojure.core/declare ser-association-name)

(clojure.core/declare ser-maintenance-window-lambda-client-context)

(clojure.core/declare ser-effective-instance-association-max-results)

(clojure.core/declare ser-step-execution-filter-list)

(clojure.core/declare ser-string)

(clojure.core/declare ser-parameter-description)

(clojure.core/declare ser-automation-execution-filter)

(clojure.core/declare ser-inventory-item-content-context)

(clojure.core/declare ser-account-id)

(clojure.core/declare ser-instance-patch-state-filter-key)

(clojure.core/declare ser-create-association-batch-request-entry)

(clojure.core/declare ser-automation-execution-filter-value-list)

(clojure.core/declare ser-patch-filter-key)

(clojure.core/declare ser-maintenance-window-lambda-parameters)

(clojure.core/declare ser-patch-source-list)

(clojure.core/declare ser-target-location)

(clojure.core/declare ser-maintenance-window-max-results)

(clojure.core/declare ser-notification-arn)

(clojure.core/declare ser-instance-information-string-filter)

(clojure.core/declare ser-maintenance-window-step-functions-input)

(clojure.core/declare ser-activation-id)

(clojure.core/declare ser-inventory-aggregator-expression)

(clojure.core/declare ser-document-format)

(clojure.core/declare ser-targets)

(clojure.core/declare ser-patch-compliance-level)

(clojure.core/declare ser-patch-source-configuration)

(clojure.core/declare ser-target-map-value)

(clojure.core/declare ser-compliance-resource-type-list)

(clojure.core/declare ser-association-execution-targets-filter-value)

(clojure.core/declare ser-parameters-filter-list)

(clojure.core/declare ser-execution-role-name)

(clojure.core/declare ser-baseline-name)

(clojure.core/declare ser-maintenance-window-step-functions-name)

(clojure.core/declare ser-compliance-resource-id)

(clojure.core/declare ser-association-execution-filter-list)

(clojure.core/declare ser-resource-data-sync-s-3-bucket-name)

(clojure.core/declare ser-maintenance-window-duration-hours)

(clojure.core/declare ser-s-3-key-prefix)

(clojure.core/declare ser-inventory-aggregator-list)

(clojure.core/declare ser-compliance-execution-type)

(clojure.core/declare ser-idempotency-token)

(clojure.core/declare ser-document-permission-type)

(clojure.core/declare ser-schedule-expression)

(clojure.core/declare ser-resource-type-for-tagging)

(clojure.core/declare ser-document-version-number)

(clojure.core/declare ser-command-id)

(clojure.core/declare ser-patch-source-name)

(clojure.core/declare ser-inventory-item-entry-list)

(clojure.core/declare ser-association-status-name)

(clojure.core/declare ser-command-filter)

(clojure.core/declare ser-session-filter-value)

(clojure.core/declare ser-maintenance-window-filter-value)

(clojure.core/declare ser-resource-data-sync-name)

(clojure.core/declare ser-patch-rule-list)

(clojure.core/declare ser-owner-information)

(clojure.core/declare ser-describe-activations-filter-list)

(clojure.core/declare ser-maintenance-window-string-date-time)

(clojure.core/declare ser-describe-activations-filter)

(clojure.core/declare ser-service-setting-id)

(clojure.core/declare ser-s-3-output-location)

(clojure.core/declare ser-automation-parameter-value)

(clojure.core/declare ser-patch-filter-value-list)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-create-association-batch-request-entries)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-maintenance-window-schedule)

(clojure.core/declare ser-inventory-item-type-name)

(clojure.core/declare ser-result-attribute-list)

(clojure.core/declare ser-document-key-values-filter-key)

(clojure.core/declare ser-maintenance-window-task-invocation-parameters)

(clojure.core/declare ser-step-execution-filter-key)

(clojure.core/declare ser-document-name)

(clojure.core/declare ser-compliance-item-content-hash)

(clojure.core/declare ser-maintenance-window-step-functions-parameters)

(clojure.core/declare ser-patch-filter-value)

(clojure.core/declare ser-maintenance-window-task-type)

(clojure.core/declare ser-maintenance-window-allow-unassociated-targets)

(clojure.core/declare ser-session-manager-parameters)

(clojure.core/declare ser-inventory-item)

(clojure.core/declare ser-command-filter-list)

(clojure.core/declare ser-inventory-group-list)

(clojure.core/declare ser-document-version)

(clojure.core/declare ser-target)

(clojure.core/declare ser-document-hash-type)

(clojure.core/declare ser-session-filter-key)

(clojure.core/declare ser-maintenance-window-filter-key)

(clojure.core/declare ser-document-filter)

(clojure.core/declare ser-session-manager-parameter-value)

(clojure.core/declare ser-describe-activations-filter-keys)

(clojure.core/declare ser-maintenance-window-timezone)

(clojure.core/declare ser-association-compliance-severity)

(clojure.core/declare ser-activation-description)

(clojure.core/declare ser-is-sub-type-schema)

(clojure.core/declare ser-compliance-filter-value)

(clojure.core/declare ser-ps-parameter-name)

(clojure.core/declare ser-instance-association-output-location)

(clojure.core/declare ser-session-filter)

(clojure.core/declare ser-maintenance-window-automation-parameters)

(clojure.core/declare ser-compliance-resource-id-list)

(clojure.core/declare ser-inventory-item-capture-time)

(clojure.core/declare ser-association-execution-targets-filter)

(clojure.core/declare ser-baseline-description)

(clojure.core/declare ser-maintenance-window-execution-id)

(clojure.core/declare ser-compliance-query-operator-type)

(clojure.core/declare ser-automation-execution-id)

(clojure.core/declare ser-target-value)

(clojure.core/declare ser-patch-filter-list)

(clojure.core/declare ser-inventory-deletion-id)

(clojure.core/declare ser-region)

(clojure.core/declare ser-patch-source-product)

(clojure.core/declare ser-instance-patch-state-operator-type)

(clojure.core/declare ser-maintenance-window-task-parameter-value-expression)

(clojure.core/declare ser-target-map-value-list)

(clojure.core/declare ser-target-key)

(clojure.core/declare ser-automation-parameter-value-list)

(clojure.core/declare ser-compliance-item-details)

(clojure.core/declare ser-maintenance-window-task-parameter-value-list)

(clojure.core/declare ser-instance-information-string-filter-key)

(clojure.core/declare ser-max-results-ec-2-compatible)

(clojure.core/declare ser-association-execution-targets-filter-key)

(clojure.core/declare ser-operating-system)

(clojure.core/declare ser-association-filter)

(clojure.core/declare ser-client-token)

(clojure.core/declare ser-notification-event-list)

(clojure.core/declare ser-snapshot-id)

(clojure.core/declare ser-registration-limit)

(clojure.core/declare ser-parameter-value)

(clojure.core/declare ser-association-filter-operator-type)

(clojure.core/declare ser-date-time)

(clojure.core/declare ser-target-values)

(clojure.core/declare ser-maintenance-window-task-parameter-value)

(clojure.core/declare ser-boolean)

(clojure.core/declare ser-maintenance-window-resource-type)

(clojure.core/defn- ser-parameter-string-filter-value [input] #:http.request.field{:value input, :shape "ParameterStringFilterValue"})

(clojure.core/defn- ser-attachments-source-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-attachments-source coll) #:http.request.field{:shape "AttachmentsSource"}))) input), :shape "AttachmentsSourceList", :type "list", :max 1, :min 0})

(clojure.core/defn- ser-target-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-target-map-key k) #:http.request.field{:map-info "key", :shape "TargetMapKey"}) (clojure.core/into (ser-target-map-value-list v) #:http.request.field{:map-info "value", :shape "TargetMapValueList"})])) input), :shape "TargetMap", :type "map", :max 20, :min 1})

(clojure.core/defn- ser-instance-information-filter-value-set [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-information-filter-value coll) #:http.request.field{:shape "InstanceInformationFilterValue"}))) input), :shape "InstanceInformationFilterValueSet", :type "list", :max 100, :min 1})

(clojure.core/defn- ser-instance-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-id coll) #:http.request.field{:shape "InstanceId"}))) input), :shape "InstanceIdList", :type "list", :max 50, :min 0})

(clojure.core/defn- ser-automation-parameter-key [input] #:http.request.field{:value input, :shape "AutomationParameterKey"})

(clojure.core/defn- ser-automation-execution-filter-value [input] #:http.request.field{:value input, :shape "AutomationExecutionFilterValue"})

(clojure.core/defn- ser-dry-run [input] #:http.request.field{:value input, :shape "DryRun"})

(clojure.core/defn- ser-approve-after-days [input] #:http.request.field{:value input, :shape "ApproveAfterDays"})

(clojure.core/defn- ser-string-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "StringList", :type "list"})

(clojure.core/defn- ser-maintenance-window-run-command-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowRunCommandParameters", :type "structure"} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "Comment", :shape "Comment"})) (clojure.core/contains? input :timeout-seconds) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-seconds (input :timeout-seconds)) #:http.request.field{:name "TimeoutSeconds", :shape "TimeoutSeconds", :box true})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :output-s-3-bucket-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket-name (input :output-s-3-bucket-name)) #:http.request.field{:name "OutputS3BucketName", :shape "S3BucketName"})) (clojure.core/contains? input :notification-config) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-config (input :notification-config)) #:http.request.field{:name "NotificationConfig", :shape "NotificationConfig"})) (clojure.core/contains? input :document-hash) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash (input :document-hash)) #:http.request.field{:name "DocumentHash", :shape "DocumentHash"})) (clojure.core/contains? input :output-s-3-key-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :output-s-3-key-prefix)) #:http.request.field{:name "OutputS3KeyPrefix", :shape "S3KeyPrefix"})) (clojure.core/contains? input :document-hash-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash-type (input :document-hash-type)) #:http.request.field{:name "DocumentHashType", :shape "DocumentHashType"}))))

(clojure.core/defn- ser-automation-execution-filter-key [input] #:http.request.field{:value (clojure.core/get {"AutomationType" "AutomationType", "StartTimeBefore" "StartTimeBefore", "ParentExecutionId" "ParentExecutionId", :automation-type "AutomationType", :document-name-prefix "DocumentNamePrefix", :parent-execution-id "ParentExecutionId", :start-time-before "StartTimeBefore", "StartTimeAfter" "StartTimeAfter", "CurrentAction" "CurrentAction", :execution-status "ExecutionStatus", "ExecutionId" "ExecutionId", :current-action "CurrentAction", :execution-id "ExecutionId", "ExecutionStatus" "ExecutionStatus", "DocumentNamePrefix" "DocumentNamePrefix", :start-time-after "StartTimeAfter"} input), :shape "AutomationExecutionFilterKey"})

(clojure.core/defn- ser-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-value coll) #:http.request.field{:shape "ParameterValue"}))) input), :shape "ParameterValueList", :type "list"})

(clojure.core/defn- ser-command-filter-value [input] #:http.request.field{:value input, :shape "CommandFilterValue"})

(clojure.core/defn- ser-document-content [input] #:http.request.field{:value input, :shape "DocumentContent"})

(clojure.core/defn- ser-inventory-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-filter-value coll) #:http.request.field{:shape "InventoryFilterValue"}))) input), :shape "InventoryFilterValueList", :type "list", :max 40, :min 1})

(clojure.core/defn- ser-association-version [input] #:http.request.field{:value input, :shape "AssociationVersion"})

(clojure.core/defn- ser-target-maps [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-map coll) #:http.request.field{:shape "TargetMap"}))) input), :shape "TargetMaps", :type "list", :max 300, :min 0})

(clojure.core/defn- ser-service-role [input] #:http.request.field{:value input, :shape "ServiceRole"})

(clojure.core/defn- ser-maintenance-window-enabled [input] #:http.request.field{:value input, :shape "MaintenanceWindowEnabled"})

(clojure.core/defn- ser-maintenance-window-name [input] #:http.request.field{:value input, :shape "MaintenanceWindowName"})

(clojure.core/defn- ser-instance-id [input] #:http.request.field{:value input, :shape "InstanceId"})

(clojure.core/defn- ser-instance-information-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-information-filter coll) #:http.request.field{:shape "InstanceInformationFilter"}))) input), :shape "InstanceInformationFilterList", :type "list", :min 0})

(clojure.core/defn- ser-compliance-item-entry-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-item-entry coll) #:http.request.field{:shape "ComplianceItemEntry"}))) input), :shape "ComplianceItemEntryList", :type "list", :max 10000, :min 0})

(clojure.core/defn- ser-maintenance-window-search-max-results [input] #:http.request.field{:value input, :shape "MaintenanceWindowSearchMaxResults"})

(clojure.core/defn- ser-step-execution-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-step-execution-filter-key (:key input)) #:http.request.field{:name "Key", :shape "StepExecutionFilterKey"}) (clojure.core/into (ser-step-execution-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "StepExecutionFilterValueList"})], :shape "StepExecutionFilter", :type "structure"}))

(clojure.core/defn- ser-patch-group [input] #:http.request.field{:value input, :shape "PatchGroup"})

(clojure.core/defn- ser-compliance-item-entry [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-compliance-severity (:severity input)) #:http.request.field{:name "Severity", :shape "ComplianceSeverity"}) (clojure.core/into (ser-compliance-status (:status input)) #:http.request.field{:name "Status", :shape "ComplianceStatus"})], :shape "ComplianceItemEntry", :type "structure"} (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-id (input :id)) #:http.request.field{:name "Id", :shape "ComplianceItemId"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-title (input :title)) #:http.request.field{:name "Title", :shape "ComplianceItemTitle"})) (clojure.core/contains? input :details) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-details (input :details)) #:http.request.field{:name "Details", :shape "ComplianceItemDetails"}))))

(clojure.core/defn- ser-patch-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-filter-key (:key input)) #:http.request.field{:name "Key", :shape "PatchFilterKey"}) (clojure.core/into (ser-patch-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "PatchFilterValueList"})], :shape "PatchFilter", :type "structure"}))

(clojure.core/defn- ser-notification-event [input] #:http.request.field{:value (clojure.core/get {:timed-out "TimedOut", "Failed" "Failed", "Cancelled" "Cancelled", :in-progress "InProgress", "TimedOut" "TimedOut", :all "All", "Success" "Success", :cancelled "Cancelled", :success "Success", "InProgress" "InProgress", "All" "All", :failed "Failed"} input), :shape "NotificationEvent"})

(clojure.core/defn- ser-instance-information-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-instance-information-filter-key (:key input)) #:http.request.field{:name "key", :shape "InstanceInformationFilterKey"}) (clojure.core/into (ser-instance-information-filter-value-set (:value-set input)) #:http.request.field{:name "valueSet", :shape "InstanceInformationFilterValueSet"})], :shape "InstanceInformationFilter", :type "structure"}))

(clojure.core/defn- ser-inventory-aggregator [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InventoryAggregator", :type "structure"} (clojure.core/contains? input :expression) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-aggregator-expression (input :expression)) #:http.request.field{:name "Expression", :shape "InventoryAggregatorExpression"})) (clojure.core/contains? input :aggregators) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-aggregator-list (input :aggregators)) #:http.request.field{:name "Aggregators", :shape "InventoryAggregatorList"})) (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-group-list (input :groups)) #:http.request.field{:name "Groups", :shape "InventoryGroupList"}))))

(clojure.core/defn- ser-document-version-name [input] #:http.request.field{:value input, :shape "DocumentVersionName"})

(clojure.core/defn- ser-parameter-name [input] #:http.request.field{:value input, :shape "ParameterName"})

(clojure.core/defn- ser-patch-orchestrator-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PatchOrchestratorFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-key (input :key)) #:http.request.field{:name "Key", :shape "PatchOrchestratorFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-values (input :values)) #:http.request.field{:name "Values", :shape "PatchOrchestratorFilterValues"}))))

(clojure.core/defn- ser-parameter-type [input] #:http.request.field{:value (clojure.core/get {"String" "String", :string "String", "StringList" "StringList", :string-list "StringList", "SecureString" "SecureString", :secure-string "SecureString"} input), :shape "ParameterType"})

(clojure.core/defn- ser-inventory-query-operator-type [input] #:http.request.field{:value (clojure.core/get {:exists "Exists", "NotEqual" "NotEqual", :less-than "LessThan", "BeginWith" "BeginWith", "Exists" "Exists", "Equal" "Equal", "LessThan" "LessThan", :greater-than "GreaterThan", "GreaterThan" "GreaterThan", :not-equal "NotEqual", :begin-with "BeginWith", :equal "Equal"} input), :shape "InventoryQueryOperatorType"})

(clojure.core/defn- ser-parameter-string-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-parameter-string-filter-key (:key input)) #:http.request.field{:name "Key", :shape "ParameterStringFilterKey"})], :shape "ParameterStringFilter", :type "structure"} (clojure.core/contains? input :option) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-query-option (input :option)) #:http.request.field{:name "Option", :shape "ParameterStringQueryOption"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-filter-value-list (input :values)) #:http.request.field{:name "Values", :shape "ParameterStringFilterValueList"}))))

(clojure.core/defn- ser-s-3-region [input] #:http.request.field{:value input, :shape "S3Region"})

(clojure.core/defn- ser-instance-patch-state-filter-value [input] #:http.request.field{:value input, :shape "InstancePatchStateFilterValue"})

(clojure.core/defn- ser-document-filter-key [input] #:http.request.field{:value (clojure.core/get {"Name" "Name", :name "Name", "Owner" "Owner", :owner "Owner", "PlatformTypes" "PlatformTypes", :platform-types "PlatformTypes", "DocumentType" "DocumentType", :document-type "DocumentType"} input), :shape "DocumentFilterKey"})

(clojure.core/defn- ser-comment [input] #:http.request.field{:value input, :shape "Comment"})

(clojure.core/defn- ser-compliance-resource-type [input] #:http.request.field{:value input, :shape "ComplianceResourceType"})

(clojure.core/defn- ser-association-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-id coll) #:http.request.field{:shape "AssociationId"}))) input), :shape "AssociationIdList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-document-key-values-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-document-key-values-filter coll) #:http.request.field{:shape "DocumentKeyValuesFilter"}))) input), :shape "DocumentKeyValuesFilterList", :type "list", :max 6, :min 0})

(clojure.core/defn- ser-patch-source [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-source-name (:name input)) #:http.request.field{:name "Name", :shape "PatchSourceName"}) (clojure.core/into (ser-patch-source-product-list (:products input)) #:http.request.field{:name "Products", :shape "PatchSourceProductList"}) (clojure.core/into (ser-patch-source-configuration (:configuration input)) #:http.request.field{:name "Configuration", :shape "PatchSourceConfiguration"})], :shape "PatchSource", :type "structure"}))

(clojure.core/defn- ser-compliance-string-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-string-filter coll) #:http.request.field{:shape "ComplianceStringFilter"}))) input), :shape "ComplianceStringFilterList", :type "list"})

(clojure.core/defn- ser-instance-information-filter-value [input] #:http.request.field{:value input, :shape "InstanceInformationFilterValue"})

(clojure.core/defn- ser-instance-information-string-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-information-string-filter coll) #:http.request.field{:shape "InstanceInformationStringFilter"}))) input), :shape "InstanceInformationStringFilterList", :type "list", :min 0})

(clojure.core/defn- ser-command-max-results [input] #:http.request.field{:value input, :shape "CommandMaxResults"})

(clojure.core/defn- ser-parameter-label-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-label coll) #:http.request.field{:shape "ParameterLabel"}))) input), :shape "ParameterLabelList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-association-execution-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-association-execution-filter-key (:key input)) #:http.request.field{:name "Key", :shape "AssociationExecutionFilterKey"}) (clojure.core/into (ser-association-execution-filter-value (:value input)) #:http.request.field{:name "Value", :shape "AssociationExecutionFilterValue"}) (clojure.core/into (ser-association-filter-operator-type (:type input)) #:http.request.field{:name "Type", :shape "AssociationFilterOperatorType"})], :shape "AssociationExecutionFilter", :type "structure"}))

(clojure.core/defn- ser-inventory-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-filter-key (:key input)) #:http.request.field{:name "Key", :shape "InventoryFilterKey"}) (clojure.core/into (ser-inventory-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "InventoryFilterValueList"})], :shape "InventoryFilter", :type "structure"} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-query-operator-type (input :type)) #:http.request.field{:name "Type", :shape "InventoryQueryOperatorType"}))))

(clojure.core/defn- ser-inventory-item-type-name-filter [input] #:http.request.field{:value input, :shape "InventoryItemTypeNameFilter"})

(clojure.core/defn- ser-maintenance-window-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-maintenance-window-filter-value coll) #:http.request.field{:shape "MaintenanceWindowFilterValue"}))) input), :shape "MaintenanceWindowFilterValues", :type "list"})

(clojure.core/defn- ser-get-parameters-by-path-max-results [input] #:http.request.field{:value input, :shape "GetParametersByPathMaxResults"})

(clojure.core/defn- ser-session-id [input] #:http.request.field{:value input, :shape "SessionId"})

(clojure.core/defn- ser-ps-parameter-version [input] #:http.request.field{:value input, :shape "PSParameterVersion"})

(clojure.core/defn- ser-account-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-account-id coll) #:http.request.field{:shape "AccountId"}))) input), :shape "AccountIdList", :type "list", :max 20})

(clojure.core/defn- ser-session-max-results [input] #:http.request.field{:value input, :shape "SessionMaxResults"})

(clojure.core/defn- ser-maintenance-window-execution-task-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowExecutionTaskId"})

(clojure.core/defn- ser-patch-orchestrator-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-orchestrator-filter coll) #:http.request.field{:shape "PatchOrchestratorFilter"}))) input), :shape "PatchOrchestratorFilterList", :type "list", :max 5, :min 0})

(clojure.core/defn- ser-maintenance-window-cutoff [input] #:http.request.field{:value input, :shape "MaintenanceWindowCutoff"})

(clojure.core/defn- ser-timeout-seconds [input] #:http.request.field{:value input, :shape "TimeoutSeconds"})

(clojure.core/defn- ser-resource-data-sync-s-3-region [input] #:http.request.field{:value input, :shape "ResourceDataSyncS3Region"})

(clojure.core/defn- ser-attribute-name [input] #:http.request.field{:value input, :shape "AttributeName"})

(clojure.core/defn- ser-parameters-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-parameters-filter-key (:key input)) #:http.request.field{:name "Key", :shape "ParametersFilterKey"}) (clojure.core/into (ser-parameters-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "ParametersFilterValueList"})], :shape "ParametersFilter", :type "structure"}))

(clojure.core/defn- ser-status-additional-info [input] #:http.request.field{:value input, :shape "StatusAdditionalInfo"})

(clojure.core/defn- ser-parameter-string-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-string-filter coll) #:http.request.field{:shape "ParameterStringFilter"}))) input), :shape "ParameterStringFilterList", :type "list"})

(clojure.core/defn- ser-resource-data-sync-awskms-key-arn [input] #:http.request.field{:value input, :shape "ResourceDataSyncAWSKMSKeyARN"})

(clojure.core/defn- ser-association-execution-filter-value [input] #:http.request.field{:value input, :shape "AssociationExecutionFilterValue"})

(clojure.core/defn- ser-status-message [input] #:http.request.field{:value input, :shape "StatusMessage"})

(clojure.core/defn- ser-patch-orchestrator-filter-value [input] #:http.request.field{:value input, :shape "PatchOrchestratorFilterValue"})

(clojure.core/defn- ser-patch-rule [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-filter-group (:patch-filter-group input)) #:http.request.field{:name "PatchFilterGroup", :shape "PatchFilterGroup"}) (clojure.core/into (ser-approve-after-days (:approve-after-days input)) #:http.request.field{:name "ApproveAfterDays", :shape "ApproveAfterDays", :box true})], :shape "PatchRule", :type "structure"} (clojure.core/contains? input :compliance-level) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-level (input :compliance-level)) #:http.request.field{:name "ComplianceLevel", :shape "PatchComplianceLevel"})) (clojure.core/contains? input :enable-non-security) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enable-non-security)) #:http.request.field{:name "EnableNonSecurity", :shape "Boolean", :box true}))))

(clojure.core/defn- ser-execution-mode [input] #:http.request.field{:value (clojure.core/get {"Auto" "Auto", :auto "Auto", "Interactive" "Interactive", :interactive "Interactive"} input), :shape "ExecutionMode"})

(clojure.core/defn- ser-inventory-item-content-hash [input] #:http.request.field{:value input, :shape "InventoryItemContentHash"})

(clojure.core/defn- ser-patch-orchestrator-filter-key [input] #:http.request.field{:value input, :shape "PatchOrchestratorFilterKey"})

(clojure.core/defn- ser-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag-key coll) #:http.request.field{:shape "TagKey"}))) input), :shape "KeyList", :type "list"})

(clojure.core/defn- ser-inventory-item-entry [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "InventoryItemEntry", :type "map", :max 50, :min 0})

(clojure.core/defn- ser-cloud-watch-log-group-name [input] #:http.request.field{:value input, :shape "CloudWatchLogGroupName"})

(clojure.core/defn- ser-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-parameter-name k) #:http.request.field{:map-info "key", :shape "ParameterName"}) (clojure.core/into (ser-parameter-value-list v) #:http.request.field{:map-info "value", :shape "ParameterValueList"})])) input), :shape "Parameters", :type "map"})

(clojure.core/defn- ser-inventory-filter-value [input] #:http.request.field{:value input, :shape "InventoryFilterValue"})

(clojure.core/defn- ser-association-execution-id [input] #:http.request.field{:value input, :shape "AssociationExecutionId"})

(clojure.core/defn- ser-resource-data-sync-s-3-format [input] #:http.request.field{:value (clojure.core/get {"JsonSerDe" "JsonSerDe", :json-ser-de "JsonSerDe"} input), :shape "ResourceDataSyncS3Format"})

(clojure.core/defn- ser-attachments-source-key [input] #:http.request.field{:value (clojure.core/get {"SourceUrl" "SourceUrl", :source-url "SourceUrl"} input), :shape "AttachmentsSourceKey"})

(clojure.core/defn- ser-document-type [input] #:http.request.field{:value (clojure.core/get {"Automation" "Automation", :package "Package", "Package" "Package", :command "Command", :policy "Policy", "Command" "Command", :automation "Automation", "Policy" "Policy", "Session" "Session", :session "Session"} input), :shape "DocumentType"})

(clojure.core/defn- ser-parameters-filter-value [input] #:http.request.field{:value input, :shape "ParametersFilterValue"})

(clojure.core/defn- ser-association-id [input] #:http.request.field{:value input, :shape "AssociationId"})

(clojure.core/defn- ser-get-inventory-schema-max-results [input] #:http.request.field{:value input, :shape "GetInventorySchemaMaxResults"})

(clojure.core/defn- ser-automation-execution-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-automation-execution-filter coll) #:http.request.field{:shape "AutomationExecutionFilter"}))) input), :shape "AutomationExecutionFilterList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-session-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-session-filter coll) #:http.request.field{:shape "SessionFilter"}))) input), :shape "SessionFilterList", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-parameters-filter-key [input] #:http.request.field{:value (clojure.core/get {"Name" "Name", :name "Name", "Type" "Type", :type "Type", "KeyId" "KeyId", :key-id "KeyId"} input), :shape "ParametersFilterKey"})

(clojure.core/defn- ser-inventory-group [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-group-name (:name input)) #:http.request.field{:name "Name", :shape "InventoryGroupName"}) (clojure.core/into (ser-inventory-filter-list (:filters input)) #:http.request.field{:name "Filters", :shape "InventoryFilterList"})], :shape "InventoryGroup", :type "structure"}))

(clojure.core/defn- ser-compliance-item-title [input] #:http.request.field{:value input, :shape "ComplianceItemTitle"})

(clojure.core/defn- ser-document-key-values-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-document-key-values-filter-value coll) #:http.request.field{:shape "DocumentKeyValuesFilterValue"}))) input), :shape "DocumentKeyValuesFilterValues", :type "list"})

(clojure.core/defn- ser-document-key-values-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DocumentKeyValuesFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-key-values-filter-key (input :key)) #:http.request.field{:name "Key", :shape "DocumentKeyValuesFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-key-values-filter-values (input :values)) #:http.request.field{:name "Values", :shape "DocumentKeyValuesFilterValues"}))))

(clojure.core/defn- ser-tag-key [input] #:http.request.field{:value input, :shape "TagKey"})

(clojure.core/defn- ser-parameter-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ps-parameter-name coll) #:http.request.field{:shape "PSParameterName"}))) input), :shape "ParameterNameList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-target-type [input] #:http.request.field{:value input, :shape "TargetType"})

(clojure.core/defn- ser-resource-data-sync-s-3-prefix [input] #:http.request.field{:value input, :shape "ResourceDataSyncS3Prefix"})

(clojure.core/defn- ser-notification-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NotificationConfig", :type "structure"} (clojure.core/contains? input :notification-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-arn (input :notification-arn)) #:http.request.field{:name "NotificationArn", :shape "NotificationArn"})) (clojure.core/contains? input :notification-events) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-event-list (input :notification-events)) #:http.request.field{:name "NotificationEvents", :shape "NotificationEventList"})) (clojure.core/contains? input :notification-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-type (input :notification-type)) #:http.request.field{:name "NotificationType", :shape "NotificationType"}))))

(clojure.core/defn- ser-s-3-bucket-name [input] #:http.request.field{:value input, :shape "S3BucketName"})

(clojure.core/defn- ser-document-hash [input] #:http.request.field{:value input, :shape "DocumentHash"})

(clojure.core/defn- ser-inventory-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-filter coll) #:http.request.field{:shape "InventoryFilter"}))) input), :shape "InventoryFilterList", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-association-execution-targets-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-execution-targets-filter coll) #:http.request.field{:shape "AssociationExecutionTargetsFilter"}))) input), :shape "AssociationExecutionTargetsFilterList", :type "list", :min 1})

(clojure.core/defn- ser-parameters-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameters-filter-value coll) #:http.request.field{:shape "ParametersFilterValue"}))) input), :shape "ParametersFilterValueList", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-iam-role [input] #:http.request.field{:value input, :shape "IamRole"})

(clojure.core/defn- ser-compliance-severity [input] #:http.request.field{:value (clojure.core/get {"INFORMATIONAL" "INFORMATIONAL", :unspecified "UNSPECIFIED", "CRITICAL" "CRITICAL", :medium "MEDIUM", "LOW" "LOW", :high "HIGH", :critical "CRITICAL", "HIGH" "HIGH", :low "LOW", "UNSPECIFIED" "UNSPECIFIED", :informational "INFORMATIONAL", "MEDIUM" "MEDIUM"} input), :shape "ComplianceSeverity"})

(clojure.core/defn- ser-session-state [input] #:http.request.field{:value (clojure.core/get {"Active" "Active", :active "Active", "History" "History", :history "History"} input), :shape "SessionState"})

(clojure.core/defn- ser-notification-type [input] #:http.request.field{:value (clojure.core/get {"Command" "Command", :command "Command", "Invocation" "Invocation", :invocation "Invocation"} input), :shape "NotificationType"})

(clojure.core/defn- ser-maintenance-window-lambda-payload [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "MaintenanceWindowLambdaPayload"})

(clojure.core/defn- ser-result-attribute [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-item-type-name (:type-name input)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"})], :shape "ResultAttribute", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-task-arn [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskArn"})

(clojure.core/defn- ser-maintenance-window-lambda-qualifier [input] #:http.request.field{:value input, :shape "MaintenanceWindowLambdaQualifier"})

(clojure.core/defn- ser-target-map-key [input] #:http.request.field{:value input, :shape "TargetMapKey"})

(clojure.core/defn- ser-association-status [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-date-time (:date input)) #:http.request.field{:name "Date", :shape "DateTime"}) (clojure.core/into (ser-association-status-name (:name input)) #:http.request.field{:name "Name", :shape "AssociationStatusName"}) (clojure.core/into (ser-status-message (:message input)) #:http.request.field{:name "Message", :shape "StatusMessage"})], :shape "AssociationStatus", :type "structure"} (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-status-additional-info (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "StatusAdditionalInfo"}))))

(clojure.core/defn- ser-target-locations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-location coll) #:http.request.field{:shape "TargetLocation"}))) input), :shape "TargetLocations", :type "list", :max 100, :min 1})

(clojure.core/defn- ser-association-filter-key [input] #:http.request.field{:value (clojure.core/get {"InstanceId" "InstanceId", :association-id "AssociationId", "AssociationId" "AssociationId", :name "Name", :association-name "AssociationName", :instance-id "InstanceId", "LastExecutedBefore" "LastExecutedBefore", "AssociationName" "AssociationName", :association-status-name "AssociationStatusName", "AssociationStatusName" "AssociationStatusName", :last-executed-after "LastExecutedAfter", "Name" "Name", :last-executed-before "LastExecutedBefore", "LastExecutedAfter" "LastExecutedAfter"} input), :shape "AssociationFilterKey"})

(clojure.core/defn- ser-inventory-schema-delete-option [input] #:http.request.field{:value (clojure.core/get {"DisableSchema" "DisableSchema", :disable-schema "DisableSchema", "DeleteSchema" "DeleteSchema", :delete-schema "DeleteSchema"} input), :shape "InventorySchemaDeleteOption"})

(clojure.core/defn- ser-maintenance-window-task-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-maintenance-window-task-parameter-name k) #:http.request.field{:map-info "key", :shape "MaintenanceWindowTaskParameterName"}) (clojure.core/into (ser-maintenance-window-task-parameter-value-expression v) #:http.request.field{:map-info "value", :shape "MaintenanceWindowTaskParameterValueExpression"})])) input), :shape "MaintenanceWindowTaskParameters", :type "map", :sensitive true})

(clojure.core/defn- ser-next-token [input] #:http.request.field{:value input, :shape "NextToken"})

(clojure.core/defn- ser-session-manager-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-session-manager-parameter-value coll) #:http.request.field{:shape "SessionManagerParameterValue"}))) input), :shape "SessionManagerParameterValueList", :type "list"})

(clojure.core/defn- ser-resource-data-sync-s-3-destination [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-resource-data-sync-s-3-bucket-name (:bucket-name input)) #:http.request.field{:name "BucketName", :shape "ResourceDataSyncS3BucketName"}) (clojure.core/into (ser-resource-data-sync-s-3-format (:sync-format input)) #:http.request.field{:name "SyncFormat", :shape "ResourceDataSyncS3Format"}) (clojure.core/into (ser-resource-data-sync-s-3-region (:region input)) #:http.request.field{:name "Region", :shape "ResourceDataSyncS3Region"})], :shape "ResourceDataSyncS3Destination", :type "structure"} (clojure.core/contains? input :prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-data-sync-s-3-prefix (input :prefix)) #:http.request.field{:name "Prefix", :shape "ResourceDataSyncS3Prefix"})) (clojure.core/contains? input :awskms-key-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-data-sync-awskms-key-arn (input :awskms-key-arn)) #:http.request.field{:name "AWSKMSKeyARN", :shape "ResourceDataSyncAWSKMSKeyARN"}))))

(clojure.core/defn- ser-aggregator-schema-only [input] #:http.request.field{:value input, :shape "AggregatorSchemaOnly"})

(clojure.core/defn- ser-cloud-watch-output-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CloudWatchOutputConfig", :type "structure"} (clojure.core/contains? input :cloud-watch-log-group-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloud-watch-log-group-name (input :cloud-watch-log-group-name)) #:http.request.field{:name "CloudWatchLogGroupName", :shape "CloudWatchLogGroupName"})) (clojure.core/contains? input :cloud-watch-output-enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloud-watch-output-enabled (input :cloud-watch-output-enabled)) #:http.request.field{:name "CloudWatchOutputEnabled", :shape "CloudWatchOutputEnabled"}))))

(clojure.core/defn- ser-parameter-string-query-option [input] #:http.request.field{:value input, :shape "ParameterStringQueryOption"})

(clojure.core/defn- ser-patch-baseline-max-results [input] #:http.request.field{:value input, :shape "PatchBaselineMaxResults"})

(clojure.core/defn- ser-default-instance-name [input] #:http.request.field{:value input, :shape "DefaultInstanceName"})

(clojure.core/defn- ser-instance-information-filter-key [input] #:http.request.field{:value (clojure.core/get {"InstanceIds" "InstanceIds", "ActivationIds" "ActivationIds", :platform-types "PlatformTypes", :iam-role "IamRole", "PingStatus" "PingStatus", "IamRole" "IamRole", "AgentVersion" "AgentVersion", "AssociationStatus" "AssociationStatus", :association-status "AssociationStatus", "ResourceType" "ResourceType", :instance-ids "InstanceIds", "PlatformTypes" "PlatformTypes", :resource-type "ResourceType", :agent-version "AgentVersion", :activation-ids "ActivationIds", :ping-status "PingStatus"} input), :shape "InstanceInformationFilterKey"})

(clojure.core/defn- ser-maintenance-window-task-parameter-name [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskParameterName"})

(clojure.core/defn- ser-session-target [input] #:http.request.field{:value input, :shape "SessionTarget"})

(clojure.core/defn- ser-expiration-date [input] #:http.request.field{:value input, :shape "ExpirationDate"})

(clojure.core/defn- ser-maintenance-window-task-priority [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskPriority"})

(clojure.core/defn- ser-document-arn [input] #:http.request.field{:value input, :shape "DocumentARN"})

(clojure.core/defn- ser-patch-id [input] #:http.request.field{:value input, :shape "PatchId"})

(clojure.core/defn- ser-max-concurrency [input] #:http.request.field{:value input, :shape "MaxConcurrency"})

(clojure.core/defn- ser-resource-id [input] #:http.request.field{:value input, :shape "ResourceId"})

(clojure.core/defn- ser-maintenance-window-task-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskId"})

(clojure.core/defn- ser-maintenance-window-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-key (input :key)) #:http.request.field{:name "Key", :shape "MaintenanceWindowFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-values (input :values)) #:http.request.field{:name "Values", :shape "MaintenanceWindowFilterValues"}))))

(clojure.core/defn- ser-patch-action [input] #:http.request.field{:value (clojure.core/get {"ALLOW_AS_DEPENDENCY" "ALLOW_AS_DEPENDENCY", :allow-as-dependency "ALLOW_AS_DEPENDENCY", "BLOCK" "BLOCK", :block "BLOCK"} input), :shape "PatchAction"})

(clojure.core/defn- ser-stop-type [input] #:http.request.field{:value (clojure.core/get {"Complete" "Complete", :complete "Complete", "Cancel" "Cancel", :cancel "Cancel"} input), :shape "StopType"})

(clojure.core/defn- ser-regions [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-region coll) #:http.request.field{:shape "Region"}))) input), :shape "Regions", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-step-execution-filter-value [input] #:http.request.field{:value input, :shape "StepExecutionFilterValue"})

(clojure.core/defn- ser-patch-compliance-max-results [input] #:http.request.field{:value input, :shape "PatchComplianceMaxResults"})

(clojure.core/defn- ser-instance-patch-state-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-patch-state-filter-value coll) #:http.request.field{:shape "InstancePatchStateFilterValue"}))) input), :shape "InstancePatchStateFilterValues", :type "list", :max 1, :min 1})

(clojure.core/defn- ser-signal-type [input] #:http.request.field{:value (clojure.core/get {:stop-step "StopStep", :approve "Approve", "Resume" "Resume", "StopStep" "StopStep", "StartStep" "StartStep", "Approve" "Approve", :reject "Reject", :resume "Resume", :start-step "StartStep", "Reject" "Reject"} input), :shape "SignalType"})

(clojure.core/defn- ser-compliance-item-id [input] #:http.request.field{:value input, :shape "ComplianceItemId"})

(clojure.core/defn- ser-association-filter-value [input] #:http.request.field{:value input, :shape "AssociationFilterValue"})

(clojure.core/defn- ser-cloud-watch-output-enabled [input] #:http.request.field{:value input, :shape "CloudWatchOutputEnabled"})

(clojure.core/defn- ser-document-filter-value [input] #:http.request.field{:value input, :shape "DocumentFilterValue"})

(clojure.core/defn- ser-parameter-label [input] #:http.request.field{:value input, :shape "ParameterLabel"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag"}))) input), :shape "TagList", :type "list", :max 1000})

(clojure.core/defn- ser-compliance-string-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ComplianceStringFilter", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-key (input :key)) #:http.request.field{:name "Key", :shape "ComplianceStringFilterKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-value-list (input :values)) #:http.request.field{:name "Values", :shape "ComplianceStringFilterValueList"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-query-operator-type (input :type)) #:http.request.field{:name "Type", :shape "ComplianceQueryOperatorType"}))))

(clojure.core/defn- ser-compliance-type-name [input] #:http.request.field{:value input, :shape "ComplianceTypeName"})

(clojure.core/defn- ser-patch-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-id coll) #:http.request.field{:shape "PatchId"}))) input), :shape "PatchIdList", :type "list", :max 50, :min 0})

(clojure.core/defn- ser-document-key-values-filter-value [input] #:http.request.field{:value input, :shape "DocumentKeyValuesFilterValue"})

(clojure.core/defn- ser-logging-info [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-s-3-bucket-name (:s-3-bucket-name input)) #:http.request.field{:name "S3BucketName", :shape "S3BucketName"}) (clojure.core/into (ser-s-3-region (:s-3-region input)) #:http.request.field{:name "S3Region", :shape "S3Region"})], :shape "LoggingInfo", :type "structure"} (clojure.core/contains? input :s-3-key-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :s-3-key-prefix)) #:http.request.field{:name "S3KeyPrefix", :shape "S3KeyPrefix"}))))

(clojure.core/defn- ser-ps-parameter-value [input] #:http.request.field{:value input, :shape "PSParameterValue"})

(clojure.core/defn- ser-patch-filter-group [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-filter-list (:patch-filters input)) #:http.request.field{:name "PatchFilters", :shape "PatchFilterList"})], :shape "PatchFilterGroup", :type "structure"}))

(clojure.core/defn- ser-instance-patch-state-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-instance-patch-state-filter-key (:key input)) #:http.request.field{:name "Key", :shape "InstancePatchStateFilterKey"}) (clojure.core/into (ser-instance-patch-state-filter-values (:values input)) #:http.request.field{:name "Values", :shape "InstancePatchStateFilterValues"}) (clojure.core/into (ser-instance-patch-state-operator-type (:type input)) #:http.request.field{:name "Type", :shape "InstancePatchStateOperatorType"})], :shape "InstancePatchStateFilter", :type "structure"}))

(clojure.core/defn- ser-command-plugin-name [input] #:http.request.field{:value input, :shape "CommandPluginName"})

(clojure.core/defn- ser-attribute-value [input] #:http.request.field{:value input, :shape "AttributeValue"})

(clojure.core/defn- ser-maintenance-window-execution-task-invocation-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowExecutionTaskInvocationId"})

(clojure.core/defn- ser-parameter-key-id [input] #:http.request.field{:value input, :shape "ParameterKeyId"})

(clojure.core/defn- ser-automation-parameter-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-automation-parameter-key k) #:http.request.field{:map-info "key", :shape "AutomationParameterKey"}) (clojure.core/into (ser-automation-parameter-value-list v) #:http.request.field{:map-info "value", :shape "AutomationParameterValueList"})])) input), :shape "AutomationParameterMap", :type "map", :max 200, :min 1})

(clojure.core/defn- ser-step-execution-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-step-execution-filter-value coll) #:http.request.field{:shape "StepExecutionFilterValue"}))) input), :shape "StepExecutionFilterValueList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-document-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-document-filter coll) #:http.request.field{:shape "DocumentFilter"}))) input), :shape "DocumentFilterList", :type "list", :min 1})

(clojure.core/defn- ser-patch-rule-group [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-patch-rule-list (:patch-rules input)) #:http.request.field{:name "PatchRules", :shape "PatchRuleList"})], :shape "PatchRuleGroup", :type "structure"}))

(clojure.core/defn- ser-inventory-item-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-item coll) #:http.request.field{:shape "InventoryItem"}))) input), :shape "InventoryItemList", :type "list", :max 30, :min 1})

(clojure.core/defn- ser-accounts [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-account coll) #:http.request.field{:shape "Account"}))) input), :shape "Accounts", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-maintenance-window-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-maintenance-window-filter coll) #:http.request.field{:shape "MaintenanceWindowFilter"}))) input), :shape "MaintenanceWindowFilterList", :type "list", :max 5, :min 0})

(clojure.core/defn- ser-service-setting-value [input] #:http.request.field{:value input, :shape "ServiceSettingValue"})

(clojure.core/defn- ser-association-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-filter coll) #:http.request.field{:shape "AssociationFilter"}))) input), :shape "AssociationFilterList", :type "list", :min 1})

(clojure.core/defn- ser-max-errors [input] #:http.request.field{:value input, :shape "MaxErrors"})

(clojure.core/defn- ser-parameter-string-filter-key [input] #:http.request.field{:value input, :shape "ParameterStringFilterKey"})

(clojure.core/defn- ser-inventory-item-schema-version [input] #:http.request.field{:value input, :shape "InventoryItemSchemaVersion"})

(clojure.core/defn- ser-compliance-status [input] #:http.request.field{:value (clojure.core/get {"COMPLIANT" "COMPLIANT", :compliant "COMPLIANT", "NON_COMPLIANT" "NON_COMPLIANT", :non-compliant "NON_COMPLIANT"} input), :shape "ComplianceStatus"})

(clojure.core/defn- ser-parameter-string-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-string-filter-value coll) #:http.request.field{:shape "ParameterStringFilterValue"}))) input), :shape "ParameterStringFilterValueList", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-account [input] #:http.request.field{:value input, :shape "Account"})

(clojure.core/defn- ser-compliance-execution-summary [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-date-time (:execution-time input)) #:http.request.field{:name "ExecutionTime", :shape "DateTime"})], :shape "ComplianceExecutionSummary", :type "structure"} (clojure.core/contains? input :execution-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-execution-id (input :execution-id)) #:http.request.field{:name "ExecutionId", :shape "ComplianceExecutionId"})) (clojure.core/contains? input :execution-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-execution-type (input :execution-type)) #:http.request.field{:name "ExecutionType", :shape "ComplianceExecutionType"}))))

(clojure.core/defn- ser-attachments-source-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-attachments-source-value coll) #:http.request.field{:shape "AttachmentsSourceValue"}))) input), :shape "AttachmentsSourceValues", :type "list", :max 1, :min 1})

(clojure.core/defn- ser-attachments-source [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttachmentsSource", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-key (input :key)) #:http.request.field{:name "Key", :shape "AttachmentsSourceKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-values (input :values)) #:http.request.field{:name "Values", :shape "AttachmentsSourceValues"}))))

(clojure.core/defn- ser-allowed-pattern [input] #:http.request.field{:value input, :shape "AllowedPattern"})

(clojure.core/defn- ser-tag-value [input] #:http.request.field{:value input, :shape "TagValue"})

(clojure.core/defn- ser-compliance-string-filter-key [input] #:http.request.field{:value input, :shape "ComplianceStringFilterKey"})

(clojure.core/defn- ser-inventory-filter-key [input] #:http.request.field{:value input, :shape "InventoryFilterKey"})

(clojure.core/defn- ser-command-filter-key [input] #:http.request.field{:value (clojure.core/get {"InvokedBefore" "InvokedBefore", :document-name "DocumentName", "InvokedAfter" "InvokedAfter", "ExecutionStage" "ExecutionStage", "Status" "Status", :invoked-before "InvokedBefore", :invoked-after "InvokedAfter", :status "Status", "DocumentName" "DocumentName", :execution-stage "ExecutionStage"} input), :shape "CommandFilterKey"})

(clojure.core/defn- ser-patch-source-product-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-source-product coll) #:http.request.field{:shape "PatchSourceProduct"}))) input), :shape "PatchSourceProductList", :type "list", :max 20, :min 1})

(clojure.core/defn- ser-baseline-id [input] #:http.request.field{:value input, :shape "BaselineId"})

(clojure.core/defn- ser-inventory-group-name [input] #:http.request.field{:value input, :shape "InventoryGroupName"})

(clojure.core/defn- ser-maintenance-window-target-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowTargetId"})

(clojure.core/defn- ser-association-execution-filter-key [input] #:http.request.field{:value (clojure.core/get {"ExecutionId" "ExecutionId", :execution-id "ExecutionId", "Status" "Status", :status "Status", "CreatedTime" "CreatedTime", :created-time "CreatedTime"} input), :shape "AssociationExecutionFilterKey"})

(clojure.core/defn- ser-managed-instance-id [input] #:http.request.field{:value input, :shape "ManagedInstanceId"})

(clojure.core/defn- ser-compliance-string-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-filter-value coll) #:http.request.field{:shape "ComplianceFilterValue"}))) input), :shape "ComplianceStringFilterValueList", :type "list", :max 20, :min 1})

(clojure.core/defn- ser-maintenance-window-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowId"})

(clojure.core/defn- ser-session-manager-parameter-name [input] #:http.request.field{:value input, :shape "SessionManagerParameterName"})

(clojure.core/defn- ser-patch-orchestrator-filter-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-orchestrator-filter-value coll) #:http.request.field{:shape "PatchOrchestratorFilterValue"}))) input), :shape "PatchOrchestratorFilterValues", :type "list"})

(clojure.core/defn- ser-attachments-source-value [input] #:http.request.field{:value input, :shape "AttachmentsSourceValue"})

(clojure.core/defn- ser-instance-patch-state-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-instance-patch-state-filter coll) #:http.request.field{:shape "InstancePatchStateFilter"}))) input), :shape "InstancePatchStateFilterList", :type "list", :max 4, :min 0})

(clojure.core/defn- ser-automation-target-parameter-name [input] #:http.request.field{:value input, :shape "AutomationTargetParameterName"})

(clojure.core/defn- ser-compliance-execution-id [input] #:http.request.field{:value input, :shape "ComplianceExecutionId"})

(clojure.core/defn- ser-maintenance-window-description [input] #:http.request.field{:value input, :shape "MaintenanceWindowDescription"})

(clojure.core/defn- ser-association-name [input] #:http.request.field{:value input, :shape "AssociationName"})

(clojure.core/defn- ser-maintenance-window-lambda-client-context [input] #:http.request.field{:value input, :shape "MaintenanceWindowLambdaClientContext"})

(clojure.core/defn- ser-effective-instance-association-max-results [input] #:http.request.field{:value input, :shape "EffectiveInstanceAssociationMaxResults"})

(clojure.core/defn- ser-step-execution-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-step-execution-filter coll) #:http.request.field{:shape "StepExecutionFilter"}))) input), :shape "StepExecutionFilterList", :type "list", :max 6, :min 1})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-parameter-description [input] #:http.request.field{:value input, :shape "ParameterDescription"})

(clojure.core/defn- ser-automation-execution-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-automation-execution-filter-key (:key input)) #:http.request.field{:name "Key", :shape "AutomationExecutionFilterKey"}) (clojure.core/into (ser-automation-execution-filter-value-list (:values input)) #:http.request.field{:name "Values", :shape "AutomationExecutionFilterValueList"})], :shape "AutomationExecutionFilter", :type "structure"}))

(clojure.core/defn- ser-inventory-item-content-context [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "InventoryItemContentContext", :type "map", :max 50, :min 0})

(clojure.core/defn- ser-account-id [input] #:http.request.field{:value input, :shape "AccountId"})

(clojure.core/defn- ser-instance-patch-state-filter-key [input] #:http.request.field{:value input, :shape "InstancePatchStateFilterKey"})

(clojure.core/defn- ser-create-association-batch-request-entry [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-document-arn (:name input)) #:http.request.field{:name "Name", :shape "DocumentARN"})], :shape "CreateAssociationBatchRequestEntry", :type "structure"} (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :compliance-severity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-compliance-severity (input :compliance-severity)) #:http.request.field{:name "ComplianceSeverity", :shape "AssociationComplianceSeverity"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :automation-target-parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-target-parameter-name (input :automation-target-parameter-name)) #:http.request.field{:name "AutomationTargetParameterName", :shape "AutomationTargetParameterName"})) (clojure.core/contains? input :association-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-name (input :association-name)) #:http.request.field{:name "AssociationName", :shape "AssociationName"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "ScheduleExpression"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :output-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-association-output-location (input :output-location)) #:http.request.field{:name "OutputLocation", :shape "InstanceAssociationOutputLocation"}))))

(clojure.core/defn- ser-automation-execution-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-automation-execution-filter-value coll) #:http.request.field{:shape "AutomationExecutionFilterValue"}))) input), :shape "AutomationExecutionFilterValueList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-patch-filter-key [input] #:http.request.field{:value (clojure.core/get {"PATCH_ID" "PATCH_ID", "CLASSIFICATION" "CLASSIFICATION", :section "SECTION", "SEVERITY" "SEVERITY", :classification "CLASSIFICATION", "MSRC_SEVERITY" "MSRC_SEVERITY", "SECTION" "SECTION", :product "PRODUCT", :priority "PRIORITY", :patch-id "PATCH_ID", :severity "SEVERITY", "PRODUCT" "PRODUCT", :msrc-severity "MSRC_SEVERITY", "PRIORITY" "PRIORITY"} input), :shape "PatchFilterKey"})

(clojure.core/defn- ser-maintenance-window-lambda-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowLambdaParameters", :type "structure"} (clojure.core/contains? input :client-context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-client-context (input :client-context)) #:http.request.field{:name "ClientContext", :shape "MaintenanceWindowLambdaClientContext"})) (clojure.core/contains? input :qualifier) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-qualifier (input :qualifier)) #:http.request.field{:name "Qualifier", :shape "MaintenanceWindowLambdaQualifier"})) (clojure.core/contains? input :payload) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-payload (input :payload)) #:http.request.field{:name "Payload", :shape "MaintenanceWindowLambdaPayload"}))))

(clojure.core/defn- ser-patch-source-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-source coll) #:http.request.field{:shape "PatchSource"}))) input), :shape "PatchSourceList", :type "list", :max 20, :min 0})

(clojure.core/defn- ser-target-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TargetLocation", :type "structure"} (clojure.core/contains? input :accounts) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-accounts (input :accounts)) #:http.request.field{:name "Accounts", :shape "Accounts"})) (clojure.core/contains? input :regions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-regions (input :regions)) #:http.request.field{:name "Regions", :shape "Regions"})) (clojure.core/contains? input :target-location-max-concurrency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :target-location-max-concurrency)) #:http.request.field{:name "TargetLocationMaxConcurrency", :shape "MaxConcurrency", :box true})) (clojure.core/contains? input :target-location-max-errors) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :target-location-max-errors)) #:http.request.field{:name "TargetLocationMaxErrors", :shape "MaxErrors", :box true})) (clojure.core/contains? input :execution-role-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-role-name (input :execution-role-name)) #:http.request.field{:name "ExecutionRoleName", :shape "ExecutionRoleName", :box true}))))

(clojure.core/defn- ser-maintenance-window-max-results [input] #:http.request.field{:value input, :shape "MaintenanceWindowMaxResults"})

(clojure.core/defn- ser-notification-arn [input] #:http.request.field{:value input, :shape "NotificationArn"})

(clojure.core/defn- ser-instance-information-string-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-instance-information-string-filter-key (:key input)) #:http.request.field{:name "Key", :shape "InstanceInformationStringFilterKey"}) (clojure.core/into (ser-instance-information-filter-value-set (:values input)) #:http.request.field{:name "Values", :shape "InstanceInformationFilterValueSet"})], :shape "InstanceInformationStringFilter", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-step-functions-input [input] #:http.request.field{:value input, :shape "MaintenanceWindowStepFunctionsInput"})

(clojure.core/defn- ser-activation-id [input] #:http.request.field{:value input, :shape "ActivationId"})

(clojure.core/defn- ser-inventory-aggregator-expression [input] #:http.request.field{:value input, :shape "InventoryAggregatorExpression"})

(clojure.core/defn- ser-document-format [input] #:http.request.field{:value (clojure.core/get {"YAML" "YAML", :yaml "YAML", "JSON" "JSON", :json "JSON"} input), :shape "DocumentFormat"})

(clojure.core/defn- ser-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target coll) #:http.request.field{:shape "Target"}))) input), :shape "Targets", :type "list", :max 5, :min 0})

(clojure.core/defn- ser-patch-compliance-level [input] #:http.request.field{:value (clojure.core/get {"INFORMATIONAL" "INFORMATIONAL", :unspecified "UNSPECIFIED", "CRITICAL" "CRITICAL", :medium "MEDIUM", "LOW" "LOW", :high "HIGH", :critical "CRITICAL", "HIGH" "HIGH", :low "LOW", "UNSPECIFIED" "UNSPECIFIED", :informational "INFORMATIONAL", "MEDIUM" "MEDIUM"} input), :shape "PatchComplianceLevel"})

(clojure.core/defn- ser-patch-source-configuration [input] #:http.request.field{:value input, :shape "PatchSourceConfiguration"})

(clojure.core/defn- ser-target-map-value [input] #:http.request.field{:value input, :shape "TargetMapValue"})

(clojure.core/defn- ser-compliance-resource-type-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-resource-type coll) #:http.request.field{:shape "ComplianceResourceType"}))) input), :shape "ComplianceResourceTypeList", :type "list", :min 1})

(clojure.core/defn- ser-association-execution-targets-filter-value [input] #:http.request.field{:value input, :shape "AssociationExecutionTargetsFilterValue"})

(clojure.core/defn- ser-parameters-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameters-filter coll) #:http.request.field{:shape "ParametersFilter"}))) input), :shape "ParametersFilterList", :type "list"})

(clojure.core/defn- ser-execution-role-name [input] #:http.request.field{:value input, :shape "ExecutionRoleName"})

(clojure.core/defn- ser-baseline-name [input] #:http.request.field{:value input, :shape "BaselineName"})

(clojure.core/defn- ser-maintenance-window-step-functions-name [input] #:http.request.field{:value input, :shape "MaintenanceWindowStepFunctionsName"})

(clojure.core/defn- ser-compliance-resource-id [input] #:http.request.field{:value input, :shape "ComplianceResourceId"})

(clojure.core/defn- ser-association-execution-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-association-execution-filter coll) #:http.request.field{:shape "AssociationExecutionFilter"}))) input), :shape "AssociationExecutionFilterList", :type "list", :min 1})

(clojure.core/defn- ser-resource-data-sync-s-3-bucket-name [input] #:http.request.field{:value input, :shape "ResourceDataSyncS3BucketName"})

(clojure.core/defn- ser-maintenance-window-duration-hours [input] #:http.request.field{:value input, :shape "MaintenanceWindowDurationHours"})

(clojure.core/defn- ser-s-3-key-prefix [input] #:http.request.field{:value input, :shape "S3KeyPrefix"})

(clojure.core/defn- ser-inventory-aggregator-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-aggregator coll) #:http.request.field{:shape "InventoryAggregator"}))) input), :shape "InventoryAggregatorList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-compliance-execution-type [input] #:http.request.field{:value input, :shape "ComplianceExecutionType"})

(clojure.core/defn- ser-idempotency-token [input] #:http.request.field{:value input, :shape "IdempotencyToken"})

(clojure.core/defn- ser-document-permission-type [input] #:http.request.field{:value (clojure.core/get {"Share" "Share", :share "Share"} input), :shape "DocumentPermissionType"})

(clojure.core/defn- ser-schedule-expression [input] #:http.request.field{:value input, :shape "ScheduleExpression"})

(clojure.core/defn- ser-resource-type-for-tagging [input] #:http.request.field{:value (clojure.core/get {:managed-instance "ManagedInstance", :maintenance-window "MaintenanceWindow", "PatchBaseline" "PatchBaseline", "MaintenanceWindow" "MaintenanceWindow", :document "Document", "Parameter" "Parameter", :patch-baseline "PatchBaseline", "Document" "Document", "ManagedInstance" "ManagedInstance", :parameter "Parameter"} input), :shape "ResourceTypeForTagging"})

(clojure.core/defn- ser-document-version-number [input] #:http.request.field{:value input, :shape "DocumentVersionNumber"})

(clojure.core/defn- ser-command-id [input] #:http.request.field{:value input, :shape "CommandId"})

(clojure.core/defn- ser-patch-source-name [input] #:http.request.field{:value input, :shape "PatchSourceName"})

(clojure.core/defn- ser-inventory-item-entry-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-item-entry coll) #:http.request.field{:shape "InventoryItemEntry"}))) input), :shape "InventoryItemEntryList", :type "list", :max 10000, :min 0})

(clojure.core/defn- ser-association-status-name [input] #:http.request.field{:value (clojure.core/get {"Pending" "Pending", :pending "Pending", "Success" "Success", :success "Success", "Failed" "Failed", :failed "Failed"} input), :shape "AssociationStatusName"})

(clojure.core/defn- ser-command-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-command-filter-key (:key input)) #:http.request.field{:name "key", :shape "CommandFilterKey"}) (clojure.core/into (ser-command-filter-value (:value input)) #:http.request.field{:name "value", :shape "CommandFilterValue"})], :shape "CommandFilter", :type "structure"}))

(clojure.core/defn- ser-session-filter-value [input] #:http.request.field{:value input, :shape "SessionFilterValue"})

(clojure.core/defn- ser-maintenance-window-filter-value [input] #:http.request.field{:value input, :shape "MaintenanceWindowFilterValue"})

(clojure.core/defn- ser-resource-data-sync-name [input] #:http.request.field{:value input, :shape "ResourceDataSyncName"})

(clojure.core/defn- ser-patch-rule-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-rule coll) #:http.request.field{:shape "PatchRule"}))) input), :shape "PatchRuleList", :type "list", :max 10, :min 0})

(clojure.core/defn- ser-owner-information [input] #:http.request.field{:value input, :shape "OwnerInformation"})

(clojure.core/defn- ser-describe-activations-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-describe-activations-filter coll) #:http.request.field{:shape "DescribeActivationsFilter"}))) input), :shape "DescribeActivationsFilterList", :type "list"})

(clojure.core/defn- ser-maintenance-window-string-date-time [input] #:http.request.field{:value input, :shape "MaintenanceWindowStringDateTime"})

(clojure.core/defn- ser-describe-activations-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DescribeActivationsFilter", :type "structure"} (clojure.core/contains? input :filter-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-activations-filter-keys (input :filter-key)) #:http.request.field{:name "FilterKey", :shape "DescribeActivationsFilterKeys"})) (clojure.core/contains? input :filter-values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string-list (input :filter-values)) #:http.request.field{:name "FilterValues", :shape "StringList"}))))

(clojure.core/defn- ser-service-setting-id [input] #:http.request.field{:value input, :shape "ServiceSettingId"})

(clojure.core/defn- ser-s-3-output-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3OutputLocation", :type "structure"} (clojure.core/contains? input :output-s-3-region) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-region (input :output-s-3-region)) #:http.request.field{:name "OutputS3Region", :shape "S3Region"})) (clojure.core/contains? input :output-s-3-bucket-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket-name (input :output-s-3-bucket-name)) #:http.request.field{:name "OutputS3BucketName", :shape "S3BucketName"})) (clojure.core/contains? input :output-s-3-key-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :output-s-3-key-prefix)) #:http.request.field{:name "OutputS3KeyPrefix", :shape "S3KeyPrefix"}))))

(clojure.core/defn- ser-automation-parameter-value [input] #:http.request.field{:value input, :shape "AutomationParameterValue"})

(clojure.core/defn- ser-patch-filter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-filter-value coll) #:http.request.field{:shape "PatchFilterValue"}))) input), :shape "PatchFilterValueList", :type "list", :max 20, :min 1})

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-create-association-batch-request-entries [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-create-association-batch-request-entry coll) #:http.request.field{:shape "CreateAssociationBatchRequestEntry"}))) input), :shape "CreateAssociationBatchRequestEntries", :type "list", :min 1})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-tag-key (:key input)) #:http.request.field{:name "Key", :shape "TagKey"}) (clojure.core/into (ser-tag-value (:value input)) #:http.request.field{:name "Value", :shape "TagValue"})], :shape "Tag", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-schedule [input] #:http.request.field{:value input, :shape "MaintenanceWindowSchedule"})

(clojure.core/defn- ser-inventory-item-type-name [input] #:http.request.field{:value input, :shape "InventoryItemTypeName"})

(clojure.core/defn- ser-result-attribute-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-result-attribute coll) #:http.request.field{:shape "ResultAttribute"}))) input), :shape "ResultAttributeList", :type "list", :max 1, :min 1})

(clojure.core/defn- ser-document-key-values-filter-key [input] #:http.request.field{:value input, :shape "DocumentKeyValuesFilterKey"})

(clojure.core/defn- ser-maintenance-window-task-invocation-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowTaskInvocationParameters", :type "structure"} (clojure.core/contains? input :run-command) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-run-command-parameters (input :run-command)) #:http.request.field{:name "RunCommand", :shape "MaintenanceWindowRunCommandParameters"})) (clojure.core/contains? input :automation) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-automation-parameters (input :automation)) #:http.request.field{:name "Automation", :shape "MaintenanceWindowAutomationParameters"})) (clojure.core/contains? input :step-functions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-step-functions-parameters (input :step-functions)) #:http.request.field{:name "StepFunctions", :shape "MaintenanceWindowStepFunctionsParameters"})) (clojure.core/contains? input :lambda) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-lambda-parameters (input :lambda)) #:http.request.field{:name "Lambda", :shape "MaintenanceWindowLambdaParameters"}))))

(clojure.core/defn- ser-step-execution-filter-key [input] #:http.request.field{:value (clojure.core/get {:step-execution-status "StepExecutionStatus", "StartTimeBefore" "StartTimeBefore", "StepExecutionStatus" "StepExecutionStatus", "StepExecutionId" "StepExecutionId", :step-execution-id "StepExecutionId", :start-time-before "StartTimeBefore", "StartTimeAfter" "StartTimeAfter", :step-name "StepName", "StepName" "StepName", :action "Action", "Action" "Action", :start-time-after "StartTimeAfter"} input), :shape "StepExecutionFilterKey"})

(clojure.core/defn- ser-document-name [input] #:http.request.field{:value input, :shape "DocumentName"})

(clojure.core/defn- ser-compliance-item-content-hash [input] #:http.request.field{:value input, :shape "ComplianceItemContentHash"})

(clojure.core/defn- ser-maintenance-window-step-functions-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowStepFunctionsParameters", :type "structure"} (clojure.core/contains? input :input) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-step-functions-input (input :input)) #:http.request.field{:name "Input", :shape "MaintenanceWindowStepFunctionsInput"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-step-functions-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowStepFunctionsName"}))))

(clojure.core/defn- ser-patch-filter-value [input] #:http.request.field{:value input, :shape "PatchFilterValue"})

(clojure.core/defn- ser-maintenance-window-task-type [input] #:http.request.field{:value (clojure.core/get {"RUN_COMMAND" "RUN_COMMAND", :run-command "RUN_COMMAND", "AUTOMATION" "AUTOMATION", :automation "AUTOMATION", "STEP_FUNCTIONS" "STEP_FUNCTIONS", :step-functions "STEP_FUNCTIONS", "LAMBDA" "LAMBDA", :lambda "LAMBDA"} input), :shape "MaintenanceWindowTaskType"})

(clojure.core/defn- ser-maintenance-window-allow-unassociated-targets [input] #:http.request.field{:value input, :shape "MaintenanceWindowAllowUnassociatedTargets"})

(clojure.core/defn- ser-session-manager-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-session-manager-parameter-name k) #:http.request.field{:map-info "key", :shape "SessionManagerParameterName"}) (clojure.core/into (ser-session-manager-parameter-value-list v) #:http.request.field{:map-info "value", :shape "SessionManagerParameterValueList"})])) input), :shape "SessionManagerParameters", :type "map"})

(clojure.core/defn- ser-inventory-item [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-inventory-item-type-name (:type-name input)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"}) (clojure.core/into (ser-inventory-item-schema-version (:schema-version input)) #:http.request.field{:name "SchemaVersion", :shape "InventoryItemSchemaVersion"}) (clojure.core/into (ser-inventory-item-capture-time (:capture-time input)) #:http.request.field{:name "CaptureTime", :shape "InventoryItemCaptureTime"})], :shape "InventoryItem", :type "structure"} (clojure.core/contains? input :content-hash) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-content-hash (input :content-hash)) #:http.request.field{:name "ContentHash", :shape "InventoryItemContentHash"})) (clojure.core/contains? input :content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-entry-list (input :content)) #:http.request.field{:name "Content", :shape "InventoryItemEntryList"})) (clojure.core/contains? input :context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-content-context (input :context)) #:http.request.field{:name "Context", :shape "InventoryItemContentContext"}))))

(clojure.core/defn- ser-command-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-command-filter coll) #:http.request.field{:shape "CommandFilter"}))) input), :shape "CommandFilterList", :type "list", :max 5, :min 1})

(clojure.core/defn- ser-inventory-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-inventory-group coll) #:http.request.field{:shape "InventoryGroup"}))) input), :shape "InventoryGroupList", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-document-version [input] #:http.request.field{:value input, :shape "DocumentVersion"})

(clojure.core/defn- ser-target [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Target", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-key (input :key)) #:http.request.field{:name "Key", :shape "TargetKey"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-values (input :values)) #:http.request.field{:name "Values", :shape "TargetValues"}))))

(clojure.core/defn- ser-document-hash-type [input] #:http.request.field{:value (clojure.core/get {"Sha256" "Sha256", :sha-256 "Sha256", "Sha1" "Sha1", :sha-1 "Sha1"} input), :shape "DocumentHashType"})

(clojure.core/defn- ser-session-filter-key [input] #:http.request.field{:value (clojure.core/get {"InvokedBefore" "InvokedBefore", "InvokedAfter" "InvokedAfter", "Status" "Status", :invoked-before "InvokedBefore", :invoked-after "InvokedAfter", :status "Status", "Owner" "Owner", :target "Target", "Target" "Target", :owner "Owner"} input), :shape "SessionFilterKey"})

(clojure.core/defn- ser-maintenance-window-filter-key [input] #:http.request.field{:value input, :shape "MaintenanceWindowFilterKey"})

(clojure.core/defn- ser-document-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-document-filter-key (:key input)) #:http.request.field{:name "key", :shape "DocumentFilterKey"}) (clojure.core/into (ser-document-filter-value (:value input)) #:http.request.field{:name "value", :shape "DocumentFilterValue"})], :shape "DocumentFilter", :type "structure"}))

(clojure.core/defn- ser-session-manager-parameter-value [input] #:http.request.field{:value input, :shape "SessionManagerParameterValue"})

(clojure.core/defn- ser-describe-activations-filter-keys [input] #:http.request.field{:value (clojure.core/get {"ActivationIds" "ActivationIds", :activation-ids "ActivationIds", "DefaultInstanceName" "DefaultInstanceName", :default-instance-name "DefaultInstanceName", "IamRole" "IamRole", :iam-role "IamRole"} input), :shape "DescribeActivationsFilterKeys"})

(clojure.core/defn- ser-maintenance-window-timezone [input] #:http.request.field{:value input, :shape "MaintenanceWindowTimezone"})

(clojure.core/defn- ser-association-compliance-severity [input] #:http.request.field{:value (clojure.core/get {:unspecified "UNSPECIFIED", "CRITICAL" "CRITICAL", :medium "MEDIUM", "LOW" "LOW", :high "HIGH", :critical "CRITICAL", "HIGH" "HIGH", :low "LOW", "UNSPECIFIED" "UNSPECIFIED", "MEDIUM" "MEDIUM"} input), :shape "AssociationComplianceSeverity"})

(clojure.core/defn- ser-activation-description [input] #:http.request.field{:value input, :shape "ActivationDescription"})

(clojure.core/defn- ser-is-sub-type-schema [input] #:http.request.field{:value input, :shape "IsSubTypeSchema"})

(clojure.core/defn- ser-compliance-filter-value [input] #:http.request.field{:value input, :shape "ComplianceFilterValue"})

(clojure.core/defn- ser-ps-parameter-name [input] #:http.request.field{:value input, :shape "PSParameterName"})

(clojure.core/defn- ser-instance-association-output-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "InstanceAssociationOutputLocation", :type "structure"} (clojure.core/contains? input :s-3-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-output-location (input :s-3-location)) #:http.request.field{:name "S3Location", :shape "S3OutputLocation"}))))

(clojure.core/defn- ser-session-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-session-filter-key (:key input)) #:http.request.field{:name "key", :shape "SessionFilterKey"}) (clojure.core/into (ser-session-filter-value (:value input)) #:http.request.field{:name "value", :shape "SessionFilterValue"})], :shape "SessionFilter", :type "structure"}))

(clojure.core/defn- ser-maintenance-window-automation-parameters [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowAutomationParameters", :type "structure"} (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-map (input :parameters)) #:http.request.field{:name "Parameters", :shape "AutomationParameterMap"}))))

(clojure.core/defn- ser-compliance-resource-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-compliance-resource-id coll) #:http.request.field{:shape "ComplianceResourceId"}))) input), :shape "ComplianceResourceIdList", :type "list", :min 1})

(clojure.core/defn- ser-inventory-item-capture-time [input] #:http.request.field{:value input, :shape "InventoryItemCaptureTime"})

(clojure.core/defn- ser-association-execution-targets-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-association-execution-targets-filter-key (:key input)) #:http.request.field{:name "Key", :shape "AssociationExecutionTargetsFilterKey"}) (clojure.core/into (ser-association-execution-targets-filter-value (:value input)) #:http.request.field{:name "Value", :shape "AssociationExecutionTargetsFilterValue"})], :shape "AssociationExecutionTargetsFilter", :type "structure"}))

(clojure.core/defn- ser-baseline-description [input] #:http.request.field{:value input, :shape "BaselineDescription"})

(clojure.core/defn- ser-maintenance-window-execution-id [input] #:http.request.field{:value input, :shape "MaintenanceWindowExecutionId"})

(clojure.core/defn- ser-compliance-query-operator-type [input] #:http.request.field{:value (clojure.core/get {"BEGIN_WITH" "BEGIN_WITH", "GREATER_THAN" "GREATER_THAN", :less-than "LESS_THAN", :greater-than "GREATER_THAN", "LESS_THAN" "LESS_THAN", :not-equal "NOT_EQUAL", :begin-with "BEGIN_WITH", "EQUAL" "EQUAL", :equal "EQUAL", "NOT_EQUAL" "NOT_EQUAL"} input), :shape "ComplianceQueryOperatorType"})

(clojure.core/defn- ser-automation-execution-id [input] #:http.request.field{:value input, :shape "AutomationExecutionId"})

(clojure.core/defn- ser-target-value [input] #:http.request.field{:value input, :shape "TargetValue"})

(clojure.core/defn- ser-patch-filter-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-filter coll) #:http.request.field{:shape "PatchFilter"}))) input), :shape "PatchFilterList", :type "list", :max 4, :min 0})

(clojure.core/defn- ser-inventory-deletion-id [input] #:http.request.field{:value input, :shape "InventoryDeletionId"})

(clojure.core/defn- ser-region [input] #:http.request.field{:value input, :shape "Region"})

(clojure.core/defn- ser-patch-source-product [input] #:http.request.field{:value input, :shape "PatchSourceProduct"})

(clojure.core/defn- ser-instance-patch-state-operator-type [input] #:http.request.field{:value (clojure.core/get {"Equal" "Equal", :equal "Equal", "NotEqual" "NotEqual", :not-equal "NotEqual", "LessThan" "LessThan", :less-than "LessThan", "GreaterThan" "GreaterThan", :greater-than "GreaterThan"} input), :shape "InstancePatchStateOperatorType"})

(clojure.core/defn- ser-maintenance-window-task-parameter-value-expression [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MaintenanceWindowTaskParameterValueExpression", :type "structure", :sensitive true} (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-parameter-value-list (input :values)) #:http.request.field{:name "Values", :shape "MaintenanceWindowTaskParameterValueList"}))))

(clojure.core/defn- ser-target-map-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-map-value coll) #:http.request.field{:shape "TargetMapValue"}))) input), :shape "TargetMapValueList", :type "list", :max 25, :min 0})

(clojure.core/defn- ser-target-key [input] #:http.request.field{:value input, :shape "TargetKey"})

(clojure.core/defn- ser-automation-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-automation-parameter-value coll) #:http.request.field{:shape "AutomationParameterValue"}))) input), :shape "AutomationParameterValueList", :type "list", :max 10, :min 0})

(clojure.core/defn- ser-compliance-item-details [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "ComplianceItemDetails", :type "map"})

(clojure.core/defn- ser-maintenance-window-task-parameter-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-maintenance-window-task-parameter-value coll) #:http.request.field{:shape "MaintenanceWindowTaskParameterValue"}))) input), :shape "MaintenanceWindowTaskParameterValueList", :type "list", :sensitive true})

(clojure.core/defn- ser-instance-information-string-filter-key [input] #:http.request.field{:value input, :shape "InstanceInformationStringFilterKey"})

(clojure.core/defn- ser-max-results-ec-2-compatible [input] #:http.request.field{:value input, :shape "MaxResultsEC2Compatible"})

(clojure.core/defn- ser-association-execution-targets-filter-key [input] #:http.request.field{:value (clojure.core/get {"Status" "Status", :status "Status", "ResourceId" "ResourceId", :resource-id "ResourceId", "ResourceType" "ResourceType", :resource-type "ResourceType"} input), :shape "AssociationExecutionTargetsFilterKey"})

(clojure.core/defn- ser-operating-system [input] #:http.request.field{:value (clojure.core/get {"AMAZON_LINUX_2" "AMAZON_LINUX_2", :windows "WINDOWS", "WINDOWS" "WINDOWS", "CENTOS" "CENTOS", :amazon-linux-2 "AMAZON_LINUX_2", :suse "SUSE", :centos "CENTOS", "REDHAT_ENTERPRISE_LINUX" "REDHAT_ENTERPRISE_LINUX", "AMAZON_LINUX" "AMAZON_LINUX", "UBUNTU" "UBUNTU", "SUSE" "SUSE", :redhat-enterprise-linux "REDHAT_ENTERPRISE_LINUX", :amazon-linux "AMAZON_LINUX", :ubuntu "UBUNTU"} input), :shape "OperatingSystem"})

(clojure.core/defn- ser-association-filter [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-association-filter-key (:key input)) #:http.request.field{:name "key", :shape "AssociationFilterKey"}) (clojure.core/into (ser-association-filter-value (:value input)) #:http.request.field{:name "value", :shape "AssociationFilterValue"})], :shape "AssociationFilter", :type "structure"}))

(clojure.core/defn- ser-client-token [input] #:http.request.field{:value input, :shape "ClientToken"})

(clojure.core/defn- ser-notification-event-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-notification-event coll) #:http.request.field{:shape "NotificationEvent"}))) input), :shape "NotificationEventList", :type "list"})

(clojure.core/defn- ser-snapshot-id [input] #:http.request.field{:value input, :shape "SnapshotId"})

(clojure.core/defn- ser-registration-limit [input] #:http.request.field{:value input, :shape "RegistrationLimit"})

(clojure.core/defn- ser-parameter-value [input] #:http.request.field{:value input, :shape "ParameterValue"})

(clojure.core/defn- ser-association-filter-operator-type [input] #:http.request.field{:value (clojure.core/get {"EQUAL" "EQUAL", :equal "EQUAL", "LESS_THAN" "LESS_THAN", :less-than "LESS_THAN", "GREATER_THAN" "GREATER_THAN", :greater-than "GREATER_THAN"} input), :shape "AssociationFilterOperatorType"})

(clojure.core/defn- ser-date-time [input] #:http.request.field{:value input, :shape "DateTime"})

(clojure.core/defn- ser-target-values [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-value coll) #:http.request.field{:shape "TargetValue"}))) input), :shape "TargetValues", :type "list", :max 50, :min 0})

(clojure.core/defn- ser-maintenance-window-task-parameter-value [input] #:http.request.field{:value input, :shape "MaintenanceWindowTaskParameterValue"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- ser-maintenance-window-resource-type [input] #:http.request.field{:value (clojure.core/get {"INSTANCE" "INSTANCE", :instance "INSTANCE"} input), :shape "MaintenanceWindowResourceType"})

(clojure.core/defn- req-update-maintenance-window-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-task-id (input :window-task-id)) #:http.request.field{:name "WindowTaskId", :shape "MaintenanceWindowTaskId"})]} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-priority (input :priority)) #:http.request.field{:name "Priority", :shape "MaintenanceWindowTaskPriority", :box true})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :logging-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-logging-info (input :logging-info)) #:http.request.field{:name "LoggingInfo", :shape "LoggingInfo"})) (clojure.core/contains? input :task-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-arn (input :task-arn)) #:http.request.field{:name "TaskArn", :shape "MaintenanceWindowTaskArn"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :task-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-parameters (input :task-parameters)) #:http.request.field{:name "TaskParameters", :shape "MaintenanceWindowTaskParameters"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :task-invocation-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-invocation-parameters (input :task-invocation-parameters)) #:http.request.field{:name "TaskInvocationParameters", :shape "MaintenanceWindowTaskInvocationParameters"}))))

(clojure.core/defn- req-get-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]}))

(clojure.core/defn- req-get-deployable-patch-snapshot-for-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-snapshot-id (input :snapshot-id)) #:http.request.field{:name "SnapshotId", :shape "SnapshotId"})]}))

(clojure.core/defn- req-describe-association-execution-targets-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"}) (clojure.core/into (ser-association-execution-id (input :execution-id)) #:http.request.field{:name "ExecutionId", :shape "AssociationExecutionId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-execution-targets-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "AssociationExecutionTargetsFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-maintenance-window-executions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-register-task-with-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"}) (clojure.core/into (ser-maintenance-window-task-arn (input :task-arn)) #:http.request.field{:name "TaskArn", :shape "MaintenanceWindowTaskArn"}) (clojure.core/into (ser-maintenance-window-task-type (input :task-type)) #:http.request.field{:name "TaskType", :shape "MaintenanceWindowTaskType"}) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"}) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})]} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-priority (input :priority)) #:http.request.field{:name "Priority", :shape "MaintenanceWindowTaskPriority", :box true})) (clojure.core/contains? input :logging-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-logging-info (input :logging-info)) #:http.request.field{:name "LoggingInfo", :shape "LoggingInfo"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :task-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-parameters (input :task-parameters)) #:http.request.field{:name "TaskParameters", :shape "MaintenanceWindowTaskParameters"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :task-invocation-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-task-invocation-parameters (input :task-invocation-parameters)) #:http.request.field{:name "TaskInvocationParameters", :shape "MaintenanceWindowTaskInvocationParameters"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-start-session-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-target (input :target)) #:http.request.field{:name "Target", :shape "SessionTarget"})]} (clojure.core/contains? input :document-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :document-name)) #:http.request.field{:name "DocumentName", :shape "DocumentARN"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-manager-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "SessionManagerParameters"}))))

(clojure.core/defn- req-list-documents-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :document-filter-list) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-filter-list (input :document-filter-list)) #:http.request.field{:name "DocumentFilterList", :shape "DocumentFilterList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-key-values-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "DocumentKeyValuesFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-parameter-history-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"})]} (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-connection-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-target (input :target)) #:http.request.field{:name "Target", :shape "SessionTarget"})]}))

(clojure.core/defn- req-get-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})]} (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :document-format) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-format (input :document-format)) #:http.request.field{:name "DocumentFormat", :shape "DocumentFormat"}))))

(clojure.core/defn- req-get-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]}))

(clojure.core/defn- req-describe-maintenance-window-execution-tasks-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-maintenance-window-execution-task-invocation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"}) (clojure.core/into (ser-maintenance-window-execution-task-id (input :task-id)) #:http.request.field{:name "TaskId", :shape "MaintenanceWindowExecutionTaskId"}) (clojure.core/into (ser-maintenance-window-execution-task-invocation-id (input :invocation-id)) #:http.request.field{:name "InvocationId", :shape "MaintenanceWindowExecutionTaskInvocationId"})]}))

(clojure.core/defn- req-send-automation-signal-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"}) (clojure.core/into (ser-signal-type (input :signal-type)) #:http.request.field{:name "SignalType", :shape "SignalType"})]} (clojure.core/contains? input :payload) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-map (input :payload)) #:http.request.field{:name "Payload", :shape "AutomationParameterMap"}))))

(clojure.core/defn- req-describe-maintenance-window-schedule-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :window-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "MaintenanceWindowResourceType"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-search-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowSearchMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-deregister-managed-instance-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-managed-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "ManagedInstanceId"})]}))

(clojure.core/defn- req-cancel-command-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"})]} (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdList"}))))

(clojure.core/defn- req-register-default-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]}))

(clojure.core/defn- req-describe-effective-patches-for-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-list-tags-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-type-for-tagging (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceTypeForTagging"}) (clojure.core/into (ser-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceId"})]}))

(clojure.core/defn- req-describe-maintenance-window-execution-task-invocations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"}) (clojure.core/into (ser-maintenance-window-execution-task-id (input :task-id)) #:http.request.field{:name "TaskId", :shape "MaintenanceWindowExecutionTaskId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-service-setting-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-service-setting-id (input :setting-id)) #:http.request.field{:name "SettingId", :shape "ServiceSettingId"})]}))

(clojure.core/defn- req-list-compliance-summaries-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ComplianceStringFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-label-parameter-version-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"}) (clojure.core/into (ser-parameter-label-list (input :labels)) #:http.request.field{:name "Labels", :shape "ParameterLabelList"})]} (clojure.core/contains? input :parameter-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ps-parameter-version (input :parameter-version)) #:http.request.field{:name "ParameterVersion", :shape "PSParameterVersion", :box true}))))

(clojure.core/defn- req-describe-patch-group-state-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]}))

(clojure.core/defn- req-get-parameter-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"})]} (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true}))))

(clojure.core/defn- req-describe-maintenance-window-targets-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-update-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :allow-unassociated-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-allow-unassociated-targets (input :allow-unassociated-targets)) #:http.request.field{:name "AllowUnassociatedTargets", :shape "MaintenanceWindowAllowUnassociatedTargets", :box true})) (clojure.core/contains? input :end-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :end-date)) #:http.request.field{:name "EndDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-enabled (input :enabled)) #:http.request.field{:name "Enabled", :shape "MaintenanceWindowEnabled", :box true})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-duration-hours (input :duration)) #:http.request.field{:name "Duration", :shape "MaintenanceWindowDurationHours", :box true})) (clojure.core/contains? input :cutoff) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-cutoff (input :cutoff)) #:http.request.field{:name "Cutoff", :shape "MaintenanceWindowCutoff", :box true})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true})) (clojure.core/contains? input :schedule) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-schedule (input :schedule)) #:http.request.field{:name "Schedule", :shape "MaintenanceWindowSchedule"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :start-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :start-date)) #:http.request.field{:name "StartDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :schedule-timezone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-timezone (input :schedule-timezone)) #:http.request.field{:name "ScheduleTimezone", :shape "MaintenanceWindowTimezone"}))))

(clojure.core/defn- req-create-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-content (input :content)) #:http.request.field{:name "Content", :shape "DocumentContent"}) (clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]} (clojure.core/contains? input :attachments) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-list (input :attachments)) #:http.request.field{:name "Attachments", :shape "AttachmentsSourceList"})) (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"})) (clojure.core/contains? input :document-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-type (input :document-type)) #:http.request.field{:name "DocumentType", :shape "DocumentType"})) (clojure.core/contains? input :document-format) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-format (input :document-format)) #:http.request.field{:name "DocumentFormat", :shape "DocumentFormat"})) (clojure.core/contains? input :target-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-type (input :target-type)) #:http.request.field{:name "TargetType", :shape "TargetType"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-resource-data-sync-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-data-sync-name (input :sync-name)) #:http.request.field{:name "SyncName", :shape "ResourceDataSyncName"})]}))

(clojure.core/defn- req-deregister-task-from-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-task-id (input :window-task-id)) #:http.request.field{:name "WindowTaskId", :shape "MaintenanceWindowTaskId"})]}))

(clojure.core/defn- req-describe-maintenance-windows-for-target-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"}) (clojure.core/into (ser-maintenance-window-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "MaintenanceWindowResourceType"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-search-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowSearchMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-create-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"}) (clojure.core/into (ser-maintenance-window-schedule (input :schedule)) #:http.request.field{:name "Schedule", :shape "MaintenanceWindowSchedule"}) (clojure.core/into (ser-maintenance-window-duration-hours (input :duration)) #:http.request.field{:name "Duration", :shape "MaintenanceWindowDurationHours"}) (clojure.core/into (ser-maintenance-window-cutoff (input :cutoff)) #:http.request.field{:name "Cutoff", :shape "MaintenanceWindowCutoff"}) (clojure.core/into (ser-maintenance-window-allow-unassociated-targets (input :allow-unassociated-targets)) #:http.request.field{:name "AllowUnassociatedTargets", :shape "MaintenanceWindowAllowUnassociatedTargets"})]} (clojure.core/contains? input :end-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :end-date)) #:http.request.field{:name "EndDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true})) (clojure.core/contains? input :start-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-string-date-time (input :start-date)) #:http.request.field{:name "StartDate", :shape "MaintenanceWindowStringDateTime"})) (clojure.core/contains? input :schedule-timezone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-timezone (input :schedule-timezone)) #:http.request.field{:name "ScheduleTimezone", :shape "MaintenanceWindowTimezone"}))))

(clojure.core/defn- req-describe-document-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"}) (clojure.core/into (ser-document-permission-type (input :permission-type)) #:http.request.field{:name "PermissionType", :shape "DocumentPermissionType"})]}))

(clojure.core/defn- req-describe-maintenance-window-tasks-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-list-resource-compliance-summaries-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ComplianceStringFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-update-association-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"}) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-association-status (input :association-status)) #:http.request.field{:name "AssociationStatus", :shape "AssociationStatus"})]}))

(clojure.core/defn- req-describe-parameters-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ParametersFilterList"})) (clojure.core/contains? input :parameter-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-filter-list (input :parameter-filters)) #:http.request.field{:name "ParameterFilters", :shape "ParameterStringFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-deregister-patch-baseline-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"}) (clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]}))

(clojure.core/defn- req-list-association-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-cancel-maintenance-window-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"})]}))

(clojure.core/defn- req-delete-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"})]}))

(clojure.core/defn- req-list-inventory-entries-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-inventory-item-type-name (input :type-name)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InventoryFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-list-associations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :association-filter-list) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-filter-list (input :association-filter-list)) #:http.request.field{:name "AssociationFilterList", :shape "AssociationFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-start-automation-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :document-name)) #:http.request.field{:name "DocumentName", :shape "DocumentARN"})]} (clojure.core/contains? input :target-maps) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-maps (input :target-maps)) #:http.request.field{:name "TargetMaps", :shape "TargetMaps"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-map (input :parameters)) #:http.request.field{:name "Parameters", :shape "AutomationParameterMap"})) (clojure.core/contains? input :target-locations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-locations (input :target-locations)) #:http.request.field{:name "TargetLocations", :shape "TargetLocations", :box true})) (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-mode (input :mode)) #:http.request.field{:name "Mode", :shape "ExecutionMode"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion", :box true})) (clojure.core/contains? input :target-parameter-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-parameter-key (input :target-parameter-name)) #:http.request.field{:name "TargetParameterName", :shape "AutomationParameterKey"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-idempotency-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "IdempotencyToken"}))))

(clojure.core/defn- req-describe-inventory-deletions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :deletion-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-deletion-id (input :deletion-id)) #:http.request.field{:name "DeletionId", :shape "InventoryDeletionId"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-describe-association-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :association-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})) (clojure.core/contains? input :association-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-version (input :association-version)) #:http.request.field{:name "AssociationVersion", :shape "AssociationVersion"}))))

(clojure.core/defn- req-describe-instance-patches-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchComplianceMaxResults", :box true}))))

(clojure.core/defn- req-create-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})]} (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :compliance-severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-compliance-severity (input :compliance-severity)) #:http.request.field{:name "ComplianceSeverity", :shape "AssociationComplianceSeverity"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :automation-target-parameter-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-target-parameter-name (input :automation-target-parameter-name)) #:http.request.field{:name "AutomationTargetParameterName", :shape "AutomationTargetParameterName"})) (clojure.core/contains? input :association-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-name (input :association-name)) #:http.request.field{:name "AssociationName", :shape "AssociationName"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "ScheduleExpression"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :output-location) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-association-output-location (input :output-location)) #:http.request.field{:name "OutputLocation", :shape "InstanceAssociationOutputLocation"}))))

(clojure.core/defn- req-describe-automation-step-executions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-step-execution-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "StepExecutionFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :reverse-order) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reverse-order)) #:http.request.field{:name "ReverseOrder", :shape "Boolean", :box true}))))

(clojure.core/defn- req-put-compliance-items-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-compliance-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ComplianceResourceId"}) (clojure.core/into (ser-compliance-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ComplianceResourceType"}) (clojure.core/into (ser-compliance-type-name (input :compliance-type)) #:http.request.field{:name "ComplianceType", :shape "ComplianceTypeName"}) (clojure.core/into (ser-compliance-execution-summary (input :execution-summary)) #:http.request.field{:name "ExecutionSummary", :shape "ComplianceExecutionSummary"}) (clojure.core/into (ser-compliance-item-entry-list (input :items)) #:http.request.field{:name "Items", :shape "ComplianceItemEntryList"})]} (clojure.core/contains? input :item-content-hash) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-item-content-hash (input :item-content-hash)) #:http.request.field{:name "ItemContentHash", :shape "ComplianceItemContentHash"}))))

(clojure.core/defn- req-update-document-default-version-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"}) (clojure.core/into (ser-document-version-number (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersionNumber"})]}))

(clojure.core/defn- req-update-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]} (clojure.core/contains? input :rejected-patches-action) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-action (input :rejected-patches-action)) #:http.request.field{:name "RejectedPatchesAction", :shape "PatchAction"})) (clojure.core/contains? input :global-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-filter-group (input :global-filters)) #:http.request.field{:name "GlobalFilters", :shape "PatchFilterGroup"})) (clojure.core/contains? input :approved-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :approved-patches)) #:http.request.field{:name "ApprovedPatches", :shape "PatchIdList"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baseline-description (input :description)) #:http.request.field{:name "Description", :shape "BaselineDescription"})) (clojure.core/contains? input :approved-patches-enable-non-security) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :approved-patches-enable-non-security)) #:http.request.field{:name "ApprovedPatchesEnableNonSecurity", :shape "Boolean", :box true})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true})) (clojure.core/contains? input :approval-rules) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-rule-group (input :approval-rules)) #:http.request.field{:name "ApprovalRules", :shape "PatchRuleGroup"})) (clojure.core/contains? input :approved-patches-compliance-level) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-level (input :approved-patches-compliance-level)) #:http.request.field{:name "ApprovedPatchesComplianceLevel", :shape "PatchComplianceLevel"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baseline-name (input :name)) #:http.request.field{:name "Name", :shape "BaselineName"})) (clojure.core/contains? input :sources) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-source-list (input :sources)) #:http.request.field{:name "Sources", :shape "PatchSourceList"})) (clojure.core/contains? input :rejected-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :rejected-patches)) #:http.request.field{:name "RejectedPatches", :shape "PatchIdList"}))))

(clojure.core/defn- req-update-managed-instance-role-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-managed-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "ManagedInstanceId"}) (clojure.core/into (ser-iam-role (input :iam-role)) #:http.request.field{:name "IamRole", :shape "IamRole"})]}))

(clojure.core/defn- req-list-document-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-modify-document-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"}) (clojure.core/into (ser-document-permission-type (input :permission-type)) #:http.request.field{:name "PermissionType", :shape "DocumentPermissionType"})]} (clojure.core/contains? input :account-ids-to-add) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-account-id-list (input :account-ids-to-add)) #:http.request.field{:name "AccountIdsToAdd", :shape "AccountIdList"})) (clojure.core/contains? input :account-ids-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-account-id-list (input :account-ids-to-remove)) #:http.request.field{:name "AccountIdsToRemove", :shape "AccountIdList"}))))

(clojure.core/defn- req-list-resource-data-sync-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-get-parameters-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-parameter-name-list (input :names)) #:http.request.field{:name "Names", :shape "ParameterNameList"})]} (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true}))))

(clojure.core/defn- req-put-parameter-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"}) (clojure.core/into (ser-ps-parameter-value (input :value)) #:http.request.field{:name "Value", :shape "PSParameterValue"}) (clojure.core/into (ser-parameter-type (input :type)) #:http.request.field{:name "Type", :shape "ParameterType"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-description (input :description)) #:http.request.field{:name "Description", :shape "ParameterDescription"})) (clojure.core/contains? input :key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-key-id (input :key-id)) #:http.request.field{:name "KeyId", :shape "ParameterKeyId"})) (clojure.core/contains? input :overwrite) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :overwrite)) #:http.request.field{:name "Overwrite", :shape "Boolean", :box true})) (clojure.core/contains? input :allowed-pattern) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allowed-pattern (input :allowed-pattern)) #:http.request.field{:name "AllowedPattern", :shape "AllowedPattern"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-sessions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-state (input :state)) #:http.request.field{:name "State", :shape "SessionState"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "SessionMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "SessionFilterList"}))))

(clojure.core/defn- req-deregister-target-from-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-target-id (input :window-target-id)) #:http.request.field{:name "WindowTargetId", :shape "MaintenanceWindowTargetId"})]} (clojure.core/contains? input :safe) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :safe)) #:http.request.field{:name "Safe", :shape "Boolean", :box true}))))

(clojure.core/defn- req-list-commands-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :command-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "CommandMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "CommandFilterList"}))))

(clojure.core/defn- req-get-automation-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"})]}))

(clojure.core/defn- req-get-command-invocation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"}) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :plugin-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-plugin-name (input :plugin-name)) #:http.request.field{:name "PluginName", :shape "CommandPluginName"}))))

(clojure.core/defn- req-update-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-content (input :content)) #:http.request.field{:name "Content", :shape "DocumentContent"}) (clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]} (clojure.core/contains? input :attachments) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attachments-source-list (input :attachments)) #:http.request.field{:name "Attachments", :shape "AttachmentsSourceList"})) (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :document-format) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-format (input :document-format)) #:http.request.field{:name "DocumentFormat", :shape "DocumentFormat"})) (clojure.core/contains? input :target-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-type (input :target-type)) #:http.request.field{:name "TargetType", :shape "TargetType"}))))

(clojure.core/defn- req-delete-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"})]}))

(clojure.core/defn- req-list-command-invocations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :command-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-id (input :command-id)) #:http.request.field{:name "CommandId", :shape "CommandId"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "CommandMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-command-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "CommandFilterList"})) (clojure.core/contains? input :details) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :details)) #:http.request.field{:name "Details", :shape "Boolean"}))))

(clojure.core/defn- req-describe-automation-executions-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-execution-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "AutomationExecutionFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-update-service-setting-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-service-setting-id (input :setting-id)) #:http.request.field{:name "SettingId", :shape "ServiceSettingId"}) (clojure.core/into (ser-service-setting-value (input :setting-value)) #:http.request.field{:name "SettingValue", :shape "ServiceSettingValue"})]}))

(clojure.core/defn- req-create-resource-data-sync-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-data-sync-name (input :sync-name)) #:http.request.field{:name "SyncName", :shape "ResourceDataSyncName"}) (clojure.core/into (ser-resource-data-sync-s-3-destination (input :s-3-destination)) #:http.request.field{:name "S3Destination", :shape "ResourceDataSyncS3Destination"})]}))

(clojure.core/defn- req-describe-instance-information-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :instance-information-filter-list) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-information-filter-list (input :instance-information-filter-list)) #:http.request.field{:name "InstanceInformationFilterList", :shape "InstanceInformationFilterList"})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-information-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InstanceInformationStringFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results-ec-2-compatible (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResultsEC2Compatible", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-maintenance-windows-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "MaintenanceWindowFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaintenanceWindowMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-reset-service-setting-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-service-setting-id (input :setting-id)) #:http.request.field{:name "SettingId", :shape "ServiceSettingId"})]}))

(clojure.core/defn- req-delete-activation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-activation-id (input :activation-id)) #:http.request.field{:name "ActivationId", :shape "ActivationId"})]}))

(clojure.core/defn- req-stop-automation-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-automation-execution-id (input :automation-execution-id)) #:http.request.field{:name "AutomationExecutionId", :shape "AutomationExecutionId"})]} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stop-type (input :type)) #:http.request.field{:name "Type", :shape "StopType"}))))

(clojure.core/defn- req-describe-activations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-describe-activations-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "DescribeActivationsFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-delete-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-name (input :name)) #:http.request.field{:name "Name", :shape "DocumentName"})]}))

(clojure.core/defn- req-get-maintenance-window-execution-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"}) (clojure.core/into (ser-maintenance-window-execution-task-id (input :task-id)) #:http.request.field{:name "TaskId", :shape "MaintenanceWindowExecutionTaskId"})]}))

(clojure.core/defn- req-delete-parameter-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :name)) #:http.request.field{:name "Name", :shape "PSParameterName"})]}))

(clojure.core/defn- req-delete-inventory-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-inventory-item-type-name (input :type-name)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeName"})]} (clojure.core/contains? input :schema-delete-option) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-schema-delete-option (input :schema-delete-option)) #:http.request.field{:name "SchemaDeleteOption", :shape "InventorySchemaDeleteOption"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dry-run (input :dry-run)) #:http.request.field{:name "DryRun", :shape "DryRun"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-describe-effective-instance-associations-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-effective-instance-association-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "EffectiveInstanceAssociationMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-inventory-schema-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :type-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-item-type-name-filter (input :type-name)) #:http.request.field{:name "TypeName", :shape "InventoryItemTypeNameFilter"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-get-inventory-schema-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "GetInventorySchemaMaxResults", :box true})) (clojure.core/contains? input :aggregator) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aggregator-schema-only (input :aggregator)) #:http.request.field{:name "Aggregator", :shape "AggregatorSchemaOnly"})) (clojure.core/contains? input :sub-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-is-sub-type-schema (input :sub-type)) #:http.request.field{:name "SubType", :shape "IsSubTypeSchema", :box true}))))

(clojure.core/defn- req-update-maintenance-window-target-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-target-id (input :window-target-id)) #:http.request.field{:name "WindowTargetId", :shape "MaintenanceWindowTargetId"})]} (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :owner-information) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-information (input :owner-information)) #:http.request.field{:name "OwnerInformation", :shape "OwnerInformation"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :replace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :replace)) #:http.request.field{:name "Replace", :shape "Boolean", :box true}))))

(clojure.core/defn- req-register-patch-baseline-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-id (input :baseline-id)) #:http.request.field{:name "BaselineId", :shape "BaselineId"}) (clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]}))

(clojure.core/defn- req-remove-tags-from-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-type-for-tagging (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceTypeForTagging"}) (clojure.core/into (ser-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceId"}) (clojure.core/into (ser-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "KeyList"})]}))

(clojure.core/defn- req-describe-instance-patch-states-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdList"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchComplianceMaxResults", :box true}))))

(clojure.core/defn- req-create-association-batch-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-create-association-batch-request-entries (input :entries)) #:http.request.field{:name "Entries", :shape "CreateAssociationBatchRequestEntries"})]}))

(clojure.core/defn- req-describe-instance-patch-states-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-patch-state-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InstancePatchStateFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchComplianceMaxResults", :box true}))))

(clojure.core/defn- req-send-command-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :document-name)) #:http.request.field{:name "DocumentName", :shape "DocumentARN"})]} (clojure.core/contains? input :service-role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-service-role (input :service-role-arn)) #:http.request.field{:name "ServiceRoleArn", :shape "ServiceRole"})) (clojure.core/contains? input :instance-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id-list (input :instance-ids)) #:http.request.field{:name "InstanceIds", :shape "InstanceIdList"})) (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "Comment", :shape "Comment"})) (clojure.core/contains? input :timeout-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-seconds (input :timeout-seconds)) #:http.request.field{:name "TimeoutSeconds", :shape "TimeoutSeconds", :box true})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :output-s-3-bucket-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket-name (input :output-s-3-bucket-name)) #:http.request.field{:name "OutputS3BucketName", :shape "S3BucketName"})) (clojure.core/contains? input :notification-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-config (input :notification-config)) #:http.request.field{:name "NotificationConfig", :shape "NotificationConfig"})) (clojure.core/contains? input :document-hash) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash (input :document-hash)) #:http.request.field{:name "DocumentHash", :shape "DocumentHash"})) (clojure.core/contains? input :cloud-watch-output-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloud-watch-output-config (input :cloud-watch-output-config)) #:http.request.field{:name "CloudWatchOutputConfig", :shape "CloudWatchOutputConfig"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :output-s-3-key-prefix) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key-prefix (input :output-s-3-key-prefix)) #:http.request.field{:name "OutputS3KeyPrefix", :shape "S3KeyPrefix"})) (clojure.core/contains? input :output-s-3-region) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-region (input :output-s-3-region)) #:http.request.field{:name "OutputS3Region", :shape "S3Region"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :document-hash-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-hash-type (input :document-hash-type)) #:http.request.field{:name "DocumentHashType", :shape "DocumentHashType"}))))

(clojure.core/defn- req-get-inventory-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "InventoryFilterList"})) (clojure.core/contains? input :aggregators) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inventory-aggregator-list (input :aggregators)) #:http.request.field{:name "Aggregators", :shape "InventoryAggregatorList"})) (clojure.core/contains? input :result-attributes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-result-attribute-list (input :result-attributes)) #:http.request.field{:name "ResultAttributes", :shape "ResultAttributeList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-update-association-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})]} (clojure.core/contains? input :association-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-version (input :association-version)) #:http.request.field{:name "AssociationVersion", :shape "AssociationVersion"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "Parameters", :shape "Parameters"})) (clojure.core/contains? input :compliance-severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-compliance-severity (input :compliance-severity)) #:http.request.field{:name "ComplianceSeverity", :shape "AssociationComplianceSeverity"})) (clojure.core/contains? input :max-concurrency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-concurrency (input :max-concurrency)) #:http.request.field{:name "MaxConcurrency", :shape "MaxConcurrency"})) (clojure.core/contains? input :max-errors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-errors (input :max-errors)) #:http.request.field{:name "MaxErrors", :shape "MaxErrors"})) (clojure.core/contains? input :automation-target-parameter-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-automation-target-parameter-name (input :automation-target-parameter-name)) #:http.request.field{:name "AutomationTargetParameterName", :shape "AutomationTargetParameterName"})) (clojure.core/contains? input :association-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-name (input :association-name)) #:http.request.field{:name "AssociationName", :shape "AssociationName"})) (clojure.core/contains? input :targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})) (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "ScheduleExpression"})) (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})) (clojure.core/contains? input :output-location) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-association-output-location (input :output-location)) #:http.request.field{:name "OutputLocation", :shape "InstanceAssociationOutputLocation"}))))

(clojure.core/defn- req-get-maintenance-window-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-execution-id (input :window-execution-id)) #:http.request.field{:name "WindowExecutionId", :shape "MaintenanceWindowExecutionId"})]}))

(clojure.core/defn- req-list-compliance-items-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-string-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "ComplianceStringFilterList"})) (clojure.core/contains? input :resource-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-resource-id-list (input :resource-ids)) #:http.request.field{:name "ResourceIds", :shape "ComplianceResourceIdList"})) (clojure.core/contains? input :resource-types) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-compliance-resource-type-list (input :resource-types)) #:http.request.field{:name "ResourceTypes", :shape "ComplianceResourceTypeList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true}))))

(clojure.core/defn- req-start-associations-once-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id-list (input :association-ids)) #:http.request.field{:name "AssociationIds", :shape "AssociationIdList"})]}))

(clojure.core/defn- req-get-patch-baseline-for-patch-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-patch-group (input :patch-group)) #:http.request.field{:name "PatchGroup", :shape "PatchGroup"})]} (clojure.core/contains? input :operating-system) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operating-system (input :operating-system)) #:http.request.field{:name "OperatingSystem", :shape "OperatingSystem"}))))

(clojure.core/defn- req-delete-association-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})) (clojure.core/contains? input :instance-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})) (clojure.core/contains? input :association-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"}))))

(clojure.core/defn- req-register-target-with-maintenance-window-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "MaintenanceWindowResourceType"}) (clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "Targets", :shape "Targets"})]} (clojure.core/contains? input :owner-information) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-owner-information (input :owner-information)) #:http.request.field{:name "OwnerInformation", :shape "OwnerInformation"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-name (input :name)) #:http.request.field{:name "Name", :shape "MaintenanceWindowName"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maintenance-window-description (input :description)) #:http.request.field{:name "Description", :shape "MaintenanceWindowDescription"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-delete-parameters-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-parameter-name-list (input :names)) #:http.request.field{:name "Names", :shape "ParameterNameList"})]}))

(clojure.core/defn- req-create-patch-baseline-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-baseline-name (input :name)) #:http.request.field{:name "Name", :shape "BaselineName"})]} (clojure.core/contains? input :rejected-patches-action) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-action (input :rejected-patches-action)) #:http.request.field{:name "RejectedPatchesAction", :shape "PatchAction"})) (clojure.core/contains? input :global-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-filter-group (input :global-filters)) #:http.request.field{:name "GlobalFilters", :shape "PatchFilterGroup"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :approved-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :approved-patches)) #:http.request.field{:name "ApprovedPatches", :shape "PatchIdList"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baseline-description (input :description)) #:http.request.field{:name "Description", :shape "BaselineDescription"})) (clojure.core/contains? input :approved-patches-enable-non-security) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :approved-patches-enable-non-security)) #:http.request.field{:name "ApprovedPatchesEnableNonSecurity", :shape "Boolean", :box true})) (clojure.core/contains? input :approval-rules) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-rule-group (input :approval-rules)) #:http.request.field{:name "ApprovalRules", :shape "PatchRuleGroup"})) (clojure.core/contains? input :approved-patches-compliance-level) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-compliance-level (input :approved-patches-compliance-level)) #:http.request.field{:name "ApprovedPatchesComplianceLevel", :shape "PatchComplianceLevel"})) (clojure.core/contains? input :sources) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-source-list (input :sources)) #:http.request.field{:name "Sources", :shape "PatchSourceList"})) (clojure.core/contains? input :operating-system) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operating-system (input :operating-system)) #:http.request.field{:name "OperatingSystem", :shape "OperatingSystem"})) (clojure.core/contains? input :rejected-patches) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-id-list (input :rejected-patches)) #:http.request.field{:name "RejectedPatches", :shape "PatchIdList"})) (clojure.core/contains? input :client-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-token (input :client-token)) #:http.request.field{:name "ClientToken", :shape "ClientToken", :idempotency-token true}))))

(clojure.core/defn- req-describe-patch-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-maintenance-window-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-maintenance-window-id (input :window-id)) #:http.request.field{:name "WindowId", :shape "MaintenanceWindowId"}) (clojure.core/into (ser-maintenance-window-task-id (input :window-task-id)) #:http.request.field{:name "WindowTaskId", :shape "MaintenanceWindowTaskId"})]}))

(clojure.core/defn- req-describe-available-patches-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-terminate-session-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-id (input :session-id)) #:http.request.field{:name "SessionId", :shape "SessionId"})]}))

(clojure.core/defn- req-describe-instance-associations-status-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"})]} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-describe-patch-baselines-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-orchestrator-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "PatchOrchestratorFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-patch-baseline-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "PatchBaselineMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-add-tags-to-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-type-for-tagging (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceTypeForTagging"}) (clojure.core/into (ser-resource-id (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceId"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})]}))

(clojure.core/defn- req-put-inventory-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-instance-id (input :instance-id)) #:http.request.field{:name "InstanceId", :shape "InstanceId"}) (clojure.core/into (ser-inventory-item-list (input :items)) #:http.request.field{:name "Items", :shape "InventoryItemList"})]}))

(clojure.core/defn- req-resume-session-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-session-id (input :session-id)) #:http.request.field{:name "SessionId", :shape "SessionId"})]}))

(clojure.core/defn- req-describe-association-executions-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-association-id (input :association-id)) #:http.request.field{:name "AssociationId", :shape "AssociationId"})]} (clojure.core/contains? input :filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-association-execution-filter-list (input :filters)) #:http.request.field{:name "Filters", :shape "AssociationExecutionFilterList"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-parameters-by-path-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-ps-parameter-name (input :path)) #:http.request.field{:name "Path", :shape "PSParameterName"})]} (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :recursive)) #:http.request.field{:name "Recursive", :shape "Boolean", :box true})) (clojure.core/contains? input :parameter-filters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-string-filter-list (input :parameter-filters)) #:http.request.field{:name "ParameterFilters", :shape "ParameterStringFilterList"})) (clojure.core/contains? input :with-decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :with-decryption)) #:http.request.field{:name "WithDecryption", :shape "Boolean", :box true})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-get-parameters-by-path-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "GetParametersByPathMaxResults", :box true})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "NextToken", :shape "NextToken"}))))

(clojure.core/defn- req-get-default-patch-baseline-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :operating-system) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-operating-system (input :operating-system)) #:http.request.field{:name "OperatingSystem", :shape "OperatingSystem"}))))

(clojure.core/defn- req-create-activation-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-iam-role (input :iam-role)) #:http.request.field{:name "IamRole", :shape "IamRole"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-activation-description (input :description)) #:http.request.field{:name "Description", :shape "ActivationDescription"})) (clojure.core/contains? input :default-instance-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-instance-name (input :default-instance-name)) #:http.request.field{:name "DefaultInstanceName", :shape "DefaultInstanceName"})) (clojure.core/contains? input :registration-limit) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registration-limit (input :registration-limit)) #:http.request.field{:name "RegistrationLimit", :shape "RegistrationLimit", :box true})) (clojure.core/contains? input :expiration-date) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-expiration-date (input :expiration-date)) #:http.request.field{:name "ExpirationDate", :shape "ExpirationDate"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-document-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-document-arn (input :name)) #:http.request.field{:name "Name", :shape "DocumentARN"})]} (clojure.core/contains? input :document-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version (input :document-version)) #:http.request.field{:name "DocumentVersion", :shape "DocumentVersion"})) (clojure.core/contains? input :version-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-name (input :version-name)) #:http.request.field{:name "VersionName", :shape "DocumentVersionName"}))))

(clojure.core/declare deser-string-date-time)

(clojure.core/declare deser-parameter-history)

(clojure.core/declare deser-inventory-result-entity)

(clojure.core/declare deser-target-map)

(clojure.core/declare deser-command-plugin-output)

(clojure.core/declare deser-non-compliant-summary)

(clojure.core/declare deser-association-resource-id)

(clojure.core/declare deser-patch-compliance-data-list)

(clojure.core/declare deser-instance-id-list)

(clojure.core/declare deser-automation-parameter-key)

(clojure.core/declare deser-approve-after-days)

(clojure.core/declare deser-maintenance-window-run-command-parameters)

(clojure.core/declare deser-association-version-list)

(clojure.core/declare deser-attachment-information)

(clojure.core/declare deser-output-source-id)

(clojure.core/declare deser-parameter-value-list)

(clojure.core/declare deser-document-content)

(clojure.core/declare deser-automation-type)

(clojure.core/declare deser-association-version)

(clojure.core/declare deser-maintenance-window-execution-task-execution-id)

(clojure.core/declare deser-maintenance-window-task)

(clojure.core/declare deser-target-maps)

(clojure.core/declare deser-command-invocation-list)

(clojure.core/declare deser-association-list)

(clojure.core/declare deser-patch-severity)

(clojure.core/declare deser-automation-execution-metadata-list)

(clojure.core/declare deser-document-version-info)

(clojure.core/declare deser-service-role)

(clojure.core/declare deser-maintenance-window-enabled)

(clojure.core/declare deser-maintenance-window-name)

(clojure.core/declare deser-association-description-list)

(clojure.core/declare deser-command-status)

(clojure.core/declare deser-instance-id)

(clojure.core/declare deser-document-status-information)

(clojure.core/declare deser-inventory-type-display-name)

(clojure.core/declare deser-patch-group)

(clojure.core/declare deser-automation-action-name)

(clojure.core/declare deser-patch-group-list)

(clojure.core/declare deser-patch-filter)

(clojure.core/declare deser-notification-event)

(clojure.core/declare deser-association-executions-list)

(clojure.core/declare deser-document-version-name)

(clojure.core/declare deser-instance-association-status-infos)

(clojure.core/declare deser-parameter-name)

(clojure.core/declare deser-patch-baseline-identity-list)

(clojure.core/declare deser-parameter-type)

(clojure.core/declare deser-s-3-region)

(clojure.core/declare deser-patch-classification)

(clojure.core/declare deser-comment)

(clojure.core/declare deser-command-invocation-status)

(clojure.core/declare deser-last-resource-data-sync-message)

(clojure.core/declare deser-compliance-resource-type)

(clojure.core/declare deser-patch-source)

(clojure.core/declare deser-document-identifier)

(clojure.core/declare deser-association-resource-type)

(clojure.core/declare deser-parameter-label-list)

(clojure.core/declare deser-session-id)

(clojure.core/declare deser-progress-counters)

(clojure.core/declare deser-ps-parameter-version)

(clojure.core/declare deser-account-id-list)

(clojure.core/declare deser-maintenance-window-execution-task-identity-list)

(clojure.core/declare deser-maintenance-window-execution-task-id)

(clojure.core/declare deser-maintenance-window-cutoff)

(clojure.core/declare deser-timeout-seconds)

(clojure.core/declare deser-resource-data-sync-s-3-region)

(clojure.core/declare deser-delivery-timed-out-count)

(clojure.core/declare deser-compliance-summary-item-list)

(clojure.core/declare deser-attribute-name)

(clojure.core/declare deser-step-execution)

(clojure.core/declare deser-product)

(clojure.core/declare deser-patch-installed-count)

(clojure.core/declare deser-status-additional-info)

(clojure.core/declare deser-completed-count)

(clojure.core/declare deser-resource-data-sync-awskms-key-arn)

(clojure.core/declare deser-instance-count)

(clojure.core/declare deser-put-inventory-message)

(clojure.core/declare deser-last-resource-data-sync-status)

(clojure.core/declare deser-error-count)

(clojure.core/declare deser-status-message)

(clojure.core/declare deser-patch-rule)

(clojure.core/declare deser-execution-mode)

(clojure.core/declare deser-inventory-item-content-hash)

(clojure.core/declare deser-maintenance-window-execution-status)

(clojure.core/declare deser-output-source)

(clojure.core/declare deser-inventory-item-entry)

(clojure.core/declare deser-parameter-metadata)

(clojure.core/declare deser-association-execution-targets-list)

(clojure.core/declare deser-command-plugin)

(clojure.core/declare deser-cloud-watch-log-group-name)

(clojure.core/declare deser-parameters)

(clojure.core/declare deser-response-code)

(clojure.core/declare deser-association-execution-id)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-identity-list)

(clojure.core/declare deser-instance-association-output-url)

(clojure.core/declare deser-resource-data-sync-s-3-format)

(clojure.core/declare deser-document-type)

(clojure.core/declare deser-association-execution)

(clojure.core/declare deser-document-parameter)

(clojure.core/declare deser-association-id)

(clojure.core/declare deser-severity-summary)

(clojure.core/declare deser-maintenance-window-identity-for-target)

(clojure.core/declare deser-patch-deployment-status)

(clojure.core/declare deser-automation-execution)

(clojure.core/declare deser-patch-content-url)

(clojure.core/declare deser-compliance-item-title)

(clojure.core/declare deser-tag-key)

(clojure.core/declare deser-instance-association-list)

(clojure.core/declare deser-maintenance-window-execution-list)

(clojure.core/declare deser-platform-type)

(clojure.core/declare deser-parameter-name-list)

(clojure.core/declare deser-instance-aggregated-association-overview)

(clojure.core/declare deser-target-type)

(clojure.core/declare deser-resource-data-sync-s-3-prefix)

(clojure.core/declare deser-notification-config)

(clojure.core/declare deser-automation-execution-metadata)

(clojure.core/declare deser-s-3-bucket-name)

(clojure.core/declare deser-ping-status)

(clojure.core/declare deser-inventory-deletion-summary-items)

(clojure.core/declare deser-compliance-item-list)

(clojure.core/declare deser-document-hash)

(clojure.core/declare deser-inventory-result-entity-list)

(clojure.core/declare deser-inventory-item-schema)

(clojure.core/declare deser-iam-role)

(clojure.core/declare deser-compliance-severity)

(clojure.core/declare deser-notification-type)

(clojure.core/declare deser-inventory-deletion-status-item)

(clojure.core/declare deser-maintenance-window-lambda-payload)

(clojure.core/declare deser-maintenance-window-task-arn)

(clojure.core/declare deser-maintenance-window-lambda-qualifier)

(clojure.core/declare deser-patch-compliance-data)

(clojure.core/declare deser-target-map-key)

(clojure.core/declare deser-inventory-deletions-list)

(clojure.core/declare deser-patch-msrc-number)

(clojure.core/declare deser-patch-missing-count)

(clojure.core/declare deser-scheduled-window-execution)

(clojure.core/declare deser-association-status)

(clojure.core/declare deser-document-parameter-name)

(clojure.core/declare deser-attachment-hash)

(clojure.core/declare deser-document-parameter-descrption)

(clojure.core/declare deser-snapshot-download-url)

(clojure.core/declare deser-inventory-item-attribute-name)

(clojure.core/declare deser-target-locations)

(clojure.core/declare deser-patch-installed-rejected-count)

(clojure.core/declare deser-status-details)

(clojure.core/declare deser-maintenance-window-task-parameters)

(clojure.core/declare deser-patch-baseline-identity)

(clojure.core/declare deser-next-token)

(clojure.core/declare deser-standard-output-content)

(clojure.core/declare deser-resource-data-sync-s-3-destination)

(clojure.core/declare deser-agent-error-code)

(clojure.core/declare deser-document-owner)

(clojure.core/declare deser-cloud-watch-output-config)

(clojure.core/declare deser-document-parameter-list)

(clojure.core/declare deser-document-sha-1)

(clojure.core/declare deser-connection-status)

(clojure.core/declare deser-document-version-list)

(clojure.core/declare deser-parameter-metadata-list)

(clojure.core/declare deser-default-instance-name)

(clojure.core/declare deser-maintenance-window-task-parameter-name)

(clojure.core/declare deser-session-target)

(clojure.core/declare deser-session-owner)

(clojure.core/declare deser-expiration-date)

(clojure.core/declare deser-maintenance-window-task-priority)

(clojure.core/declare deser-session-status)

(clojure.core/declare deser-document-arn)

(clojure.core/declare deser-inventory-result-entity-id)

(clojure.core/declare deser-patch-id)

(clojure.core/declare deser-effective-patch)

(clojure.core/declare deser-max-concurrency)

(clojure.core/declare deser-maintenance-window-task-id)

(clojure.core/declare deser-resolved-targets)

(clojure.core/declare deser-instance-patch-states-list)

(clojure.core/declare deser-inventory-deletion-start-time)

(clojure.core/declare deser-patch-action)

(clojure.core/declare deser-command-invocation)

(clojure.core/declare deser-compliant-summary)

(clojure.core/declare deser-regions)

(clojure.core/declare deser-session-details)

(clojure.core/declare deser-compliance-item-id)

(clojure.core/declare deser-resource-data-sync-item)

(clojure.core/declare deser-cloud-watch-output-enabled)

(clojure.core/declare deser-parameter-list)

(clojure.core/declare deser-parameter-label)

(clojure.core/declare deser-association-description)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-document-description)

(clojure.core/declare deser-maintenance-window-target)

(clojure.core/declare deser-inventory-deletion-last-status-update-time)

(clojure.core/declare deser-compliance-type-name)

(clojure.core/declare deser-patch-id-list)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-parameters)

(clojure.core/declare deser-logging-info)

(clojure.core/declare deser-ps-parameter-value)

(clojure.core/declare deser-attachment-content)

(clojure.core/declare deser-patch-filter-group)

(clojure.core/declare deser-instance-information)

(clojure.core/declare deser-maintenance-window-task-list)

(clojure.core/declare deser-status-name)

(clojure.core/declare deser-inventory-result-item)

(clojure.core/declare deser-command-plugin-name)

(clojure.core/declare deser-content-length)

(clojure.core/declare deser-attribute-value)

(clojure.core/declare deser-session-manager-output-url)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-id)

(clojure.core/declare deser-inventory-deletion-summary)

(clojure.core/declare deser-parameter-key-id)

(clojure.core/declare deser-automation-parameter-map)

(clojure.core/declare deser-association-overview)

(clojure.core/declare deser-resource-compliance-summary-item)

(clojure.core/declare deser-patch-rule-group)

(clojure.core/declare deser-maintenance-window-target-list)

(clojure.core/declare deser-command-plugin-list)

(clojure.core/declare deser-accounts)

(clojure.core/declare deser-parameter-history-list)

(clojure.core/declare deser-service-setting-value)

(clojure.core/declare deser-registrations-count)

(clojure.core/declare deser-max-errors)

(clojure.core/declare deser-inventory-item-attribute-list)

(clojure.core/declare deser-inventory-item-schema-version)

(clojure.core/declare deser-compliance-status)

(clojure.core/declare deser-inventory-deletion-status)

(clojure.core/declare deser-account)

(clojure.core/declare deser-compliance-execution-summary)

(clojure.core/declare deser-url)

(clojure.core/declare deser-invocation-trace-output)

(clojure.core/declare deser-stream-url)

(clojure.core/declare deser-allowed-pattern)

(clojure.core/declare deser-tag-value)

(clojure.core/declare deser-valid-next-step)

(clojure.core/declare deser-patch-msrc-severity)

(clojure.core/declare deser-document-default-version-description)

(clojure.core/declare deser-default-baseline)

(clojure.core/declare deser-instance-tag-name)

(clojure.core/declare deser-total-count)

(clojure.core/declare deser-batch-error-message)

(clojure.core/declare deser-patch-source-product-list)

(clojure.core/declare deser-baseline-id)

(clojure.core/declare deser-patch-not-applicable-count)

(clojure.core/declare deser-maintenance-window-target-id)

(clojure.core/declare deser-failure-details)

(clojure.core/declare deser-patch-product)

(clojure.core/declare deser-ip-address)

(clojure.core/declare deser-maintenance-window-id)

(clojure.core/declare deser-created-date)

(clojure.core/declare deser-patch-status)

(clojure.core/declare deser-normal-string-map)

(clojure.core/declare deser-automation-target-parameter-name)

(clojure.core/declare deser-patch-vendor)

(clojure.core/declare deser-compliance-execution-id)

(clojure.core/declare deser-maintenance-window-description)

(clojure.core/declare deser-association-name)

(clojure.core/declare deser-maintenance-window-lambda-client-context)

(clojure.core/declare deser-maintenance-window-execution)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-last-successful-resource-data-sync-time)

(clojure.core/declare deser-string)

(clojure.core/declare deser-parameter)

(clojure.core/declare deser-parameter-description)

(clojure.core/declare deser-patch-installed-other-count)

(clojure.core/declare deser-account-id)

(clojure.core/declare deser-inventory-item-schema-result-list)

(clojure.core/declare deser-resource-compliance-summary-item-list)

(clojure.core/declare deser-maintenance-window-task-target-id)

(clojure.core/declare deser-create-association-batch-request-entry)

(clojure.core/declare deser-patch-description)

(clojure.core/declare deser-patch-filter-key)

(clojure.core/declare deser-attachment-name)

(clojure.core/declare deser-patch-failed-count)

(clojure.core/declare deser-maintenance-window-lambda-parameters)

(clojure.core/declare deser-automation-execution-status)

(clojure.core/declare deser-document-schema-version)

(clojure.core/declare deser-attachment-information-list)

(clojure.core/declare deser-patch-source-list)

(clojure.core/declare deser-target-location)

(clojure.core/declare deser-notification-arn)

(clojure.core/declare deser-resource-data-sync-created-time)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-maintenance-window-step-functions-input)

(clojure.core/declare deser-activation-id)

(clojure.core/declare deser-document-parameter-default-value)

(clojure.core/declare deser-document-format)

(clojure.core/declare deser-targets)

(clojure.core/declare deser-patch-compliance-level)

(clojure.core/declare deser-patch-list)

(clojure.core/declare deser-patch-source-configuration)

(clojure.core/declare deser-target-map-value)

(clojure.core/declare deser-document-status)

(clojure.core/declare deser-description-in-document)

(clojure.core/declare deser-command)

(clojure.core/declare deser-target-parameter-list)

(clojure.core/declare deser-instances-count)

(clojure.core/declare deser-patch-group-patch-baseline-mapping-list)

(clojure.core/declare deser-resource-count)

(clojure.core/declare deser-execution-role-name)

(clojure.core/declare deser-baseline-name)

(clojure.core/declare deser-session-manager-s-3-output-url)

(clojure.core/declare deser-attachment-hash-type)

(clojure.core/declare deser-attachment-url)

(clojure.core/declare deser-activation)

(clojure.core/declare deser-maintenance-window-step-functions-name)

(clojure.core/declare deser-compliance-resource-id)

(clojure.core/declare deser-maintenance-window-execution-task-invocation-identity)

(clojure.core/declare deser-resource-data-sync-s-3-bucket-name)

(clojure.core/declare deser-maintenance-window-duration-hours)

(clojure.core/declare deser-platform-type-list)

(clojure.core/declare deser-s-3-key-prefix)

(clojure.core/declare deser-session-manager-cloud-watch-output-url)

(clojure.core/declare deser-compliance-execution-type)

(clojure.core/declare deser-effective-patch-list)

(clojure.core/declare deser-schedule-expression)

(clojure.core/declare deser-failed-create-association)

(clojure.core/declare deser-resource-data-sync-item-list)

(clojure.core/declare deser-command-list)

(clojure.core/declare deser-command-id)

(clojure.core/declare deser-association-version-info)

(clojure.core/declare deser-instance-association)

(clojure.core/declare deser-long)

(clojure.core/declare deser-s-3-output-url)

(clojure.core/declare deser-install-override-list)

(clojure.core/declare deser-activation-code)

(clojure.core/declare deser-patch-source-name)

(clojure.core/declare deser-inventory-item-entry-list)

(clojure.core/declare deser-instance-association-status-info)

(clojure.core/declare deser-association-status-name)

(clojure.core/declare deser-inventory-result-item-map)

(clojure.core/declare deser-remaining-count)

(clojure.core/declare deser-resource-data-sync-name)

(clojure.core/declare deser-patch-rule-list)

(clojure.core/declare deser-owner-information)

(clojure.core/declare deser-session-list)

(clojure.core/declare deser-maintenance-window-string-date-time)

(clojure.core/declare deser-service-setting-id)

(clojure.core/declare deser-s-3-output-location)

(clojure.core/declare deser-fault)

(clojure.core/declare deser-maintenance-window-identity-list)

(clojure.core/declare deser-automation-parameter-value)

(clojure.core/declare deser-patch-filter-value-list)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-maintenance-window-schedule)

(clojure.core/declare deser-version)

(clojure.core/declare deser-inventory-item-type-name)

(clojure.core/declare deser-patch-compliance-data-state)

(clojure.core/declare deser-maintenance-window-task-invocation-parameters)

(clojure.core/declare deser-document-name)

(clojure.core/declare deser-ps-parameter-selector)

(clojure.core/declare deser-maintenance-window-step-functions-parameters)

(clojure.core/declare deser-inventory-result-item-key)

(clojure.core/declare deser-maintenance-windows-for-target-list)

(clojure.core/declare deser-patch-filter-value)

(clojure.core/declare deser-maintenance-window-task-type)

(clojure.core/declare deser-output-source-type)

(clojure.core/declare deser-maintenance-window-allow-unassociated-targets)

(clojure.core/declare deser-maintenance-window-execution-status-details)

(clojure.core/declare deser-maintenance-window-task-parameters-list)

(clojure.core/declare deser-document-version)

(clojure.core/declare deser-target)

(clojure.core/declare deser-scheduled-window-execution-list)

(clojure.core/declare deser-document-hash-type)

(clojure.core/declare deser-valid-next-step-list)

(clojure.core/declare deser-maintenance-window-execution-task-id-list)

(clojure.core/declare deser-association-execution-target)

(clojure.core/declare deser-instance-association-execution-summary)

(clojure.core/declare deser-instance-patch-state)

(clojure.core/declare deser-association)

(clojure.core/declare deser-patch-product-family)

(clojure.core/declare deser-document-parameter-type)

(clojure.core/declare deser-resource-count-by-status)

(clojure.core/declare deser-service-setting)

(clojure.core/declare deser-compliance-summary-item)

(clojure.core/declare deser-command-plugin-status)

(clojure.core/declare deser-maintenance-window-timezone)

(clojure.core/declare deser-patch-title)

(clojure.core/declare deser-association-compliance-severity)

(clojure.core/declare deser-session)

(clojure.core/declare deser-activation-description)

(clojure.core/declare deser-ps-parameter-name)

(clojure.core/declare deser-activation-list)

(clojure.core/declare deser-instance-association-output-location)

(clojure.core/declare deser-maintenance-window-automation-parameters)

(clojure.core/declare deser-association-status-aggregated-count)

(clojure.core/declare deser-patch-language)

(clojure.core/declare deser-attachment-content-list)

(clojure.core/declare deser-inventory-item-capture-time)

(clojure.core/declare deser-maintenance-window-execution-task-identity)

(clojure.core/declare deser-failed-create-association-list)

(clojure.core/declare deser-baseline-description)

(clojure.core/declare deser-maintenance-window-execution-id)

(clojure.core/declare deser-automation-execution-id)

(clojure.core/declare deser-target-value)

(clojure.core/declare deser-compliance-summary-count)

(clojure.core/declare deser-patch-filter-list)

(clojure.core/declare deser-inventory-deletion-id)

(clojure.core/declare deser-region)

(clojure.core/declare deser-token-value)

(clojure.core/declare deser-inventory-item-attribute)

(clojure.core/declare deser-patch-source-product)

(clojure.core/declare deser-computer-name)

(clojure.core/declare deser-maintenance-window-task-parameter-value-expression)

(clojure.core/declare deser-target-map-value-list)

(clojure.core/declare deser-target-key)

(clojure.core/declare deser-inventory-deletion-summary-item)

(clojure.core/declare deser-automation-parameter-value-list)

(clojure.core/declare deser-compliance-item-details)

(clojure.core/declare deser-maintenance-window-task-parameter-value-list)

(clojure.core/declare deser-last-resource-data-sync-time)

(clojure.core/declare deser-patch)

(clojure.core/declare deser-patch-group-patch-baseline-mapping)

(clojure.core/declare deser-instance-information-list)

(clojure.core/declare deser-compliance-item)

(clojure.core/declare deser-operating-system)

(clojure.core/declare deser-document-identifier-list)

(clojure.core/declare deser-notification-event-list)

(clojure.core/declare deser-step-execution-list)

(clojure.core/declare deser-instance-association-status-aggregated-count)

(clojure.core/declare deser-maintenance-window-identity)

(clojure.core/declare deser-snapshot-id)

(clojure.core/declare deser-registration-limit)

(clojure.core/declare deser-parameter-value)

(clojure.core/declare deser-standard-error-content)

(clojure.core/declare deser-date-time)

(clojure.core/declare deser-patch-operation-type)

(clojure.core/declare deser-target-values)

(clojure.core/declare deser-patch-kb-number)

(clojure.core/declare deser-inventory-attribute-data-type)

(clojure.core/declare deser-instance-patch-state-list)

(clojure.core/declare deser-target-count)

(clojure.core/declare deser-maintenance-window-task-parameter-value)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-inventory-deletion-last-status-message)

(clojure.core/declare deser-maintenance-window-resource-type)

(clojure.core/defn- deser-string-date-time [input] input)

(clojure.core/defn- deser-parameter-history [input] (clojure.core/cond-> {} (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-parameter-type (input "Type"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "KeyId") (clojure.core/assoc :key-id (deser-parameter-key-id (input "KeyId"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-ps-parameter-value (input "Value"))) (clojure.core/contains? input "AllowedPattern") (clojure.core/assoc :allowed-pattern (deser-allowed-pattern (input "AllowedPattern"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-parameter-description (input "Description"))) (clojure.core/contains? input "Labels") (clojure.core/assoc :labels (deser-parameter-label-list (input "Labels"))) (clojure.core/contains? input "LastModifiedUser") (clojure.core/assoc :last-modified-user (deser-string (input "LastModifiedUser"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-ps-parameter-version (input "Version"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-ps-parameter-name (input "Name")))))

(clojure.core/defn- deser-inventory-result-entity [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-inventory-result-entity-id (input "Id"))) (clojure.core/contains? input "Data") (clojure.core/assoc :data (deser-inventory-result-item-map (input "Data")))))

(clojure.core/defn- deser-target-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-target-map-key k) (deser-target-map-value-list v)])) input))

(clojure.core/defn- deser-command-plugin-output [input] input)

(clojure.core/defn- deser-non-compliant-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "NonCompliantCount") (clojure.core/assoc :non-compliant-count (deser-compliance-summary-count (input "NonCompliantCount"))) (clojure.core/contains? input "SeveritySummary") (clojure.core/assoc :severity-summary (deser-severity-summary (input "SeveritySummary")))))

(clojure.core/defn- deser-association-resource-id [input] input)

(clojure.core/defn- deser-patch-compliance-data-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-compliance-data coll))) input))

(clojure.core/defn- deser-instance-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-id coll))) input))

(clojure.core/defn- deser-automation-parameter-key [input] input)

(clojure.core/defn- deser-approve-after-days [input] input)

(clojure.core/defn- deser-maintenance-window-run-command-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (input "ServiceRoleArn"))) (clojure.core/contains? input "Comment") (clojure.core/assoc :comment (deser-comment (input "Comment"))) (clojure.core/contains? input "TimeoutSeconds") (clojure.core/assoc :timeout-seconds (deser-timeout-seconds (input "TimeoutSeconds"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "NotificationConfig") (clojure.core/assoc :notification-config (deser-notification-config (input "NotificationConfig"))) (clojure.core/contains? input "DocumentHash") (clojure.core/assoc :document-hash (deser-document-hash (input "DocumentHash"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix"))) (clojure.core/contains? input "DocumentHashType") (clojure.core/assoc :document-hash-type (deser-document-hash-type (input "DocumentHashType")))))

(clojure.core/defn- deser-association-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-version-info coll))) input))

(clojure.core/defn- deser-attachment-information [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-attachment-name (input "Name")))))

(clojure.core/defn- deser-output-source-id [input] input)

(clojure.core/defn- deser-parameter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-value coll))) input))

(clojure.core/defn- deser-document-content [input] input)

(clojure.core/defn- deser-automation-type [input] (clojure.core/get {"CrossAccount" :cross-account, "Local" :local} input))

(clojure.core/defn- deser-association-version [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-execution-id [input] input)

(clojure.core/defn- deser-maintenance-window-task [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (input "ServiceRoleArn"))) (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-maintenance-window-task-type (input "Type"))) (clojure.core/contains? input "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (input "Priority"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "LoggingInfo") (clojure.core/assoc :logging-info (deser-logging-info (input "LoggingInfo"))) (clojure.core/contains? input "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (input "TaskArn"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-maintenance-window-description (input "Description"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (input "WindowTaskId"))) (clojure.core/contains? input "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters (input "TaskParameters"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name")))))

(clojure.core/defn- deser-target-maps [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-map coll))) input))

(clojure.core/defn- deser-command-invocation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-command-invocation coll))) input))

(clojure.core/defn- deser-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association coll))) input))

(clojure.core/defn- deser-patch-severity [input] input)

(clojure.core/defn- deser-automation-execution-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-automation-execution-metadata coll))) input))

(clojure.core/defn- deser-document-version-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-name (input "Name"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (input "VersionName"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (input "CreatedDate"))) (clojure.core/contains? input "IsDefaultVersion") (clojure.core/assoc :is-default-version (deser-boolean (input "IsDefaultVersion"))) (clojure.core/contains? input "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (input "DocumentFormat"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-document-status (input "Status"))) (clojure.core/contains? input "StatusInformation") (clojure.core/assoc :status-information (deser-document-status-information (input "StatusInformation")))))

(clojure.core/defn- deser-service-role [input] input)

(clojure.core/defn- deser-maintenance-window-enabled [input] input)

(clojure.core/defn- deser-maintenance-window-name [input] input)

(clojure.core/defn- deser-association-description-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-description coll))) input))

(clojure.core/defn- deser-command-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Success" :success, "Cancelled" :cancelled, "Failed" :failed, "TimedOut" :timed-out, "Cancelling" :cancelling} input))

(clojure.core/defn- deser-instance-id [input] input)

(clojure.core/defn- deser-document-status-information [input] input)

(clojure.core/defn- deser-inventory-type-display-name [input] input)

(clojure.core/defn- deser-patch-group [input] input)

(clojure.core/defn- deser-automation-action-name [input] input)

(clojure.core/defn- deser-patch-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-group coll))) input))

(clojure.core/defn- deser-patch-filter [input] (clojure.core/cond-> {:key (deser-patch-filter-key (input "Key")), :values (deser-patch-filter-value-list (input "Values"))}))

(clojure.core/defn- deser-notification-event [input] (clojure.core/get {"All" :all, "InProgress" :in-progress, "Success" :success, "TimedOut" :timed-out, "Cancelled" :cancelled, "Failed" :failed} input))

(clojure.core/defn- deser-association-executions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-execution coll))) input))

(clojure.core/defn- deser-document-version-name [input] input)

(clojure.core/defn- deser-instance-association-status-infos [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-association-status-info coll))) input))

(clojure.core/defn- deser-parameter-name [input] input)

(clojure.core/defn- deser-patch-baseline-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-baseline-identity coll))) input))

(clojure.core/defn- deser-parameter-type [input] (clojure.core/get {"String" :string, "StringList" :string-list, "SecureString" :secure-string} input))

(clojure.core/defn- deser-s-3-region [input] input)

(clojure.core/defn- deser-patch-classification [input] input)

(clojure.core/defn- deser-comment [input] input)

(clojure.core/defn- deser-command-invocation-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Delayed" :delayed, "Success" :success, "Cancelled" :cancelled, "TimedOut" :timed-out, "Failed" :failed, "Cancelling" :cancelling} input))

(clojure.core/defn- deser-last-resource-data-sync-message [input] input)

(clojure.core/defn- deser-compliance-resource-type [input] input)

(clojure.core/defn- deser-patch-source [input] (clojure.core/cond-> {:name (deser-patch-source-name (input "Name")), :products (deser-patch-source-product-list (input "Products")), :configuration (deser-patch-source-configuration (input "Configuration"))}))

(clojure.core/defn- deser-document-identifier [input] (clojure.core/cond-> {} (clojure.core/contains? input "SchemaVersion") (clojure.core/assoc :schema-version (deser-document-schema-version (input "SchemaVersion"))) (clojure.core/contains? input "DocumentType") (clojure.core/assoc :document-type (deser-document-type (input "DocumentType"))) (clojure.core/contains? input "TargetType") (clojure.core/assoc :target-type (deser-target-type (input "TargetType"))) (clojure.core/contains? input "Tags") (clojure.core/assoc :tags (deser-tag-list (input "Tags"))) (clojure.core/contains? input "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (input "DocumentFormat"))) (clojure.core/contains? input "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (input "VersionName"))) (clojure.core/contains? input "PlatformTypes") (clojure.core/assoc :platform-types (deser-platform-type-list (input "PlatformTypes"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-document-owner (input "Owner"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name")))))

(clojure.core/defn- deser-association-resource-type [input] input)

(clojure.core/defn- deser-parameter-label-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-label coll))) input))

(clojure.core/defn- deser-session-id [input] input)

(clojure.core/defn- deser-progress-counters [input] (clojure.core/cond-> {} (clojure.core/contains? input "TotalSteps") (clojure.core/assoc :total-steps (deser-integer (input "TotalSteps"))) (clojure.core/contains? input "SuccessSteps") (clojure.core/assoc :success-steps (deser-integer (input "SuccessSteps"))) (clojure.core/contains? input "FailedSteps") (clojure.core/assoc :failed-steps (deser-integer (input "FailedSteps"))) (clojure.core/contains? input "CancelledSteps") (clojure.core/assoc :cancelled-steps (deser-integer (input "CancelledSteps"))) (clojure.core/contains? input "TimedOutSteps") (clojure.core/assoc :timed-out-steps (deser-integer (input "TimedOutSteps")))))

(clojure.core/defn- deser-ps-parameter-version [input] input)

(clojure.core/defn- deser-account-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-id coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution-task-identity coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-id [input] input)

(clojure.core/defn- deser-maintenance-window-cutoff [input] input)

(clojure.core/defn- deser-timeout-seconds [input] input)

(clojure.core/defn- deser-resource-data-sync-s-3-region [input] input)

(clojure.core/defn- deser-delivery-timed-out-count [input] input)

(clojure.core/defn- deser-compliance-summary-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-compliance-summary-item coll))) input))

(clojure.core/defn- deser-attribute-name [input] input)

(clojure.core/defn- deser-step-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "TimeoutSeconds") (clojure.core/assoc :timeout-seconds (deser-long (input "TimeoutSeconds"))) (clojure.core/contains? input "ResponseCode") (clojure.core/assoc :response-code (deser-string (input "ResponseCode"))) (clojure.core/contains? input "StepExecutionId") (clojure.core/assoc :step-execution-id (deser-string (input "StepExecutionId"))) (clojure.core/contains? input "ValidNextSteps") (clojure.core/assoc :valid-next-steps (deser-valid-next-step-list (input "ValidNextSteps"))) (clojure.core/contains? input "Outputs") (clojure.core/assoc :outputs (deser-automation-parameter-map (input "Outputs"))) (clojure.core/contains? input "Response") (clojure.core/assoc :response (deser-string (input "Response"))) (clojure.core/contains? input "FailureMessage") (clojure.core/assoc :failure-message (deser-string (input "FailureMessage"))) (clojure.core/contains? input "Inputs") (clojure.core/assoc :inputs (deser-normal-string-map (input "Inputs"))) (clojure.core/contains? input "NextStep") (clojure.core/assoc :next-step (deser-string (input "NextStep"))) (clojure.core/contains? input "FailureDetails") (clojure.core/assoc :failure-details (deser-failure-details (input "FailureDetails"))) (clojure.core/contains? input "StepStatus") (clojure.core/assoc :step-status (deser-automation-execution-status (input "StepStatus"))) (clojure.core/contains? input "TargetLocation") (clojure.core/assoc :target-location (deser-target-location (input "TargetLocation"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "IsCritical") (clojure.core/assoc :is-critical (deser-boolean (input "IsCritical"))) (clojure.core/contains? input "StepName") (clojure.core/assoc :step-name (deser-string (input "StepName"))) (clojure.core/contains? input "OverriddenParameters") (clojure.core/assoc :overridden-parameters (deser-automation-parameter-map (input "OverriddenParameters"))) (clojure.core/contains? input "OnFailure") (clojure.core/assoc :on-failure (deser-string (input "OnFailure"))) (clojure.core/contains? input "ExecutionEndTime") (clojure.core/assoc :execution-end-time (deser-date-time (input "ExecutionEndTime"))) (clojure.core/contains? input "ExecutionStartTime") (clojure.core/assoc :execution-start-time (deser-date-time (input "ExecutionStartTime"))) (clojure.core/contains? input "Action") (clojure.core/assoc :action (deser-automation-action-name (input "Action"))) (clojure.core/contains? input "IsEnd") (clojure.core/assoc :is-end (deser-boolean (input "IsEnd"))) (clojure.core/contains? input "MaxAttempts") (clojure.core/assoc :max-attempts (deser-integer (input "MaxAttempts")))))

(clojure.core/defn- deser-product [input] input)

(clojure.core/defn- deser-patch-installed-count [input] input)

(clojure.core/defn- deser-status-additional-info [input] input)

(clojure.core/defn- deser-completed-count [input] input)

(clojure.core/defn- deser-resource-data-sync-awskms-key-arn [input] input)

(clojure.core/defn- deser-instance-count [input] input)

(clojure.core/defn- deser-put-inventory-message [input] input)

(clojure.core/defn- deser-last-resource-data-sync-status [input] (clojure.core/get {"Successful" :successful, "Failed" :failed, "InProgress" :in-progress} input))

(clojure.core/defn- deser-error-count [input] input)

(clojure.core/defn- deser-status-message [input] input)

(clojure.core/defn- deser-patch-rule [input] (clojure.core/cond-> {:patch-filter-group (deser-patch-filter-group (input "PatchFilterGroup")), :approve-after-days (deser-approve-after-days (input "ApproveAfterDays"))} (clojure.core/contains? input "ComplianceLevel") (clojure.core/assoc :compliance-level (deser-patch-compliance-level (input "ComplianceLevel"))) (clojure.core/contains? input "EnableNonSecurity") (clojure.core/assoc :enable-non-security (deser-boolean (input "EnableNonSecurity")))))

(clojure.core/defn- deser-execution-mode [input] (clojure.core/get {"Auto" :auto, "Interactive" :interactive} input))

(clojure.core/defn- deser-inventory-item-content-hash [input] input)

(clojure.core/defn- deser-maintenance-window-execution-status [input] (clojure.core/get {"PENDING" :pending, "IN_PROGRESS" :in-progress, "SUCCESS" :success, "FAILED" :failed, "TIMED_OUT" :timed-out, "CANCELLING" :cancelling, "CANCELLED" :cancelled, "SKIPPED_OVERLAPPING" :skipped-overlapping} input))

(clojure.core/defn- deser-output-source [input] (clojure.core/cond-> {} (clojure.core/contains? input "OutputSourceId") (clojure.core/assoc :output-source-id (deser-output-source-id (input "OutputSourceId"))) (clojure.core/contains? input "OutputSourceType") (clojure.core/assoc :output-source-type (deser-output-source-type (input "OutputSourceType")))))

(clojure.core/defn- deser-inventory-item-entry [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-name k) (deser-attribute-value v)])) input))

(clojure.core/defn- deser-parameter-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-ps-parameter-name (input "Name"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-parameter-type (input "Type"))) (clojure.core/contains? input "KeyId") (clojure.core/assoc :key-id (deser-parameter-key-id (input "KeyId"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "LastModifiedUser") (clojure.core/assoc :last-modified-user (deser-string (input "LastModifiedUser"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-parameter-description (input "Description"))) (clojure.core/contains? input "AllowedPattern") (clojure.core/assoc :allowed-pattern (deser-allowed-pattern (input "AllowedPattern"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-ps-parameter-version (input "Version")))))

(clojure.core/defn- deser-association-execution-targets-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-association-execution-target coll))) input))

(clojure.core/defn- deser-command-plugin [input] (clojure.core/cond-> {} (clojure.core/contains? input "ResponseFinishDateTime") (clojure.core/assoc :response-finish-date-time (deser-date-time (input "ResponseFinishDateTime"))) (clojure.core/contains? input "ResponseCode") (clojure.core/assoc :response-code (deser-response-code (input "ResponseCode"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-command-plugin-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (input "StatusDetails"))) (clojure.core/contains? input "StandardOutputUrl") (clojure.core/assoc :standard-output-url (deser-url (input "StandardOutputUrl"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix"))) (clojure.core/contains? input "OutputS3Region") (clojure.core/assoc :output-s-3-region (deser-s-3-region (input "OutputS3Region"))) (clojure.core/contains? input "Output") (clojure.core/assoc :output (deser-command-plugin-output (input "Output"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-command-plugin-name (input "Name"))) (clojure.core/contains? input "StandardErrorUrl") (clojure.core/assoc :standard-error-url (deser-url (input "StandardErrorUrl"))) (clojure.core/contains? input "ResponseStartDateTime") (clojure.core/assoc :response-start-date-time (deser-date-time (input "ResponseStartDateTime")))))

(clojure.core/defn- deser-cloud-watch-log-group-name [input] input)

(clojure.core/defn- deser-parameters [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-parameter-name k) (deser-parameter-value-list v)])) input))

(clojure.core/defn- deser-response-code [input] input)

(clojure.core/defn- deser-association-execution-id [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution-task-invocation-identity coll))) input))

(clojure.core/defn- deser-instance-association-output-url [input] (clojure.core/cond-> {} (clojure.core/contains? input "S3OutputUrl") (clojure.core/assoc :s-3-output-url (deser-s-3-output-url (input "S3OutputUrl")))))

(clojure.core/defn- deser-resource-data-sync-s-3-format [input] (clojure.core/get {"JsonSerDe" :json-ser-de} input))

(clojure.core/defn- deser-document-type [input] (clojure.core/get {"Command" :command, "Policy" :policy, "Automation" :automation, "Session" :session, "Package" :package} input))

(clojure.core/defn- deser-association-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-association-execution-id (input "ExecutionId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "CreatedTime") (clojure.core/assoc :created-time (deser-date-time (input "CreatedTime"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "ResourceCountByStatus") (clojure.core/assoc :resource-count-by-status (deser-resource-count-by-status (input "ResourceCountByStatus")))))

(clojure.core/defn- deser-document-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-parameter-name (input "Name"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-document-parameter-type (input "Type"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-document-parameter-descrption (input "Description"))) (clojure.core/contains? input "DefaultValue") (clojure.core/assoc :default-value (deser-document-parameter-default-value (input "DefaultValue")))))

(clojure.core/defn- deser-association-id [input] input)

(clojure.core/defn- deser-severity-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "CriticalCount") (clojure.core/assoc :critical-count (deser-compliance-summary-count (input "CriticalCount"))) (clojure.core/contains? input "HighCount") (clojure.core/assoc :high-count (deser-compliance-summary-count (input "HighCount"))) (clojure.core/contains? input "MediumCount") (clojure.core/assoc :medium-count (deser-compliance-summary-count (input "MediumCount"))) (clojure.core/contains? input "LowCount") (clojure.core/assoc :low-count (deser-compliance-summary-count (input "LowCount"))) (clojure.core/contains? input "InformationalCount") (clojure.core/assoc :informational-count (deser-compliance-summary-count (input "InformationalCount"))) (clojure.core/contains? input "UnspecifiedCount") (clojure.core/assoc :unspecified-count (deser-compliance-summary-count (input "UnspecifiedCount")))))

(clojure.core/defn- deser-maintenance-window-identity-for-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name")))))

(clojure.core/defn- deser-patch-deployment-status [input] (clojure.core/get {"APPROVED" :approved, "PENDING_APPROVAL" :pending-approval, "EXPLICIT_APPROVED" :explicit-approved, "EXPLICIT_REJECTED" :explicit-rejected} input))

(clojure.core/defn- deser-automation-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "TargetMaps") (clojure.core/assoc :target-maps (deser-target-maps (input "TargetMaps"))) (clojure.core/contains? input "ProgressCounters") (clojure.core/assoc :progress-counters (deser-progress-counters (input "ProgressCounters"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-automation-parameter-map (input "Parameters"))) (clojure.core/contains? input "ParentAutomationExecutionId") (clojure.core/assoc :parent-automation-execution-id (deser-automation-execution-id (input "ParentAutomationExecutionId"))) (clojure.core/contains? input "CurrentStepName") (clojure.core/assoc :current-step-name (deser-string (input "CurrentStepName"))) (clojure.core/contains? input "ExecutedBy") (clojure.core/assoc :executed-by (deser-string (input "ExecutedBy"))) (clojure.core/contains? input "CurrentAction") (clojure.core/assoc :current-action (deser-string (input "CurrentAction"))) (clojure.core/contains? input "TargetLocations") (clojure.core/assoc :target-locations (deser-target-locations (input "TargetLocations"))) (clojure.core/contains? input "Mode") (clojure.core/assoc :mode (deser-execution-mode (input "Mode"))) (clojure.core/contains? input "Outputs") (clojure.core/assoc :outputs (deser-automation-parameter-map (input "Outputs"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "ResolvedTargets") (clojure.core/assoc :resolved-targets (deser-resolved-targets (input "ResolvedTargets"))) (clojure.core/contains? input "FailureMessage") (clojure.core/assoc :failure-message (deser-string (input "FailureMessage"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "StepExecutions") (clojure.core/assoc :step-executions (deser-step-execution-list (input "StepExecutions"))) (clojure.core/contains? input "AutomationExecutionStatus") (clojure.core/assoc :automation-execution-status (deser-automation-execution-status (input "AutomationExecutionStatus"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Target") (clojure.core/assoc :target (deser-string (input "Target"))) (clojure.core/contains? input "TargetParameterName") (clojure.core/assoc :target-parameter-name (deser-automation-parameter-key (input "TargetParameterName"))) (clojure.core/contains? input "ExecutionEndTime") (clojure.core/assoc :execution-end-time (deser-date-time (input "ExecutionEndTime"))) (clojure.core/contains? input "ExecutionStartTime") (clojure.core/assoc :execution-start-time (deser-date-time (input "ExecutionStartTime"))) (clojure.core/contains? input "AutomationExecutionId") (clojure.core/assoc :automation-execution-id (deser-automation-execution-id (input "AutomationExecutionId"))) (clojure.core/contains? input "StepExecutionsTruncated") (clojure.core/assoc :step-executions-truncated (deser-boolean (input "StepExecutionsTruncated")))))

(clojure.core/defn- deser-patch-content-url [input] input)

(clojure.core/defn- deser-compliance-item-title [input] input)

(clojure.core/defn- deser-tag-key [input] input)

(clojure.core/defn- deser-instance-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-association coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution coll))) input))

(clojure.core/defn- deser-platform-type [input] (clojure.core/get {"Windows" :windows, "Linux" :linux} input))

(clojure.core/defn- deser-parameter-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ps-parameter-name coll))) input))

(clojure.core/defn- deser-instance-aggregated-association-overview [input] (clojure.core/cond-> {} (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "InstanceAssociationStatusAggregatedCount") (clojure.core/assoc :instance-association-status-aggregated-count (deser-instance-association-status-aggregated-count (input "InstanceAssociationStatusAggregatedCount")))))

(clojure.core/defn- deser-target-type [input] input)

(clojure.core/defn- deser-resource-data-sync-s-3-prefix [input] input)

(clojure.core/defn- deser-notification-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "NotificationArn") (clojure.core/assoc :notification-arn (deser-notification-arn (input "NotificationArn"))) (clojure.core/contains? input "NotificationEvents") (clojure.core/assoc :notification-events (deser-notification-event-list (input "NotificationEvents"))) (clojure.core/contains? input "NotificationType") (clojure.core/assoc :notification-type (deser-notification-type (input "NotificationType")))))

(clojure.core/defn- deser-automation-execution-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "AutomationType") (clojure.core/assoc :automation-type (deser-automation-type (input "AutomationType"))) (clojure.core/contains? input "TargetMaps") (clojure.core/assoc :target-maps (deser-target-maps (input "TargetMaps"))) (clojure.core/contains? input "LogFile") (clojure.core/assoc :log-file (deser-string (input "LogFile"))) (clojure.core/contains? input "ParentAutomationExecutionId") (clojure.core/assoc :parent-automation-execution-id (deser-automation-execution-id (input "ParentAutomationExecutionId"))) (clojure.core/contains? input "CurrentStepName") (clojure.core/assoc :current-step-name (deser-string (input "CurrentStepName"))) (clojure.core/contains? input "ExecutedBy") (clojure.core/assoc :executed-by (deser-string (input "ExecutedBy"))) (clojure.core/contains? input "CurrentAction") (clojure.core/assoc :current-action (deser-string (input "CurrentAction"))) (clojure.core/contains? input "Mode") (clojure.core/assoc :mode (deser-execution-mode (input "Mode"))) (clojure.core/contains? input "Outputs") (clojure.core/assoc :outputs (deser-automation-parameter-map (input "Outputs"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "ResolvedTargets") (clojure.core/assoc :resolved-targets (deser-resolved-targets (input "ResolvedTargets"))) (clojure.core/contains? input "FailureMessage") (clojure.core/assoc :failure-message (deser-string (input "FailureMessage"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "AutomationExecutionStatus") (clojure.core/assoc :automation-execution-status (deser-automation-execution-status (input "AutomationExecutionStatus"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Target") (clojure.core/assoc :target (deser-string (input "Target"))) (clojure.core/contains? input "TargetParameterName") (clojure.core/assoc :target-parameter-name (deser-automation-parameter-key (input "TargetParameterName"))) (clojure.core/contains? input "ExecutionEndTime") (clojure.core/assoc :execution-end-time (deser-date-time (input "ExecutionEndTime"))) (clojure.core/contains? input "ExecutionStartTime") (clojure.core/assoc :execution-start-time (deser-date-time (input "ExecutionStartTime"))) (clojure.core/contains? input "AutomationExecutionId") (clojure.core/assoc :automation-execution-id (deser-automation-execution-id (input "AutomationExecutionId")))))

(clojure.core/defn- deser-s-3-bucket-name [input] input)

(clojure.core/defn- deser-ping-status [input] (clojure.core/get {"Online" :online, "ConnectionLost" :connection-lost, "Inactive" :inactive} input))

(clojure.core/defn- deser-inventory-deletion-summary-items [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-deletion-summary-item coll))) input))

(clojure.core/defn- deser-compliance-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-compliance-item coll))) input))

(clojure.core/defn- deser-document-hash [input] input)

(clojure.core/defn- deser-inventory-result-entity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-result-entity coll))) input))

(clojure.core/defn- deser-inventory-item-schema [input] (clojure.core/cond-> {:type-name (deser-inventory-item-type-name (input "TypeName")), :attributes (deser-inventory-item-attribute-list (input "Attributes"))} (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-inventory-item-schema-version (input "Version"))) (clojure.core/contains? input "DisplayName") (clojure.core/assoc :display-name (deser-inventory-type-display-name (input "DisplayName")))))

(clojure.core/defn- deser-iam-role [input] input)

(clojure.core/defn- deser-compliance-severity [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low, "INFORMATIONAL" :informational, "UNSPECIFIED" :unspecified} input))

(clojure.core/defn- deser-notification-type [input] (clojure.core/get {"Command" :command, "Invocation" :invocation} input))

(clojure.core/defn- deser-inventory-deletion-status-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "DeletionId") (clojure.core/assoc :deletion-id (deser-inventory-deletion-id (input "DeletionId"))) (clojure.core/contains? input "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (input "TypeName"))) (clojure.core/contains? input "DeletionStartTime") (clojure.core/assoc :deletion-start-time (deser-inventory-deletion-start-time (input "DeletionStartTime"))) (clojure.core/contains? input "LastStatus") (clojure.core/assoc :last-status (deser-inventory-deletion-status (input "LastStatus"))) (clojure.core/contains? input "LastStatusMessage") (clojure.core/assoc :last-status-message (deser-inventory-deletion-last-status-message (input "LastStatusMessage"))) (clojure.core/contains? input "DeletionSummary") (clojure.core/assoc :deletion-summary (deser-inventory-deletion-summary (input "DeletionSummary"))) (clojure.core/contains? input "LastStatusUpdateTime") (clojure.core/assoc :last-status-update-time (deser-inventory-deletion-last-status-update-time (input "LastStatusUpdateTime")))))

(clojure.core/defn- deser-maintenance-window-lambda-payload [input] (portkey.aws/base64-decode input))

(clojure.core/defn- deser-maintenance-window-task-arn [input] input)

(clojure.core/defn- deser-maintenance-window-lambda-qualifier [input] input)

(clojure.core/defn- deser-patch-compliance-data [input] (clojure.core/cond-> {:title (deser-patch-title (input "Title")), :kb-id (deser-patch-kb-number (input "KBId")), :classification (deser-patch-classification (input "Classification")), :severity (deser-patch-severity (input "Severity")), :state (deser-patch-compliance-data-state (input "State")), :installed-time (deser-date-time (input "InstalledTime"))}))

(clojure.core/defn- deser-target-map-key [input] input)

(clojure.core/defn- deser-inventory-deletions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-deletion-status-item coll))) input))

(clojure.core/defn- deser-patch-msrc-number [input] input)

(clojure.core/defn- deser-patch-missing-count [input] input)

(clojure.core/defn- deser-scheduled-window-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name"))) (clojure.core/contains? input "ExecutionTime") (clojure.core/assoc :execution-time (deser-maintenance-window-string-date-time (input "ExecutionTime")))))

(clojure.core/defn- deser-association-status [input] (clojure.core/cond-> {:date (deser-date-time (input "Date")), :name (deser-association-status-name (input "Name")), :message (deser-status-message (input "Message"))} (clojure.core/contains? input "AdditionalInfo") (clojure.core/assoc :additional-info (deser-status-additional-info (input "AdditionalInfo")))))

(clojure.core/defn- deser-document-parameter-name [input] input)

(clojure.core/defn- deser-attachment-hash [input] input)

(clojure.core/defn- deser-document-parameter-descrption [input] input)

(clojure.core/defn- deser-snapshot-download-url [input] input)

(clojure.core/defn- deser-inventory-item-attribute-name [input] input)

(clojure.core/defn- deser-target-locations [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-location coll))) input))

(clojure.core/defn- deser-patch-installed-rejected-count [input] input)

(clojure.core/defn- deser-status-details [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameters [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-maintenance-window-task-parameter-name k) (deser-maintenance-window-task-parameter-value-expression v)])) input))

(clojure.core/defn- deser-patch-baseline-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (input "BaselineId"))) (clojure.core/contains? input "BaselineName") (clojure.core/assoc :baseline-name (deser-baseline-name (input "BaselineName"))) (clojure.core/contains? input "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (input "OperatingSystem"))) (clojure.core/contains? input "BaselineDescription") (clojure.core/assoc :baseline-description (deser-baseline-description (input "BaselineDescription"))) (clojure.core/contains? input "DefaultBaseline") (clojure.core/assoc :default-baseline (deser-default-baseline (input "DefaultBaseline")))))

(clojure.core/defn- deser-next-token [input] input)

(clojure.core/defn- deser-standard-output-content [input] input)

(clojure.core/defn- deser-resource-data-sync-s-3-destination [input] (clojure.core/cond-> {:bucket-name (deser-resource-data-sync-s-3-bucket-name (input "BucketName")), :sync-format (deser-resource-data-sync-s-3-format (input "SyncFormat")), :region (deser-resource-data-sync-s-3-region (input "Region"))} (clojure.core/contains? input "Prefix") (clojure.core/assoc :prefix (deser-resource-data-sync-s-3-prefix (input "Prefix"))) (clojure.core/contains? input "AWSKMSKeyARN") (clojure.core/assoc :awskms-key-arn (deser-resource-data-sync-awskms-key-arn (input "AWSKMSKeyARN")))))

(clojure.core/defn- deser-agent-error-code [input] input)

(clojure.core/defn- deser-document-owner [input] input)

(clojure.core/defn- deser-cloud-watch-output-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "CloudWatchLogGroupName") (clojure.core/assoc :cloud-watch-log-group-name (deser-cloud-watch-log-group-name (input "CloudWatchLogGroupName"))) (clojure.core/contains? input "CloudWatchOutputEnabled") (clojure.core/assoc :cloud-watch-output-enabled (deser-cloud-watch-output-enabled (input "CloudWatchOutputEnabled")))))

(clojure.core/defn- deser-document-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-parameter coll))) input))

(clojure.core/defn- deser-document-sha-1 [input] input)

(clojure.core/defn- deser-connection-status [input] (clojure.core/get {"Connected" :connected, "NotConnected" :not-connected} input))

(clojure.core/defn- deser-document-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-version-info coll))) input))

(clojure.core/defn- deser-parameter-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-metadata coll))) input))

(clojure.core/defn- deser-default-instance-name [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameter-name [input] input)

(clojure.core/defn- deser-session-target [input] input)

(clojure.core/defn- deser-session-owner [input] input)

(clojure.core/defn- deser-expiration-date [input] input)

(clojure.core/defn- deser-maintenance-window-task-priority [input] input)

(clojure.core/defn- deser-session-status [input] (clojure.core/get {"Connected" :connected, "Connecting" :connecting, "Disconnected" :disconnected, "Terminated" :terminated, "Terminating" :terminating, "Failed" :failed} input))

(clojure.core/defn- deser-document-arn [input] input)

(clojure.core/defn- deser-inventory-result-entity-id [input] input)

(clojure.core/defn- deser-patch-id [input] input)

(clojure.core/defn- deser-effective-patch [input] (clojure.core/cond-> {} (clojure.core/contains? input "Patch") (clojure.core/assoc :patch (deser-patch (input "Patch"))) (clojure.core/contains? input "PatchStatus") (clojure.core/assoc :patch-status (deser-patch-status (input "PatchStatus")))))

(clojure.core/defn- deser-max-concurrency [input] input)

(clojure.core/defn- deser-maintenance-window-task-id [input] input)

(clojure.core/defn- deser-resolved-targets [input] (clojure.core/cond-> {} (clojure.core/contains? input "ParameterValues") (clojure.core/assoc :parameter-values (deser-target-parameter-list (input "ParameterValues"))) (clojure.core/contains? input "Truncated") (clojure.core/assoc :truncated (deser-boolean (input "Truncated")))))

(clojure.core/defn- deser-instance-patch-states-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-patch-state coll))) input))

(clojure.core/defn- deser-inventory-deletion-start-time [input] input)

(clojure.core/defn- deser-patch-action [input] (clojure.core/get {"ALLOW_AS_DEPENDENCY" :allow-as-dependency, "BLOCK" :block} input))

(clojure.core/defn- deser-command-invocation [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRole") (clojure.core/assoc :service-role (deser-service-role (input "ServiceRole"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "Comment") (clojure.core/assoc :comment (deser-comment (input "Comment"))) (clojure.core/contains? input "NotificationConfig") (clojure.core/assoc :notification-config (deser-notification-config (input "NotificationConfig"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-command-invocation-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (input "StatusDetails"))) (clojure.core/contains? input "CloudWatchOutputConfig") (clojure.core/assoc :cloud-watch-output-config (deser-cloud-watch-output-config (input "CloudWatchOutputConfig"))) (clojure.core/contains? input "CommandPlugins") (clojure.core/assoc :command-plugins (deser-command-plugin-list (input "CommandPlugins"))) (clojure.core/contains? input "InstanceName") (clojure.core/assoc :instance-name (deser-instance-tag-name (input "InstanceName"))) (clojure.core/contains? input "RequestedDateTime") (clojure.core/assoc :requested-date-time (deser-date-time (input "RequestedDateTime"))) (clojure.core/contains? input "StandardOutputUrl") (clojure.core/assoc :standard-output-url (deser-url (input "StandardOutputUrl"))) (clojure.core/contains? input "TraceOutput") (clojure.core/assoc :trace-output (deser-invocation-trace-output (input "TraceOutput"))) (clojure.core/contains? input "CommandId") (clojure.core/assoc :command-id (deser-command-id (input "CommandId"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "StandardErrorUrl") (clojure.core/assoc :standard-error-url (deser-url (input "StandardErrorUrl")))))

(clojure.core/defn- deser-compliant-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "CompliantCount") (clojure.core/assoc :compliant-count (deser-compliance-summary-count (input "CompliantCount"))) (clojure.core/contains? input "SeveritySummary") (clojure.core/assoc :severity-summary (deser-severity-summary (input "SeveritySummary")))))

(clojure.core/defn- deser-regions [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-region coll))) input))

(clojure.core/defn- deser-session-details [input] input)

(clojure.core/defn- deser-compliance-item-id [input] input)

(clojure.core/defn- deser-resource-data-sync-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "SyncName") (clojure.core/assoc :sync-name (deser-resource-data-sync-name (input "SyncName"))) (clojure.core/contains? input "S3Destination") (clojure.core/assoc :s-3-destination (deser-resource-data-sync-s-3-destination (input "S3Destination"))) (clojure.core/contains? input "LastSyncTime") (clojure.core/assoc :last-sync-time (deser-last-resource-data-sync-time (input "LastSyncTime"))) (clojure.core/contains? input "LastSuccessfulSyncTime") (clojure.core/assoc :last-successful-sync-time (deser-last-successful-resource-data-sync-time (input "LastSuccessfulSyncTime"))) (clojure.core/contains? input "LastStatus") (clojure.core/assoc :last-status (deser-last-resource-data-sync-status (input "LastStatus"))) (clojure.core/contains? input "SyncCreatedTime") (clojure.core/assoc :sync-created-time (deser-resource-data-sync-created-time (input "SyncCreatedTime"))) (clojure.core/contains? input "LastSyncStatusMessage") (clojure.core/assoc :last-sync-status-message (deser-last-resource-data-sync-message (input "LastSyncStatusMessage")))))

(clojure.core/defn- deser-cloud-watch-output-enabled [input] input)

(clojure.core/defn- deser-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter coll))) input))

(clojure.core/defn- deser-parameter-label [input] input)

(clojure.core/defn- deser-association-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "LastUpdateAssociationDate") (clojure.core/assoc :last-update-association-date (deser-date-time (input "LastUpdateAssociationDate"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "ComplianceSeverity") (clojure.core/assoc :compliance-severity (deser-association-compliance-severity (input "ComplianceSeverity"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-association-status (input "Status"))) (clojure.core/contains? input "Overview") (clojure.core/assoc :overview (deser-association-overview (input "Overview"))) (clojure.core/contains? input "Date") (clojure.core/assoc :date (deser-date-time (input "Date"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "AutomationTargetParameterName") (clojure.core/assoc :automation-target-parameter-name (deser-automation-target-parameter-name (input "AutomationTargetParameterName"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "LastSuccessfulExecutionDate") (clojure.core/assoc :last-successful-execution-date (deser-date-time (input "LastSuccessfulExecutionDate"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name"))) (clojure.core/contains? input "OutputLocation") (clojure.core/assoc :output-location (deser-instance-association-output-location (input "OutputLocation")))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-document-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "SchemaVersion") (clojure.core/assoc :schema-version (deser-document-schema-version (input "SchemaVersion"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-document-parameter-list (input "Parameters"))) (clojure.core/contains? input "DocumentType") (clojure.core/assoc :document-type (deser-document-type (input "DocumentType"))) (clojure.core/contains? input "TargetType") (clojure.core/assoc :target-type (deser-target-type (input "TargetType"))) (clojure.core/contains? input "Tags") (clojure.core/assoc :tags (deser-tag-list (input "Tags"))) (clojure.core/contains? input "Hash") (clojure.core/assoc :hash (deser-document-hash (input "Hash"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-document-status (input "Status"))) (clojure.core/contains? input "StatusInformation") (clojure.core/assoc :status-information (deser-document-status-information (input "StatusInformation"))) (clojure.core/contains? input "AttachmentsInformation") (clojure.core/assoc :attachments-information (deser-attachment-information-list (input "AttachmentsInformation"))) (clojure.core/contains? input "DefaultVersion") (clojure.core/assoc :default-version (deser-document-version (input "DefaultVersion"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-description-in-document (input "Description"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (input "CreatedDate"))) (clojure.core/contains? input "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (input "DocumentFormat"))) (clojure.core/contains? input "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (input "VersionName"))) (clojure.core/contains? input "PlatformTypes") (clojure.core/assoc :platform-types (deser-platform-type-list (input "PlatformTypes"))) (clojure.core/contains? input "LatestVersion") (clojure.core/assoc :latest-version (deser-document-version (input "LatestVersion"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-document-owner (input "Owner"))) (clojure.core/contains? input "HashType") (clojure.core/assoc :hash-type (deser-document-hash-type (input "HashType"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name"))) (clojure.core/contains? input "Sha1") (clojure.core/assoc :sha-1 (deser-document-sha-1 (input "Sha1")))))

(clojure.core/defn- deser-maintenance-window-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (input "WindowTargetId"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-maintenance-window-resource-type (input "ResourceType"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (input "OwnerInformation"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-maintenance-window-description (input "Description")))))

(clojure.core/defn- deser-inventory-deletion-last-status-update-time [input] input)

(clojure.core/defn- deser-compliance-type-name [input] input)

(clojure.core/defn- deser-patch-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-id coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-parameters [input] input)

(clojure.core/defn- deser-logging-info [input] (clojure.core/cond-> {:s-3-bucket-name (deser-s-3-bucket-name (input "S3BucketName")), :s-3-region (deser-s-3-region (input "S3Region"))} (clojure.core/contains? input "S3KeyPrefix") (clojure.core/assoc :s-3-key-prefix (deser-s-3-key-prefix (input "S3KeyPrefix")))))

(clojure.core/defn- deser-ps-parameter-value [input] input)

(clojure.core/defn- deser-attachment-content [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-attachment-name (input "Name"))) (clojure.core/contains? input "Size") (clojure.core/assoc :size (deser-content-length (input "Size"))) (clojure.core/contains? input "Hash") (clojure.core/assoc :hash (deser-attachment-hash (input "Hash"))) (clojure.core/contains? input "HashType") (clojure.core/assoc :hash-type (deser-attachment-hash-type (input "HashType"))) (clojure.core/contains? input "Url") (clojure.core/assoc :url (deser-attachment-url (input "Url")))))

(clojure.core/defn- deser-patch-filter-group [input] (clojure.core/cond-> {:patch-filters (deser-patch-filter-list (input "PatchFilters"))}))

(clojure.core/defn- deser-instance-information [input] (clojure.core/cond-> {} (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "PlatformName") (clojure.core/assoc :platform-name (deser-string (input "PlatformName"))) (clojure.core/contains? input "PlatformType") (clojure.core/assoc :platform-type (deser-platform-type (input "PlatformType"))) (clojure.core/contains? input "PingStatus") (clojure.core/assoc :ping-status (deser-ping-status (input "PingStatus"))) (clojure.core/contains? input "IamRole") (clojure.core/assoc :iam-role (deser-iam-role (input "IamRole"))) (clojure.core/contains? input "AgentVersion") (clojure.core/assoc :agent-version (deser-version (input "AgentVersion"))) (clojure.core/contains? input "AssociationStatus") (clojure.core/assoc :association-status (deser-status-name (input "AssociationStatus"))) (clojure.core/contains? input "LastSuccessfulAssociationExecutionDate") (clojure.core/assoc :last-successful-association-execution-date (deser-date-time (input "LastSuccessfulAssociationExecutionDate"))) (clojure.core/contains? input "LastPingDateTime") (clojure.core/assoc :last-ping-date-time (deser-date-time (input "LastPingDateTime"))) (clojure.core/contains? input "AssociationOverview") (clojure.core/assoc :association-overview (deser-instance-aggregated-association-overview (input "AssociationOverview"))) (clojure.core/contains? input "IsLatestVersion") (clojure.core/assoc :is-latest-version (deser-boolean (input "IsLatestVersion"))) (clojure.core/contains? input "IPAddress") (clojure.core/assoc :ip-address (deser-ip-address (input "IPAddress"))) (clojure.core/contains? input "PlatformVersion") (clojure.core/assoc :platform-version (deser-string (input "PlatformVersion"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "ResourceType"))) (clojure.core/contains? input "ActivationId") (clojure.core/assoc :activation-id (deser-activation-id (input "ActivationId"))) (clojure.core/contains? input "LastAssociationExecutionDate") (clojure.core/assoc :last-association-execution-date (deser-date-time (input "LastAssociationExecutionDate"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-string (input "Name"))) (clojure.core/contains? input "RegistrationDate") (clojure.core/assoc :registration-date (deser-date-time (input "RegistrationDate"))) (clojure.core/contains? input "ComputerName") (clojure.core/assoc :computer-name (deser-computer-name (input "ComputerName")))))

(clojure.core/defn- deser-maintenance-window-task-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-task coll))) input))

(clojure.core/defn- deser-status-name [input] input)

(clojure.core/defn- deser-inventory-result-item [input] (clojure.core/cond-> {:type-name (deser-inventory-item-type-name (input "TypeName")), :schema-version (deser-inventory-item-schema-version (input "SchemaVersion")), :content (deser-inventory-item-entry-list (input "Content"))} (clojure.core/contains? input "CaptureTime") (clojure.core/assoc :capture-time (deser-inventory-item-capture-time (input "CaptureTime"))) (clojure.core/contains? input "ContentHash") (clojure.core/assoc :content-hash (deser-inventory-item-content-hash (input "ContentHash")))))

(clojure.core/defn- deser-command-plugin-name [input] input)

(clojure.core/defn- deser-content-length [input] input)

(clojure.core/defn- deser-attribute-value [input] input)

(clojure.core/defn- deser-session-manager-output-url [input] (clojure.core/cond-> {} (clojure.core/contains? input "S3OutputUrl") (clojure.core/assoc :s-3-output-url (deser-session-manager-s-3-output-url (input "S3OutputUrl"))) (clojure.core/contains? input "CloudWatchOutputUrl") (clojure.core/assoc :cloud-watch-output-url (deser-session-manager-cloud-watch-output-url (input "CloudWatchOutputUrl")))))

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-id [input] input)

(clojure.core/defn- deser-inventory-deletion-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "TotalCount") (clojure.core/assoc :total-count (deser-total-count (input "TotalCount"))) (clojure.core/contains? input "RemainingCount") (clojure.core/assoc :remaining-count (deser-remaining-count (input "RemainingCount"))) (clojure.core/contains? input "SummaryItems") (clojure.core/assoc :summary-items (deser-inventory-deletion-summary-items (input "SummaryItems")))))

(clojure.core/defn- deser-parameter-key-id [input] input)

(clojure.core/defn- deser-automation-parameter-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-automation-parameter-key k) (deser-automation-parameter-value-list v)])) input))

(clojure.core/defn- deser-association-overview [input] (clojure.core/cond-> {} (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "AssociationStatusAggregatedCount") (clojure.core/assoc :association-status-aggregated-count (deser-association-status-aggregated-count (input "AssociationStatusAggregatedCount")))))

(clojure.core/defn- deser-resource-compliance-summary-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "ComplianceType") (clojure.core/assoc :compliance-type (deser-compliance-type-name (input "ComplianceType"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-compliance-resource-type (input "ResourceType"))) (clojure.core/contains? input "ResourceId") (clojure.core/assoc :resource-id (deser-compliance-resource-id (input "ResourceId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-compliance-status (input "Status"))) (clojure.core/contains? input "OverallSeverity") (clojure.core/assoc :overall-severity (deser-compliance-severity (input "OverallSeverity"))) (clojure.core/contains? input "ExecutionSummary") (clojure.core/assoc :execution-summary (deser-compliance-execution-summary (input "ExecutionSummary"))) (clojure.core/contains? input "CompliantSummary") (clojure.core/assoc :compliant-summary (deser-compliant-summary (input "CompliantSummary"))) (clojure.core/contains? input "NonCompliantSummary") (clojure.core/assoc :non-compliant-summary (deser-non-compliant-summary (input "NonCompliantSummary")))))

(clojure.core/defn- deser-patch-rule-group [input] (clojure.core/cond-> {:patch-rules (deser-patch-rule-list (input "PatchRules"))}))

(clojure.core/defn- deser-maintenance-window-target-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-target coll))) input))

(clojure.core/defn- deser-command-plugin-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-command-plugin coll))) input))

(clojure.core/defn- deser-accounts [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account coll))) input))

(clojure.core/defn- deser-parameter-history-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-history coll))) input))

(clojure.core/defn- deser-service-setting-value [input] input)

(clojure.core/defn- deser-registrations-count [input] input)

(clojure.core/defn- deser-max-errors [input] input)

(clojure.core/defn- deser-inventory-item-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-item-attribute coll))) input))

(clojure.core/defn- deser-inventory-item-schema-version [input] input)

(clojure.core/defn- deser-compliance-status [input] (clojure.core/get {"COMPLIANT" :compliant, "NON_COMPLIANT" :non-compliant} input))

(clojure.core/defn- deser-inventory-deletion-status [input] (clojure.core/get {"InProgress" :in-progress, "Complete" :complete} input))

(clojure.core/defn- deser-account [input] input)

(clojure.core/defn- deser-compliance-execution-summary [input] (clojure.core/cond-> {:execution-time (deser-date-time (input "ExecutionTime"))} (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-compliance-execution-id (input "ExecutionId"))) (clojure.core/contains? input "ExecutionType") (clojure.core/assoc :execution-type (deser-compliance-execution-type (input "ExecutionType")))))

(clojure.core/defn- deser-url [input] input)

(clojure.core/defn- deser-invocation-trace-output [input] input)

(clojure.core/defn- deser-stream-url [input] input)

(clojure.core/defn- deser-allowed-pattern [input] input)

(clojure.core/defn- deser-tag-value [input] input)

(clojure.core/defn- deser-valid-next-step [input] input)

(clojure.core/defn- deser-patch-msrc-severity [input] input)

(clojure.core/defn- deser-document-default-version-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-name (input "Name"))) (clojure.core/contains? input "DefaultVersion") (clojure.core/assoc :default-version (deser-document-version (input "DefaultVersion"))) (clojure.core/contains? input "DefaultVersionName") (clojure.core/assoc :default-version-name (deser-document-version-name (input "DefaultVersionName")))))

(clojure.core/defn- deser-default-baseline [input] input)

(clojure.core/defn- deser-instance-tag-name [input] input)

(clojure.core/defn- deser-total-count [input] input)

(clojure.core/defn- deser-batch-error-message [input] input)

(clojure.core/defn- deser-patch-source-product-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-source-product coll))) input))

(clojure.core/defn- deser-baseline-id [input] input)

(clojure.core/defn- deser-patch-not-applicable-count [input] input)

(clojure.core/defn- deser-maintenance-window-target-id [input] input)

(clojure.core/defn- deser-failure-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "FailureStage") (clojure.core/assoc :failure-stage (deser-string (input "FailureStage"))) (clojure.core/contains? input "FailureType") (clojure.core/assoc :failure-type (deser-string (input "FailureType"))) (clojure.core/contains? input "Details") (clojure.core/assoc :details (deser-automation-parameter-map (input "Details")))))

(clojure.core/defn- deser-patch-product [input] input)

(clojure.core/defn- deser-ip-address [input] input)

(clojure.core/defn- deser-maintenance-window-id [input] input)

(clojure.core/defn- deser-created-date [input] input)

(clojure.core/defn- deser-patch-status [input] (clojure.core/cond-> {} (clojure.core/contains? input "DeploymentStatus") (clojure.core/assoc :deployment-status (deser-patch-deployment-status (input "DeploymentStatus"))) (clojure.core/contains? input "ComplianceLevel") (clojure.core/assoc :compliance-level (deser-patch-compliance-level (input "ComplianceLevel"))) (clojure.core/contains? input "ApprovalDate") (clojure.core/assoc :approval-date (deser-date-time (input "ApprovalDate")))))

(clojure.core/defn- deser-normal-string-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-automation-target-parameter-name [input] input)

(clojure.core/defn- deser-patch-vendor [input] input)

(clojure.core/defn- deser-compliance-execution-id [input] input)

(clojure.core/defn- deser-maintenance-window-description [input] input)

(clojure.core/defn- deser-association-name [input] input)

(clojure.core/defn- deser-maintenance-window-lambda-client-context [input] input)

(clojure.core/defn- deser-maintenance-window-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (input "WindowExecutionId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (input "StatusDetails"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-date-time (input "StartTime"))) (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-date-time (input "EndTime")))))

(clojure.core/defn- deser-integer [input] input)

(clojure.core/defn- deser-last-successful-resource-data-sync-time [input] input)

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-ps-parameter-name (input "Name"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-parameter-type (input "Type"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-ps-parameter-value (input "Value"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-ps-parameter-version (input "Version"))) (clojure.core/contains? input "Selector") (clojure.core/assoc :selector (deser-ps-parameter-selector (input "Selector"))) (clojure.core/contains? input "SourceResult") (clojure.core/assoc :source-result (deser-string (input "SourceResult"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "ARN") (clojure.core/assoc :arn (deser-string (input "ARN")))))

(clojure.core/defn- deser-parameter-description [input] input)

(clojure.core/defn- deser-patch-installed-other-count [input] input)

(clojure.core/defn- deser-account-id [input] input)

(clojure.core/defn- deser-inventory-item-schema-result-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-item-schema coll))) input))

(clojure.core/defn- deser-resource-compliance-summary-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource-compliance-summary-item coll))) input))

(clojure.core/defn- deser-maintenance-window-task-target-id [input] input)

(clojure.core/defn- deser-create-association-batch-request-entry [input] (clojure.core/cond-> {:name (deser-document-arn (input "Name"))} (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "ComplianceSeverity") (clojure.core/assoc :compliance-severity (deser-association-compliance-severity (input "ComplianceSeverity"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "AutomationTargetParameterName") (clojure.core/assoc :automation-target-parameter-name (deser-automation-target-parameter-name (input "AutomationTargetParameterName"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "OutputLocation") (clojure.core/assoc :output-location (deser-instance-association-output-location (input "OutputLocation")))))

(clojure.core/defn- deser-patch-description [input] input)

(clojure.core/defn- deser-patch-filter-key [input] (clojure.core/get {"PRODUCT" :product, "CLASSIFICATION" :classification, "MSRC_SEVERITY" :msrc-severity, "PATCH_ID" :patch-id, "SECTION" :section, "PRIORITY" :priority, "SEVERITY" :severity} input))

(clojure.core/defn- deser-attachment-name [input] input)

(clojure.core/defn- deser-patch-failed-count [input] input)

(clojure.core/defn- deser-maintenance-window-lambda-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "ClientContext") (clojure.core/assoc :client-context (deser-maintenance-window-lambda-client-context (input "ClientContext"))) (clojure.core/contains? input "Qualifier") (clojure.core/assoc :qualifier (deser-maintenance-window-lambda-qualifier (input "Qualifier"))) (clojure.core/contains? input "Payload") (clojure.core/assoc :payload (deser-maintenance-window-lambda-payload (input "Payload")))))

(clojure.core/defn- deser-automation-execution-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Waiting" :waiting, "Success" :success, "TimedOut" :timed-out, "Cancelling" :cancelling, "Cancelled" :cancelled, "Failed" :failed} input))

(clojure.core/defn- deser-document-schema-version [input] input)

(clojure.core/defn- deser-attachment-information-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attachment-information coll))) input))

(clojure.core/defn- deser-patch-source-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-source coll))) input))

(clojure.core/defn- deser-target-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "Accounts") (clojure.core/assoc :accounts (deser-accounts (input "Accounts"))) (clojure.core/contains? input "Regions") (clojure.core/assoc :regions (deser-regions (input "Regions"))) (clojure.core/contains? input "TargetLocationMaxConcurrency") (clojure.core/assoc :target-location-max-concurrency (deser-max-concurrency (input "TargetLocationMaxConcurrency"))) (clojure.core/contains? input "TargetLocationMaxErrors") (clojure.core/assoc :target-location-max-errors (deser-max-errors (input "TargetLocationMaxErrors"))) (clojure.core/contains? input "ExecutionRoleName") (clojure.core/assoc :execution-role-name (deser-execution-role-name (input "ExecutionRoleName")))))

(clojure.core/defn- deser-notification-arn [input] input)

(clojure.core/defn- deser-resource-data-sync-created-time [input] input)

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"ManagedInstance" :managed-instance, "Document" :document, "EC2Instance" :ec-2-instance} input))

(clojure.core/defn- deser-maintenance-window-step-functions-input [input] input)

(clojure.core/defn- deser-activation-id [input] input)

(clojure.core/defn- deser-document-parameter-default-value [input] input)

(clojure.core/defn- deser-document-format [input] (clojure.core/get {"YAML" :yaml, "JSON" :json} input))

(clojure.core/defn- deser-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target coll))) input))

(clojure.core/defn- deser-patch-compliance-level [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low, "INFORMATIONAL" :informational, "UNSPECIFIED" :unspecified} input))

(clojure.core/defn- deser-patch-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch coll))) input))

(clojure.core/defn- deser-patch-source-configuration [input] input)

(clojure.core/defn- deser-target-map-value [input] input)

(clojure.core/defn- deser-document-status [input] (clojure.core/get {"Creating" :creating, "Active" :active, "Updating" :updating, "Deleting" :deleting, "Failed" :failed} input))

(clojure.core/defn- deser-description-in-document [input] input)

(clojure.core/defn- deser-command [input] (clojure.core/cond-> {} (clojure.core/contains? input "ServiceRole") (clojure.core/assoc :service-role (deser-service-role (input "ServiceRole"))) (clojure.core/contains? input "InstanceIds") (clojure.core/assoc :instance-ids (deser-instance-id-list (input "InstanceIds"))) (clojure.core/contains? input "Comment") (clojure.core/assoc :comment (deser-comment (input "Comment"))) (clojure.core/contains? input "DeliveryTimedOutCount") (clojure.core/assoc :delivery-timed-out-count (deser-delivery-timed-out-count (input "DeliveryTimedOutCount"))) (clojure.core/contains? input "CompletedCount") (clojure.core/assoc :completed-count (deser-completed-count (input "CompletedCount"))) (clojure.core/contains? input "ErrorCount") (clojure.core/assoc :error-count (deser-error-count (input "ErrorCount"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "NotificationConfig") (clojure.core/assoc :notification-config (deser-notification-config (input "NotificationConfig"))) (clojure.core/contains? input "ExpiresAfter") (clojure.core/assoc :expires-after (deser-date-time (input "ExpiresAfter"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-command-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (input "StatusDetails"))) (clojure.core/contains? input "CloudWatchOutputConfig") (clojure.core/assoc :cloud-watch-output-config (deser-cloud-watch-output-config (input "CloudWatchOutputConfig"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "RequestedDateTime") (clojure.core/assoc :requested-date-time (deser-date-time (input "RequestedDateTime"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "CommandId") (clojure.core/assoc :command-id (deser-command-id (input "CommandId"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix"))) (clojure.core/contains? input "OutputS3Region") (clojure.core/assoc :output-s-3-region (deser-s-3-region (input "OutputS3Region"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "TargetCount") (clojure.core/assoc :target-count (deser-target-count (input "TargetCount")))))

(clojure.core/defn- deser-target-parameter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter-value coll))) input))

(clojure.core/defn- deser-instances-count [input] input)

(clojure.core/defn- deser-patch-group-patch-baseline-mapping-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-group-patch-baseline-mapping coll))) input))

(clojure.core/defn- deser-resource-count [input] input)

(clojure.core/defn- deser-execution-role-name [input] input)

(clojure.core/defn- deser-baseline-name [input] input)

(clojure.core/defn- deser-session-manager-s-3-output-url [input] input)

(clojure.core/defn- deser-attachment-hash-type [input] (clojure.core/get {"Sha256" :sha-256} input))

(clojure.core/defn- deser-attachment-url [input] input)

(clojure.core/defn- deser-activation [input] (clojure.core/cond-> {} (clojure.core/contains? input "Tags") (clojure.core/assoc :tags (deser-tag-list (input "Tags"))) (clojure.core/contains? input "IamRole") (clojure.core/assoc :iam-role (deser-iam-role (input "IamRole"))) (clojure.core/contains? input "DefaultInstanceName") (clojure.core/assoc :default-instance-name (deser-default-instance-name (input "DefaultInstanceName"))) (clojure.core/contains? input "ExpirationDate") (clojure.core/assoc :expiration-date (deser-expiration-date (input "ExpirationDate"))) (clojure.core/contains? input "Expired") (clojure.core/assoc :expired (deser-boolean (input "Expired"))) (clojure.core/contains? input "RegistrationsCount") (clojure.core/assoc :registrations-count (deser-registrations-count (input "RegistrationsCount"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-activation-description (input "Description"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-created-date (input "CreatedDate"))) (clojure.core/contains? input "ActivationId") (clojure.core/assoc :activation-id (deser-activation-id (input "ActivationId"))) (clojure.core/contains? input "RegistrationLimit") (clojure.core/assoc :registration-limit (deser-registration-limit (input "RegistrationLimit")))))

(clojure.core/defn- deser-maintenance-window-step-functions-name [input] input)

(clojure.core/defn- deser-compliance-resource-id [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-invocation-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (input "TaskExecutionId"))) (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-date-time (input "EndTime"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-date-time (input "StartTime"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-maintenance-window-execution-task-invocation-parameters (input "Parameters"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (input "StatusDetails"))) (clojure.core/contains? input "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (input "WindowExecutionId"))) (clojure.core/contains? input "InvocationId") (clojure.core/assoc :invocation-id (deser-maintenance-window-execution-task-invocation-id (input "InvocationId"))) (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-maintenance-window-execution-task-execution-id (input "ExecutionId"))) (clojure.core/contains? input "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-task-target-id (input "WindowTargetId"))) (clojure.core/contains? input "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (input "TaskType"))) (clojure.core/contains? input "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (input "OwnerInformation")))))

(clojure.core/defn- deser-resource-data-sync-s-3-bucket-name [input] input)

(clojure.core/defn- deser-maintenance-window-duration-hours [input] input)

(clojure.core/defn- deser-platform-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-platform-type coll))) input))

(clojure.core/defn- deser-s-3-key-prefix [input] input)

(clojure.core/defn- deser-session-manager-cloud-watch-output-url [input] input)

(clojure.core/defn- deser-compliance-execution-type [input] input)

(clojure.core/defn- deser-effective-patch-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-effective-patch coll))) input))

(clojure.core/defn- deser-schedule-expression [input] input)

(clojure.core/defn- deser-failed-create-association [input] (clojure.core/cond-> {} (clojure.core/contains? input "Entry") (clojure.core/assoc :entry (deser-create-association-batch-request-entry (input "Entry"))) (clojure.core/contains? input "Message") (clojure.core/assoc :message (deser-batch-error-message (input "Message"))) (clojure.core/contains? input "Fault") (clojure.core/assoc :fault (deser-fault (input "Fault")))))

(clojure.core/defn- deser-resource-data-sync-item-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource-data-sync-item coll))) input))

(clojure.core/defn- deser-command-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-command coll))) input))

(clojure.core/defn- deser-command-id [input] input)

(clojure.core/defn- deser-association-version-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-parameters (input "Parameters"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "ComplianceSeverity") (clojure.core/assoc :compliance-severity (deser-association-compliance-severity (input "ComplianceSeverity"))) (clojure.core/contains? input "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (input "MaxConcurrency"))) (clojure.core/contains? input "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (input "MaxErrors"))) (clojure.core/contains? input "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (input "CreatedDate"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name"))) (clojure.core/contains? input "OutputLocation") (clojure.core/assoc :output-location (deser-instance-association-output-location (input "OutputLocation")))))

(clojure.core/defn- deser-instance-association [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "Content") (clojure.core/assoc :content (deser-document-content (input "Content"))) (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion")))))

(clojure.core/defn- deser-long [input] input)

(clojure.core/defn- deser-s-3-output-url [input] (clojure.core/cond-> {} (clojure.core/contains? input "OutputUrl") (clojure.core/assoc :output-url (deser-url (input "OutputUrl")))))

(clojure.core/defn- deser-install-override-list [input] input)

(clojure.core/defn- deser-activation-code [input] input)

(clojure.core/defn- deser-patch-source-name [input] input)

(clojure.core/defn- deser-inventory-item-entry-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-inventory-item-entry coll))) input))

(clojure.core/defn- deser-instance-association-status-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "ExecutionDate") (clojure.core/assoc :execution-date (deser-date-time (input "ExecutionDate"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "OutputUrl") (clojure.core/assoc :output-url (deser-instance-association-output-url (input "OutputUrl"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "ErrorCode") (clojure.core/assoc :error-code (deser-agent-error-code (input "ErrorCode"))) (clojure.core/contains? input "ExecutionSummary") (clojure.core/assoc :execution-summary (deser-instance-association-execution-summary (input "ExecutionSummary"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name")))))

(clojure.core/defn- deser-association-status-name [input] (clojure.core/get {"Pending" :pending, "Success" :success, "Failed" :failed} input))

(clojure.core/defn- deser-inventory-result-item-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-inventory-result-item-key k) (deser-inventory-result-item v)])) input))

(clojure.core/defn- deser-remaining-count [input] input)

(clojure.core/defn- deser-resource-data-sync-name [input] input)

(clojure.core/defn- deser-patch-rule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-rule coll))) input))

(clojure.core/defn- deser-owner-information [input] input)

(clojure.core/defn- deser-session-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-session coll))) input))

(clojure.core/defn- deser-maintenance-window-string-date-time [input] input)

(clojure.core/defn- deser-service-setting-id [input] input)

(clojure.core/defn- deser-s-3-output-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "OutputS3Region") (clojure.core/assoc :output-s-3-region (deser-s-3-region (input "OutputS3Region"))) (clojure.core/contains? input "OutputS3BucketName") (clojure.core/assoc :output-s-3-bucket-name (deser-s-3-bucket-name (input "OutputS3BucketName"))) (clojure.core/contains? input "OutputS3KeyPrefix") (clojure.core/assoc :output-s-3-key-prefix (deser-s-3-key-prefix (input "OutputS3KeyPrefix")))))

(clojure.core/defn- deser-fault [input] (clojure.core/get {"Client" :client, "Server" :server, "Unknown" :unknown} input))

(clojure.core/defn- deser-maintenance-window-identity-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-identity coll))) input))

(clojure.core/defn- deser-automation-parameter-value [input] input)

(clojure.core/defn- deser-patch-filter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-filter-value coll))) input))

(clojure.core/defn- deser-tag [input] (clojure.core/cond-> {:key (deser-tag-key (input "Key")), :value (deser-tag-value (input "Value"))}))

(clojure.core/defn- deser-maintenance-window-schedule [input] input)

(clojure.core/defn- deser-version [input] input)

(clojure.core/defn- deser-inventory-item-type-name [input] input)

(clojure.core/defn- deser-patch-compliance-data-state [input] (clojure.core/get {"INSTALLED" :installed, "INSTALLED_OTHER" :installed-other, "INSTALLED_REJECTED" :installed-rejected, "MISSING" :missing, "NOT_APPLICABLE" :not-applicable, "FAILED" :failed} input))

(clojure.core/defn- deser-maintenance-window-task-invocation-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "RunCommand") (clojure.core/assoc :run-command (deser-maintenance-window-run-command-parameters (input "RunCommand"))) (clojure.core/contains? input "Automation") (clojure.core/assoc :automation (deser-maintenance-window-automation-parameters (input "Automation"))) (clojure.core/contains? input "StepFunctions") (clojure.core/assoc :step-functions (deser-maintenance-window-step-functions-parameters (input "StepFunctions"))) (clojure.core/contains? input "Lambda") (clojure.core/assoc :lambda (deser-maintenance-window-lambda-parameters (input "Lambda")))))

(clojure.core/defn- deser-document-name [input] input)

(clojure.core/defn- deser-ps-parameter-selector [input] input)

(clojure.core/defn- deser-maintenance-window-step-functions-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "Input") (clojure.core/assoc :input (deser-maintenance-window-step-functions-input (input "Input"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-step-functions-name (input "Name")))))

(clojure.core/defn- deser-inventory-result-item-key [input] input)

(clojure.core/defn- deser-maintenance-windows-for-target-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-identity-for-target coll))) input))

(clojure.core/defn- deser-patch-filter-value [input] input)

(clojure.core/defn- deser-maintenance-window-task-type [input] (clojure.core/get {"RUN_COMMAND" :run-command, "AUTOMATION" :automation, "STEP_FUNCTIONS" :step-functions, "LAMBDA" :lambda} input))

(clojure.core/defn- deser-output-source-type [input] input)

(clojure.core/defn- deser-maintenance-window-allow-unassociated-targets [input] input)

(clojure.core/defn- deser-maintenance-window-execution-status-details [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameters-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-task-parameters coll))) input))

(clojure.core/defn- deser-document-version [input] input)

(clojure.core/defn- deser-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "Key") (clojure.core/assoc :key (deser-target-key (input "Key"))) (clojure.core/contains? input "Values") (clojure.core/assoc :values (deser-target-values (input "Values")))))

(clojure.core/defn- deser-scheduled-window-execution-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-window-execution coll))) input))

(clojure.core/defn- deser-document-hash-type [input] (clojure.core/get {"Sha256" :sha-256, "Sha1" :sha-1} input))

(clojure.core/defn- deser-valid-next-step-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-valid-next-step coll))) input))

(clojure.core/defn- deser-maintenance-window-execution-task-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-execution-task-id coll))) input))

(clojure.core/defn- deser-association-execution-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "OutputSource") (clojure.core/assoc :output-source (deser-output-source (input "OutputSource"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-status-name (input "Status"))) (clojure.core/contains? input "ResourceId") (clojure.core/assoc :resource-id (deser-association-resource-id (input "ResourceId"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "ExecutionId") (clojure.core/assoc :execution-id (deser-association-execution-id (input "ExecutionId"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-association-resource-type (input "ResourceType"))) (clojure.core/contains? input "DetailedStatus") (clojure.core/assoc :detailed-status (deser-status-name (input "DetailedStatus")))))

(clojure.core/defn- deser-instance-association-execution-summary [input] input)

(clojure.core/defn- deser-instance-patch-state [input] (clojure.core/cond-> {:instance-id (deser-instance-id (input "InstanceId")), :patch-group (deser-patch-group (input "PatchGroup")), :baseline-id (deser-baseline-id (input "BaselineId")), :operation-start-time (deser-date-time (input "OperationStartTime")), :operation-end-time (deser-date-time (input "OperationEndTime")), :operation (deser-patch-operation-type (input "Operation"))} (clojure.core/contains? input "FailedCount") (clojure.core/assoc :failed-count (deser-patch-failed-count (input "FailedCount"))) (clojure.core/contains? input "InstalledOtherCount") (clojure.core/assoc :installed-other-count (deser-patch-installed-other-count (input "InstalledOtherCount"))) (clojure.core/contains? input "NotApplicableCount") (clojure.core/assoc :not-applicable-count (deser-patch-not-applicable-count (input "NotApplicableCount"))) (clojure.core/contains? input "InstallOverrideList") (clojure.core/assoc :install-override-list (deser-install-override-list (input "InstallOverrideList"))) (clojure.core/contains? input "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (input "OwnerInformation"))) (clojure.core/contains? input "InstalledCount") (clojure.core/assoc :installed-count (deser-patch-installed-count (input "InstalledCount"))) (clojure.core/contains? input "InstalledRejectedCount") (clojure.core/assoc :installed-rejected-count (deser-patch-installed-rejected-count (input "InstalledRejectedCount"))) (clojure.core/contains? input "MissingCount") (clojure.core/assoc :missing-count (deser-patch-missing-count (input "MissingCount"))) (clojure.core/contains? input "SnapshotId") (clojure.core/assoc :snapshot-id (deser-snapshot-id (input "SnapshotId")))))

(clojure.core/defn- deser-association [input] (clojure.core/cond-> {} (clojure.core/contains? input "AssociationVersion") (clojure.core/assoc :association-version (deser-association-version (input "AssociationVersion"))) (clojure.core/contains? input "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (input "InstanceId"))) (clojure.core/contains? input "AssociationId") (clojure.core/assoc :association-id (deser-association-id (input "AssociationId"))) (clojure.core/contains? input "Overview") (clojure.core/assoc :overview (deser-association-overview (input "Overview"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (deser-date-time (input "LastExecutionDate"))) (clojure.core/contains? input "AssociationName") (clojure.core/assoc :association-name (deser-association-name (input "AssociationName"))) (clojure.core/contains? input "Targets") (clojure.core/assoc :targets (deser-targets (input "Targets"))) (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-schedule-expression (input "ScheduleExpression"))) (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-document-arn (input "Name")))))

(clojure.core/defn- deser-patch-product-family [input] input)

(clojure.core/defn- deser-document-parameter-type [input] (clojure.core/get {"String" :string, "StringList" :string-list} input))

(clojure.core/defn- deser-resource-count-by-status [input] input)

(clojure.core/defn- deser-service-setting [input] (clojure.core/cond-> {} (clojure.core/contains? input "SettingId") (clojure.core/assoc :setting-id (deser-service-setting-id (input "SettingId"))) (clojure.core/contains? input "SettingValue") (clojure.core/assoc :setting-value (deser-service-setting-value (input "SettingValue"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-time (input "LastModifiedDate"))) (clojure.core/contains? input "LastModifiedUser") (clojure.core/assoc :last-modified-user (deser-string (input "LastModifiedUser"))) (clojure.core/contains? input "ARN") (clojure.core/assoc :arn (deser-string (input "ARN"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-string (input "Status")))))

(clojure.core/defn- deser-compliance-summary-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "ComplianceType") (clojure.core/assoc :compliance-type (deser-compliance-type-name (input "ComplianceType"))) (clojure.core/contains? input "CompliantSummary") (clojure.core/assoc :compliant-summary (deser-compliant-summary (input "CompliantSummary"))) (clojure.core/contains? input "NonCompliantSummary") (clojure.core/assoc :non-compliant-summary (deser-non-compliant-summary (input "NonCompliantSummary")))))

(clojure.core/defn- deser-command-plugin-status [input] (clojure.core/get {"Pending" :pending, "InProgress" :in-progress, "Success" :success, "TimedOut" :timed-out, "Cancelled" :cancelled, "Failed" :failed} input))

(clojure.core/defn- deser-maintenance-window-timezone [input] input)

(clojure.core/defn- deser-patch-title [input] input)

(clojure.core/defn- deser-association-compliance-severity [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low, "UNSPECIFIED" :unspecified} input))

(clojure.core/defn- deser-session [input] (clojure.core/cond-> {} (clojure.core/contains? input "SessionId") (clojure.core/assoc :session-id (deser-session-id (input "SessionId"))) (clojure.core/contains? input "Details") (clojure.core/assoc :details (deser-session-details (input "Details"))) (clojure.core/contains? input "EndDate") (clojure.core/assoc :end-date (deser-date-time (input "EndDate"))) (clojure.core/contains? input "OutputUrl") (clojure.core/assoc :output-url (deser-session-manager-output-url (input "OutputUrl"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-session-status (input "Status"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-session-owner (input "Owner"))) (clojure.core/contains? input "DocumentName") (clojure.core/assoc :document-name (deser-document-name (input "DocumentName"))) (clojure.core/contains? input "Target") (clojure.core/assoc :target (deser-session-target (input "Target"))) (clojure.core/contains? input "StartDate") (clojure.core/assoc :start-date (deser-date-time (input "StartDate")))))

(clojure.core/defn- deser-activation-description [input] input)

(clojure.core/defn- deser-ps-parameter-name [input] input)

(clojure.core/defn- deser-activation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-activation coll))) input))

(clojure.core/defn- deser-instance-association-output-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "S3Location") (clojure.core/assoc :s-3-location (deser-s-3-output-location (input "S3Location")))))

(clojure.core/defn- deser-maintenance-window-automation-parameters [input] (clojure.core/cond-> {} (clojure.core/contains? input "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (input "DocumentVersion"))) (clojure.core/contains? input "Parameters") (clojure.core/assoc :parameters (deser-automation-parameter-map (input "Parameters")))))

(clojure.core/defn- deser-association-status-aggregated-count [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-status-name k) (deser-instance-count v)])) input))

(clojure.core/defn- deser-patch-language [input] input)

(clojure.core/defn- deser-attachment-content-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attachment-content coll))) input))

(clojure.core/defn- deser-inventory-item-capture-time [input] input)

(clojure.core/defn- deser-maintenance-window-execution-task-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (input "WindowExecutionId"))) (clojure.core/contains? input "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (input "TaskExecutionId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (input "Status"))) (clojure.core/contains? input "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (input "StatusDetails"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-date-time (input "StartTime"))) (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-date-time (input "EndTime"))) (clojure.core/contains? input "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (input "TaskArn"))) (clojure.core/contains? input "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (input "TaskType")))))

(clojure.core/defn- deser-failed-create-association-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-failed-create-association coll))) input))

(clojure.core/defn- deser-baseline-description [input] input)

(clojure.core/defn- deser-maintenance-window-execution-id [input] input)

(clojure.core/defn- deser-automation-execution-id [input] input)

(clojure.core/defn- deser-target-value [input] input)

(clojure.core/defn- deser-compliance-summary-count [input] input)

(clojure.core/defn- deser-patch-filter-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-patch-filter coll))) input))

(clojure.core/defn- deser-inventory-deletion-id [input] input)

(clojure.core/defn- deser-region [input] input)

(clojure.core/defn- deser-token-value [input] input)

(clojure.core/defn- deser-inventory-item-attribute [input] (clojure.core/cond-> {:name (deser-inventory-item-attribute-name (input "Name")), :data-type (deser-inventory-attribute-data-type (input "DataType"))}))

(clojure.core/defn- deser-patch-source-product [input] input)

(clojure.core/defn- deser-computer-name [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameter-value-expression [input] (clojure.core/cond-> {} (clojure.core/contains? input "Values") (clojure.core/assoc :values (deser-maintenance-window-task-parameter-value-list (input "Values")))))

(clojure.core/defn- deser-target-map-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-map-value coll))) input))

(clojure.core/defn- deser-target-key [input] input)

(clojure.core/defn- deser-inventory-deletion-summary-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-inventory-item-schema-version (input "Version"))) (clojure.core/contains? input "Count") (clojure.core/assoc :count (deser-resource-count (input "Count"))) (clojure.core/contains? input "RemainingCount") (clojure.core/assoc :remaining-count (deser-remaining-count (input "RemainingCount")))))

(clojure.core/defn- deser-automation-parameter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-automation-parameter-value coll))) input))

(clojure.core/defn- deser-compliance-item-details [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-name k) (deser-attribute-value v)])) input))

(clojure.core/defn- deser-maintenance-window-task-parameter-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-window-task-parameter-value coll))) input))

(clojure.core/defn- deser-last-resource-data-sync-time [input] input)

(clojure.core/defn- deser-patch [input] (clojure.core/cond-> {} (clojure.core/contains? input "KbNumber") (clojure.core/assoc :kb-number (deser-patch-kb-number (input "KbNumber"))) (clojure.core/contains? input "Product") (clojure.core/assoc :product (deser-patch-product (input "Product"))) (clojure.core/contains? input "MsrcNumber") (clojure.core/assoc :msrc-number (deser-patch-msrc-number (input "MsrcNumber"))) (clojure.core/contains? input "Title") (clojure.core/assoc :title (deser-patch-title (input "Title"))) (clojure.core/contains? input "MsrcSeverity") (clojure.core/assoc :msrc-severity (deser-patch-msrc-severity (input "MsrcSeverity"))) (clojure.core/contains? input "ProductFamily") (clojure.core/assoc :product-family (deser-patch-product-family (input "ProductFamily"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-patch-description (input "Description"))) (clojure.core/contains? input "ReleaseDate") (clojure.core/assoc :release-date (deser-date-time (input "ReleaseDate"))) (clojure.core/contains? input "Classification") (clojure.core/assoc :classification (deser-patch-classification (input "Classification"))) (clojure.core/contains? input "ContentUrl") (clojure.core/assoc :content-url (deser-patch-content-url (input "ContentUrl"))) (clojure.core/contains? input "Language") (clojure.core/assoc :language (deser-patch-language (input "Language"))) (clojure.core/contains? input "Vendor") (clojure.core/assoc :vendor (deser-patch-vendor (input "Vendor"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-patch-id (input "Id")))))

(clojure.core/defn- deser-patch-group-patch-baseline-mapping [input] (clojure.core/cond-> {} (clojure.core/contains? input "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (input "PatchGroup"))) (clojure.core/contains? input "BaselineIdentity") (clojure.core/assoc :baseline-identity (deser-patch-baseline-identity (input "BaselineIdentity")))))

(clojure.core/defn- deser-instance-information-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-information coll))) input))

(clojure.core/defn- deser-compliance-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "Severity") (clojure.core/assoc :severity (deser-compliance-severity (input "Severity"))) (clojure.core/contains? input "Details") (clojure.core/assoc :details (deser-compliance-item-details (input "Details"))) (clojure.core/contains? input "Title") (clojure.core/assoc :title (deser-compliance-item-title (input "Title"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-compliance-status (input "Status"))) (clojure.core/contains? input "ResourceId") (clojure.core/assoc :resource-id (deser-compliance-resource-id (input "ResourceId"))) (clojure.core/contains? input "ExecutionSummary") (clojure.core/assoc :execution-summary (deser-compliance-execution-summary (input "ExecutionSummary"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-compliance-resource-type (input "ResourceType"))) (clojure.core/contains? input "ComplianceType") (clojure.core/assoc :compliance-type (deser-compliance-type-name (input "ComplianceType"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-compliance-item-id (input "Id")))))

(clojure.core/defn- deser-operating-system [input] (clojure.core/get {"WINDOWS" :windows, "AMAZON_LINUX" :amazon-linux, "AMAZON_LINUX_2" :amazon-linux-2, "UBUNTU" :ubuntu, "REDHAT_ENTERPRISE_LINUX" :redhat-enterprise-linux, "SUSE" :suse, "CENTOS" :centos} input))

(clojure.core/defn- deser-document-identifier-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-identifier coll))) input))

(clojure.core/defn- deser-notification-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-notification-event coll))) input))

(clojure.core/defn- deser-step-execution-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-step-execution coll))) input))

(clojure.core/defn- deser-instance-association-status-aggregated-count [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-status-name k) (deser-instance-count v)])) input))

(clojure.core/defn- deser-maintenance-window-identity [input] (clojure.core/cond-> {} (clojure.core/contains? input "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (input "WindowId"))) (clojure.core/contains? input "EndDate") (clojure.core/assoc :end-date (deser-maintenance-window-string-date-time (input "EndDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-maintenance-window-enabled (input "Enabled"))) (clojure.core/contains? input "NextExecutionTime") (clojure.core/assoc :next-execution-time (deser-maintenance-window-string-date-time (input "NextExecutionTime"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-maintenance-window-description (input "Description"))) (clojure.core/contains? input "Duration") (clojure.core/assoc :duration (deser-maintenance-window-duration-hours (input "Duration"))) (clojure.core/contains? input "Cutoff") (clojure.core/assoc :cutoff (deser-maintenance-window-cutoff (input "Cutoff"))) (clojure.core/contains? input "Schedule") (clojure.core/assoc :schedule (deser-maintenance-window-schedule (input "Schedule"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-maintenance-window-name (input "Name"))) (clojure.core/contains? input "StartDate") (clojure.core/assoc :start-date (deser-maintenance-window-string-date-time (input "StartDate"))) (clojure.core/contains? input "ScheduleTimezone") (clojure.core/assoc :schedule-timezone (deser-maintenance-window-timezone (input "ScheduleTimezone")))))

(clojure.core/defn- deser-snapshot-id [input] input)

(clojure.core/defn- deser-registration-limit [input] input)

(clojure.core/defn- deser-parameter-value [input] input)

(clojure.core/defn- deser-standard-error-content [input] input)

(clojure.core/defn- deser-date-time [input] input)

(clojure.core/defn- deser-patch-operation-type [input] (clojure.core/get {"Scan" :scan, "Install" :install} input))

(clojure.core/defn- deser-target-values [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-value coll))) input))

(clojure.core/defn- deser-patch-kb-number [input] input)

(clojure.core/defn- deser-inventory-attribute-data-type [input] (clojure.core/get {"string" :string, "number" :number} input))

(clojure.core/defn- deser-instance-patch-state-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-instance-patch-state coll))) input))

(clojure.core/defn- deser-target-count [input] input)

(clojure.core/defn- deser-maintenance-window-task-parameter-value [input] input)

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- deser-inventory-deletion-last-status-message [input] input)

(clojure.core/defn- deser-maintenance-window-resource-type [input] (clojure.core/get {"INSTANCE" :instance} input))

(clojure.core/defn- response-invalid-delete-inventory-parameters-exception ([input] (response-invalid-delete-inventory-parameters-exception nil input)) ([resultWrapper2078172 input] (clojure.core/let [rawinput2078171 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078173 {"Message" (rawinput2078171 "Message")}] (clojure.core/cond-> {} (letvar2078173 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078173 ["Message"])))))))

(clojure.core/defn- response-list-tags-for-resource-result ([input] (response-list-tags-for-resource-result nil input)) ([resultWrapper2078175 input] (clojure.core/let [rawinput2078174 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078176 {"TagList" (rawinput2078174 "TagList")}] (clojure.core/cond-> {} (letvar2078176 "TagList") (clojure.core/assoc :tag-list (deser-tag-list (clojure.core/get-in letvar2078176 ["TagList"])))))))

(clojure.core/defn- response-invalid-automation-status-update-exception ([input] (response-invalid-automation-status-update-exception nil input)) ([resultWrapper2078178 input] (clojure.core/let [rawinput2078177 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078179 {"Message" (rawinput2078177 "Message")}] (clojure.core/cond-> {} (letvar2078179 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078179 ["Message"])))))))

(clojure.core/defn- response-automation-step-not-found-exception ([input] (response-automation-step-not-found-exception nil input)) ([resultWrapper2078181 input] (clojure.core/let [rawinput2078180 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078182 {"Message" (rawinput2078180 "Message")}] (clojure.core/cond-> {} (letvar2078182 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078182 ["Message"])))))))

(clojure.core/defn- response-stop-automation-execution-result ([input] (response-stop-automation-execution-result nil input)) ([resultWrapper2078184 input] (clojure.core/let [rawinput2078183 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078185 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-association-result ([input] (response-create-association-result nil input)) ([resultWrapper2078187 input] (clojure.core/let [rawinput2078186 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078188 {"AssociationDescription" (rawinput2078186 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2078188 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2078188 ["AssociationDescription"])))))))

(clojure.core/defn- response-compliance-type-count-limit-exceeded-exception ([input] (response-compliance-type-count-limit-exceeded-exception nil input)) ([resultWrapper2078190 input] (clojure.core/let [rawinput2078189 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078191 {"Message" (rawinput2078189 "Message")}] (clojure.core/cond-> {} (letvar2078191 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078191 ["Message"])))))))

(clojure.core/defn- response-describe-maintenance-windows-result ([input] (response-describe-maintenance-windows-result nil input)) ([resultWrapper2078193 input] (clojure.core/let [rawinput2078192 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078194 {"WindowIdentities" (rawinput2078192 "WindowIdentities"), "NextToken" (rawinput2078192 "NextToken")}] (clojure.core/cond-> {} (letvar2078194 "WindowIdentities") (clojure.core/assoc :window-identities (deser-maintenance-window-identity-list (clojure.core/get-in letvar2078194 ["WindowIdentities"]))) (letvar2078194 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078194 ["NextToken"])))))))

(clojure.core/defn- response-invalid-activation ([input] (response-invalid-activation nil input)) ([resultWrapper2078196 input] (clojure.core/let [rawinput2078195 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078197 {"Message" (rawinput2078195 "Message")}] (clojure.core/cond-> {} (letvar2078197 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078197 ["Message"])))))))

(clojure.core/defn- response-invalid-document-content ([input] (response-invalid-document-content nil input)) ([resultWrapper2078199 input] (clojure.core/let [rawinput2078198 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078200 {"Message" (rawinput2078198 "Message")}] (clojure.core/cond-> {} (letvar2078200 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078200 ["Message"])))))))

(clojure.core/defn- response-automation-definition-not-found-exception ([input] (response-automation-definition-not-found-exception nil input)) ([resultWrapper2078202 input] (clojure.core/let [rawinput2078201 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078203 {"Message" (rawinput2078201 "Message")}] (clojure.core/cond-> {} (letvar2078203 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078203 ["Message"])))))))

(clojure.core/defn- response-get-parameter-result ([input] (response-get-parameter-result nil input)) ([resultWrapper2078205 input] (clojure.core/let [rawinput2078204 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078206 {"Parameter" (rawinput2078204 "Parameter")}] (clojure.core/cond-> {} (letvar2078206 "Parameter") (clojure.core/assoc :parameter (deser-parameter (clojure.core/get-in letvar2078206 ["Parameter"])))))))

(clojure.core/defn- response-label-parameter-version-result ([input] (response-label-parameter-version-result nil input)) ([resultWrapper2078208 input] (clojure.core/let [rawinput2078207 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078209 {"InvalidLabels" (rawinput2078207 "InvalidLabels")}] (clojure.core/cond-> {} (letvar2078209 "InvalidLabels") (clojure.core/assoc :invalid-labels (deser-parameter-label-list (clojure.core/get-in letvar2078209 ["InvalidLabels"])))))))

(clojure.core/defn- response-describe-available-patches-result ([input] (response-describe-available-patches-result nil input)) ([resultWrapper2078211 input] (clojure.core/let [rawinput2078210 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078212 {"Patches" (rawinput2078210 "Patches"), "NextToken" (rawinput2078210 "NextToken")}] (clojure.core/cond-> {} (letvar2078212 "Patches") (clojure.core/assoc :patches (deser-patch-list (clojure.core/get-in letvar2078212 ["Patches"]))) (letvar2078212 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078212 ["NextToken"])))))))

(clojure.core/defn- response-list-documents-result ([input] (response-list-documents-result nil input)) ([resultWrapper2078214 input] (clojure.core/let [rawinput2078213 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078215 {"DocumentIdentifiers" (rawinput2078213 "DocumentIdentifiers"), "NextToken" (rawinput2078213 "NextToken")}] (clojure.core/cond-> {} (letvar2078215 "DocumentIdentifiers") (clojure.core/assoc :document-identifiers (deser-document-identifier-list (clojure.core/get-in letvar2078215 ["DocumentIdentifiers"]))) (letvar2078215 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078215 ["NextToken"])))))))

(clojure.core/defn- response-update-association-result ([input] (response-update-association-result nil input)) ([resultWrapper2078217 input] (clojure.core/let [rawinput2078216 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078218 {"AssociationDescription" (rawinput2078216 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2078218 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2078218 ["AssociationDescription"])))))))

(clojure.core/defn- response-already-exists-exception ([input] (response-already-exists-exception nil input)) ([resultWrapper2078220 input] (clojure.core/let [rawinput2078219 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078221 {"Message" (rawinput2078219 "Message")}] (clojure.core/cond-> {} (letvar2078221 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078221 ["Message"])))))))

(clojure.core/defn- response-max-document-size-exceeded ([input] (response-max-document-size-exceeded nil input)) ([resultWrapper2078223 input] (clojure.core/let [rawinput2078222 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078224 {"Message" (rawinput2078222 "Message")}] (clojure.core/cond-> {} (letvar2078224 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078224 ["Message"])))))))

(clojure.core/defn- response-put-parameter-result ([input] (response-put-parameter-result nil input)) ([resultWrapper2078226 input] (clojure.core/let [rawinput2078225 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078227 {"Version" (rawinput2078225 "Version")}] (clojure.core/cond-> {} (letvar2078227 "Version") (clojure.core/assoc :version (deser-ps-parameter-version (clojure.core/get-in letvar2078227 ["Version"])))))))

(clojure.core/defn- response-invalid-automation-execution-parameters-exception ([input] (response-invalid-automation-execution-parameters-exception nil input)) ([resultWrapper2078229 input] (clojure.core/let [rawinput2078228 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078230 {"Message" (rawinput2078228 "Message")}] (clojure.core/cond-> {} (letvar2078230 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078230 ["Message"])))))))

(clojure.core/defn- response-describe-automation-step-executions-result ([input] (response-describe-automation-step-executions-result nil input)) ([resultWrapper2078232 input] (clojure.core/let [rawinput2078231 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078233 {"StepExecutions" (rawinput2078231 "StepExecutions"), "NextToken" (rawinput2078231 "NextToken")}] (clojure.core/cond-> {} (letvar2078233 "StepExecutions") (clojure.core/assoc :step-executions (deser-step-execution-list (clojure.core/get-in letvar2078233 ["StepExecutions"]))) (letvar2078233 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078233 ["NextToken"])))))))

(clojure.core/defn- response-invalid-schedule ([input] (response-invalid-schedule nil input)) ([resultWrapper2078235 input] (clojure.core/let [rawinput2078234 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078236 {"Message" (rawinput2078234 "Message")}] (clojure.core/cond-> {} (letvar2078236 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078236 ["Message"])))))))

(clojure.core/defn- response-association-limit-exceeded ([input] (response-association-limit-exceeded nil input)) ([resultWrapper2078238 input] (clojure.core/let [rawinput2078237 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078239 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-maintenance-window-execution-task-invocation-result ([input] (response-get-maintenance-window-execution-task-invocation-result nil input)) ([resultWrapper2078241 input] (clojure.core/let [rawinput2078240 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078242 {"TaskExecutionId" (rawinput2078240 "TaskExecutionId"), "EndTime" (rawinput2078240 "EndTime"), "StartTime" (rawinput2078240 "StartTime"), "Parameters" (rawinput2078240 "Parameters"), "Status" (rawinput2078240 "Status"), "StatusDetails" (rawinput2078240 "StatusDetails"), "WindowExecutionId" (rawinput2078240 "WindowExecutionId"), "InvocationId" (rawinput2078240 "InvocationId"), "ExecutionId" (rawinput2078240 "ExecutionId"), "WindowTargetId" (rawinput2078240 "WindowTargetId"), "TaskType" (rawinput2078240 "TaskType"), "OwnerInformation" (rawinput2078240 "OwnerInformation")}] (clojure.core/cond-> {} (letvar2078242 "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (clojure.core/get-in letvar2078242 ["TaskExecutionId"]))) (letvar2078242 "EndTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar2078242 ["EndTime"]))) (letvar2078242 "StartTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar2078242 ["StartTime"]))) (letvar2078242 "Parameters") (clojure.core/assoc :parameters (deser-maintenance-window-execution-task-invocation-parameters (clojure.core/get-in letvar2078242 ["Parameters"]))) (letvar2078242 "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (clojure.core/get-in letvar2078242 ["Status"]))) (letvar2078242 "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (clojure.core/get-in letvar2078242 ["StatusDetails"]))) (letvar2078242 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2078242 ["WindowExecutionId"]))) (letvar2078242 "InvocationId") (clojure.core/assoc :invocation-id (deser-maintenance-window-execution-task-invocation-id (clojure.core/get-in letvar2078242 ["InvocationId"]))) (letvar2078242 "ExecutionId") (clojure.core/assoc :execution-id (deser-maintenance-window-execution-task-execution-id (clojure.core/get-in letvar2078242 ["ExecutionId"]))) (letvar2078242 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-task-target-id (clojure.core/get-in letvar2078242 ["WindowTargetId"]))) (letvar2078242 "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (clojure.core/get-in letvar2078242 ["TaskType"]))) (letvar2078242 "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (clojure.core/get-in letvar2078242 ["OwnerInformation"])))))))

(clojure.core/defn- response-too-many-tags-error ([input] (response-too-many-tags-error nil input)) ([resultWrapper2078244 input] (clojure.core/let [rawinput2078243 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078245 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-command-invocations-result ([input] (response-list-command-invocations-result nil input)) ([resultWrapper2078247 input] (clojure.core/let [rawinput2078246 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078248 {"CommandInvocations" (rawinput2078246 "CommandInvocations"), "NextToken" (rawinput2078246 "NextToken")}] (clojure.core/cond-> {} (letvar2078248 "CommandInvocations") (clojure.core/assoc :command-invocations (deser-command-invocation-list (clojure.core/get-in letvar2078248 ["CommandInvocations"]))) (letvar2078248 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078248 ["NextToken"])))))))

(clojure.core/defn- response-hierarchy-type-mismatch-exception ([input] (response-hierarchy-type-mismatch-exception nil input)) ([resultWrapper2078250 input] (clojure.core/let [rawinput2078249 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078251 {"message" (rawinput2078249 "message")}] (clojure.core/cond-> {} (letvar2078251 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078251 ["message"])))))))

(clojure.core/defn- response-update-service-setting-result ([input] (response-update-service-setting-result nil input)) ([resultWrapper2078253 input] (clojure.core/let [rawinput2078252 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078254 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-activation-id ([input] (response-invalid-activation-id nil input)) ([resultWrapper2078256 input] (clojure.core/let [rawinput2078255 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078257 {"Message" (rawinput2078255 "Message")}] (clojure.core/cond-> {} (letvar2078257 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078257 ["Message"])))))))

(clojure.core/defn- response-association-execution-does-not-exist ([input] (response-association-execution-does-not-exist nil input)) ([resultWrapper2078259 input] (clojure.core/let [rawinput2078258 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078260 {"Message" (rawinput2078258 "Message")}] (clojure.core/cond-> {} (letvar2078260 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078260 ["Message"])))))))

(clojure.core/defn- response-create-activation-result ([input] (response-create-activation-result nil input)) ([resultWrapper2078262 input] (clojure.core/let [rawinput2078261 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078263 {"ActivationId" (rawinput2078261 "ActivationId"), "ActivationCode" (rawinput2078261 "ActivationCode")}] (clojure.core/cond-> {} (letvar2078263 "ActivationId") (clojure.core/assoc :activation-id (deser-activation-id (clojure.core/get-in letvar2078263 ["ActivationId"]))) (letvar2078263 "ActivationCode") (clojure.core/assoc :activation-code (deser-activation-code (clojure.core/get-in letvar2078263 ["ActivationCode"])))))))

(clojure.core/defn- response-resource-data-sync-invalid-configuration-exception ([input] (response-resource-data-sync-invalid-configuration-exception nil input)) ([resultWrapper2078265 input] (clojure.core/let [rawinput2078264 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078266 {"Message" (rawinput2078264 "Message")}] (clojure.core/cond-> {} (letvar2078266 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078266 ["Message"])))))))

(clojure.core/defn- response-invalid-option-exception ([input] (response-invalid-option-exception nil input)) ([resultWrapper2078268 input] (clojure.core/let [rawinput2078267 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078269 {"Message" (rawinput2078267 "Message")}] (clojure.core/cond-> {} (letvar2078269 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078269 ["Message"])))))))

(clojure.core/defn- response-get-inventory-result ([input] (response-get-inventory-result nil input)) ([resultWrapper2078271 input] (clojure.core/let [rawinput2078270 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078272 {"Entities" (rawinput2078270 "Entities"), "NextToken" (rawinput2078270 "NextToken")}] (clojure.core/cond-> {} (letvar2078272 "Entities") (clojure.core/assoc :entities (deser-inventory-result-entity-list (clojure.core/get-in letvar2078272 ["Entities"]))) (letvar2078272 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078272 ["NextToken"])))))))

(clojure.core/defn- response-list-inventory-entries-result ([input] (response-list-inventory-entries-result nil input)) ([resultWrapper2078274 input] (clojure.core/let [rawinput2078273 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078275 {"TypeName" (rawinput2078273 "TypeName"), "InstanceId" (rawinput2078273 "InstanceId"), "SchemaVersion" (rawinput2078273 "SchemaVersion"), "CaptureTime" (rawinput2078273 "CaptureTime"), "Entries" (rawinput2078273 "Entries"), "NextToken" (rawinput2078273 "NextToken")}] (clojure.core/cond-> {} (letvar2078275 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2078275 ["TypeName"]))) (letvar2078275 "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (clojure.core/get-in letvar2078275 ["InstanceId"]))) (letvar2078275 "SchemaVersion") (clojure.core/assoc :schema-version (deser-inventory-item-schema-version (clojure.core/get-in letvar2078275 ["SchemaVersion"]))) (letvar2078275 "CaptureTime") (clojure.core/assoc :capture-time (deser-inventory-item-capture-time (clojure.core/get-in letvar2078275 ["CaptureTime"]))) (letvar2078275 "Entries") (clojure.core/assoc :entries (deser-inventory-item-entry-list (clojure.core/get-in letvar2078275 ["Entries"]))) (letvar2078275 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078275 ["NextToken"])))))))

(clojure.core/defn- response-delete-document-result ([input] (response-delete-document-result nil input)) ([resultWrapper2078277 input] (clojure.core/let [rawinput2078276 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078278 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-target-not-connected ([input] (response-target-not-connected nil input)) ([resultWrapper2078280 input] (clojure.core/let [rawinput2078279 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078281 {"Message" (rawinput2078279 "Message")}] (clojure.core/cond-> {} (letvar2078281 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078281 ["Message"])))))))

(clojure.core/defn- response-parameter-not-found ([input] (response-parameter-not-found nil input)) ([resultWrapper2078283 input] (clojure.core/let [rawinput2078282 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078284 {"message" (rawinput2078282 "message")}] (clojure.core/cond-> {} (letvar2078284 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078284 ["message"])))))))

(clojure.core/defn- response-list-compliance-items-result ([input] (response-list-compliance-items-result nil input)) ([resultWrapper2078286 input] (clojure.core/let [rawinput2078285 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078287 {"ComplianceItems" (rawinput2078285 "ComplianceItems"), "NextToken" (rawinput2078285 "NextToken")}] (clojure.core/cond-> {} (letvar2078287 "ComplianceItems") (clojure.core/assoc :compliance-items (deser-compliance-item-list (clojure.core/get-in letvar2078287 ["ComplianceItems"]))) (letvar2078287 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078287 ["NextToken"])))))))

(clojure.core/defn- response-document-limit-exceeded ([input] (response-document-limit-exceeded nil input)) ([resultWrapper2078289 input] (clojure.core/let [rawinput2078288 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078290 {"Message" (rawinput2078288 "Message")}] (clojure.core/cond-> {} (letvar2078290 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078290 ["Message"])))))))

(clojure.core/defn- response-get-maintenance-window-execution-result ([input] (response-get-maintenance-window-execution-result nil input)) ([resultWrapper2078292 input] (clojure.core/let [rawinput2078291 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078293 {"WindowExecutionId" (rawinput2078291 "WindowExecutionId"), "TaskIds" (rawinput2078291 "TaskIds"), "Status" (rawinput2078291 "Status"), "StatusDetails" (rawinput2078291 "StatusDetails"), "StartTime" (rawinput2078291 "StartTime"), "EndTime" (rawinput2078291 "EndTime")}] (clojure.core/cond-> {} (letvar2078293 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2078293 ["WindowExecutionId"]))) (letvar2078293 "TaskIds") (clojure.core/assoc :task-ids (deser-maintenance-window-execution-task-id-list (clojure.core/get-in letvar2078293 ["TaskIds"]))) (letvar2078293 "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (clojure.core/get-in letvar2078293 ["Status"]))) (letvar2078293 "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (clojure.core/get-in letvar2078293 ["StatusDetails"]))) (letvar2078293 "StartTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar2078293 ["StartTime"]))) (letvar2078293 "EndTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar2078293 ["EndTime"])))))))

(clojure.core/defn- response-invalid-filter-option ([input] (response-invalid-filter-option nil input)) ([resultWrapper2078295 input] (clojure.core/let [rawinput2078294 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078296 {"message" (rawinput2078294 "message")}] (clojure.core/cond-> {} (letvar2078296 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078296 ["message"])))))))

(clojure.core/defn- response-terminate-session-response ([input] (response-terminate-session-response nil input)) ([resultWrapper2078298 input] (clojure.core/let [rawinput2078297 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078299 {"SessionId" (rawinput2078297 "SessionId")}] (clojure.core/cond-> {} (letvar2078299 "SessionId") (clojure.core/assoc :session-id (deser-session-id (clojure.core/get-in letvar2078299 ["SessionId"])))))))

(clojure.core/defn- response-duplicate-instance-id ([input] (response-duplicate-instance-id nil input)) ([resultWrapper2078301 input] (clojure.core/let [rawinput2078300 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078302 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-maintenance-window-task-result ([input] (response-get-maintenance-window-task-result nil input)) ([resultWrapper2078304 input] (clojure.core/let [rawinput2078303 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078305 {"ServiceRoleArn" (rawinput2078303 "ServiceRoleArn"), "WindowId" (rawinput2078303 "WindowId"), "Priority" (rawinput2078303 "Priority"), "MaxConcurrency" (rawinput2078303 "MaxConcurrency"), "LoggingInfo" (rawinput2078303 "LoggingInfo"), "TaskArn" (rawinput2078303 "TaskArn"), "MaxErrors" (rawinput2078303 "MaxErrors"), "Description" (rawinput2078303 "Description"), "Targets" (rawinput2078303 "Targets"), "TaskType" (rawinput2078303 "TaskType"), "WindowTaskId" (rawinput2078303 "WindowTaskId"), "TaskParameters" (rawinput2078303 "TaskParameters"), "Name" (rawinput2078303 "Name"), "TaskInvocationParameters" (rawinput2078303 "TaskInvocationParameters")}] (clojure.core/cond-> {} (letvar2078305 "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (clojure.core/get-in letvar2078305 ["ServiceRoleArn"]))) (letvar2078305 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078305 ["WindowId"]))) (letvar2078305 "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (clojure.core/get-in letvar2078305 ["Priority"]))) (letvar2078305 "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (clojure.core/get-in letvar2078305 ["MaxConcurrency"]))) (letvar2078305 "LoggingInfo") (clojure.core/assoc :logging-info (deser-logging-info (clojure.core/get-in letvar2078305 ["LoggingInfo"]))) (letvar2078305 "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (clojure.core/get-in letvar2078305 ["TaskArn"]))) (letvar2078305 "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (clojure.core/get-in letvar2078305 ["MaxErrors"]))) (letvar2078305 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2078305 ["Description"]))) (letvar2078305 "Targets") (clojure.core/assoc :targets (deser-targets (clojure.core/get-in letvar2078305 ["Targets"]))) (letvar2078305 "TaskType") (clojure.core/assoc :task-type (deser-maintenance-window-task-type (clojure.core/get-in letvar2078305 ["TaskType"]))) (letvar2078305 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2078305 ["WindowTaskId"]))) (letvar2078305 "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters (clojure.core/get-in letvar2078305 ["TaskParameters"]))) (letvar2078305 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2078305 ["Name"]))) (letvar2078305 "TaskInvocationParameters") (clojure.core/assoc :task-invocation-parameters (deser-maintenance-window-task-invocation-parameters (clojure.core/get-in letvar2078305 ["TaskInvocationParameters"])))))))

(clojure.core/defn- response-invalid-resource-id ([input] (response-invalid-resource-id nil input)) ([resultWrapper2078307 input] (clojure.core/let [rawinput2078306 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078308 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-too-many-updates ([input] (response-too-many-updates nil input)) ([resultWrapper2078310 input] (clojure.core/let [rawinput2078309 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078311 {"Message" (rawinput2078309 "Message")}] (clojure.core/cond-> {} (letvar2078311 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078311 ["Message"])))))))

(clojure.core/defn- response-invalid-type-name-exception ([input] (response-invalid-type-name-exception nil input)) ([resultWrapper2078313 input] (clojure.core/let [rawinput2078312 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078314 {"Message" (rawinput2078312 "Message")}] (clojure.core/cond-> {} (letvar2078314 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078314 ["Message"])))))))

(clojure.core/defn- response-unsupported-parameter-type ([input] (response-unsupported-parameter-type nil input)) ([resultWrapper2078316 input] (clojure.core/let [rawinput2078315 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078317 {"message" (rawinput2078315 "message")}] (clojure.core/cond-> {} (letvar2078317 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078317 ["message"])))))))

(clojure.core/defn- response-put-compliance-items-result ([input] (response-put-compliance-items-result nil input)) ([resultWrapper2078319 input] (clojure.core/let [rawinput2078318 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078320 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-patch-baseline-result ([input] (response-delete-patch-baseline-result nil input)) ([resultWrapper2078322 input] (clojure.core/let [rawinput2078321 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078323 {"BaselineId" (rawinput2078321 "BaselineId")}] (clojure.core/cond-> {} (letvar2078323 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078323 ["BaselineId"])))))))

(clojure.core/defn- response-item-content-mismatch-exception ([input] (response-item-content-mismatch-exception nil input)) ([resultWrapper2078325 input] (clojure.core/let [rawinput2078324 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078326 {"TypeName" (rawinput2078324 "TypeName"), "Message" (rawinput2078324 "Message")}] (clojure.core/cond-> {} (letvar2078326 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2078326 ["TypeName"]))) (letvar2078326 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078326 ["Message"])))))))

(clojure.core/defn- response-document-permission-limit ([input] (response-document-permission-limit nil input)) ([resultWrapper2078328 input] (clojure.core/let [rawinput2078327 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078329 {"Message" (rawinput2078327 "Message")}] (clojure.core/cond-> {} (letvar2078329 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078329 ["Message"])))))))

(clojure.core/defn- response-hierarchy-level-limit-exceeded-exception ([input] (response-hierarchy-level-limit-exceeded-exception nil input)) ([resultWrapper2078331 input] (clojure.core/let [rawinput2078330 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078332 {"message" (rawinput2078330 "message")}] (clojure.core/cond-> {} (letvar2078332 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078332 ["message"])))))))

(clojure.core/defn- response-delete-association-result ([input] (response-delete-association-result nil input)) ([resultWrapper2078334 input] (clojure.core/let [rawinput2078333 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078335 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-maintenance-windows-for-target-result ([input] (response-describe-maintenance-windows-for-target-result nil input)) ([resultWrapper2078337 input] (clojure.core/let [rawinput2078336 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078338 {"WindowIdentities" (rawinput2078336 "WindowIdentities"), "NextToken" (rawinput2078336 "NextToken")}] (clojure.core/cond-> {} (letvar2078338 "WindowIdentities") (clojure.core/assoc :window-identities (deser-maintenance-windows-for-target-list (clojure.core/get-in letvar2078338 ["WindowIdentities"]))) (letvar2078338 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078338 ["NextToken"])))))))

(clojure.core/defn- response-unsupported-inventory-item-context-exception ([input] (response-unsupported-inventory-item-context-exception nil input)) ([resultWrapper2078340 input] (clojure.core/let [rawinput2078339 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078341 {"TypeName" (rawinput2078339 "TypeName"), "Message" (rawinput2078339 "Message")}] (clojure.core/cond-> {} (letvar2078341 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2078341 ["TypeName"]))) (letvar2078341 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078341 ["Message"])))))))

(clojure.core/defn- response-cancel-maintenance-window-execution-result ([input] (response-cancel-maintenance-window-execution-result nil input)) ([resultWrapper2078343 input] (clojure.core/let [rawinput2078342 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078344 {"WindowExecutionId" (rawinput2078342 "WindowExecutionId")}] (clojure.core/cond-> {} (letvar2078344 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2078344 ["WindowExecutionId"])))))))

(clojure.core/defn- response-create-association-batch-result ([input] (response-create-association-batch-result nil input)) ([resultWrapper2078346 input] (clojure.core/let [rawinput2078345 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078347 {"Successful" (rawinput2078345 "Successful"), "Failed" (rawinput2078345 "Failed")}] (clojure.core/cond-> {} (letvar2078347 "Successful") (clojure.core/assoc :successful (deser-association-description-list (clojure.core/get-in letvar2078347 ["Successful"]))) (letvar2078347 "Failed") (clojure.core/assoc :failed (deser-failed-create-association-list (clojure.core/get-in letvar2078347 ["Failed"])))))))

(clojure.core/defn- response-get-parameters-result ([input] (response-get-parameters-result nil input)) ([resultWrapper2078349 input] (clojure.core/let [rawinput2078348 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078350 {"Parameters" (rawinput2078348 "Parameters"), "InvalidParameters" (rawinput2078348 "InvalidParameters")}] (clojure.core/cond-> {} (letvar2078350 "Parameters") (clojure.core/assoc :parameters (deser-parameter-list (clojure.core/get-in letvar2078350 ["Parameters"]))) (letvar2078350 "InvalidParameters") (clojure.core/assoc :invalid-parameters (deser-parameter-name-list (clojure.core/get-in letvar2078350 ["InvalidParameters"])))))))

(clojure.core/defn- response-invalid-filter ([input] (response-invalid-filter nil input)) ([resultWrapper2078352 input] (clojure.core/let [rawinput2078351 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078353 {"Message" (rawinput2078351 "Message")}] (clojure.core/cond-> {} (letvar2078353 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078353 ["Message"])))))))

(clojure.core/defn- response-get-maintenance-window-result ([input] (response-get-maintenance-window-result nil input)) ([resultWrapper2078355 input] (clojure.core/let [rawinput2078354 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078356 {"WindowId" (rawinput2078354 "WindowId"), "AllowUnassociatedTargets" (rawinput2078354 "AllowUnassociatedTargets"), "EndDate" (rawinput2078354 "EndDate"), "Enabled" (rawinput2078354 "Enabled"), "NextExecutionTime" (rawinput2078354 "NextExecutionTime"), "Description" (rawinput2078354 "Description"), "Duration" (rawinput2078354 "Duration"), "CreatedDate" (rawinput2078354 "CreatedDate"), "Cutoff" (rawinput2078354 "Cutoff"), "ModifiedDate" (rawinput2078354 "ModifiedDate"), "Schedule" (rawinput2078354 "Schedule"), "Name" (rawinput2078354 "Name"), "StartDate" (rawinput2078354 "StartDate"), "ScheduleTimezone" (rawinput2078354 "ScheduleTimezone")}] (clojure.core/cond-> {} (letvar2078356 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078356 ["WindowId"]))) (letvar2078356 "AllowUnassociatedTargets") (clojure.core/assoc :allow-unassociated-targets (deser-maintenance-window-allow-unassociated-targets (clojure.core/get-in letvar2078356 ["AllowUnassociatedTargets"]))) (letvar2078356 "EndDate") (clojure.core/assoc :end-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2078356 ["EndDate"]))) (letvar2078356 "Enabled") (clojure.core/assoc :enabled (deser-maintenance-window-enabled (clojure.core/get-in letvar2078356 ["Enabled"]))) (letvar2078356 "NextExecutionTime") (clojure.core/assoc :next-execution-time (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2078356 ["NextExecutionTime"]))) (letvar2078356 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2078356 ["Description"]))) (letvar2078356 "Duration") (clojure.core/assoc :duration (deser-maintenance-window-duration-hours (clojure.core/get-in letvar2078356 ["Duration"]))) (letvar2078356 "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (clojure.core/get-in letvar2078356 ["CreatedDate"]))) (letvar2078356 "Cutoff") (clojure.core/assoc :cutoff (deser-maintenance-window-cutoff (clojure.core/get-in letvar2078356 ["Cutoff"]))) (letvar2078356 "ModifiedDate") (clojure.core/assoc :modified-date (deser-date-time (clojure.core/get-in letvar2078356 ["ModifiedDate"]))) (letvar2078356 "Schedule") (clojure.core/assoc :schedule (deser-maintenance-window-schedule (clojure.core/get-in letvar2078356 ["Schedule"]))) (letvar2078356 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2078356 ["Name"]))) (letvar2078356 "StartDate") (clojure.core/assoc :start-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2078356 ["StartDate"]))) (letvar2078356 "ScheduleTimezone") (clojure.core/assoc :schedule-timezone (deser-maintenance-window-timezone (clojure.core/get-in letvar2078356 ["ScheduleTimezone"])))))))

(clojure.core/defn- response-total-size-limit-exceeded-exception ([input] (response-total-size-limit-exceeded-exception nil input)) ([resultWrapper2078358 input] (clojure.core/let [rawinput2078357 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078359 {"Message" (rawinput2078357 "Message")}] (clojure.core/cond-> {} (letvar2078359 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078359 ["Message"])))))))

(clojure.core/defn- response-target-in-use-exception ([input] (response-target-in-use-exception nil input)) ([resultWrapper2078361 input] (clojure.core/let [rawinput2078360 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078362 {"Message" (rawinput2078360 "Message")}] (clojure.core/cond-> {} (letvar2078362 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078362 ["Message"])))))))

(clojure.core/defn- response-resource-in-use-exception ([input] (response-resource-in-use-exception nil input)) ([resultWrapper2078364 input] (clojure.core/let [rawinput2078363 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078365 {"Message" (rawinput2078363 "Message")}] (clojure.core/cond-> {} (letvar2078365 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078365 ["Message"])))))))

(clojure.core/defn- response-reset-service-setting-result ([input] (response-reset-service-setting-result nil input)) ([resultWrapper2078367 input] (clojure.core/let [rawinput2078366 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078368 {"ServiceSetting" (rawinput2078366 "ServiceSetting")}] (clojure.core/cond-> {} (letvar2078368 "ServiceSetting") (clojure.core/assoc :service-setting (deser-service-setting (clojure.core/get-in letvar2078368 ["ServiceSetting"])))))))

(clojure.core/defn- response-invalid-deletion-id-exception ([input] (response-invalid-deletion-id-exception nil input)) ([resultWrapper2078370 input] (clojure.core/let [rawinput2078369 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078371 {"Message" (rawinput2078369 "Message")}] (clojure.core/cond-> {} (letvar2078371 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078371 ["Message"])))))))

(clojure.core/defn- response-describe-association-result ([input] (response-describe-association-result nil input)) ([resultWrapper2078373 input] (clojure.core/let [rawinput2078372 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078374 {"AssociationDescription" (rawinput2078372 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2078374 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2078374 ["AssociationDescription"])))))))

(clojure.core/defn- response-describe-maintenance-window-executions-result ([input] (response-describe-maintenance-window-executions-result nil input)) ([resultWrapper2078376 input] (clojure.core/let [rawinput2078375 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078377 {"WindowExecutions" (rawinput2078375 "WindowExecutions"), "NextToken" (rawinput2078375 "NextToken")}] (clojure.core/cond-> {} (letvar2078377 "WindowExecutions") (clojure.core/assoc :window-executions (deser-maintenance-window-execution-list (clojure.core/get-in letvar2078377 ["WindowExecutions"]))) (letvar2078377 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078377 ["NextToken"])))))))

(clojure.core/defn- response-register-patch-baseline-for-patch-group-result ([input] (response-register-patch-baseline-for-patch-group-result nil input)) ([resultWrapper2078379 input] (clojure.core/let [rawinput2078378 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078380 {"BaselineId" (rawinput2078378 "BaselineId"), "PatchGroup" (rawinput2078378 "PatchGroup")}] (clojure.core/cond-> {} (letvar2078380 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078380 ["BaselineId"]))) (letvar2078380 "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (clojure.core/get-in letvar2078380 ["PatchGroup"])))))))

(clojure.core/defn- response-idempotent-parameter-mismatch ([input] (response-idempotent-parameter-mismatch nil input)) ([resultWrapper2078382 input] (clojure.core/let [rawinput2078381 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078383 {"Message" (rawinput2078381 "Message")}] (clojure.core/cond-> {} (letvar2078383 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078383 ["Message"])))))))

(clojure.core/defn- response-invalid-resource-type ([input] (response-invalid-resource-type nil input)) ([resultWrapper2078385 input] (clojure.core/let [rawinput2078384 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078386 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-automation-execution-result ([input] (response-start-automation-execution-result nil input)) ([resultWrapper2078388 input] (clojure.core/let [rawinput2078387 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078389 {"AutomationExecutionId" (rawinput2078387 "AutomationExecutionId")}] (clojure.core/cond-> {} (letvar2078389 "AutomationExecutionId") (clojure.core/assoc :automation-execution-id (deser-automation-execution-id (clojure.core/get-in letvar2078389 ["AutomationExecutionId"])))))))

(clojure.core/defn- response-describe-instance-associations-status-result ([input] (response-describe-instance-associations-status-result nil input)) ([resultWrapper2078391 input] (clojure.core/let [rawinput2078390 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078392 {"InstanceAssociationStatusInfos" (rawinput2078390 "InstanceAssociationStatusInfos"), "NextToken" (rawinput2078390 "NextToken")}] (clojure.core/cond-> {} (letvar2078392 "InstanceAssociationStatusInfos") (clojure.core/assoc :instance-association-status-infos (deser-instance-association-status-infos (clojure.core/get-in letvar2078392 ["InstanceAssociationStatusInfos"]))) (letvar2078392 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078392 ["NextToken"])))))))

(clojure.core/defn- response-create-resource-data-sync-result ([input] (response-create-resource-data-sync-result nil input)) ([resultWrapper2078394 input] (clojure.core/let [rawinput2078393 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078395 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-association-already-exists ([input] (response-association-already-exists nil input)) ([resultWrapper2078397 input] (clojure.core/let [rawinput2078396 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078398 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-associations-once-result ([input] (response-start-associations-once-result nil input)) ([resultWrapper2078400 input] (clojure.core/let [rawinput2078399 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078401 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-maintenance-window-task-result ([input] (response-update-maintenance-window-task-result nil input)) ([resultWrapper2078403 input] (clojure.core/let [rawinput2078402 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078404 {"ServiceRoleArn" (rawinput2078402 "ServiceRoleArn"), "WindowId" (rawinput2078402 "WindowId"), "Priority" (rawinput2078402 "Priority"), "MaxConcurrency" (rawinput2078402 "MaxConcurrency"), "LoggingInfo" (rawinput2078402 "LoggingInfo"), "TaskArn" (rawinput2078402 "TaskArn"), "MaxErrors" (rawinput2078402 "MaxErrors"), "Description" (rawinput2078402 "Description"), "Targets" (rawinput2078402 "Targets"), "WindowTaskId" (rawinput2078402 "WindowTaskId"), "TaskParameters" (rawinput2078402 "TaskParameters"), "Name" (rawinput2078402 "Name"), "TaskInvocationParameters" (rawinput2078402 "TaskInvocationParameters")}] (clojure.core/cond-> {} (letvar2078404 "ServiceRoleArn") (clojure.core/assoc :service-role-arn (deser-service-role (clojure.core/get-in letvar2078404 ["ServiceRoleArn"]))) (letvar2078404 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078404 ["WindowId"]))) (letvar2078404 "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (clojure.core/get-in letvar2078404 ["Priority"]))) (letvar2078404 "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (clojure.core/get-in letvar2078404 ["MaxConcurrency"]))) (letvar2078404 "LoggingInfo") (clojure.core/assoc :logging-info (deser-logging-info (clojure.core/get-in letvar2078404 ["LoggingInfo"]))) (letvar2078404 "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (clojure.core/get-in letvar2078404 ["TaskArn"]))) (letvar2078404 "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (clojure.core/get-in letvar2078404 ["MaxErrors"]))) (letvar2078404 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2078404 ["Description"]))) (letvar2078404 "Targets") (clojure.core/assoc :targets (deser-targets (clojure.core/get-in letvar2078404 ["Targets"]))) (letvar2078404 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2078404 ["WindowTaskId"]))) (letvar2078404 "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters (clojure.core/get-in letvar2078404 ["TaskParameters"]))) (letvar2078404 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2078404 ["Name"]))) (letvar2078404 "TaskInvocationParameters") (clojure.core/assoc :task-invocation-parameters (deser-maintenance-window-task-invocation-parameters (clojure.core/get-in letvar2078404 ["TaskInvocationParameters"])))))))

(clojure.core/defn- response-describe-instance-patch-states-for-patch-group-result ([input] (response-describe-instance-patch-states-for-patch-group-result nil input)) ([resultWrapper2078406 input] (clojure.core/let [rawinput2078405 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078407 {"InstancePatchStates" (rawinput2078405 "InstancePatchStates"), "NextToken" (rawinput2078405 "NextToken")}] (clojure.core/cond-> {} (letvar2078407 "InstancePatchStates") (clojure.core/assoc :instance-patch-states (deser-instance-patch-states-list (clojure.core/get-in letvar2078407 ["InstancePatchStates"]))) (letvar2078407 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078407 ["NextToken"])))))))

(clojure.core/defn- response-parameter-already-exists ([input] (response-parameter-already-exists nil input)) ([resultWrapper2078409 input] (clojure.core/let [rawinput2078408 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078410 {"message" (rawinput2078408 "message")}] (clojure.core/cond-> {} (letvar2078410 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078410 ["message"])))))))

(clojure.core/defn- response-list-compliance-summaries-result ([input] (response-list-compliance-summaries-result nil input)) ([resultWrapper2078412 input] (clojure.core/let [rawinput2078411 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078413 {"ComplianceSummaryItems" (rawinput2078411 "ComplianceSummaryItems"), "NextToken" (rawinput2078411 "NextToken")}] (clojure.core/cond-> {} (letvar2078413 "ComplianceSummaryItems") (clojure.core/assoc :compliance-summary-items (deser-compliance-summary-item-list (clojure.core/get-in letvar2078413 ["ComplianceSummaryItems"]))) (letvar2078413 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078413 ["NextToken"])))))))

(clojure.core/defn- response-invalid-instance-information-filter-value ([input] (response-invalid-instance-information-filter-value nil input)) ([resultWrapper2078415 input] (clojure.core/let [rawinput2078414 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078416 {"message" (rawinput2078414 "message")}] (clojure.core/cond-> {} (letvar2078416 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078416 ["message"])))))))

(clojure.core/defn- response-update-document-default-version-result ([input] (response-update-document-default-version-result nil input)) ([resultWrapper2078418 input] (clojure.core/let [rawinput2078417 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078419 {"Description" (rawinput2078417 "Description")}] (clojure.core/cond-> {} (letvar2078419 "Description") (clojure.core/assoc :description (deser-document-default-version-description (clojure.core/get-in letvar2078419 ["Description"])))))))

(clojure.core/defn- response-register-target-with-maintenance-window-result ([input] (response-register-target-with-maintenance-window-result nil input)) ([resultWrapper2078421 input] (clojure.core/let [rawinput2078420 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078422 {"WindowTargetId" (rawinput2078420 "WindowTargetId")}] (clojure.core/cond-> {} (letvar2078422 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (clojure.core/get-in letvar2078422 ["WindowTargetId"])))))))

(clojure.core/defn- response-does-not-exist-exception ([input] (response-does-not-exist-exception nil input)) ([resultWrapper2078424 input] (clojure.core/let [rawinput2078423 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078425 {"Message" (rawinput2078423 "Message")}] (clojure.core/cond-> {} (letvar2078425 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078425 ["Message"])))))))

(clojure.core/defn- response-parameter-limit-exceeded ([input] (response-parameter-limit-exceeded nil input)) ([resultWrapper2078427 input] (clojure.core/let [rawinput2078426 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078428 {"message" (rawinput2078426 "message")}] (clojure.core/cond-> {} (letvar2078428 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078428 ["message"])))))))

(clojure.core/defn- response-unsupported-platform-type ([input] (response-unsupported-platform-type nil input)) ([resultWrapper2078430 input] (clojure.core/let [rawinput2078429 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078431 {"Message" (rawinput2078429 "Message")}] (clojure.core/cond-> {} (letvar2078431 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078431 ["Message"])))))))

(clojure.core/defn- response-describe-instance-patches-result ([input] (response-describe-instance-patches-result nil input)) ([resultWrapper2078433 input] (clojure.core/let [rawinput2078432 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078434 {"Patches" (rawinput2078432 "Patches"), "NextToken" (rawinput2078432 "NextToken")}] (clojure.core/cond-> {} (letvar2078434 "Patches") (clojure.core/assoc :patches (deser-patch-compliance-data-list (clojure.core/get-in letvar2078434 ["Patches"]))) (letvar2078434 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078434 ["NextToken"])))))))

(clojure.core/defn- response-status-unchanged ([input] (response-status-unchanged nil input)) ([resultWrapper2078436 input] (clojure.core/let [rawinput2078435 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078437 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-command-id ([input] (response-invalid-command-id nil input)) ([resultWrapper2078439 input] (clojure.core/let [rawinput2078438 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078440 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cancel-command-result ([input] (response-cancel-command-result nil input)) ([resultWrapper2078442 input] (clojure.core/let [rawinput2078441 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078443 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-maintenance-window-result ([input] (response-create-maintenance-window-result nil input)) ([resultWrapper2078445 input] (clojure.core/let [rawinput2078444 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078446 {"WindowId" (rawinput2078444 "WindowId")}] (clojure.core/cond-> {} (letvar2078446 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078446 ["WindowId"])))))))

(clojure.core/defn- response-automation-execution-not-found-exception ([input] (response-automation-execution-not-found-exception nil input)) ([resultWrapper2078448 input] (clojure.core/let [rawinput2078447 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078449 {"Message" (rawinput2078447 "Message")}] (clojure.core/cond-> {} (letvar2078449 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078449 ["Message"])))))))

(clojure.core/defn- response-invalid-document ([input] (response-invalid-document nil input)) ([resultWrapper2078451 input] (clojure.core/let [rawinput2078450 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078452 {"Message" (rawinput2078450 "Message")}] (clojure.core/cond-> {} (letvar2078452 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078452 ["Message"])))))))

(clojure.core/defn- response-update-association-status-result ([input] (response-update-association-status-result nil input)) ([resultWrapper2078454 input] (clojure.core/let [rawinput2078453 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078455 {"AssociationDescription" (rawinput2078453 "AssociationDescription")}] (clojure.core/cond-> {} (letvar2078455 "AssociationDescription") (clojure.core/assoc :association-description (deser-association-description (clojure.core/get-in letvar2078455 ["AssociationDescription"])))))))

(clojure.core/defn- response-parameter-pattern-mismatch-exception ([input] (response-parameter-pattern-mismatch-exception nil input)) ([resultWrapper2078457 input] (clojure.core/let [rawinput2078456 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078458 {"message" (rawinput2078456 "message")}] (clojure.core/cond-> {} (letvar2078458 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078458 ["message"])))))))

(clojure.core/defn- response-invalid-result-attribute-exception ([input] (response-invalid-result-attribute-exception nil input)) ([resultWrapper2078460 input] (clojure.core/let [rawinput2078459 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078461 {"Message" (rawinput2078459 "Message")}] (clojure.core/cond-> {} (letvar2078461 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078461 ["Message"])))))))

(clojure.core/defn- response-describe-patch-group-state-result ([input] (response-describe-patch-group-state-result nil input)) ([resultWrapper2078463 input] (clojure.core/let [rawinput2078462 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078464 {"Instances" (rawinput2078462 "Instances"), "InstancesWithInstalledPatches" (rawinput2078462 "InstancesWithInstalledPatches"), "InstancesWithInstalledOtherPatches" (rawinput2078462 "InstancesWithInstalledOtherPatches"), "InstancesWithInstalledRejectedPatches" (rawinput2078462 "InstancesWithInstalledRejectedPatches"), "InstancesWithMissingPatches" (rawinput2078462 "InstancesWithMissingPatches"), "InstancesWithFailedPatches" (rawinput2078462 "InstancesWithFailedPatches"), "InstancesWithNotApplicablePatches" (rawinput2078462 "InstancesWithNotApplicablePatches")}] (clojure.core/cond-> {} (letvar2078464 "Instances") (clojure.core/assoc :instances (deser-integer (clojure.core/get-in letvar2078464 ["Instances"]))) (letvar2078464 "InstancesWithInstalledPatches") (clojure.core/assoc :instances-with-installed-patches (deser-integer (clojure.core/get-in letvar2078464 ["InstancesWithInstalledPatches"]))) (letvar2078464 "InstancesWithInstalledOtherPatches") (clojure.core/assoc :instances-with-installed-other-patches (deser-integer (clojure.core/get-in letvar2078464 ["InstancesWithInstalledOtherPatches"]))) (letvar2078464 "InstancesWithInstalledRejectedPatches") (clojure.core/assoc :instances-with-installed-rejected-patches (deser-instances-count (clojure.core/get-in letvar2078464 ["InstancesWithInstalledRejectedPatches"]))) (letvar2078464 "InstancesWithMissingPatches") (clojure.core/assoc :instances-with-missing-patches (deser-integer (clojure.core/get-in letvar2078464 ["InstancesWithMissingPatches"]))) (letvar2078464 "InstancesWithFailedPatches") (clojure.core/assoc :instances-with-failed-patches (deser-integer (clojure.core/get-in letvar2078464 ["InstancesWithFailedPatches"]))) (letvar2078464 "InstancesWithNotApplicablePatches") (clojure.core/assoc :instances-with-not-applicable-patches (deser-integer (clojure.core/get-in letvar2078464 ["InstancesWithNotApplicablePatches"])))))))

(clojure.core/defn- response-list-commands-result ([input] (response-list-commands-result nil input)) ([resultWrapper2078466 input] (clojure.core/let [rawinput2078465 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078467 {"Commands" (rawinput2078465 "Commands"), "NextToken" (rawinput2078465 "NextToken")}] (clojure.core/cond-> {} (letvar2078467 "Commands") (clojure.core/assoc :commands (deser-command-list (clojure.core/get-in letvar2078467 ["Commands"]))) (letvar2078467 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078467 ["NextToken"])))))))

(clojure.core/defn- response-create-patch-baseline-result ([input] (response-create-patch-baseline-result nil input)) ([resultWrapper2078469 input] (clojure.core/let [rawinput2078468 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078470 {"BaselineId" (rawinput2078468 "BaselineId")}] (clojure.core/cond-> {} (letvar2078470 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078470 ["BaselineId"])))))))

(clojure.core/defn- response-list-associations-result ([input] (response-list-associations-result nil input)) ([resultWrapper2078472 input] (clojure.core/let [rawinput2078471 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078473 {"Associations" (rawinput2078471 "Associations"), "NextToken" (rawinput2078471 "NextToken")}] (clojure.core/cond-> {} (letvar2078473 "Associations") (clojure.core/assoc :associations (deser-association-list (clojure.core/get-in letvar2078473 ["Associations"]))) (letvar2078473 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078473 ["NextToken"])))))))

(clojure.core/defn- response-get-automation-execution-result ([input] (response-get-automation-execution-result nil input)) ([resultWrapper2078475 input] (clojure.core/let [rawinput2078474 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078476 {"AutomationExecution" (rawinput2078474 "AutomationExecution")}] (clojure.core/cond-> {} (letvar2078476 "AutomationExecution") (clojure.core/assoc :automation-execution (deser-automation-execution (clojure.core/get-in letvar2078476 ["AutomationExecution"])))))))

(clojure.core/defn- response-get-parameters-by-path-result ([input] (response-get-parameters-by-path-result nil input)) ([resultWrapper2078478 input] (clojure.core/let [rawinput2078477 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078479 {"Parameters" (rawinput2078477 "Parameters"), "NextToken" (rawinput2078477 "NextToken")}] (clojure.core/cond-> {} (letvar2078479 "Parameters") (clojure.core/assoc :parameters (deser-parameter-list (clojure.core/get-in letvar2078479 ["Parameters"]))) (letvar2078479 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078479 ["NextToken"])))))))

(clojure.core/defn- response-delete-resource-data-sync-result ([input] (response-delete-resource-data-sync-result nil input)) ([resultWrapper2078481 input] (clojure.core/let [rawinput2078480 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078482 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-association-executions-result ([input] (response-describe-association-executions-result nil input)) ([resultWrapper2078484 input] (clojure.core/let [rawinput2078483 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078485 {"AssociationExecutions" (rawinput2078483 "AssociationExecutions"), "NextToken" (rawinput2078483 "NextToken")}] (clojure.core/cond-> {} (letvar2078485 "AssociationExecutions") (clojure.core/assoc :association-executions (deser-association-executions-list (clojure.core/get-in letvar2078485 ["AssociationExecutions"]))) (letvar2078485 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078485 ["NextToken"])))))))

(clojure.core/defn- response-association-does-not-exist ([input] (response-association-does-not-exist nil input)) ([resultWrapper2078487 input] (clojure.core/let [rawinput2078486 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078488 {"Message" (rawinput2078486 "Message")}] (clojure.core/cond-> {} (letvar2078488 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078488 ["Message"])))))))

(clojure.core/defn- response-send-automation-signal-result ([input] (response-send-automation-signal-result nil input)) ([resultWrapper2078490 input] (clojure.core/let [rawinput2078489 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078491 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-document-version ([input] (response-invalid-document-version nil input)) ([resultWrapper2078493 input] (clojure.core/let [rawinput2078492 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078494 {"Message" (rawinput2078492 "Message")}] (clojure.core/cond-> {} (letvar2078494 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078494 ["Message"])))))))

(clojure.core/defn- response-invalid-plugin-name ([input] (response-invalid-plugin-name nil input)) ([resultWrapper2078496 input] (clojure.core/let [rawinput2078495 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078497 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-document-result ([input] (response-create-document-result nil input)) ([resultWrapper2078499 input] (clojure.core/let [rawinput2078498 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078500 {"DocumentDescription" (rawinput2078498 "DocumentDescription")}] (clojure.core/cond-> {} (letvar2078500 "DocumentDescription") (clojure.core/assoc :document-description (deser-document-description (clojure.core/get-in letvar2078500 ["DocumentDescription"])))))))

(clojure.core/defn- response-custom-schema-count-limit-exceeded-exception ([input] (response-custom-schema-count-limit-exceeded-exception nil input)) ([resultWrapper2078502 input] (clojure.core/let [rawinput2078501 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078503 {"Message" (rawinput2078501 "Message")}] (clojure.core/cond-> {} (letvar2078503 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078503 ["Message"])))))))

(clojure.core/defn- response-invalid-document-operation ([input] (response-invalid-document-operation nil input)) ([resultWrapper2078505 input] (clojure.core/let [rawinput2078504 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078506 {"Message" (rawinput2078504 "Message")}] (clojure.core/cond-> {} (letvar2078506 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078506 ["Message"])))))))

(clojure.core/defn- response-duplicate-document-content ([input] (response-duplicate-document-content nil input)) ([resultWrapper2078508 input] (clojure.core/let [rawinput2078507 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078509 {"Message" (rawinput2078507 "Message")}] (clojure.core/cond-> {} (letvar2078509 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078509 ["Message"])))))))

(clojure.core/defn- response-delete-activation-result ([input] (response-delete-activation-result nil input)) ([resultWrapper2078511 input] (clojure.core/let [rawinput2078510 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078512 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-inventory-schema-result ([input] (response-get-inventory-schema-result nil input)) ([resultWrapper2078514 input] (clojure.core/let [rawinput2078513 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078515 {"Schemas" (rawinput2078513 "Schemas"), "NextToken" (rawinput2078513 "NextToken")}] (clojure.core/cond-> {} (letvar2078515 "Schemas") (clojure.core/assoc :schemas (deser-inventory-item-schema-result-list (clojure.core/get-in letvar2078515 ["Schemas"]))) (letvar2078515 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078515 ["NextToken"])))))))

(clojure.core/defn- response-put-inventory-result ([input] (response-put-inventory-result nil input)) ([resultWrapper2078517 input] (clojure.core/let [rawinput2078516 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078518 {"Message" (rawinput2078516 "Message")}] (clojure.core/cond-> {} (letvar2078518 "Message") (clojure.core/assoc :message (deser-put-inventory-message (clojure.core/get-in letvar2078518 ["Message"])))))))

(clojure.core/defn- response-update-document-result ([input] (response-update-document-result nil input)) ([resultWrapper2078520 input] (clojure.core/let [rawinput2078519 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078521 {"DocumentDescription" (rawinput2078519 "DocumentDescription")}] (clojure.core/cond-> {} (letvar2078521 "DocumentDescription") (clojure.core/assoc :document-description (deser-document-description (clojure.core/get-in letvar2078521 ["DocumentDescription"])))))))

(clojure.core/defn- response-get-connection-status-response ([input] (response-get-connection-status-response nil input)) ([resultWrapper2078523 input] (clojure.core/let [rawinput2078522 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078524 {"Target" (rawinput2078522 "Target"), "Status" (rawinput2078522 "Status")}] (clojure.core/cond-> {} (letvar2078524 "Target") (clojure.core/assoc :target (deser-session-target (clojure.core/get-in letvar2078524 ["Target"]))) (letvar2078524 "Status") (clojure.core/assoc :status (deser-connection-status (clojure.core/get-in letvar2078524 ["Status"])))))))

(clojure.core/defn- response-describe-instance-patch-states-result ([input] (response-describe-instance-patch-states-result nil input)) ([resultWrapper2078526 input] (clojure.core/let [rawinput2078525 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078527 {"InstancePatchStates" (rawinput2078525 "InstancePatchStates"), "NextToken" (rawinput2078525 "NextToken")}] (clojure.core/cond-> {} (letvar2078527 "InstancePatchStates") (clojure.core/assoc :instance-patch-states (deser-instance-patch-state-list (clojure.core/get-in letvar2078527 ["InstancePatchStates"]))) (letvar2078527 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078527 ["NextToken"])))))))

(clojure.core/defn- response-get-patch-baseline-for-patch-group-result ([input] (response-get-patch-baseline-for-patch-group-result nil input)) ([resultWrapper2078529 input] (clojure.core/let [rawinput2078528 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078530 {"BaselineId" (rawinput2078528 "BaselineId"), "PatchGroup" (rawinput2078528 "PatchGroup"), "OperatingSystem" (rawinput2078528 "OperatingSystem")}] (clojure.core/cond-> {} (letvar2078530 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078530 ["BaselineId"]))) (letvar2078530 "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (clojure.core/get-in letvar2078530 ["PatchGroup"]))) (letvar2078530 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2078530 ["OperatingSystem"])))))))

(clojure.core/defn- response-update-maintenance-window-result ([input] (response-update-maintenance-window-result nil input)) ([resultWrapper2078532 input] (clojure.core/let [rawinput2078531 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078533 {"WindowId" (rawinput2078531 "WindowId"), "AllowUnassociatedTargets" (rawinput2078531 "AllowUnassociatedTargets"), "EndDate" (rawinput2078531 "EndDate"), "Enabled" (rawinput2078531 "Enabled"), "Description" (rawinput2078531 "Description"), "Duration" (rawinput2078531 "Duration"), "Cutoff" (rawinput2078531 "Cutoff"), "Schedule" (rawinput2078531 "Schedule"), "Name" (rawinput2078531 "Name"), "StartDate" (rawinput2078531 "StartDate"), "ScheduleTimezone" (rawinput2078531 "ScheduleTimezone")}] (clojure.core/cond-> {} (letvar2078533 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078533 ["WindowId"]))) (letvar2078533 "AllowUnassociatedTargets") (clojure.core/assoc :allow-unassociated-targets (deser-maintenance-window-allow-unassociated-targets (clojure.core/get-in letvar2078533 ["AllowUnassociatedTargets"]))) (letvar2078533 "EndDate") (clojure.core/assoc :end-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2078533 ["EndDate"]))) (letvar2078533 "Enabled") (clojure.core/assoc :enabled (deser-maintenance-window-enabled (clojure.core/get-in letvar2078533 ["Enabled"]))) (letvar2078533 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2078533 ["Description"]))) (letvar2078533 "Duration") (clojure.core/assoc :duration (deser-maintenance-window-duration-hours (clojure.core/get-in letvar2078533 ["Duration"]))) (letvar2078533 "Cutoff") (clojure.core/assoc :cutoff (deser-maintenance-window-cutoff (clojure.core/get-in letvar2078533 ["Cutoff"]))) (letvar2078533 "Schedule") (clojure.core/assoc :schedule (deser-maintenance-window-schedule (clojure.core/get-in letvar2078533 ["Schedule"]))) (letvar2078533 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2078533 ["Name"]))) (letvar2078533 "StartDate") (clojure.core/assoc :start-date (deser-maintenance-window-string-date-time (clojure.core/get-in letvar2078533 ["StartDate"]))) (letvar2078533 "ScheduleTimezone") (clojure.core/assoc :schedule-timezone (deser-maintenance-window-timezone (clojure.core/get-in letvar2078533 ["ScheduleTimezone"])))))))

(clojure.core/defn- response-start-session-response ([input] (response-start-session-response nil input)) ([resultWrapper2078535 input] (clojure.core/let [rawinput2078534 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078536 {"SessionId" (rawinput2078534 "SessionId"), "TokenValue" (rawinput2078534 "TokenValue"), "StreamUrl" (rawinput2078534 "StreamUrl")}] (clojure.core/cond-> {} (letvar2078536 "SessionId") (clojure.core/assoc :session-id (deser-session-id (clojure.core/get-in letvar2078536 ["SessionId"]))) (letvar2078536 "TokenValue") (clojure.core/assoc :token-value (deser-token-value (clojure.core/get-in letvar2078536 ["TokenValue"]))) (letvar2078536 "StreamUrl") (clojure.core/assoc :stream-url (deser-stream-url (clojure.core/get-in letvar2078536 ["StreamUrl"])))))))

(clojure.core/defn- response-delete-inventory-result ([input] (response-delete-inventory-result nil input)) ([resultWrapper2078538 input] (clojure.core/let [rawinput2078537 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078539 {"DeletionId" (rawinput2078537 "DeletionId"), "TypeName" (rawinput2078537 "TypeName"), "DeletionSummary" (rawinput2078537 "DeletionSummary")}] (clojure.core/cond-> {} (letvar2078539 "DeletionId") (clojure.core/assoc :deletion-id (deser-inventory-deletion-id (clojure.core/get-in letvar2078539 ["DeletionId"]))) (letvar2078539 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2078539 ["TypeName"]))) (letvar2078539 "DeletionSummary") (clojure.core/assoc :deletion-summary (deser-inventory-deletion-summary (clojure.core/get-in letvar2078539 ["DeletionSummary"])))))))

(clojure.core/defn- response-describe-automation-executions-result ([input] (response-describe-automation-executions-result nil input)) ([resultWrapper2078541 input] (clojure.core/let [rawinput2078540 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078542 {"AutomationExecutionMetadataList" (rawinput2078540 "AutomationExecutionMetadataList"), "NextToken" (rawinput2078540 "NextToken")}] (clojure.core/cond-> {} (letvar2078542 "AutomationExecutionMetadataList") (clojure.core/assoc :automation-execution-metadata-list (deser-automation-execution-metadata-list (clojure.core/get-in letvar2078542 ["AutomationExecutionMetadataList"]))) (letvar2078542 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078542 ["NextToken"])))))))

(clojure.core/defn- response-parameter-version-label-limit-exceeded ([input] (response-parameter-version-label-limit-exceeded nil input)) ([resultWrapper2078544 input] (clojure.core/let [rawinput2078543 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078545 {"message" (rawinput2078543 "message")}] (clojure.core/cond-> {} (letvar2078545 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078545 ["message"])))))))

(clojure.core/defn- response-automation-definition-version-not-found-exception ([input] (response-automation-definition-version-not-found-exception nil input)) ([resultWrapper2078547 input] (clojure.core/let [rawinput2078546 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078548 {"Message" (rawinput2078546 "Message")}] (clojure.core/cond-> {} (letvar2078548 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078548 ["Message"])))))))

(clojure.core/defn- response-deregister-target-from-maintenance-window-result ([input] (response-deregister-target-from-maintenance-window-result nil input)) ([resultWrapper2078550 input] (clojure.core/let [rawinput2078549 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078551 {"WindowId" (rawinput2078549 "WindowId"), "WindowTargetId" (rawinput2078549 "WindowTargetId")}] (clojure.core/cond-> {} (letvar2078551 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078551 ["WindowId"]))) (letvar2078551 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (clojure.core/get-in letvar2078551 ["WindowTargetId"])))))))

(clojure.core/defn- response-update-patch-baseline-result ([input] (response-update-patch-baseline-result nil input)) ([resultWrapper2078553 input] (clojure.core/let [rawinput2078552 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078554 {"RejectedPatchesAction" (rawinput2078552 "RejectedPatchesAction"), "GlobalFilters" (rawinput2078552 "GlobalFilters"), "ApprovedPatches" (rawinput2078552 "ApprovedPatches"), "Description" (rawinput2078552 "Description"), "ApprovedPatchesEnableNonSecurity" (rawinput2078552 "ApprovedPatchesEnableNonSecurity"), "BaselineId" (rawinput2078552 "BaselineId"), "CreatedDate" (rawinput2078552 "CreatedDate"), "ModifiedDate" (rawinput2078552 "ModifiedDate"), "ApprovalRules" (rawinput2078552 "ApprovalRules"), "ApprovedPatchesComplianceLevel" (rawinput2078552 "ApprovedPatchesComplianceLevel"), "Name" (rawinput2078552 "Name"), "Sources" (rawinput2078552 "Sources"), "OperatingSystem" (rawinput2078552 "OperatingSystem"), "RejectedPatches" (rawinput2078552 "RejectedPatches")}] (clojure.core/cond-> {} (letvar2078554 "RejectedPatchesAction") (clojure.core/assoc :rejected-patches-action (deser-patch-action (clojure.core/get-in letvar2078554 ["RejectedPatchesAction"]))) (letvar2078554 "GlobalFilters") (clojure.core/assoc :global-filters (deser-patch-filter-group (clojure.core/get-in letvar2078554 ["GlobalFilters"]))) (letvar2078554 "ApprovedPatches") (clojure.core/assoc :approved-patches (deser-patch-id-list (clojure.core/get-in letvar2078554 ["ApprovedPatches"]))) (letvar2078554 "Description") (clojure.core/assoc :description (deser-baseline-description (clojure.core/get-in letvar2078554 ["Description"]))) (letvar2078554 "ApprovedPatchesEnableNonSecurity") (clojure.core/assoc :approved-patches-enable-non-security (deser-boolean (clojure.core/get-in letvar2078554 ["ApprovedPatchesEnableNonSecurity"]))) (letvar2078554 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078554 ["BaselineId"]))) (letvar2078554 "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (clojure.core/get-in letvar2078554 ["CreatedDate"]))) (letvar2078554 "ModifiedDate") (clojure.core/assoc :modified-date (deser-date-time (clojure.core/get-in letvar2078554 ["ModifiedDate"]))) (letvar2078554 "ApprovalRules") (clojure.core/assoc :approval-rules (deser-patch-rule-group (clojure.core/get-in letvar2078554 ["ApprovalRules"]))) (letvar2078554 "ApprovedPatchesComplianceLevel") (clojure.core/assoc :approved-patches-compliance-level (deser-patch-compliance-level (clojure.core/get-in letvar2078554 ["ApprovedPatchesComplianceLevel"]))) (letvar2078554 "Name") (clojure.core/assoc :name (deser-baseline-name (clojure.core/get-in letvar2078554 ["Name"]))) (letvar2078554 "Sources") (clojure.core/assoc :sources (deser-patch-source-list (clojure.core/get-in letvar2078554 ["Sources"]))) (letvar2078554 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2078554 ["OperatingSystem"]))) (letvar2078554 "RejectedPatches") (clojure.core/assoc :rejected-patches (deser-patch-id-list (clojure.core/get-in letvar2078554 ["RejectedPatches"])))))))

(clojure.core/defn- response-describe-maintenance-window-targets-result ([input] (response-describe-maintenance-window-targets-result nil input)) ([resultWrapper2078556 input] (clojure.core/let [rawinput2078555 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078557 {"Targets" (rawinput2078555 "Targets"), "NextToken" (rawinput2078555 "NextToken")}] (clojure.core/cond-> {} (letvar2078557 "Targets") (clojure.core/assoc :targets (deser-maintenance-window-target-list (clojure.core/get-in letvar2078557 ["Targets"]))) (letvar2078557 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078557 ["NextToken"])))))))

(clojure.core/defn- response-describe-maintenance-window-tasks-result ([input] (response-describe-maintenance-window-tasks-result nil input)) ([resultWrapper2078559 input] (clojure.core/let [rawinput2078558 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078560 {"Tasks" (rawinput2078558 "Tasks"), "NextToken" (rawinput2078558 "NextToken")}] (clojure.core/cond-> {} (letvar2078560 "Tasks") (clojure.core/assoc :tasks (deser-maintenance-window-task-list (clojure.core/get-in letvar2078560 ["Tasks"]))) (letvar2078560 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078560 ["NextToken"])))))))

(clojure.core/defn- response-invalid-parameters ([input] (response-invalid-parameters nil input)) ([resultWrapper2078562 input] (clojure.core/let [rawinput2078561 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078563 {"Message" (rawinput2078561 "Message")}] (clojure.core/cond-> {} (letvar2078563 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078563 ["Message"])))))))

(clojure.core/defn- response-describe-association-execution-targets-result ([input] (response-describe-association-execution-targets-result nil input)) ([resultWrapper2078565 input] (clojure.core/let [rawinput2078564 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078566 {"AssociationExecutionTargets" (rawinput2078564 "AssociationExecutionTargets"), "NextToken" (rawinput2078564 "NextToken")}] (clojure.core/cond-> {} (letvar2078566 "AssociationExecutionTargets") (clojure.core/assoc :association-execution-targets (deser-association-execution-targets-list (clojure.core/get-in letvar2078566 ["AssociationExecutionTargets"]))) (letvar2078566 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078566 ["NextToken"])))))))

(clojure.core/defn- response-get-patch-baseline-result ([input] (response-get-patch-baseline-result nil input)) ([resultWrapper2078568 input] (clojure.core/let [rawinput2078567 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078569 {"RejectedPatchesAction" (rawinput2078567 "RejectedPatchesAction"), "GlobalFilters" (rawinput2078567 "GlobalFilters"), "ApprovedPatches" (rawinput2078567 "ApprovedPatches"), "Description" (rawinput2078567 "Description"), "ApprovedPatchesEnableNonSecurity" (rawinput2078567 "ApprovedPatchesEnableNonSecurity"), "BaselineId" (rawinput2078567 "BaselineId"), "CreatedDate" (rawinput2078567 "CreatedDate"), "PatchGroups" (rawinput2078567 "PatchGroups"), "ModifiedDate" (rawinput2078567 "ModifiedDate"), "ApprovalRules" (rawinput2078567 "ApprovalRules"), "ApprovedPatchesComplianceLevel" (rawinput2078567 "ApprovedPatchesComplianceLevel"), "Name" (rawinput2078567 "Name"), "Sources" (rawinput2078567 "Sources"), "OperatingSystem" (rawinput2078567 "OperatingSystem"), "RejectedPatches" (rawinput2078567 "RejectedPatches")}] (clojure.core/cond-> {} (letvar2078569 "RejectedPatchesAction") (clojure.core/assoc :rejected-patches-action (deser-patch-action (clojure.core/get-in letvar2078569 ["RejectedPatchesAction"]))) (letvar2078569 "GlobalFilters") (clojure.core/assoc :global-filters (deser-patch-filter-group (clojure.core/get-in letvar2078569 ["GlobalFilters"]))) (letvar2078569 "ApprovedPatches") (clojure.core/assoc :approved-patches (deser-patch-id-list (clojure.core/get-in letvar2078569 ["ApprovedPatches"]))) (letvar2078569 "Description") (clojure.core/assoc :description (deser-baseline-description (clojure.core/get-in letvar2078569 ["Description"]))) (letvar2078569 "ApprovedPatchesEnableNonSecurity") (clojure.core/assoc :approved-patches-enable-non-security (deser-boolean (clojure.core/get-in letvar2078569 ["ApprovedPatchesEnableNonSecurity"]))) (letvar2078569 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078569 ["BaselineId"]))) (letvar2078569 "CreatedDate") (clojure.core/assoc :created-date (deser-date-time (clojure.core/get-in letvar2078569 ["CreatedDate"]))) (letvar2078569 "PatchGroups") (clojure.core/assoc :patch-groups (deser-patch-group-list (clojure.core/get-in letvar2078569 ["PatchGroups"]))) (letvar2078569 "ModifiedDate") (clojure.core/assoc :modified-date (deser-date-time (clojure.core/get-in letvar2078569 ["ModifiedDate"]))) (letvar2078569 "ApprovalRules") (clojure.core/assoc :approval-rules (deser-patch-rule-group (clojure.core/get-in letvar2078569 ["ApprovalRules"]))) (letvar2078569 "ApprovedPatchesComplianceLevel") (clojure.core/assoc :approved-patches-compliance-level (deser-patch-compliance-level (clojure.core/get-in letvar2078569 ["ApprovedPatchesComplianceLevel"]))) (letvar2078569 "Name") (clojure.core/assoc :name (deser-baseline-name (clojure.core/get-in letvar2078569 ["Name"]))) (letvar2078569 "Sources") (clojure.core/assoc :sources (deser-patch-source-list (clojure.core/get-in letvar2078569 ["Sources"]))) (letvar2078569 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2078569 ["OperatingSystem"]))) (letvar2078569 "RejectedPatches") (clojure.core/assoc :rejected-patches (deser-patch-id-list (clojure.core/get-in letvar2078569 ["RejectedPatches"])))))))

(clojure.core/defn- response-deregister-task-from-maintenance-window-result ([input] (response-deregister-task-from-maintenance-window-result nil input)) ([resultWrapper2078571 input] (clojure.core/let [rawinput2078570 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078572 {"WindowId" (rawinput2078570 "WindowId"), "WindowTaskId" (rawinput2078570 "WindowTaskId")}] (clojure.core/cond-> {} (letvar2078572 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078572 ["WindowId"]))) (letvar2078572 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2078572 ["WindowTaskId"])))))))

(clojure.core/defn- response-unsupported-inventory-schema-version-exception ([input] (response-unsupported-inventory-schema-version-exception nil input)) ([resultWrapper2078574 input] (clojure.core/let [rawinput2078573 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078575 {"Message" (rawinput2078573 "Message")}] (clojure.core/cond-> {} (letvar2078575 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078575 ["Message"])))))))

(clojure.core/defn- response-invalid-item-content-exception ([input] (response-invalid-item-content-exception nil input)) ([resultWrapper2078577 input] (clojure.core/let [rawinput2078576 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078578 {"TypeName" (rawinput2078576 "TypeName"), "Message" (rawinput2078576 "Message")}] (clojure.core/cond-> {} (letvar2078578 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2078578 ["TypeName"]))) (letvar2078578 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078578 ["Message"])))))))

(clojure.core/defn- response-invalid-filter-key ([input] (response-invalid-filter-key nil input)) ([resultWrapper2078580 input] (clojure.core/let [rawinput2078579 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078581 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-notification-config ([input] (response-invalid-notification-config nil input)) ([resultWrapper2078583 input] (clojure.core/let [rawinput2078582 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078584 {"Message" (rawinput2078582 "Message")}] (clojure.core/cond-> {} (letvar2078584 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078584 ["Message"])))))))

(clojure.core/defn- response-describe-document-permission-response ([input] (response-describe-document-permission-response nil input)) ([resultWrapper2078586 input] (clojure.core/let [rawinput2078585 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078587 {"AccountIds" (rawinput2078585 "AccountIds")}] (clojure.core/cond-> {} (letvar2078587 "AccountIds") (clojure.core/assoc :account-ids (deser-account-id-list (clojure.core/get-in letvar2078587 ["AccountIds"])))))))

(clojure.core/defn- response-unsupported-operating-system ([input] (response-unsupported-operating-system nil input)) ([resultWrapper2078589 input] (clojure.core/let [rawinput2078588 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078590 {"Message" (rawinput2078588 "Message")}] (clojure.core/cond-> {} (letvar2078590 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078590 ["Message"])))))))

(clojure.core/defn- response-get-default-patch-baseline-result ([input] (response-get-default-patch-baseline-result nil input)) ([resultWrapper2078592 input] (clojure.core/let [rawinput2078591 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078593 {"BaselineId" (rawinput2078591 "BaselineId"), "OperatingSystem" (rawinput2078591 "OperatingSystem")}] (clojure.core/cond-> {} (letvar2078593 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078593 ["BaselineId"]))) (letvar2078593 "OperatingSystem") (clojure.core/assoc :operating-system (deser-operating-system (clojure.core/get-in letvar2078593 ["OperatingSystem"])))))))

(clojure.core/defn- response-describe-patch-groups-result ([input] (response-describe-patch-groups-result nil input)) ([resultWrapper2078595 input] (clojure.core/let [rawinput2078594 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078596 {"Mappings" (rawinput2078594 "Mappings"), "NextToken" (rawinput2078594 "NextToken")}] (clojure.core/cond-> {} (letvar2078596 "Mappings") (clojure.core/assoc :mappings (deser-patch-group-patch-baseline-mapping-list (clojure.core/get-in letvar2078596 ["Mappings"]))) (letvar2078596 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078596 ["NextToken"])))))))

(clojure.core/defn- response-remove-tags-from-resource-result ([input] (response-remove-tags-from-resource-result nil input)) ([resultWrapper2078598 input] (clojure.core/let [rawinput2078597 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078599 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-parameter-result ([input] (response-delete-parameter-result nil input)) ([resultWrapper2078601 input] (clojure.core/let [rawinput2078600 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078602 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-filter-value ([input] (response-invalid-filter-value nil input)) ([resultWrapper2078604 input] (clojure.core/let [rawinput2078603 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078605 {"Message" (rawinput2078603 "Message")}] (clojure.core/cond-> {} (letvar2078605 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078605 ["Message"])))))))

(clojure.core/defn- response-invalid-key-id ([input] (response-invalid-key-id nil input)) ([resultWrapper2078607 input] (clojure.core/let [rawinput2078606 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078608 {"message" (rawinput2078606 "message")}] (clojure.core/cond-> {} (letvar2078608 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078608 ["message"])))))))

(clojure.core/defn- response-describe-maintenance-window-execution-task-invocations-result ([input] (response-describe-maintenance-window-execution-task-invocations-result nil input)) ([resultWrapper2078610 input] (clojure.core/let [rawinput2078609 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078611 {"WindowExecutionTaskInvocationIdentities" (rawinput2078609 "WindowExecutionTaskInvocationIdentities"), "NextToken" (rawinput2078609 "NextToken")}] (clojure.core/cond-> {} (letvar2078611 "WindowExecutionTaskInvocationIdentities") (clojure.core/assoc :window-execution-task-invocation-identities (deser-maintenance-window-execution-task-invocation-identity-list (clojure.core/get-in letvar2078611 ["WindowExecutionTaskInvocationIdentities"]))) (letvar2078611 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078611 ["NextToken"])))))))

(clojure.core/defn- response-parameter-max-version-limit-exceeded ([input] (response-parameter-max-version-limit-exceeded nil input)) ([resultWrapper2078613 input] (clojure.core/let [rawinput2078612 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078614 {"message" (rawinput2078612 "message")}] (clojure.core/cond-> {} (letvar2078614 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078614 ["message"])))))))

(clojure.core/defn- response-feature-not-available-exception ([input] (response-feature-not-available-exception nil input)) ([resultWrapper2078616 input] (clojure.core/let [rawinput2078615 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078617 {"Message" (rawinput2078615 "Message")}] (clojure.core/cond-> {} (letvar2078617 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078617 ["Message"])))))))

(clojure.core/defn- response-invalid-automation-signal-exception ([input] (response-invalid-automation-signal-exception nil input)) ([resultWrapper2078619 input] (clojure.core/let [rawinput2078618 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078620 {"Message" (rawinput2078618 "Message")}] (clojure.core/cond-> {} (letvar2078620 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078620 ["Message"])))))))

(clojure.core/defn- response-describe-effective-patches-for-patch-baseline-result ([input] (response-describe-effective-patches-for-patch-baseline-result nil input)) ([resultWrapper2078622 input] (clojure.core/let [rawinput2078621 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078623 {"EffectivePatches" (rawinput2078621 "EffectivePatches"), "NextToken" (rawinput2078621 "NextToken")}] (clojure.core/cond-> {} (letvar2078623 "EffectivePatches") (clojure.core/assoc :effective-patches (deser-effective-patch-list (clojure.core/get-in letvar2078623 ["EffectivePatches"]))) (letvar2078623 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078623 ["NextToken"])))))))

(clojure.core/defn- response-resource-data-sync-count-exceeded-exception ([input] (response-resource-data-sync-count-exceeded-exception nil input)) ([resultWrapper2078625 input] (clojure.core/let [rawinput2078624 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078626 {"Message" (rawinput2078624 "Message")}] (clojure.core/cond-> {} (letvar2078626 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078626 ["Message"])))))))

(clojure.core/defn- response-list-resource-data-sync-result ([input] (response-list-resource-data-sync-result nil input)) ([resultWrapper2078628 input] (clojure.core/let [rawinput2078627 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078629 {"ResourceDataSyncItems" (rawinput2078627 "ResourceDataSyncItems"), "NextToken" (rawinput2078627 "NextToken")}] (clojure.core/cond-> {} (letvar2078629 "ResourceDataSyncItems") (clojure.core/assoc :resource-data-sync-items (deser-resource-data-sync-item-list (clojure.core/get-in letvar2078629 ["ResourceDataSyncItems"]))) (letvar2078629 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078629 ["NextToken"])))))))

(clojure.core/defn- response-describe-document-result ([input] (response-describe-document-result nil input)) ([resultWrapper2078631 input] (clojure.core/let [rawinput2078630 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078632 {"Document" (rawinput2078630 "Document")}] (clojure.core/cond-> {} (letvar2078632 "Document") (clojure.core/assoc :document (deser-document-description (clojure.core/get-in letvar2078632 ["Document"])))))))

(clojure.core/defn- response-describe-sessions-response ([input] (response-describe-sessions-response nil input)) ([resultWrapper2078634 input] (clojure.core/let [rawinput2078633 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078635 {"Sessions" (rawinput2078633 "Sessions"), "NextToken" (rawinput2078633 "NextToken")}] (clojure.core/cond-> {} (letvar2078635 "Sessions") (clojure.core/assoc :sessions (deser-session-list (clojure.core/get-in letvar2078635 ["Sessions"]))) (letvar2078635 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078635 ["NextToken"])))))))

(clojure.core/defn- response-resource-limit-exceeded-exception ([input] (response-resource-limit-exceeded-exception nil input)) ([resultWrapper2078637 input] (clojure.core/let [rawinput2078636 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078638 {"Message" (rawinput2078636 "Message")}] (clojure.core/cond-> {} (letvar2078638 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078638 ["Message"])))))))

(clojure.core/defn- response-invalid-inventory-item-context-exception ([input] (response-invalid-inventory-item-context-exception nil input)) ([resultWrapper2078640 input] (clojure.core/let [rawinput2078639 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078641 {"Message" (rawinput2078639 "Message")}] (clojure.core/cond-> {} (letvar2078641 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078641 ["Message"])))))))

(clojure.core/defn- response-get-document-result ([input] (response-get-document-result nil input)) ([resultWrapper2078643 input] (clojure.core/let [rawinput2078642 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078644 {"DocumentType" (rawinput2078642 "DocumentType"), "Status" (rawinput2078642 "Status"), "StatusInformation" (rawinput2078642 "StatusInformation"), "Content" (rawinput2078642 "Content"), "DocumentFormat" (rawinput2078642 "DocumentFormat"), "VersionName" (rawinput2078642 "VersionName"), "AttachmentsContent" (rawinput2078642 "AttachmentsContent"), "DocumentVersion" (rawinput2078642 "DocumentVersion"), "Name" (rawinput2078642 "Name")}] (clojure.core/cond-> {} (letvar2078644 "DocumentType") (clojure.core/assoc :document-type (deser-document-type (clojure.core/get-in letvar2078644 ["DocumentType"]))) (letvar2078644 "Status") (clojure.core/assoc :status (deser-document-status (clojure.core/get-in letvar2078644 ["Status"]))) (letvar2078644 "StatusInformation") (clojure.core/assoc :status-information (deser-document-status-information (clojure.core/get-in letvar2078644 ["StatusInformation"]))) (letvar2078644 "Content") (clojure.core/assoc :content (deser-document-content (clojure.core/get-in letvar2078644 ["Content"]))) (letvar2078644 "DocumentFormat") (clojure.core/assoc :document-format (deser-document-format (clojure.core/get-in letvar2078644 ["DocumentFormat"]))) (letvar2078644 "VersionName") (clojure.core/assoc :version-name (deser-document-version-name (clojure.core/get-in letvar2078644 ["VersionName"]))) (letvar2078644 "AttachmentsContent") (clojure.core/assoc :attachments-content (deser-attachment-content-list (clojure.core/get-in letvar2078644 ["AttachmentsContent"]))) (letvar2078644 "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (clojure.core/get-in letvar2078644 ["DocumentVersion"]))) (letvar2078644 "Name") (clojure.core/assoc :name (deser-document-arn (clojure.core/get-in letvar2078644 ["Name"])))))))

(clojure.core/defn- response-duplicate-document-version-name ([input] (response-duplicate-document-version-name nil input)) ([resultWrapper2078646 input] (clojure.core/let [rawinput2078645 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078647 {"Message" (rawinput2078645 "Message")}] (clojure.core/cond-> {} (letvar2078647 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078647 ["Message"])))))))

(clojure.core/defn- response-association-version-limit-exceeded ([input] (response-association-version-limit-exceeded nil input)) ([resultWrapper2078649 input] (clojure.core/let [rawinput2078648 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078650 {"Message" (rawinput2078648 "Message")}] (clojure.core/cond-> {} (letvar2078650 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078650 ["Message"])))))))

(clojure.core/defn- response-list-association-versions-result ([input] (response-list-association-versions-result nil input)) ([resultWrapper2078652 input] (clojure.core/let [rawinput2078651 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078653 {"AssociationVersions" (rawinput2078651 "AssociationVersions"), "NextToken" (rawinput2078651 "NextToken")}] (clojure.core/cond-> {} (letvar2078653 "AssociationVersions") (clojure.core/assoc :association-versions (deser-association-version-list (clojure.core/get-in letvar2078653 ["AssociationVersions"]))) (letvar2078653 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078653 ["NextToken"])))))))

(clojure.core/defn- response-resume-session-response ([input] (response-resume-session-response nil input)) ([resultWrapper2078655 input] (clojure.core/let [rawinput2078654 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078656 {"SessionId" (rawinput2078654 "SessionId"), "TokenValue" (rawinput2078654 "TokenValue"), "StreamUrl" (rawinput2078654 "StreamUrl")}] (clojure.core/cond-> {} (letvar2078656 "SessionId") (clojure.core/assoc :session-id (deser-session-id (clojure.core/get-in letvar2078656 ["SessionId"]))) (letvar2078656 "TokenValue") (clojure.core/assoc :token-value (deser-token-value (clojure.core/get-in letvar2078656 ["TokenValue"]))) (letvar2078656 "StreamUrl") (clojure.core/assoc :stream-url (deser-stream-url (clojure.core/get-in letvar2078656 ["StreamUrl"])))))))

(clojure.core/defn- response-invalid-target ([input] (response-invalid-target nil input)) ([resultWrapper2078658 input] (clojure.core/let [rawinput2078657 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078659 {"Message" (rawinput2078657 "Message")}] (clojure.core/cond-> {} (letvar2078659 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078659 ["Message"])))))))

(clojure.core/defn- response-describe-activations-result ([input] (response-describe-activations-result nil input)) ([resultWrapper2078661 input] (clojure.core/let [rawinput2078660 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078662 {"ActivationList" (rawinput2078660 "ActivationList"), "NextToken" (rawinput2078660 "NextToken")}] (clojure.core/cond-> {} (letvar2078662 "ActivationList") (clojure.core/assoc :activation-list (deser-activation-list (clojure.core/get-in letvar2078662 ["ActivationList"]))) (letvar2078662 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078662 ["NextToken"])))))))

(clojure.core/defn- response-invalid-association-version ([input] (response-invalid-association-version nil input)) ([resultWrapper2078664 input] (clojure.core/let [rawinput2078663 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078665 {"Message" (rawinput2078663 "Message")}] (clojure.core/cond-> {} (letvar2078665 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078665 ["Message"])))))))

(clojure.core/defn- response-invalid-inventory-request-exception ([input] (response-invalid-inventory-request-exception nil input)) ([resultWrapper2078667 input] (clojure.core/let [rawinput2078666 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078668 {"Message" (rawinput2078666 "Message")}] (clojure.core/cond-> {} (letvar2078668 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078668 ["Message"])))))))

(clojure.core/defn- response-sub-type-count-limit-exceeded-exception ([input] (response-sub-type-count-limit-exceeded-exception nil input)) ([resultWrapper2078670 input] (clojure.core/let [rawinput2078669 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078671 {"Message" (rawinput2078669 "Message")}] (clojure.core/cond-> {} (letvar2078671 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078671 ["Message"])))))))

(clojure.core/defn- response-associated-instances ([input] (response-associated-instances nil input)) ([resultWrapper2078673 input] (clojure.core/let [rawinput2078672 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078674 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-output-folder ([input] (response-invalid-output-folder nil input)) ([resultWrapper2078676 input] (clojure.core/let [rawinput2078675 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078677 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-resource-compliance-summaries-result ([input] (response-list-resource-compliance-summaries-result nil input)) ([resultWrapper2078679 input] (clojure.core/let [rawinput2078678 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078680 {"ResourceComplianceSummaryItems" (rawinput2078678 "ResourceComplianceSummaryItems"), "NextToken" (rawinput2078678 "NextToken")}] (clojure.core/cond-> {} (letvar2078680 "ResourceComplianceSummaryItems") (clojure.core/assoc :resource-compliance-summary-items (deser-resource-compliance-summary-item-list (clojure.core/get-in letvar2078680 ["ResourceComplianceSummaryItems"]))) (letvar2078680 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078680 ["NextToken"])))))))

(clojure.core/defn- response-invalid-role ([input] (response-invalid-role nil input)) ([resultWrapper2078682 input] (clojure.core/let [rawinput2078681 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078683 {"Message" (rawinput2078681 "Message")}] (clojure.core/cond-> {} (letvar2078683 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078683 ["Message"])))))))

(clojure.core/defn- response-invalid-association ([input] (response-invalid-association nil input)) ([resultWrapper2078685 input] (clojure.core/let [rawinput2078684 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078686 {"Message" (rawinput2078684 "Message")}] (clojure.core/cond-> {} (letvar2078686 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078686 ["Message"])))))))

(clojure.core/defn- response-describe-parameters-result ([input] (response-describe-parameters-result nil input)) ([resultWrapper2078688 input] (clojure.core/let [rawinput2078687 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078689 {"Parameters" (rawinput2078687 "Parameters"), "NextToken" (rawinput2078687 "NextToken")}] (clojure.core/cond-> {} (letvar2078689 "Parameters") (clojure.core/assoc :parameters (deser-parameter-metadata-list (clojure.core/get-in letvar2078689 ["Parameters"]))) (letvar2078689 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078689 ["NextToken"])))))))

(clojure.core/defn- response-resource-data-sync-already-exists-exception ([input] (response-resource-data-sync-already-exists-exception nil input)) ([resultWrapper2078691 input] (clojure.core/let [rawinput2078690 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078692 {"SyncName" (rawinput2078690 "SyncName")}] (clojure.core/cond-> {} (letvar2078692 "SyncName") (clojure.core/assoc :sync-name (deser-resource-data-sync-name (clojure.core/get-in letvar2078692 ["SyncName"])))))))

(clojure.core/defn- response-update-maintenance-window-target-result ([input] (response-update-maintenance-window-target-result nil input)) ([resultWrapper2078694 input] (clojure.core/let [rawinput2078693 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078695 {"WindowId" (rawinput2078693 "WindowId"), "WindowTargetId" (rawinput2078693 "WindowTargetId"), "Targets" (rawinput2078693 "Targets"), "OwnerInformation" (rawinput2078693 "OwnerInformation"), "Name" (rawinput2078693 "Name"), "Description" (rawinput2078693 "Description")}] (clojure.core/cond-> {} (letvar2078695 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078695 ["WindowId"]))) (letvar2078695 "WindowTargetId") (clojure.core/assoc :window-target-id (deser-maintenance-window-target-id (clojure.core/get-in letvar2078695 ["WindowTargetId"]))) (letvar2078695 "Targets") (clojure.core/assoc :targets (deser-targets (clojure.core/get-in letvar2078695 ["Targets"]))) (letvar2078695 "OwnerInformation") (clojure.core/assoc :owner-information (deser-owner-information (clojure.core/get-in letvar2078695 ["OwnerInformation"]))) (letvar2078695 "Name") (clojure.core/assoc :name (deser-maintenance-window-name (clojure.core/get-in letvar2078695 ["Name"]))) (letvar2078695 "Description") (clojure.core/assoc :description (deser-maintenance-window-description (clojure.core/get-in letvar2078695 ["Description"])))))))

(clojure.core/defn- response-invalid-inventory-group-exception ([input] (response-invalid-inventory-group-exception nil input)) ([resultWrapper2078697 input] (clojure.core/let [rawinput2078696 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078698 {"Message" (rawinput2078696 "Message")}] (clojure.core/cond-> {} (letvar2078698 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078698 ["Message"])))))))

(clojure.core/defn- response-invalid-allowed-pattern-exception ([input] (response-invalid-allowed-pattern-exception nil input)) ([resultWrapper2078700 input] (clojure.core/let [rawinput2078699 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078701 {"message" (rawinput2078699 "message")}] (clojure.core/cond-> {} (letvar2078701 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078701 ["message"])))))))

(clojure.core/defn- response-invalid-aggregator-exception ([input] (response-invalid-aggregator-exception nil input)) ([resultWrapper2078703 input] (clojure.core/let [rawinput2078702 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078704 {"Message" (rawinput2078702 "Message")}] (clojure.core/cond-> {} (letvar2078704 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078704 ["Message"])))))))

(clojure.core/defn- response-get-service-setting-result ([input] (response-get-service-setting-result nil input)) ([resultWrapper2078706 input] (clojure.core/let [rawinput2078705 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078707 {"ServiceSetting" (rawinput2078705 "ServiceSetting")}] (clojure.core/cond-> {} (letvar2078707 "ServiceSetting") (clojure.core/assoc :service-setting (deser-service-setting (clojure.core/get-in letvar2078707 ["ServiceSetting"])))))))

(clojure.core/defn- response-invocation-does-not-exist ([input] (response-invocation-does-not-exist nil input)) ([resultWrapper2078709 input] (clojure.core/let [rawinput2078708 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078710 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-patch-baselines-result ([input] (response-describe-patch-baselines-result nil input)) ([resultWrapper2078712 input] (clojure.core/let [rawinput2078711 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078713 {"BaselineIdentities" (rawinput2078711 "BaselineIdentities"), "NextToken" (rawinput2078711 "NextToken")}] (clojure.core/cond-> {} (letvar2078713 "BaselineIdentities") (clojure.core/assoc :baseline-identities (deser-patch-baseline-identity-list (clojure.core/get-in letvar2078713 ["BaselineIdentities"]))) (letvar2078713 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078713 ["NextToken"])))))))

(clojure.core/defn- response-internal-server-error ([input] (response-internal-server-error nil input)) ([resultWrapper2078715 input] (clojure.core/let [rawinput2078714 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078716 {"Message" (rawinput2078714 "Message")}] (clojure.core/cond-> {} (letvar2078716 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078716 ["Message"])))))))

(clojure.core/defn- response-delete-maintenance-window-result ([input] (response-delete-maintenance-window-result nil input)) ([resultWrapper2078718 input] (clojure.core/let [rawinput2078717 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078719 {"WindowId" (rawinput2078717 "WindowId")}] (clojure.core/cond-> {} (letvar2078719 "WindowId") (clojure.core/assoc :window-id (deser-maintenance-window-id (clojure.core/get-in letvar2078719 ["WindowId"])))))))

(clojure.core/defn- response-describe-maintenance-window-execution-tasks-result ([input] (response-describe-maintenance-window-execution-tasks-result nil input)) ([resultWrapper2078721 input] (clojure.core/let [rawinput2078720 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078722 {"WindowExecutionTaskIdentities" (rawinput2078720 "WindowExecutionTaskIdentities"), "NextToken" (rawinput2078720 "NextToken")}] (clojure.core/cond-> {} (letvar2078722 "WindowExecutionTaskIdentities") (clojure.core/assoc :window-execution-task-identities (deser-maintenance-window-execution-task-identity-list (clojure.core/get-in letvar2078722 ["WindowExecutionTaskIdentities"]))) (letvar2078722 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078722 ["NextToken"])))))))

(clojure.core/defn- response-get-parameter-history-result ([input] (response-get-parameter-history-result nil input)) ([resultWrapper2078724 input] (clojure.core/let [rawinput2078723 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078725 {"Parameters" (rawinput2078723 "Parameters"), "NextToken" (rawinput2078723 "NextToken")}] (clojure.core/cond-> {} (letvar2078725 "Parameters") (clojure.core/assoc :parameters (deser-parameter-history-list (clojure.core/get-in letvar2078725 ["Parameters"]))) (letvar2078725 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078725 ["NextToken"])))))))

(clojure.core/defn- response-service-setting-not-found ([input] (response-service-setting-not-found nil input)) ([resultWrapper2078727 input] (clojure.core/let [rawinput2078726 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078728 {"Message" (rawinput2078726 "Message")}] (clojure.core/cond-> {} (letvar2078728 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078728 ["Message"])))))))

(clojure.core/defn- response-describe-maintenance-window-schedule-result ([input] (response-describe-maintenance-window-schedule-result nil input)) ([resultWrapper2078730 input] (clojure.core/let [rawinput2078729 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078731 {"ScheduledWindowExecutions" (rawinput2078729 "ScheduledWindowExecutions"), "NextToken" (rawinput2078729 "NextToken")}] (clojure.core/cond-> {} (letvar2078731 "ScheduledWindowExecutions") (clojure.core/assoc :scheduled-window-executions (deser-scheduled-window-execution-list (clojure.core/get-in letvar2078731 ["ScheduledWindowExecutions"]))) (letvar2078731 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078731 ["NextToken"])))))))

(clojure.core/defn- response-describe-instance-information-result ([input] (response-describe-instance-information-result nil input)) ([resultWrapper2078733 input] (clojure.core/let [rawinput2078732 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078734 {"InstanceInformationList" (rawinput2078732 "InstanceInformationList"), "NextToken" (rawinput2078732 "NextToken")}] (clojure.core/cond-> {} (letvar2078734 "InstanceInformationList") (clojure.core/assoc :instance-information-list (deser-instance-information-list (clojure.core/get-in letvar2078734 ["InstanceInformationList"]))) (letvar2078734 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078734 ["NextToken"])))))))

(clojure.core/defn- response-invalid-instance-id ([input] (response-invalid-instance-id nil input)) ([resultWrapper2078736 input] (clojure.core/let [rawinput2078735 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078737 {"Message" (rawinput2078735 "Message")}] (clojure.core/cond-> {} (letvar2078737 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078737 ["Message"])))))))

(clojure.core/defn- response-invalid-permission-type ([input] (response-invalid-permission-type nil input)) ([resultWrapper2078739 input] (clojure.core/let [rawinput2078738 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078740 {"Message" (rawinput2078738 "Message")}] (clojure.core/cond-> {} (letvar2078740 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078740 ["Message"])))))))

(clojure.core/defn- response-invalid-update ([input] (response-invalid-update nil input)) ([resultWrapper2078742 input] (clojure.core/let [rawinput2078741 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078743 {"Message" (rawinput2078741 "Message")}] (clojure.core/cond-> {} (letvar2078743 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078743 ["Message"])))))))

(clojure.core/defn- response-invalid-output-location ([input] (response-invalid-output-location nil input)) ([resultWrapper2078745 input] (clojure.core/let [rawinput2078744 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078746 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-deregister-managed-instance-result ([input] (response-deregister-managed-instance-result nil input)) ([resultWrapper2078748 input] (clojure.core/let [rawinput2078747 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078749 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-effective-instance-associations-result ([input] (response-describe-effective-instance-associations-result nil input)) ([resultWrapper2078751 input] (clojure.core/let [rawinput2078750 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078752 {"Associations" (rawinput2078750 "Associations"), "NextToken" (rawinput2078750 "NextToken")}] (clojure.core/cond-> {} (letvar2078752 "Associations") (clojure.core/assoc :associations (deser-instance-association-list (clojure.core/get-in letvar2078752 ["Associations"]))) (letvar2078752 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078752 ["NextToken"])))))))

(clojure.core/defn- response-get-command-invocation-result ([input] (response-get-command-invocation-result nil input)) ([resultWrapper2078754 input] (clojure.core/let [rawinput2078753 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078755 {"InstanceId" (rawinput2078753 "InstanceId"), "ExecutionStartDateTime" (rawinput2078753 "ExecutionStartDateTime"), "Comment" (rawinput2078753 "Comment"), "PluginName" (rawinput2078753 "PluginName"), "ExecutionElapsedTime" (rawinput2078753 "ExecutionElapsedTime"), "ResponseCode" (rawinput2078753 "ResponseCode"), "Status" (rawinput2078753 "Status"), "StatusDetails" (rawinput2078753 "StatusDetails"), "StandardOutputContent" (rawinput2078753 "StandardOutputContent"), "CloudWatchOutputConfig" (rawinput2078753 "CloudWatchOutputConfig"), "StandardOutputUrl" (rawinput2078753 "StandardOutputUrl"), "CommandId" (rawinput2078753 "CommandId"), "ExecutionEndDateTime" (rawinput2078753 "ExecutionEndDateTime"), "DocumentName" (rawinput2078753 "DocumentName"), "DocumentVersion" (rawinput2078753 "DocumentVersion"), "StandardErrorUrl" (rawinput2078753 "StandardErrorUrl"), "StandardErrorContent" (rawinput2078753 "StandardErrorContent")}] (clojure.core/cond-> {} (letvar2078755 "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (clojure.core/get-in letvar2078755 ["InstanceId"]))) (letvar2078755 "ExecutionStartDateTime") (clojure.core/assoc :execution-start-date-time (deser-string-date-time (clojure.core/get-in letvar2078755 ["ExecutionStartDateTime"]))) (letvar2078755 "Comment") (clojure.core/assoc :comment (deser-comment (clojure.core/get-in letvar2078755 ["Comment"]))) (letvar2078755 "PluginName") (clojure.core/assoc :plugin-name (deser-command-plugin-name (clojure.core/get-in letvar2078755 ["PluginName"]))) (letvar2078755 "ExecutionElapsedTime") (clojure.core/assoc :execution-elapsed-time (deser-string-date-time (clojure.core/get-in letvar2078755 ["ExecutionElapsedTime"]))) (letvar2078755 "ResponseCode") (clojure.core/assoc :response-code (deser-response-code (clojure.core/get-in letvar2078755 ["ResponseCode"]))) (letvar2078755 "Status") (clojure.core/assoc :status (deser-command-invocation-status (clojure.core/get-in letvar2078755 ["Status"]))) (letvar2078755 "StatusDetails") (clojure.core/assoc :status-details (deser-status-details (clojure.core/get-in letvar2078755 ["StatusDetails"]))) (letvar2078755 "StandardOutputContent") (clojure.core/assoc :standard-output-content (deser-standard-output-content (clojure.core/get-in letvar2078755 ["StandardOutputContent"]))) (letvar2078755 "CloudWatchOutputConfig") (clojure.core/assoc :cloud-watch-output-config (deser-cloud-watch-output-config (clojure.core/get-in letvar2078755 ["CloudWatchOutputConfig"]))) (letvar2078755 "StandardOutputUrl") (clojure.core/assoc :standard-output-url (deser-url (clojure.core/get-in letvar2078755 ["StandardOutputUrl"]))) (letvar2078755 "CommandId") (clojure.core/assoc :command-id (deser-command-id (clojure.core/get-in letvar2078755 ["CommandId"]))) (letvar2078755 "ExecutionEndDateTime") (clojure.core/assoc :execution-end-date-time (deser-string-date-time (clojure.core/get-in letvar2078755 ["ExecutionEndDateTime"]))) (letvar2078755 "DocumentName") (clojure.core/assoc :document-name (deser-document-name (clojure.core/get-in letvar2078755 ["DocumentName"]))) (letvar2078755 "DocumentVersion") (clojure.core/assoc :document-version (deser-document-version (clojure.core/get-in letvar2078755 ["DocumentVersion"]))) (letvar2078755 "StandardErrorUrl") (clojure.core/assoc :standard-error-url (deser-url (clojure.core/get-in letvar2078755 ["StandardErrorUrl"]))) (letvar2078755 "StandardErrorContent") (clojure.core/assoc :standard-error-content (deser-standard-error-content (clojure.core/get-in letvar2078755 ["StandardErrorContent"])))))))

(clojure.core/defn- response-document-version-limit-exceeded ([input] (response-document-version-limit-exceeded nil input)) ([resultWrapper2078757 input] (clojure.core/let [rawinput2078756 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078758 {"Message" (rawinput2078756 "Message")}] (clojure.core/cond-> {} (letvar2078758 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078758 ["Message"])))))))

(clojure.core/defn- response-register-task-with-maintenance-window-result ([input] (response-register-task-with-maintenance-window-result nil input)) ([resultWrapper2078760 input] (clojure.core/let [rawinput2078759 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078761 {"WindowTaskId" (rawinput2078759 "WindowTaskId")}] (clojure.core/cond-> {} (letvar2078761 "WindowTaskId") (clojure.core/assoc :window-task-id (deser-maintenance-window-task-id (clojure.core/get-in letvar2078761 ["WindowTaskId"])))))))

(clojure.core/defn- response-document-already-exists ([input] (response-document-already-exists nil input)) ([resultWrapper2078763 input] (clojure.core/let [rawinput2078762 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078764 {"Message" (rawinput2078762 "Message")}] (clojure.core/cond-> {} (letvar2078764 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078764 ["Message"])))))))

(clojure.core/defn- response-register-default-patch-baseline-result ([input] (response-register-default-patch-baseline-result nil input)) ([resultWrapper2078766 input] (clojure.core/let [rawinput2078765 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078767 {"BaselineId" (rawinput2078765 "BaselineId")}] (clojure.core/cond-> {} (letvar2078767 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078767 ["BaselineId"])))))))

(clojure.core/defn- response-automation-execution-limit-exceeded-exception ([input] (response-automation-execution-limit-exceeded-exception nil input)) ([resultWrapper2078769 input] (clojure.core/let [rawinput2078768 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078770 {"Message" (rawinput2078768 "Message")}] (clojure.core/cond-> {} (letvar2078770 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078770 ["Message"])))))))

(clojure.core/defn- response-describe-inventory-deletions-result ([input] (response-describe-inventory-deletions-result nil input)) ([resultWrapper2078772 input] (clojure.core/let [rawinput2078771 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078773 {"InventoryDeletions" (rawinput2078771 "InventoryDeletions"), "NextToken" (rawinput2078771 "NextToken")}] (clojure.core/cond-> {} (letvar2078773 "InventoryDeletions") (clojure.core/assoc :inventory-deletions (deser-inventory-deletions-list (clojure.core/get-in letvar2078773 ["InventoryDeletions"]))) (letvar2078773 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078773 ["NextToken"])))))))

(clojure.core/defn- response-get-deployable-patch-snapshot-for-instance-result ([input] (response-get-deployable-patch-snapshot-for-instance-result nil input)) ([resultWrapper2078775 input] (clojure.core/let [rawinput2078774 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078776 {"InstanceId" (rawinput2078774 "InstanceId"), "SnapshotId" (rawinput2078774 "SnapshotId"), "SnapshotDownloadUrl" (rawinput2078774 "SnapshotDownloadUrl"), "Product" (rawinput2078774 "Product")}] (clojure.core/cond-> {} (letvar2078776 "InstanceId") (clojure.core/assoc :instance-id (deser-instance-id (clojure.core/get-in letvar2078776 ["InstanceId"]))) (letvar2078776 "SnapshotId") (clojure.core/assoc :snapshot-id (deser-snapshot-id (clojure.core/get-in letvar2078776 ["SnapshotId"]))) (letvar2078776 "SnapshotDownloadUrl") (clojure.core/assoc :snapshot-download-url (deser-snapshot-download-url (clojure.core/get-in letvar2078776 ["SnapshotDownloadUrl"]))) (letvar2078776 "Product") (clojure.core/assoc :product (deser-product (clojure.core/get-in letvar2078776 ["Product"])))))))

(clojure.core/defn- response-send-command-result ([input] (response-send-command-result nil input)) ([resultWrapper2078778 input] (clojure.core/let [rawinput2078777 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078779 {"Command" (rawinput2078777 "Command")}] (clojure.core/cond-> {} (letvar2078779 "Command") (clojure.core/assoc :command (deser-command (clojure.core/get-in letvar2078779 ["Command"])))))))

(clojure.core/defn- response-get-maintenance-window-execution-task-result ([input] (response-get-maintenance-window-execution-task-result nil input)) ([resultWrapper2078781 input] (clojure.core/let [rawinput2078780 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078782 {"TaskExecutionId" (rawinput2078780 "TaskExecutionId"), "ServiceRole" (rawinput2078780 "ServiceRole"), "EndTime" (rawinput2078780 "EndTime"), "Type" (rawinput2078780 "Type"), "StartTime" (rawinput2078780 "StartTime"), "Status" (rawinput2078780 "Status"), "StatusDetails" (rawinput2078780 "StatusDetails"), "Priority" (rawinput2078780 "Priority"), "MaxConcurrency" (rawinput2078780 "MaxConcurrency"), "WindowExecutionId" (rawinput2078780 "WindowExecutionId"), "TaskArn" (rawinput2078780 "TaskArn"), "MaxErrors" (rawinput2078780 "MaxErrors"), "TaskParameters" (rawinput2078780 "TaskParameters")}] (clojure.core/cond-> {} (letvar2078782 "TaskExecutionId") (clojure.core/assoc :task-execution-id (deser-maintenance-window-execution-task-id (clojure.core/get-in letvar2078782 ["TaskExecutionId"]))) (letvar2078782 "ServiceRole") (clojure.core/assoc :service-role (deser-service-role (clojure.core/get-in letvar2078782 ["ServiceRole"]))) (letvar2078782 "EndTime") (clojure.core/assoc :end-time (deser-date-time (clojure.core/get-in letvar2078782 ["EndTime"]))) (letvar2078782 "Type") (clojure.core/assoc :type (deser-maintenance-window-task-type (clojure.core/get-in letvar2078782 ["Type"]))) (letvar2078782 "StartTime") (clojure.core/assoc :start-time (deser-date-time (clojure.core/get-in letvar2078782 ["StartTime"]))) (letvar2078782 "Status") (clojure.core/assoc :status (deser-maintenance-window-execution-status (clojure.core/get-in letvar2078782 ["Status"]))) (letvar2078782 "StatusDetails") (clojure.core/assoc :status-details (deser-maintenance-window-execution-status-details (clojure.core/get-in letvar2078782 ["StatusDetails"]))) (letvar2078782 "Priority") (clojure.core/assoc :priority (deser-maintenance-window-task-priority (clojure.core/get-in letvar2078782 ["Priority"]))) (letvar2078782 "MaxConcurrency") (clojure.core/assoc :max-concurrency (deser-max-concurrency (clojure.core/get-in letvar2078782 ["MaxConcurrency"]))) (letvar2078782 "WindowExecutionId") (clojure.core/assoc :window-execution-id (deser-maintenance-window-execution-id (clojure.core/get-in letvar2078782 ["WindowExecutionId"]))) (letvar2078782 "TaskArn") (clojure.core/assoc :task-arn (deser-maintenance-window-task-arn (clojure.core/get-in letvar2078782 ["TaskArn"]))) (letvar2078782 "MaxErrors") (clojure.core/assoc :max-errors (deser-max-errors (clojure.core/get-in letvar2078782 ["MaxErrors"]))) (letvar2078782 "TaskParameters") (clojure.core/assoc :task-parameters (deser-maintenance-window-task-parameters-list (clojure.core/get-in letvar2078782 ["TaskParameters"])))))))

(clojure.core/defn- response-item-size-limit-exceeded-exception ([input] (response-item-size-limit-exceeded-exception nil input)) ([resultWrapper2078784 input] (clojure.core/let [rawinput2078783 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078785 {"TypeName" (rawinput2078783 "TypeName"), "Message" (rawinput2078783 "Message")}] (clojure.core/cond-> {} (letvar2078785 "TypeName") (clojure.core/assoc :type-name (deser-inventory-item-type-name (clojure.core/get-in letvar2078785 ["TypeName"]))) (letvar2078785 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078785 ["Message"])))))))

(clojure.core/defn- response-list-document-versions-result ([input] (response-list-document-versions-result nil input)) ([resultWrapper2078787 input] (clojure.core/let [rawinput2078786 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078788 {"DocumentVersions" (rawinput2078786 "DocumentVersions"), "NextToken" (rawinput2078786 "NextToken")}] (clojure.core/cond-> {} (letvar2078788 "DocumentVersions") (clojure.core/assoc :document-versions (deser-document-version-list (clojure.core/get-in letvar2078788 ["DocumentVersions"]))) (letvar2078788 "NextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar2078788 ["NextToken"])))))))

(clojure.core/defn- response-deregister-patch-baseline-for-patch-group-result ([input] (response-deregister-patch-baseline-for-patch-group-result nil input)) ([resultWrapper2078790 input] (clojure.core/let [rawinput2078789 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078791 {"BaselineId" (rawinput2078789 "BaselineId"), "PatchGroup" (rawinput2078789 "PatchGroup")}] (clojure.core/cond-> {} (letvar2078791 "BaselineId") (clojure.core/assoc :baseline-id (deser-baseline-id (clojure.core/get-in letvar2078791 ["BaselineId"]))) (letvar2078791 "PatchGroup") (clojure.core/assoc :patch-group (deser-patch-group (clojure.core/get-in letvar2078791 ["PatchGroup"])))))))

(clojure.core/defn- response-invalid-next-token ([input] (response-invalid-next-token nil input)) ([resultWrapper2078793 input] (clojure.core/let [rawinput2078792 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078794 {"Message" (rawinput2078792 "Message")}] (clojure.core/cond-> {} (letvar2078794 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078794 ["Message"])))))))

(clojure.core/defn- response-update-managed-instance-role-result ([input] (response-update-managed-instance-role-result nil input)) ([resultWrapper2078796 input] (clojure.core/let [rawinput2078795 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078797 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-add-tags-to-resource-result ([input] (response-add-tags-to-resource-result nil input)) ([resultWrapper2078799 input] (clojure.core/let [rawinput2078798 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078800 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-document-schema-version ([input] (response-invalid-document-schema-version nil input)) ([resultWrapper2078802 input] (clojure.core/let [rawinput2078801 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078803 {"Message" (rawinput2078801 "Message")}] (clojure.core/cond-> {} (letvar2078803 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078803 ["Message"])))))))

(clojure.core/defn- response-modify-document-permission-response ([input] (response-modify-document-permission-response nil input)) ([resultWrapper2078805 input] (clojure.core/let [rawinput2078804 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078806 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-parameter-version-not-found ([input] (response-parameter-version-not-found nil input)) ([resultWrapper2078808 input] (clojure.core/let [rawinput2078807 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078809 {"message" (rawinput2078807 "message")}] (clojure.core/cond-> {} (letvar2078809 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar2078809 ["message"])))))))

(clojure.core/defn- response-delete-parameters-result ([input] (response-delete-parameters-result nil input)) ([resultWrapper2078811 input] (clojure.core/let [rawinput2078810 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078812 {"DeletedParameters" (rawinput2078810 "DeletedParameters"), "InvalidParameters" (rawinput2078810 "InvalidParameters")}] (clojure.core/cond-> {} (letvar2078812 "DeletedParameters") (clojure.core/assoc :deleted-parameters (deser-parameter-name-list (clojure.core/get-in letvar2078812 ["DeletedParameters"]))) (letvar2078812 "InvalidParameters") (clojure.core/assoc :invalid-parameters (deser-parameter-name-list (clojure.core/get-in letvar2078812 ["InvalidParameters"])))))))

(clojure.core/defn- response-resource-data-sync-not-found-exception ([input] (response-resource-data-sync-not-found-exception nil input)) ([resultWrapper2078814 input] (clojure.core/let [rawinput2078813 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar2078815 {"SyncName" (rawinput2078813 "SyncName")}] (clojure.core/cond-> {} (letvar2078815 "SyncName") (clojure.core/assoc :sync-name (deser-resource-data-sync-name (clojure.core/get-in letvar2078815 ["SyncName"])))))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-string-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-delete-inventory-parameters-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-delete-inventory-parameters-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-delete-inventory-parameters-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-tags-for-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/tag-list]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/priority (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/replace (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-maintenance-window-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/window-id :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/window-task-id] :opt-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/service-role-arn :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/priority :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/logging-info :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/task-arn :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/description :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/replace :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/task-parameters :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/name :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-request/task-invocation-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-automation-status-update-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-automation-status-update-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-automation-status-update-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/string-date-time (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([\-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d(?!:))?)?(\17[0-5]\d([\.,]\d)?)?([zZ]|([\-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-step-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-step-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.automation-step-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/key-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-key-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/labels (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-label-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/last-modified-user (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-history/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-history (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-history/type :portkey.aws.ssm.-2014-11-06.parameter-history/last-modified-date :portkey.aws.ssm.-2014-11-06.parameter-history/key-id :portkey.aws.ssm.-2014-11-06.parameter-history/value :portkey.aws.ssm.-2014-11-06/allowed-pattern :portkey.aws.ssm.-2014-11-06.parameter-history/description :portkey.aws.ssm.-2014-11-06.parameter-history/labels :portkey.aws.ssm.-2014-11-06.parameter-history/last-modified-user :portkey.aws.ssm.-2014-11-06.parameter-history/version :portkey.aws.ssm.-2014-11-06.parameter-history/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachments-source-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/attachments-source :min-count 0 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/stop-automation-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-entity/id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-result-entity-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-entity/data (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-result-item-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-result-entity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-result-entity/id :portkey.aws.ssm.-2014-11-06.inventory-result-entity/data]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-map (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/target-map-key :portkey.aws.ssm.-2014-11-06/target-map-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-plugin-output (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 2500))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-type-count-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-type-count-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.compliance-type-count-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.non-compliant-summary/non-compliant-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/non-compliant-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.non-compliant-summary/non-compliant-count :portkey.aws.ssm.-2014-11-06/severity-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-deployable-patch-snapshot-for-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/snapshot-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-resource-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-compliance-data-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-compliance-data))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-result/window-identities (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-result/window-identities :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-association-execution-targets-request/execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-association-execution-targets-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-association-execution-targets-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06.describe-association-execution-targets-request/execution-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-association-execution-targets-request/filters :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-filter-value-set (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-information-filter-value :min-count 1 :max-count 100))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-id :min-count 0 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-parameter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 30))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 150))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-activation/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-activation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-activation/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/dry-run clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/approve-after-days (clojure.spec.alpha/int-in 0 100))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-executions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-request/window-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/string-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/string))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-document-content/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-document-content (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-document-content/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-run-command-parameters/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-run-command-parameters/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-run-command-parameters/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-run-command-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-run-command-parameters/service-role-arn :portkey.aws.ssm.-2014-11-06/comment :portkey.aws.ssm.-2014-11-06/timeout-seconds :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06.maintenance-window-run-command-parameters/output-s-3-bucket-name :portkey.aws.ssm.-2014-11-06/notification-config :portkey.aws.ssm.-2014-11-06/document-hash :portkey.aws.ssm.-2014-11-06.maintenance-window-run-command-parameters/output-s-3-key-prefix :portkey.aws.ssm.-2014-11-06/document-hash-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-definition-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-definition-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.automation-definition-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/priority (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-task-with-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/window-id :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-arn :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-type :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors] :opt-un [:portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/service-role-arn :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/priority :portkey.aws.ssm.-2014-11-06/logging-info :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/description :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-parameters :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/name :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-request/task-invocation-parameters :portkey.aws.ssm.-2014-11-06/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-version-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-version-info :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachment-information/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-information (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.attachment-information/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-filter-key #{"AutomationType" "StartTimeBefore" "ParentExecutionId" :automation-type :document-name-prefix :parent-execution-id :start-time-before "StartTimeAfter" "CurrentAction" :execution-status "ExecutionId" :current-action :execution-id "ExecutionStatus" "DocumentNamePrefix" :start-time-after})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/output-source-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameter-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/parameter]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.label-parameter-version-result/invalid-labels (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-label-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/label-parameter-version-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.label-parameter-version-result/invalid-labels]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-content (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-available-patches-result/patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-available-patches-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-available-patches-result/patches :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-type #{:cross-account "Local" :local "CrossAccount"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-filter-value :min-count 1 :max-count 40))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"([$]LATEST)|([1-9][0-9]*)" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-execution-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/priority (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-task/service-role-arn :portkey.aws.ssm.-2014-11-06.maintenance-window-task/window-id :portkey.aws.ssm.-2014-11-06.maintenance-window-task/type :portkey.aws.ssm.-2014-11-06.maintenance-window-task/priority :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/logging-info :portkey.aws.ssm.-2014-11-06.maintenance-window-task/task-arn :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.maintenance-window-task/description :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.maintenance-window-task/window-task-id :portkey.aws.ssm.-2014-11-06.maintenance-window-task/task-parameters :portkey.aws.ssm.-2014-11-06.maintenance-window-task/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-maps (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/target-map :min-count 0 :max-count 300))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-invocation-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/command-invocation))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-severity (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/automation-execution-metadata))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-info/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-info/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-info/created-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-info/is-default-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-info/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-info/status-information (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-status-information))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-version-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-version-info/name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.document-version-info/version-name :portkey.aws.ssm.-2014-11-06.document-version-info/created-date :portkey.aws.ssm.-2014-11-06.document-version-info/is-default-version :portkey.aws.ssm.-2014-11-06/document-format :portkey.aws.ssm.-2014-11-06.document-version-info/status :portkey.aws.ssm.-2014-11-06.document-version-info/status-information]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/service-role (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-enabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-documents-result/document-identifiers (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-identifier-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-documents-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-documents-result/document-identifiers :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 3 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-description-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-description))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-status #{:timed-out "Failed" "Cancelled" :in-progress "Cancelling" :pending "TimedOut" "Success" :cancelled :success "InProgress" :cancelling "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"(^i-(\w{8}|\w{17})$)|(^mi-\w{17}$)" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-information-filter :min-count 0))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-entry-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-item-entry :min-count 0 :max-count 10000))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-session-request/target (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-session-request/document-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-session-request/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-manager-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/start-session-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.start-session-request/target] :opt-un [:portkey.aws.ssm.-2014-11-06.start-session-request/document-name :portkey.aws.ssm.-2014-11-06.start-session-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-status-information (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-documents-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-key-values-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-documents-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/document-filter-list :portkey.aws.ssm.-2014-11-06.list-documents-request/filters :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-search-max-results (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/step-execution-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/step-execution-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.step-execution-filter/key :portkey.aws.ssm.-2014-11-06.step-execution-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.already-exists-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-type-display-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-group (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameter-history-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameter-history-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameter-history-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-parameter-history-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameter-history-request/with-decryption :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.max-document-size-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/max-document-size-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.max-document-size-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-result/version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-parameter-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.put-parameter-result/version]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-connection-status-request/target (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-connection-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-connection-status-request/target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-action-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^aws:[a-zA-Z]{3,25}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-automation-execution-parameters-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-automation-execution-parameters-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-automation-execution-parameters-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-group-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-group))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-automation-step-executions-result/step-executions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/step-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-automation-step-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-automation-step-executions-result/step-executions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item-entry/id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item-entry/title (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-title))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item-entry/severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item-entry/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item-entry/details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-entry (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.compliance-item-entry/severity :portkey.aws.ssm.-2014-11-06.compliance-item-entry/status] :opt-un [:portkey.aws.ssm.-2014-11-06.compliance-item-entry/id :portkey.aws.ssm.-2014-11-06.compliance-item-entry/title :portkey.aws.ssm.-2014-11-06.compliance-item-entry/details]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-schedule/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-schedule/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.patch-filter/key :portkey.aws.ssm.-2014-11-06.patch-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/notification-event #{:timed-out "Failed" "Cancelled" :in-progress "TimedOut" :all "Success" :cancelled :success "InProgress" "All" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/status-details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/invocation-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/task-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-invocation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/task-execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/end-time :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/start-time :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/parameters :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/status :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/status-details :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/window-execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/invocation-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/window-target-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-result/task-type :portkey.aws.ssm.-2014-11-06/owner-information]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-document-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06.get-document-request/version-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06/document-format]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-information-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information-filter/value-set (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-information-filter-value-set))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.instance-information-filter/key :portkey.aws.ssm.-2014-11-06.instance-information-filter/value-set] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-executions-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-execution))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/too-many-tags-error (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-aggregator/expression (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-aggregator-expression))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-aggregator/aggregators (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-aggregator-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-aggregator/groups (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-group-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-aggregator (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-aggregator/expression :portkey.aws.ssm.-2014-11-06.inventory-aggregator/aggregators :portkey.aws.ssm.-2014-11-06.inventory-aggregator/groups]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-command-invocations-result/command-invocations (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-invocation-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-command-invocations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-command-invocations-result/command-invocations :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-version-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{1,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-request/window-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-status-infos (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-association-status-info))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.hierarchy-type-mismatch-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/hierarchy-type-mismatch-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.hierarchy-type-mismatch-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-orchestrator-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-orchestrator-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.patch-orchestrator-filter/key :portkey.aws.ssm.-2014-11-06.patch-orchestrator-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-service-setting-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-baseline-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-baseline-identity))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-activation-id/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-activation-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-activation-id/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-type #{"StringList" :string-list :string "String" :secure-string "SecureString"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-does-not-exist/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-does-not-exist (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.association-execution-does-not-exist/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-query-operator-type #{:exists "NotEqual" :less-than "BeginWith" "Exists" "Equal" "LessThan" :greater-than "GreaterThan" :not-equal :begin-with :equal})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-string-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-string-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-string-filter/option (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-string-query-option))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-string-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-string-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-string-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.parameter-string-filter/key] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-string-filter/option :portkey.aws.ssm.-2014-11-06.parameter-string-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-activation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/activation-id :portkey.aws.ssm.-2014-11-06/activation-code]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/s-3-region (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 3 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 20))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-classification (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-invalid-configuration-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-invalid-configuration-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-invalid-configuration-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-tasks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-request/window-execution-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-request/task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-request/invocation-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-invocation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-request/window-execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-request/task-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-invocation-request/invocation-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-option-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-option-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-option-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-result/entities (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-result-entity-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-inventory-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-inventory-result/entities :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-filter-key #{:platform-types "DocumentType" :name :document-type "PlatformTypes" "Owner" "Name" :owner})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/schema-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/capture-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-capture-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/entries (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-inventory-entries-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/type-name :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/schema-version :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/capture-time :portkey.aws.ssm.-2014-11-06.list-inventory-entries-result/entries :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/comment (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-invocation-status #{:timed-out "Failed" "Cancelled" :delayed :in-progress "Cancelling" :pending "TimedOut" "Success" :cancelled "Delayed" :success "InProgress" :cancelling "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/last-resource-data-sync-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-resource-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-id :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-key-values-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/document-key-values-filter :min-count 0 :max-count 6))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-document-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.target-not-connected/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-not-connected (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.target-not-connected/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-source/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-source/products (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-product-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-source/configuration (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-configuration))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-source (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.patch-source/name :portkey.aws.ssm.-2014-11-06.patch-source/products :portkey.aws.ssm.-2014-11-06.patch-source/configuration] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-string-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-string-filter))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-automation-signal-request/payload (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/send-automation-signal-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/automation-execution-id :portkey.aws.ssm.-2014-11-06/signal-type] :opt-un [:portkey.aws.ssm.-2014-11-06.send-automation-signal-request/payload]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-identifier/schema-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-identifier/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-identifier/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-identifier/platform-types (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/platform-type-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-identifier/owner (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-owner))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-identifier/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-identifier/schema-version :portkey.aws.ssm.-2014-11-06/document-type :portkey.aws.ssm.-2014-11-06/target-type :portkey.aws.ssm.-2014-11-06.document-identifier/tags :portkey.aws.ssm.-2014-11-06/document-format :portkey.aws.ssm.-2014-11-06.document-identifier/version-name :portkey.aws.ssm.-2014-11-06.document-identifier/platform-types :portkey.aws.ssm.-2014-11-06.document-identifier/owner :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.document-identifier/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-string-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-information-string-filter :min-count 0))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-max-results (clojure.spec.alpha/int-in 1 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-resource-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-search-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-schedule-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/window-id :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/resource-type :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-label-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-label :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-managed-instance-request/instance-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/managed-instance-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-managed-instance-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.deregister-managed-instance-request/instance-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-filter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-filter/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-filter-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.association-execution-filter/key :portkey.aws.ssm.-2014-11-06.association-execution-filter/value :portkey.aws.ssm.-2014-11-06.association-execution-filter/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-filter/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-query-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.inventory-filter/key :portkey.aws.ssm.-2014-11-06.inventory-filter/values] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-filter/type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-type-name-filter (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-max-results (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-not-found/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-not-found (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-not-found/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 96))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.progress-counters/total-steps (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.progress-counters/success-steps (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.progress-counters/failed-steps (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.progress-counters/cancelled-steps (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.progress-counters/timed-out-steps (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/progress-counters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.progress-counters/total-steps :portkey.aws.ssm.-2014-11-06.progress-counters/success-steps :portkey.aws.ssm.-2014-11-06.progress-counters/failed-steps :portkey.aws.ssm.-2014-11-06.progress-counters/cancelled-steps :portkey.aws.ssm.-2014-11-06.progress-counters/timed-out-steps]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/ps-parameter-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/account-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/account-id :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-max-results (clojure.spec.alpha/int-in 1 200))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-identity))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter :min-count 0 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.cancel-command-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cancel-command-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/command-id] :opt-un [:portkey.aws.ssm.-2014-11-06.cancel-command-request/instance-ids]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-cutoff (clojure.spec.alpha/int-in 0 23))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/timeout-seconds (clojure.spec.alpha/int-in 30 2592000))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-region (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-compliance-items-result/compliance-items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-compliance-items-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-compliance-items-result/compliance-items :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delivery-timed-out-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-summary-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-summary-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attribute-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/timeout-seconds (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/long))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/response-code (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/step-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/valid-next-steps (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/valid-next-step-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/outputs (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/response (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/failure-message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/inputs (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/normal-string-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/next-step (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/step-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/is-critical (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/step-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/overridden-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/on-failure (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/execution-end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/execution-start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-action-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/is-end (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.step-execution/max-attempts (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.step-execution/timeout-seconds :portkey.aws.ssm.-2014-11-06.step-execution/response-code :portkey.aws.ssm.-2014-11-06.step-execution/step-execution-id :portkey.aws.ssm.-2014-11-06.step-execution/valid-next-steps :portkey.aws.ssm.-2014-11-06.step-execution/outputs :portkey.aws.ssm.-2014-11-06.step-execution/response :portkey.aws.ssm.-2014-11-06.step-execution/failure-message :portkey.aws.ssm.-2014-11-06.step-execution/inputs :portkey.aws.ssm.-2014-11-06.step-execution/next-step :portkey.aws.ssm.-2014-11-06/failure-details :portkey.aws.ssm.-2014-11-06.step-execution/step-status :portkey.aws.ssm.-2014-11-06/target-location :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.step-execution/is-critical :portkey.aws.ssm.-2014-11-06.step-execution/step-name :portkey.aws.ssm.-2014-11-06.step-execution/overridden-parameters :portkey.aws.ssm.-2014-11-06.step-execution/on-failure :portkey.aws.ssm.-2014-11-06.step-execution/execution-end-time :portkey.aws.ssm.-2014-11-06.step-execution/execution-start-time :portkey.aws.ssm.-2014-11-06.step-execution/action :portkey.aws.ssm.-2014-11-06.step-execution/is-end :portkey.aws.ssm.-2014-11-06.step-execution/max-attempts]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/product (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-installed-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameters-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameters-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameters-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameters-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameters-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.parameters-filter/key :portkey.aws.ssm.-2014-11-06.parameters-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/status-additional-info (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/completed-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-string-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-string-filter))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-default-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-awskms-key-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 512)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"arn:.*" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/task-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/status-details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/window-execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/task-ids :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/status :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/status-details :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/start-time :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-result/end-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-inventory-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/last-resource-data-sync-status #{"Failed" :in-progress :successful "InProgress" "Successful" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/error-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/status-message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-filter-option/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-filter-option (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-filter-option/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-effective-patches-for-patch-baseline-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-effective-patches-for-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-effective-patches-for-patch-baseline-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/terminate-session-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/session-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-rule/compliance-level (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-rule/enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-rule (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/patch-filter-group :portkey.aws.ssm.-2014-11-06/approve-after-days] :opt-un [:portkey.aws.ssm.-2014-11-06.patch-rule/compliance-level :portkey.aws.ssm.-2014-11-06.patch-rule/enable-non-security]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/execution-mode #{:interactive "Interactive" "Auto" :auto})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-tags-for-resource-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-type-for-tagging))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-tags-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.list-tags-for-resource-request/resource-type :portkey.aws.ssm.-2014-11-06/resource-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-content-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/duplicate-instance-id (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/priority (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/service-role-arn :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/window-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/priority :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/logging-info :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-arn :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/description :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-type :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/window-task-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-parameters :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/name :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-result/task-invocation-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status #{"SUCCESS" :timed-out "IN_PROGRESS" "TIMED_OUT" :in-progress "CANCELLING" :skipped-overlapping :pending "SKIPPED_OVERLAPPING" "PENDING" :cancelled :success "FAILED" "CANCELLED" :cancelling :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/key-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/tag-key))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/output-source (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/output-source-id :portkey.aws.ssm.-2014-11-06/output-source-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-task-invocations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/window-execution-id :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/task-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-service-setting-request/setting-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-service-setting-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-service-setting-request/setting-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-entry (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/attribute-name :portkey.aws.ssm.-2014-11-06/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/key-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-key-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/last-modified-user (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-metadata/version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-metadata/name :portkey.aws.ssm.-2014-11-06.parameter-metadata/type :portkey.aws.ssm.-2014-11-06.parameter-metadata/key-id :portkey.aws.ssm.-2014-11-06.parameter-metadata/last-modified-date :portkey.aws.ssm.-2014-11-06.parameter-metadata/last-modified-user :portkey.aws.ssm.-2014-11-06.parameter-metadata/description :portkey.aws.ssm.-2014-11-06/allowed-pattern :portkey.aws.ssm.-2014-11-06.parameter-metadata/version]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-resource-id (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.too-many-updates/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/too-many-updates (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.too-many-updates/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-compliance-summaries-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-compliance-summaries-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-compliance-summaries-request/filters :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-targets-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-execution-target))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/response-finish-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-plugin-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/standard-output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/output (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-plugin-output))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-plugin-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/standard-error-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-plugin/response-start-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-plugin (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.command-plugin/response-finish-date-time :portkey.aws.ssm.-2014-11-06/response-code :portkey.aws.ssm.-2014-11-06.command-plugin/output-s-3-bucket-name :portkey.aws.ssm.-2014-11-06.command-plugin/status :portkey.aws.ssm.-2014-11-06/status-details :portkey.aws.ssm.-2014-11-06.command-plugin/standard-output-url :portkey.aws.ssm.-2014-11-06.command-plugin/output-s-3-key-prefix :portkey.aws.ssm.-2014-11-06.command-plugin/output-s-3-region :portkey.aws.ssm.-2014-11-06.command-plugin/output :portkey.aws.ssm.-2014-11-06.command-plugin/name :portkey.aws.ssm.-2014-11-06.command-plugin/standard-error-url :portkey.aws.ssm.-2014-11-06.command-plugin/response-start-date-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cloud-watch-log-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 512)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"[\.\-_/#A-Za-z0-9]+" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameters (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/parameter-name :portkey.aws.ssm.-2014-11-06/parameter-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-filter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/response-code clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.label-parameter-version-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.label-parameter-version-request/parameter-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.label-parameter-version-request/labels (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-label-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/label-parameter-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.label-parameter-version-request/name :portkey.aws.ssm.-2014-11-06.label-parameter-version-request/labels] :opt-un [:portkey.aws.ssm.-2014-11-06.label-parameter-version-request/parameter-version]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-patch-group-state-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/patch-group] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameter-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameter-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameter-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-parameter-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameter-request/with-decryption]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-type-name-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-type-name-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-type-name-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-identity))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.unsupported-parameter-type/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/unsupported-parameter-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.unsupported-parameter-type/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-output-url (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/s-3-output-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-compliance-items-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-format #{"JsonSerDe" :json-ser-de})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachments-source-key #{:source-url "SourceUrl"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-type #{"Automation" :package "Package" :command :policy "Command" :automation "Policy" "Session" :session})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.item-content-mismatch-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.item-content-mismatch-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/item-content-mismatch-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.item-content-mismatch-exception/type-name :portkey.aws.ssm.-2014-11-06.item-content-mismatch-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameters-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution/execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution/created-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06.association-execution/execution-id :portkey.aws.ssm.-2014-11-06.association-execution/status :portkey.aws.ssm.-2014-11-06.association-execution/detailed-status :portkey.aws.ssm.-2014-11-06.association-execution/created-time :portkey.aws.ssm.-2014-11-06.association-execution/last-execution-date :portkey.aws.ssm.-2014-11-06/resource-count-by-status]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-parameter/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-parameter/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-parameter/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-parameter-descrption))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-parameter/default-value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-parameter-default-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-parameter/name :portkey.aws.ssm.-2014-11-06.document-parameter/type :portkey.aws.ssm.-2014-11-06.document-parameter/description :portkey.aws.ssm.-2014-11-06.document-parameter/default-value]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-permission-limit/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-permission-limit (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-permission-limit/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.severity-summary/critical-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.severity-summary/high-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.severity-summary/medium-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.severity-summary/low-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.severity-summary/informational-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.severity-summary/unspecified-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/severity-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.severity-summary/critical-count :portkey.aws.ssm.-2014-11-06.severity-summary/high-count :portkey.aws.ssm.-2014-11-06.severity-summary/medium-count :portkey.aws.ssm.-2014-11-06.severity-summary/low-count :portkey.aws.ssm.-2014-11-06.severity-summary/informational-count :portkey.aws.ssm.-2014-11-06.severity-summary/unspecified-count]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-inventory-schema-max-results (clojure.spec.alpha/int-in 50 200))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/automation-execution-filter :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.hierarchy-level-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/hierarchy-level-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.hierarchy-level-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity-for-target/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity-for-target/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-identity-for-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-identity-for-target/window-id :portkey.aws.ssm.-2014-11-06.maintenance-window-identity-for-target/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-deployment-status #{:explicit-approved :explicit-rejected :approved :pending-approval "APPROVED" "PENDING_APPROVAL" "EXPLICIT_APPROVED" "EXPLICIT_REJECTED"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/session-filter :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/parent-automation-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/current-step-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/executed-by (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/current-action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/mode (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/execution-mode))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/outputs (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/failure-message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/step-executions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/step-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/target (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/target-parameter-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/execution-end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/execution-start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution/step-executions-truncated (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/target-maps :portkey.aws.ssm.-2014-11-06/progress-counters :portkey.aws.ssm.-2014-11-06.automation-execution/parameters :portkey.aws.ssm.-2014-11-06.automation-execution/parent-automation-execution-id :portkey.aws.ssm.-2014-11-06.automation-execution/current-step-name :portkey.aws.ssm.-2014-11-06.automation-execution/executed-by :portkey.aws.ssm.-2014-11-06.automation-execution/current-action :portkey.aws.ssm.-2014-11-06/target-locations :portkey.aws.ssm.-2014-11-06.automation-execution/mode :portkey.aws.ssm.-2014-11-06.automation-execution/outputs :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/resolved-targets :portkey.aws.ssm.-2014-11-06.automation-execution/failure-message :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.automation-execution/step-executions :portkey.aws.ssm.-2014-11-06/automation-execution-status :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/document-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.automation-execution/target :portkey.aws.ssm.-2014-11-06.automation-execution/target-parameter-name :portkey.aws.ssm.-2014-11-06.automation-execution/execution-end-time :portkey.aws.ssm.-2014-11-06.automation-execution/execution-start-time :portkey.aws.ssm.-2014-11-06/automation-execution-id :portkey.aws.ssm.-2014-11-06.automation-execution/step-executions-truncated]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-content-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-association-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-for-target-result/window-identities (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-windows-for-target-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-for-target-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-for-target-result/window-identities :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameters-filter-key #{"Type" :key-id :name "KeyId" :type "Name"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.unsupported-inventory-item-context-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.unsupported-inventory-item-context-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/unsupported-inventory-item-context-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.unsupported-inventory-item-context-exception/type-name :portkey.aws.ssm.-2014-11-06.unsupported-inventory-item-context-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.cancel-maintenance-window-execution-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cancel-maintenance-window-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.cancel-maintenance-window-execution-result/window-execution-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-batch-result/successful (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-description-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-batch-result/failed (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/failed-create-association-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-association-batch-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.create-association-batch-result/successful :portkey.aws.ssm.-2014-11-06.create-association-batch-result/failed]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-group/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-group-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-group/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-group (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.inventory-group/name :portkey.aws.ssm.-2014-11-06.inventory-group/filters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-title (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 500))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-key-values-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/document-key-values-filter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-key-values-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-key-values-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-key-values-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-key-values-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-key-values-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-key-values-filter/key :portkey.aws.ssm.-2014-11-06.document-key-values-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-targets-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-request/window-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/end-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/enabled (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/duration (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/cutoff (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/replace (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/schedule (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/start-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/window-id] :opt-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/allow-unassociated-targets :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/end-date :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/enabled :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/description :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/duration :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/cutoff :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/replace :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/schedule :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/name :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/start-date :portkey.aws.ssm.-2014-11-06.update-maintenance-window-request/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-result/invalid-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameters-result/parameters :portkey.aws.ssm.-2014-11-06.get-parameters-result/invalid-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/tag-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-filter/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-filter/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-association))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-execution))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/platform-type #{:windows "Windows" "Linux" :linux})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-name-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/ps-parameter-name :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-aggregated-association-overview/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-aggregated-association-overview (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.instance-aggregated-association-overview/detailed-status :portkey.aws.ssm.-2014-11-06/instance-association-status-aggregated-count]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/end-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/enabled (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/next-execution-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/duration (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/created-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/cutoff (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/schedule (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/start-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/window-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/allow-unassociated-targets :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/end-date :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/enabled :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/next-execution-time :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/description :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/duration :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/created-date :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/cutoff :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/modified-date :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/schedule :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/name :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/start-date :portkey.aws.ssm.-2014-11-06.get-maintenance-window-result/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 200)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^\/[\w\.\-\:\/]*$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-document-request/content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-document-request/attachments (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachments-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-document-request/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-document-request/content :portkey.aws.ssm.-2014-11-06.create-document-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06.create-document-request/attachments :portkey.aws.ssm.-2014-11-06.create-document-request/version-name :portkey.aws.ssm.-2014-11-06/document-type :portkey.aws.ssm.-2014-11-06/document-format :portkey.aws.ssm.-2014-11-06/target-type :portkey.aws.ssm.-2014-11-06.create-document-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-prefix (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-resource-data-sync-request/sync-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-resource-data-sync-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.delete-resource-data-sync-request/sync-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-request/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-task-from-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-request/window-id :portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-request/window-task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.total-size-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/total-size-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.total-size-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.target-in-use-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-in-use-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.target-in-use-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-in-use-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-in-use-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-in-use-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/reset-service-setting-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/service-setting]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-deletion-id-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-deletion-id-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-deletion-id-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.notification-config/notification-events (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/notification-event-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/notification-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/notification-arn :portkey.aws.ssm.-2014-11-06.notification-config/notification-events :portkey.aws.ssm.-2014-11-06/notification-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/log-file (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/parent-automation-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/current-step-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/executed-by (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/current-action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/mode (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/execution-mode))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/outputs (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/failure-message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/target (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/target-parameter-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/execution-end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/execution-start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/automation-type :portkey.aws.ssm.-2014-11-06/target-maps :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/log-file :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/parent-automation-execution-id :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/current-step-name :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/executed-by :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/current-action :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/mode :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/outputs :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/resolved-targets :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/failure-message :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/automation-execution-status :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/document-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/target :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/target-parameter-name :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/execution-end-time :portkey.aws.ssm.-2014-11-06.automation-execution-metadata/execution-start-time :portkey.aws.ssm.-2014-11-06/automation-execution-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/s-3-bucket-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 3 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 63))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/ping-status #{:inactive "Inactive" "ConnectionLost" :online :connection-lost "Online"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-association-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary-items (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-for-target-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-for-target-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-search-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-for-target-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-for-target-request/resource-type] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-for-target-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-result-entity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-result-entity))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-filter :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-result/window-executions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-executions-result/window-executions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameters-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameters-filter-value :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item-schema/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item-schema/version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item-schema/attributes (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-attribute-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item-schema/display-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-type-display-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-schema (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.inventory-item-schema/type-name :portkey.aws.ssm.-2014-11-06.inventory-item-schema/attributes] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-item-schema/version :portkey.aws.ssm.-2014-11-06.inventory-item-schema/display-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/iam-role (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/end-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/duration (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/cutoff (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/schedule (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/start-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/name :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/schedule :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/duration :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/cutoff :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/allow-unassociated-targets] :opt-un [:portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/end-date :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/tags :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/description :portkey.aws.ssm.-2014-11-06/client-token :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/start-date :portkey.aws.ssm.-2014-11-06.create-maintenance-window-request/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-severity #{"INFORMATIONAL" :unspecified "CRITICAL" :medium "LOW" :high :critical "HIGH" :low "UNSPECIFIED" :informational "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-state #{"Active" :history "History" :active})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-patch-baseline-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/patch-group]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/notification-type #{:command :invocation "Command" "Invocation"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/deletion-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/deletion-start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-start-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/last-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/last-status-message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-last-status-message))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/deletion-summary (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/last-status-update-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-last-status-update-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-status-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/deletion-id :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/type-name :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/deletion-start-time :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/last-status :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/last-status-message :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/deletion-summary :portkey.aws.ssm.-2014-11-06.inventory-deletion-status-item/last-status-update-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-payload clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.result-attribute/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/result-attribute (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.result-attribute/type-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1600))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-qualifier (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-compliance-data/title (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-title))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-compliance-data/kb-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-kb-number))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-compliance-data/classification (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-classification))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-compliance-data/severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-compliance-data/state (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-data-state))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-compliance-data/installed-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-compliance-data (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.patch-compliance-data/title :portkey.aws.ssm.-2014-11-06.patch-compliance-data/kb-id :portkey.aws.ssm.-2014-11-06.patch-compliance-data/classification :portkey.aws.ssm.-2014-11-06.patch-compliance-data/severity :portkey.aws.ssm.-2014-11-06.patch-compliance-data/state :portkey.aws.ssm.-2014-11-06.patch-compliance-data/installed-time] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-map-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletions-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-deletion-status-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-msrc-number (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.idempotent-parameter-mismatch/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/idempotent-parameter-mismatch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.idempotent-parameter-mismatch/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-missing-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.scheduled-window-execution/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.scheduled-window-execution/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.scheduled-window-execution/execution-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/scheduled-window-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.scheduled-window-execution/window-id :portkey.aws.ssm.-2014-11-06.scheduled-window-execution/name :portkey.aws.ssm.-2014-11-06.scheduled-window-execution/execution-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-status/date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-status/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-status/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-message))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-status/additional-info (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-additional-info))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-status (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.association-status/date :portkey.aws.ssm.-2014-11-06.association-status/name :portkey.aws.ssm.-2014-11-06.association-status/message] :opt-un [:portkey.aws.ssm.-2014-11-06.association-status/additional-info]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-parameter-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-resource-type (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-document-permission-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-document-permission-request/permission-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-permission-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-document-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-document-permission-request/name :portkey.aws.ssm.-2014-11-06.describe-document-permission-request/permission-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/start-automation-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/automation-execution-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-parameter-descrption (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-associations-status-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-association-status-infos :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/snapshot-download-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-resource-data-sync-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-tasks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-request/window-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-resource-compliance-summaries-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-resource-compliance-summaries-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-resource-compliance-summaries-request/filters :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-already-exists (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-attribute-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-association-status-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-association-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-association-status-request/name :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/association-status] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-locations (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/target-location :min-count 1 :max-count 100))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/start-associations-once-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-parameters-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameters-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-parameters-request/parameter-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-parameters-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-parameters-request/filters :portkey.aws.ssm.-2014-11-06.describe-parameters-request/parameter-filters :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-patch-baseline-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/patch-group] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/priority (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/task-invocation-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-maintenance-window-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/service-role-arn :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/window-id :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/priority :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/logging-info :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/task-arn :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/description :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/window-task-id :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/task-parameters :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/name :portkey.aws.ssm.-2014-11-06.update-maintenance-window-task-result/task-invocation-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-filter-key #{"InstanceId" :association-id "AssociationId" :name :association-name :instance-id "LastExecutedBefore" "AssociationName" :association-status-name "AssociationStatusName" :last-executed-after "Name" :last-executed-before "LastExecutedAfter"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-for-patch-group-result/instance-patch-states (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-patch-states-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-for-patch-group-result/instance-patch-states :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-installed-rejected-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/status-details (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-already-exists/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-already-exists (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-already-exists/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-compliance-summaries-result/compliance-summary-items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-compliance-summaries-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-compliance-summaries-result/compliance-summary-items :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-schema-delete-option #{:delete-schema "DeleteSchema" "DisableSchema" :disable-schema})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-name :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-value-expression))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-baseline-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/baseline-name :portkey.aws.ssm.-2014-11-06/operating-system :portkey.aws.ssm.-2014-11-06/baseline-description :portkey.aws.ssm.-2014-11-06/default-baseline]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-association-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/association-id] :opt-un [:portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/next-token (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/standard-output-content (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 24000))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/session-manager-parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/bucket-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/prefix (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/sync-format (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-format))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/region (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/awskms-key-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-awskms-key-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-destination (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/bucket-name :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/sync-format :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/region] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/prefix :portkey.aws.ssm.-2014-11-06.resource-data-sync-s-3-destination/awskms-key-arn]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/agent-error-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 10))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-owner (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/aggregator-schema-only clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-instance-information-filter-value/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-instance-information-filter-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-instance-information-filter-value/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cloud-watch-output-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/cloud-watch-log-group-name :portkey.aws.ssm.-2014-11-06/cloud-watch-output-enabled]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-parameter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/document-parameter))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-sha-1 (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.cancel-maintenance-window-execution-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cancel-maintenance-window-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.cancel-maintenance-window-execution-request/window-execution-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-string-query-option (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 10))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/connection-status #{:not-connected "Connected" :connected "NotConnected"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-baseline-max-results (clojure.spec.alpha/int-in 1 100))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-version-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/document-version-info :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-default-version-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-default-version-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-document-default-version-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.update-document-default-version-result/description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-metadata))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/default-instance-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-filter-key #{"InstanceIds" "ActivationIds" :platform-types :iam-role "PingStatus" "IamRole" "AgentVersion" "AssociationStatus" :association-status "ResourceType" :instance-ids "PlatformTypes" :resource-type :agent-version :activation-ids :ping-status})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-target-with-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-result/window-target-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.does-not-exist-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/does-not-exist-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.does-not-exist-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-target (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-owner (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/expiration-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.delete-maintenance-window-request/window-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority (clojure.spec.alpha/int-in 0 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-status #{"Failed" "Connected" :disconnected :connecting :connected "Disconnected" :terminating "Connecting" "Terminating" :terminated "Terminated" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.:/]{3,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-inventory-entries-request/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-inventory-entries-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-inventory-entries-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.list-inventory-entries-request/type-name] :opt-un [:portkey.aws.ssm.-2014-11-06.list-inventory-entries-request/filters :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.unsupported-platform-type/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/unsupported-platform-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.unsupported-platform-type/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-result-entity-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/effective-patch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/patch :portkey.aws.ssm.-2014-11-06/patch-status]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/max-concurrency (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 7)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([1-9][0-9]*|[1-9][0-9]%|[1-9]%|100%)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patches-result/patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-data-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-patches-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-instance-patches-result/patches :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-filter/key :portkey.aws.ssm.-2014-11-06.maintenance-window-filter/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resolved-targets/parameter-values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/target-parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resolved-targets/truncated (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resolved-targets (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resolved-targets/parameter-values :portkey.aws.ssm.-2014-11-06.resolved-targets/truncated]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-states-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-patch-state :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-start-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-action #{:block "BLOCK" "ALLOW_AS_DEPENDENCY" :allow-as-dependency})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/status-unchanged (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-invocation-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/command-plugins (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-plugin-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/instance-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-tag-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/requested-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/standard-output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/trace-output (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/invocation-trace-output))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-invocation/standard-error-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-invocation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/service-role :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/comment :portkey.aws.ssm.-2014-11-06/notification-config :portkey.aws.ssm.-2014-11-06.command-invocation/status :portkey.aws.ssm.-2014-11-06/status-details :portkey.aws.ssm.-2014-11-06/cloud-watch-output-config :portkey.aws.ssm.-2014-11-06.command-invocation/command-plugins :portkey.aws.ssm.-2014-11-06.command-invocation/instance-name :portkey.aws.ssm.-2014-11-06.command-invocation/requested-date-time :portkey.aws.ssm.-2014-11-06.command-invocation/standard-output-url :portkey.aws.ssm.-2014-11-06.command-invocation/trace-output :portkey.aws.ssm.-2014-11-06/command-id :portkey.aws.ssm.-2014-11-06/document-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.command-invocation/standard-error-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-command-id (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/stop-type #{"Cancel" "Complete" :cancel :complete})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliant-summary/compliant-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-summary-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliant-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.compliant-summary/compliant-count :portkey.aws.ssm.-2014-11-06/severity-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-associations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-filter-list :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/regions (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/region :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cancel-command-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/mode (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/execution-mode))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/document-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/target-parameter-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/client-token (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/idempotency-token))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/start-automation-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.start-automation-execution-request/document-name] :opt-un [:portkey.aws.ssm.-2014-11-06/target-maps :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/parameters :portkey.aws.ssm.-2014-11-06/target-locations :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/mode :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/target-parameter-name :portkey.aws.ssm.-2014-11-06.start-automation-execution-request/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.create-maintenance-window-result/window-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 150))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-compliance-max-results (clojure.spec.alpha/int-in 10 100))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-inventory-deletions-request/deletion-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-inventory-deletions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-inventory-deletions-request/deletion-id :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-value :min-count 1 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.automation-execution-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-association-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-association-request/name :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06/association-version]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/signal-type #{:stop-step :approve "Resume" "StopStep" "StartStep" "Approve" :reject :resume :start-step "Reject"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-details (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/sync-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/s-3-destination (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-destination))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-sync-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/last-resource-data-sync-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-successful-sync-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/last-successful-resource-data-sync-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/last-resource-data-sync-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/sync-created-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-created-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-sync-status-message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/last-resource-data-sync-message))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-item/sync-name :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/s-3-destination :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-sync-time :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-successful-sync-time :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-status :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/sync-created-time :portkey.aws.ssm.-2014-11-06.resource-data-sync-item/last-sync-status-message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/cloud-watch-output-enabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patches-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patches-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-patches-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-instance-patches-request/filters :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.describe-instance-patches-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-document/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-document (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-document/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-association-status-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-pattern-mismatch-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-pattern-mismatch-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-pattern-mismatch-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-result-attribute-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-result-attribute-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-result-attribute-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-label (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-installed-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-installed-other-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-installed-rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instances-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-missing-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-failed-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-not-applicable-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/integer))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-patch-group-state-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-installed-patches :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-installed-other-patches :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-installed-rejected-patches :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-missing-patches :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-failed-patches :portkey.aws.ssm.-2014-11-06.describe-patch-group-state-result/instances-with-not-applicable-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/last-update-association-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/overview (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-overview))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/last-successful-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-description/output-location (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.association-description/last-update-association-date :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06.association-description/compliance-severity :portkey.aws.ssm.-2014-11-06.association-description/status :portkey.aws.ssm.-2014-11-06.association-description/overview :portkey.aws.ssm.-2014-11-06.association-description/date :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06.association-description/last-execution-date :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/automation-target-parameter-name :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.association-description/last-successful-execution-date :portkey.aws.ssm.-2014-11-06/schedule-expression :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.association-description/name :portkey.aws.ssm.-2014-11-06.association-description/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-commands-result/commands (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-commands-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-commands-result/commands :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/tag-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/tag :max-count 1000))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/schema-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/hash (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/status-information (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-status-information))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/attachments-information (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-information-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/default-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/description-in-document))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/created-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/platform-types (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/platform-type-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/latest-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/owner (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-owner))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/hash-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-hash-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-description/sha-1 (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-sha-1))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-description/schema-version :portkey.aws.ssm.-2014-11-06.document-description/parameters :portkey.aws.ssm.-2014-11-06/document-type :portkey.aws.ssm.-2014-11-06/target-type :portkey.aws.ssm.-2014-11-06.document-description/tags :portkey.aws.ssm.-2014-11-06.document-description/hash :portkey.aws.ssm.-2014-11-06.document-description/status :portkey.aws.ssm.-2014-11-06.document-description/status-information :portkey.aws.ssm.-2014-11-06.document-description/attachments-information :portkey.aws.ssm.-2014-11-06.document-description/default-version :portkey.aws.ssm.-2014-11-06.document-description/description :portkey.aws.ssm.-2014-11-06.document-description/created-date :portkey.aws.ssm.-2014-11-06/document-format :portkey.aws.ssm.-2014-11-06.document-description/version-name :portkey.aws.ssm.-2014-11-06.document-description/platform-types :portkey.aws.ssm.-2014-11-06.document-description/latest-version :portkey.aws.ssm.-2014-11-06.document-description/owner :portkey.aws.ssm.-2014-11-06.document-description/hash-type :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.document-description/name :portkey.aws.ssm.-2014-11-06.document-description/sha-1]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-target/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-target/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-target/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-target/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-target/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-target/window-id :portkey.aws.ssm.-2014-11-06.maintenance-window-target/window-target-id :portkey.aws.ssm.-2014-11-06.maintenance-window-target/resource-type :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/owner-information :portkey.aws.ssm.-2014-11-06.maintenance-window-target/name :portkey.aws.ssm.-2014-11-06.maintenance-window-target/description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-string-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-string-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-string-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-string-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-string-filter/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-query-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-string-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.compliance-string-filter/key :portkey.aws.ssm.-2014-11-06.compliance-string-filter/values :portkey.aws.ssm.-2014-11-06.compliance-string-filter/type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-last-status-update-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"[A-Za-z0-9_\-]\w+|Custom:[a-zA-Z0-9_\-]\w+" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-id :min-count 0 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-request/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-request/output-location (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-association-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06.create-association-request/compliance-severity :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/automation-target-parameter-name :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/schedule-expression :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.create-association-request/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-automation-step-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/step-execution-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-automation-step-executions-request/reverse-order (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-automation-step-executions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/automation-execution-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-automation-step-executions-request/filters :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06.describe-automation-step-executions-request/reverse-order]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-parameters (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/resource-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/item-content-hash (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-content-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-compliance-items-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.put-compliance-items-request/resource-id :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/resource-type :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/compliance-type :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/execution-summary :portkey.aws.ssm.-2014-11-06.put-compliance-items-request/items] :opt-un [:portkey.aws.ssm.-2014-11-06.put-compliance-items-request/item-content-hash]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-key-values-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-associations-result/associations (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-associations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-associations-result/associations :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-automation-execution-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/automation-execution]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/logging-info (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/s-3-bucket-name :portkey.aws.ssm.-2014-11-06/s-3-region] :opt-un [:portkey.aws.ssm.-2014-11-06/s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/ps-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameters-by-path-result/parameters :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-resource-data-sync-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-association-executions-result/association-executions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-executions-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-association-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-association-executions-result/association-executions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-does-not-exist/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-does-not-exist (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.association-does-not-exist/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachment-content/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachment-content/size (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/content-length))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachment-content/hash (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachment-content/hash-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-hash-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachment-content/url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-content (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.attachment-content/name :portkey.aws.ssm.-2014-11-06.attachment-content/size :portkey.aws.ssm.-2014-11-06.attachment-content/hash :portkey.aws.ssm.-2014-11-06.attachment-content/hash-type :portkey.aws.ssm.-2014-11-06.attachment-content/url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/send-automation-signal-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-document-version/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-document-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-document-version/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-filter-group/patch-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-filter-group (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.patch-filter-group/patch-filters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/platform-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/agent-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/association-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/last-successful-association-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/last-ping-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/association-overview (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-aggregated-association-overview))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/is-latest-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/platform-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/last-association-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information/registration-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.instance-information/platform-name :portkey.aws.ssm.-2014-11-06/platform-type :portkey.aws.ssm.-2014-11-06/ping-status :portkey.aws.ssm.-2014-11-06/iam-role :portkey.aws.ssm.-2014-11-06.instance-information/agent-version :portkey.aws.ssm.-2014-11-06.instance-information/association-status :portkey.aws.ssm.-2014-11-06.instance-information/last-successful-association-execution-date :portkey.aws.ssm.-2014-11-06.instance-information/last-ping-date-time :portkey.aws.ssm.-2014-11-06.instance-information/association-overview :portkey.aws.ssm.-2014-11-06.instance-information/is-latest-version :portkey.aws.ssm.-2014-11-06/ip-address :portkey.aws.ssm.-2014-11-06.instance-information/platform-version :portkey.aws.ssm.-2014-11-06/resource-type :portkey.aws.ssm.-2014-11-06/activation-id :portkey.aws.ssm.-2014-11-06.instance-information/last-association-execution-date :portkey.aws.ssm.-2014-11-06.instance-information/name :portkey.aws.ssm.-2014-11-06.instance-information/registration-date :portkey.aws.ssm.-2014-11-06/computer-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-plugin-name (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-task))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-values))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state-filter/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-patch-state-operator-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.instance-patch-state-filter/key :portkey.aws.ssm.-2014-11-06.instance-patch-state-filter/values :portkey.aws.ssm.-2014-11-06.instance-patch-state-filter/type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/status-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/document-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-item/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-item/schema-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-item/capture-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-capture-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-item/content-hash (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-content-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-result-item/content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-result-item (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.inventory-result-item/type-name :portkey.aws.ssm.-2014-11-06.inventory-result-item/schema-version :portkey.aws.ssm.-2014-11-06.inventory-result-item/content] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-result-item/capture-time :portkey.aws.ssm.-2014-11-06.inventory-result-item/content-hash]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-plugin-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 4 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/content-length clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-default-version-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-default-version-request/document-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-number))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-document-default-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-document-default-version-request/name :portkey.aws.ssm.-2014-11-06.update-document-default-version-request/document-version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/global-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/replace (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/sources (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id] :opt-un [:portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/rejected-patches-action :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/global-filters :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approved-patches :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/description :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approved-patches-enable-non-security :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/replace :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approval-rules :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/approved-patches-compliance-level :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/name :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/sources :portkey.aws.ssm.-2014-11-06.update-patch-baseline-request/rejected-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attribute-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session-manager-output-url/s-3-output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-manager-s-3-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session-manager-output-url/cloud-watch-output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-manager-cloud-watch-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-output-url (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.session-manager-output-url/s-3-output-url :portkey.aws.ssm.-2014-11-06.session-manager-output-url/cloud-watch-output-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.custom-schema-count-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/custom-schema-count-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.custom-schema-count-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-summary/summary-items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary-items))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/total-count :portkey.aws.ssm.-2014-11-06/remaining-count :portkey.aws.ssm.-2014-11-06.inventory-deletion-summary/summary-items]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-managed-instance-role-request/instance-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/managed-instance-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-managed-instance-role-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-managed-instance-role-request/instance-id :portkey.aws.ssm.-2014-11-06/iam-role] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-key-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([a-zA-Z0-9:/_-]+)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-parameter-map (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/automation-parameter-key :portkey.aws.ssm.-2014-11-06/automation-parameter-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-document-operation/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-document-operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-document-operation/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/step-execution-filter-value :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-overview/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-overview/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-overview (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.association-overview/status :portkey.aws.ssm.-2014-11-06.association-overview/detailed-status :portkey.aws.ssm.-2014-11-06/association-status-aggregated-count]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/document-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.duplicate-document-content/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/duplicate-document-content (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.duplicate-document-content/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-document-versions-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-document-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.list-document-versions-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/resource-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/overall-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-compliance-summary-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/compliance-type :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/resource-type :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/resource-id :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/status :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/overall-severity :portkey.aws.ssm.-2014-11-06.resource-compliance-summary-item/execution-summary :portkey.aws.ssm.-2014-11-06/compliant-summary :portkey.aws.ssm.-2014-11-06/non-compliant-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-rule-group/patch-rules (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-rule-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-rule-group (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.patch-rule-group/patch-rules] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-activation-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-target-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-target))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.modify-document-permission-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.modify-document-permission-request/permission-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-permission-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.modify-document-permission-request/account-ids-to-add (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/account-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.modify-document-permission-request/account-ids-to-remove (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/account-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/modify-document-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.modify-document-permission-request/name :portkey.aws.ssm.-2014-11-06.modify-document-permission-request/permission-type] :opt-un [:portkey.aws.ssm.-2014-11-06.modify-document-permission-request/account-ids-to-add :portkey.aws.ssm.-2014-11-06.modify-document-permission-request/account-ids-to-remove]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-plugin-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/command-plugin))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-resource-data-sync-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-request/names (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameters-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-parameters-request/names] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameters-request/with-decryption]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-item :min-count 1 :max-count 30))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/accounts (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/account :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-schema-result/schemas (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-schema-result-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-inventory-schema-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-inventory-schema-result/schemas :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/key-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-key-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/overwrite (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-parameter-request/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-parameter-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.put-parameter-request/name :portkey.aws.ssm.-2014-11-06.put-parameter-request/value :portkey.aws.ssm.-2014-11-06.put-parameter-request/type] :opt-un [:portkey.aws.ssm.-2014-11-06.put-parameter-request/description :portkey.aws.ssm.-2014-11-06.put-parameter-request/key-id :portkey.aws.ssm.-2014-11-06.put-parameter-request/overwrite :portkey.aws.ssm.-2014-11-06/allowed-pattern :portkey.aws.ssm.-2014-11-06.put-parameter-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-history-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-history))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-filter :min-count 0 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/service-setting-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-sessions-request/state (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-state))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-sessions-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-sessions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-sessions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-sessions-request/state] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-sessions-request/max-results :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.describe-sessions-request/filters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-inventory-result/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/put-inventory-message))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-inventory-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.put-inventory-result/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/registrations-count (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-request/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-request/safe (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-target-from-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-request/window-id :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-request/window-target-id] :opt-un [:portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-request/safe]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/document-description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/max-errors (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 7)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([1-9][0-9]*|[0]|[1-9][0-9]%|[0-9]%|100%)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-item-attribute :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-string-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 132)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"tag:.+|Name|Type|KeyId|Path|Label" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-schema-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([0-9]{1,6})(\.[0-9]{1,6})$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-commands-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-commands-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-commands-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/command-id :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.list-commands-request/max-results :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.list-commands-request/filters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-status #{"NON_COMPLIANT" "COMPLIANT" :compliant :non-compliant})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-connection-status-response/target (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-connection-status-response/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/connection-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-connection-status-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-connection-status-response/target :portkey.aws.ssm.-2014-11-06.get-connection-status-response/status]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-automation-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/automation-execution-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-request/plugin-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-plugin-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-command-invocation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/command-id :portkey.aws.ssm.-2014-11-06/instance-id] :opt-un [:portkey.aws.ssm.-2014-11-06.get-command-invocation-request/plugin-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-string-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-string-filter-value :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-request/content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-request/attachments (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachments-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-document-request/content :portkey.aws.ssm.-2014-11-06.update-document-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06.update-document-request/attachments :portkey.aws.ssm.-2014-11-06.update-document-request/version-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06/document-format :portkey.aws.ssm.-2014-11-06/target-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-result/instance-patch-states (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-patch-state-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-result/instance-patch-states :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-status #{:in-progress "InProgress" "Complete" :complete})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/account (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-patch-baseline-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/patch-group :portkey.aws.ssm.-2014-11-06/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-execution-summary/execution-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-execution-summary/execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-execution-summary/execution-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-execution-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-execution-summary (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.compliance-execution-summary/execution-time] :opt-un [:portkey.aws.ssm.-2014-11-06.compliance-execution-summary/execution-id :portkey.aws.ssm.-2014-11-06.compliance-execution-summary/execution-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachments-source-values (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/attachments-source-value :min-count 1 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invocation-trace-output (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 2500))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/stream-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachments-source/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachments-source-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.attachments-source/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachments-source-values))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachments-source (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.attachments-source/key :portkey.aws.ssm.-2014-11-06.attachments-source/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/allowed-pattern (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/tag-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/valid-next-step (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 65535))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-msrc-severity (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-command-invocations-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-command-invocations-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-command-invocations-request/details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-command-invocations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/command-id :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.list-command-invocations-request/max-results :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.list-command-invocations-request/filters :portkey.aws.ssm.-2014-11-06.list-command-invocations-request/details]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-string-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-default-version-description/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-default-version-description/default-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-default-version-description/default-version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-default-version-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-default-version-description/name :portkey.aws.ssm.-2014-11-06.document-default-version-description/default-version :portkey.aws.ssm.-2014-11-06.document-default-version-description/default-version-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/default-baseline clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/allow-unassociated-targets (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-allow-unassociated-targets))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/end-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/enabled (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/duration (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/cutoff (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/schedule (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/start-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/window-id :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/allow-unassociated-targets :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/end-date :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/enabled :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/description :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/duration :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/cutoff :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/schedule :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/name :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/start-date :portkey.aws.ssm.-2014-11-06.update-maintenance-window-result/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/start-session-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/session-id :portkey.aws.ssm.-2014-11-06/token-value :portkey.aws.ssm.-2014-11-06/stream-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-tag-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-filter-key #{"InvokedBefore" :document-name "InvokedAfter" "ExecutionStage" "Status" :invoked-before :invoked-after :status "DocumentName" :execution-stage})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-inventory-result/deletion-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-inventory-result/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-inventory-result/deletion-summary (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-inventory-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.delete-inventory-result/deletion-id :portkey.aws.ssm.-2014-11-06.delete-inventory-result/type-name :portkey.aws.ssm.-2014-11-06.delete-inventory-result/deletion-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/total-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/batch-error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-source-product-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-source-product :min-count 1 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/baseline-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 20 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-:/]{20,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-automation-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-execution-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-automation-executions-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-automation-executions-request/filters :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-automation-executions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/automation-execution-metadata-list :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-version-label-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-version-label-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-version-label-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-definition-version-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-definition-version-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.automation-definition-version-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-target-from-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-result/window-id :portkey.aws.ssm.-2014-11-06.deregister-target-from-maintenance-window-result/window-target-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-service-setting-request/setting-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-service-setting-request/setting-value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-setting-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-service-setting-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-service-setting-request/setting-id :portkey.aws.ssm.-2014-11-06.update-service-setting-request/setting-value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-not-applicable-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.failure-details/failure-stage (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.failure-details/failure-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.failure-details/details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/failure-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.failure-details/failure-stage :portkey.aws.ssm.-2014-11-06.failure-details/failure-type :portkey.aws.ssm.-2014-11-06.failure-details/details]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-product (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-filter-key #{"Status" "CreatedTime" "ExecutionId" :status :execution-id :created-time})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/ip-address (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 46))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/managed-instance-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^mi-[0-9a-f]{17}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-string-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-filter-value :min-count 1 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/global-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/created-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/sources (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/rejected-patches-action :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/global-filters :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approved-patches :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/description :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approved-patches-enable-non-security :portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/created-date :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/modified-date :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approval-rules :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/approved-patches-compliance-level :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/name :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/sources :portkey.aws.ssm.-2014-11-06/operating-system :portkey.aws.ssm.-2014-11-06.update-patch-baseline-result/rejected-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 20 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 20)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^mw-[0-9a-f]{17}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-result/targets (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-targets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-targets-result/targets :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-values (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/created-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-status/deployment-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-deployment-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-status/compliance-level (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-status/approval-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.patch-status/deployment-status :portkey.aws.ssm.-2014-11-06.patch-status/compliance-level :portkey.aws.ssm.-2014-11-06.patch-status/approval-date]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/normal-string-map (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/string :portkey.aws.ssm.-2014-11-06/string))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachments-source-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-result/tasks (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-tasks-result/tasks :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter :min-count 0 :max-count 4))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-parameters/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-parameters/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-target-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-vendor (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-client-context (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 8000))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/effective-instance-association-max-results (clojure.spec.alpha/int-in 1 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/status-details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-execution/window-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/window-execution-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/status :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/status-details :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/start-time :portkey.aws.ssm.-2014-11-06.maintenance-window-execution/end-time]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-association-execution-targets-result/association-execution-targets (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-targets-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-association-execution-targets-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-association-execution-targets-result/association-execution-targets :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-resource-data-sync-request/sync-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-resource-data-sync-request/s-3-destination (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-destination))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-resource-data-sync-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-resource-data-sync-request/sync-name :portkey.aws.ssm.-2014-11-06.create-resource-data-sync-request/s-3-destination] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/last-successful-resource-data-sync-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/step-execution-filter :min-count 1 :max-count 6))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-information-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-information-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-information-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/max-results-ec-2-compatible))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-information-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-information-filter-list :portkey.aws.ssm.-2014-11-06.describe-instance-information-request/filters :portkey.aws.ssm.-2014-11-06.describe-instance-information-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/global-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/created-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/patch-groups (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-group-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/sources (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/rejected-patches-action :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/global-filters :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approved-patches :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/description :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approved-patches-enable-non-security :portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/created-date :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/patch-groups :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/modified-date :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approval-rules :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/approved-patches-compliance-level :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/name :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/sources :portkey.aws.ssm.-2014-11-06/operating-system :portkey.aws.ssm.-2014-11-06.get-patch-baseline-result/rejected-patches]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-task-from-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-result/window-id :portkey.aws.ssm.-2014-11-06.deregister-task-from-maintenance-window-result/window-task-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/selector (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-selector))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/source-result (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter/arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter/name :portkey.aws.ssm.-2014-11-06.parameter/type :portkey.aws.ssm.-2014-11-06.parameter/value :portkey.aws.ssm.-2014-11-06.parameter/version :portkey.aws.ssm.-2014-11-06.parameter/selector :portkey.aws.ssm.-2014-11-06.parameter/source-result :portkey.aws.ssm.-2014-11-06.parameter/last-modified-date :portkey.aws.ssm.-2014-11-06.parameter/arn]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.unsupported-inventory-schema-version-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/unsupported-inventory-schema-version-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.unsupported-inventory-schema-version-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-execution-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-execution-filter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.automation-execution-filter/key :portkey.aws.ssm.-2014-11-06.automation-execution-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-installed-other-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-content-context (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/attribute-name :portkey.aws.ssm.-2014-11-06/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/account-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"(?i)all|[0-9]{12}" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-schema-result-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-item-schema))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-item-content-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-item-content-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-item-content-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-item-content-exception/type-name :portkey.aws.ssm.-2014-11-06.invalid-item-content-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-compliance-summary-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/resource-compliance-summary-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-filter-key (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-request/filters :portkey.aws.ssm.-2014-11-06.describe-maintenance-windows-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-target-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-batch-request-entry/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-batch-request-entry/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-batch-request-entry/output-location (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-association-batch-request-entry (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-association-batch-request-entry/name] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06.create-association-batch-request-entry/compliance-severity :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/automation-target-parameter-name :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/schedule-expression :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.create-association-batch-request-entry/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/automation-execution-filter-value :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-description (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-filter-key #{"PATCH_ID" "CLASSIFICATION" :section "SEVERITY" :classification "MSRC_SEVERITY" "SECTION" :product :priority :patch-id :severity "PRODUCT" :msrc-severity "PRIORITY"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-failed-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-lambda-parameters/client-context (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-client-context))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-lambda-parameters/qualifier (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-qualifier))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-lambda-parameters/payload (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-payload))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-lambda-parameters/client-context :portkey.aws.ssm.-2014-11-06.maintenance-window-lambda-parameters/qualifier :portkey.aws.ssm.-2014-11-06.maintenance-window-lambda-parameters/payload]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-status #{:timed-out "Failed" "Cancelled" :in-progress "Cancelling" :pending "TimedOut" "Success" :waiting :cancelled :success "InProgress" "Waiting" :cancelling "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.reset-service-setting-request/setting-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/reset-service-setting-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.reset-service-setting-request/setting-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-notification-config/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-notification-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-notification-config/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-schema-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"([0-9]+)\.([0-9]+)" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-information-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/attachment-information))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-source-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-source :min-count 0 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.target-location/target-location-max-concurrency (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/max-concurrency))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.target-location/target-location-max-errors (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/max-errors))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/accounts :portkey.aws.ssm.-2014-11-06/regions :portkey.aws.ssm.-2014-11-06.target-location/target-location-max-concurrency :portkey.aws.ssm.-2014-11-06.target-location/target-location-max-errors :portkey.aws.ssm.-2014-11-06/execution-role-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-max-results (clojure.spec.alpha/int-in 10 100))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/notification-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-document-permission-response/account-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/account-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-document-permission-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-document-permission-response/account-ids]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-activation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/activation-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-created-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.unsupported-operating-system/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/unsupported-operating-system (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.unsupported-operating-system/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-default-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information-string-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-information-string-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-information-string-filter/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-information-filter-value-set))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-string-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.instance-information-string-filter/key :portkey.aws.ssm.-2014-11-06.instance-information-string-filter/values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-type #{:managed-instance "EC2Instance" :document "Document" "ManagedInstance" :ec-2-instance})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-step-functions-input (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 4096))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/activation-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-parameter-default-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-aggregator-expression (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1000))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-format #{"YAML" :yaml "JSON" :json})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/targets (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/target :min-count 0 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-groups-result/mappings (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-group-patch-baseline-mapping-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-patch-groups-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-patch-groups-result/mappings :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-compliance-level #{"INFORMATIONAL" :unspecified "CRITICAL" :medium "LOW" :high :critical "HIGH" :low "UNSPECIFIED" :informational "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-source-configuration (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-map-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.stop-automation-execution-request/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/stop-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/stop-automation-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/automation-execution-id] :opt-un [:portkey.aws.ssm.-2014-11-06.stop-automation-execution-request/type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-resource-type-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-resource-type :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-status #{"Failed" "Active" "Creating" :creating :deleting "Deleting" :active :updating "Updating" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-activations-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-activations-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-activations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-activations-request/filters :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/description-in-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/remove-tags-from-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/expires-after (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/requested-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/service-role :portkey.aws.ssm.-2014-11-06.command/instance-ids :portkey.aws.ssm.-2014-11-06/comment :portkey.aws.ssm.-2014-11-06/delivery-timed-out-count :portkey.aws.ssm.-2014-11-06/completed-count :portkey.aws.ssm.-2014-11-06/error-count :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06.command/output-s-3-bucket-name :portkey.aws.ssm.-2014-11-06/notification-config :portkey.aws.ssm.-2014-11-06.command/expires-after :portkey.aws.ssm.-2014-11-06.command/status :portkey.aws.ssm.-2014-11-06/status-details :portkey.aws.ssm.-2014-11-06/cloud-watch-output-config :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.command/requested-date-time :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/command-id :portkey.aws.ssm.-2014-11-06.command/output-s-3-key-prefix :portkey.aws.ssm.-2014-11-06.command/output-s-3-region :portkey.aws.ssm.-2014-11-06/document-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06/target-count]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-parameter-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-parameter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instances-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-filter-value/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-filter-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-filter-value/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-group-patch-baseline-mapping-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-group-patch-baseline-mapping))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-key-id/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-key-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-key-id/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-result/window-execution-task-invocation-identities (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-task-invocations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-task-invocations-result/window-execution-task-invocation-identities :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameters-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/parameters-filter))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.delete-document-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/execution-role-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/baseline-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 3 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-s-3-output-url (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 2083))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-max-version-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-max-version-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-max-version-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-hash-type #{"Sha256" :sha-256})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.activation/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.activation/expired (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.activation/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/activation-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/activation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.activation/tags :portkey.aws.ssm.-2014-11-06/iam-role :portkey.aws.ssm.-2014-11-06/default-instance-name :portkey.aws.ssm.-2014-11-06/expiration-date :portkey.aws.ssm.-2014-11-06.activation/expired :portkey.aws.ssm.-2014-11-06/registrations-count :portkey.aws.ssm.-2014-11-06.activation/description :portkey.aws.ssm.-2014-11-06/created-date :portkey.aws.ssm.-2014-11-06/activation-id :portkey.aws.ssm.-2014-11-06/registration-limit]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-request/task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-request/window-execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-step-functions-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 80))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-resource-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/association-execution-filter :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.feature-not-available-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/feature-not-available-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.feature-not-available-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-parameter-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-parameter-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.delete-parameter-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/status-details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/invocation-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/task-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-invocation-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/task-execution-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/end-time :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/start-time :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/parameters :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/status :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/status-details :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/window-execution-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/invocation-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/execution-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/window-target-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-invocation-identity/task-type :portkey.aws.ssm.-2014-11-06/owner-information]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-s-3-bucket-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-duration-hours (clojure.spec.alpha/int-in 1 24))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-automation-signal-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-automation-signal-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-automation-signal-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-inventory-request/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-inventory-request/schema-delete-option (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-schema-delete-option))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-inventory-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.delete-inventory-request/type-name] :opt-un [:portkey.aws.ssm.-2014-11-06.delete-inventory-request/schema-delete-option :portkey.aws.ssm.-2014-11-06/dry-run :portkey.aws.ssm.-2014-11-06/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-effective-instance-associations-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/effective-instance-association-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-effective-instance-associations-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-effective-instance-associations-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/platform-type-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/platform-type))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/s-3-key-prefix (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 500))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-effective-patches-for-patch-baseline-result/effective-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/effective-patch-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-effective-patches-for-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-effective-patches-for-patch-baseline-result/effective-patches :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-aggregator-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-aggregator :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name-filter))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-inventory-schema-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/aggregator (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/aggregator-schema-only))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/sub-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/is-sub-type-schema))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-inventory-schema-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/type-name :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/max-results :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/aggregator :portkey.aws.ssm.-2014-11-06.get-inventory-schema-request/sub-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/replace (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-maintenance-window-target-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/window-id :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/window-target-id] :opt-un [:portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/owner-information :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/name :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/description :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-request/replace]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-cloud-watch-output-url (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 2083))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-execution-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 50))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-count-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-count-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-count-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/effective-patch-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/effective-patch))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/idempotency-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-permission-type #{"Share" :share})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/schedule-expression (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-resource-data-sync-result/resource-data-sync-items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-resource-data-sync-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-resource-data-sync-result/resource-data-sync-items :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-type-for-tagging #{:managed-instance :maintenance-window "PatchBaseline" "MaintenanceWindow" :document "Parameter" :patch-baseline "Document" "ManagedInstance" :parameter})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-document-result/document (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-document-result/document]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-version-number (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"(^[1-9][0-9]*$)" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.failed-create-association/entry (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-association-batch-request-entry))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.failed-create-association/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/batch-error-message))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/failed-create-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.failed-create-association/entry :portkey.aws.ssm.-2014-11-06.failed-create-association/message :portkey.aws.ssm.-2014-11-06/fault]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-sessions-response/sessions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-sessions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-sessions-response/sessions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-inventory-item-context-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-inventory-item-context-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-inventory-item-context-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-item-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/resource-data-sync-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/command))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-patch-baseline-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/patch-group] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-result/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-result/status-information (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-status-information))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-result/content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-result/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-result/attachments-content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/attachment-content-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-document-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-document-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/document-type :portkey.aws.ssm.-2014-11-06.get-document-result/status :portkey.aws.ssm.-2014-11-06.get-document-result/status-information :portkey.aws.ssm.-2014-11-06.get-document-result/content :portkey.aws.ssm.-2014-11-06/document-format :portkey.aws.ssm.-2014-11-06.get-document-result/version-name :portkey.aws.ssm.-2014-11-06.get-document-result/attachments-content :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.get-document-result/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-version-info/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-version-info/created-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-version-info/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-version-info/output-location (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-version-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06.association-version-info/compliance-severity :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.association-version-info/created-date :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/schedule-expression :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.association-version-info/name :portkey.aws.ssm.-2014-11-06.association-version-info/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association/content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-content))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.instance-association/content :portkey.aws.ssm.-2014-11-06/association-version]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.remove-tags-from-resource-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-type-for-tagging))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.remove-tags-from-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/key-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/remove-tags-from-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.remove-tags-from-resource-request/resource-type :portkey.aws.ssm.-2014-11-06/resource-id :portkey.aws.ssm.-2014-11-06.remove-tags-from-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.duplicate-document-version-name/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/duplicate-document-version-name (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.duplicate-document-version-name/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.s-3-output-url/output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/s-3-output-url (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.s-3-output-url/output-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-version-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-version-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.association-version-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/install-override-list (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^https://.+$|^s3://([^/]+)/(.*?([^/]+))$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-request/instance-ids] :opt-un [:portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/activation-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 20 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 250))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-source-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,50}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-entry-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-item-entry :min-count 0 :max-count 10000))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/error-code (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/agent-error-code))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-status-info/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-status-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06.instance-association-status-info/execution-date :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06.instance-association-status-info/output-url :portkey.aws.ssm.-2014-11-06.instance-association-status-info/status :portkey.aws.ssm.-2014-11-06.instance-association-status-info/error-code :portkey.aws.ssm.-2014-11-06.instance-association-status-info/execution-summary :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06.instance-association-status-info/detailed-status :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.instance-association-status-info/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-status-name #{"Failed" :pending "Success" :success "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.command-filter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.command-filter/key :portkey.aws.ssm.-2014-11-06.command-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-result-item-map (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/inventory-result-item-key :portkey.aws.ssm.-2014-11-06/inventory-result-item))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-association-versions-result/association-versions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-version-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-association-versions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-association-versions-result/association-versions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resume-session-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/session-id :portkey.aws.ssm.-2014-11-06/token-value :portkey.aws.ssm.-2014-11-06/stream-url]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-association-batch-request/entries (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-association-batch-request-entries))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-association-batch-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-association-batch-request/entries] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-target/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-target/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-activations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/activation-list :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-association-version/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-association-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-association-version/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/remaining-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-inventory-request-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-inventory-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-inventory-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-rule-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-rule :min-count 0 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/owner-information (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-activations-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/describe-activations-filter))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/session))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-activations-filter/filter-key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-activations-filter-keys))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-activations-filter/filter-values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-activations-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-activations-filter/filter-key :portkey.aws.ssm.-2014-11-06.describe-activations-filter/filter-values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.sub-type-count-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/sub-type-count-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.sub-type-count-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/associated-instances (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-for-patch-group-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-patch-state-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-for-patch-group-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/patch-group] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-for-patch-group-request/filters :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06.describe-instance-patch-states-for-patch-group-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-output-folder (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-resource-compliance-summaries-result/resource-compliance-summary-items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-compliance-summary-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-resource-compliance-summaries-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-resource-compliance-summaries-result/resource-compliance-summary-items :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-role/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-role (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-role/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/service-setting-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1000))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.s-3-output-location/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.s-3-output-location/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.s-3-output-location/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/s-3-output-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.s-3-output-location/output-s-3-region :portkey.aws.ssm.-2014-11-06.s-3-output-location/output-s-3-bucket-name :portkey.aws.ssm.-2014-11-06.s-3-output-location/output-s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/fault #{:unknown :server :client "Unknown" "Server" "Client"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-command-request/service-role-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-role))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-command-request/instance-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-command-request/output-s-3-bucket-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-command-request/output-s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-key-prefix))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-command-request/output-s-3-region (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-region))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.send-command-request/document-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/send-command-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.send-command-request/document-name] :opt-un [:portkey.aws.ssm.-2014-11-06.send-command-request/service-role-arn :portkey.aws.ssm.-2014-11-06.send-command-request/instance-ids :portkey.aws.ssm.-2014-11-06/comment :portkey.aws.ssm.-2014-11-06/timeout-seconds :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06.send-command-request/output-s-3-bucket-name :portkey.aws.ssm.-2014-11-06/notification-config :portkey.aws.ssm.-2014-11-06/document-hash :portkey.aws.ssm.-2014-11-06/cloud-watch-output-config :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06.send-command-request/output-s-3-key-prefix :portkey.aws.ssm.-2014-11-06.send-command-request/output-s-3-region :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06/document-hash-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-association/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-association/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-identity-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-identity))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-filter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-filter-value :min-count 1 :max-count 20))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/max-results (clojure.spec.alpha/int-in 1 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-association-batch-request-entries (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/create-association-batch-request-entry :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.tag/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.tag/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/tag (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.tag/key :portkey.aws.ssm.-2014-11-06.tag/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-request/aggregators (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-aggregator-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-inventory-request/result-attributes (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/result-attribute-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-inventory-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-inventory-request/filters :portkey.aws.ssm.-2014-11-06.get-inventory-request/aggregators :portkey.aws.ssm.-2014-11-06.get-inventory-request/result-attributes :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-schedule (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9]{1,6}(\.[0-9]{1,6}){2,3}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 100)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^(AWS|Custom):.*$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/result-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/result-attribute :min-count 1 :max-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-association-request/compliance-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-association-request/output-location (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-association-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/association-id] :opt-un [:portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06/parameters :portkey.aws.ssm.-2014-11-06.update-association-request/compliance-severity :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06/automation-target-parameter-name :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/schedule-expression :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.update-association-request/name :portkey.aws.ssm.-2014-11-06.update-association-request/output-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-key-values-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-parameters-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-metadata-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-parameters-result/parameters :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-compliance-data-state #{"INSTALLED_REJECTED" :not-applicable "INSTALLED_OTHER" "NOT_APPLICABLE" "INSTALLED" "FAILED" :missing "MISSING" :installed-rejected :installed :installed-other :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-already-exists-exception/sync-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-already-exists-exception/sync-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-request/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-request/window-execution-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/run-command (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-run-command-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/automation (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-automation-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/step-functions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-step-functions-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/lambda (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-lambda-parameters))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-invocation-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/run-command :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/automation :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/step-functions :portkey.aws.ssm.-2014-11-06.maintenance-window-task-invocation-parameters/lambda]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/window-target-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-target-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-maintenance-window-target-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/window-id :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/window-target-id :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/owner-information :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/name :portkey.aws.ssm.-2014-11-06.update-maintenance-window-target-result/description]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-inventory-group-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-inventory-group-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-inventory-group-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-allowed-pattern-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-allowed-pattern-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-allowed-pattern-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-compliance-items-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-compliance-items-request/resource-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-compliance-items-request/resource-types (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-type-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-compliance-items-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-compliance-items-request/filters :portkey.aws.ssm.-2014-11-06.list-compliance-items-request/resource-ids :portkey.aws.ssm.-2014-11-06.list-compliance-items-request/resource-types :portkey.aws.ssm.-2014-11-06/next-token :portkey.aws.ssm.-2014-11-06/max-results]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution-filter-key #{:step-execution-status "StartTimeBefore" "StepExecutionStatus" "StepExecutionId" :step-execution-id :start-time-before "StartTimeAfter" :step-name "StepName" :action "Action" :start-time-after})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_\-.]{3,128}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.start-associations-once-request/association-ids (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/start-associations-once-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.start-associations-once-request/association-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-content-hash (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/ps-parameter-selector (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-step-functions-parameters/input (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-step-functions-input))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-step-functions-parameters/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-step-functions-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-step-functions-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-step-functions-parameters/input :portkey.aws.ssm.-2014-11-06.maintenance-window-step-functions-parameters/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-result-item-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-windows-for-target-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-identity-for-target))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-aggregator-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-aggregator-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-aggregator-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-patch-baseline-for-patch-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/patch-group] :opt-un [:portkey.aws.ssm.-2014-11-06/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-service-setting-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/service-setting]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-filter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type #{:lambda :step-functions "LAMBDA" :run-command "RUN_COMMAND" :automation "STEP_FUNCTIONS" "AUTOMATION"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/output-source-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-allow-unassociated-targets clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invocation-does-not-exist (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-parameters (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/session-manager-parameter-name :portkey.aws.ssm.-2014-11-06/session-manager-parameter-value-list))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item/schema-version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item/capture-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-capture-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item/content-hash (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-content-hash))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item/content (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-entry-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item/context (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-content-context))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.inventory-item/type-name :portkey.aws.ssm.-2014-11-06.inventory-item/schema-version :portkey.aws.ssm.-2014-11-06.inventory-item/capture-time] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-item/content-hash :portkey.aws.ssm.-2014-11-06.inventory-item/content :portkey.aws.ssm.-2014-11-06.inventory-item/context]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 250))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-baselines-result/baseline-identities (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-baseline-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-patch-baselines-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-patch-baselines-result/baseline-identities :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/command-filter :min-count 1 :max-count 5))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-group-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/inventory-group :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"([$]LATEST|[$]DEFAULT|^[1-9][0-9]*$)" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.target/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/target-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.target/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/target-values))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.target/key :portkey.aws.ssm.-2014-11-06.target/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/scheduled-window-execution-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/scheduled-window-execution))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.internal-server-error/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/internal-server-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.internal-server-error/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-hash-type #{:sha-1 "Sha256" :sha-256 "Sha1"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-maintenance-window-result/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.delete-maintenance-window-result/window-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/valid-next-step-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/valid-next-step))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-filter-key #{"InvokedBefore" "InvokedAfter" "Status" :invoked-before :invoked-after :status "Owner" :target "Target" :owner})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-filter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.document-filter/key :portkey.aws.ssm.-2014-11-06.document-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-target/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-target/resource-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-target/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-target/execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-target/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-target/detailed-status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/status-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06/output-source :portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06.association-execution-target/status :portkey.aws.ssm.-2014-11-06.association-execution-target/resource-id :portkey.aws.ssm.-2014-11-06.association-execution-target/last-execution-date :portkey.aws.ssm.-2014-11-06.association-execution-target/execution-id :portkey.aws.ssm.-2014-11-06.association-execution-target/resource-type :portkey.aws.ssm.-2014-11-06.association-execution-target/detailed-status]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-execution-summary (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-association-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-association-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.delete-association-request/name :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/association-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/failed-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-failed-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/operation (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-operation-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/installed-other-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-installed-other-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/operation-start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/not-applicable-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-not-applicable-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/operation-end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/installed-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-installed-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/installed-rejected-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-installed-rejected-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-patch-state/missing-count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-missing-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/patch-group :portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06.instance-patch-state/operation-start-time :portkey.aws.ssm.-2014-11-06.instance-patch-state/operation-end-time :portkey.aws.ssm.-2014-11-06.instance-patch-state/operation] :opt-un [:portkey.aws.ssm.-2014-11-06.instance-patch-state/failed-count :portkey.aws.ssm.-2014-11-06.instance-patch-state/installed-other-count :portkey.aws.ssm.-2014-11-06.instance-patch-state/not-applicable-count :portkey.aws.ssm.-2014-11-06/install-override-list :portkey.aws.ssm.-2014-11-06/owner-information :portkey.aws.ssm.-2014-11-06.instance-patch-state/installed-count :portkey.aws.ssm.-2014-11-06.instance-patch-state/installed-rejected-count :portkey.aws.ssm.-2014-11-06.instance-patch-state/missing-count :portkey.aws.ssm.-2014-11-06/snapshot-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-target-with-maintenance-window-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/window-id :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/resource-type :portkey.aws.ssm.-2014-11-06/targets] :opt-un [:portkey.aws.ssm.-2014-11-06/owner-information :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/name :portkey.aws.ssm.-2014-11-06.register-target-with-maintenance-window-request/description :portkey.aws.ssm.-2014-11-06/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association/overview (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-overview))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association/last-execution-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/association-version :portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/association-id :portkey.aws.ssm.-2014-11-06.association/overview :portkey.aws.ssm.-2014-11-06.association/last-execution-date :portkey.aws.ssm.-2014-11-06/association-name :portkey.aws.ssm.-2014-11-06/targets :portkey.aws.ssm.-2014-11-06/schedule-expression :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.association/name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-parameters-request/names (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-parameters-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.delete-parameters-request/names] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-manager-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 65535))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-product-family (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/rejected-patches-action (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-action))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/global-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-filter-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approved-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approved-patches-enable-non-security (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approval-rules (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-rule-group))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approved-patches-compliance-level (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-compliance-level))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/baseline-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/sources (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-source-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/rejected-patches (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-patch-baseline-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/rejected-patches-action :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/global-filters :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/tags :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approved-patches :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/description :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approved-patches-enable-non-security :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approval-rules :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/approved-patches-compliance-level :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/sources :portkey.aws.ssm.-2014-11-06/operating-system :portkey.aws.ssm.-2014-11-06.create-patch-baseline-request/rejected-patches :portkey.aws.ssm.-2014-11-06/client-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-parameter-type #{"StringList" :string-list :string "String"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-activations-filter-keys #{"ActivationIds" :iam-role :default-instance-name "IamRole" "DefaultInstanceName" :activation-ids})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-groups-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-patch-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-patch-groups-request/max-results :portkey.aws.ssm.-2014-11-06.describe-patch-groups-request/filters :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-request/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-request/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-request/window-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-task-request/window-task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-count-by-status (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting/setting-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-setting-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting/setting-value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/service-setting-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting/last-modified-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting/last-modified-user (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting/arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/service-setting (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.service-setting/setting-id :portkey.aws.ssm.-2014-11-06.service-setting/setting-value :portkey.aws.ssm.-2014-11-06.service-setting/last-modified-date :portkey.aws.ssm.-2014-11-06.service-setting/last-modified-user :portkey.aws.ssm.-2014-11-06.service-setting/arn :portkey.aws.ssm.-2014-11-06.service-setting/status]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-summary-item/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-summary-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.compliance-summary-item/compliance-type :portkey.aws.ssm.-2014-11-06/compliant-summary :portkey.aws.ssm.-2014-11-06/non-compliant-summary]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-result/window-execution-task-identities (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-identity-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-tasks-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-execution-tasks-result/window-execution-task-identities :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-available-patches-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-available-patches-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-available-patches-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-available-patches-request/filters :portkey.aws.ssm.-2014-11-06.describe-available-patches-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/terminate-session-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/session-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/command-plugin-status #{:timed-out "Failed" "Cancelled" :in-progress :pending "TimedOut" "Success" :cancelled :success "InProgress" "Pending" :failed})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameter-history-result/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-history-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameter-history-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameter-history-result/parameters :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-timezone (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-title (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-compliance-severity #{:unspecified "CRITICAL" :medium "LOW" :high :critical "HIGH" :low "UNSPECIFIED" "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/end-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-manager-output-url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/owner (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-owner))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/target (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-target))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session/start-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/session-id :portkey.aws.ssm.-2014-11-06.session/details :portkey.aws.ssm.-2014-11-06.session/end-date :portkey.aws.ssm.-2014-11-06.session/output-url :portkey.aws.ssm.-2014-11-06.session/status :portkey.aws.ssm.-2014-11-06.session/owner :portkey.aws.ssm.-2014-11-06/document-name :portkey.aws.ssm.-2014-11-06.session/target :portkey.aws.ssm.-2014-11-06.session/start-date]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-associations-status-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id] :opt-un [:portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/activation-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-baselines-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-orchestrator-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-patch-baselines-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-baseline-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-patch-baselines-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-patch-baselines-request/filters :portkey.aws.ssm.-2014-11-06.describe-patch-baselines-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/is-sub-type-schema clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.service-setting-not-found/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/service-setting-not-found (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.service-setting-not-found/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-filter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-result/scheduled-window-executions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/scheduled-window-execution-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-schedule-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-maintenance-window-schedule-result/scheduled-window-executions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-instance-information-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-information-list :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/ps-parameter-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/activation-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/activation))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.instance-association-output-location/s-3-location (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/s-3-output-location))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-output-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.instance-association-output-location/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.session-filter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/session-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/session-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.session-filter/key :portkey.aws.ssm.-2014-11-06.session-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.add-tags-to-resource-request/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-type-for-tagging))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.add-tags-to-resource-request/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/add-tags-to-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.add-tags-to-resource-request/resource-type :portkey.aws.ssm.-2014-11-06/resource-id :portkey.aws.ssm.-2014-11-06.add-tags-to-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-automation-parameters/parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/automation-parameter-map))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-automation-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.maintenance-window-automation-parameters/parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-resource-id-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/compliance-resource-id :min-count 1))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-instance-id/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-instance-id (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-instance-id/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-status-aggregated-count (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/status-name :portkey.aws.ssm.-2014-11-06/instance-count))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-language (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/attachment-content-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/attachment-content))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-capture-time (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^(20)[0-9][0-9]-(0[1-9]|1[012])-([12][0-9]|3[01]|0[1-9])(T)(2[0-3]|[0-1][0-9])(:[0-5][0-9])(:[0-5][0-9])(Z)$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-permission-type/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-permission-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-permission-type/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-update/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-update (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-update/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.put-inventory-request/items (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/put-inventory-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.put-inventory-request/items] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/status-details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/task-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/window-execution-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/task-execution-id :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/status :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/status-details :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/start-time :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/end-time :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/task-arn :portkey.aws.ssm.-2014-11-06.maintenance-window-execution-task-identity/task-type]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/failed-create-association-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/failed-create-association))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-targets-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-execution-targets-filter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.association-execution-targets-filter/key :portkey.aws.ssm.-2014-11-06.association-execution-targets-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/baseline-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-output-location (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resume-session-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/session-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-managed-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-effective-instance-associations-result/associations (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/instance-association-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-effective-instance-associations-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-effective-instance-associations-result/associations :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-query-operator-type #{"BEGIN_WITH" "GREATER_THAN" :less-than :greater-than "LESS_THAN" :not-equal :begin-with "EQUAL" :equal "NOT_EQUAL"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-summary-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/execution-start-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/plugin-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-plugin-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/execution-elapsed-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/command-invocation-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/standard-output-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/execution-end-date-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/standard-error-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-command-invocation-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/execution-start-date-time :portkey.aws.ssm.-2014-11-06/comment :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/plugin-name :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/execution-elapsed-time :portkey.aws.ssm.-2014-11-06/response-code :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/status :portkey.aws.ssm.-2014-11-06/status-details :portkey.aws.ssm.-2014-11-06/standard-output-content :portkey.aws.ssm.-2014-11-06/cloud-watch-output-config :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/standard-output-url :portkey.aws.ssm.-2014-11-06/command-id :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/execution-end-date-time :portkey.aws.ssm.-2014-11-06/document-name :portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.get-command-invocation-result/standard-error-url :portkey.aws.ssm.-2014-11-06/standard-error-content]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-version-limit-exceeded/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-version-limit-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-version-limit-exceeded/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-result/window-task-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-task-with-maintenance-window-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.register-task-with-maintenance-window-result/window-task-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.document-already-exists/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-already-exists (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.document-already-exists/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/register-default-patch-baseline-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-filter-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/patch-filter :min-count 0 :max-count 4))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/region (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/token-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 0 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 300))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item-attribute/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-attribute-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-item-attribute/data-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-attribute-data-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-item-attribute (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.inventory-item-attribute/name :portkey.aws.ssm.-2014-11-06.inventory-item-attribute/data-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-source-product (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/computer-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-operator-type #{"NotEqual" :less-than "Equal" "LessThan" :greater-than "GreaterThan" :not-equal :equal})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-task-parameter-value-expression/values (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-value-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-value-expression (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-task-parameter-value-expression/values]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-map-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/target-map-value :min-count 0 :max-count 25))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.automation-execution-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-execution-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.automation-execution-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 128)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[\p{L}\p{Z}\p{N}_.:/=\-@]*$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-inventory-deletions-result/inventory-deletions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-deletions-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-inventory-deletions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-inventory-deletions-result/inventory-deletions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-deployable-patch-snapshot-for-instance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/instance-id :portkey.aws.ssm.-2014-11-06/snapshot-id :portkey.aws.ssm.-2014-11-06/snapshot-download-url :portkey.aws.ssm.-2014-11-06/product]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-summary-item/version (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-schema-version))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.inventory-deletion-summary-item/count (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-count))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-summary-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.inventory-deletion-summary-item/version :portkey.aws.ssm.-2014-11-06.inventory-deletion-summary-item/count :portkey.aws.ssm.-2014-11-06/remaining-count]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/send-command-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/command]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/automation-parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/automation-parameter-value :min-count 0 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item-details (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/attribute-name :portkey.aws.ssm.-2014-11-06/attribute-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-value-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-value))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-string-filter-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__)))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/task-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-task-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/end-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/start-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/status-details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/priority (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-priority))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/window-execution-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-execution-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/task-arn (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/task-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameters-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/task-execution-id :portkey.aws.ssm.-2014-11-06/service-role :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/end-time :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/type :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/start-time :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/status :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/status-details :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/priority :portkey.aws.ssm.-2014-11-06/max-concurrency :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/window-execution-id :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/task-arn :portkey.aws.ssm.-2014-11-06/max-errors :portkey.aws.ssm.-2014-11-06.get-maintenance-window-execution-task-result/task-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.item-size-limit-exceeded-exception/type-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/inventory-item-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.item-size-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/item-size-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.item-size-limit-exceeded-exception/type-name :portkey.aws.ssm.-2014-11-06.item-size-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/last-resource-data-sync-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/kb-number (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-kb-number))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/product (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-product))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/msrc-number (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-msrc-number))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/title (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-title))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/msrc-severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-msrc-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/product-family (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-product-family))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/release-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/classification (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-classification))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/content-url (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-content-url))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/language (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-language))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/vendor (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-vendor))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch/id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.patch/kb-number :portkey.aws.ssm.-2014-11-06.patch/product :portkey.aws.ssm.-2014-11-06.patch/msrc-number :portkey.aws.ssm.-2014-11-06.patch/title :portkey.aws.ssm.-2014-11-06.patch/msrc-severity :portkey.aws.ssm.-2014-11-06.patch/product-family :portkey.aws.ssm.-2014-11-06.patch/description :portkey.aws.ssm.-2014-11-06.patch/release-date :portkey.aws.ssm.-2014-11-06.patch/classification :portkey.aws.ssm.-2014-11-06.patch/content-url :portkey.aws.ssm.-2014-11-06.patch/language :portkey.aws.ssm.-2014-11-06.patch/vendor :portkey.aws.ssm.-2014-11-06.patch/id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.list-document-versions-result/document-versions (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/list-document-versions-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.list-document-versions-result/document-versions :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/max-results-ec-2-compatible (clojure.spec.alpha/int-in 5 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-execution-targets-filter-key #{:resource-id "Status" "ResourceId" :status "ResourceType" :resource-type})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/deregister-patch-baseline-for-patch-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/baseline-id :portkey.aws.ssm.-2014-11-06/patch-group]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.patch-group-patch-baseline-mapping/baseline-identity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/patch-baseline-identity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-group-patch-baseline-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/patch-group :portkey.aws.ssm.-2014-11-06.patch-group-patch-baseline-mapping/baseline-identity]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-information-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-information))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/severity (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-severity))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/details (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-details))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/title (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-title))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/status (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-status))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/resource-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/execution-summary (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-execution-summary))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/resource-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-resource-type))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/compliance-type (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-type-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.compliance-item/id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/compliance-item-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/compliance-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.compliance-item/severity :portkey.aws.ssm.-2014-11-06.compliance-item/details :portkey.aws.ssm.-2014-11-06.compliance-item/title :portkey.aws.ssm.-2014-11-06.compliance-item/status :portkey.aws.ssm.-2014-11-06.compliance-item/resource-id :portkey.aws.ssm.-2014-11-06.compliance-item/execution-summary :portkey.aws.ssm.-2014-11-06.compliance-item/resource-type :portkey.aws.ssm.-2014-11-06.compliance-item/compliance-type :portkey.aws.ssm.-2014-11-06.compliance-item/id]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/operating-system #{"AMAZON_LINUX_2" :windows "WINDOWS" "CENTOS" :amazon-linux-2 :suse :centos "REDHAT_ENTERPRISE_LINUX" "AMAZON_LINUX" "UBUNTU" "SUSE" :redhat-enterprise-linux :amazon-linux :ubuntu})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-next-token/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-next-token (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-next-token/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/document-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/document-identifier))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-filter/key (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-filter-key))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.association-filter/value (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-filter-value))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-filter (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.association-filter/key :portkey.aws.ssm.-2014-11-06.association-filter/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/client-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/update-managed-instance-role-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-association-executions-request/filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/association-execution-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-association-executions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/association-id] :opt-un [:portkey.aws.ssm.-2014-11-06.describe-association-executions-request/filters :portkey.aws.ssm.-2014-11-06/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/notification-event-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/notification-event))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/step-execution-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/step-execution))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/path (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/ps-parameter-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/recursive (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/parameter-filters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-string-filter-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/with-decryption (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/boolean))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/max-results (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-max-results))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/path] :opt-un [:portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/recursive :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/parameter-filters :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/with-decryption :portkey.aws.ssm.-2014-11-06.get-parameters-by-path-request/max-results :portkey.aws.ssm.-2014-11-06/next-token]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-association-status-aggregated-count (clojure.spec.alpha/map-of :portkey.aws.ssm.-2014-11-06/status-name :portkey.aws.ssm.-2014-11-06/instance-count))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/window-id (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-id))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/end-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/enabled (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-enabled))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/next-execution-time (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/duration (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-duration-hours))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/cutoff (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-cutoff))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/schedule (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-schedule))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/start-date (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-string-date-time))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/schedule-timezone (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/maintenance-window-timezone))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-identity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.maintenance-window-identity/window-id :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/end-date :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/enabled :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/next-execution-time :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/description :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/duration :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/cutoff :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/schedule :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/name :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/start-date :portkey.aws.ssm.-2014-11-06.maintenance-window-identity/schedule-timezone]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/snapshot-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 36 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 36)) (clojure.core/fn [s__1467903__auto__] (clojure.core/re-matches #"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$" s__1467903__auto__))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/get-default-patch-baseline-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06/operating-system]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/registration-limit (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/add-tags-to-resource-result (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-activation-request/description (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/activation-description))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.create-activation-request/tags (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/tag-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/create-activation-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06/iam-role] :opt-un [:portkey.aws.ssm.-2014-11-06.create-activation-request/description :portkey.aws.ssm.-2014-11-06/default-instance-name :portkey.aws.ssm.-2014-11-06/registration-limit :portkey.aws.ssm.-2014-11-06/expiration-date :portkey.aws.ssm.-2014-11-06.create-activation-request/tags]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.invalid-document-schema-version/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/invalid-document-schema-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.invalid-document-schema-version/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/standard-error-content (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 8000))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/modify-document-permission-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/association-filter-operator-type #{"GREATER_THAN" :less-than :greater-than "LESS_THAN" "EQUAL" :equal})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/date-time clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-operation-type #{:install "Scan" "Install" :scan})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.parameter-version-not-found/message (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/string))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/parameter-version-not-found (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.parameter-version-not-found/message]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-values (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/target-value :min-count 0 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/patch-kb-number (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-attribute-data-type #{"string" :number :string "number"})

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/instance-patch-state-list (clojure.spec.alpha/coll-of :portkey.aws.ssm.-2014-11-06/instance-patch-state))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/target-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-task-parameter-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1467901__auto__] (clojure.core/<= 1 (clojure.core/count s__1467901__auto__))) (clojure.core/fn [s__1467902__auto__] (clojure.core/< (clojure.core/count s__1467902__auto__) 255))))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-parameters-result/deleted-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.delete-parameters-result/invalid-parameters (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/parameter-name-list))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/delete-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.delete-parameters-result/deleted-parameters :portkey.aws.ssm.-2014-11-06.delete-parameters-result/invalid-parameters]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/inventory-deletion-last-status-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-document-request/name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-arn))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.describe-document-request/version-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/document-version-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/describe-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.ssm.-2014-11-06.describe-document-request/name] :opt-un [:portkey.aws.ssm.-2014-11-06/document-version :portkey.aws.ssm.-2014-11-06.describe-document-request/version-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06.resource-data-sync-not-found-exception/sync-name (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resource-data-sync-name))
(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/resource-data-sync-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.ssm.-2014-11-06.resource-data-sync-not-found-exception/sync-name]))

(clojure.spec.alpha/def :portkey.aws.ssm.-2014-11-06/maintenance-window-resource-type #{"INSTANCE" :instance})

(clojure.core/defn cancel-maintenance-window-execution ([cancel-maintenance-window-execution-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-cancel-maintenance-window-execution-request cancel-maintenance-window-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/cancel-maintenance-window-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/cancel-maintenance-window-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelMaintenanceWindowExecution", :http.request.configuration/output-deser-fn response-cancel-maintenance-window-execution-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception}})))))
(clojure.spec.alpha/fdef cancel-maintenance-window-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/cancel-maintenance-window-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/cancel-maintenance-window-execution-result))

(clojure.core/defn update-maintenance-window-task ([update-maintenance-window-task-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-maintenance-window-task-request update-maintenance-window-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-maintenance-window-task-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-maintenance-window-task-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMaintenanceWindowTask", :http.request.configuration/output-deser-fn response-update-maintenance-window-task-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef update-maintenance-window-task :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-maintenance-window-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-maintenance-window-task-result))

(clojure.core/defn delete-activation ([delete-activation-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-activation-request delete-activation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-activation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-activation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteActivation", :http.request.configuration/output-deser-fn response-delete-activation-result, :http.request.spec/error-spec {"InvalidActivationId" :portkey.aws.ssm.-2014-11-06/invalid-activation-id, "InvalidActivation" :portkey.aws.ssm.-2014-11-06/invalid-activation, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef delete-activation :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-activation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-activation-result))

(clojure.core/defn describe-patch-group-state ([describe-patch-group-state-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-patch-group-state-request describe-patch-group-state-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-patch-group-state-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-patch-group-state-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePatchGroupState", :http.request.configuration/output-deser-fn response-describe-patch-group-state-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-patch-group-state :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-patch-group-state-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-patch-group-state-result))

(clojure.core/defn cancel-command ([cancel-command-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-cancel-command-request cancel-command-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/cancel-command-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/cancel-command-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelCommand", :http.request.configuration/output-deser-fn response-cancel-command-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidCommandId" :portkey.aws.ssm.-2014-11-06/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "DuplicateInstanceId" :portkey.aws.ssm.-2014-11-06/duplicate-instance-id}})))))
(clojure.spec.alpha/fdef cancel-command :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/cancel-command-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/cancel-command-result))

(clojure.core/defn describe-document ([describe-document-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-document-request describe-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDocument", :http.request.configuration/output-deser-fn response-describe-document-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version}})))))
(clojure.spec.alpha/fdef describe-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-document-result))

(clojure.core/defn get-default-patch-baseline ([] (get-default-patch-baseline {})) ([get-default-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-default-patch-baseline-request get-default-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-default-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-default-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDefaultPatchBaseline", :http.request.configuration/output-deser-fn response-get-default-patch-baseline-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-default-patch-baseline :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/get-default-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-default-patch-baseline-result))

(clojure.core/defn describe-inventory-deletions ([] (describe-inventory-deletions {})) ([describe-inventory-deletions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-inventory-deletions-request describe-inventory-deletions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-inventory-deletions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-inventory-deletions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInventoryDeletions", :http.request.configuration/output-deser-fn response-describe-inventory-deletions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDeletionIdException" :portkey.aws.ssm.-2014-11-06/invalid-deletion-id-exception, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-inventory-deletions :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-inventory-deletions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-inventory-deletions-result))

(clojure.core/defn get-maintenance-window-task ([get-maintenance-window-task-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-maintenance-window-task-request get-maintenance-window-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-task-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-task-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowTask", :http.request.configuration/output-deser-fn response-get-maintenance-window-task-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-task :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-maintenance-window-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-maintenance-window-task-result))

(clojure.core/defn register-default-patch-baseline ([register-default-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-register-default-patch-baseline-request register-default-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/register-default-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/register-default-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterDefaultPatchBaseline", :http.request.configuration/output-deser-fn response-register-default-patch-baseline-result, :http.request.spec/error-spec {"InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef register-default-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/register-default-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/register-default-patch-baseline-result))

(clojure.core/defn put-inventory ([put-inventory-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-put-inventory-request put-inventory-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/put-inventory-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/put-inventory-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutInventory", :http.request.configuration/output-deser-fn response-put-inventory-result, :http.request.spec/error-spec {"InvalidTypeNameException" :portkey.aws.ssm.-2014-11-06/invalid-type-name-exception, "ItemContentMismatchException" :portkey.aws.ssm.-2014-11-06/item-content-mismatch-exception, "UnsupportedInventoryItemContextException" :portkey.aws.ssm.-2014-11-06/unsupported-inventory-item-context-exception, "TotalSizeLimitExceededException" :portkey.aws.ssm.-2014-11-06/total-size-limit-exceeded-exception, "CustomSchemaCountLimitExceededException" :portkey.aws.ssm.-2014-11-06/custom-schema-count-limit-exceeded-exception, "UnsupportedInventorySchemaVersionException" :portkey.aws.ssm.-2014-11-06/unsupported-inventory-schema-version-exception, "InvalidItemContentException" :portkey.aws.ssm.-2014-11-06/invalid-item-content-exception, "InvalidInventoryItemContextException" :portkey.aws.ssm.-2014-11-06/invalid-inventory-item-context-exception, "SubTypeCountLimitExceededException" :portkey.aws.ssm.-2014-11-06/sub-type-count-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "ItemSizeLimitExceededException" :portkey.aws.ssm.-2014-11-06/item-size-limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef put-inventory :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/put-inventory-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/put-inventory-result))

(clojure.core/defn send-automation-signal ([send-automation-signal-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-send-automation-signal-request send-automation-signal-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/send-automation-signal-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/send-automation-signal-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SendAutomationSignal", :http.request.configuration/output-deser-fn response-send-automation-signal-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-execution-not-found-exception, "AutomationStepNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-step-not-found-exception, "InvalidAutomationSignalException" :portkey.aws.ssm.-2014-11-06/invalid-automation-signal-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef send-automation-signal :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/send-automation-signal-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/send-automation-signal-result))

(clojure.core/defn get-document ([get-document-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-document-request get-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocument", :http.request.configuration/output-deser-fn response-get-document-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version}})))))
(clojure.spec.alpha/fdef get-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-document-result))

(clojure.core/defn describe-maintenance-windows ([] (describe-maintenance-windows {})) ([describe-maintenance-windows-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-windows-request describe-maintenance-windows-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindows", :http.request.configuration/output-deser-fn response-describe-maintenance-windows-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-windows :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-result))

(clojure.core/defn put-compliance-items ([put-compliance-items-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-put-compliance-items-request put-compliance-items-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/put-compliance-items-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/put-compliance-items-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutComplianceItems", :http.request.configuration/output-deser-fn response-put-compliance-items-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidItemContentException" :portkey.aws.ssm.-2014-11-06/invalid-item-content-exception, "TotalSizeLimitExceededException" :portkey.aws.ssm.-2014-11-06/total-size-limit-exceeded-exception, "ItemSizeLimitExceededException" :portkey.aws.ssm.-2014-11-06/item-size-limit-exceeded-exception, "ComplianceTypeCountLimitExceededException" :portkey.aws.ssm.-2014-11-06/compliance-type-count-limit-exceeded-exception, "InvalidResourceType" :portkey.aws.ssm.-2014-11-06/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id}})))))
(clojure.spec.alpha/fdef put-compliance-items :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/put-compliance-items-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/put-compliance-items-result))

(clojure.core/defn update-service-setting ([update-service-setting-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-service-setting-request update-service-setting-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-service-setting-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-service-setting-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateServiceSetting", :http.request.configuration/output-deser-fn response-update-service-setting-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ServiceSettingNotFound" :portkey.aws.ssm.-2014-11-06/service-setting-not-found, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef update-service-setting :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-service-setting-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-service-setting-result))

(clojure.core/defn describe-patch-baselines ([] (describe-patch-baselines {})) ([describe-patch-baselines-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-patch-baselines-request describe-patch-baselines-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-patch-baselines-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-patch-baselines-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePatchBaselines", :http.request.configuration/output-deser-fn response-describe-patch-baselines-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-patch-baselines :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-patch-baselines-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-patch-baselines-result))

(clojure.core/defn get-parameters-by-path ([get-parameters-by-path-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-parameters-by-path-request get-parameters-by-path-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParametersByPath", :http.request.configuration/output-deser-fn response-get-parameters-by-path-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidFilterOption" :portkey.aws.ssm.-2014-11-06/invalid-filter-option, "InvalidFilterValue" :portkey.aws.ssm.-2014-11-06/invalid-filter-value, "InvalidKeyId" :portkey.aws.ssm.-2014-11-06/invalid-key-id, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef get-parameters-by-path :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-parameters-by-path-result))

(clojure.core/defn get-deployable-patch-snapshot-for-instance ([get-deployable-patch-snapshot-for-instance-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-deployable-patch-snapshot-for-instance-request get-deployable-patch-snapshot-for-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-deployable-patch-snapshot-for-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-deployable-patch-snapshot-for-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDeployablePatchSnapshotForInstance", :http.request.configuration/output-deser-fn response-get-deployable-patch-snapshot-for-instance-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "UnsupportedOperatingSystem" :portkey.aws.ssm.-2014-11-06/unsupported-operating-system}})))))
(clojure.spec.alpha/fdef get-deployable-patch-snapshot-for-instance :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-deployable-patch-snapshot-for-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-deployable-patch-snapshot-for-instance-result))

(clojure.core/defn get-maintenance-window ([get-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-maintenance-window-request get-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindow", :http.request.configuration/output-deser-fn response-get-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-maintenance-window-result))

(clojure.core/defn create-association-batch ([create-association-batch-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-association-batch-request create-association-batch-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-association-batch-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-association-batch-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAssociationBatch", :http.request.configuration/output-deser-fn response-create-association-batch-result, :http.request.spec/error-spec {"InvalidSchedule" :portkey.aws.ssm.-2014-11-06/invalid-schedule, "AssociationLimitExceeded" :portkey.aws.ssm.-2014-11-06/association-limit-exceeded, "DuplicateInstanceId" :portkey.aws.ssm.-2014-11-06/duplicate-instance-id, "UnsupportedPlatformType" :portkey.aws.ssm.-2014-11-06/unsupported-platform-type, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version, "InvalidParameters" :portkey.aws.ssm.-2014-11-06/invalid-parameters, "InvalidTarget" :portkey.aws.ssm.-2014-11-06/invalid-target, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidOutputLocation" :portkey.aws.ssm.-2014-11-06/invalid-output-location}})))))
(clojure.spec.alpha/fdef create-association-batch :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-association-batch-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-association-batch-result))

(clojure.core/defn describe-maintenance-window-tasks ([describe-maintenance-window-tasks-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-window-tasks-request describe-maintenance-window-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-tasks-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowTasks", :http.request.configuration/output-deser-fn response-describe-maintenance-window-tasks-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-tasks :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-tasks-result))

(clojure.core/defn register-task-with-maintenance-window ([register-task-with-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-register-task-with-maintenance-window-request register-task-with-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/register-task-with-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/register-task-with-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterTaskWithMaintenanceWindow", :http.request.configuration/output-deser-fn response-register-task-with-maintenance-window-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm.-2014-11-06/idempotent-parameter-mismatch, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "ResourceLimitExceededException" :portkey.aws.ssm.-2014-11-06/resource-limit-exceeded-exception, "FeatureNotAvailableException" :portkey.aws.ssm.-2014-11-06/feature-not-available-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef register-task-with-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/register-task-with-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/register-task-with-maintenance-window-result))

(clojure.core/defn deregister-patch-baseline-for-patch-group ([deregister-patch-baseline-for-patch-group-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-deregister-patch-baseline-for-patch-group-request deregister-patch-baseline-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/deregister-patch-baseline-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/deregister-patch-baseline-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterPatchBaselineForPatchGroup", :http.request.configuration/output-deser-fn response-deregister-patch-baseline-for-patch-group-result, :http.request.spec/error-spec {"InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef deregister-patch-baseline-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/deregister-patch-baseline-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/deregister-patch-baseline-for-patch-group-result))

(clojure.core/defn list-commands ([] (list-commands {})) ([list-commands-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-commands-request list-commands-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-commands-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-commands-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCommands", :http.request.configuration/output-deser-fn response-list-commands-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidCommandId" :portkey.aws.ssm.-2014-11-06/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-commands :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-commands-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-commands-result))

(clojure.core/defn update-patch-baseline ([update-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-patch-baseline-request update-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdatePatchBaseline", :http.request.configuration/output-deser-fn response-update-patch-baseline-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef update-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-patch-baseline-result))

(clojure.core/defn update-maintenance-window-target ([update-maintenance-window-target-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-maintenance-window-target-request update-maintenance-window-target-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-maintenance-window-target-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-maintenance-window-target-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMaintenanceWindowTarget", :http.request.configuration/output-deser-fn response-update-maintenance-window-target-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef update-maintenance-window-target :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-maintenance-window-target-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-maintenance-window-target-result))

(clojure.core/defn delete-resource-data-sync ([delete-resource-data-sync-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-resource-data-sync-request delete-resource-data-sync-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-resource-data-sync-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-resource-data-sync-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteResourceDataSync", :http.request.configuration/output-deser-fn response-delete-resource-data-sync-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ResourceDataSyncNotFoundException" :portkey.aws.ssm.-2014-11-06/resource-data-sync-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-resource-data-sync :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-resource-data-sync-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-resource-data-sync-result))

(clojure.core/defn describe-maintenance-window-schedule ([] (describe-maintenance-window-schedule {})) ([describe-maintenance-window-schedule-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-window-schedule-request describe-maintenance-window-schedule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-schedule-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-schedule-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowSchedule", :http.request.configuration/output-deser-fn response-describe-maintenance-window-schedule-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-schedule :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-schedule-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-schedule-result))

(clojure.core/defn deregister-task-from-maintenance-window ([deregister-task-from-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-deregister-task-from-maintenance-window-request deregister-task-from-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/deregister-task-from-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/deregister-task-from-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterTaskFromMaintenanceWindow", :http.request.configuration/output-deser-fn response-deregister-task-from-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef deregister-task-from-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/deregister-task-from-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/deregister-task-from-maintenance-window-result))

(clojure.core/defn get-parameter-history ([get-parameter-history-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-parameter-history-request get-parameter-history-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-parameter-history-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-parameter-history-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParameterHistory", :http.request.configuration/output-deser-fn response-get-parameter-history-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ParameterNotFound" :portkey.aws.ssm.-2014-11-06/parameter-not-found, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InvalidKeyId" :portkey.aws.ssm.-2014-11-06/invalid-key-id}})))))
(clojure.spec.alpha/fdef get-parameter-history :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-parameter-history-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-parameter-history-result))

(clojure.core/defn start-session ([start-session-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-start-session-request start-session-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/start-session-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/start-session-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartSession", :http.request.configuration/output-deser-fn response-start-session-response, :http.request.spec/error-spec {"InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "TargetNotConnected" :portkey.aws.ssm.-2014-11-06/target-not-connected, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef start-session :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/start-session-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/start-session-response))

(clojure.core/defn list-association-versions ([list-association-versions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-association-versions-request list-association-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-association-versions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-association-versions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAssociationVersions", :http.request.configuration/output-deser-fn response-list-association-versions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist}})))))
(clojure.spec.alpha/fdef list-association-versions :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/list-association-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-association-versions-result))

(clojure.core/defn list-tags-for-resource ([list-tags-for-resource-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-tags-for-resource-request list-tags-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-tags-for-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-tags-for-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-list-tags-for-resource-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm.-2014-11-06/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/list-tags-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-tags-for-resource-result))

(clojure.core/defn create-document ([create-document-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-document-request create-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDocument", :http.request.configuration/output-deser-fn response-create-document-result, :http.request.spec/error-spec {"DocumentAlreadyExists" :portkey.aws.ssm.-2014-11-06/document-already-exists, "MaxDocumentSizeExceeded" :portkey.aws.ssm.-2014-11-06/max-document-size-exceeded, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocumentContent" :portkey.aws.ssm.-2014-11-06/invalid-document-content, "DocumentLimitExceeded" :portkey.aws.ssm.-2014-11-06/document-limit-exceeded, "InvalidDocumentSchemaVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-schema-version}})))))
(clojure.spec.alpha/fdef create-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-document-result))

(clojure.core/defn list-resource-data-sync ([] (list-resource-data-sync {})) ([list-resource-data-sync-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-resource-data-sync-request list-resource-data-sync-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-resource-data-sync-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-resource-data-sync-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListResourceDataSync", :http.request.configuration/output-deser-fn response-list-resource-data-sync-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-resource-data-sync :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-resource-data-sync-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-resource-data-sync-result))

(clojure.core/defn describe-association ([] (describe-association {})) ([describe-association-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-association-request describe-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAssociation", :http.request.configuration/output-deser-fn response-describe-association-result, :http.request.spec/error-spec {"AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist, "InvalidAssociationVersion" :portkey.aws.ssm.-2014-11-06/invalid-association-version, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id}})))))
(clojure.spec.alpha/fdef describe-association :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-association-result))

(clojure.core/defn describe-automation-executions ([] (describe-automation-executions {})) ([describe-automation-executions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-automation-executions-request describe-automation-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-automation-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-automation-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAutomationExecutions", :http.request.configuration/output-deser-fn response-describe-automation-executions-result, :http.request.spec/error-spec {"InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidFilterValue" :portkey.aws.ssm.-2014-11-06/invalid-filter-value, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-automation-executions :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-automation-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-automation-executions-result))

(clojure.core/defn get-parameter ([get-parameter-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-parameter-request get-parameter-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-parameter-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-parameter-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParameter", :http.request.configuration/output-deser-fn response-get-parameter-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidKeyId" :portkey.aws.ssm.-2014-11-06/invalid-key-id, "ParameterNotFound" :portkey.aws.ssm.-2014-11-06/parameter-not-found, "ParameterVersionNotFound" :portkey.aws.ssm.-2014-11-06/parameter-version-not-found}})))))
(clojure.spec.alpha/fdef get-parameter :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-parameter-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-parameter-result))

(clojure.core/defn start-associations-once ([start-associations-once-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-start-associations-once-request start-associations-once-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/start-associations-once-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/start-associations-once-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartAssociationsOnce", :http.request.configuration/output-deser-fn response-start-associations-once-result, :http.request.spec/error-spec {"InvalidAssociation" :portkey.aws.ssm.-2014-11-06/invalid-association, "AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist}})))))
(clojure.spec.alpha/fdef start-associations-once :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/start-associations-once-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/start-associations-once-result))

(clojure.core/defn update-document-default-version ([update-document-default-version-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-document-default-version-request update-document-default-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-document-default-version-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-document-default-version-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentDefaultVersion", :http.request.configuration/output-deser-fn response-update-document-default-version-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version, "InvalidDocumentSchemaVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-schema-version}})))))
(clojure.spec.alpha/fdef update-document-default-version :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-document-default-version-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-document-default-version-result))

(clojure.core/defn update-association ([update-association-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-association-request update-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAssociation", :http.request.configuration/output-deser-fn response-update-association-result, :http.request.spec/error-spec {"InvalidSchedule" :portkey.aws.ssm.-2014-11-06/invalid-schedule, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version, "InvalidParameters" :portkey.aws.ssm.-2014-11-06/invalid-parameters, "AssociationVersionLimitExceeded" :portkey.aws.ssm.-2014-11-06/association-version-limit-exceeded, "InvalidTarget" :portkey.aws.ssm.-2014-11-06/invalid-target, "InvalidAssociationVersion" :portkey.aws.ssm.-2014-11-06/invalid-association-version, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidUpdate" :portkey.aws.ssm.-2014-11-06/invalid-update, "InvalidOutputLocation" :portkey.aws.ssm.-2014-11-06/invalid-output-location}})))))
(clojure.spec.alpha/fdef update-association :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-association-result))

(clojure.core/defn get-maintenance-window-execution-task-invocation ([get-maintenance-window-execution-task-invocation-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-maintenance-window-execution-task-invocation-request get-maintenance-window-execution-task-invocation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-invocation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-invocation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowExecutionTaskInvocation", :http.request.configuration/output-deser-fn response-get-maintenance-window-execution-task-invocation-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-execution-task-invocation :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-invocation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-invocation-result))

(clojure.core/defn send-command ([send-command-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-send-command-request send-command-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/send-command-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/send-command-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SendCommand", :http.request.configuration/output-deser-fn response-send-command-result, :http.request.spec/error-spec {"MaxDocumentSizeExceeded" :portkey.aws.ssm.-2014-11-06/max-document-size-exceeded, "DuplicateInstanceId" :portkey.aws.ssm.-2014-11-06/duplicate-instance-id, "UnsupportedPlatformType" :portkey.aws.ssm.-2014-11-06/unsupported-platform-type, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version, "InvalidParameters" :portkey.aws.ssm.-2014-11-06/invalid-parameters, "InvalidNotificationConfig" :portkey.aws.ssm.-2014-11-06/invalid-notification-config, "InvalidOutputFolder" :portkey.aws.ssm.-2014-11-06/invalid-output-folder, "InvalidRole" :portkey.aws.ssm.-2014-11-06/invalid-role, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id}})))))
(clojure.spec.alpha/fdef send-command :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/send-command-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/send-command-result))

(clojure.core/defn describe-parameters ([] (describe-parameters {})) ([describe-parameters-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-parameters-request describe-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeParameters", :http.request.configuration/output-deser-fn response-describe-parameters-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidFilterOption" :portkey.aws.ssm.-2014-11-06/invalid-filter-option, "InvalidFilterValue" :portkey.aws.ssm.-2014-11-06/invalid-filter-value, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-parameters :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-parameters-result))

(clojure.core/defn resume-session ([resume-session-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-resume-session-request resume-session-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/resume-session-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/resume-session-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResumeSession", :http.request.configuration/output-deser-fn response-resume-session-response, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef resume-session :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/resume-session-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/resume-session-response))

(clojure.core/defn update-managed-instance-role ([update-managed-instance-role-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-managed-instance-role-request update-managed-instance-role-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-managed-instance-role-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-managed-instance-role-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateManagedInstanceRole", :http.request.configuration/output-deser-fn response-update-managed-instance-role-result, :http.request.spec/error-spec {"InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef update-managed-instance-role :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-managed-instance-role-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-managed-instance-role-result))

(clojure.core/defn create-activation ([create-activation-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-activation-request create-activation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-activation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-activation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateActivation", :http.request.configuration/output-deser-fn response-create-activation-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef create-activation :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-activation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-activation-result))

(clojure.core/defn list-document-versions ([list-document-versions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-document-versions-request list-document-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-document-versions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-document-versions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListDocumentVersions", :http.request.configuration/output-deser-fn response-list-document-versions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document}})))))
(clojure.spec.alpha/fdef list-document-versions :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/list-document-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-document-versions-result))

(clojure.core/defn reset-service-setting ([reset-service-setting-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-reset-service-setting-request reset-service-setting-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/reset-service-setting-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/reset-service-setting-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ResetServiceSetting", :http.request.configuration/output-deser-fn response-reset-service-setting-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ServiceSettingNotFound" :portkey.aws.ssm.-2014-11-06/service-setting-not-found, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef reset-service-setting :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/reset-service-setting-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/reset-service-setting-result))

(clojure.core/defn describe-effective-instance-associations ([describe-effective-instance-associations-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-effective-instance-associations-request describe-effective-instance-associations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-effective-instance-associations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-effective-instance-associations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEffectiveInstanceAssociations", :http.request.configuration/output-deser-fn response-describe-effective-instance-associations-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-effective-instance-associations :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-effective-instance-associations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-effective-instance-associations-result))

(clojure.core/defn describe-maintenance-windows-for-target ([describe-maintenance-windows-for-target-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-windows-for-target-request describe-maintenance-windows-for-target-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-for-target-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-for-target-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowsForTarget", :http.request.configuration/output-deser-fn response-describe-maintenance-windows-for-target-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-windows-for-target :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-for-target-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-windows-for-target-result))

(clojure.core/defn modify-document-permission ([modify-document-permission-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-modify-document-permission-request modify-document-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/modify-document-permission-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/modify-document-permission-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyDocumentPermission", :http.request.configuration/output-deser-fn response-modify-document-permission-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidPermissionType" :portkey.aws.ssm.-2014-11-06/invalid-permission-type, "DocumentPermissionLimit" :portkey.aws.ssm.-2014-11-06/document-permission-limit, "DocumentLimitExceeded" :portkey.aws.ssm.-2014-11-06/document-limit-exceeded}})))))
(clojure.spec.alpha/fdef modify-document-permission :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/modify-document-permission-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/modify-document-permission-response))

(clojure.core/defn get-maintenance-window-execution-task ([get-maintenance-window-execution-task-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-maintenance-window-execution-task-request get-maintenance-window-execution-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowExecutionTask", :http.request.configuration/output-deser-fn response-get-maintenance-window-execution-task-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-execution-task :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-task-result))

(clojure.core/defn describe-association-execution-targets ([describe-association-execution-targets-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-association-execution-targets-request describe-association-execution-targets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-association-execution-targets-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-association-execution-targets-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAssociationExecutionTargets", :http.request.configuration/output-deser-fn response-describe-association-execution-targets-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "AssociationExecutionDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-execution-does-not-exist}})))))
(clojure.spec.alpha/fdef describe-association-execution-targets :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-association-execution-targets-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-association-execution-targets-result))

(clojure.core/defn delete-inventory ([delete-inventory-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-inventory-request delete-inventory-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-inventory-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-inventory-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteInventory", :http.request.configuration/output-deser-fn response-delete-inventory-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidTypeNameException" :portkey.aws.ssm.-2014-11-06/invalid-type-name-exception, "InvalidOptionException" :portkey.aws.ssm.-2014-11-06/invalid-option-exception, "InvalidDeleteInventoryParametersException" :portkey.aws.ssm.-2014-11-06/invalid-delete-inventory-parameters-exception, "InvalidInventoryRequestException" :portkey.aws.ssm.-2014-11-06/invalid-inventory-request-exception}})))))
(clojure.spec.alpha/fdef delete-inventory :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-inventory-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-inventory-result))

(clojure.core/defn list-resource-compliance-summaries ([] (list-resource-compliance-summaries {})) ([list-resource-compliance-summaries-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-resource-compliance-summaries-request list-resource-compliance-summaries-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-resource-compliance-summaries-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-resource-compliance-summaries-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListResourceComplianceSummaries", :http.request.configuration/output-deser-fn response-list-resource-compliance-summaries-result, :http.request.spec/error-spec {"InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef list-resource-compliance-summaries :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-resource-compliance-summaries-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-resource-compliance-summaries-result))

(clojure.core/defn get-patch-baseline-for-patch-group ([get-patch-baseline-for-patch-group-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-patch-baseline-for-patch-group-request get-patch-baseline-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-patch-baseline-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-patch-baseline-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPatchBaselineForPatchGroup", :http.request.configuration/output-deser-fn response-get-patch-baseline-for-patch-group-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-patch-baseline-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-patch-baseline-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-patch-baseline-for-patch-group-result))

(clojure.core/defn get-service-setting ([get-service-setting-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-service-setting-request get-service-setting-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-service-setting-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-service-setting-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetServiceSetting", :http.request.configuration/output-deser-fn response-get-service-setting-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ServiceSettingNotFound" :portkey.aws.ssm.-2014-11-06/service-setting-not-found}})))))
(clojure.spec.alpha/fdef get-service-setting :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-service-setting-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-service-setting-result))

(clojure.core/defn get-maintenance-window-execution ([get-maintenance-window-execution-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-maintenance-window-execution-request get-maintenance-window-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMaintenanceWindowExecution", :http.request.configuration/output-deser-fn response-get-maintenance-window-execution-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-maintenance-window-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-maintenance-window-execution-result))

(clojure.core/defn delete-parameters ([delete-parameters-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-parameters-request delete-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteParameters", :http.request.configuration/output-deser-fn response-delete-parameters-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef delete-parameters :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-parameters-result))

(clojure.core/defn create-association ([create-association-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-association-request create-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAssociation", :http.request.configuration/output-deser-fn response-create-association-result, :http.request.spec/error-spec {"InvalidSchedule" :portkey.aws.ssm.-2014-11-06/invalid-schedule, "AssociationLimitExceeded" :portkey.aws.ssm.-2014-11-06/association-limit-exceeded, "AssociationAlreadyExists" :portkey.aws.ssm.-2014-11-06/association-already-exists, "UnsupportedPlatformType" :portkey.aws.ssm.-2014-11-06/unsupported-platform-type, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version, "InvalidParameters" :portkey.aws.ssm.-2014-11-06/invalid-parameters, "InvalidTarget" :portkey.aws.ssm.-2014-11-06/invalid-target, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidOutputLocation" :portkey.aws.ssm.-2014-11-06/invalid-output-location}})))))
(clojure.spec.alpha/fdef create-association :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-association-result))

(clojure.core/defn list-compliance-items ([] (list-compliance-items {})) ([list-compliance-items-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-compliance-items-request list-compliance-items-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-compliance-items-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-compliance-items-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListComplianceItems", :http.request.configuration/output-deser-fn response-list-compliance-items-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm.-2014-11-06/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-compliance-items :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-compliance-items-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-compliance-items-result))

(clojure.core/defn list-documents ([] (list-documents {})) ([list-documents-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-documents-request list-documents-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-documents-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-documents-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListDocuments", :http.request.configuration/output-deser-fn response-list-documents-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key}})))))
(clojure.spec.alpha/fdef list-documents :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-documents-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-documents-result))

(clojure.core/defn describe-instance-patch-states-for-patch-group ([describe-instance-patch-states-for-patch-group-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-instance-patch-states-for-patch-group-request describe-instance-patch-states-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstancePatchStatesForPatchGroup", :http.request.configuration/output-deser-fn response-describe-instance-patch-states-for-patch-group-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-patch-states-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-for-patch-group-result))

(clojure.core/defn delete-association ([] (delete-association {})) ([delete-association-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-association-request delete-association-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-association-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-association-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAssociation", :http.request.configuration/output-deser-fn response-delete-association-result, :http.request.spec/error-spec {"AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef delete-association :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/delete-association-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-association-result))

(clojure.core/defn get-parameters ([get-parameters-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-parameters-request get-parameters-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-parameters-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetParameters", :http.request.configuration/output-deser-fn response-get-parameters-result, :http.request.spec/error-spec {"InvalidKeyId" :portkey.aws.ssm.-2014-11-06/invalid-key-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-parameters :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-parameters-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-parameters-result))

(clojure.core/defn update-association-status ([update-association-status-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-association-status-request update-association-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-association-status-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-association-status-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAssociationStatus", :http.request.configuration/output-deser-fn response-update-association-status-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist, "StatusUnchanged" :portkey.aws.ssm.-2014-11-06/status-unchanged, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef update-association-status :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-association-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-association-status-result))

(clojure.core/defn get-command-invocation ([get-command-invocation-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-command-invocation-request get-command-invocation-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-command-invocation-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-command-invocation-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCommandInvocation", :http.request.configuration/output-deser-fn response-get-command-invocation-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidCommandId" :portkey.aws.ssm.-2014-11-06/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidPluginName" :portkey.aws.ssm.-2014-11-06/invalid-plugin-name, "InvocationDoesNotExist" :portkey.aws.ssm.-2014-11-06/invocation-does-not-exist}})))))
(clojure.spec.alpha/fdef get-command-invocation :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-command-invocation-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-command-invocation-result))

(clojure.core/defn describe-automation-step-executions ([describe-automation-step-executions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-automation-step-executions-request describe-automation-step-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-automation-step-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-automation-step-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAutomationStepExecutions", :http.request.configuration/output-deser-fn response-describe-automation-step-executions-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-execution-not-found-exception, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidFilterValue" :portkey.aws.ssm.-2014-11-06/invalid-filter-value, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-automation-step-executions :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-automation-step-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-automation-step-executions-result))

(clojure.core/defn update-maintenance-window ([update-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-maintenance-window-request update-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMaintenanceWindow", :http.request.configuration/output-deser-fn response-update-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef update-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-maintenance-window-result))

(clojure.core/defn describe-instance-information ([] (describe-instance-information {})) ([describe-instance-information-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-instance-information-request describe-instance-information-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-instance-information-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-instance-information-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceInformation", :http.request.configuration/output-deser-fn response-describe-instance-information-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InvalidInstanceInformationFilterValue" :portkey.aws.ssm.-2014-11-06/invalid-instance-information-filter-value, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key}})))))
(clojure.spec.alpha/fdef describe-instance-information :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-instance-information-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-instance-information-result))

(clojure.core/defn describe-maintenance-window-execution-tasks ([describe-maintenance-window-execution-tasks-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-window-execution-tasks-request describe-maintenance-window-execution-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-tasks-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-tasks-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowExecutionTasks", :http.request.configuration/output-deser-fn response-describe-maintenance-window-execution-tasks-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-execution-tasks :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-tasks-result))

(clojure.core/defn describe-activations ([] (describe-activations {})) ([describe-activations-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-activations-request describe-activations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-activations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-activations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeActivations", :http.request.configuration/output-deser-fn response-describe-activations-result, :http.request.spec/error-spec {"InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-activations :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-activations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-activations-result))

(clojure.core/defn list-associations ([] (list-associations {})) ([list-associations-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-associations-request list-associations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-associations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-associations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAssociations", :http.request.configuration/output-deser-fn response-list-associations-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-associations :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-associations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-associations-result))

(clojure.core/defn deregister-managed-instance ([deregister-managed-instance-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-deregister-managed-instance-request deregister-managed-instance-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/deregister-managed-instance-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/deregister-managed-instance-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterManagedInstance", :http.request.configuration/output-deser-fn response-deregister-managed-instance-result, :http.request.spec/error-spec {"InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef deregister-managed-instance :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/deregister-managed-instance-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/deregister-managed-instance-result))

(clojure.core/defn deregister-target-from-maintenance-window ([deregister-target-from-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-deregister-target-from-maintenance-window-request deregister-target-from-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/deregister-target-from-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/deregister-target-from-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeregisterTargetFromMaintenanceWindow", :http.request.configuration/output-deser-fn response-deregister-target-from-maintenance-window-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "TargetInUseException" :portkey.aws.ssm.-2014-11-06/target-in-use-exception}})))))
(clojure.spec.alpha/fdef deregister-target-from-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/deregister-target-from-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/deregister-target-from-maintenance-window-result))

(clojure.core/defn describe-sessions ([describe-sessions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-sessions-request describe-sessions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-sessions-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-sessions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSessions", :http.request.configuration/output-deser-fn response-describe-sessions-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-sessions :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-sessions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-sessions-response))

(clojure.core/defn stop-automation-execution ([stop-automation-execution-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-stop-automation-execution-request stop-automation-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/stop-automation-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/stop-automation-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopAutomationExecution", :http.request.configuration/output-deser-fn response-stop-automation-execution-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-execution-not-found-exception, "InvalidAutomationStatusUpdateException" :portkey.aws.ssm.-2014-11-06/invalid-automation-status-update-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef stop-automation-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/stop-automation-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/stop-automation-execution-result))

(clojure.core/defn start-automation-execution ([start-automation-execution-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-start-automation-execution-request start-automation-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/start-automation-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/start-automation-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartAutomationExecution", :http.request.configuration/output-deser-fn response-start-automation-execution-result, :http.request.spec/error-spec {"AutomationDefinitionNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-definition-not-found-exception, "InvalidAutomationExecutionParametersException" :portkey.aws.ssm.-2014-11-06/invalid-automation-execution-parameters-exception, "AutomationExecutionLimitExceededException" :portkey.aws.ssm.-2014-11-06/automation-execution-limit-exceeded-exception, "AutomationDefinitionVersionNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-definition-version-not-found-exception, "IdempotentParameterMismatch" :portkey.aws.ssm.-2014-11-06/idempotent-parameter-mismatch, "InvalidTarget" :portkey.aws.ssm.-2014-11-06/invalid-target, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef start-automation-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/start-automation-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/start-automation-execution-result))

(clojure.core/defn get-connection-status ([get-connection-status-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-connection-status-request get-connection-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-connection-status-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-connection-status-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetConnectionStatus", :http.request.configuration/output-deser-fn response-get-connection-status-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-connection-status :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-connection-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-connection-status-response))

(clojure.core/defn describe-instance-patch-states ([describe-instance-patch-states-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-instance-patch-states-request describe-instance-patch-states-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstancePatchStates", :http.request.configuration/output-deser-fn response-describe-instance-patch-states-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-patch-states :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-instance-patch-states-result))

(clojure.core/defn update-document ([update-document-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-update-document-request update-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/update-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/update-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocument", :http.request.configuration/output-deser-fn response-update-document-result, :http.request.spec/error-spec {"InvalidDocumentContent" :portkey.aws.ssm.-2014-11-06/invalid-document-content, "MaxDocumentSizeExceeded" :portkey.aws.ssm.-2014-11-06/max-document-size-exceeded, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-version, "InvalidDocumentOperation" :portkey.aws.ssm.-2014-11-06/invalid-document-operation, "DuplicateDocumentContent" :portkey.aws.ssm.-2014-11-06/duplicate-document-content, "DuplicateDocumentVersionName" :portkey.aws.ssm.-2014-11-06/duplicate-document-version-name, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "DocumentVersionLimitExceeded" :portkey.aws.ssm.-2014-11-06/document-version-limit-exceeded, "InvalidDocumentSchemaVersion" :portkey.aws.ssm.-2014-11-06/invalid-document-schema-version}})))))
(clojure.spec.alpha/fdef update-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/update-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/update-document-result))

(clojure.core/defn describe-available-patches ([] (describe-available-patches {})) ([describe-available-patches-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-available-patches-request describe-available-patches-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-available-patches-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-available-patches-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAvailablePatches", :http.request.configuration/output-deser-fn response-describe-available-patches-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-available-patches :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-available-patches-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-available-patches-result))

(clojure.core/defn register-patch-baseline-for-patch-group ([register-patch-baseline-for-patch-group-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-register-patch-baseline-for-patch-group-request register-patch-baseline-for-patch-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/register-patch-baseline-for-patch-group-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/register-patch-baseline-for-patch-group-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterPatchBaselineForPatchGroup", :http.request.configuration/output-deser-fn response-register-patch-baseline-for-patch-group-result, :http.request.spec/error-spec {"AlreadyExistsException" :portkey.aws.ssm.-2014-11-06/already-exists-exception, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "ResourceLimitExceededException" :portkey.aws.ssm.-2014-11-06/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef register-patch-baseline-for-patch-group :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/register-patch-baseline-for-patch-group-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/register-patch-baseline-for-patch-group-result))

(clojure.core/defn create-patch-baseline ([create-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-patch-baseline-request create-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePatchBaseline", :http.request.configuration/output-deser-fn response-create-patch-baseline-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm.-2014-11-06/idempotent-parameter-mismatch, "ResourceLimitExceededException" :portkey.aws.ssm.-2014-11-06/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef create-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-patch-baseline-result))

(clojure.core/defn describe-effective-patches-for-patch-baseline ([describe-effective-patches-for-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-effective-patches-for-patch-baseline-request describe-effective-patches-for-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-effective-patches-for-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-effective-patches-for-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEffectivePatchesForPatchBaseline", :http.request.configuration/output-deser-fn response-describe-effective-patches-for-patch-baseline-result, :http.request.spec/error-spec {"InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "UnsupportedOperatingSystem" :portkey.aws.ssm.-2014-11-06/unsupported-operating-system, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-effective-patches-for-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-effective-patches-for-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-effective-patches-for-patch-baseline-result))

(clojure.core/defn describe-maintenance-window-executions ([describe-maintenance-window-executions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-window-executions-request describe-maintenance-window-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowExecutions", :http.request.configuration/output-deser-fn response-describe-maintenance-window-executions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-executions :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-executions-result))

(clojure.core/defn create-resource-data-sync ([create-resource-data-sync-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-resource-data-sync-request create-resource-data-sync-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-resource-data-sync-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-resource-data-sync-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateResourceDataSync", :http.request.configuration/output-deser-fn response-create-resource-data-sync-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ResourceDataSyncCountExceededException" :portkey.aws.ssm.-2014-11-06/resource-data-sync-count-exceeded-exception, "ResourceDataSyncAlreadyExistsException" :portkey.aws.ssm.-2014-11-06/resource-data-sync-already-exists-exception, "ResourceDataSyncInvalidConfigurationException" :portkey.aws.ssm.-2014-11-06/resource-data-sync-invalid-configuration-exception}})))))
(clojure.spec.alpha/fdef create-resource-data-sync :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-resource-data-sync-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-resource-data-sync-result))

(clojure.core/defn delete-document ([delete-document-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-document-request delete-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-document-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-document-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocument", :http.request.configuration/output-deser-fn response-delete-document-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidDocumentOperation" :portkey.aws.ssm.-2014-11-06/invalid-document-operation, "AssociatedInstances" :portkey.aws.ssm.-2014-11-06/associated-instances}})))))
(clojure.spec.alpha/fdef delete-document :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-document-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-document-result))

(clojure.core/defn delete-patch-baseline ([delete-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-patch-baseline-request delete-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePatchBaseline", :http.request.configuration/output-deser-fn response-delete-patch-baseline-result, :http.request.spec/error-spec {"ResourceInUseException" :portkey.aws.ssm.-2014-11-06/resource-in-use-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef delete-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-patch-baseline-result))

(clojure.core/defn remove-tags-from-resource ([remove-tags-from-resource-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-remove-tags-from-resource-request remove-tags-from-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/remove-tags-from-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/remove-tags-from-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveTagsFromResource", :http.request.configuration/output-deser-fn response-remove-tags-from-resource-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm.-2014-11-06/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef remove-tags-from-resource :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/remove-tags-from-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/remove-tags-from-resource-result))

(clojure.core/defn describe-document-permission ([describe-document-permission-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-document-permission-request describe-document-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-document-permission-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-document-permission-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDocumentPermission", :http.request.configuration/output-deser-fn response-describe-document-permission-response, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidDocument" :portkey.aws.ssm.-2014-11-06/invalid-document, "InvalidPermissionType" :portkey.aws.ssm.-2014-11-06/invalid-permission-type}})))))
(clojure.spec.alpha/fdef describe-document-permission :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-document-permission-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-document-permission-response))

(clojure.core/defn delete-maintenance-window ([delete-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-maintenance-window-request delete-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteMaintenanceWindow", :http.request.configuration/output-deser-fn response-delete-maintenance-window-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef delete-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-maintenance-window-result))

(clojure.core/defn get-automation-execution ([get-automation-execution-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-automation-execution-request get-automation-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-automation-execution-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-automation-execution-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAutomationExecution", :http.request.configuration/output-deser-fn response-get-automation-execution-result, :http.request.spec/error-spec {"AutomationExecutionNotFoundException" :portkey.aws.ssm.-2014-11-06/automation-execution-not-found-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-automation-execution :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-automation-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-automation-execution-result))

(clojure.core/defn create-maintenance-window ([create-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-create-maintenance-window-request create-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/create-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/create-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateMaintenanceWindow", :http.request.configuration/output-deser-fn response-create-maintenance-window-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm.-2014-11-06/idempotent-parameter-mismatch, "ResourceLimitExceededException" :portkey.aws.ssm.-2014-11-06/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef create-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/create-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/create-maintenance-window-result))

(clojure.core/defn describe-maintenance-window-targets ([describe-maintenance-window-targets-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-window-targets-request describe-maintenance-window-targets-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-targets-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-targets-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowTargets", :http.request.configuration/output-deser-fn response-describe-maintenance-window-targets-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-targets :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-targets-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-targets-result))

(clojure.core/defn describe-patch-groups ([] (describe-patch-groups {})) ([describe-patch-groups-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-patch-groups-request describe-patch-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-patch-groups-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-patch-groups-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribePatchGroups", :http.request.configuration/output-deser-fn response-describe-patch-groups-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-patch-groups :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/describe-patch-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-patch-groups-result))

(clojure.core/defn list-inventory-entries ([list-inventory-entries-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-inventory-entries-request list-inventory-entries-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-inventory-entries-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-inventory-entries-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListInventoryEntries", :http.request.configuration/output-deser-fn response-list-inventory-entries-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidTypeNameException" :portkey.aws.ssm.-2014-11-06/invalid-type-name-exception, "InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-inventory-entries :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/list-inventory-entries-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-inventory-entries-result))

(clojure.core/defn delete-parameter ([delete-parameter-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-delete-parameter-request delete-parameter-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/delete-parameter-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/delete-parameter-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteParameter", :http.request.configuration/output-deser-fn response-delete-parameter-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "ParameterNotFound" :portkey.aws.ssm.-2014-11-06/parameter-not-found}})))))
(clojure.spec.alpha/fdef delete-parameter :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/delete-parameter-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/delete-parameter-result))

(clojure.core/defn put-parameter ([put-parameter-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-put-parameter-request put-parameter-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/put-parameter-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/put-parameter-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutParameter", :http.request.configuration/output-deser-fn response-put-parameter-result, :http.request.spec/error-spec {"HierarchyTypeMismatchException" :portkey.aws.ssm.-2014-11-06/hierarchy-type-mismatch-exception, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates, "UnsupportedParameterType" :portkey.aws.ssm.-2014-11-06/unsupported-parameter-type, "HierarchyLevelLimitExceededException" :portkey.aws.ssm.-2014-11-06/hierarchy-level-limit-exceeded-exception, "ParameterAlreadyExists" :portkey.aws.ssm.-2014-11-06/parameter-already-exists, "ParameterLimitExceeded" :portkey.aws.ssm.-2014-11-06/parameter-limit-exceeded, "ParameterPatternMismatchException" :portkey.aws.ssm.-2014-11-06/parameter-pattern-mismatch-exception, "InvalidKeyId" :portkey.aws.ssm.-2014-11-06/invalid-key-id, "ParameterMaxVersionLimitExceeded" :portkey.aws.ssm.-2014-11-06/parameter-max-version-limit-exceeded, "InvalidAllowedPatternException" :portkey.aws.ssm.-2014-11-06/invalid-allowed-pattern-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef put-parameter :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/put-parameter-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/put-parameter-result))

(clojure.core/defn describe-maintenance-window-execution-task-invocations ([describe-maintenance-window-execution-task-invocations-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-maintenance-window-execution-task-invocations-request describe-maintenance-window-execution-task-invocations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-task-invocations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-task-invocations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeMaintenanceWindowExecutionTaskInvocations", :http.request.configuration/output-deser-fn response-describe-maintenance-window-execution-task-invocations-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef describe-maintenance-window-execution-task-invocations :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-task-invocations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-maintenance-window-execution-task-invocations-result))

(clojure.core/defn register-target-with-maintenance-window ([register-target-with-maintenance-window-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-register-target-with-maintenance-window-request register-target-with-maintenance-window-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/register-target-with-maintenance-window-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/register-target-with-maintenance-window-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterTargetWithMaintenanceWindow", :http.request.configuration/output-deser-fn response-register-target-with-maintenance-window-result, :http.request.spec/error-spec {"IdempotentParameterMismatch" :portkey.aws.ssm.-2014-11-06/idempotent-parameter-mismatch, "DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "ResourceLimitExceededException" :portkey.aws.ssm.-2014-11-06/resource-limit-exceeded-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef register-target-with-maintenance-window :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/register-target-with-maintenance-window-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/register-target-with-maintenance-window-result))

(clojure.core/defn label-parameter-version ([label-parameter-version-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-label-parameter-version-request label-parameter-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/label-parameter-version-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/label-parameter-version-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "LabelParameterVersion", :http.request.configuration/output-deser-fn response-label-parameter-version-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates, "ParameterNotFound" :portkey.aws.ssm.-2014-11-06/parameter-not-found, "ParameterVersionNotFound" :portkey.aws.ssm.-2014-11-06/parameter-version-not-found, "ParameterVersionLabelLimitExceeded" :portkey.aws.ssm.-2014-11-06/parameter-version-label-limit-exceeded}})))))
(clojure.spec.alpha/fdef label-parameter-version :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/label-parameter-version-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/label-parameter-version-result))

(clojure.core/defn get-patch-baseline ([get-patch-baseline-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-patch-baseline-request get-patch-baseline-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-patch-baseline-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-patch-baseline-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPatchBaseline", :http.request.configuration/output-deser-fn response-get-patch-baseline-result, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef get-patch-baseline :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/get-patch-baseline-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-patch-baseline-result))

(clojure.core/defn list-compliance-summaries ([] (list-compliance-summaries {})) ([list-compliance-summaries-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-compliance-summaries-request list-compliance-summaries-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-compliance-summaries-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-compliance-summaries-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListComplianceSummaries", :http.request.configuration/output-deser-fn response-list-compliance-summaries-result, :http.request.spec/error-spec {"InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef list-compliance-summaries :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-compliance-summaries-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-compliance-summaries-result))

(clojure.core/defn get-inventory ([] (get-inventory {})) ([get-inventory-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-inventory-request get-inventory-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-inventory-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-inventory-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInventory", :http.request.configuration/output-deser-fn response-get-inventory-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidInventoryGroupException" :portkey.aws.ssm.-2014-11-06/invalid-inventory-group-exception, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token, "InvalidTypeNameException" :portkey.aws.ssm.-2014-11-06/invalid-type-name-exception, "InvalidAggregatorException" :portkey.aws.ssm.-2014-11-06/invalid-aggregator-exception, "InvalidResultAttributeException" :portkey.aws.ssm.-2014-11-06/invalid-result-attribute-exception}})))))
(clojure.spec.alpha/fdef get-inventory :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/get-inventory-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-inventory-result))

(clojure.core/defn add-tags-to-resource ([add-tags-to-resource-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-add-tags-to-resource-request add-tags-to-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/add-tags-to-resource-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/add-tags-to-resource-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddTagsToResource", :http.request.configuration/output-deser-fn response-add-tags-to-resource-result, :http.request.spec/error-spec {"InvalidResourceType" :portkey.aws.ssm.-2014-11-06/invalid-resource-type, "InvalidResourceId" :portkey.aws.ssm.-2014-11-06/invalid-resource-id, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "TooManyTagsError" :portkey.aws.ssm.-2014-11-06/too-many-tags-error, "TooManyUpdates" :portkey.aws.ssm.-2014-11-06/too-many-updates}})))))
(clojure.spec.alpha/fdef add-tags-to-resource :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/add-tags-to-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/add-tags-to-resource-result))

(clojure.core/defn describe-instance-associations-status ([describe-instance-associations-status-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-instance-associations-status-request describe-instance-associations-status-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-instance-associations-status-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-instance-associations-status-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstanceAssociationsStatus", :http.request.configuration/output-deser-fn response-describe-instance-associations-status-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-associations-status :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-instance-associations-status-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-instance-associations-status-result))

(clojure.core/defn terminate-session ([terminate-session-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-terminate-session-request terminate-session-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/terminate-session-response, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/terminate-session-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TerminateSession", :http.request.configuration/output-deser-fn response-terminate-session-response, :http.request.spec/error-spec {"DoesNotExistException" :portkey.aws.ssm.-2014-11-06/does-not-exist-exception, "InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error}})))))
(clojure.spec.alpha/fdef terminate-session :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/terminate-session-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/terminate-session-response))

(clojure.core/defn list-command-invocations ([] (list-command-invocations {})) ([list-command-invocations-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-list-command-invocations-request list-command-invocations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/list-command-invocations-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/list-command-invocations-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCommandInvocations", :http.request.configuration/output-deser-fn response-list-command-invocations-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidCommandId" :portkey.aws.ssm.-2014-11-06/invalid-command-id, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidFilterKey" :portkey.aws.ssm.-2014-11-06/invalid-filter-key, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef list-command-invocations :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/list-command-invocations-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/list-command-invocations-result))

(clojure.core/defn get-inventory-schema ([] (get-inventory-schema {})) ([get-inventory-schema-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-get-inventory-schema-request get-inventory-schema-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/get-inventory-schema-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/get-inventory-schema-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetInventorySchema", :http.request.configuration/output-deser-fn response-get-inventory-schema-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidTypeNameException" :portkey.aws.ssm.-2014-11-06/invalid-type-name-exception, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef get-inventory-schema :args (clojure.spec.alpha/? :portkey.aws.ssm.-2014-11-06/get-inventory-schema-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/get-inventory-schema-result))

(clojure.core/defn describe-association-executions ([describe-association-executions-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-association-executions-request describe-association-executions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-association-executions-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-association-executions-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAssociationExecutions", :http.request.configuration/output-deser-fn response-describe-association-executions-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "AssociationDoesNotExist" :portkey.aws.ssm.-2014-11-06/association-does-not-exist, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-association-executions :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-association-executions-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-association-executions-result))

(clojure.core/defn describe-instance-patches ([describe-instance-patches-requestinput] (clojure.core/let [request-function-result__1468878__auto__ (req-describe-instance-patches-request describe-instance-patches-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1468878__auto__ {:http.request.configuration/endpoints portkey.aws.ssm.-2014-11-06/endpoints, :http.request.configuration/target-prefix "AmazonSSM", :http.request.spec/output-spec :portkey.aws.ssm.-2014-11-06/describe-instance-patches-result, :http.request.configuration/mime-type {"content-type" "application/x-amz-json-1.1"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2014-11-06", :http.request.configuration/service-id "SSM", :http.request.spec/input-spec :portkey.aws.ssm.-2014-11-06/describe-instance-patches-request, :http.request.configuration/protocol "json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeInstancePatches", :http.request.configuration/output-deser-fn response-describe-instance-patches-result, :http.request.spec/error-spec {"InternalServerError" :portkey.aws.ssm.-2014-11-06/internal-server-error, "InvalidInstanceId" :portkey.aws.ssm.-2014-11-06/invalid-instance-id, "InvalidFilter" :portkey.aws.ssm.-2014-11-06/invalid-filter, "InvalidNextToken" :portkey.aws.ssm.-2014-11-06/invalid-next-token}})))))
(clojure.spec.alpha/fdef describe-instance-patches :args (clojure.spec.alpha/tuple :portkey.aws.ssm.-2014-11-06/describe-instance-patches-request) :ret (clojure.spec.alpha/and :portkey.aws.ssm.-2014-11-06/describe-instance-patches-result))
