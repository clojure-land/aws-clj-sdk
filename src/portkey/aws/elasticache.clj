(ns portkey.aws.elasticache (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope
    {:service "elasticache", :region "us-gov-east-1"},
    :ssl-common-name "elasticache.us-gov-east-1.amazonaws.com",
    :endpoint "https://elasticache.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope
    {:service "elasticache", :region "ap-northeast-1"},
    :ssl-common-name "elasticache.ap-northeast-1.amazonaws.com",
    :endpoint "https://elasticache.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "elasticache", :region "eu-west-1"},
    :ssl-common-name "elasticache.eu-west-1.amazonaws.com",
    :endpoint "https://elasticache.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "elasticache", :region "us-east-2"},
    :ssl-common-name "elasticache.us-east-2.amazonaws.com",
    :endpoint "https://elasticache.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope
    {:service "elasticache", :region "ap-southeast-2"},
    :ssl-common-name "elasticache.ap-southeast-2.amazonaws.com",
    :endpoint "https://elasticache.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "elasticache", :region "cn-north-1"},
    :ssl-common-name "elasticache.cn-north-1.amazonaws.com.cn",
    :endpoint "https://elasticache.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "elasticache", :region "sa-east-1"},
    :ssl-common-name "elasticache.sa-east-1.amazonaws.com",
    :endpoint "https://elasticache.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope
    {:service "elasticache", :region "ap-southeast-1"},
    :ssl-common-name "elasticache.ap-southeast-1.amazonaws.com",
    :endpoint "https://elasticache.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope
    {:service "elasticache", :region "cn-northwest-1"},
    :ssl-common-name "elasticache.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://elasticache.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope
    {:service "elasticache", :region "ap-northeast-2"},
    :ssl-common-name "elasticache.ap-northeast-2.amazonaws.com",
    :endpoint "https://elasticache.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "elasticache", :region "eu-west-3"},
    :ssl-common-name "elasticache.eu-west-3.amazonaws.com",
    :endpoint "https://elasticache.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "elasticache", :region "ca-central-1"},
    :ssl-common-name "elasticache.ca-central-1.amazonaws.com",
    :endpoint "https://elasticache.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "elasticache", :region "eu-central-1"},
    :ssl-common-name "elasticache.eu-central-1.amazonaws.com",
    :endpoint "https://elasticache.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "elasticache", :region "eu-west-2"},
    :ssl-common-name "elasticache.eu-west-2.amazonaws.com",
    :endpoint "https://elasticache.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope
    {:service "elasticache", :region "us-gov-west-1"},
    :ssl-common-name "elasticache.us-gov-west-1.amazonaws.com",
    :endpoint "https://elasticache.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "elasticache", :region "us-west-2"},
    :ssl-common-name "elasticache.us-west-2.amazonaws.com",
    :endpoint "https://elasticache.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "elasticache", :region "us-east-1"},
    :ssl-common-name "elasticache.us-east-1.amazonaws.com",
    :endpoint "https://elasticache.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "elasticache", :region "us-west-1"},
    :ssl-common-name "elasticache.us-west-1.amazonaws.com",
    :endpoint "https://elasticache.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "elasticache", :region "ap-south-1"},
    :ssl-common-name "elasticache.ap-south-1.amazonaws.com",
    :endpoint "https://elasticache.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "fips"
   {:credential-scope
    {:service "elasticache", :region "us-gov-west-1"},
    :ssl-common-name "elasticache-fips.us-gov-west-1.amazonaws.com",
    :endpoint "https://elasticache-fips.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "elasticache", :region "eu-north-1"},
    :ssl-common-name "elasticache.eu-north-1.amazonaws.com",
    :endpoint "https://elasticache.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-subnet-identifier-list)

(clojure.core/declare ser-az-mode)

(clojure.core/declare ser-node-group-configuration-list)

(clojure.core/declare ser-node-groups-to-remove-list)

(clojure.core/declare ser-security-group-ids-list)

(clojure.core/declare ser-parameter-name-value-list)

(clojure.core/declare ser-resharding-configuration-list)

(clojure.core/declare ser-key-list)

(clojure.core/declare ser-availability-zones-list)

(clojure.core/declare ser-source-type)

(clojure.core/declare ser-snapshot-arns-list)

(clojure.core/declare ser-parameter-name-value)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-cache-security-group-name-list)

(clojure.core/declare ser-remove-replicas-list)

(clojure.core/declare ser-node-group-configuration)

(clojure.core/declare ser-cache-node-ids-list)

(clojure.core/declare ser-allowed-node-group-id)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-string)

(clojure.core/declare ser-resharding-configuration)

(clojure.core/declare ser-t-stamp)

(clojure.core/declare ser-preferred-availability-zone-list)

(clojure.core/declare ser-node-groups-to-retain-list)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-boolean-optional)

(clojure.core/declare ser-configure-shard)

(clojure.core/declare ser-integer-optional)

(clojure.core/declare ser-replica-configuration-list)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-subnet-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SubnetIdentifier"}))) input), :shape "SubnetIdentifierList", :type "list"})

(clojure.core/defn- ser-az-mode [input] #:http.request.field{:value (clojure.core/get {"single-az" "single-az", :singleaz "single-az", "cross-az" "cross-az", :crossaz "cross-az"} input), :shape "AZMode"})

(clojure.core/defn- ser-node-group-configuration-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-node-group-configuration coll) #:http.request.field{:shape "NodeGroupConfiguration", :location-name "NodeGroupConfiguration"}))) input), :shape "NodeGroupConfigurationList", :type "list"})

(clojure.core/defn- ser-node-groups-to-remove-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-allowed-node-group-id coll) #:http.request.field{:shape "AllowedNodeGroupId", :location-name "NodeGroupToRemove"}))) input), :shape "NodeGroupsToRemoveList", :type "list"})

(clojure.core/defn- ser-security-group-ids-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SecurityGroupId"}))) input), :shape "SecurityGroupIdsList", :type "list"})

(clojure.core/defn- ser-parameter-name-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter-name-value coll) #:http.request.field{:shape "ParameterNameValue", :location-name "ParameterNameValue"}))) input), :shape "ParameterNameValueList", :type "list"})

(clojure.core/defn- ser-resharding-configuration-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-resharding-configuration coll) #:http.request.field{:shape "ReshardingConfiguration", :location-name "ReshardingConfiguration"}))) input), :shape "ReshardingConfigurationList", :type "list"})

(clojure.core/defn- ser-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "KeyList", :type "list"})

(clojure.core/defn- ser-availability-zones-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "AvailabilityZone"}))) input), :shape "AvailabilityZonesList", :type "list"})

(clojure.core/defn- ser-source-type [input] #:http.request.field{:value (clojure.core/get {:cacheparametergroup "cache-parameter-group", "cache-subnet-group" "cache-subnet-group", "cache-parameter-group" "cache-parameter-group", "cache-cluster" "cache-cluster", :replicationgroup "replication-group", "replication-group" "replication-group", "cache-security-group" "cache-security-group", :cachesubnetgroup "cache-subnet-group", :cachecluster "cache-cluster", :cachesecuritygroup "cache-security-group"} input), :shape "SourceType"})

(clojure.core/defn- ser-snapshot-arns-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SnapshotArn"}))) input), :shape "SnapshotArnsList", :type "list"})

(clojure.core/defn- ser-parameter-name-value [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ParameterNameValue", :type "structure"} (clojure.core/contains? input :parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-name)) #:http.request.field{:name "ParameterName", :shape "String"})) (clojure.core/contains? input :parameter-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-value)) #:http.request.field{:name "ParameterValue", :shape "String"}))))

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag", :location-name "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-cache-security-group-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "CacheSecurityGroupName"}))) input), :shape "CacheSecurityGroupNameList", :type "list"})

(clojure.core/defn- ser-remove-replicas-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "RemoveReplicasList", :type "list"})

(clojure.core/defn- ser-node-group-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NodeGroupConfiguration", :type "structure"} (clojure.core/contains? input :node-group-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allowed-node-group-id (input :node-group-id)) #:http.request.field{:name "NodeGroupId", :shape "AllowedNodeGroupId"})) (clojure.core/contains? input :slots) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :slots)) #:http.request.field{:name "Slots", :shape "String"})) (clojure.core/contains? input :replica-count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :replica-count)) #:http.request.field{:name "ReplicaCount", :shape "IntegerOptional"})) (clojure.core/contains? input :primary-availability-zone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :primary-availability-zone)) #:http.request.field{:name "PrimaryAvailabilityZone", :shape "String"})) (clojure.core/contains? input :replica-availability-zones) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-availability-zones-list (input :replica-availability-zones)) #:http.request.field{:name "ReplicaAvailabilityZones", :shape "AvailabilityZonesList"}))))

(clojure.core/defn- ser-cache-node-ids-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "CacheNodeId"}))) input), :shape "CacheNodeIdsList", :type "list"})

(clojure.core/defn- ser-allowed-node-group-id [input] #:http.request.field{:value input, :shape "AllowedNodeGroupId"})

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-resharding-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ReshardingConfiguration", :type "structure"} (clojure.core/contains? input :node-group-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allowed-node-group-id (input :node-group-id)) #:http.request.field{:name "NodeGroupId", :shape "AllowedNodeGroupId"})) (clojure.core/contains? input :preferred-availability-zones) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-availability-zones-list (input :preferred-availability-zones)) #:http.request.field{:name "PreferredAvailabilityZones", :shape "AvailabilityZonesList"}))))

(clojure.core/defn- ser-t-stamp [input] #:http.request.field{:value input, :shape "TStamp"})

(clojure.core/defn- ser-preferred-availability-zone-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "PreferredAvailabilityZone"}))) input), :shape "PreferredAvailabilityZoneList", :type "list"})

(clojure.core/defn- ser-node-groups-to-retain-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-allowed-node-group-id coll) #:http.request.field{:shape "AllowedNodeGroupId", :location-name "NodeGroupToRetain"}))) input), :shape "NodeGroupsToRetainList", :type "list"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String"}))))

(clojure.core/defn- ser-boolean-optional [input] #:http.request.field{:value input, :shape "BooleanOptional"})

(clojure.core/defn- ser-configure-shard [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-allowed-node-group-id (:node-group-id input)) #:http.request.field{:name "NodeGroupId", :shape "AllowedNodeGroupId"}) (clojure.core/into (ser-integer (:new-replica-count input)) #:http.request.field{:name "NewReplicaCount", :shape "Integer"})], :shape "ConfigureShard", :type "structure"} (clojure.core/contains? input :preferred-availability-zones) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-preferred-availability-zone-list (input :preferred-availability-zones)) #:http.request.field{:name "PreferredAvailabilityZones", :shape "PreferredAvailabilityZoneList"}))))

(clojure.core/defn- ser-integer-optional [input] #:http.request.field{:value input, :shape "IntegerOptional"})

(clojure.core/defn- ser-replica-configuration-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-configure-shard coll) #:http.request.field{:shape "ConfigureShard", :location-name "ConfigureShard"}))) input), :shape "ReplicaConfigurationList", :type "list"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-test-failover-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"}) (clojure.core/into (ser-allowed-node-group-id (input :node-group-id)) #:http.request.field{:name "NodeGroupId", :shape "AllowedNodeGroupId"})]}))

(clojure.core/defn- req-describe-cache-engine-versions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :engine) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine)) #:http.request.field{:name "Engine", :shape "String"})) (clojure.core/contains? input :engine-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine-version)) #:http.request.field{:name "EngineVersion", :shape "String"})) (clojure.core/contains? input :cache-parameter-group-family) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-parameter-group-family)) #:http.request.field{:name "CacheParameterGroupFamily", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :default-only) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :default-only)) #:http.request.field{:name "DefaultOnly", :shape "Boolean"}))))

(clojure.core/defn- req-delete-replication-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"})]} (clojure.core/contains? input :retain-primary-cluster) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :retain-primary-cluster)) #:http.request.field{:name "RetainPrimaryCluster", :shape "BooleanOptional"})) (clojure.core/contains? input :final-snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :final-snapshot-identifier)) #:http.request.field{:name "FinalSnapshotIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-engine-default-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-parameter-group-family)) #:http.request.field{:name "CacheParameterGroupFamily", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-cache-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"}) (clojure.core/into (ser-string (input :cache-parameter-group-family)) #:http.request.field{:name "CacheParameterGroupFamily", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]}))

(clojure.core/defn- req-modify-cache-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-subnet-group-name)) #:http.request.field{:name "CacheSubnetGroupName", :shape "String"})]} (clojure.core/contains? input :cache-subnet-group-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-subnet-group-description)) #:http.request.field{:name "CacheSubnetGroupDescription", :shape "String"})) (clojure.core/contains? input :subnet-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"}))))

(clojure.core/defn- req-decrease-replica-count-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"}) (clojure.core/into (ser-boolean (input :apply-immediately)) #:http.request.field{:name "ApplyImmediately", :shape "Boolean"})]} (clojure.core/contains? input :new-replica-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :new-replica-count)) #:http.request.field{:name "NewReplicaCount", :shape "IntegerOptional"})) (clojure.core/contains? input :replica-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-replica-configuration-list (input :replica-configuration)) #:http.request.field{:name "ReplicaConfiguration", :shape "ReplicaConfigurationList"})) (clojure.core/contains? input :replicas-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-remove-replicas-list (input :replicas-to-remove)) #:http.request.field{:name "ReplicasToRemove", :shape "RemoveReplicasList"}))))

(clojure.core/defn- req-describe-cache-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})]} (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-purchase-reserved-cache-nodes-offering-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-cache-nodes-offering-id)) #:http.request.field{:name "ReservedCacheNodesOfferingId", :shape "String"})]} (clojure.core/contains? input :reserved-cache-node-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-cache-node-id)) #:http.request.field{:name "ReservedCacheNodeId", :shape "String"})) (clojure.core/contains? input :cache-node-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :cache-node-count)) #:http.request.field{:name "CacheNodeCount", :shape "IntegerOptional"}))))

(clojure.core/defn- req-modify-cache-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"})]} (clojure.core/contains? input :cache-node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-node-type)) #:http.request.field{:name "CacheNodeType", :shape "String"})) (clojure.core/contains? input :az-mode) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-az-mode (input :az-mode)) #:http.request.field{:name "AZMode", :shape "AZMode"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-ids-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "SecurityGroupIdsList"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :auto-minor-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-minor-version-upgrade)) #:http.request.field{:name "AutoMinorVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :num-cache-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :num-cache-nodes)) #:http.request.field{:name "NumCacheNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :engine-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine-version)) #:http.request.field{:name "EngineVersion", :shape "String"})) (clojure.core/contains? input :notification-topic-status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :notification-topic-status)) #:http.request.field{:name "NotificationTopicStatus", :shape "String"})) (clojure.core/contains? input :notification-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :notification-topic-arn)) #:http.request.field{:name "NotificationTopicArn", :shape "String"})) (clojure.core/contains? input :snapshot-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-window)) #:http.request.field{:name "SnapshotWindow", :shape "String"})) (clojure.core/contains? input :cache-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})) (clojure.core/contains? input :snapshot-retention-limit) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :snapshot-retention-limit)) #:http.request.field{:name "SnapshotRetentionLimit", :shape "IntegerOptional"})) (clojure.core/contains? input :apply-immediately) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :apply-immediately)) #:http.request.field{:name "ApplyImmediately", :shape "Boolean"})) (clojure.core/contains? input :cache-node-ids-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-node-ids-list (input :cache-node-ids-to-remove)) #:http.request.field{:name "CacheNodeIdsToRemove", :shape "CacheNodeIdsList"})) (clojure.core/contains? input :cache-security-group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-security-group-name-list (input :cache-security-group-names)) #:http.request.field{:name "CacheSecurityGroupNames", :shape "CacheSecurityGroupNameList"})) (clojure.core/contains? input :new-availability-zones) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-preferred-availability-zone-list (input :new-availability-zones)) #:http.request.field{:name "NewAvailabilityZones", :shape "PreferredAvailabilityZoneList"}))))

(clojure.core/defn- req-create-cache-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-security-group-name)) #:http.request.field{:name "CacheSecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]}))

(clojure.core/defn- req-modify-replication-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"})]} (clojure.core/contains? input :cache-node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-node-type)) #:http.request.field{:name "CacheNodeType", :shape "String"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-ids-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "SecurityGroupIdsList"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :auto-minor-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-minor-version-upgrade)) #:http.request.field{:name "AutoMinorVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :primary-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :primary-cluster-id)) #:http.request.field{:name "PrimaryClusterId", :shape "String"})) (clojure.core/contains? input :engine-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine-version)) #:http.request.field{:name "EngineVersion", :shape "String"})) (clojure.core/contains? input :notification-topic-status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :notification-topic-status)) #:http.request.field{:name "NotificationTopicStatus", :shape "String"})) (clojure.core/contains? input :notification-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :notification-topic-arn)) #:http.request.field{:name "NotificationTopicArn", :shape "String"})) (clojure.core/contains? input :snapshot-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-window)) #:http.request.field{:name "SnapshotWindow", :shape "String"})) (clojure.core/contains? input :snapshotting-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshotting-cluster-id)) #:http.request.field{:name "SnapshottingClusterId", :shape "String"})) (clojure.core/contains? input :cache-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})) (clojure.core/contains? input :snapshot-retention-limit) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :snapshot-retention-limit)) #:http.request.field{:name "SnapshotRetentionLimit", :shape "IntegerOptional"})) (clojure.core/contains? input :apply-immediately) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :apply-immediately)) #:http.request.field{:name "ApplyImmediately", :shape "Boolean"})) (clojure.core/contains? input :automatic-failover-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :automatic-failover-enabled)) #:http.request.field{:name "AutomaticFailoverEnabled", :shape "BooleanOptional"})) (clojure.core/contains? input :replication-group-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :replication-group-description)) #:http.request.field{:name "ReplicationGroupDescription", :shape "String"})) (clojure.core/contains? input :node-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-group-id)) #:http.request.field{:name "NodeGroupId", :shape "String", :deprecated true})) (clojure.core/contains? input :cache-security-group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-security-group-name-list (input :cache-security-group-names)) #:http.request.field{:name "CacheSecurityGroupNames", :shape "CacheSecurityGroupNameList"}))))

(clojure.core/defn- req-increase-replica-count-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"}) (clojure.core/into (ser-boolean (input :apply-immediately)) #:http.request.field{:name "ApplyImmediately", :shape "Boolean"})]} (clojure.core/contains? input :new-replica-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :new-replica-count)) #:http.request.field{:name "NewReplicaCount", :shape "IntegerOptional"})) (clojure.core/contains? input :replica-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-replica-configuration-list (input :replica-configuration)) #:http.request.field{:name "ReplicaConfiguration", :shape "ReplicaConfigurationList"}))))

(clojure.core/defn- req-create-replication-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"}) (clojure.core/into (ser-string (input :replication-group-description)) #:http.request.field{:name "ReplicationGroupDescription", :shape "String"})]} (clojure.core/contains? input :cache-node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-node-type)) #:http.request.field{:name "CacheNodeType", :shape "String"})) (clojure.core/contains? input :cache-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-subnet-group-name)) #:http.request.field{:name "CacheSubnetGroupName", :shape "String"})) (clojure.core/contains? input :num-node-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :num-node-groups)) #:http.request.field{:name "NumNodeGroups", :shape "IntegerOptional"})) (clojure.core/contains? input :auth-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :auth-token)) #:http.request.field{:name "AuthToken", :shape "String"})) (clojure.core/contains? input :snapshot-arns) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-arns-list (input :snapshot-arns)) #:http.request.field{:name "SnapshotArns", :shape "SnapshotArnsList"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-ids-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "SecurityGroupIdsList"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :auto-minor-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-minor-version-upgrade)) #:http.request.field{:name "AutoMinorVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :replicas-per-node-group) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :replicas-per-node-group)) #:http.request.field{:name "ReplicasPerNodeGroup", :shape "IntegerOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :preferred-cache-cluster-a-zs) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-availability-zones-list (input :preferred-cache-cluster-a-zs)) #:http.request.field{:name "PreferredCacheClusterAZs", :shape "AvailabilityZonesList"})) (clojure.core/contains? input :at-rest-encryption-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :at-rest-encryption-enabled)) #:http.request.field{:name "AtRestEncryptionEnabled", :shape "BooleanOptional"})) (clojure.core/contains? input :transit-encryption-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :transit-encryption-enabled)) #:http.request.field{:name "TransitEncryptionEnabled", :shape "BooleanOptional"})) (clojure.core/contains? input :primary-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :primary-cluster-id)) #:http.request.field{:name "PrimaryClusterId", :shape "String"})) (clojure.core/contains? input :engine-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine-version)) #:http.request.field{:name "EngineVersion", :shape "String"})) (clojure.core/contains? input :notification-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :notification-topic-arn)) #:http.request.field{:name "NotificationTopicArn", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :snapshot-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-window)) #:http.request.field{:name "SnapshotWindow", :shape "String"})) (clojure.core/contains? input :node-group-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-node-group-configuration-list (input :node-group-configuration)) #:http.request.field{:name "NodeGroupConfiguration", :shape "NodeGroupConfigurationList"})) (clojure.core/contains? input :cache-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})) (clojure.core/contains? input :snapshot-retention-limit) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :snapshot-retention-limit)) #:http.request.field{:name "SnapshotRetentionLimit", :shape "IntegerOptional"})) (clojure.core/contains? input :automatic-failover-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :automatic-failover-enabled)) #:http.request.field{:name "AutomaticFailoverEnabled", :shape "BooleanOptional"})) (clojure.core/contains? input :num-cache-clusters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :num-cache-clusters)) #:http.request.field{:name "NumCacheClusters", :shape "IntegerOptional"})) (clojure.core/contains? input :engine) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine)) #:http.request.field{:name "Engine", :shape "String"})) (clojure.core/contains? input :cache-security-group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-security-group-name-list (input :cache-security-group-names)) #:http.request.field{:name "CacheSecurityGroupNames", :shape "CacheSecurityGroupNameList"})) (clojure.core/contains? input :snapshot-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-name)) #:http.request.field{:name "SnapshotName", :shape "String"}))))

(clojure.core/defn- req-describe-cache-parameter-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cache-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-events-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-identifier)) #:http.request.field{:name "SourceIdentifier", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-type (input :source-type)) #:http.request.field{:name "SourceType", :shape "SourceType"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration)) #:http.request.field{:name "Duration", :shape "IntegerOptional"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-snapshots-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :replication-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"})) (clojure.core/contains? input :cache-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"})) (clojure.core/contains? input :snapshot-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-name)) #:http.request.field{:name "SnapshotName", :shape "String"})) (clojure.core/contains? input :snapshot-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-source)) #:http.request.field{:name "SnapshotSource", :shape "String"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :show-node-group-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :show-node-group-config)) #:http.request.field{:name "ShowNodeGroupConfig", :shape "BooleanOptional"}))))

(clojure.core/defn- req-authorize-cache-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-security-group-name)) #:http.request.field{:name "CacheSecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"})]}))

(clojure.core/defn- req-modify-replication-group-shard-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"}) (clojure.core/into (ser-integer (input :node-group-count)) #:http.request.field{:name "NodeGroupCount", :shape "Integer"}) (clojure.core/into (ser-boolean (input :apply-immediately)) #:http.request.field{:name "ApplyImmediately", :shape "Boolean"})]} (clojure.core/contains? input :resharding-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resharding-configuration-list (input :resharding-configuration)) #:http.request.field{:name "ReshardingConfiguration", :shape "ReshardingConfigurationList"})) (clojure.core/contains? input :node-groups-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-node-groups-to-remove-list (input :node-groups-to-remove)) #:http.request.field{:name "NodeGroupsToRemove", :shape "NodeGroupsToRemoveList"})) (clojure.core/contains? input :node-groups-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-node-groups-to-retain-list (input :node-groups-to-retain)) #:http.request.field{:name "NodeGroupsToRetain", :shape "NodeGroupsToRetainList"}))))

(clojure.core/defn- req-describe-replication-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :replication-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-name)) #:http.request.field{:name "SnapshotName", :shape "String"})]} (clojure.core/contains? input :replication-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"})) (clojure.core/contains? input :cache-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"}))))

(clojure.core/defn- req-describe-cache-clusters-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cache-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :show-cache-node-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :show-cache-node-info)) #:http.request.field{:name "ShowCacheNodeInfo", :shape "BooleanOptional"})) (clojure.core/contains? input :show-cache-clusters-not-in-replication-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :show-cache-clusters-not-in-replication-groups)) #:http.request.field{:name "ShowCacheClustersNotInReplicationGroups", :shape "BooleanOptional"}))))

(clojure.core/defn- req-reboot-cache-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"}) (clojure.core/into (ser-cache-node-ids-list (input :cache-node-ids-to-reboot)) #:http.request.field{:name "CacheNodeIdsToReboot", :shape "CacheNodeIdsList"})]}))

(clojure.core/defn- req-create-cache-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-subnet-group-name)) #:http.request.field{:name "CacheSubnetGroupName", :shape "String"}) (clojure.core/into (ser-string (input :cache-subnet-group-description)) #:http.request.field{:name "CacheSubnetGroupDescription", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]}))

(clojure.core/defn- req-create-cache-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"})]} (clojure.core/contains? input :cache-node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-node-type)) #:http.request.field{:name "CacheNodeType", :shape "String"})) (clojure.core/contains? input :cache-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-subnet-group-name)) #:http.request.field{:name "CacheSubnetGroupName", :shape "String"})) (clojure.core/contains? input :az-mode) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-az-mode (input :az-mode)) #:http.request.field{:name "AZMode", :shape "AZMode"})) (clojure.core/contains? input :auth-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :auth-token)) #:http.request.field{:name "AuthToken", :shape "String"})) (clojure.core/contains? input :preferred-availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-availability-zone)) #:http.request.field{:name "PreferredAvailabilityZone", :shape "String"})) (clojure.core/contains? input :snapshot-arns) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-arns-list (input :snapshot-arns)) #:http.request.field{:name "SnapshotArns", :shape "SnapshotArnsList"})) (clojure.core/contains? input :security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-group-ids-list (input :security-group-ids)) #:http.request.field{:name "SecurityGroupIds", :shape "SecurityGroupIdsList"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :preferred-availability-zones) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-preferred-availability-zone-list (input :preferred-availability-zones)) #:http.request.field{:name "PreferredAvailabilityZones", :shape "PreferredAvailabilityZoneList"})) (clojure.core/contains? input :auto-minor-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-minor-version-upgrade)) #:http.request.field{:name "AutoMinorVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :num-cache-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :num-cache-nodes)) #:http.request.field{:name "NumCacheNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :engine-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine-version)) #:http.request.field{:name "EngineVersion", :shape "String"})) (clojure.core/contains? input :notification-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :notification-topic-arn)) #:http.request.field{:name "NotificationTopicArn", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :snapshot-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-window)) #:http.request.field{:name "SnapshotWindow", :shape "String"})) (clojure.core/contains? input :replication-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"})) (clojure.core/contains? input :cache-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})) (clojure.core/contains? input :snapshot-retention-limit) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :snapshot-retention-limit)) #:http.request.field{:name "SnapshotRetentionLimit", :shape "IntegerOptional"})) (clojure.core/contains? input :engine) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :engine)) #:http.request.field{:name "Engine", :shape "String"})) (clojure.core/contains? input :cache-security-group-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-security-group-name-list (input :cache-security-group-names)) #:http.request.field{:name "CacheSecurityGroupNames", :shape "CacheSecurityGroupNameList"})) (clojure.core/contains? input :snapshot-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-name)) #:http.request.field{:name "SnapshotName", :shape "String"}))))

(clojure.core/defn- req-add-tags-to-resource-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})]}))

(clojure.core/defn- req-delete-cache-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})]}))

(clojure.core/defn- req-remove-tags-from-resource-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "KeyList"})]}))

(clojure.core/defn- req-delete-cache-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"})]} (clojure.core/contains? input :final-snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :final-snapshot-identifier)) #:http.request.field{:name "FinalSnapshotIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-cache-security-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cache-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-security-group-name)) #:http.request.field{:name "CacheSecurityGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-delete-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-name)) #:http.request.field{:name "SnapshotName", :shape "String"})]}))

(clojure.core/defn- req-list-allowed-node-type-modifications-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cache-cluster-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-cluster-id)) #:http.request.field{:name "CacheClusterId", :shape "String"})) (clojure.core/contains? input :replication-group-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :replication-group-id)) #:http.request.field{:name "ReplicationGroupId", :shape "String"}))))

(clojure.core/defn- req-delete-cache-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-security-group-name)) #:http.request.field{:name "CacheSecurityGroupName", :shape "String"})]}))

(clojure.core/defn- req-delete-cache-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-subnet-group-name)) #:http.request.field{:name "CacheSubnetGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-cache-subnet-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cache-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-subnet-group-name)) #:http.request.field{:name "CacheSubnetGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-reserved-cache-nodes-offerings-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-cache-nodes-offering-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-cache-nodes-offering-id)) #:http.request.field{:name "ReservedCacheNodesOfferingId", :shape "String"})) (clojure.core/contains? input :cache-node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-node-type)) #:http.request.field{:name "CacheNodeType", :shape "String"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :duration)) #:http.request.field{:name "Duration", :shape "String"})) (clojure.core/contains? input :product-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :product-description)) #:http.request.field{:name "ProductDescription", :shape "String"})) (clojure.core/contains? input :offering-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :offering-type)) #:http.request.field{:name "OfferingType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-list-tags-for-resource-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"})]}))

(clojure.core/defn- req-revoke-cache-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-security-group-name)) #:http.request.field{:name "CacheSecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"})]}))

(clojure.core/defn- req-reset-cache-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"})]} (clojure.core/contains? input :reset-all-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reset-all-parameters)) #:http.request.field{:name "ResetAllParameters", :shape "Boolean"})) (clojure.core/contains? input :parameter-name-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-name-value-list (input :parameter-name-values)) #:http.request.field{:name "ParameterNameValues", :shape "ParameterNameValueList"}))))

(clojure.core/defn- req-modify-cache-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cache-parameter-group-name)) #:http.request.field{:name "CacheParameterGroupName", :shape "String"}) (clojure.core/into (ser-parameter-name-value-list (input :parameter-name-values)) #:http.request.field{:name "ParameterNameValues", :shape "ParameterNameValueList"})]}))

(clojure.core/defn- req-describe-reserved-cache-nodes-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-cache-node-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-cache-node-id)) #:http.request.field{:name "ReservedCacheNodeId", :shape "String"})) (clojure.core/contains? input :reserved-cache-nodes-offering-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-cache-nodes-offering-id)) #:http.request.field{:name "ReservedCacheNodesOfferingId", :shape "String"})) (clojure.core/contains? input :cache-node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-node-type)) #:http.request.field{:name "CacheNodeType", :shape "String"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :duration)) #:http.request.field{:name "Duration", :shape "String"})) (clojure.core/contains? input :product-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :product-description)) #:http.request.field{:name "ProductDescription", :shape "String"})) (clojure.core/contains? input :offering-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :offering-type)) #:http.request.field{:name "OfferingType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-copy-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :source-snapshot-name)) #:http.request.field{:name "SourceSnapshotName", :shape "String"}) (clojure.core/into (ser-string (input :target-snapshot-name)) #:http.request.field{:name "TargetSnapshotName", :shape "String"})]} (clojure.core/contains? input :target-bucket) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-bucket)) #:http.request.field{:name "TargetBucket", :shape "String"}))))

(clojure.core/declare deser-node-group-member)

(clojure.core/declare deser-cache-security-group)

(clojure.core/declare deser-double)

(clojure.core/declare deser-parameters-list)

(clojure.core/declare deser-ec-2-security-group-list)

(clojure.core/declare deser-change-type)

(clojure.core/declare deser-cache-parameter-group)

(clojure.core/declare deser-security-group-membership-list)

(clojure.core/declare deser-replication-group-list)

(clojure.core/declare deser-reserved-cache-nodes-offering)

(clojure.core/declare deser-cache-engine-version-list)

(clojure.core/declare deser-slot-migration)

(clojure.core/declare deser-cache-node)

(clojure.core/declare deser-pending-automatic-failover-status)

(clojure.core/declare deser-replication-group)

(clojure.core/declare deser-snapshot-list)

(clojure.core/declare deser-subnet)

(clojure.core/declare deser-reserved-cache-node)

(clojure.core/declare deser-cache-subnet-group)

(clojure.core/declare deser-node-group-member-list)

(clojure.core/declare deser-reserved-cache-nodes-offering-list)

(clojure.core/declare deser-availability-zones-list)

(clojure.core/declare deser-node-snapshot-list)

(clojure.core/declare deser-event-list)

(clojure.core/declare deser-source-type)

(clojure.core/declare deser-cache-security-groups)

(clojure.core/declare deser-event)

(clojure.core/declare deser-availability-zone)

(clojure.core/declare deser-cache-cluster-list)

(clojure.core/declare deser-cache-engine-version)

(clojure.core/declare deser-cache-node-list)

(clojure.core/declare deser-node-group)

(clojure.core/declare deser-recurring-charge)

(clojure.core/declare deser-cache-node-type-specific-value)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-cache-node-type-specific-parameters-list)

(clojure.core/declare deser-node-group-configuration)

(clojure.core/declare deser-ec-2-security-group)

(clojure.core/declare deser-cluster-id-list)

(clojure.core/declare deser-cache-node-ids-list)

(clojure.core/declare deser-automatic-failover-status)

(clojure.core/declare deser-replication-group-pending-modified-values)

(clojure.core/declare deser-allowed-node-group-id)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-resharding-status)

(clojure.core/declare deser-string)

(clojure.core/declare deser-parameter)

(clojure.core/declare deser-cache-node-type-specific-parameter)

(clojure.core/declare deser-snapshot)

(clojure.core/declare deser-t-stamp)

(clojure.core/declare deser-recurring-charge-list)

(clojure.core/declare deser-cache-cluster)

(clojure.core/declare deser-cache-security-group-membership)

(clojure.core/declare deser-endpoint)

(clojure.core/declare deser-cache-parameter-group-list)

(clojure.core/declare deser-security-group-membership)

(clojure.core/declare deser-node-snapshot)

(clojure.core/declare deser-reserved-cache-node-list)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-boolean-optional)

(clojure.core/declare deser-cache-node-type-specific-value-list)

(clojure.core/declare deser-cache-security-group-membership-list)

(clojure.core/declare deser-node-group-list)

(clojure.core/declare deser-notification-configuration)

(clojure.core/declare deser-cache-parameter-group-status)

(clojure.core/declare deser-aws-query-error-message)

(clojure.core/declare deser-engine-defaults)

(clojure.core/declare deser-integer-optional)

(clojure.core/declare deser-pending-modified-values)

(clojure.core/declare deser-node-type-list)

(clojure.core/declare deser-subnet-list)

(clojure.core/declare deser-cache-subnet-groups)

(clojure.core/declare deser-boolean)

(clojure.core/defn- deser-node-group-member [input] (clojure.core/let [letvar832649 {"CacheClusterId" (portkey.aws/search-for-tag input "CacheClusterId" :flattened? nil :xmlAttribute? nil), "CacheNodeId" (portkey.aws/search-for-tag input "CacheNodeId" :flattened? nil :xmlAttribute? nil), "ReadEndpoint" (portkey.aws/search-for-tag input "ReadEndpoint" :flattened? nil :xmlAttribute? nil), "PreferredAvailabilityZone" (portkey.aws/search-for-tag input "PreferredAvailabilityZone" :flattened? nil :xmlAttribute? nil), "CurrentRole" (portkey.aws/search-for-tag input "CurrentRole" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar832649 "CacheClusterId") (clojure.core/assoc :cache-cluster-id (deser-string (clojure.core/get-in letvar832649 ["CacheClusterId" :content]))) (letvar832649 "CacheNodeId") (clojure.core/assoc :cache-node-id (deser-string (clojure.core/get-in letvar832649 ["CacheNodeId" :content]))) (letvar832649 "ReadEndpoint") (clojure.core/assoc :read-endpoint (deser-endpoint (clojure.core/get-in letvar832649 ["ReadEndpoint" :content]))) (letvar832649 "PreferredAvailabilityZone") (clojure.core/assoc :preferred-availability-zone (deser-string (clojure.core/get-in letvar832649 ["PreferredAvailabilityZone" :content]))) (letvar832649 "CurrentRole") (clojure.core/assoc :current-role (deser-string (clojure.core/get-in letvar832649 ["CurrentRole" :content]))))))

(clojure.core/defn- deser-cache-security-group [input] (clojure.core/let [letvar832757 {"OwnerId" (portkey.aws/search-for-tag input "OwnerId" :flattened? nil :xmlAttribute? nil), "CacheSecurityGroupName" (portkey.aws/search-for-tag input "CacheSecurityGroupName" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroups" (portkey.aws/search-for-tag input "EC2SecurityGroups" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar832757 "OwnerId") (clojure.core/assoc :owner-id (deser-string (clojure.core/get-in letvar832757 ["OwnerId" :content]))) (letvar832757 "CacheSecurityGroupName") (clojure.core/assoc :cache-security-group-name (deser-string (clojure.core/get-in letvar832757 ["CacheSecurityGroupName" :content]))) (letvar832757 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar832757 ["Description" :content]))) (letvar832757 "EC2SecurityGroups") (clojure.core/assoc :ec-2-security-groups (deser-ec-2-security-group-list (clojure.core/get-in letvar832757 ["EC2SecurityGroups" :content]))))))

(clojure.core/defn- deser-double [input] (java.lang.Double. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-parameters-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter coll))) input))

(clojure.core/defn- deser-ec-2-security-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ec-2-security-group coll))) input))

(clojure.core/defn- deser-change-type [input] (clojure.core/get {"immediate" :immediate, "requires-reboot" :requiresreboot} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cache-parameter-group [input] (clojure.core/let [letvar832906 {"CacheParameterGroupName" (portkey.aws/search-for-tag input "CacheParameterGroupName" :flattened? nil :xmlAttribute? nil), "CacheParameterGroupFamily" (portkey.aws/search-for-tag input "CacheParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar832906 "CacheParameterGroupName") (clojure.core/assoc :cache-parameter-group-name (deser-string (clojure.core/get-in letvar832906 ["CacheParameterGroupName" :content]))) (letvar832906 "CacheParameterGroupFamily") (clojure.core/assoc :cache-parameter-group-family (deser-string (clojure.core/get-in letvar832906 ["CacheParameterGroupFamily" :content]))) (letvar832906 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar832906 ["Description" :content]))))))

(clojure.core/defn- deser-security-group-membership-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-group-membership coll))) input))

(clojure.core/defn- deser-replication-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-replication-group coll))) input))

(clojure.core/defn- deser-reserved-cache-nodes-offering [input] (clojure.core/let [letvar833048 {"ReservedCacheNodesOfferingId" (portkey.aws/search-for-tag input "ReservedCacheNodesOfferingId" :flattened? nil :xmlAttribute? nil), "CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil), "Duration" (portkey.aws/search-for-tag input "Duration" :flattened? nil :xmlAttribute? nil), "FixedPrice" (portkey.aws/search-for-tag input "FixedPrice" :flattened? nil :xmlAttribute? nil), "UsagePrice" (portkey.aws/search-for-tag input "UsagePrice" :flattened? nil :xmlAttribute? nil), "ProductDescription" (portkey.aws/search-for-tag input "ProductDescription" :flattened? nil :xmlAttribute? nil), "OfferingType" (portkey.aws/search-for-tag input "OfferingType" :flattened? nil :xmlAttribute? nil), "RecurringCharges" (portkey.aws/search-for-tag input "RecurringCharges" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833048 "ReservedCacheNodesOfferingId") (clojure.core/assoc :reserved-cache-nodes-offering-id (deser-string (clojure.core/get-in letvar833048 ["ReservedCacheNodesOfferingId" :content]))) (letvar833048 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar833048 ["CacheNodeType" :content]))) (letvar833048 "Duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar833048 ["Duration" :content]))) (letvar833048 "FixedPrice") (clojure.core/assoc :fixed-price (deser-double (clojure.core/get-in letvar833048 ["FixedPrice" :content]))) (letvar833048 "UsagePrice") (clojure.core/assoc :usage-price (deser-double (clojure.core/get-in letvar833048 ["UsagePrice" :content]))) (letvar833048 "ProductDescription") (clojure.core/assoc :product-description (deser-string (clojure.core/get-in letvar833048 ["ProductDescription" :content]))) (letvar833048 "OfferingType") (clojure.core/assoc :offering-type (deser-string (clojure.core/get-in letvar833048 ["OfferingType" :content]))) (letvar833048 "RecurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charge-list (clojure.core/get-in letvar833048 ["RecurringCharges" :content]))))))

(clojure.core/defn- deser-cache-engine-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-engine-version coll))) input))

(clojure.core/defn- deser-slot-migration [input] (clojure.core/let [letvar833173 {"ProgressPercentage" (portkey.aws/search-for-tag input "ProgressPercentage" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833173 "ProgressPercentage") (clojure.core/assoc :progress-percentage (deser-double (clojure.core/get-in letvar833173 ["ProgressPercentage" :content]))))))

(clojure.core/defn- deser-cache-node [input] (clojure.core/let [letvar833281 {"CacheNodeId" (portkey.aws/search-for-tag input "CacheNodeId" :flattened? nil :xmlAttribute? nil), "CacheNodeStatus" (portkey.aws/search-for-tag input "CacheNodeStatus" :flattened? nil :xmlAttribute? nil), "CacheNodeCreateTime" (portkey.aws/search-for-tag input "CacheNodeCreateTime" :flattened? nil :xmlAttribute? nil), "Endpoint" (portkey.aws/search-for-tag input "Endpoint" :flattened? nil :xmlAttribute? nil), "ParameterGroupStatus" (portkey.aws/search-for-tag input "ParameterGroupStatus" :flattened? nil :xmlAttribute? nil), "SourceCacheNodeId" (portkey.aws/search-for-tag input "SourceCacheNodeId" :flattened? nil :xmlAttribute? nil), "CustomerAvailabilityZone" (portkey.aws/search-for-tag input "CustomerAvailabilityZone" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833281 "CacheNodeId") (clojure.core/assoc :cache-node-id (deser-string (clojure.core/get-in letvar833281 ["CacheNodeId" :content]))) (letvar833281 "CacheNodeStatus") (clojure.core/assoc :cache-node-status (deser-string (clojure.core/get-in letvar833281 ["CacheNodeStatus" :content]))) (letvar833281 "CacheNodeCreateTime") (clojure.core/assoc :cache-node-create-time (deser-t-stamp (clojure.core/get-in letvar833281 ["CacheNodeCreateTime" :content]))) (letvar833281 "Endpoint") (clojure.core/assoc :endpoint (deser-endpoint (clojure.core/get-in letvar833281 ["Endpoint" :content]))) (letvar833281 "ParameterGroupStatus") (clojure.core/assoc :parameter-group-status (deser-string (clojure.core/get-in letvar833281 ["ParameterGroupStatus" :content]))) (letvar833281 "SourceCacheNodeId") (clojure.core/assoc :source-cache-node-id (deser-string (clojure.core/get-in letvar833281 ["SourceCacheNodeId" :content]))) (letvar833281 "CustomerAvailabilityZone") (clojure.core/assoc :customer-availability-zone (deser-string (clojure.core/get-in letvar833281 ["CustomerAvailabilityZone" :content]))))))

(clojure.core/defn- deser-pending-automatic-failover-status [input] (clojure.core/get {"enabled" :enabled, "disabled" :disabled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-replication-group [input] (clojure.core/let [letvar833394 {"CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil), "MemberClusters" (portkey.aws/search-for-tag input "MemberClusters" :flattened? nil :xmlAttribute? nil), "AutomaticFailover" (portkey.aws/search-for-tag input "AutomaticFailover" :flattened? nil :xmlAttribute? nil), "NodeGroups" (portkey.aws/search-for-tag input "NodeGroups" :flattened? nil :xmlAttribute? nil), "ConfigurationEndpoint" (portkey.aws/search-for-tag input "ConfigurationEndpoint" :flattened? nil :xmlAttribute? nil), "AuthTokenEnabled" (portkey.aws/search-for-tag input "AuthTokenEnabled" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "AtRestEncryptionEnabled" (portkey.aws/search-for-tag input "AtRestEncryptionEnabled" :flattened? nil :xmlAttribute? nil), "ClusterEnabled" (portkey.aws/search-for-tag input "ClusterEnabled" :flattened? nil :xmlAttribute? nil), "TransitEncryptionEnabled" (portkey.aws/search-for-tag input "TransitEncryptionEnabled" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "SnapshotWindow" (portkey.aws/search-for-tag input "SnapshotWindow" :flattened? nil :xmlAttribute? nil), "SnapshottingClusterId" (portkey.aws/search-for-tag input "SnapshottingClusterId" :flattened? nil :xmlAttribute? nil), "ReplicationGroupId" (portkey.aws/search-for-tag input "ReplicationGroupId" :flattened? nil :xmlAttribute? nil), "SnapshotRetentionLimit" (portkey.aws/search-for-tag input "SnapshotRetentionLimit" :flattened? nil :xmlAttribute? nil), "PendingModifiedValues" (portkey.aws/search-for-tag input "PendingModifiedValues" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833394 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar833394 ["CacheNodeType" :content]))) (letvar833394 "MemberClusters") (clojure.core/assoc :member-clusters (deser-cluster-id-list (clojure.core/get-in letvar833394 ["MemberClusters" :content]))) (letvar833394 "AutomaticFailover") (clojure.core/assoc :automatic-failover (deser-automatic-failover-status (clojure.core/get-in letvar833394 ["AutomaticFailover" :content]))) (letvar833394 "NodeGroups") (clojure.core/assoc :node-groups (deser-node-group-list (clojure.core/get-in letvar833394 ["NodeGroups" :content]))) (letvar833394 "ConfigurationEndpoint") (clojure.core/assoc :configuration-endpoint (deser-endpoint (clojure.core/get-in letvar833394 ["ConfigurationEndpoint" :content]))) (letvar833394 "AuthTokenEnabled") (clojure.core/assoc :auth-token-enabled (deser-boolean-optional (clojure.core/get-in letvar833394 ["AuthTokenEnabled" :content]))) (letvar833394 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar833394 ["Status" :content]))) (letvar833394 "AtRestEncryptionEnabled") (clojure.core/assoc :at-rest-encryption-enabled (deser-boolean-optional (clojure.core/get-in letvar833394 ["AtRestEncryptionEnabled" :content]))) (letvar833394 "ClusterEnabled") (clojure.core/assoc :cluster-enabled (deser-boolean-optional (clojure.core/get-in letvar833394 ["ClusterEnabled" :content]))) (letvar833394 "TransitEncryptionEnabled") (clojure.core/assoc :transit-encryption-enabled (deser-boolean-optional (clojure.core/get-in letvar833394 ["TransitEncryptionEnabled" :content]))) (letvar833394 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar833394 ["Description" :content]))) (letvar833394 "SnapshotWindow") (clojure.core/assoc :snapshot-window (deser-string (clojure.core/get-in letvar833394 ["SnapshotWindow" :content]))) (letvar833394 "SnapshottingClusterId") (clojure.core/assoc :snapshotting-cluster-id (deser-string (clojure.core/get-in letvar833394 ["SnapshottingClusterId" :content]))) (letvar833394 "ReplicationGroupId") (clojure.core/assoc :replication-group-id (deser-string (clojure.core/get-in letvar833394 ["ReplicationGroupId" :content]))) (letvar833394 "SnapshotRetentionLimit") (clojure.core/assoc :snapshot-retention-limit (deser-integer-optional (clojure.core/get-in letvar833394 ["SnapshotRetentionLimit" :content]))) (letvar833394 "PendingModifiedValues") (clojure.core/assoc :pending-modified-values (deser-replication-group-pending-modified-values (clojure.core/get-in letvar833394 ["PendingModifiedValues" :content]))))))

(clojure.core/defn- deser-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot coll))) input))

(clojure.core/defn- deser-subnet [input] (clojure.core/let [letvar833519 {"SubnetIdentifier" (portkey.aws/search-for-tag input "SubnetIdentifier" :flattened? nil :xmlAttribute? nil), "SubnetAvailabilityZone" (portkey.aws/search-for-tag input "SubnetAvailabilityZone" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833519 "SubnetIdentifier") (clojure.core/assoc :subnet-identifier (deser-string (clojure.core/get-in letvar833519 ["SubnetIdentifier" :content]))) (letvar833519 "SubnetAvailabilityZone") (clojure.core/assoc :subnet-availability-zone (deser-availability-zone (clojure.core/get-in letvar833519 ["SubnetAvailabilityZone" :content]))))))

(clojure.core/defn- deser-reserved-cache-node [input] (clojure.core/let [letvar833627 {"CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil), "StartTime" (portkey.aws/search-for-tag input "StartTime" :flattened? nil :xmlAttribute? nil), "CacheNodeCount" (portkey.aws/search-for-tag input "CacheNodeCount" :flattened? nil :xmlAttribute? nil), "FixedPrice" (portkey.aws/search-for-tag input "FixedPrice" :flattened? nil :xmlAttribute? nil), "ReservationARN" (portkey.aws/search-for-tag input "ReservationARN" :flattened? nil :xmlAttribute? nil), "ReservedCacheNodeId" (portkey.aws/search-for-tag input "ReservedCacheNodeId" :flattened? nil :xmlAttribute? nil), "Duration" (portkey.aws/search-for-tag input "Duration" :flattened? nil :xmlAttribute? nil), "UsagePrice" (portkey.aws/search-for-tag input "UsagePrice" :flattened? nil :xmlAttribute? nil), "ProductDescription" (portkey.aws/search-for-tag input "ProductDescription" :flattened? nil :xmlAttribute? nil), "State" (portkey.aws/search-for-tag input "State" :flattened? nil :xmlAttribute? nil), "ReservedCacheNodesOfferingId" (portkey.aws/search-for-tag input "ReservedCacheNodesOfferingId" :flattened? nil :xmlAttribute? nil), "RecurringCharges" (portkey.aws/search-for-tag input "RecurringCharges" :flattened? nil :xmlAttribute? nil), "OfferingType" (portkey.aws/search-for-tag input "OfferingType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833627 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar833627 ["CacheNodeType" :content]))) (letvar833627 "StartTime") (clojure.core/assoc :start-time (deser-t-stamp (clojure.core/get-in letvar833627 ["StartTime" :content]))) (letvar833627 "CacheNodeCount") (clojure.core/assoc :cache-node-count (deser-integer (clojure.core/get-in letvar833627 ["CacheNodeCount" :content]))) (letvar833627 "FixedPrice") (clojure.core/assoc :fixed-price (deser-double (clojure.core/get-in letvar833627 ["FixedPrice" :content]))) (letvar833627 "ReservationARN") (clojure.core/assoc :reservation-arn (deser-string (clojure.core/get-in letvar833627 ["ReservationARN" :content]))) (letvar833627 "ReservedCacheNodeId") (clojure.core/assoc :reserved-cache-node-id (deser-string (clojure.core/get-in letvar833627 ["ReservedCacheNodeId" :content]))) (letvar833627 "Duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar833627 ["Duration" :content]))) (letvar833627 "UsagePrice") (clojure.core/assoc :usage-price (deser-double (clojure.core/get-in letvar833627 ["UsagePrice" :content]))) (letvar833627 "ProductDescription") (clojure.core/assoc :product-description (deser-string (clojure.core/get-in letvar833627 ["ProductDescription" :content]))) (letvar833627 "State") (clojure.core/assoc :state (deser-string (clojure.core/get-in letvar833627 ["State" :content]))) (letvar833627 "ReservedCacheNodesOfferingId") (clojure.core/assoc :reserved-cache-nodes-offering-id (deser-string (clojure.core/get-in letvar833627 ["ReservedCacheNodesOfferingId" :content]))) (letvar833627 "RecurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charge-list (clojure.core/get-in letvar833627 ["RecurringCharges" :content]))) (letvar833627 "OfferingType") (clojure.core/assoc :offering-type (deser-string (clojure.core/get-in letvar833627 ["OfferingType" :content]))))))

(clojure.core/defn- deser-cache-subnet-group [input] (clojure.core/let [letvar833735 {"CacheSubnetGroupName" (portkey.aws/search-for-tag input "CacheSubnetGroupName" :flattened? nil :xmlAttribute? nil), "CacheSubnetGroupDescription" (portkey.aws/search-for-tag input "CacheSubnetGroupDescription" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "Subnets" (portkey.aws/search-for-tag input "Subnets" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833735 "CacheSubnetGroupName") (clojure.core/assoc :cache-subnet-group-name (deser-string (clojure.core/get-in letvar833735 ["CacheSubnetGroupName" :content]))) (letvar833735 "CacheSubnetGroupDescription") (clojure.core/assoc :cache-subnet-group-description (deser-string (clojure.core/get-in letvar833735 ["CacheSubnetGroupDescription" :content]))) (letvar833735 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar833735 ["VpcId" :content]))) (letvar833735 "Subnets") (clojure.core/assoc :subnets (deser-subnet-list (clojure.core/get-in letvar833735 ["Subnets" :content]))))))

(clojure.core/defn- deser-node-group-member-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-node-group-member coll))) input))

(clojure.core/defn- deser-reserved-cache-nodes-offering-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-cache-nodes-offering coll))) input))

(clojure.core/defn- deser-availability-zones-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-node-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-node-snapshot coll))) input))

(clojure.core/defn- deser-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event coll))) input))

(clojure.core/defn- deser-source-type [input] (clojure.core/get {"cache-cluster" :cachecluster, "cache-parameter-group" :cacheparametergroup, "cache-security-group" :cachesecuritygroup, "cache-subnet-group" :cachesubnetgroup, "replication-group" :replicationgroup} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cache-security-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-security-group coll))) input))

(clojure.core/defn- deser-event [input] (clojure.core/let [letvar833950 {"SourceIdentifier" (portkey.aws/search-for-tag input "SourceIdentifier" :flattened? nil :xmlAttribute? nil), "SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Message" (portkey.aws/search-for-tag input "Message" :flattened? nil :xmlAttribute? nil), "Date" (portkey.aws/search-for-tag input "Date" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar833950 "SourceIdentifier") (clojure.core/assoc :source-identifier (deser-string (clojure.core/get-in letvar833950 ["SourceIdentifier" :content]))) (letvar833950 "SourceType") (clojure.core/assoc :source-type (deser-source-type (clojure.core/get-in letvar833950 ["SourceType" :content]))) (letvar833950 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar833950 ["Message" :content]))) (letvar833950 "Date") (clojure.core/assoc :date (deser-t-stamp (clojure.core/get-in letvar833950 ["Date" :content]))))))

(clojure.core/defn- deser-availability-zone [input] (clojure.core/let [letvar834058 {"Name" (portkey.aws/search-for-tag input "Name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834058 "Name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar834058 ["Name" :content]))))))

(clojure.core/defn- deser-cache-cluster-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-cluster coll))) input))

(clojure.core/defn- deser-cache-engine-version [input] (clojure.core/let [letvar834183 {"Engine" (portkey.aws/search-for-tag input "Engine" :flattened? nil :xmlAttribute? nil), "EngineVersion" (portkey.aws/search-for-tag input "EngineVersion" :flattened? nil :xmlAttribute? nil), "CacheParameterGroupFamily" (portkey.aws/search-for-tag input "CacheParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "CacheEngineDescription" (portkey.aws/search-for-tag input "CacheEngineDescription" :flattened? nil :xmlAttribute? nil), "CacheEngineVersionDescription" (portkey.aws/search-for-tag input "CacheEngineVersionDescription" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834183 "Engine") (clojure.core/assoc :engine (deser-string (clojure.core/get-in letvar834183 ["Engine" :content]))) (letvar834183 "EngineVersion") (clojure.core/assoc :engine-version (deser-string (clojure.core/get-in letvar834183 ["EngineVersion" :content]))) (letvar834183 "CacheParameterGroupFamily") (clojure.core/assoc :cache-parameter-group-family (deser-string (clojure.core/get-in letvar834183 ["CacheParameterGroupFamily" :content]))) (letvar834183 "CacheEngineDescription") (clojure.core/assoc :cache-engine-description (deser-string (clojure.core/get-in letvar834183 ["CacheEngineDescription" :content]))) (letvar834183 "CacheEngineVersionDescription") (clojure.core/assoc :cache-engine-version-description (deser-string (clojure.core/get-in letvar834183 ["CacheEngineVersionDescription" :content]))))))

(clojure.core/defn- deser-cache-node-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-node coll))) input))

(clojure.core/defn- deser-node-group [input] (clojure.core/let [letvar834308 {"NodeGroupId" (portkey.aws/search-for-tag input "NodeGroupId" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "PrimaryEndpoint" (portkey.aws/search-for-tag input "PrimaryEndpoint" :flattened? nil :xmlAttribute? nil), "Slots" (portkey.aws/search-for-tag input "Slots" :flattened? nil :xmlAttribute? nil), "NodeGroupMembers" (portkey.aws/search-for-tag input "NodeGroupMembers" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834308 "NodeGroupId") (clojure.core/assoc :node-group-id (deser-string (clojure.core/get-in letvar834308 ["NodeGroupId" :content]))) (letvar834308 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar834308 ["Status" :content]))) (letvar834308 "PrimaryEndpoint") (clojure.core/assoc :primary-endpoint (deser-endpoint (clojure.core/get-in letvar834308 ["PrimaryEndpoint" :content]))) (letvar834308 "Slots") (clojure.core/assoc :slots (deser-string (clojure.core/get-in letvar834308 ["Slots" :content]))) (letvar834308 "NodeGroupMembers") (clojure.core/assoc :node-group-members (deser-node-group-member-list (clojure.core/get-in letvar834308 ["NodeGroupMembers" :content]))))))

(clojure.core/defn- deser-recurring-charge [input] (clojure.core/let [letvar834416 {"RecurringChargeAmount" (portkey.aws/search-for-tag input "RecurringChargeAmount" :flattened? nil :xmlAttribute? nil), "RecurringChargeFrequency" (portkey.aws/search-for-tag input "RecurringChargeFrequency" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834416 "RecurringChargeAmount") (clojure.core/assoc :recurring-charge-amount (deser-double (clojure.core/get-in letvar834416 ["RecurringChargeAmount" :content]))) (letvar834416 "RecurringChargeFrequency") (clojure.core/assoc :recurring-charge-frequency (deser-string (clojure.core/get-in letvar834416 ["RecurringChargeFrequency" :content]))))))

(clojure.core/defn- deser-cache-node-type-specific-value [input] (clojure.core/let [letvar834524 {"CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil), "Value" (portkey.aws/search-for-tag input "Value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834524 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar834524 ["CacheNodeType" :content]))) (letvar834524 "Value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar834524 ["Value" :content]))))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-cache-node-type-specific-parameters-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-node-type-specific-parameter coll))) input))

(clojure.core/defn- deser-node-group-configuration [input] (clojure.core/let [letvar834666 {"NodeGroupId" (portkey.aws/search-for-tag input "NodeGroupId" :flattened? nil :xmlAttribute? nil), "Slots" (portkey.aws/search-for-tag input "Slots" :flattened? nil :xmlAttribute? nil), "ReplicaCount" (portkey.aws/search-for-tag input "ReplicaCount" :flattened? nil :xmlAttribute? nil), "PrimaryAvailabilityZone" (portkey.aws/search-for-tag input "PrimaryAvailabilityZone" :flattened? nil :xmlAttribute? nil), "ReplicaAvailabilityZones" (portkey.aws/search-for-tag input "ReplicaAvailabilityZones" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834666 "NodeGroupId") (clojure.core/assoc :node-group-id (deser-allowed-node-group-id (clojure.core/get-in letvar834666 ["NodeGroupId" :content]))) (letvar834666 "Slots") (clojure.core/assoc :slots (deser-string (clojure.core/get-in letvar834666 ["Slots" :content]))) (letvar834666 "ReplicaCount") (clojure.core/assoc :replica-count (deser-integer-optional (clojure.core/get-in letvar834666 ["ReplicaCount" :content]))) (letvar834666 "PrimaryAvailabilityZone") (clojure.core/assoc :primary-availability-zone (deser-string (clojure.core/get-in letvar834666 ["PrimaryAvailabilityZone" :content]))) (letvar834666 "ReplicaAvailabilityZones") (clojure.core/assoc :replica-availability-zones (deser-availability-zones-list (clojure.core/get-in letvar834666 ["ReplicaAvailabilityZones" :content]))))))

(clojure.core/defn- deser-ec-2-security-group [input] (clojure.core/let [letvar834774 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroupName" (portkey.aws/search-for-tag input "EC2SecurityGroupName" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroupOwnerId" (portkey.aws/search-for-tag input "EC2SecurityGroupOwnerId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834774 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar834774 ["Status" :content]))) (letvar834774 "EC2SecurityGroupName") (clojure.core/assoc :ec-2-security-group-name (deser-string (clojure.core/get-in letvar834774 ["EC2SecurityGroupName" :content]))) (letvar834774 "EC2SecurityGroupOwnerId") (clojure.core/assoc :ec-2-security-group-owner-id (deser-string (clojure.core/get-in letvar834774 ["EC2SecurityGroupOwnerId" :content]))))))

(clojure.core/defn- deser-cluster-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cache-node-ids-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-automatic-failover-status [input] (clojure.core/get {"enabled" :enabled, "disabled" :disabled, "enabling" :enabling, "disabling" :disabling} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-replication-group-pending-modified-values [input] (clojure.core/let [letvar834921 {"PrimaryClusterId" (portkey.aws/search-for-tag input "PrimaryClusterId" :flattened? nil :xmlAttribute? nil), "AutomaticFailoverStatus" (portkey.aws/search-for-tag input "AutomaticFailoverStatus" :flattened? nil :xmlAttribute? nil), "Resharding" (portkey.aws/search-for-tag input "Resharding" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar834921 "PrimaryClusterId") (clojure.core/assoc :primary-cluster-id (deser-string (clojure.core/get-in letvar834921 ["PrimaryClusterId" :content]))) (letvar834921 "AutomaticFailoverStatus") (clojure.core/assoc :automatic-failover-status (deser-pending-automatic-failover-status (clojure.core/get-in letvar834921 ["AutomaticFailoverStatus" :content]))) (letvar834921 "Resharding") (clojure.core/assoc :resharding (deser-resharding-status (clojure.core/get-in letvar834921 ["Resharding" :content]))))))

(clojure.core/defn- deser-allowed-node-group-id [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-integer [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-resharding-status [input] (clojure.core/let [letvar835036 {"SlotMigration" (portkey.aws/search-for-tag input "SlotMigration" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835036 "SlotMigration") (clojure.core/assoc :slot-migration (deser-slot-migration (clojure.core/get-in letvar835036 ["SlotMigration" :content]))))))

(clojure.core/defn- deser-string [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-parameter [input] (clojure.core/let [letvar835149 {"ChangeType" (portkey.aws/search-for-tag input "ChangeType" :flattened? nil :xmlAttribute? nil), "DataType" (portkey.aws/search-for-tag input "DataType" :flattened? nil :xmlAttribute? nil), "ParameterName" (portkey.aws/search-for-tag input "ParameterName" :flattened? nil :xmlAttribute? nil), "Source" (portkey.aws/search-for-tag input "Source" :flattened? nil :xmlAttribute? nil), "MinimumEngineVersion" (portkey.aws/search-for-tag input "MinimumEngineVersion" :flattened? nil :xmlAttribute? nil), "AllowedValues" (portkey.aws/search-for-tag input "AllowedValues" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "IsModifiable" (portkey.aws/search-for-tag input "IsModifiable" :flattened? nil :xmlAttribute? nil), "ParameterValue" (portkey.aws/search-for-tag input "ParameterValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835149 "ChangeType") (clojure.core/assoc :change-type (deser-change-type (clojure.core/get-in letvar835149 ["ChangeType" :content]))) (letvar835149 "DataType") (clojure.core/assoc :data-type (deser-string (clojure.core/get-in letvar835149 ["DataType" :content]))) (letvar835149 "ParameterName") (clojure.core/assoc :parameter-name (deser-string (clojure.core/get-in letvar835149 ["ParameterName" :content]))) (letvar835149 "Source") (clojure.core/assoc :source (deser-string (clojure.core/get-in letvar835149 ["Source" :content]))) (letvar835149 "MinimumEngineVersion") (clojure.core/assoc :minimum-engine-version (deser-string (clojure.core/get-in letvar835149 ["MinimumEngineVersion" :content]))) (letvar835149 "AllowedValues") (clojure.core/assoc :allowed-values (deser-string (clojure.core/get-in letvar835149 ["AllowedValues" :content]))) (letvar835149 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar835149 ["Description" :content]))) (letvar835149 "IsModifiable") (clojure.core/assoc :is-modifiable (deser-boolean (clojure.core/get-in letvar835149 ["IsModifiable" :content]))) (letvar835149 "ParameterValue") (clojure.core/assoc :parameter-value (deser-string (clojure.core/get-in letvar835149 ["ParameterValue" :content]))))))

(clojure.core/defn- deser-cache-node-type-specific-parameter [input] (clojure.core/let [letvar835257 {"ChangeType" (portkey.aws/search-for-tag input "ChangeType" :flattened? nil :xmlAttribute? nil), "DataType" (portkey.aws/search-for-tag input "DataType" :flattened? nil :xmlAttribute? nil), "ParameterName" (portkey.aws/search-for-tag input "ParameterName" :flattened? nil :xmlAttribute? nil), "Source" (portkey.aws/search-for-tag input "Source" :flattened? nil :xmlAttribute? nil), "MinimumEngineVersion" (portkey.aws/search-for-tag input "MinimumEngineVersion" :flattened? nil :xmlAttribute? nil), "AllowedValues" (portkey.aws/search-for-tag input "AllowedValues" :flattened? nil :xmlAttribute? nil), "CacheNodeTypeSpecificValues" (portkey.aws/search-for-tag input "CacheNodeTypeSpecificValues" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "IsModifiable" (portkey.aws/search-for-tag input "IsModifiable" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835257 "ChangeType") (clojure.core/assoc :change-type (deser-change-type (clojure.core/get-in letvar835257 ["ChangeType" :content]))) (letvar835257 "DataType") (clojure.core/assoc :data-type (deser-string (clojure.core/get-in letvar835257 ["DataType" :content]))) (letvar835257 "ParameterName") (clojure.core/assoc :parameter-name (deser-string (clojure.core/get-in letvar835257 ["ParameterName" :content]))) (letvar835257 "Source") (clojure.core/assoc :source (deser-string (clojure.core/get-in letvar835257 ["Source" :content]))) (letvar835257 "MinimumEngineVersion") (clojure.core/assoc :minimum-engine-version (deser-string (clojure.core/get-in letvar835257 ["MinimumEngineVersion" :content]))) (letvar835257 "AllowedValues") (clojure.core/assoc :allowed-values (deser-string (clojure.core/get-in letvar835257 ["AllowedValues" :content]))) (letvar835257 "CacheNodeTypeSpecificValues") (clojure.core/assoc :cache-node-type-specific-values (deser-cache-node-type-specific-value-list (clojure.core/get-in letvar835257 ["CacheNodeTypeSpecificValues" :content]))) (letvar835257 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar835257 ["Description" :content]))) (letvar835257 "IsModifiable") (clojure.core/assoc :is-modifiable (deser-boolean (clojure.core/get-in letvar835257 ["IsModifiable" :content]))))))

(clojure.core/defn- deser-snapshot [input] (clojure.core/let [letvar835365 {"CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil), "CacheSubnetGroupName" (portkey.aws/search-for-tag input "CacheSubnetGroupName" :flattened? nil :xmlAttribute? nil), "NumNodeGroups" (portkey.aws/search-for-tag input "NumNodeGroups" :flattened? nil :xmlAttribute? nil), "NodeSnapshots" (portkey.aws/search-for-tag input "NodeSnapshots" :flattened? nil :xmlAttribute? nil), "PreferredAvailabilityZone" (portkey.aws/search-for-tag input "PreferredAvailabilityZone" :flattened? nil :xmlAttribute? nil), "AutomaticFailover" (portkey.aws/search-for-tag input "AutomaticFailover" :flattened? nil :xmlAttribute? nil), "PreferredMaintenanceWindow" (portkey.aws/search-for-tag input "PreferredMaintenanceWindow" :flattened? nil :xmlAttribute? nil), "CacheClusterId" (portkey.aws/search-for-tag input "CacheClusterId" :flattened? nil :xmlAttribute? nil), "AutoMinorVersionUpgrade" (portkey.aws/search-for-tag input "AutoMinorVersionUpgrade" :flattened? nil :xmlAttribute? nil), "CacheClusterCreateTime" (portkey.aws/search-for-tag input "CacheClusterCreateTime" :flattened? nil :xmlAttribute? nil), "NumCacheNodes" (portkey.aws/search-for-tag input "NumCacheNodes" :flattened? nil :xmlAttribute? nil), "SnapshotStatus" (portkey.aws/search-for-tag input "SnapshotStatus" :flattened? nil :xmlAttribute? nil), "EngineVersion" (portkey.aws/search-for-tag input "EngineVersion" :flattened? nil :xmlAttribute? nil), "Port" (portkey.aws/search-for-tag input "Port" :flattened? nil :xmlAttribute? nil), "SnapshotWindow" (portkey.aws/search-for-tag input "SnapshotWindow" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "TopicArn" (portkey.aws/search-for-tag input "TopicArn" :flattened? nil :xmlAttribute? nil), "SnapshotSource" (portkey.aws/search-for-tag input "SnapshotSource" :flattened? nil :xmlAttribute? nil), "ReplicationGroupId" (portkey.aws/search-for-tag input "ReplicationGroupId" :flattened? nil :xmlAttribute? nil), "CacheParameterGroupName" (portkey.aws/search-for-tag input "CacheParameterGroupName" :flattened? nil :xmlAttribute? nil), "SnapshotRetentionLimit" (portkey.aws/search-for-tag input "SnapshotRetentionLimit" :flattened? nil :xmlAttribute? nil), "Engine" (portkey.aws/search-for-tag input "Engine" :flattened? nil :xmlAttribute? nil), "ReplicationGroupDescription" (portkey.aws/search-for-tag input "ReplicationGroupDescription" :flattened? nil :xmlAttribute? nil), "SnapshotName" (portkey.aws/search-for-tag input "SnapshotName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835365 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar835365 ["CacheNodeType" :content]))) (letvar835365 "CacheSubnetGroupName") (clojure.core/assoc :cache-subnet-group-name (deser-string (clojure.core/get-in letvar835365 ["CacheSubnetGroupName" :content]))) (letvar835365 "NumNodeGroups") (clojure.core/assoc :num-node-groups (deser-integer-optional (clojure.core/get-in letvar835365 ["NumNodeGroups" :content]))) (letvar835365 "NodeSnapshots") (clojure.core/assoc :node-snapshots (deser-node-snapshot-list (clojure.core/get-in letvar835365 ["NodeSnapshots" :content]))) (letvar835365 "PreferredAvailabilityZone") (clojure.core/assoc :preferred-availability-zone (deser-string (clojure.core/get-in letvar835365 ["PreferredAvailabilityZone" :content]))) (letvar835365 "AutomaticFailover") (clojure.core/assoc :automatic-failover (deser-automatic-failover-status (clojure.core/get-in letvar835365 ["AutomaticFailover" :content]))) (letvar835365 "PreferredMaintenanceWindow") (clojure.core/assoc :preferred-maintenance-window (deser-string (clojure.core/get-in letvar835365 ["PreferredMaintenanceWindow" :content]))) (letvar835365 "CacheClusterId") (clojure.core/assoc :cache-cluster-id (deser-string (clojure.core/get-in letvar835365 ["CacheClusterId" :content]))) (letvar835365 "AutoMinorVersionUpgrade") (clojure.core/assoc :auto-minor-version-upgrade (deser-boolean (clojure.core/get-in letvar835365 ["AutoMinorVersionUpgrade" :content]))) (letvar835365 "CacheClusterCreateTime") (clojure.core/assoc :cache-cluster-create-time (deser-t-stamp (clojure.core/get-in letvar835365 ["CacheClusterCreateTime" :content]))) (letvar835365 "NumCacheNodes") (clojure.core/assoc :num-cache-nodes (deser-integer-optional (clojure.core/get-in letvar835365 ["NumCacheNodes" :content]))) (letvar835365 "SnapshotStatus") (clojure.core/assoc :snapshot-status (deser-string (clojure.core/get-in letvar835365 ["SnapshotStatus" :content]))) (letvar835365 "EngineVersion") (clojure.core/assoc :engine-version (deser-string (clojure.core/get-in letvar835365 ["EngineVersion" :content]))) (letvar835365 "Port") (clojure.core/assoc :port (deser-integer-optional (clojure.core/get-in letvar835365 ["Port" :content]))) (letvar835365 "SnapshotWindow") (clojure.core/assoc :snapshot-window (deser-string (clojure.core/get-in letvar835365 ["SnapshotWindow" :content]))) (letvar835365 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar835365 ["VpcId" :content]))) (letvar835365 "TopicArn") (clojure.core/assoc :topic-arn (deser-string (clojure.core/get-in letvar835365 ["TopicArn" :content]))) (letvar835365 "SnapshotSource") (clojure.core/assoc :snapshot-source (deser-string (clojure.core/get-in letvar835365 ["SnapshotSource" :content]))) (letvar835365 "ReplicationGroupId") (clojure.core/assoc :replication-group-id (deser-string (clojure.core/get-in letvar835365 ["ReplicationGroupId" :content]))) (letvar835365 "CacheParameterGroupName") (clojure.core/assoc :cache-parameter-group-name (deser-string (clojure.core/get-in letvar835365 ["CacheParameterGroupName" :content]))) (letvar835365 "SnapshotRetentionLimit") (clojure.core/assoc :snapshot-retention-limit (deser-integer-optional (clojure.core/get-in letvar835365 ["SnapshotRetentionLimit" :content]))) (letvar835365 "Engine") (clojure.core/assoc :engine (deser-string (clojure.core/get-in letvar835365 ["Engine" :content]))) (letvar835365 "ReplicationGroupDescription") (clojure.core/assoc :replication-group-description (deser-string (clojure.core/get-in letvar835365 ["ReplicationGroupDescription" :content]))) (letvar835365 "SnapshotName") (clojure.core/assoc :snapshot-name (deser-string (clojure.core/get-in letvar835365 ["SnapshotName" :content]))))))

(clojure.core/defn- deser-t-stamp [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-recurring-charge-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-recurring-charge coll))) input))

(clojure.core/defn- deser-cache-cluster [input] (clojure.core/let [letvar835492 {"CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil), "CacheSubnetGroupName" (portkey.aws/search-for-tag input "CacheSubnetGroupName" :flattened? nil :xmlAttribute? nil), "CacheParameterGroup" (portkey.aws/search-for-tag input "CacheParameterGroup" :flattened? nil :xmlAttribute? nil), "PreferredAvailabilityZone" (portkey.aws/search-for-tag input "PreferredAvailabilityZone" :flattened? nil :xmlAttribute? nil), "PreferredMaintenanceWindow" (portkey.aws/search-for-tag input "PreferredMaintenanceWindow" :flattened? nil :xmlAttribute? nil), "SecurityGroups" (portkey.aws/search-for-tag input "SecurityGroups" :flattened? nil :xmlAttribute? nil), "ConfigurationEndpoint" (portkey.aws/search-for-tag input "ConfigurationEndpoint" :flattened? nil :xmlAttribute? nil), "AuthTokenEnabled" (portkey.aws/search-for-tag input "AuthTokenEnabled" :flattened? nil :xmlAttribute? nil), "CacheClusterId" (portkey.aws/search-for-tag input "CacheClusterId" :flattened? nil :xmlAttribute? nil), "AutoMinorVersionUpgrade" (portkey.aws/search-for-tag input "AutoMinorVersionUpgrade" :flattened? nil :xmlAttribute? nil), "CacheClusterStatus" (portkey.aws/search-for-tag input "CacheClusterStatus" :flattened? nil :xmlAttribute? nil), "CacheSecurityGroups" (portkey.aws/search-for-tag input "CacheSecurityGroups" :flattened? nil :xmlAttribute? nil), "AtRestEncryptionEnabled" (portkey.aws/search-for-tag input "AtRestEncryptionEnabled" :flattened? nil :xmlAttribute? nil), "CacheClusterCreateTime" (portkey.aws/search-for-tag input "CacheClusterCreateTime" :flattened? nil :xmlAttribute? nil), "NumCacheNodes" (portkey.aws/search-for-tag input "NumCacheNodes" :flattened? nil :xmlAttribute? nil), "TransitEncryptionEnabled" (portkey.aws/search-for-tag input "TransitEncryptionEnabled" :flattened? nil :xmlAttribute? nil), "EngineVersion" (portkey.aws/search-for-tag input "EngineVersion" :flattened? nil :xmlAttribute? nil), "ClientDownloadLandingPage" (portkey.aws/search-for-tag input "ClientDownloadLandingPage" :flattened? nil :xmlAttribute? nil), "SnapshotWindow" (portkey.aws/search-for-tag input "SnapshotWindow" :flattened? nil :xmlAttribute? nil), "ReplicationGroupId" (portkey.aws/search-for-tag input "ReplicationGroupId" :flattened? nil :xmlAttribute? nil), "SnapshotRetentionLimit" (portkey.aws/search-for-tag input "SnapshotRetentionLimit" :flattened? nil :xmlAttribute? nil), "Engine" (portkey.aws/search-for-tag input "Engine" :flattened? nil :xmlAttribute? nil), "NotificationConfiguration" (portkey.aws/search-for-tag input "NotificationConfiguration" :flattened? nil :xmlAttribute? nil), "CacheNodes" (portkey.aws/search-for-tag input "CacheNodes" :flattened? nil :xmlAttribute? nil), "PendingModifiedValues" (portkey.aws/search-for-tag input "PendingModifiedValues" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835492 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar835492 ["CacheNodeType" :content]))) (letvar835492 "CacheSubnetGroupName") (clojure.core/assoc :cache-subnet-group-name (deser-string (clojure.core/get-in letvar835492 ["CacheSubnetGroupName" :content]))) (letvar835492 "CacheParameterGroup") (clojure.core/assoc :cache-parameter-group (deser-cache-parameter-group-status (clojure.core/get-in letvar835492 ["CacheParameterGroup" :content]))) (letvar835492 "PreferredAvailabilityZone") (clojure.core/assoc :preferred-availability-zone (deser-string (clojure.core/get-in letvar835492 ["PreferredAvailabilityZone" :content]))) (letvar835492 "PreferredMaintenanceWindow") (clojure.core/assoc :preferred-maintenance-window (deser-string (clojure.core/get-in letvar835492 ["PreferredMaintenanceWindow" :content]))) (letvar835492 "SecurityGroups") (clojure.core/assoc :security-groups (deser-security-group-membership-list (clojure.core/get-in letvar835492 ["SecurityGroups" :content]))) (letvar835492 "ConfigurationEndpoint") (clojure.core/assoc :configuration-endpoint (deser-endpoint (clojure.core/get-in letvar835492 ["ConfigurationEndpoint" :content]))) (letvar835492 "AuthTokenEnabled") (clojure.core/assoc :auth-token-enabled (deser-boolean-optional (clojure.core/get-in letvar835492 ["AuthTokenEnabled" :content]))) (letvar835492 "CacheClusterId") (clojure.core/assoc :cache-cluster-id (deser-string (clojure.core/get-in letvar835492 ["CacheClusterId" :content]))) (letvar835492 "AutoMinorVersionUpgrade") (clojure.core/assoc :auto-minor-version-upgrade (deser-boolean (clojure.core/get-in letvar835492 ["AutoMinorVersionUpgrade" :content]))) (letvar835492 "CacheClusterStatus") (clojure.core/assoc :cache-cluster-status (deser-string (clojure.core/get-in letvar835492 ["CacheClusterStatus" :content]))) (letvar835492 "CacheSecurityGroups") (clojure.core/assoc :cache-security-groups (deser-cache-security-group-membership-list (clojure.core/get-in letvar835492 ["CacheSecurityGroups" :content]))) (letvar835492 "AtRestEncryptionEnabled") (clojure.core/assoc :at-rest-encryption-enabled (deser-boolean-optional (clojure.core/get-in letvar835492 ["AtRestEncryptionEnabled" :content]))) (letvar835492 "CacheClusterCreateTime") (clojure.core/assoc :cache-cluster-create-time (deser-t-stamp (clojure.core/get-in letvar835492 ["CacheClusterCreateTime" :content]))) (letvar835492 "NumCacheNodes") (clojure.core/assoc :num-cache-nodes (deser-integer-optional (clojure.core/get-in letvar835492 ["NumCacheNodes" :content]))) (letvar835492 "TransitEncryptionEnabled") (clojure.core/assoc :transit-encryption-enabled (deser-boolean-optional (clojure.core/get-in letvar835492 ["TransitEncryptionEnabled" :content]))) (letvar835492 "EngineVersion") (clojure.core/assoc :engine-version (deser-string (clojure.core/get-in letvar835492 ["EngineVersion" :content]))) (letvar835492 "ClientDownloadLandingPage") (clojure.core/assoc :client-download-landing-page (deser-string (clojure.core/get-in letvar835492 ["ClientDownloadLandingPage" :content]))) (letvar835492 "SnapshotWindow") (clojure.core/assoc :snapshot-window (deser-string (clojure.core/get-in letvar835492 ["SnapshotWindow" :content]))) (letvar835492 "ReplicationGroupId") (clojure.core/assoc :replication-group-id (deser-string (clojure.core/get-in letvar835492 ["ReplicationGroupId" :content]))) (letvar835492 "SnapshotRetentionLimit") (clojure.core/assoc :snapshot-retention-limit (deser-integer-optional (clojure.core/get-in letvar835492 ["SnapshotRetentionLimit" :content]))) (letvar835492 "Engine") (clojure.core/assoc :engine (deser-string (clojure.core/get-in letvar835492 ["Engine" :content]))) (letvar835492 "NotificationConfiguration") (clojure.core/assoc :notification-configuration (deser-notification-configuration (clojure.core/get-in letvar835492 ["NotificationConfiguration" :content]))) (letvar835492 "CacheNodes") (clojure.core/assoc :cache-nodes (deser-cache-node-list (clojure.core/get-in letvar835492 ["CacheNodes" :content]))) (letvar835492 "PendingModifiedValues") (clojure.core/assoc :pending-modified-values (deser-pending-modified-values (clojure.core/get-in letvar835492 ["PendingModifiedValues" :content]))))))

(clojure.core/defn- deser-cache-security-group-membership [input] (clojure.core/let [letvar835600 {"CacheSecurityGroupName" (portkey.aws/search-for-tag input "CacheSecurityGroupName" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835600 "CacheSecurityGroupName") (clojure.core/assoc :cache-security-group-name (deser-string (clojure.core/get-in letvar835600 ["CacheSecurityGroupName" :content]))) (letvar835600 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar835600 ["Status" :content]))))))

(clojure.core/defn- deser-endpoint [input] (clojure.core/let [letvar835708 {"Address" (portkey.aws/search-for-tag input "Address" :flattened? nil :xmlAttribute? nil), "Port" (portkey.aws/search-for-tag input "Port" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835708 "Address") (clojure.core/assoc :address (deser-string (clojure.core/get-in letvar835708 ["Address" :content]))) (letvar835708 "Port") (clojure.core/assoc :port (deser-integer (clojure.core/get-in letvar835708 ["Port" :content]))))))

(clojure.core/defn- deser-cache-parameter-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-parameter-group coll))) input))

(clojure.core/defn- deser-security-group-membership [input] (clojure.core/let [letvar835833 {"SecurityGroupId" (portkey.aws/search-for-tag input "SecurityGroupId" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835833 "SecurityGroupId") (clojure.core/assoc :security-group-id (deser-string (clojure.core/get-in letvar835833 ["SecurityGroupId" :content]))) (letvar835833 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar835833 ["Status" :content]))))))

(clojure.core/defn- deser-node-snapshot [input] (clojure.core/let [letvar835941 {"CacheClusterId" (portkey.aws/search-for-tag input "CacheClusterId" :flattened? nil :xmlAttribute? nil), "NodeGroupId" (portkey.aws/search-for-tag input "NodeGroupId" :flattened? nil :xmlAttribute? nil), "CacheNodeId" (portkey.aws/search-for-tag input "CacheNodeId" :flattened? nil :xmlAttribute? nil), "NodeGroupConfiguration" (portkey.aws/search-for-tag input "NodeGroupConfiguration" :flattened? nil :xmlAttribute? nil), "CacheSize" (portkey.aws/search-for-tag input "CacheSize" :flattened? nil :xmlAttribute? nil), "CacheNodeCreateTime" (portkey.aws/search-for-tag input "CacheNodeCreateTime" :flattened? nil :xmlAttribute? nil), "SnapshotCreateTime" (portkey.aws/search-for-tag input "SnapshotCreateTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar835941 "CacheClusterId") (clojure.core/assoc :cache-cluster-id (deser-string (clojure.core/get-in letvar835941 ["CacheClusterId" :content]))) (letvar835941 "NodeGroupId") (clojure.core/assoc :node-group-id (deser-string (clojure.core/get-in letvar835941 ["NodeGroupId" :content]))) (letvar835941 "CacheNodeId") (clojure.core/assoc :cache-node-id (deser-string (clojure.core/get-in letvar835941 ["CacheNodeId" :content]))) (letvar835941 "NodeGroupConfiguration") (clojure.core/assoc :node-group-configuration (deser-node-group-configuration (clojure.core/get-in letvar835941 ["NodeGroupConfiguration" :content]))) (letvar835941 "CacheSize") (clojure.core/assoc :cache-size (deser-string (clojure.core/get-in letvar835941 ["CacheSize" :content]))) (letvar835941 "CacheNodeCreateTime") (clojure.core/assoc :cache-node-create-time (deser-t-stamp (clojure.core/get-in letvar835941 ["CacheNodeCreateTime" :content]))) (letvar835941 "SnapshotCreateTime") (clojure.core/assoc :snapshot-create-time (deser-t-stamp (clojure.core/get-in letvar835941 ["SnapshotCreateTime" :content]))))))

(clojure.core/defn- deser-reserved-cache-node-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-cache-node coll))) input))

(clojure.core/defn- deser-tag [input] (clojure.core/let [letvar836066 {"Key" (portkey.aws/search-for-tag input "Key" :flattened? nil :xmlAttribute? nil), "Value" (portkey.aws/search-for-tag input "Value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar836066 "Key") (clojure.core/assoc :key (deser-string (clojure.core/get-in letvar836066 ["Key" :content]))) (letvar836066 "Value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar836066 ["Value" :content]))))))

(clojure.core/defn- deser-boolean-optional [input] (clojure.core/when-let [boolstr__21591__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__21591__auto__) true (clojure.core/= "false" boolstr__21591__auto__) false)))

(clojure.core/defn- deser-cache-node-type-specific-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-node-type-specific-value coll))) input))

(clojure.core/defn- deser-cache-security-group-membership-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-security-group-membership coll))) input))

(clojure.core/defn- deser-node-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-node-group coll))) input))

(clojure.core/defn- deser-notification-configuration [input] (clojure.core/let [letvar836227 {"TopicArn" (portkey.aws/search-for-tag input "TopicArn" :flattened? nil :xmlAttribute? nil), "TopicStatus" (portkey.aws/search-for-tag input "TopicStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar836227 "TopicArn") (clojure.core/assoc :topic-arn (deser-string (clojure.core/get-in letvar836227 ["TopicArn" :content]))) (letvar836227 "TopicStatus") (clojure.core/assoc :topic-status (deser-string (clojure.core/get-in letvar836227 ["TopicStatus" :content]))))))

(clojure.core/defn- deser-cache-parameter-group-status [input] (clojure.core/let [letvar836335 {"CacheParameterGroupName" (portkey.aws/search-for-tag input "CacheParameterGroupName" :flattened? nil :xmlAttribute? nil), "ParameterApplyStatus" (portkey.aws/search-for-tag input "ParameterApplyStatus" :flattened? nil :xmlAttribute? nil), "CacheNodeIdsToReboot" (portkey.aws/search-for-tag input "CacheNodeIdsToReboot" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar836335 "CacheParameterGroupName") (clojure.core/assoc :cache-parameter-group-name (deser-string (clojure.core/get-in letvar836335 ["CacheParameterGroupName" :content]))) (letvar836335 "ParameterApplyStatus") (clojure.core/assoc :parameter-apply-status (deser-string (clojure.core/get-in letvar836335 ["ParameterApplyStatus" :content]))) (letvar836335 "CacheNodeIdsToReboot") (clojure.core/assoc :cache-node-ids-to-reboot (deser-cache-node-ids-list (clojure.core/get-in letvar836335 ["CacheNodeIdsToReboot" :content]))))))

(clojure.core/defn- deser-aws-query-error-message [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-engine-defaults [input] (clojure.core/let [letvar836448 {"CacheParameterGroupFamily" (portkey.aws/search-for-tag input "CacheParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Marker" (portkey.aws/search-for-tag input "Marker" :flattened? nil :xmlAttribute? nil), "Parameters" (portkey.aws/search-for-tag input "Parameters" :flattened? nil :xmlAttribute? nil), "CacheNodeTypeSpecificParameters" (portkey.aws/search-for-tag input "CacheNodeTypeSpecificParameters" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar836448 "CacheParameterGroupFamily") (clojure.core/assoc :cache-parameter-group-family (deser-string (clojure.core/get-in letvar836448 ["CacheParameterGroupFamily" :content]))) (letvar836448 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836448 ["Marker" :content]))) (letvar836448 "Parameters") (clojure.core/assoc :parameters (deser-parameters-list (clojure.core/get-in letvar836448 ["Parameters" :content]))) (letvar836448 "CacheNodeTypeSpecificParameters") (clojure.core/assoc :cache-node-type-specific-parameters (deser-cache-node-type-specific-parameters-list (clojure.core/get-in letvar836448 ["CacheNodeTypeSpecificParameters" :content]))))))

(clojure.core/defn- deser-integer-optional [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-pending-modified-values [input] (clojure.core/let [letvar836558 {"NumCacheNodes" (portkey.aws/search-for-tag input "NumCacheNodes" :flattened? nil :xmlAttribute? nil), "CacheNodeIdsToRemove" (portkey.aws/search-for-tag input "CacheNodeIdsToRemove" :flattened? nil :xmlAttribute? nil), "EngineVersion" (portkey.aws/search-for-tag input "EngineVersion" :flattened? nil :xmlAttribute? nil), "CacheNodeType" (portkey.aws/search-for-tag input "CacheNodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar836558 "NumCacheNodes") (clojure.core/assoc :num-cache-nodes (deser-integer-optional (clojure.core/get-in letvar836558 ["NumCacheNodes" :content]))) (letvar836558 "CacheNodeIdsToRemove") (clojure.core/assoc :cache-node-ids-to-remove (deser-cache-node-ids-list (clojure.core/get-in letvar836558 ["CacheNodeIdsToRemove" :content]))) (letvar836558 "EngineVersion") (clojure.core/assoc :engine-version (deser-string (clojure.core/get-in letvar836558 ["EngineVersion" :content]))) (letvar836558 "CacheNodeType") (clojure.core/assoc :cache-node-type (deser-string (clojure.core/get-in letvar836558 ["CacheNodeType" :content]))))))

(clojure.core/defn- deser-node-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-subnet-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-subnet coll))) input))

(clojure.core/defn- deser-cache-subnet-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cache-subnet-group coll))) input))

(clojure.core/defn- deser-boolean [input] (clojure.core/when-let [boolstr__21591__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__21591__auto__) true (clojure.core/= "false" boolstr__21591__auto__) false)))

(clojure.core/defn- response-cache-parameter-group-already-exists-fault ([input] (response-cache-parameter-group-already-exists-fault nil input)) ([resultWrapper836613 input] (clojure.core/let [rawinput836612 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836614 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-test-failover-not-available-fault ([input] (response-test-failover-not-available-fault nil input)) ([resultWrapper836616 input] (clojure.core/let [rawinput836615 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836617 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-decrease-replica-count-result ([input] (response-decrease-replica-count-result nil input)) ([resultWrapper836619 input] (clojure.core/let [rawinput836618 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836620 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836618 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836619)}] (clojure.core/cond-> {} (letvar836620 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836620 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-snapshot-quota-exceeded-fault ([input] (response-snapshot-quota-exceeded-fault nil input)) ([resultWrapper836622 input] (clojure.core/let [rawinput836621 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836623 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-subnet-group-already-exists-fault ([input] (response-cache-subnet-group-already-exists-fault nil input)) ([resultWrapper836625 input] (clojure.core/let [rawinput836624 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836626 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-quota-for-customer-exceeded-fault ([input] (response-cluster-quota-for-customer-exceeded-fault nil input)) ([resultWrapper836628 input] (clojure.core/let [rawinput836627 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836629 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-node-group-not-found-fault ([input] (response-node-group-not-found-fault nil input)) ([resultWrapper836631 input] (clojure.core/let [rawinput836630 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836632 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-security-group-not-found-fault ([input] (response-cache-security-group-not-found-fault nil input)) ([resultWrapper836634 input] (clojure.core/let [rawinput836633 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836635 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-purchase-reserved-cache-nodes-offering-result ([input] (response-purchase-reserved-cache-nodes-offering-result nil input)) ([resultWrapper836637 input] (clojure.core/let [rawinput836636 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836638 {"ReservedCacheNode" (portkey.aws/search-for-tag rawinput836636 "ReservedCacheNode" :flattened? nil :result-wrapper resultWrapper836637)}] (clojure.core/cond-> {} (letvar836638 "ReservedCacheNode") (clojure.core/assoc :reserved-cache-node (deser-reserved-cache-node (clojure.core/get-in letvar836638 ["ReservedCacheNode" :content])))))))

(clojure.core/defn- response-invalid-arn-fault ([input] (response-invalid-arn-fault nil input)) ([resultWrapper836640 input] (clojure.core/let [rawinput836639 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836641 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-cache-node-not-found-fault ([input] (response-reserved-cache-node-not-found-fault nil input)) ([resultWrapper836643 input] (clojure.core/let [rawinput836642 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836644 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-subnet-group-quota-exceeded-fault ([input] (response-cache-subnet-group-quota-exceeded-fault nil input)) ([resultWrapper836646 input] (clojure.core/let [rawinput836645 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836647 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-cache-node-quota-exceeded-fault ([input] (response-reserved-cache-node-quota-exceeded-fault nil input)) ([resultWrapper836649 input] (clojure.core/let [rawinput836648 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836650 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cache-subnet-group-result ([input] (response-modify-cache-subnet-group-result nil input)) ([resultWrapper836652 input] (clojure.core/let [rawinput836651 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836653 {"CacheSubnetGroup" (portkey.aws/search-for-tag rawinput836651 "CacheSubnetGroup" :flattened? nil :result-wrapper resultWrapper836652)}] (clojure.core/cond-> {} (letvar836653 "CacheSubnetGroup") (clojure.core/assoc :cache-subnet-group (deser-cache-subnet-group (clojure.core/get-in letvar836653 ["CacheSubnetGroup" :content])))))))

(clojure.core/defn- response-allowed-node-type-modifications-message ([input] (response-allowed-node-type-modifications-message nil input)) ([resultWrapper836655 input] (clojure.core/let [rawinput836654 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836656 {"ScaleUpModifications" (portkey.aws/search-for-tag rawinput836654 "ScaleUpModifications" :flattened? nil :result-wrapper resultWrapper836655)}] (clojure.core/cond-> {} (letvar836656 "ScaleUpModifications") (clojure.core/assoc :scale-up-modifications (deser-node-type-list (clojure.core/get-in letvar836656 ["ScaleUpModifications" :content])))))))

(clojure.core/defn- response-revoke-cache-security-group-ingress-result ([input] (response-revoke-cache-security-group-ingress-result nil input)) ([resultWrapper836658 input] (clojure.core/let [rawinput836657 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836659 {"CacheSecurityGroup" (portkey.aws/search-for-tag rawinput836657 "CacheSecurityGroup" :flattened? nil :result-wrapper resultWrapper836658)}] (clojure.core/cond-> {} (letvar836659 "CacheSecurityGroup") (clojure.core/assoc :cache-security-group (deser-cache-security-group (clojure.core/get-in letvar836659 ["CacheSecurityGroup" :content])))))))

(clojure.core/defn- response-describe-snapshots-list-message ([input] (response-describe-snapshots-list-message nil input)) ([resultWrapper836661 input] (clojure.core/let [rawinput836660 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836662 {"Marker" (portkey.aws/search-for-tag rawinput836660 "Marker" :flattened? nil :result-wrapper resultWrapper836661), "Snapshots" (portkey.aws/search-for-tag rawinput836660 "Snapshots" :flattened? nil :result-wrapper resultWrapper836661)}] (clojure.core/cond-> {} (letvar836662 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836662 ["Marker" :content]))) (letvar836662 "Snapshots") (clojure.core/assoc :snapshots (deser-snapshot-list (clojure.core/get-in letvar836662 ["Snapshots" :content])))))))

(clojure.core/defn- response-cache-security-group-quota-exceeded-fault ([input] (response-cache-security-group-quota-exceeded-fault nil input)) ([resultWrapper836664 input] (clojure.core/let [rawinput836663 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836665 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-replication-group-not-found-fault ([input] (response-replication-group-not-found-fault nil input)) ([resultWrapper836667 input] (clojure.core/let [rawinput836666 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836668 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-parameter-group-details ([input] (response-cache-parameter-group-details nil input)) ([resultWrapper836670 input] (clojure.core/let [rawinput836669 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836671 {"Marker" (portkey.aws/search-for-tag rawinput836669 "Marker" :flattened? nil :result-wrapper resultWrapper836670), "Parameters" (portkey.aws/search-for-tag rawinput836669 "Parameters" :flattened? nil :result-wrapper resultWrapper836670), "CacheNodeTypeSpecificParameters" (portkey.aws/search-for-tag rawinput836669 "CacheNodeTypeSpecificParameters" :flattened? nil :result-wrapper resultWrapper836670)}] (clojure.core/cond-> {} (letvar836671 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836671 ["Marker" :content]))) (letvar836671 "Parameters") (clojure.core/assoc :parameters (deser-parameters-list (clojure.core/get-in letvar836671 ["Parameters" :content]))) (letvar836671 "CacheNodeTypeSpecificParameters") (clojure.core/assoc :cache-node-type-specific-parameters (deser-cache-node-type-specific-parameters-list (clojure.core/get-in letvar836671 ["CacheNodeTypeSpecificParameters" :content])))))))

(clojure.core/defn- response-invalid-vpc-network-state-fault ([input] (response-invalid-vpc-network-state-fault nil input)) ([resultWrapper836673 input] (clojure.core/let [rawinput836672 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836674 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-subnet-group-not-found-fault ([input] (response-cache-subnet-group-not-found-fault nil input)) ([resultWrapper836676 input] (clojure.core/let [rawinput836675 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836677 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-tag-quota-per-resource-exceeded ([input] (response-tag-quota-per-resource-exceeded nil input)) ([resultWrapper836679 input] (clojure.core/let [rawinput836678 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836680 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorization-already-exists-fault ([input] (response-authorization-already-exists-fault nil input)) ([resultWrapper836682 input] (clojure.core/let [rawinput836681 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836683 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-feature-not-supported-fault ([input] (response-snapshot-feature-not-supported-fault nil input)) ([resultWrapper836685 input] (clojure.core/let [rawinput836684 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836686 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-cluster-already-exists-fault ([input] (response-cache-cluster-already-exists-fault nil input)) ([resultWrapper836688 input] (clojure.core/let [rawinput836687 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836689 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-cache-subnet-group-result ([input] (response-create-cache-subnet-group-result nil input)) ([resultWrapper836691 input] (clojure.core/let [rawinput836690 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836692 {"CacheSubnetGroup" (portkey.aws/search-for-tag rawinput836690 "CacheSubnetGroup" :flattened? nil :result-wrapper resultWrapper836691)}] (clojure.core/cond-> {} (letvar836692 "CacheSubnetGroup") (clojure.core/assoc :cache-subnet-group (deser-cache-subnet-group (clojure.core/get-in letvar836692 ["CacheSubnetGroup" :content])))))))

(clojure.core/defn- response-events-message ([input] (response-events-message nil input)) ([resultWrapper836694 input] (clojure.core/let [rawinput836693 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836695 {"Marker" (portkey.aws/search-for-tag rawinput836693 "Marker" :flattened? nil :result-wrapper resultWrapper836694), "Events" (portkey.aws/search-for-tag rawinput836693 "Events" :flattened? nil :result-wrapper resultWrapper836694)}] (clojure.core/cond-> {} (letvar836695 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836695 ["Marker" :content]))) (letvar836695 "Events") (clojure.core/assoc :events (deser-event-list (clojure.core/get-in letvar836695 ["Events" :content])))))))

(clojure.core/defn- response-invalid-snapshot-state-fault ([input] (response-invalid-snapshot-state-fault nil input)) ([resultWrapper836697 input] (clojure.core/let [rawinput836696 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836698 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-cache-node-message ([input] (response-reserved-cache-node-message nil input)) ([resultWrapper836700 input] (clojure.core/let [rawinput836699 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836701 {"Marker" (portkey.aws/search-for-tag rawinput836699 "Marker" :flattened? nil :result-wrapper resultWrapper836700), "ReservedCacheNodes" (portkey.aws/search-for-tag rawinput836699 "ReservedCacheNodes" :flattened? nil :result-wrapper resultWrapper836700)}] (clojure.core/cond-> {} (letvar836701 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836701 ["Marker" :content]))) (letvar836701 "ReservedCacheNodes") (clojure.core/assoc :reserved-cache-nodes (deser-reserved-cache-node-list (clojure.core/get-in letvar836701 ["ReservedCacheNodes" :content])))))))

(clojure.core/defn- response-cache-subnet-quota-exceeded-fault ([input] (response-cache-subnet-quota-exceeded-fault nil input)) ([resultWrapper836703 input] (clojure.core/let [rawinput836702 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836704 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-cache-node-already-exists-fault ([input] (response-reserved-cache-node-already-exists-fault nil input)) ([resultWrapper836706 input] (clojure.core/let [rawinput836705 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836707 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-increase-replica-count-result ([input] (response-increase-replica-count-result nil input)) ([resultWrapper836709 input] (clojure.core/let [rawinput836708 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836710 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836708 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836709)}] (clojure.core/cond-> {} (letvar836710 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836710 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-test-failover-result ([input] (response-test-failover-result nil input)) ([resultWrapper836712 input] (clojure.core/let [rawinput836711 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836713 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836711 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836712)}] (clojure.core/cond-> {} (letvar836713 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836713 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-delete-snapshot-result ([input] (response-delete-snapshot-result nil input)) ([resultWrapper836715 input] (clojure.core/let [rawinput836714 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836716 {"Snapshot" (portkey.aws/search-for-tag rawinput836714 "Snapshot" :flattened? nil :result-wrapper resultWrapper836715)}] (clojure.core/cond-> {} (letvar836716 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar836716 ["Snapshot" :content])))))))

(clojure.core/defn- response-service-linked-role-not-found-fault ([input] (response-service-linked-role-not-found-fault nil input)) ([resultWrapper836718 input] (clojure.core/let [rawinput836717 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836719 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-not-found-fault ([input] (response-snapshot-not-found-fault nil input)) ([resultWrapper836721 input] (clojure.core/let [rawinput836720 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836722 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-engine-default-parameters-result ([input] (response-describe-engine-default-parameters-result nil input)) ([resultWrapper836724 input] (clojure.core/let [rawinput836723 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836725 {"EngineDefaults" (portkey.aws/search-for-tag rawinput836723 "EngineDefaults" :flattened? nil :result-wrapper resultWrapper836724)}] (clojure.core/cond-> {} (letvar836725 "EngineDefaults") (clojure.core/assoc :engine-defaults (deser-engine-defaults (clojure.core/get-in letvar836725 ["EngineDefaults" :content])))))))

(clojure.core/defn- response-authorization-not-found-fault ([input] (response-authorization-not-found-fault nil input)) ([resultWrapper836727 input] (clojure.core/let [rawinput836726 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836728 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-cache-nodes-offering-message ([input] (response-reserved-cache-nodes-offering-message nil input)) ([resultWrapper836730 input] (clojure.core/let [rawinput836729 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836731 {"Marker" (portkey.aws/search-for-tag rawinput836729 "Marker" :flattened? nil :result-wrapper resultWrapper836730), "ReservedCacheNodesOfferings" (portkey.aws/search-for-tag rawinput836729 "ReservedCacheNodesOfferings" :flattened? nil :result-wrapper resultWrapper836730)}] (clojure.core/cond-> {} (letvar836731 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836731 ["Marker" :content]))) (letvar836731 "ReservedCacheNodesOfferings") (clojure.core/assoc :reserved-cache-nodes-offerings (deser-reserved-cache-nodes-offering-list (clojure.core/get-in letvar836731 ["ReservedCacheNodesOfferings" :content])))))))

(clojure.core/defn- response-invalid-subnet ([input] (response-invalid-subnet nil input)) ([resultWrapper836733 input] (clojure.core/let [rawinput836732 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836734 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reboot-cache-cluster-result ([input] (response-reboot-cache-cluster-result nil input)) ([resultWrapper836736 input] (clojure.core/let [rawinput836735 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836737 {"CacheCluster" (portkey.aws/search-for-tag rawinput836735 "CacheCluster" :flattened? nil :result-wrapper resultWrapper836736)}] (clojure.core/cond-> {} (letvar836737 "CacheCluster") (clojure.core/assoc :cache-cluster (deser-cache-cluster (clojure.core/get-in letvar836737 ["CacheCluster" :content])))))))

(clojure.core/defn- response-subnet-in-use ([input] (response-subnet-in-use nil input)) ([resultWrapper836739 input] (clojure.core/let [rawinput836738 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836740 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-security-group-message ([input] (response-cache-security-group-message nil input)) ([resultWrapper836742 input] (clojure.core/let [rawinput836741 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836743 {"Marker" (portkey.aws/search-for-tag rawinput836741 "Marker" :flattened? nil :result-wrapper resultWrapper836742), "CacheSecurityGroups" (portkey.aws/search-for-tag rawinput836741 "CacheSecurityGroups" :flattened? nil :result-wrapper resultWrapper836742)}] (clojure.core/cond-> {} (letvar836743 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836743 ["Marker" :content]))) (letvar836743 "CacheSecurityGroups") (clojure.core/assoc :cache-security-groups (deser-cache-security-groups (clojure.core/get-in letvar836743 ["CacheSecurityGroups" :content])))))))

(clojure.core/defn- response-create-cache-security-group-result ([input] (response-create-cache-security-group-result nil input)) ([resultWrapper836745 input] (clojure.core/let [rawinput836744 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836746 {"CacheSecurityGroup" (portkey.aws/search-for-tag rawinput836744 "CacheSecurityGroup" :flattened? nil :result-wrapper resultWrapper836745)}] (clojure.core/cond-> {} (letvar836746 "CacheSecurityGroup") (clojure.core/assoc :cache-security-group (deser-cache-security-group (clojure.core/get-in letvar836746 ["CacheSecurityGroup" :content])))))))

(clojure.core/defn- response-invalid-cache-security-group-state-fault ([input] (response-invalid-cache-security-group-state-fault nil input)) ([resultWrapper836748 input] (clojure.core/let [rawinput836747 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836749 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-snapshot-result ([input] (response-create-snapshot-result nil input)) ([resultWrapper836751 input] (clojure.core/let [rawinput836750 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836752 {"Snapshot" (portkey.aws/search-for-tag rawinput836750 "Snapshot" :flattened? nil :result-wrapper resultWrapper836751)}] (clojure.core/cond-> {} (letvar836752 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar836752 ["Snapshot" :content])))))))

(clojure.core/defn- response-modify-cache-cluster-result ([input] (response-modify-cache-cluster-result nil input)) ([resultWrapper836754 input] (clojure.core/let [rawinput836753 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836755 {"CacheCluster" (portkey.aws/search-for-tag rawinput836753 "CacheCluster" :flattened? nil :result-wrapper resultWrapper836754)}] (clojure.core/cond-> {} (letvar836755 "CacheCluster") (clojure.core/assoc :cache-cluster (deser-cache-cluster (clojure.core/get-in letvar836755 ["CacheCluster" :content])))))))

(clojure.core/defn- response-replication-group-already-exists-fault ([input] (response-replication-group-already-exists-fault nil input)) ([resultWrapper836757 input] (clojure.core/let [rawinput836756 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836758 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-replication-group-shard-configuration-result ([input] (response-modify-replication-group-shard-configuration-result nil input)) ([resultWrapper836760 input] (clojure.core/let [rawinput836759 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836761 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836759 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836760)}] (clojure.core/cond-> {} (letvar836761 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836761 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-delete-cache-cluster-result ([input] (response-delete-cache-cluster-result nil input)) ([resultWrapper836763 input] (clojure.core/let [rawinput836762 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836764 {"CacheCluster" (portkey.aws/search-for-tag rawinput836762 "CacheCluster" :flattened? nil :result-wrapper resultWrapper836763)}] (clojure.core/cond-> {} (letvar836764 "CacheCluster") (clojure.core/assoc :cache-cluster (deser-cache-cluster (clojure.core/get-in letvar836764 ["CacheCluster" :content])))))))

(clojure.core/defn- response-tag-list-message ([input] (response-tag-list-message nil input)) ([resultWrapper836766 input] (clojure.core/let [rawinput836765 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836767 {"TagList" (portkey.aws/search-for-tag rawinput836765 "TagList" :flattened? nil :result-wrapper resultWrapper836766)}] (clojure.core/cond-> {} (letvar836767 "TagList") (clojure.core/assoc :tag-list (deser-tag-list (clojure.core/get-in letvar836767 ["TagList" :content])))))))

(clojure.core/defn- response-delete-replication-group-result ([input] (response-delete-replication-group-result nil input)) ([resultWrapper836769 input] (clojure.core/let [rawinput836768 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836770 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836768 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836769)}] (clojure.core/cond-> {} (letvar836770 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836770 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-cache-subnet-group-in-use ([input] (response-cache-subnet-group-in-use nil input)) ([resultWrapper836772 input] (clojure.core/let [rawinput836771 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836773 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-replication-group-state-fault ([input] (response-invalid-replication-group-state-fault nil input)) ([resultWrapper836775 input] (clojure.core/let [rawinput836774 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836776 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-replication-group-result ([input] (response-create-replication-group-result nil input)) ([resultWrapper836778 input] (clojure.core/let [rawinput836777 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836779 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836777 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836778)}] (clojure.core/cond-> {} (letvar836779 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836779 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-cache-cluster-message ([input] (response-cache-cluster-message nil input)) ([resultWrapper836781 input] (clojure.core/let [rawinput836780 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836782 {"Marker" (portkey.aws/search-for-tag rawinput836780 "Marker" :flattened? nil :result-wrapper resultWrapper836781), "CacheClusters" (portkey.aws/search-for-tag rawinput836780 "CacheClusters" :flattened? nil :result-wrapper resultWrapper836781)}] (clojure.core/cond-> {} (letvar836782 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836782 ["Marker" :content]))) (letvar836782 "CacheClusters") (clojure.core/assoc :cache-clusters (deser-cache-cluster-list (clojure.core/get-in letvar836782 ["CacheClusters" :content])))))))

(clojure.core/defn- response-node-quota-for-customer-exceeded-fault ([input] (response-node-quota-for-customer-exceeded-fault nil input)) ([resultWrapper836784 input] (clojure.core/let [rawinput836783 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836785 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-parameter-groups-message ([input] (response-cache-parameter-groups-message nil input)) ([resultWrapper836787 input] (clojure.core/let [rawinput836786 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836788 {"Marker" (portkey.aws/search-for-tag rawinput836786 "Marker" :flattened? nil :result-wrapper resultWrapper836787), "CacheParameterGroups" (portkey.aws/search-for-tag rawinput836786 "CacheParameterGroups" :flattened? nil :result-wrapper resultWrapper836787)}] (clojure.core/cond-> {} (letvar836788 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836788 ["Marker" :content]))) (letvar836788 "CacheParameterGroups") (clojure.core/assoc :cache-parameter-groups (deser-cache-parameter-group-list (clojure.core/get-in letvar836788 ["CacheParameterGroups" :content])))))))

(clojure.core/defn- response-create-cache-parameter-group-result ([input] (response-create-cache-parameter-group-result nil input)) ([resultWrapper836790 input] (clojure.core/let [rawinput836789 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836791 {"CacheParameterGroup" (portkey.aws/search-for-tag rawinput836789 "CacheParameterGroup" :flattened? nil :result-wrapper resultWrapper836790)}] (clojure.core/cond-> {} (letvar836791 "CacheParameterGroup") (clojure.core/assoc :cache-parameter-group (deser-cache-parameter-group (clojure.core/get-in letvar836791 ["CacheParameterGroup" :content])))))))

(clojure.core/defn- response-node-groups-per-replication-group-quota-exceeded-fault ([input] (response-node-groups-per-replication-group-quota-exceeded-fault nil input)) ([resultWrapper836793 input] (clojure.core/let [rawinput836792 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836794 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-parameter-combination-exception ([input] (response-invalid-parameter-combination-exception nil input)) ([resultWrapper836796 input] (clojure.core/let [rawinput836795 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836797 {"message" (portkey.aws/search-for-tag rawinput836795 "message" :flattened? nil :result-wrapper resultWrapper836796)}] (clojure.core/cond-> {} (letvar836797 "message") (clojure.core/assoc :message (deser-aws-query-error-message (clojure.core/get-in letvar836797 ["message" :content])))))))

(clojure.core/defn- response-invalid-cache-parameter-group-state-fault ([input] (response-invalid-cache-parameter-group-state-fault nil input)) ([resultWrapper836799 input] (clojure.core/let [rawinput836798 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836800 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-parameter-group-not-found-fault ([input] (response-cache-parameter-group-not-found-fault nil input)) ([resultWrapper836802 input] (clojure.core/let [rawinput836801 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836803 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-parameter-group-name-message ([input] (response-cache-parameter-group-name-message nil input)) ([resultWrapper836805 input] (clojure.core/let [rawinput836804 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836806 {"CacheParameterGroupName" (portkey.aws/search-for-tag rawinput836804 "CacheParameterGroupName" :flattened? nil :result-wrapper resultWrapper836805)}] (clojure.core/cond-> {} (letvar836806 "CacheParameterGroupName") (clojure.core/assoc :cache-parameter-group-name (deser-string (clojure.core/get-in letvar836806 ["CacheParameterGroupName" :content])))))))

(clojure.core/defn- response-create-cache-cluster-result ([input] (response-create-cache-cluster-result nil input)) ([resultWrapper836808 input] (clojure.core/let [rawinput836807 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836809 {"CacheCluster" (portkey.aws/search-for-tag rawinput836807 "CacheCluster" :flattened? nil :result-wrapper resultWrapper836808)}] (clojure.core/cond-> {} (letvar836809 "CacheCluster") (clojure.core/assoc :cache-cluster (deser-cache-cluster (clojure.core/get-in letvar836809 ["CacheCluster" :content])))))))

(clojure.core/defn- response-reserved-cache-nodes-offering-not-found-fault ([input] (response-reserved-cache-nodes-offering-not-found-fault nil input)) ([resultWrapper836811 input] (clojure.core/let [rawinput836810 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836812 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-cluster-not-found-fault ([input] (response-cache-cluster-not-found-fault nil input)) ([resultWrapper836814 input] (clojure.core/let [rawinput836813 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836815 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-security-group-already-exists-fault ([input] (response-cache-security-group-already-exists-fault nil input)) ([resultWrapper836817 input] (clojure.core/let [rawinput836816 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836818 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-copy-snapshot-result ([input] (response-copy-snapshot-result nil input)) ([resultWrapper836820 input] (clojure.core/let [rawinput836819 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836821 {"Snapshot" (portkey.aws/search-for-tag rawinput836819 "Snapshot" :flattened? nil :result-wrapper resultWrapper836820)}] (clojure.core/cond-> {} (letvar836821 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar836821 ["Snapshot" :content])))))))

(clojure.core/defn- response-node-quota-for-cluster-exceeded-fault ([input] (response-node-quota-for-cluster-exceeded-fault nil input)) ([resultWrapper836823 input] (clojure.core/let [rawinput836822 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836824 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-replication-group-message ([input] (response-replication-group-message nil input)) ([resultWrapper836826 input] (clojure.core/let [rawinput836825 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836827 {"Marker" (portkey.aws/search-for-tag rawinput836825 "Marker" :flattened? nil :result-wrapper resultWrapper836826), "ReplicationGroups" (portkey.aws/search-for-tag rawinput836825 "ReplicationGroups" :flattened? nil :result-wrapper resultWrapper836826)}] (clojure.core/cond-> {} (letvar836827 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836827 ["Marker" :content]))) (letvar836827 "ReplicationGroups") (clojure.core/assoc :replication-groups (deser-replication-group-list (clojure.core/get-in letvar836827 ["ReplicationGroups" :content])))))))

(clojure.core/defn- response-tag-not-found-fault ([input] (response-tag-not-found-fault nil input)) ([resultWrapper836829 input] (clojure.core/let [rawinput836828 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836830 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-engine-version-message ([input] (response-cache-engine-version-message nil input)) ([resultWrapper836832 input] (clojure.core/let [rawinput836831 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836833 {"Marker" (portkey.aws/search-for-tag rawinput836831 "Marker" :flattened? nil :result-wrapper resultWrapper836832), "CacheEngineVersions" (portkey.aws/search-for-tag rawinput836831 "CacheEngineVersions" :flattened? nil :result-wrapper resultWrapper836832)}] (clojure.core/cond-> {} (letvar836833 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836833 ["Marker" :content]))) (letvar836833 "CacheEngineVersions") (clojure.core/assoc :cache-engine-versions (deser-cache-engine-version-list (clojure.core/get-in letvar836833 ["CacheEngineVersions" :content])))))))

(clojure.core/defn- response-cache-subnet-group-message ([input] (response-cache-subnet-group-message nil input)) ([resultWrapper836835 input] (clojure.core/let [rawinput836834 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836836 {"Marker" (portkey.aws/search-for-tag rawinput836834 "Marker" :flattened? nil :result-wrapper resultWrapper836835), "CacheSubnetGroups" (portkey.aws/search-for-tag rawinput836834 "CacheSubnetGroups" :flattened? nil :result-wrapper resultWrapper836835)}] (clojure.core/cond-> {} (letvar836836 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar836836 ["Marker" :content]))) (letvar836836 "CacheSubnetGroups") (clojure.core/assoc :cache-subnet-groups (deser-cache-subnet-groups (clojure.core/get-in letvar836836 ["CacheSubnetGroups" :content])))))))

(clojure.core/defn- response-invalid-parameter-value-exception ([input] (response-invalid-parameter-value-exception nil input)) ([resultWrapper836838 input] (clojure.core/let [rawinput836837 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836839 {"message" (portkey.aws/search-for-tag rawinput836837 "message" :flattened? nil :result-wrapper resultWrapper836838)}] (clojure.core/cond-> {} (letvar836839 "message") (clojure.core/assoc :message (deser-aws-query-error-message (clojure.core/get-in letvar836839 ["message" :content])))))))

(clojure.core/defn- response-no-operation-fault ([input] (response-no-operation-fault nil input)) ([resultWrapper836841 input] (clojure.core/let [rawinput836840 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836842 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-insufficient-cache-cluster-capacity-fault ([input] (response-insufficient-cache-cluster-capacity-fault nil input)) ([resultWrapper836844 input] (clojure.core/let [rawinput836843 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836845 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-api-call-rate-for-customer-exceeded-fault ([input] (response-api-call-rate-for-customer-exceeded-fault nil input)) ([resultWrapper836847 input] (clojure.core/let [rawinput836846 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836848 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorize-cache-security-group-ingress-result ([input] (response-authorize-cache-security-group-ingress-result nil input)) ([resultWrapper836850 input] (clojure.core/let [rawinput836849 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836851 {"CacheSecurityGroup" (portkey.aws/search-for-tag rawinput836849 "CacheSecurityGroup" :flattened? nil :result-wrapper resultWrapper836850)}] (clojure.core/cond-> {} (letvar836851 "CacheSecurityGroup") (clojure.core/assoc :cache-security-group (deser-cache-security-group (clojure.core/get-in letvar836851 ["CacheSecurityGroup" :content])))))))

(clojure.core/defn- response-modify-replication-group-result ([input] (response-modify-replication-group-result nil input)) ([resultWrapper836853 input] (clojure.core/let [rawinput836852 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836854 {"ReplicationGroup" (portkey.aws/search-for-tag rawinput836852 "ReplicationGroup" :flattened? nil :result-wrapper resultWrapper836853)}] (clojure.core/cond-> {} (letvar836854 "ReplicationGroup") (clojure.core/assoc :replication-group (deser-replication-group (clojure.core/get-in letvar836854 ["ReplicationGroup" :content])))))))

(clojure.core/defn- response-invalid-cache-cluster-state-fault ([input] (response-invalid-cache-cluster-state-fault nil input)) ([resultWrapper836856 input] (clojure.core/let [rawinput836855 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836857 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-already-exists-fault ([input] (response-snapshot-already-exists-fault nil input)) ([resultWrapper836859 input] (clojure.core/let [rawinput836858 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836860 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cache-parameter-group-quota-exceeded-fault ([input] (response-cache-parameter-group-quota-exceeded-fault nil input)) ([resultWrapper836862 input] (clojure.core/let [rawinput836861 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar836863 {}] (clojure.core/cond-> {}))))

(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-member/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-member/cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-member/read-endpoint (clojure.spec.alpha/and :portkey.aws.elasticache/endpoint))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-member/preferred-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-member/current-role (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/node-group-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.node-group-member/cache-cluster-id :portkey.aws.elasticache.node-group-member/cache-node-id :portkey.aws.elasticache.node-group-member/read-endpoint :portkey.aws.elasticache.node-group-member/preferred-availability-zone :portkey.aws.elasticache.node-group-member/current-role]))

(clojure.spec.alpha/def :portkey.aws.elasticache.test-failover-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.test-failover-message/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/allowed-node-group-id))
(clojure.spec.alpha/def :portkey.aws.elasticache/test-failover-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.test-failover-message/replication-group-id :portkey.aws.elasticache.test-failover-message/node-group-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/test-failover-not-available-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/subnet-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-engine-versions-message/engine (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-engine-versions-message/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-engine-versions-message/cache-parameter-group-family (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-engine-versions-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-engine-versions-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-engine-versions-message/default-only (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-cache-engine-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-cache-engine-versions-message/engine :portkey.aws.elasticache.describe-cache-engine-versions-message/engine-version :portkey.aws.elasticache.describe-cache-engine-versions-message/cache-parameter-group-family :portkey.aws.elasticache.describe-cache-engine-versions-message/max-records :portkey.aws.elasticache.describe-cache-engine-versions-message/marker :portkey.aws.elasticache.describe-cache-engine-versions-message/default-only]))

(clojure.spec.alpha/def :portkey.aws.elasticache.delete-replication-group-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.delete-replication-group-message/retain-primary-cluster (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.delete-replication-group-message/final-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/delete-replication-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.delete-replication-group-message/replication-group-id] :opt-un [:portkey.aws.elasticache.delete-replication-group-message/retain-primary-cluster :portkey.aws.elasticache.delete-replication-group-message/final-snapshot-identifier]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group/owner-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group/ec-2-security-groups (clojure.spec.alpha/and :portkey.aws.elasticache/ec-2-security-group-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-security-group/owner-id :portkey.aws.elasticache.cache-security-group/cache-security-group-name :portkey.aws.elasticache.cache-security-group/description :portkey.aws.elasticache.cache-security-group/ec-2-security-groups]))

(clojure.spec.alpha/def :portkey.aws.elasticache/az-mode #{:crossaz "cross-az" :singleaz "single-az"})

(clojure.spec.alpha/def :portkey.aws.elasticache/decrease-replica-count-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/parameters-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/parameter))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/ec-2-security-group-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/ec-2-security-group))

(clojure.spec.alpha/def :portkey.aws.elasticache/change-type #{"immediate" :requiresreboot "requires-reboot" :immediate})

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group/cache-parameter-group-family (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-parameter-group/cache-parameter-group-name :portkey.aws.elasticache.cache-parameter-group/cache-parameter-group-family :portkey.aws.elasticache.cache-parameter-group/description]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-group-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/node-group-configuration))

(clojure.spec.alpha/def :portkey.aws.elasticache/cluster-quota-for-customer-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/security-group-membership))

(clojure.spec.alpha/def :portkey.aws.elasticache/replication-group-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/replication-group))

(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/reserved-cache-nodes-offering-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/duration (clojure.spec.alpha/and :portkey.aws.elasticache/integer))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/fixed-price (clojure.spec.alpha/and :portkey.aws.elasticache/double))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/usage-price (clojure.spec.alpha/and :portkey.aws.elasticache/double))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/product-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/offering-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering/recurring-charges (clojure.spec.alpha/and :portkey.aws.elasticache/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-nodes-offering (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.reserved-cache-nodes-offering/reserved-cache-nodes-offering-id :portkey.aws.elasticache.reserved-cache-nodes-offering/cache-node-type :portkey.aws.elasticache.reserved-cache-nodes-offering/duration :portkey.aws.elasticache.reserved-cache-nodes-offering/fixed-price :portkey.aws.elasticache.reserved-cache-nodes-offering/usage-price :portkey.aws.elasticache.reserved-cache-nodes-offering/product-description :portkey.aws.elasticache.reserved-cache-nodes-offering/offering-type :portkey.aws.elasticache.reserved-cache-nodes-offering/recurring-charges]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-engine-version-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-engine-version))

(clojure.spec.alpha/def :portkey.aws.elasticache.slot-migration/progress-percentage (clojure.spec.alpha/and :portkey.aws.elasticache/double))
(clojure.spec.alpha/def :portkey.aws.elasticache/slot-migration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.slot-migration/progress-percentage]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node/cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node/cache-node-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node/cache-node-create-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node/parameter-group-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node/source-cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node/customer-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-node/cache-node-id :portkey.aws.elasticache.cache-node/cache-node-status :portkey.aws.elasticache.cache-node/cache-node-create-time :portkey.aws.elasticache/endpoint :portkey.aws.elasticache.cache-node/parameter-group-status :portkey.aws.elasticache.cache-node/source-cache-node-id :portkey.aws.elasticache.cache-node/customer-availability-zone]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/pending-automatic-failover-status #{:disabled "enabled" "disabled" :enabled})

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-engine-default-parameters-message/cache-parameter-group-family (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-engine-default-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-engine-default-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-engine-default-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.describe-engine-default-parameters-message/cache-parameter-group-family] :opt-un [:portkey.aws.elasticache.describe-engine-default-parameters-message/max-records :portkey.aws.elasticache.describe-engine-default-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache/purchase-reserved-cache-nodes-offering-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/reserved-cache-node]))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-arn-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-node-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-parameter-group-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-parameter-group-message/cache-parameter-group-family (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-parameter-group-message/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.create-cache-parameter-group-message/cache-parameter-group-name :portkey.aws.elasticache.create-cache-parameter-group-message/cache-parameter-group-family :portkey.aws.elasticache.create-cache-parameter-group-message/description] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-subnet-group-message/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-subnet-group-message/cache-subnet-group-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.elasticache/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/modify-cache-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.modify-cache-subnet-group-message/cache-subnet-group-name] :opt-un [:portkey.aws.elasticache.modify-cache-subnet-group-message/cache-subnet-group-description :portkey.aws.elasticache.modify-cache-subnet-group-message/subnet-ids]))

(clojure.spec.alpha/def :portkey.aws.elasticache.decrease-replica-count-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.decrease-replica-count-message/new-replica-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.decrease-replica-count-message/replica-configuration (clojure.spec.alpha/and :portkey.aws.elasticache/replica-configuration-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.decrease-replica-count-message/replicas-to-remove (clojure.spec.alpha/and :portkey.aws.elasticache/remove-replicas-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.decrease-replica-count-message/apply-immediately (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache/decrease-replica-count-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.decrease-replica-count-message/replication-group-id :portkey.aws.elasticache.decrease-replica-count-message/apply-immediately] :opt-un [:portkey.aws.elasticache.decrease-replica-count-message/new-replica-count :portkey.aws.elasticache.decrease-replica-count-message/replica-configuration :portkey.aws.elasticache.decrease-replica-count-message/replicas-to-remove]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-groups-to-remove-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/allowed-node-group-id))

(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/member-clusters (clojure.spec.alpha/and :portkey.aws.elasticache/cluster-id-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/automatic-failover (clojure.spec.alpha/and :portkey.aws.elasticache/automatic-failover-status))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/node-groups (clojure.spec.alpha/and :portkey.aws.elasticache/node-group-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/configuration-endpoint (clojure.spec.alpha/and :portkey.aws.elasticache/endpoint))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/auth-token-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/at-rest-encryption-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/cluster-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/transit-encryption-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/snapshotting-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group/pending-modified-values (clojure.spec.alpha/and :portkey.aws.elasticache/replication-group-pending-modified-values))
(clojure.spec.alpha/def :portkey.aws.elasticache/replication-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.replication-group/cache-node-type :portkey.aws.elasticache.replication-group/member-clusters :portkey.aws.elasticache.replication-group/automatic-failover :portkey.aws.elasticache.replication-group/node-groups :portkey.aws.elasticache.replication-group/configuration-endpoint :portkey.aws.elasticache.replication-group/auth-token-enabled :portkey.aws.elasticache.replication-group/status :portkey.aws.elasticache.replication-group/at-rest-encryption-enabled :portkey.aws.elasticache.replication-group/cluster-enabled :portkey.aws.elasticache.replication-group/transit-encryption-enabled :portkey.aws.elasticache.replication-group/description :portkey.aws.elasticache.replication-group/snapshot-window :portkey.aws.elasticache.replication-group/snapshotting-cluster-id :portkey.aws.elasticache.replication-group/replication-group-id :portkey.aws.elasticache.replication-group/snapshot-retention-limit :portkey.aws.elasticache.replication-group/pending-modified-values]))

(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-node-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/snapshot))

(clojure.spec.alpha/def :portkey.aws.elasticache/security-group-ids-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache.subnet/subnet-identifier (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.subnet/subnet-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/availability-zone))
(clojure.spec.alpha/def :portkey.aws.elasticache/subnet (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.subnet/subnet-identifier :portkey.aws.elasticache.subnet/subnet-availability-zone]))

(clojure.spec.alpha/def :portkey.aws.elasticache/modify-cache-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/parameter-name-value-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/parameter-name-value))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameters-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameters-message/source (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-cache-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.describe-cache-parameters-message/cache-parameter-group-name] :opt-un [:portkey.aws.elasticache.describe-cache-parameters-message/source :portkey.aws.elasticache.describe-cache-parameters-message/max-records :portkey.aws.elasticache.describe-cache-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/start-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/cache-node-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/fixed-price (clojure.spec.alpha/and :portkey.aws.elasticache/double))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/reservation-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/reserved-cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/duration (clojure.spec.alpha/and :portkey.aws.elasticache/integer))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/usage-price (clojure.spec.alpha/and :portkey.aws.elasticache/double))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/product-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/state (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/reserved-cache-nodes-offering-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/recurring-charges (clojure.spec.alpha/and :portkey.aws.elasticache/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node/offering-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.reserved-cache-node/cache-node-type :portkey.aws.elasticache.reserved-cache-node/start-time :portkey.aws.elasticache.reserved-cache-node/cache-node-count :portkey.aws.elasticache.reserved-cache-node/fixed-price :portkey.aws.elasticache.reserved-cache-node/reservation-arn :portkey.aws.elasticache.reserved-cache-node/reserved-cache-node-id :portkey.aws.elasticache.reserved-cache-node/duration :portkey.aws.elasticache.reserved-cache-node/usage-price :portkey.aws.elasticache.reserved-cache-node/product-description :portkey.aws.elasticache.reserved-cache-node/state :portkey.aws.elasticache.reserved-cache-node/reserved-cache-nodes-offering-id :portkey.aws.elasticache.reserved-cache-node/recurring-charges :portkey.aws.elasticache.reserved-cache-node/offering-type]))

(clojure.spec.alpha/def :portkey.aws.elasticache.allowed-node-type-modifications-message/scale-up-modifications (clojure.spec.alpha/and :portkey.aws.elasticache/node-type-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/allowed-node-type-modifications-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.allowed-node-type-modifications-message/scale-up-modifications]))

(clojure.spec.alpha/def :portkey.aws.elasticache.purchase-reserved-cache-nodes-offering-message/reserved-cache-nodes-offering-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.purchase-reserved-cache-nodes-offering-message/reserved-cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.purchase-reserved-cache-nodes-offering-message/cache-node-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache/purchase-reserved-cache-nodes-offering-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.purchase-reserved-cache-nodes-offering-message/reserved-cache-nodes-offering-id] :opt-un [:portkey.aws.elasticache.purchase-reserved-cache-nodes-offering-message/reserved-cache-node-id :portkey.aws.elasticache.purchase-reserved-cache-nodes-offering-message/cache-node-count]))

(clojure.spec.alpha/def :portkey.aws.elasticache/revoke-cache-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-security-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-subnet-group/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-subnet-group/cache-subnet-group-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-subnet-group/vpc-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-subnet-group/subnets (clojure.spec.alpha/and :portkey.aws.elasticache/subnet-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-subnet-group/cache-subnet-group-name :portkey.aws.elasticache.cache-subnet-group/cache-subnet-group-description :portkey.aws.elasticache.cache-subnet-group/vpc-id :portkey.aws.elasticache.cache-subnet-group/subnets]))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-list-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-list-message/snapshots (clojure.spec.alpha/and :portkey.aws.elasticache/snapshot-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-snapshots-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-snapshots-list-message/marker :portkey.aws.elasticache.describe-snapshots-list-message/snapshots]))

(clojure.spec.alpha/def :portkey.aws.elasticache/resharding-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/resharding-configuration))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/security-group-ids (clojure.spec.alpha/and :portkey.aws.elasticache/security-group-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/auto-minor-version-upgrade (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/num-cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/notification-topic-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/notification-topic-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/apply-immediately (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/cache-node-ids-to-remove (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/cache-security-group-names (clojure.spec.alpha/and :portkey.aws.elasticache/cache-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-cluster-message/new-availability-zones (clojure.spec.alpha/and :portkey.aws.elasticache/preferred-availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/modify-cache-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.modify-cache-cluster-message/cache-cluster-id] :opt-un [:portkey.aws.elasticache.modify-cache-cluster-message/cache-node-type :portkey.aws.elasticache/az-mode :portkey.aws.elasticache.modify-cache-cluster-message/security-group-ids :portkey.aws.elasticache.modify-cache-cluster-message/preferred-maintenance-window :portkey.aws.elasticache.modify-cache-cluster-message/auto-minor-version-upgrade :portkey.aws.elasticache.modify-cache-cluster-message/num-cache-nodes :portkey.aws.elasticache.modify-cache-cluster-message/engine-version :portkey.aws.elasticache.modify-cache-cluster-message/notification-topic-status :portkey.aws.elasticache.modify-cache-cluster-message/notification-topic-arn :portkey.aws.elasticache.modify-cache-cluster-message/snapshot-window :portkey.aws.elasticache.modify-cache-cluster-message/cache-parameter-group-name :portkey.aws.elasticache.modify-cache-cluster-message/snapshot-retention-limit :portkey.aws.elasticache.modify-cache-cluster-message/apply-immediately :portkey.aws.elasticache.modify-cache-cluster-message/cache-node-ids-to-remove :portkey.aws.elasticache.modify-cache-cluster-message/cache-security-group-names :portkey.aws.elasticache.modify-cache-cluster-message/new-availability-zones]))

(clojure.spec.alpha/def :portkey.aws.elasticache/key-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/replication-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-security-group-message/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-security-group-message/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.create-cache-security-group-message/cache-security-group-name :portkey.aws.elasticache.create-cache-security-group-message/description] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-details/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-details/parameters (clojure.spec.alpha/and :portkey.aws.elasticache/parameters-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-details/cache-node-type-specific-parameters (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-type-specific-parameters-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-parameter-group-details/marker :portkey.aws.elasticache.cache-parameter-group-details/parameters :portkey.aws.elasticache.cache-parameter-group-details/cache-node-type-specific-parameters]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-group-member-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/node-group-member))

(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/security-group-ids (clojure.spec.alpha/and :portkey.aws.elasticache/security-group-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/auto-minor-version-upgrade (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/primary-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/notification-topic-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/notification-topic-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/snapshotting-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/apply-immediately (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/automatic-failover-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/replication-group-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-message/cache-security-group-names (clojure.spec.alpha/and :portkey.aws.elasticache/cache-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/modify-replication-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.modify-replication-group-message/replication-group-id] :opt-un [:portkey.aws.elasticache.modify-replication-group-message/cache-node-type :portkey.aws.elasticache.modify-replication-group-message/security-group-ids :portkey.aws.elasticache.modify-replication-group-message/preferred-maintenance-window :portkey.aws.elasticache.modify-replication-group-message/auto-minor-version-upgrade :portkey.aws.elasticache.modify-replication-group-message/primary-cluster-id :portkey.aws.elasticache.modify-replication-group-message/engine-version :portkey.aws.elasticache.modify-replication-group-message/notification-topic-status :portkey.aws.elasticache.modify-replication-group-message/notification-topic-arn :portkey.aws.elasticache.modify-replication-group-message/snapshot-window :portkey.aws.elasticache.modify-replication-group-message/snapshotting-cluster-id :portkey.aws.elasticache.modify-replication-group-message/cache-parameter-group-name :portkey.aws.elasticache.modify-replication-group-message/snapshot-retention-limit :portkey.aws.elasticache.modify-replication-group-message/apply-immediately :portkey.aws.elasticache.modify-replication-group-message/automatic-failover-enabled :portkey.aws.elasticache.modify-replication-group-message/replication-group-description :portkey.aws.elasticache.modify-replication-group-message/node-group-id :portkey.aws.elasticache.modify-replication-group-message/cache-security-group-names]))

(clojure.spec.alpha/def :portkey.aws.elasticache.increase-replica-count-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.increase-replica-count-message/new-replica-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.increase-replica-count-message/replica-configuration (clojure.spec.alpha/and :portkey.aws.elasticache/replica-configuration-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.increase-replica-count-message/apply-immediately (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache/increase-replica-count-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.increase-replica-count-message/replication-group-id :portkey.aws.elasticache.increase-replica-count-message/apply-immediately] :opt-un [:portkey.aws.elasticache.increase-replica-count-message/new-replica-count :portkey.aws.elasticache.increase-replica-count-message/replica-configuration]))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-vpc-network-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/num-node-groups (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/auth-token (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/snapshot-arns (clojure.spec.alpha/and :portkey.aws.elasticache/snapshot-arns-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/security-group-ids (clojure.spec.alpha/and :portkey.aws.elasticache/security-group-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/auto-minor-version-upgrade (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/replicas-per-node-group (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/tags (clojure.spec.alpha/and :portkey.aws.elasticache/tag-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/preferred-cache-cluster-a-zs (clojure.spec.alpha/and :portkey.aws.elasticache/availability-zones-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/at-rest-encryption-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/transit-encryption-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/primary-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/notification-topic-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/port (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/node-group-configuration (clojure.spec.alpha/and :portkey.aws.elasticache/node-group-configuration-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/automatic-failover-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/num-cache-clusters (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/engine (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/replication-group-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/cache-security-group-names (clojure.spec.alpha/and :portkey.aws.elasticache/cache-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-replication-group-message/snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/create-replication-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.create-replication-group-message/replication-group-id :portkey.aws.elasticache.create-replication-group-message/replication-group-description] :opt-un [:portkey.aws.elasticache.create-replication-group-message/cache-node-type :portkey.aws.elasticache.create-replication-group-message/cache-subnet-group-name :portkey.aws.elasticache.create-replication-group-message/num-node-groups :portkey.aws.elasticache.create-replication-group-message/auth-token :portkey.aws.elasticache.create-replication-group-message/snapshot-arns :portkey.aws.elasticache.create-replication-group-message/security-group-ids :portkey.aws.elasticache.create-replication-group-message/preferred-maintenance-window :portkey.aws.elasticache.create-replication-group-message/auto-minor-version-upgrade :portkey.aws.elasticache.create-replication-group-message/replicas-per-node-group :portkey.aws.elasticache.create-replication-group-message/tags :portkey.aws.elasticache.create-replication-group-message/preferred-cache-cluster-a-zs :portkey.aws.elasticache.create-replication-group-message/at-rest-encryption-enabled :portkey.aws.elasticache.create-replication-group-message/transit-encryption-enabled :portkey.aws.elasticache.create-replication-group-message/primary-cluster-id :portkey.aws.elasticache.create-replication-group-message/engine-version :portkey.aws.elasticache.create-replication-group-message/notification-topic-arn :portkey.aws.elasticache.create-replication-group-message/port :portkey.aws.elasticache.create-replication-group-message/snapshot-window :portkey.aws.elasticache.create-replication-group-message/node-group-configuration :portkey.aws.elasticache.create-replication-group-message/cache-parameter-group-name :portkey.aws.elasticache.create-replication-group-message/snapshot-retention-limit :portkey.aws.elasticache.create-replication-group-message/automatic-failover-enabled :portkey.aws.elasticache.create-replication-group-message/num-cache-clusters :portkey.aws.elasticache.create-replication-group-message/engine :portkey.aws.elasticache.create-replication-group-message/cache-security-group-names :portkey.aws.elasticache.create-replication-group-message/snapshot-name]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-nodes-offering-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/reserved-cache-nodes-offering))

(clojure.spec.alpha/def :portkey.aws.elasticache/availability-zones-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/node-snapshot))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameter-groups-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameter-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-cache-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-cache-parameter-groups-message/cache-parameter-group-name :portkey.aws.elasticache.describe-cache-parameter-groups-message/max-records :portkey.aws.elasticache.describe-cache-parameter-groups-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache/tag-quota-per-resource-exceeded (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-events-message/source-identifier (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-events-message/start-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-events-message/end-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-events-message/duration (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-events-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-events-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-events-message/source-identifier :portkey.aws.elasticache/source-type :portkey.aws.elasticache.describe-events-message/start-time :portkey.aws.elasticache.describe-events-message/end-time :portkey.aws.elasticache.describe-events-message/duration :portkey.aws.elasticache.describe-events-message/max-records :portkey.aws.elasticache.describe-events-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache/authorization-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/snapshot-source (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-snapshots-message/show-node-group-config (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-snapshots-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-snapshots-message/replication-group-id :portkey.aws.elasticache.describe-snapshots-message/cache-cluster-id :portkey.aws.elasticache.describe-snapshots-message/snapshot-name :portkey.aws.elasticache.describe-snapshots-message/snapshot-source :portkey.aws.elasticache.describe-snapshots-message/marker :portkey.aws.elasticache.describe-snapshots-message/max-records :portkey.aws.elasticache.describe-snapshots-message/show-node-group-config]))

(clojure.spec.alpha/def :portkey.aws.elasticache.authorize-cache-security-group-ingress-message/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.authorize-cache-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.authorize-cache-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/authorize-cache-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.authorize-cache-security-group-ingress-message/cache-security-group-name :portkey.aws.elasticache.authorize-cache-security-group-ingress-message/ec-2-security-group-name :portkey.aws.elasticache.authorize-cache-security-group-ingress-message/ec-2-security-group-owner-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot-feature-not-supported-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-cluster-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/event-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/event))

(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/node-group-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/apply-immediately (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/resharding-configuration (clojure.spec.alpha/and :portkey.aws.elasticache/resharding-configuration-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/node-groups-to-remove (clojure.spec.alpha/and :portkey.aws.elasticache/node-groups-to-remove-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/node-groups-to-retain (clojure.spec.alpha/and :portkey.aws.elasticache/node-groups-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/modify-replication-group-shard-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.modify-replication-group-shard-configuration-message/replication-group-id :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/node-group-count :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/apply-immediately] :opt-un [:portkey.aws.elasticache.modify-replication-group-shard-configuration-message/resharding-configuration :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/node-groups-to-remove :portkey.aws.elasticache.modify-replication-group-shard-configuration-message/node-groups-to-retain]))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-replication-groups-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-replication-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-replication-groups-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-replication-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-replication-groups-message/replication-group-id :portkey.aws.elasticache.describe-replication-groups-message/max-records :portkey.aws.elasticache.describe-replication-groups-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache.events-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.events-message/events (clojure.spec.alpha/and :portkey.aws.elasticache/event-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.events-message/marker :portkey.aws.elasticache.events-message/events]))

(clojure.spec.alpha/def :portkey.aws.elasticache.create-snapshot-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-snapshot-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-snapshot-message/snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/create-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.create-snapshot-message/snapshot-name] :opt-un [:portkey.aws.elasticache.create-snapshot-message/replication-group-id :portkey.aws.elasticache.create-snapshot-message/cache-cluster-id]))

(clojure.spec.alpha/def :portkey.aws.elasticache/source-type #{:cacheparametergroup "cache-subnet-group" "cache-parameter-group" "cache-cluster" :replicationgroup "replication-group" "cache-security-group" :cachesubnetgroup :cachecluster :cachesecuritygroup})

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-groups (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-security-group))

(clojure.spec.alpha/def :portkey.aws.elasticache.event/source-identifier (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.event/message (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.event/date (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache/event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.event/source-identifier :portkey.aws.elasticache/source-type :portkey.aws.elasticache.event/message :portkey.aws.elasticache.event/date]))

(clojure.spec.alpha/def :portkey.aws.elasticache.availability-zone/name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/availability-zone (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.availability-zone/name]))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-snapshot-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-node-message/reserved-cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/reserved-cache-node-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-node-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.reserved-cache-node-message/marker :portkey.aws.elasticache.reserved-cache-node-message/reserved-cache-nodes]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-clusters-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-clusters-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-clusters-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-clusters-message/show-cache-node-info (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-clusters-message/show-cache-clusters-not-in-replication-groups (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-cache-clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-cache-clusters-message/cache-cluster-id :portkey.aws.elasticache.describe-cache-clusters-message/max-records :portkey.aws.elasticache.describe-cache-clusters-message/marker :portkey.aws.elasticache.describe-cache-clusters-message/show-cache-node-info :portkey.aws.elasticache.describe-cache-clusters-message/show-cache-clusters-not-in-replication-groups]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-cluster-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-cluster))

(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-node-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/increase-replica-count-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version/engine (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version/cache-parameter-group-family (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version/cache-engine-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version/cache-engine-version-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-engine-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-engine-version/engine :portkey.aws.elasticache.cache-engine-version/engine-version :portkey.aws.elasticache.cache-engine-version/cache-parameter-group-family :portkey.aws.elasticache.cache-engine-version/cache-engine-description :portkey.aws.elasticache.cache-engine-version/cache-engine-version-description]))

(clojure.spec.alpha/def :portkey.aws.elasticache/test-failover-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-node))

(clojure.spec.alpha/def :portkey.aws.elasticache.reboot-cache-cluster-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reboot-cache-cluster-message/cache-node-ids-to-reboot (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/reboot-cache-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.reboot-cache-cluster-message/cache-cluster-id :portkey.aws.elasticache.reboot-cache-cluster-message/cache-node-ids-to-reboot] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/delete-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/snapshot]))

(clojure.spec.alpha/def :portkey.aws.elasticache.node-group/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group/status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group/primary-endpoint (clojure.spec.alpha/and :portkey.aws.elasticache/endpoint))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group/slots (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group/node-group-members (clojure.spec.alpha/and :portkey.aws.elasticache/node-group-member-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/node-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.node-group/node-group-id :portkey.aws.elasticache.node-group/status :portkey.aws.elasticache.node-group/primary-endpoint :portkey.aws.elasticache.node-group/slots :portkey.aws.elasticache.node-group/node-group-members]))

(clojure.spec.alpha/def :portkey.aws.elasticache/service-linked-role-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-subnet-group-message/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-subnet-group-message/cache-subnet-group-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.elasticache/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.create-cache-subnet-group-message/cache-subnet-group-name :portkey.aws.elasticache.create-cache-subnet-group-message/cache-subnet-group-description :portkey.aws.elasticache.create-cache-subnet-group-message/subnet-ids] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.recurring-charge/recurring-charge-amount (clojure.spec.alpha/and :portkey.aws.elasticache/double))
(clojure.spec.alpha/def :portkey.aws.elasticache.recurring-charge/recurring-charge-frequency (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/recurring-charge (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.recurring-charge/recurring-charge-amount :portkey.aws.elasticache.recurring-charge/recurring-charge-frequency]))

(clojure.spec.alpha/def :portkey.aws.elasticache/describe-engine-default-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/engine-defaults]))

(clojure.spec.alpha/def :portkey.aws.elasticache/authorization-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-value/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-value/value (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node-type-specific-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-node-type-specific-value/cache-node-type :portkey.aws.elasticache.cache-node-type-specific-value/value]))

(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot-arns-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/auth-token (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/preferred-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/snapshot-arns (clojure.spec.alpha/and :portkey.aws.elasticache/snapshot-arns-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/security-group-ids (clojure.spec.alpha/and :portkey.aws.elasticache/security-group-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/preferred-availability-zones (clojure.spec.alpha/and :portkey.aws.elasticache/preferred-availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/auto-minor-version-upgrade (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/tags (clojure.spec.alpha/and :portkey.aws.elasticache/tag-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/num-cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/notification-topic-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/port (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/engine (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/cache-security-group-names (clojure.spec.alpha/and :portkey.aws.elasticache/cache-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.create-cache-cluster-message/snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.create-cache-cluster-message/cache-cluster-id] :opt-un [:portkey.aws.elasticache.create-cache-cluster-message/cache-node-type :portkey.aws.elasticache.create-cache-cluster-message/cache-subnet-group-name :portkey.aws.elasticache/az-mode :portkey.aws.elasticache.create-cache-cluster-message/auth-token :portkey.aws.elasticache.create-cache-cluster-message/preferred-availability-zone :portkey.aws.elasticache.create-cache-cluster-message/snapshot-arns :portkey.aws.elasticache.create-cache-cluster-message/security-group-ids :portkey.aws.elasticache.create-cache-cluster-message/preferred-maintenance-window :portkey.aws.elasticache.create-cache-cluster-message/preferred-availability-zones :portkey.aws.elasticache.create-cache-cluster-message/auto-minor-version-upgrade :portkey.aws.elasticache.create-cache-cluster-message/tags :portkey.aws.elasticache.create-cache-cluster-message/num-cache-nodes :portkey.aws.elasticache.create-cache-cluster-message/engine-version :portkey.aws.elasticache.create-cache-cluster-message/notification-topic-arn :portkey.aws.elasticache.create-cache-cluster-message/port :portkey.aws.elasticache.create-cache-cluster-message/snapshot-window :portkey.aws.elasticache.create-cache-cluster-message/replication-group-id :portkey.aws.elasticache.create-cache-cluster-message/cache-parameter-group-name :portkey.aws.elasticache.create-cache-cluster-message/snapshot-retention-limit :portkey.aws.elasticache.create-cache-cluster-message/engine :portkey.aws.elasticache.create-cache-cluster-message/cache-security-group-names :portkey.aws.elasticache.create-cache-cluster-message/snapshot-name]))

(clojure.spec.alpha/def :portkey.aws.elasticache.parameter-name-value/parameter-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter-name-value/parameter-value (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/parameter-name-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.parameter-name-value/parameter-name :portkey.aws.elasticache.parameter-name-value/parameter-value]))

(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reserved-cache-nodes-offering-message/reserved-cache-nodes-offerings (clojure.spec.alpha/and :portkey.aws.elasticache/reserved-cache-nodes-offering-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-nodes-offering-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.reserved-cache-nodes-offering-message/marker :portkey.aws.elasticache.reserved-cache-nodes-offering-message/reserved-cache-nodes-offerings]))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-subnet (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/reboot-cache-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-cluster]))

(clojure.spec.alpha/def :portkey.aws.elasticache/subnet-in-use (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/tag-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/tag))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-security-group-message/marker :portkey.aws.elasticache/cache-security-groups]))

(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-security-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-security-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-cache-security-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/create-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/snapshot]))

(clojure.spec.alpha/def :portkey.aws.elasticache.add-tags-to-resource-message/resource-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.add-tags-to-resource-message/tags (clojure.spec.alpha/and :portkey.aws.elasticache/tag-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/add-tags-to-resource-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.add-tags-to-resource-message/resource-name :portkey.aws.elasticache.add-tags-to-resource-message/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/modify-cache-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-cluster]))

(clojure.spec.alpha/def :portkey.aws.elasticache.delete-cache-parameter-group-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/delete-cache-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.delete-cache-parameter-group-message/cache-parameter-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/replication-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/modify-replication-group-shard-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/delete-cache-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-cluster]))

(clojure.spec.alpha/def :portkey.aws.elasticache/tag-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/tag-list]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node-type-specific-parameters-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-node-type-specific-parameter))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-name-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/delete-replication-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-group-in-use (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-replication-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/remove-replicas-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/create-replication-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster-message/cache-clusters (clojure.spec.alpha/and :portkey.aws.elasticache/cache-cluster-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-cluster-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-cluster-message/marker :portkey.aws.elasticache.cache-cluster-message/cache-clusters]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-groups-message/cache-parameter-groups (clojure.spec.alpha/and :portkey.aws.elasticache/cache-parameter-group-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-parameter-groups-message/marker :portkey.aws.elasticache.cache-parameter-groups-message/cache-parameter-groups]))

(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-configuration/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/allowed-node-group-id))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-configuration/slots (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-configuration/replica-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-configuration/primary-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-group-configuration/replica-availability-zones (clojure.spec.alpha/and :portkey.aws.elasticache/availability-zones-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/node-group-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.node-group-configuration/node-group-id :portkey.aws.elasticache.node-group-configuration/slots :portkey.aws.elasticache.node-group-configuration/replica-count :portkey.aws.elasticache.node-group-configuration/primary-availability-zone :portkey.aws.elasticache.node-group-configuration/replica-availability-zones]))

(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-parameter-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-parameter-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache.ec-2-security-group/status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.ec-2-security-group/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.ec-2-security-group/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/ec-2-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.ec-2-security-group/status :portkey.aws.elasticache.ec-2-security-group/ec-2-security-group-name :portkey.aws.elasticache.ec-2-security-group/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cluster-id-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node-ids-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/automatic-failover-status #{:disabled "enabled" :disabling :enabling "disabling" "enabling" "disabled" :enabled})

(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group-pending-modified-values/primary-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group-pending-modified-values/automatic-failover-status (clojure.spec.alpha/and :portkey.aws.elasticache/pending-automatic-failover-status))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group-pending-modified-values/resharding (clojure.spec.alpha/and :portkey.aws.elasticache/resharding-status))
(clojure.spec.alpha/def :portkey.aws.elasticache/replication-group-pending-modified-values (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.replication-group-pending-modified-values/primary-cluster-id :portkey.aws.elasticache.replication-group-pending-modified-values/automatic-failover-status :portkey.aws.elasticache.replication-group-pending-modified-values/resharding]))

(clojure.spec.alpha/def :portkey.aws.elasticache.remove-tags-from-resource-message/resource-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.remove-tags-from-resource-message/tag-keys (clojure.spec.alpha/and :portkey.aws.elasticache/key-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/remove-tags-from-resource-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.remove-tags-from-resource-message/resource-name :portkey.aws.elasticache.remove-tags-from-resource-message/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/allowed-node-group-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21076__auto__] (clojure.core/<= 1 (clojure.core/count s__21076__auto__))) (clojure.core/fn [s__21077__auto__] (clojure.core/< (clojure.core/count s__21077__auto__) 4)) (clojure.core/fn [s__21078__auto__] (clojure.core/re-matches #"\d+" s__21078__auto__))))

(clojure.spec.alpha/def :portkey.aws.elasticache/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.elasticache/resharding-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/slot-migration]))

(clojure.spec.alpha/def :portkey.aws.elasticache/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/data-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/parameter-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/source (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/minimum-engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/allowed-values (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/is-modifiable (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.parameter/parameter-value (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/change-type :portkey.aws.elasticache.parameter/data-type :portkey.aws.elasticache.parameter/parameter-name :portkey.aws.elasticache.parameter/source :portkey.aws.elasticache.parameter/minimum-engine-version :portkey.aws.elasticache.parameter/allowed-values :portkey.aws.elasticache.parameter/description :portkey.aws.elasticache.parameter/is-modifiable :portkey.aws.elasticache.parameter/parameter-value]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/data-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/parameter-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/source (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/minimum-engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/allowed-values (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/cache-node-type-specific-values (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-type-specific-value-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-node-type-specific-parameter/is-modifiable (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node-type-specific-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/change-type :portkey.aws.elasticache.cache-node-type-specific-parameter/data-type :portkey.aws.elasticache.cache-node-type-specific-parameter/parameter-name :portkey.aws.elasticache.cache-node-type-specific-parameter/source :portkey.aws.elasticache.cache-node-type-specific-parameter/minimum-engine-version :portkey.aws.elasticache.cache-node-type-specific-parameter/allowed-values :portkey.aws.elasticache.cache-node-type-specific-parameter/cache-node-type-specific-values :portkey.aws.elasticache.cache-node-type-specific-parameter/description :portkey.aws.elasticache.cache-node-type-specific-parameter/is-modifiable]))

(clojure.spec.alpha/def :portkey.aws.elasticache.resharding-configuration/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/allowed-node-group-id))
(clojure.spec.alpha/def :portkey.aws.elasticache.resharding-configuration/preferred-availability-zones (clojure.spec.alpha/and :portkey.aws.elasticache/availability-zones-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/resharding-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.resharding-configuration/node-group-id :portkey.aws.elasticache.resharding-configuration/preferred-availability-zones]))

(clojure.spec.alpha/def :portkey.aws.elasticache.delete-cache-cluster-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.delete-cache-cluster-message/final-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/delete-cache-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.delete-cache-cluster-message/cache-cluster-id] :opt-un [:portkey.aws.elasticache.delete-cache-cluster-message/final-snapshot-identifier]))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-security-groups-message/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-security-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-security-groups-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-cache-security-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-cache-security-groups-message/cache-security-group-name :portkey.aws.elasticache.describe-cache-security-groups-message/max-records :portkey.aws.elasticache.describe-cache-security-groups-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-groups-per-replication-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/num-node-groups (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/node-snapshots (clojure.spec.alpha/and :portkey.aws.elasticache/node-snapshot-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/preferred-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/automatic-failover (clojure.spec.alpha/and :portkey.aws.elasticache/automatic-failover-status))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/auto-minor-version-upgrade (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/cache-cluster-create-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/num-cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/snapshot-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/port (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/vpc-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/topic-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/snapshot-source (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/engine (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/replication-group-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.snapshot/snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.snapshot/cache-node-type :portkey.aws.elasticache.snapshot/cache-subnet-group-name :portkey.aws.elasticache.snapshot/num-node-groups :portkey.aws.elasticache.snapshot/node-snapshots :portkey.aws.elasticache.snapshot/preferred-availability-zone :portkey.aws.elasticache.snapshot/automatic-failover :portkey.aws.elasticache.snapshot/preferred-maintenance-window :portkey.aws.elasticache.snapshot/cache-cluster-id :portkey.aws.elasticache.snapshot/auto-minor-version-upgrade :portkey.aws.elasticache.snapshot/cache-cluster-create-time :portkey.aws.elasticache.snapshot/num-cache-nodes :portkey.aws.elasticache.snapshot/snapshot-status :portkey.aws.elasticache.snapshot/engine-version :portkey.aws.elasticache.snapshot/port :portkey.aws.elasticache.snapshot/snapshot-window :portkey.aws.elasticache.snapshot/vpc-id :portkey.aws.elasticache.snapshot/topic-arn :portkey.aws.elasticache.snapshot/snapshot-source :portkey.aws.elasticache.snapshot/replication-group-id :portkey.aws.elasticache.snapshot/cache-parameter-group-name :portkey.aws.elasticache.snapshot/snapshot-retention-limit :portkey.aws.elasticache.snapshot/engine :portkey.aws.elasticache.snapshot/replication-group-description :portkey.aws.elasticache.snapshot/snapshot-name]))

(clojure.spec.alpha/def :portkey.aws.elasticache/t-stamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.elasticache.invalid-parameter-combination-exception/message (clojure.spec.alpha/and :portkey.aws.elasticache/aws-query-error-message))
(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-parameter-combination-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.invalid-parameter-combination-exception/message]))

(clojure.spec.alpha/def :portkey.aws.elasticache.delete-snapshot-message/snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/delete-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.delete-snapshot-message/snapshot-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.list-allowed-node-type-modifications-message/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.list-allowed-node-type-modifications-message/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/list-allowed-node-type-modifications-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.list-allowed-node-type-modifications-message/cache-cluster-id :portkey.aws.elasticache.list-allowed-node-type-modifications-message/replication-group-id]))

(clojure.spec.alpha/def :portkey.aws.elasticache/recurring-charge-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/recurring-charge))

(clojure.spec.alpha/def :portkey.aws.elasticache.delete-cache-security-group-message/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/delete-cache-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.delete-cache-security-group-message/cache-security-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.delete-cache-subnet-group-message/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/delete-cache-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.delete-cache-subnet-group-message/cache-subnet-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-cache-parameter-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-name-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-name-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-parameter-group-name-message/cache-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-parameter-group (clojure.spec.alpha/and :portkey.aws.elasticache/cache-parameter-group-status))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/preferred-availability-zone (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/security-groups (clojure.spec.alpha/and :portkey.aws.elasticache/security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/configuration-endpoint (clojure.spec.alpha/and :portkey.aws.elasticache/endpoint))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/auth-token-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/auto-minor-version-upgrade (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-cluster-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-security-groups (clojure.spec.alpha/and :portkey.aws.elasticache/cache-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/at-rest-encryption-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-cluster-create-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/num-cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/transit-encryption-enabled (clojure.spec.alpha/and :portkey.aws.elasticache/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/client-download-landing-page (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/snapshot-window (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/replication-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/snapshot-retention-limit (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/engine (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-cluster/cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-cluster (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-cluster/cache-node-type :portkey.aws.elasticache.cache-cluster/cache-subnet-group-name :portkey.aws.elasticache.cache-cluster/cache-parameter-group :portkey.aws.elasticache.cache-cluster/preferred-availability-zone :portkey.aws.elasticache.cache-cluster/preferred-maintenance-window :portkey.aws.elasticache.cache-cluster/security-groups :portkey.aws.elasticache.cache-cluster/configuration-endpoint :portkey.aws.elasticache.cache-cluster/auth-token-enabled :portkey.aws.elasticache.cache-cluster/cache-cluster-id :portkey.aws.elasticache.cache-cluster/auto-minor-version-upgrade :portkey.aws.elasticache.cache-cluster/cache-cluster-status :portkey.aws.elasticache.cache-cluster/cache-security-groups :portkey.aws.elasticache.cache-cluster/at-rest-encryption-enabled :portkey.aws.elasticache.cache-cluster/cache-cluster-create-time :portkey.aws.elasticache.cache-cluster/num-cache-nodes :portkey.aws.elasticache.cache-cluster/transit-encryption-enabled :portkey.aws.elasticache.cache-cluster/engine-version :portkey.aws.elasticache.cache-cluster/client-download-landing-page :portkey.aws.elasticache.cache-cluster/snapshot-window :portkey.aws.elasticache.cache-cluster/replication-group-id :portkey.aws.elasticache.cache-cluster/snapshot-retention-limit :portkey.aws.elasticache.cache-cluster/engine :portkey.aws.elasticache/notification-configuration :portkey.aws.elasticache.cache-cluster/cache-nodes :portkey.aws.elasticache/pending-modified-values]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group-membership/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-security-group-membership/cache-security-group-name :portkey.aws.elasticache.cache-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.elasticache/preferred-availability-zone-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/create-cache-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-cluster]))

(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-nodes-offering-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.endpoint/address (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.endpoint/port (clojure.spec.alpha/and :portkey.aws.elasticache/integer))
(clojure.spec.alpha/def :portkey.aws.elasticache/endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.endpoint/address :portkey.aws.elasticache.endpoint/port]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-cluster-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/copy-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/snapshot]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-groups-to-retain-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/allowed-node-group-id))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-quota-for-cluster-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.replication-group-message/replication-groups (clojure.spec.alpha/and :portkey.aws.elasticache/replication-group-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/replication-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.replication-group-message/marker :portkey.aws.elasticache.replication-group-message/replication-groups]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-parameter-group))

(clojure.spec.alpha/def :portkey.aws.elasticache.security-group-membership/security-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.security-group-membership/status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.security-group-membership/security-group-id :portkey.aws.elasticache.security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-subnet-groups-message/cache-subnet-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-subnet-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-cache-subnet-groups-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-cache-subnet-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-cache-subnet-groups-message/cache-subnet-group-name :portkey.aws.elasticache.describe-cache-subnet-groups-message/max-records :portkey.aws.elasticache.describe-cache-subnet-groups-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache.node-snapshot/cache-cluster-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-snapshot/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-snapshot/cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-snapshot/cache-size (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-snapshot/cache-node-create-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache.node-snapshot/snapshot-create-time (clojure.spec.alpha/and :portkey.aws.elasticache/t-stamp))
(clojure.spec.alpha/def :portkey.aws.elasticache/node-snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.node-snapshot/cache-cluster-id :portkey.aws.elasticache.node-snapshot/node-group-id :portkey.aws.elasticache.node-snapshot/cache-node-id :portkey.aws.elasticache/node-group-configuration :portkey.aws.elasticache.node-snapshot/cache-size :portkey.aws.elasticache.node-snapshot/cache-node-create-time :portkey.aws.elasticache.node-snapshot/snapshot-create-time]))

(clojure.spec.alpha/def :portkey.aws.elasticache/reserved-cache-node-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/reserved-cache-node))

(clojure.spec.alpha/def :portkey.aws.elasticache.tag/key (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.tag/value (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.tag/key :portkey.aws.elasticache.tag/value]))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/reserved-cache-nodes-offering-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/duration (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/product-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/offering-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-reserved-cache-nodes-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/reserved-cache-nodes-offering-id :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/cache-node-type :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/duration :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/product-description :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/offering-type :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/max-records :portkey.aws.elasticache.describe-reserved-cache-nodes-offerings-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache/boolean-optional clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-node-type-specific-value-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-node-type-specific-value))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.elasticache.list-tags-for-resource-message/resource-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/list-tags-for-resource-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.list-tags-for-resource-message/resource-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-group-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/node-group))

(clojure.spec.alpha/def :portkey.aws.elasticache/tag-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.notification-configuration/topic-arn (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.notification-configuration/topic-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/notification-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.notification-configuration/topic-arn :portkey.aws.elasticache.notification-configuration/topic-status]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-status/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-parameter-group-status/cache-node-ids-to-reboot (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-parameter-group-status/cache-parameter-group-name :portkey.aws.elasticache.cache-parameter-group-status/parameter-apply-status :portkey.aws.elasticache.cache-parameter-group-status/cache-node-ids-to-reboot]))

(clojure.spec.alpha/def :portkey.aws.elasticache.revoke-cache-security-group-ingress-message/cache-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.revoke-cache-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.revoke-cache-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/revoke-cache-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.revoke-cache-security-group-ingress-message/cache-security-group-name :portkey.aws.elasticache.revoke-cache-security-group-ingress-message/ec-2-security-group-name :portkey.aws.elasticache.revoke-cache-security-group-ingress-message/ec-2-security-group-owner-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.reset-cache-parameter-group-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.reset-cache-parameter-group-message/reset-all-parameters (clojure.spec.alpha/and :portkey.aws.elasticache/boolean))
(clojure.spec.alpha/def :portkey.aws.elasticache.reset-cache-parameter-group-message/parameter-name-values (clojure.spec.alpha/and :portkey.aws.elasticache/parameter-name-value-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/reset-cache-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.reset-cache-parameter-group-message/cache-parameter-group-name] :opt-un [:portkey.aws.elasticache.reset-cache-parameter-group-message/reset-all-parameters :portkey.aws.elasticache.reset-cache-parameter-group-message/parameter-name-values]))

(clojure.spec.alpha/def :portkey.aws.elasticache/aws-query-error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.elasticache.engine-defaults/cache-parameter-group-family (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.engine-defaults/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.engine-defaults/parameters (clojure.spec.alpha/and :portkey.aws.elasticache/parameters-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.engine-defaults/cache-node-type-specific-parameters (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-type-specific-parameters-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/engine-defaults (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.engine-defaults/cache-parameter-group-family :portkey.aws.elasticache.engine-defaults/marker :portkey.aws.elasticache.engine-defaults/parameters :portkey.aws.elasticache.engine-defaults/cache-node-type-specific-parameters]))

(clojure.spec.alpha/def :portkey.aws.elasticache.configure-shard/node-group-id (clojure.spec.alpha/and :portkey.aws.elasticache/allowed-node-group-id))
(clojure.spec.alpha/def :portkey.aws.elasticache.configure-shard/new-replica-count (clojure.spec.alpha/and :portkey.aws.elasticache/integer))
(clojure.spec.alpha/def :portkey.aws.elasticache.configure-shard/preferred-availability-zones (clojure.spec.alpha/and :portkey.aws.elasticache/preferred-availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/configure-shard (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.configure-shard/node-group-id :portkey.aws.elasticache.configure-shard/new-replica-count] :opt-un [:portkey.aws.elasticache.configure-shard/preferred-availability-zones]))

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.cache-engine-version-message/cache-engine-versions (clojure.spec.alpha/and :portkey.aws.elasticache/cache-engine-version-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-engine-version-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-engine-version-message/marker :portkey.aws.elasticache.cache-engine-version-message/cache-engine-versions]))

(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-parameter-group-message/cache-parameter-group-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.modify-cache-parameter-group-message/parameter-name-values (clojure.spec.alpha/and :portkey.aws.elasticache/parameter-name-value-list))
(clojure.spec.alpha/def :portkey.aws.elasticache/modify-cache-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.modify-cache-parameter-group-message/cache-parameter-group-name :portkey.aws.elasticache.modify-cache-parameter-group-message/parameter-name-values] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/reserved-cache-node-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/reserved-cache-nodes-offering-id (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/duration (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/product-description (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/offering-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/max-records (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.describe-reserved-cache-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/describe-reserved-cache-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.describe-reserved-cache-nodes-message/reserved-cache-node-id :portkey.aws.elasticache.describe-reserved-cache-nodes-message/reserved-cache-nodes-offering-id :portkey.aws.elasticache.describe-reserved-cache-nodes-message/cache-node-type :portkey.aws.elasticache.describe-reserved-cache-nodes-message/duration :portkey.aws.elasticache.describe-reserved-cache-nodes-message/product-description :portkey.aws.elasticache.describe-reserved-cache-nodes-message/offering-type :portkey.aws.elasticache.describe-reserved-cache-nodes-message/max-records :portkey.aws.elasticache.describe-reserved-cache-nodes-message/marker]))

(clojure.spec.alpha/def :portkey.aws.elasticache/integer-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.elasticache.cache-subnet-group-message/marker (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.cache-subnet-group-message/marker :portkey.aws.elasticache/cache-subnet-groups]))

(clojure.spec.alpha/def :portkey.aws.elasticache.invalid-parameter-value-exception/message (clojure.spec.alpha/and :portkey.aws.elasticache/aws-query-error-message))
(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-parameter-value-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.invalid-parameter-value-exception/message]))

(clojure.spec.alpha/def :portkey.aws.elasticache/no-operation-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache.pending-modified-values/num-cache-nodes (clojure.spec.alpha/and :portkey.aws.elasticache/integer-optional))
(clojure.spec.alpha/def :portkey.aws.elasticache.pending-modified-values/cache-node-ids-to-remove (clojure.spec.alpha/and :portkey.aws.elasticache/cache-node-ids-list))
(clojure.spec.alpha/def :portkey.aws.elasticache.pending-modified-values/engine-version (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.pending-modified-values/cache-node-type (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/pending-modified-values (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache.pending-modified-values/num-cache-nodes :portkey.aws.elasticache.pending-modified-values/cache-node-ids-to-remove :portkey.aws.elasticache.pending-modified-values/engine-version :portkey.aws.elasticache.pending-modified-values/cache-node-type]))

(clojure.spec.alpha/def :portkey.aws.elasticache.copy-snapshot-message/source-snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.copy-snapshot-message/target-snapshot-name (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache.copy-snapshot-message/target-bucket (clojure.spec.alpha/and :portkey.aws.elasticache/string))
(clojure.spec.alpha/def :portkey.aws.elasticache/copy-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.elasticache.copy-snapshot-message/source-snapshot-name :portkey.aws.elasticache.copy-snapshot-message/target-snapshot-name] :opt-un [:portkey.aws.elasticache.copy-snapshot-message/target-bucket]))

(clojure.spec.alpha/def :portkey.aws.elasticache/node-type-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/string))

(clojure.spec.alpha/def :portkey.aws.elasticache/api-call-rate-for-customer-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/subnet-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/subnet))

(clojure.spec.alpha/def :portkey.aws.elasticache/authorize-cache-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/cache-security-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/modify-replication-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.elasticache/replication-group]))

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-subnet-groups (clojure.spec.alpha/coll-of :portkey.aws.elasticache/cache-subnet-group))

(clojure.spec.alpha/def :portkey.aws.elasticache/invalid-cache-cluster-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/snapshot-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.elasticache/replica-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.elasticache/configure-shard))

(clojure.spec.alpha/def :portkey.aws.elasticache/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.elasticache/cache-parameter-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.core/defn describe-cache-parameter-groups "Returns a list of cache parameter group descriptions. If a cache parameter group\nname is specified, the list contains only the descriptions for that group." ([] (describe-cache-parameter-groups {})) ([describe-cache-parameter-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cache-parameter-groups-message describe-cache-parameter-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-parameter-groups-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-cache-parameter-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeCacheParameterGroupsResult", :http.request.configuration/action "DescribeCacheParameterGroups", :http.request.configuration/output-deser-fn response-cache-parameter-groups-message, :http.request.spec/error-spec {"CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-cache-parameter-groups :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-cache-parameter-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-parameter-groups-message))

(clojure.core/defn modify-replication-group-shard-configuration "Modifies a replication group's shards (node groups) by allowing you to add\nshards, remove shards, or rebalance the keyspaces among exisiting shards." ([modify-replication-group-shard-configuration-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-replication-group-shard-configuration-message modify-replication-group-shard-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/modify-replication-group-shard-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/modify-replication-group-shard-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyReplicationGroupShardConfigurationResult", :http.request.configuration/action "ModifyReplicationGroupShardConfiguration", :http.request.configuration/output-deser-fn response-modify-replication-group-shard-configuration-result, :http.request.spec/error-spec {"ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "NodeGroupsPerReplicationGroupQuotaExceededFault" :portkey.aws.elasticache/node-groups-per-replication-group-quota-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-replication-group-shard-configuration :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/modify-replication-group-shard-configuration-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/modify-replication-group-shard-configuration-result))

(clojure.core/defn describe-cache-security-groups "Returns a list of cache security group descriptions. If a cache security group\nname is specified, the list contains only the description of that group." ([] (describe-cache-security-groups {})) ([describe-cache-security-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cache-security-groups-message describe-cache-security-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-security-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-cache-security-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeCacheSecurityGroupsResult", :http.request.configuration/action "DescribeCacheSecurityGroups", :http.request.configuration/output-deser-fn response-cache-security-group-message, :http.request.spec/error-spec {"CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-cache-security-groups :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-cache-security-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-security-group-message))

(clojure.core/defn modify-cache-parameter-group "Modifies the parameters of a cache parameter group. You can modify up to 20\nparameters in a single request by submitting a list parameter name and value\npairs." ([modify-cache-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cache-parameter-group-message modify-cache-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/modify-cache-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyCacheParameterGroupResult", :http.request.configuration/action "ModifyCacheParameterGroup", :http.request.configuration/output-deser-fn response-cache-parameter-group-name-message, :http.request.spec/error-spec {"CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "InvalidCacheParameterGroupStateFault" :portkey.aws.elasticache/invalid-cache-parameter-group-state-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef modify-cache-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/modify-cache-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-parameter-group-name-message))

(clojure.core/defn test-failover "Represents the input of a TestFailover operation which test automatic failover\non a specified node group (called shard in the console) in a replication group\n(called cluster in the console).\n Note the following\n * A customer can use this operation to test automatic failover on up to 5\nshards (called node groups in the ElastiCache API and AWS CLI) in any rolling\n24-hour period.\n * If calling this operation on shards in different clusters (called replication\ngroups in the API and CLI), the calls can be made concurrently.\n * If calling this operation multiple times on different shards in the same\nRedis (cluster mode enabled) replication group, the first node replacement must\ncomplete before a subsequent call can be made.\n * To determine whether the node replacement is complete you can check Events\nusing the Amazon ElastiCache console, the AWS CLI, or the ElastiCache API. Look\nfor the following automatic failover related events, listed here in order of\noccurrance:\n * Replication group message: Test Failover API called for node group\n<node-group-id>\n * Cache cluster message: Failover from master node <primary-node-id> to replica\nnode <node-id> completed\n * Replication group message: Failover from master node <primary-node-id> to\nreplica node <node-id> completed\n * Cache cluster message: Recovering cache nodes <node-id>\n * Cache cluster message: Finished recovery for cache nodes <node-id>\n For more information see:\n * Viewing ElastiCache Events\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/ECEvents.Viewing.html)\nin the ElastiCache User Guide\n * DescribeEvents\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_DescribeEvents.html)\nin the ElastiCache API Reference\n Also see, Testing Multi-AZ with Automatic Failover\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/AutoFailover.html#auto-failover-test)\nin the ElastiCache User Guide." ([test-failover-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-test-failover-message test-failover-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/test-failover-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/test-failover-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "TestFailoverResult", :http.request.configuration/action "TestFailover", :http.request.configuration/output-deser-fn response-test-failover-result, :http.request.spec/error-spec {"APICallRateForCustomerExceededFault" :portkey.aws.elasticache/api-call-rate-for-customer-exceeded-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "NodeGroupNotFoundFault" :portkey.aws.elasticache/node-group-not-found-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "TestFailoverNotAvailableFault" :portkey.aws.elasticache/test-failover-not-available-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef test-failover :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/test-failover-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/test-failover-result))

(clojure.core/defn delete-cache-parameter-group "Deletes the specified cache parameter group. You cannot delete a cache parameter\ngroup if it is associated with any cache clusters." ([delete-cache-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cache-parameter-group-message delete-cache-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/delete-cache-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCacheParameterGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidCacheParameterGroupStateFault" :portkey.aws.elasticache/invalid-cache-parameter-group-state-fault, "CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef delete-cache-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/delete-cache-parameter-group-message) :ret clojure.core/true?)

(clojure.core/defn delete-replication-group "Deletes an existing replication group. By default, this operation deletes the\nentire replication group, including the primary/primaries and all of the read\nreplicas. If the replication group has only one primary, you can optionally\ndelete only the read replicas, while retaining the primary by setting\nRetainPrimaryCluster=true.\n When you receive a successful response from this operation, Amazon ElastiCache\nimmediately begins deleting the selected resources; you cannot cancel or revert\nthis operation.\n This operation is valid for Redis only." ([delete-replication-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-replication-group-message delete-replication-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/delete-replication-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/delete-replication-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteReplicationGroupResult", :http.request.configuration/action "DeleteReplicationGroup", :http.request.configuration/output-deser-fn response-delete-replication-group-result, :http.request.spec/error-spec {"ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "SnapshotAlreadyExistsFault" :portkey.aws.elasticache/snapshot-already-exists-fault, "SnapshotFeatureNotSupportedFault" :portkey.aws.elasticache/snapshot-feature-not-supported-fault, "SnapshotQuotaExceededFault" :portkey.aws.elasticache/snapshot-quota-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef delete-replication-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/delete-replication-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/delete-replication-group-result))

(clojure.core/defn purchase-reserved-cache-nodes-offering "Allows you to purchase a reserved cache node offering." ([purchase-reserved-cache-nodes-offering-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-purchase-reserved-cache-nodes-offering-message purchase-reserved-cache-nodes-offering-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/purchase-reserved-cache-nodes-offering-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/purchase-reserved-cache-nodes-offering-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "PurchaseReservedCacheNodesOfferingResult", :http.request.configuration/action "PurchaseReservedCacheNodesOffering", :http.request.configuration/output-deser-fn response-purchase-reserved-cache-nodes-offering-result, :http.request.spec/error-spec {"ReservedCacheNodesOfferingNotFoundFault" :portkey.aws.elasticache/reserved-cache-nodes-offering-not-found-fault, "ReservedCacheNodeAlreadyExistsFault" :portkey.aws.elasticache/reserved-cache-node-already-exists-fault, "ReservedCacheNodeQuotaExceededFault" :portkey.aws.elasticache/reserved-cache-node-quota-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef purchase-reserved-cache-nodes-offering :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/purchase-reserved-cache-nodes-offering-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/purchase-reserved-cache-nodes-offering-result))

(clojure.core/defn describe-events "Returns events related to clusters, cache security groups, and cache parameter\ngroups. You can obtain events specific to a particular cluster, cache security\ngroup, or cache parameter group by providing the name as a parameter.\n By default, only the events occurring within the last hour are returned;\nhowever, you can retrieve up to 14 days' worth of events if necessary." ([] (describe-events {})) ([describe-events-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-events-message describe-events-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/events-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-events-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventsResult", :http.request.configuration/action "DescribeEvents", :http.request.configuration/output-deser-fn response-events-message, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-events :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-events-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/events-message))

(clojure.core/defn create-snapshot "Creates a copy of an entire cluster or replication group at a specific moment in\ntime.\n This operation is valid for Redis only." ([create-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-snapshot-message create-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/create-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/create-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateSnapshotResult", :http.request.configuration/action "CreateSnapshot", :http.request.configuration/output-deser-fn response-create-snapshot-result, :http.request.spec/error-spec {"SnapshotQuotaExceededFault" :portkey.aws.elasticache/snapshot-quota-exceeded-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "SnapshotFeatureNotSupportedFault" :portkey.aws.elasticache/snapshot-feature-not-supported-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault, "SnapshotAlreadyExistsFault" :portkey.aws.elasticache/snapshot-already-exists-fault}})))))
(clojure.spec.alpha/fdef create-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/create-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/create-snapshot-result))

(clojure.core/defn increase-replica-count "Dynamically increases the number of replics in a Redis (cluster mode disabled)\nreplication group or the number of replica nodes in one or more node groups\n(shards) of a Redis (cluster mode enabled) replication group. This operation is\nperformed with no cluster down time." ([increase-replica-count-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-increase-replica-count-message increase-replica-count-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/increase-replica-count-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/increase-replica-count-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "IncreaseReplicaCountResult", :http.request.configuration/action "IncreaseReplicaCount", :http.request.configuration/output-deser-fn response-increase-replica-count-result, :http.request.spec/error-spec {"ClusterQuotaForCustomerExceededFault" :portkey.aws.elasticache/cluster-quota-for-customer-exceeded-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "NodeGroupsPerReplicationGroupQuotaExceededFault" :portkey.aws.elasticache/node-groups-per-replication-group-quota-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "NoOperationFault" :portkey.aws.elasticache/no-operation-fault, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault}})))))
(clojure.spec.alpha/fdef increase-replica-count :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/increase-replica-count-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/increase-replica-count-result))

(clojure.core/defn describe-cache-engine-versions "Returns a list of the available cache engines and their versions." ([] (describe-cache-engine-versions {})) ([describe-cache-engine-versions-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cache-engine-versions-message describe-cache-engine-versions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-engine-version-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-cache-engine-versions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeCacheEngineVersionsResult", :http.request.configuration/action "DescribeCacheEngineVersions", :http.request.configuration/output-deser-fn response-cache-engine-version-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-cache-engine-versions :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-cache-engine-versions-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-engine-version-message))

(clojure.core/defn reset-cache-parameter-group "Modifies the parameters of a cache parameter group to the engine or system\ndefault value. You can reset specific parameters by submitting a list of\nparameter names. To reset the entire cache parameter group, specify the\nResetAllParameters and CacheParameterGroupName parameters." ([reset-cache-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-cache-parameter-group-message reset-cache-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/reset-cache-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ResetCacheParameterGroupResult", :http.request.configuration/action "ResetCacheParameterGroup", :http.request.configuration/output-deser-fn response-cache-parameter-group-name-message, :http.request.spec/error-spec {"InvalidCacheParameterGroupStateFault" :portkey.aws.elasticache/invalid-cache-parameter-group-state-fault, "CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef reset-cache-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/reset-cache-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-parameter-group-name-message))

(clojure.core/defn modify-replication-group "Modifies the settings for a replication group.\n For Redis (cluster mode enabled) clusters, this operation cannot be used to\nchange a cluster's node type or engine version. For more information, see:\n * Scaling for Amazon ElastiCache for Redis—Redis (cluster mode enabled)\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/scaling-redis-cluster-mode-enabled.html)\nin the ElastiCache User Guide\n * ModifyReplicationGroupShardConfiguration\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_ModifyReplicationGroupShardConfiguration.html)\nin the ElastiCache API Reference\n This operation is valid for Redis only." ([modify-replication-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-replication-group-message modify-replication-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/modify-replication-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/modify-replication-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyReplicationGroupResult", :http.request.configuration/action "ModifyReplicationGroup", :http.request.configuration/output-deser-fn response-modify-replication-group-result, :http.request.spec/error-spec {"CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "InvalidCacheSecurityGroupStateFault" :portkey.aws.elasticache/invalid-cache-security-group-state-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "NodeQuotaForClusterExceededFault" :portkey.aws.elasticache/node-quota-for-cluster-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-replication-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/modify-replication-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/modify-replication-group-result))

(clojure.core/defn describe-replication-groups "Returns information about a particular replication group. If no identifier is\nspecified, DescribeReplicationGroups returns information about all replication\ngroups.\n This operation is valid for Redis only." ([] (describe-replication-groups {})) ([describe-replication-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-replication-groups-message describe-replication-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/replication-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-replication-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReplicationGroupsResult", :http.request.configuration/action "DescribeReplicationGroups", :http.request.configuration/output-deser-fn response-replication-group-message, :http.request.spec/error-spec {"ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-replication-groups :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-replication-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/replication-group-message))

(clojure.core/defn reboot-cache-cluster "Reboots some, or all, of the cache nodes within a provisioned cluster. This\noperation applies any modified cache parameter groups to the cluster. The reboot\noperation takes place as soon as possible, and results in a momentary outage to\nthe cluster. During the reboot, the cluster status is set to REBOOTING.\n The reboot causes the contents of the cache (for each cache node being\nrebooted) to be lost.\n When the reboot is complete, a cluster event is created.\n Rebooting a cluster is currently supported on Memcached and Redis (cluster mode\ndisabled) clusters. Rebooting is not supported on Redis (cluster mode enabled)\nclusters.\n If you make changes to parameters that require a Redis (cluster mode enabled)\ncluster reboot for the changes to be applied, see Rebooting a Cluster\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Clusters.Rebooting.html)\nfor an alternate process." ([reboot-cache-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-reboot-cache-cluster-message reboot-cache-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/reboot-cache-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/reboot-cache-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RebootCacheClusterResult", :http.request.configuration/action "RebootCacheCluster", :http.request.configuration/output-deser-fn response-reboot-cache-cluster-result, :http.request.spec/error-spec {"InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault, "CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef reboot-cache-cluster :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/reboot-cache-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/reboot-cache-cluster-result))

(clojure.core/defn list-tags-for-resource "Lists all cost allocation tags currently on the named resource. A cost\nallocation tag is a key-value pair where the key is case-sensitive and the value\nis optional. You can use cost allocation tags to categorize and track your AWS\ncosts.\n If the cluster is not in the available state, ListTagsForResource returns an\nerror.\n You can have a maximum of 50 cost allocation tags on an ElastiCache resource.\nFor more information, see Monitoring Costs with Tags\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Tagging.html)." ([list-tags-for-resource-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-tags-for-resource-message list-tags-for-resource-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/tag-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/list-tags-for-resource-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ListTagsForResourceResult", :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-tag-list-message, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "SnapshotNotFoundFault" :portkey.aws.elasticache/snapshot-not-found-fault, "InvalidARNFault" :portkey.aws.elasticache/invalid-arn-fault}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/list-tags-for-resource-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/tag-list-message))

(clojure.core/defn describe-engine-default-parameters "Returns the default engine and system parameter information for the specified\ncache engine." ([describe-engine-default-parameters-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-engine-default-parameters-message describe-engine-default-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/describe-engine-default-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-engine-default-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEngineDefaultParametersResult", :http.request.configuration/action "DescribeEngineDefaultParameters", :http.request.configuration/output-deser-fn response-describe-engine-default-parameters-result, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-engine-default-parameters :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/describe-engine-default-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/describe-engine-default-parameters-result))

(clojure.core/defn describe-cache-clusters "Returns information about all provisioned clusters if no cluster identifier is\nspecified, or about a specific cache cluster if a cluster identifier is\nsupplied.\n By default, abbreviated information about the clusters is returned. You can use\nthe optional ShowCacheNodeInfo flag to retrieve detailed information about the\ncache nodes associated with the clusters. These details include the DNS address\nand port for the cache node endpoint.\n If the cluster is in the creating state, only cluster-level information is\ndisplayed until all of the nodes are successfully provisioned.\n If the cluster is in the deleting state, only cluster-level information is\ndisplayed.\n If cache nodes are currently being added to the cluster, node endpoint\ninformation and creation time for the additional nodes are not displayed until\nthey are completely provisioned. When the cluster state is available, the\ncluster is ready for use.\n If cache nodes are currently being removed from the cluster, no endpoint\ninformation for the removed nodes is displayed." ([] (describe-cache-clusters {})) ([describe-cache-clusters-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cache-clusters-message describe-cache-clusters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-cluster-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-cache-clusters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeCacheClustersResult", :http.request.configuration/action "DescribeCacheClusters", :http.request.configuration/output-deser-fn response-cache-cluster-message, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-cache-clusters :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-cache-clusters-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-cluster-message))

(clojure.core/defn authorize-cache-security-group-ingress "Allows network ingress to a cache security group. Applications using ElastiCache\nmust be running on Amazon EC2, and Amazon EC2 security groups are used as the\nauthorization mechanism.\n You cannot authorize ingress from an Amazon EC2 security group in one region to\nan ElastiCache cluster in another region." ([authorize-cache-security-group-ingress-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-authorize-cache-security-group-ingress-message authorize-cache-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/authorize-cache-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/authorize-cache-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AuthorizeCacheSecurityGroupIngressResult", :http.request.configuration/action "AuthorizeCacheSecurityGroupIngress", :http.request.configuration/output-deser-fn response-authorize-cache-security-group-ingress-result, :http.request.spec/error-spec {"CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "InvalidCacheSecurityGroupStateFault" :portkey.aws.elasticache/invalid-cache-security-group-state-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.elasticache/authorization-already-exists-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef authorize-cache-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/authorize-cache-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/authorize-cache-security-group-ingress-result))

(clojure.core/defn create-cache-cluster "Creates a cluster. All nodes in the cluster run the same protocol-compliant\ncache engine software, either Memcached or Redis.\n This operation is not supported for Redis (cluster mode enabled) clusters." ([create-cache-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cache-cluster-message create-cache-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/create-cache-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/create-cache-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateCacheClusterResult", :http.request.configuration/action "CreateCacheCluster", :http.request.configuration/output-deser-fn response-create-cache-cluster-result, :http.request.spec/error-spec {"ClusterQuotaForCustomerExceededFault" :portkey.aws.elasticache/cluster-quota-for-customer-exceeded-fault, "CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "CacheSubnetGroupNotFoundFault" :portkey.aws.elasticache/cache-subnet-group-not-found-fault, "TagQuotaPerResourceExceeded" :portkey.aws.elasticache/tag-quota-per-resource-exceeded, "CacheClusterAlreadyExistsFault" :portkey.aws.elasticache/cache-cluster-already-exists-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "NodeQuotaForClusterExceededFault" :portkey.aws.elasticache/node-quota-for-cluster-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault}})))))
(clojure.spec.alpha/fdef create-cache-cluster :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/create-cache-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/create-cache-cluster-result))

(clojure.core/defn delete-cache-security-group "Deletes a cache security group.\n You cannot delete a cache security group if it is associated with any clusters." ([delete-cache-security-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cache-security-group-message delete-cache-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/delete-cache-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCacheSecurityGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidCacheSecurityGroupStateFault" :portkey.aws.elasticache/invalid-cache-security-group-state-fault, "CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef delete-cache-security-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/delete-cache-security-group-message) :ret clojure.core/true?)

(clojure.core/defn delete-cache-subnet-group "Deletes a cache subnet group.\n You cannot delete a cache subnet group if it is associated with any clusters." ([delete-cache-subnet-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cache-subnet-group-message delete-cache-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/delete-cache-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCacheSubnetGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"CacheSubnetGroupInUse" :portkey.aws.elasticache/cache-subnet-group-in-use, "CacheSubnetGroupNotFoundFault" :portkey.aws.elasticache/cache-subnet-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cache-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/delete-cache-subnet-group-message) :ret clojure.core/true?)

(clojure.core/defn delete-snapshot "Deletes an existing snapshot. When you receive a successful response from this\noperation, ElastiCache immediately begins deleting the snapshot; you cannot\ncancel or revert this operation.\n This operation is valid for Redis only." ([delete-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-snapshot-message delete-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/delete-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/delete-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteSnapshotResult", :http.request.configuration/action "DeleteSnapshot", :http.request.configuration/output-deser-fn response-delete-snapshot-result, :http.request.spec/error-spec {"SnapshotNotFoundFault" :portkey.aws.elasticache/snapshot-not-found-fault, "InvalidSnapshotStateFault" :portkey.aws.elasticache/invalid-snapshot-state-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef delete-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/delete-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/delete-snapshot-result))

(clojure.core/defn describe-cache-parameters "Returns the detailed parameter list for a particular cache parameter group." ([describe-cache-parameters-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cache-parameters-message describe-cache-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-parameter-group-details, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-cache-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeCacheParametersResult", :http.request.configuration/action "DescribeCacheParameters", :http.request.configuration/output-deser-fn response-cache-parameter-group-details, :http.request.spec/error-spec {"CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-cache-parameters :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/describe-cache-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-parameter-group-details))

(clojure.core/defn create-replication-group "Creates a Redis (cluster mode disabled) or a Redis (cluster mode enabled)\nreplication group.\n A Redis (cluster mode disabled) replication group is a collection of clusters,\nwhere one of the clusters is a read/write primary and the others are read-only\nreplicas. Writes to the primary are asynchronously propagated to the replicas.\n A Redis (cluster mode enabled) replication group is a collection of 1 to 15\nnode groups (shards). Each node group (shard) has one read/write primary node\nand up to 5 read-only replica nodes. Writes to the primary are asynchronously\npropagated to the replicas. Redis (cluster mode enabled) replication groups\npartition the data across node groups (shards).\n When a Redis (cluster mode disabled) replication group has been successfully\ncreated, you can add one or more read replicas to it, up to a total of 5 read\nreplicas. You cannot alter a Redis (cluster mode enabled) replication group\nafter it has been created. However, if you need to increase or decrease the\nnumber of node groups (console: shards), you can avail yourself of ElastiCache\nfor Redis' enhanced backup and restore. For more information, see Restoring From\na Backup with Cluster Resizing\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/backups-restoring.html)\nin the ElastiCache User Guide.\n This operation is valid for Redis only." ([create-replication-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-replication-group-message create-replication-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/create-replication-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/create-replication-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateReplicationGroupResult", :http.request.configuration/action "CreateReplicationGroup", :http.request.configuration/output-deser-fn response-create-replication-group-result, :http.request.spec/error-spec {"ClusterQuotaForCustomerExceededFault" :portkey.aws.elasticache/cluster-quota-for-customer-exceeded-fault, "CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "CacheSubnetGroupNotFoundFault" :portkey.aws.elasticache/cache-subnet-group-not-found-fault, "TagQuotaPerResourceExceeded" :portkey.aws.elasticache/tag-quota-per-resource-exceeded, "ReplicationGroupAlreadyExistsFault" :portkey.aws.elasticache/replication-group-already-exists-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "NodeGroupsPerReplicationGroupQuotaExceededFault" :portkey.aws.elasticache/node-groups-per-replication-group-quota-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "NodeQuotaForClusterExceededFault" :portkey.aws.elasticache/node-quota-for-cluster-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault}})))))
(clojure.spec.alpha/fdef create-replication-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/create-replication-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/create-replication-group-result))

(clojure.core/defn revoke-cache-security-group-ingress "Revokes ingress from a cache security group. Use this operation to disallow\naccess from an Amazon EC2 security group that had been previously authorized." ([revoke-cache-security-group-ingress-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-revoke-cache-security-group-ingress-message revoke-cache-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/revoke-cache-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/revoke-cache-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RevokeCacheSecurityGroupIngressResult", :http.request.configuration/action "RevokeCacheSecurityGroupIngress", :http.request.configuration/output-deser-fn response-revoke-cache-security-group-ingress-result, :http.request.spec/error-spec {"CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "AuthorizationNotFoundFault" :portkey.aws.elasticache/authorization-not-found-fault, "InvalidCacheSecurityGroupStateFault" :portkey.aws.elasticache/invalid-cache-security-group-state-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef revoke-cache-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/revoke-cache-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/revoke-cache-security-group-ingress-result))

(clojure.core/defn create-cache-subnet-group "Creates a new cache subnet group.\n Use this parameter only when you are creating a cluster in an Amazon Virtual\nPrivate Cloud (Amazon VPC)." ([create-cache-subnet-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cache-subnet-group-message create-cache-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/create-cache-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/create-cache-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateCacheSubnetGroupResult", :http.request.configuration/action "CreateCacheSubnetGroup", :http.request.configuration/output-deser-fn response-create-cache-subnet-group-result, :http.request.spec/error-spec {"CacheSubnetGroupAlreadyExistsFault" :portkey.aws.elasticache/cache-subnet-group-already-exists-fault, "CacheSubnetGroupQuotaExceededFault" :portkey.aws.elasticache/cache-subnet-group-quota-exceeded-fault, "CacheSubnetQuotaExceededFault" :portkey.aws.elasticache/cache-subnet-quota-exceeded-fault, "InvalidSubnet" :portkey.aws.elasticache/invalid-subnet}})))))
(clojure.spec.alpha/fdef create-cache-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/create-cache-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/create-cache-subnet-group-result))

(clojure.core/defn describe-cache-subnet-groups "Returns a list of cache subnet group descriptions. If a subnet group name is\nspecified, the list contains only the description of that group." ([] (describe-cache-subnet-groups {})) ([describe-cache-subnet-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cache-subnet-groups-message describe-cache-subnet-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/cache-subnet-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-cache-subnet-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeCacheSubnetGroupsResult", :http.request.configuration/action "DescribeCacheSubnetGroups", :http.request.configuration/output-deser-fn response-cache-subnet-group-message, :http.request.spec/error-spec {"CacheSubnetGroupNotFoundFault" :portkey.aws.elasticache/cache-subnet-group-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-cache-subnet-groups :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-cache-subnet-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/cache-subnet-group-message))

(clojure.core/defn describe-snapshots "Returns information about cluster or replication group snapshots. By default,\nDescribeSnapshots lists all of your snapshots; it can optionally describe a\nsingle snapshot, or just the snapshots associated with a particular cache\ncluster.\n This operation is valid for Redis only." ([] (describe-snapshots {})) ([describe-snapshots-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-snapshots-message describe-snapshots-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/describe-snapshots-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-snapshots-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeSnapshotsResult", :http.request.configuration/action "DescribeSnapshots", :http.request.configuration/output-deser-fn response-describe-snapshots-list-message, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "SnapshotNotFoundFault" :portkey.aws.elasticache/snapshot-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-snapshots :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-snapshots-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/describe-snapshots-list-message))

(clojure.core/defn decrease-replica-count "Dynamically decreases the number of replics in a Redis (cluster mode disabled)\nreplication group or the number of replica nodes in one or more node groups\n(shards) of a Redis (cluster mode enabled) replication group. This operation is\nperformed with no cluster down time." ([decrease-replica-count-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-decrease-replica-count-message decrease-replica-count-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/decrease-replica-count-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/decrease-replica-count-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DecreaseReplicaCountResult", :http.request.configuration/action "DecreaseReplicaCount", :http.request.configuration/output-deser-fn response-decrease-replica-count-result, :http.request.spec/error-spec {"ClusterQuotaForCustomerExceededFault" :portkey.aws.elasticache/cluster-quota-for-customer-exceeded-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "ServiceLinkedRoleNotFoundFault" :portkey.aws.elasticache/service-linked-role-not-found-fault, "InvalidReplicationGroupStateFault" :portkey.aws.elasticache/invalid-replication-group-state-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "NodeGroupsPerReplicationGroupQuotaExceededFault" :portkey.aws.elasticache/node-groups-per-replication-group-quota-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "NoOperationFault" :portkey.aws.elasticache/no-operation-fault, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault}})))))
(clojure.spec.alpha/fdef decrease-replica-count :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/decrease-replica-count-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/decrease-replica-count-result))

(clojure.core/defn modify-cache-cluster "Modifies the settings for a cluster. You can use this operation to change one or\nmore cluster configuration parameters by specifying the parameters and the new\nvalues." ([modify-cache-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cache-cluster-message modify-cache-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/modify-cache-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/modify-cache-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyCacheClusterResult", :http.request.configuration/action "ModifyCacheCluster", :http.request.configuration/output-deser-fn response-modify-cache-cluster-result, :http.request.spec/error-spec {"CacheSecurityGroupNotFoundFault" :portkey.aws.elasticache/cache-security-group-not-found-fault, "InvalidVPCNetworkStateFault" :portkey.aws.elasticache/invalid-vpc-network-state-fault, "InvalidCacheSecurityGroupStateFault" :portkey.aws.elasticache/invalid-cache-security-group-state-fault, "NodeQuotaForCustomerExceededFault" :portkey.aws.elasticache/node-quota-for-customer-exceeded-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "CacheParameterGroupNotFoundFault" :portkey.aws.elasticache/cache-parameter-group-not-found-fault, "CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "NodeQuotaForClusterExceededFault" :portkey.aws.elasticache/node-quota-for-cluster-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InsufficientCacheClusterCapacityFault" :portkey.aws.elasticache/insufficient-cache-cluster-capacity-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-cache-cluster :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/modify-cache-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/modify-cache-cluster-result))

(clojure.core/defn copy-snapshot "Makes a copy of an existing snapshot.\n This operation is valid for Redis only.\n Users or groups that have permissions to use the CopySnapshot operation can\ncreate their own Amazon S3 buckets and copy snapshots to it. To control access\nto your snapshots, use an IAM policy to control who has the ability to use the\nCopySnapshot operation. For more information about using IAM to control the use\nof ElastiCache operations, see Exporting Snapshots\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html)\nand Authentication & Access Control\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/IAM.html).\n You could receive the following error messages.\n Error Messages\n * Error Message: The S3 bucket %s is outside of the region.\n Solution: Create an Amazon S3 bucket in the same region as your snapshot. For\nmore information, see Step 1: Create an Amazon S3 Bucket\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html#Snapshots.Exporting.CreateBucket)\nin the ElastiCache User Guide.\n * Error Message: The S3 bucket %s does not exist.\n Solution: Create an Amazon S3 bucket in the same region as your snapshot. For\nmore information, see Step 1: Create an Amazon S3 Bucket\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html#Snapshots.Exporting.CreateBucket)\nin the ElastiCache User Guide.\n * Error Message: The S3 bucket %s is not owned by the authenticated user.\n Solution: Create an Amazon S3 bucket in the same region as your snapshot. For\nmore information, see Step 1: Create an Amazon S3 Bucket\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html#Snapshots.Exporting.CreateBucket)\nin the ElastiCache User Guide.\n * Error Message: The authenticated user does not have sufficient permissions to\nperform the desired activity.\n Solution: Contact your system administrator to get the needed permissions.\n * Error Message: The S3 bucket %s already contains an object with key %s.\n Solution: Give the TargetSnapshotName a new and unique value. If exporting a\nsnapshot, you could alternatively create a new Amazon S3 bucket and use this\nsame value for TargetSnapshotName.\n * Error Message: ElastiCache has not been granted READ permissions %s on the S3\nBucket.\n Solution: Add List and Read permissions on the bucket. For more information,\nsee Step 2: Grant ElastiCache Access to Your Amazon S3 Bucket\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html#Snapshots.Exporting.GrantAccess)\nin the ElastiCache User Guide.\n * Error Message: ElastiCache has not been granted WRITE permissions %s on the\nS3 Bucket.\n Solution: Add Upload/Delete permissions on the bucket. For more information,\nsee Step 2: Grant ElastiCache Access to Your Amazon S3 Bucket\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html#Snapshots.Exporting.GrantAccess)\nin the ElastiCache User Guide.\n * Error Message: ElastiCache has not been granted READ_ACP permissions %s on\nthe S3 Bucket.\n Solution: Add View Permissions on the bucket. For more information, see Step 2:\nGrant ElastiCache Access to Your Amazon S3 Bucket\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Snapshots.Exporting.html#Snapshots.Exporting.GrantAccess)\nin the ElastiCache User Guide." ([copy-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-copy-snapshot-message copy-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/copy-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/copy-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CopySnapshotResult", :http.request.configuration/action "CopySnapshot", :http.request.configuration/output-deser-fn response-copy-snapshot-result, :http.request.spec/error-spec {"SnapshotAlreadyExistsFault" :portkey.aws.elasticache/snapshot-already-exists-fault, "SnapshotNotFoundFault" :portkey.aws.elasticache/snapshot-not-found-fault, "SnapshotQuotaExceededFault" :portkey.aws.elasticache/snapshot-quota-exceeded-fault, "InvalidSnapshotStateFault" :portkey.aws.elasticache/invalid-snapshot-state-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef copy-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/copy-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/copy-snapshot-result))

(clojure.core/defn modify-cache-subnet-group "Modifies an existing cache subnet group." ([modify-cache-subnet-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cache-subnet-group-message modify-cache-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/modify-cache-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/modify-cache-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyCacheSubnetGroupResult", :http.request.configuration/action "ModifyCacheSubnetGroup", :http.request.configuration/output-deser-fn response-modify-cache-subnet-group-result, :http.request.spec/error-spec {"CacheSubnetGroupNotFoundFault" :portkey.aws.elasticache/cache-subnet-group-not-found-fault, "CacheSubnetQuotaExceededFault" :portkey.aws.elasticache/cache-subnet-quota-exceeded-fault, "SubnetInUse" :portkey.aws.elasticache/subnet-in-use, "InvalidSubnet" :portkey.aws.elasticache/invalid-subnet}})))))
(clojure.spec.alpha/fdef modify-cache-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/modify-cache-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/modify-cache-subnet-group-result))

(clojure.core/defn create-cache-security-group "Creates a new cache security group. Use a cache security group to control access\nto one or more clusters.\n Cache security groups are only used when you are creating a cluster outside of\nan Amazon Virtual Private Cloud (Amazon VPC). If you are creating a cluster\ninside of a VPC, use a cache subnet group instead. For more information, see\nCreateCacheSubnetGroup\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_CreateCacheSubnetGroup.html)." ([create-cache-security-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cache-security-group-message create-cache-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/create-cache-security-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/create-cache-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateCacheSecurityGroupResult", :http.request.configuration/action "CreateCacheSecurityGroup", :http.request.configuration/output-deser-fn response-create-cache-security-group-result, :http.request.spec/error-spec {"CacheSecurityGroupAlreadyExistsFault" :portkey.aws.elasticache/cache-security-group-already-exists-fault, "CacheSecurityGroupQuotaExceededFault" :portkey.aws.elasticache/cache-security-group-quota-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef create-cache-security-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/create-cache-security-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/create-cache-security-group-result))

(clojure.core/defn remove-tags-from-resource "Removes the tags identified by the TagKeys list from the named resource." ([remove-tags-from-resource-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-remove-tags-from-resource-message remove-tags-from-resource-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/tag-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/remove-tags-from-resource-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RemoveTagsFromResourceResult", :http.request.configuration/action "RemoveTagsFromResource", :http.request.configuration/output-deser-fn response-tag-list-message, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "SnapshotNotFoundFault" :portkey.aws.elasticache/snapshot-not-found-fault, "InvalidARNFault" :portkey.aws.elasticache/invalid-arn-fault, "TagNotFoundFault" :portkey.aws.elasticache/tag-not-found-fault}})))))
(clojure.spec.alpha/fdef remove-tags-from-resource :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/remove-tags-from-resource-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/tag-list-message))

(clojure.core/defn list-allowed-node-type-modifications "Lists all available node types that you can scale your Redis cluster's or\nreplication group's current node type up to.\n When you use the ModifyCacheCluster or ModifyReplicationGroup operations to\nscale up your cluster or replication group, the value of the CacheNodeType\nparameter must be one of the node types returned by this operation." ([] (list-allowed-node-type-modifications {})) ([list-allowed-node-type-modifications-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-allowed-node-type-modifications-message list-allowed-node-type-modifications-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/allowed-node-type-modifications-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/list-allowed-node-type-modifications-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ListAllowedNodeTypeModificationsResult", :http.request.configuration/action "ListAllowedNodeTypeModifications", :http.request.configuration/output-deser-fn response-allowed-node-type-modifications-message, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "ReplicationGroupNotFoundFault" :portkey.aws.elasticache/replication-group-not-found-fault, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception}})))))
(clojure.spec.alpha/fdef list-allowed-node-type-modifications :args (clojure.spec.alpha/? :portkey.aws.elasticache/list-allowed-node-type-modifications-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/allowed-node-type-modifications-message))

(clojure.core/defn create-cache-parameter-group "Creates a new Amazon ElastiCache cache parameter group. An ElastiCache cache\nparameter group is a collection of parameters and their values that are applied\nto all of the nodes in any cluster or replication group using the\nCacheParameterGroup.\n A newly created CacheParameterGroup is an exact duplicate of the default\nparameter group for the CacheParameterGroupFamily. To customize the newly\ncreated CacheParameterGroup you can change the values of specific parameters.\nFor more information, see:\n * ModifyCacheParameterGroup\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_ModifyCacheParameterGroup.html)\nin the ElastiCache API Reference.\n * Parameters and Parameter Groups\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/ParameterGroups.html)\nin the ElastiCache User Guide." ([create-cache-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cache-parameter-group-message create-cache-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/create-cache-parameter-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/create-cache-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateCacheParameterGroupResult", :http.request.configuration/action "CreateCacheParameterGroup", :http.request.configuration/output-deser-fn response-create-cache-parameter-group-result, :http.request.spec/error-spec {"CacheParameterGroupQuotaExceededFault" :portkey.aws.elasticache/cache-parameter-group-quota-exceeded-fault, "CacheParameterGroupAlreadyExistsFault" :portkey.aws.elasticache/cache-parameter-group-already-exists-fault, "InvalidCacheParameterGroupStateFault" :portkey.aws.elasticache/invalid-cache-parameter-group-state-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef create-cache-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/create-cache-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/create-cache-parameter-group-result))

(clojure.core/defn add-tags-to-resource "Adds up to 50 cost allocation tags to the named resource. A cost allocation tag\nis a key-value pair where the key and value are case-sensitive. You can use cost\nallocation tags to categorize and track your AWS costs.\n When you apply tags to your ElastiCache resources, AWS generates a cost\nallocation report as a comma-separated value (CSV) file with your usage and\ncosts aggregated by your tags. You can apply tags that represent business\ncategories (such as cost centers, application names, or owners) to organize your\ncosts across multiple services. For more information, see Using Cost Allocation\nTags in Amazon ElastiCache\n(http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Tagging.html) in the\nElastiCache User Guide." ([add-tags-to-resource-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-add-tags-to-resource-message add-tags-to-resource-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/tag-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/add-tags-to-resource-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AddTagsToResourceResult", :http.request.configuration/action "AddTagsToResource", :http.request.configuration/output-deser-fn response-tag-list-message, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "SnapshotNotFoundFault" :portkey.aws.elasticache/snapshot-not-found-fault, "TagQuotaPerResourceExceeded" :portkey.aws.elasticache/tag-quota-per-resource-exceeded, "InvalidARNFault" :portkey.aws.elasticache/invalid-arn-fault}})))))
(clojure.spec.alpha/fdef add-tags-to-resource :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/add-tags-to-resource-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/tag-list-message))

(clojure.core/defn describe-reserved-cache-nodes "Returns information about reserved cache nodes for this account, or about a\nspecified reserved cache node." ([] (describe-reserved-cache-nodes {})) ([describe-reserved-cache-nodes-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-cache-nodes-message describe-reserved-cache-nodes-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/reserved-cache-node-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-reserved-cache-nodes-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReservedCacheNodesResult", :http.request.configuration/action "DescribeReservedCacheNodes", :http.request.configuration/output-deser-fn response-reserved-cache-node-message, :http.request.spec/error-spec {"ReservedCacheNodeNotFoundFault" :portkey.aws.elasticache/reserved-cache-node-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-reserved-cache-nodes :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-reserved-cache-nodes-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/reserved-cache-node-message))

(clojure.core/defn describe-reserved-cache-nodes-offerings "Lists available reserved cache node offerings." ([] (describe-reserved-cache-nodes-offerings {})) ([describe-reserved-cache-nodes-offerings-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-cache-nodes-offerings-message describe-reserved-cache-nodes-offerings-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/reserved-cache-nodes-offering-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/describe-reserved-cache-nodes-offerings-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReservedCacheNodesOfferingsResult", :http.request.configuration/action "DescribeReservedCacheNodesOfferings", :http.request.configuration/output-deser-fn response-reserved-cache-nodes-offering-message, :http.request.spec/error-spec {"ReservedCacheNodesOfferingNotFoundFault" :portkey.aws.elasticache/reserved-cache-nodes-offering-not-found-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef describe-reserved-cache-nodes-offerings :args (clojure.spec.alpha/? :portkey.aws.elasticache/describe-reserved-cache-nodes-offerings-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/reserved-cache-nodes-offering-message))

(clojure.core/defn delete-cache-cluster "Deletes a previously provisioned cluster. DeleteCacheCluster deletes all\nassociated cache nodes, node endpoints and the cluster itself. When you receive\na successful response from this operation, Amazon ElastiCache immediately begins\ndeleting the cluster; you cannot cancel or revert this operation.\n This operation cannot be used to delete a cluster that is the last read replica\nof a replication group or node group (shard) that has Multi-AZ mode enabled or a\ncluster from a Redis (cluster mode enabled) replication group.\n This operation is not valid for Redis (cluster mode enabled) clusters." ([delete-cache-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cache-cluster-message delete-cache-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.elasticache/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.elasticache/delete-cache-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2015-02-02", :http.request.configuration/service-id "ElastiCache", :http.request.spec/input-spec :portkey.aws.elasticache/delete-cache-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteCacheClusterResult", :http.request.configuration/action "DeleteCacheCluster", :http.request.configuration/output-deser-fn response-delete-cache-cluster-result, :http.request.spec/error-spec {"CacheClusterNotFoundFault" :portkey.aws.elasticache/cache-cluster-not-found-fault, "InvalidCacheClusterStateFault" :portkey.aws.elasticache/invalid-cache-cluster-state-fault, "SnapshotAlreadyExistsFault" :portkey.aws.elasticache/snapshot-already-exists-fault, "SnapshotFeatureNotSupportedFault" :portkey.aws.elasticache/snapshot-feature-not-supported-fault, "SnapshotQuotaExceededFault" :portkey.aws.elasticache/snapshot-quota-exceeded-fault, "InvalidParameterValueException" :portkey.aws.elasticache/invalid-parameter-value-exception, "InvalidParameterCombinationException" :portkey.aws.elasticache/invalid-parameter-combination-exception}})))))
(clojure.spec.alpha/fdef delete-cache-cluster :args (clojure.spec.alpha/tuple :portkey.aws.elasticache/delete-cache-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.elasticache/delete-cache-cluster-result))
