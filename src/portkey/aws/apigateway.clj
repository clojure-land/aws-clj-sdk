(ns portkey.aws.apigateway (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "apigateway", :region "us-gov-east-1"},
    :ssl-common-name "apigateway.us-gov-east-1.amazonaws.com",
    :endpoint "https://apigateway.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope
    {:service "apigateway", :region "ap-northeast-1"},
    :ssl-common-name "apigateway.ap-northeast-1.amazonaws.com",
    :endpoint "https://apigateway.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "apigateway", :region "eu-west-1"},
    :ssl-common-name "apigateway.eu-west-1.amazonaws.com",
    :endpoint "https://apigateway.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "apigateway", :region "us-east-2"},
    :ssl-common-name "apigateway.us-east-2.amazonaws.com",
    :endpoint "https://apigateway.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope
    {:service "apigateway", :region "ap-southeast-2"},
    :ssl-common-name "apigateway.ap-southeast-2.amazonaws.com",
    :endpoint "https://apigateway.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "apigateway", :region "cn-north-1"},
    :ssl-common-name "apigateway.cn-north-1.amazonaws.com.cn",
    :endpoint "https://apigateway.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "apigateway", :region "sa-east-1"},
    :ssl-common-name "apigateway.sa-east-1.amazonaws.com",
    :endpoint "https://apigateway.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope
    {:service "apigateway", :region "ap-southeast-1"},
    :ssl-common-name "apigateway.ap-southeast-1.amazonaws.com",
    :endpoint "https://apigateway.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope
    {:service "apigateway", :region "cn-northwest-1"},
    :ssl-common-name "apigateway.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://apigateway.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope
    {:service "apigateway", :region "ap-northeast-2"},
    :ssl-common-name "apigateway.ap-northeast-2.amazonaws.com",
    :endpoint "https://apigateway.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "apigateway", :region "eu-west-3"},
    :ssl-common-name "apigateway.eu-west-3.amazonaws.com",
    :endpoint "https://apigateway.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "apigateway", :region "ca-central-1"},
    :ssl-common-name "apigateway.ca-central-1.amazonaws.com",
    :endpoint "https://apigateway.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "apigateway", :region "eu-central-1"},
    :ssl-common-name "apigateway.eu-central-1.amazonaws.com",
    :endpoint "https://apigateway.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "apigateway", :region "eu-west-2"},
    :ssl-common-name "apigateway.eu-west-2.amazonaws.com",
    :endpoint "https://apigateway.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "apigateway", :region "us-gov-west-1"},
    :ssl-common-name "apigateway.us-gov-west-1.amazonaws.com",
    :endpoint "https://apigateway.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "apigateway", :region "us-west-2"},
    :ssl-common-name "apigateway.us-west-2.amazonaws.com",
    :endpoint "https://apigateway.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "apigateway", :region "us-east-1"},
    :ssl-common-name "apigateway.us-east-1.amazonaws.com",
    :endpoint "https://apigateway.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "apigateway", :region "us-west-1"},
    :ssl-common-name "apigateway.us-west-1.amazonaws.com",
    :endpoint "https://apigateway.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "apigateway", :region "ap-south-1"},
    :ssl-common-name "apigateway.ap-south-1.amazonaws.com",
    :endpoint "https://apigateway.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "apigateway", :region "eu-north-1"},
    :ssl-common-name "apigateway.eu-north-1.amazonaws.com",
    :endpoint "https://apigateway.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-documentation-part-location-status-code)

(clojure.core/declare ser-double)

(clojure.core/declare ser-gateway-response-type)

(clojure.core/declare ser-status-code)

(clojure.core/declare ser-api-stage)

(clojure.core/declare ser-map-of-string-to-list)

(clojure.core/declare ser-endpoint-type)

(clojure.core/declare ser-list-of-string)

(clojure.core/declare ser-documentation-part-type)

(clojure.core/declare ser-patch-operation)

(clojure.core/declare ser-nullable-boolean)

(clojure.core/declare ser-map-of-string-to-boolean)

(clojure.core/declare ser-quota-period-type)

(clojure.core/declare ser-put-mode)

(clojure.core/declare ser-deployment-canary-settings)

(clojure.core/declare ser-api-key-source-type)

(clojure.core/declare ser-throttle-settings)

(clojure.core/declare ser-cache-cluster-size)

(clojure.core/declare ser-integration-type)

(clojure.core/declare ser-op)

(clojure.core/declare ser-authorizer-type)

(clojure.core/declare ser-list-of-ar-ns)

(clojure.core/declare ser-list-of-api-stage)

(clojure.core/declare ser-canary-settings)

(clojure.core/declare ser-stage-key)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-string)

(clojure.core/declare ser-quota-settings)

(clojure.core/declare ser-provider-arn)

(clojure.core/declare ser-map-of-string-to-string)

(clojure.core/declare ser-connection-type)

(clojure.core/declare ser-documentation-part-location)

(clojure.core/declare ser-api-keys-format)

(clojure.core/declare ser-list-of-endpoint-type)

(clojure.core/declare ser-list-of-patch-operation)

(clojure.core/declare ser-nullable-integer)

(clojure.core/declare ser-map-of-api-stage-throttle-settings)

(clojure.core/declare ser-blob)

(clojure.core/declare ser-location-status-type)

(clojure.core/declare ser-endpoint-configuration)

(clojure.core/declare ser-list-of-stage-keys)

(clojure.core/declare ser-content-handling-strategy)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-documentation-part-location-status-code [input] #:http.request.field{:value input, :shape "DocumentationPartLocationStatusCode"})

(clojure.core/defn- ser-double [input] #:http.request.field{:value input, :shape "Double"})

(clojure.core/defn- ser-gateway-response-type [input] #:http.request.field{:value (clojure.core/get {:integration-timeout "INTEGRATION_TIMEOUT", "REQUEST_TOO_LARGE" "REQUEST_TOO_LARGE", :unauthorized "UNAUTHORIZED", "INTEGRATION_TIMEOUT" "INTEGRATION_TIMEOUT", "RESOURCE_NOT_FOUND" "RESOURCE_NOT_FOUND", :invalid-api-key "INVALID_API_KEY", :integration-failure "INTEGRATION_FAILURE", "AUTHORIZER_CONFIGURATION_ERROR" "AUTHORIZER_CONFIGURATION_ERROR", "INTEGRATION_FAILURE" "INTEGRATION_FAILURE", "DEFAULT_5XX" "DEFAULT_5XX", "UNAUTHORIZED" "UNAUTHORIZED", :quota-exceeded "QUOTA_EXCEEDED", :invalid-signature "INVALID_SIGNATURE", :expired-token "EXPIRED_TOKEN", :bad-request-parameters "BAD_REQUEST_PARAMETERS", "AUTHORIZER_FAILURE" "AUTHORIZER_FAILURE", :unsupported-media-type "UNSUPPORTED_MEDIA_TYPE", "INVALID_API_KEY" "INVALID_API_KEY", "ACCESS_DENIED" "ACCESS_DENIED", "API_CONFIGURATION_ERROR" "API_CONFIGURATION_ERROR", "DEFAULT_4XX" "DEFAULT_4XX", "INVALID_SIGNATURE" "INVALID_SIGNATURE", :bad-request-body "BAD_REQUEST_BODY", :api-configuration-error "API_CONFIGURATION_ERROR", "EXPIRED_TOKEN" "EXPIRED_TOKEN", "UNSUPPORTED_MEDIA_TYPE" "UNSUPPORTED_MEDIA_TYPE", :authorizer-configuration-error "AUTHORIZER_CONFIGURATION_ERROR", :default-5-xx "DEFAULT_5XX", :request-too-large "REQUEST_TOO_LARGE", :default-4-xx "DEFAULT_4XX", :authorizer-failure "AUTHORIZER_FAILURE", :throttled "THROTTLED", "QUOTA_EXCEEDED" "QUOTA_EXCEEDED", "BAD_REQUEST_PARAMETERS" "BAD_REQUEST_PARAMETERS", "MISSING_AUTHENTICATION_TOKEN" "MISSING_AUTHENTICATION_TOKEN", :missing-authentication-token "MISSING_AUTHENTICATION_TOKEN", "BAD_REQUEST_BODY" "BAD_REQUEST_BODY", :resource-not-found "RESOURCE_NOT_FOUND", :access-denied "ACCESS_DENIED", "THROTTLED" "THROTTLED"} input), :shape "GatewayResponseType"})

(clojure.core/defn- ser-status-code [input] #:http.request.field{:value input, :shape "StatusCode"})

(clojure.core/defn- ser-api-stage [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ApiStage", :type "structure"} (clojure.core/contains? input :api-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :api-id)) #:http.request.field{:name "apiId", :shape "String"})) (clojure.core/contains? input :stage) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage)) #:http.request.field{:name "stage", :shape "String"})) (clojure.core/contains? input :throttle) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-api-stage-throttle-settings (input :throttle)) #:http.request.field{:name "throttle", :shape "MapOfApiStageThrottleSettings"}))))

(clojure.core/defn- ser-map-of-string-to-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-list-of-string v) #:http.request.field{:map-info "value", :shape "ListOfString"})])) input), :shape "MapOfStringToList", :type "map"})

(clojure.core/defn- ser-endpoint-type [input] #:http.request.field{:value (clojure.core/get {"REGIONAL" "REGIONAL", :regional "REGIONAL", "EDGE" "EDGE", :edge "EDGE", "PRIVATE" "PRIVATE", :private "PRIVATE"} input), :shape "EndpointType"})

(clojure.core/defn- ser-list-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "ListOfString", :type "list"})

(clojure.core/defn- ser-documentation-part-type [input] #:http.request.field{:value (clojure.core/get {:response "RESPONSE", "PATH_PARAMETER" "PATH_PARAMETER", :api "API", :response-header "RESPONSE_HEADER", :method "METHOD", "API" "API", "REQUEST_HEADER" "REQUEST_HEADER", :path-parameter "PATH_PARAMETER", "METHOD" "METHOD", :request-body "REQUEST_BODY", :resource "RESOURCE", :request-header "REQUEST_HEADER", "RESOURCE" "RESOURCE", :response-body "RESPONSE_BODY", :query-parameter "QUERY_PARAMETER", "RESPONSE_HEADER" "RESPONSE_HEADER", :authorizer "AUTHORIZER", "REQUEST_BODY" "REQUEST_BODY", "QUERY_PARAMETER" "QUERY_PARAMETER", "AUTHORIZER" "AUTHORIZER", "MODEL" "MODEL", "RESPONSE" "RESPONSE", "RESPONSE_BODY" "RESPONSE_BODY", :model "MODEL"} input), :shape "DocumentationPartType"})

(clojure.core/defn- ser-patch-operation [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PatchOperation", :type "structure"} (clojure.core/contains? input :op) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-op (input :op)) #:http.request.field{:name "op", :shape "Op"})) (clojure.core/contains? input :path) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path)) #:http.request.field{:name "path", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "value", :shape "String"})) (clojure.core/contains? input :from) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :from)) #:http.request.field{:name "from", :shape "String"}))))

(clojure.core/defn- ser-nullable-boolean [input] #:http.request.field{:value input, :shape "NullableBoolean"})

(clojure.core/defn- ser-map-of-string-to-boolean [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-nullable-boolean v) #:http.request.field{:map-info "value", :shape "NullableBoolean"})])) input), :shape "MapOfStringToBoolean", :type "map"})

(clojure.core/defn- ser-quota-period-type [input] #:http.request.field{:value (clojure.core/get {"DAY" "DAY", :day "DAY", "WEEK" "WEEK", :week "WEEK", "MONTH" "MONTH", :month "MONTH"} input), :shape "QuotaPeriodType"})

(clojure.core/defn- ser-put-mode [input] #:http.request.field{:value (clojure.core/get {"merge" "merge", :merge "merge", "overwrite" "overwrite", :overwrite "overwrite"} input), :shape "PutMode"})

(clojure.core/defn- ser-deployment-canary-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DeploymentCanarySettings", :type "structure"} (clojure.core/contains? input :percent-traffic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :percent-traffic)) #:http.request.field{:name "percentTraffic", :shape "Double"})) (clojure.core/contains? input :stage-variable-overrides) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variable-overrides)) #:http.request.field{:name "stageVariableOverrides", :shape "MapOfStringToString"})) (clojure.core/contains? input :use-stage-cache) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :use-stage-cache)) #:http.request.field{:name "useStageCache", :shape "Boolean"}))))

(clojure.core/defn- ser-api-key-source-type [input] #:http.request.field{:value (clojure.core/get {"HEADER" "HEADER", :header "HEADER", "AUTHORIZER" "AUTHORIZER", :authorizer "AUTHORIZER"} input), :shape "ApiKeySourceType"})

(clojure.core/defn- ser-throttle-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ThrottleSettings", :type "structure"} (clojure.core/contains? input :burst-limit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :burst-limit)) #:http.request.field{:name "burstLimit", :shape "Integer"})) (clojure.core/contains? input :rate-limit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :rate-limit)) #:http.request.field{:name "rateLimit", :shape "Double"}))))

(clojure.core/defn- ser-cache-cluster-size [input] #:http.request.field{:value (clojure.core/get {"118" "118", "237" "237", :05 "0.5", "1.6" "1.6", :118 "118", :61 "6.1", "0.5" "0.5", :16 "1.6", "28.4" "28.4", :135 "13.5", "58.2" "58.2", :284 "28.4", "6.1" "6.1", :237 "237", :582 "58.2", "13.5" "13.5"} input), :shape "CacheClusterSize"})

(clojure.core/defn- ser-integration-type [input] #:http.request.field{:value (clojure.core/get {:aws "AWS", "AWS" "AWS", :aws-proxy "AWS_PROXY", "MOCK" "MOCK", "AWS_PROXY" "AWS_PROXY", "HTTP_PROXY" "HTTP_PROXY", :http "HTTP", :http-proxy "HTTP_PROXY", "HTTP" "HTTP", :mock "MOCK"} input), :shape "IntegrationType"})

(clojure.core/defn- ser-op [input] #:http.request.field{:value (clojure.core/get {:remove "remove", :copy "copy", "copy" "copy", :replace "replace", :move "move", "replace" "replace", "remove" "remove", "move" "move", "add" "add", :add "add", :test "test", "test" "test"} input), :shape "Op"})

(clojure.core/defn- ser-authorizer-type [input] #:http.request.field{:value (clojure.core/get {"TOKEN" "TOKEN", :token "TOKEN", "REQUEST" "REQUEST", :request "REQUEST", "COGNITO_USER_POOLS" "COGNITO_USER_POOLS", :cognito-user-pools "COGNITO_USER_POOLS"} input), :shape "AuthorizerType"})

(clojure.core/defn- ser-list-of-ar-ns [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-provider-arn coll) #:http.request.field{:shape "ProviderARN"}))) input), :shape "ListOfARNs", :type "list"})

(clojure.core/defn- ser-list-of-api-stage [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-api-stage coll) #:http.request.field{:shape "ApiStage"}))) input), :shape "ListOfApiStage", :type "list"})

(clojure.core/defn- ser-canary-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CanarySettings", :type "structure"} (clojure.core/contains? input :percent-traffic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :percent-traffic)) #:http.request.field{:name "percentTraffic", :shape "Double"})) (clojure.core/contains? input :deployment-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String"})) (clojure.core/contains? input :stage-variable-overrides) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variable-overrides)) #:http.request.field{:name "stageVariableOverrides", :shape "MapOfStringToString"})) (clojure.core/contains? input :use-stage-cache) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :use-stage-cache)) #:http.request.field{:name "useStageCache", :shape "Boolean"}))))

(clojure.core/defn- ser-stage-key [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StageKey", :type "structure"} (clojure.core/contains? input :rest-api-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String"})) (clojure.core/contains? input :stage-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"}))))

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-quota-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "QuotaSettings", :type "structure"} (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :limit)) #:http.request.field{:name "limit", :shape "Integer"})) (clojure.core/contains? input :offset) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :offset)) #:http.request.field{:name "offset", :shape "Integer"})) (clojure.core/contains? input :period) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-quota-period-type (input :period)) #:http.request.field{:name "period", :shape "QuotaPeriodType"}))))

(clojure.core/defn- ser-provider-arn [input] #:http.request.field{:value input, :shape "ProviderARN"})

(clojure.core/defn- ser-map-of-string-to-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-string v) #:http.request.field{:map-info "value", :shape "String"})])) input), :shape "MapOfStringToString", :type "map"})

(clojure.core/defn- ser-connection-type [input] #:http.request.field{:value (clojure.core/get {"INTERNET" "INTERNET", :internet "INTERNET", "VPC_LINK" "VPC_LINK", :vpc-link "VPC_LINK"} input), :shape "ConnectionType"})

(clojure.core/defn- ser-documentation-part-location [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-documentation-part-type (:type input)) #:http.request.field{:name "type", :shape "DocumentationPartType"})], :shape "DocumentationPartLocation", :type "structure"} (clojure.core/contains? input :path) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path)) #:http.request.field{:name "path", :shape "String"})) (clojure.core/contains? input :method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :method)) #:http.request.field{:name "method", :shape "String"})) (clojure.core/contains? input :status-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-documentation-part-location-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "DocumentationPartLocationStatusCode"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}))))

(clojure.core/defn- ser-api-keys-format [input] #:http.request.field{:value (clojure.core/get {"csv" "csv", :csv "csv"} input), :shape "ApiKeysFormat"})

(clojure.core/defn- ser-list-of-endpoint-type [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-endpoint-type coll) #:http.request.field{:shape "EndpointType"}))) input), :shape "ListOfEndpointType", :type "list"})

(clojure.core/defn- ser-list-of-patch-operation [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-operation coll) #:http.request.field{:shape "PatchOperation"}))) input), :shape "ListOfPatchOperation", :type "list"})

(clojure.core/defn- ser-nullable-integer [input] #:http.request.field{:value input, :shape "NullableInteger"})

(clojure.core/defn- ser-map-of-api-stage-throttle-settings [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-throttle-settings v) #:http.request.field{:map-info "value", :shape "ThrottleSettings"})])) input), :shape "MapOfApiStageThrottleSettings", :type "map"})

(clojure.core/defn- ser-blob [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "Blob"})

(clojure.core/defn- ser-location-status-type [input] #:http.request.field{:value (clojure.core/get {"DOCUMENTED" "DOCUMENTED", :documented "DOCUMENTED", "UNDOCUMENTED" "UNDOCUMENTED", :undocumented "UNDOCUMENTED"} input), :shape "LocationStatusType"})

(clojure.core/defn- ser-endpoint-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointConfiguration", :type "structure"} (clojure.core/contains? input :types) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-endpoint-type (input :types)) #:http.request.field{:name "types", :shape "ListOfEndpointType"}))))

(clojure.core/defn- ser-list-of-stage-keys [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-stage-key coll) #:http.request.field{:shape "StageKey"}))) input), :shape "ListOfStageKeys", :type "list"})

(clojure.core/defn- ser-content-handling-strategy [input] #:http.request.field{:value (clojure.core/get {"CONVERT_TO_BINARY" "CONVERT_TO_BINARY", :convert-to-binary "CONVERT_TO_BINARY", "CONVERT_TO_TEXT" "CONVERT_TO_TEXT", :convert-to-text "CONVERT_TO_TEXT"} input), :shape "ContentHandlingStrategy"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-create-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :parent-id)) #:http.request.field{:name "parentId", :shape "String", :location "uri", :location-name "parent_id"})], :body [(clojure.core/into (ser-string (input :path-part)) #:http.request.field{:name "pathPart", :shape "String"})]}))

(clojure.core/defn- req-put-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})]} (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-put-mode (input :mode)) #:http.request.field{:name "mode", :shape "PutMode", :location "querystring", :location-name "mode"})) (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"}))))

(clojure.core/defn- req-get-stages-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :deployment-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "querystring", :location-name "deploymentId"}))))

(clojure.core/defn- req-delete-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]}))

(clojure.core/defn- req-delete-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"})]}))

(clojure.core/defn- req-delete-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]}))

(clojure.core/defn- req-create-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}) (clojure.core/into (ser-list-of-string (input :target-arns)) #:http.request.field{:name "targetArns", :shape "ListOfString"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-get-resources-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :embed) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :embed)) #:http.request.field{:name "embed", :shape "ListOfString", :location "querystring", :location-name "embed"}))))

(clojure.core/defn- req-test-invoke-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]} (clojure.core/contains? input :headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :headers)) #:http.request.field{:name "headers", :shape "MapOfStringToString"})) (clojure.core/contains? input :multi-value-headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-list (input :multi-value-headers)) #:http.request.field{:name "multiValueHeaders", :shape "MapOfStringToList"})) (clojure.core/contains? input :path-with-query-string) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path-with-query-string)) #:http.request.field{:name "pathWithQueryString", :shape "String"})) (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "body", :shape "String"})) (clojure.core/contains? input :stage-variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variables)) #:http.request.field{:name "stageVariables", :shape "MapOfStringToString"})) (clojure.core/contains? input :additional-context) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :additional-context)) #:http.request.field{:name "additionalContext", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-test-invoke-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "body", :shape "String"})) (clojure.core/contains? input :multi-value-headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-list (input :multi-value-headers)) #:http.request.field{:name "multiValueHeaders", :shape "MapOfStringToList"})) (clojure.core/contains? input :path-with-query-string) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path-with-query-string)) #:http.request.field{:name "pathWithQueryString", :shape "String"})) (clojure.core/contains? input :client-certificate-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String"})) (clojure.core/contains? input :stage-variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variables)) #:http.request.field{:name "stageVariables", :shape "MapOfStringToString"})) (clojure.core/contains? input :headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :headers)) #:http.request.field{:name "headers", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-get-sdk-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :id)) #:http.request.field{:name "id", :shape "String", :location "uri", :location-name "sdktype_id"})]}))

(clojure.core/defn- req-get-sdk-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"}) (clojure.core/into (ser-string (input :sdk-type)) #:http.request.field{:name "sdkType", :shape "String", :location "uri", :location-name "sdk_type"})]} (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"}))))

(clojure.core/defn- req-update-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-delete-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-delete-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-part-id)) #:http.request.field{:name "documentationPartId", :shape "String", :location "uri", :location-name "part_id"})]}))

(clojure.core/defn- req-get-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-get-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"})]} (clojure.core/contains? input :embed) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :embed)) #:http.request.field{:name "embed", :shape "ListOfString", :location "querystring", :location-name "embed"}))))

(clojure.core/defn- req-get-usage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})], :querystring [(clojure.core/into (ser-string (input :start-date)) #:http.request.field{:name "startDate", :shape "String", :location "querystring", :location-name "startDate"}) (clojure.core/into (ser-string (input :end-date)) #:http.request.field{:name "endDate", :shape "String", :location "querystring", :location-name "endDate"})]} (clojure.core/contains? input :key-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "querystring", :location-name "keyId"})) (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"}) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String", :location "uri", :location-name "base_path"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-sdk-types-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-import-documentation-parts-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})]} (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-put-mode (input :mode)) #:http.request.field{:name "mode", :shape "PutMode", :location "querystring", :location-name "mode"})) (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"}))))

(clojure.core/defn- req-generate-client-certificate-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-get-client-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String", :location "uri", :location-name "clientcertificate_id"})]}))

(clojure.core/defn- req-update-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "uri", :location-name "deployment_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-put-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})], :body [(clojure.core/into (ser-integration-type (input :type)) #:http.request.field{:name "type", :shape "IntegrationType"})]} (clojure.core/contains? input :connection-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :connection-id)) #:http.request.field{:name "connectionId", :shape "String"})) (clojure.core/contains? input :uri) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :uri)) #:http.request.field{:name "uri", :shape "String"})) (clojure.core/contains? input :integration-http-method) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :integration-http-method)) #:http.request.field{:name "integrationHttpMethod", :shape "String", :location-name "httpMethod"})) (clojure.core/contains? input :connection-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-connection-type (input :connection-type)) #:http.request.field{:name "connectionType", :shape "ConnectionType"})) (clojure.core/contains? input :request-templates) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :request-templates)) #:http.request.field{:name "requestTemplates", :shape "MapOfStringToString"})) (clojure.core/contains? input :request-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :request-parameters)) #:http.request.field{:name "requestParameters", :shape "MapOfStringToString"})) (clojure.core/contains? input :cache-namespace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-namespace)) #:http.request.field{:name "cacheNamespace", :shape "String"})) (clojure.core/contains? input :passthrough-behavior) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :passthrough-behavior)) #:http.request.field{:name "passthroughBehavior", :shape "String"})) (clojure.core/contains? input :content-handling) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-content-handling-strategy (input :content-handling)) #:http.request.field{:name "contentHandling", :shape "ContentHandlingStrategy"})) (clojure.core/contains? input :cache-key-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :cache-key-parameters)) #:http.request.field{:name "cacheKeyParameters", :shape "ListOfString"})) (clojure.core/contains? input :credentials) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :credentials)) #:http.request.field{:name "credentials", :shape "String"})) (clojure.core/contains? input :timeout-in-millis) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :timeout-in-millis)) #:http.request.field{:name "timeoutInMillis", :shape "NullableInteger"}))))

(clojure.core/defn- req-update-usage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"}) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "uri", :location-name "keyId"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-delete-api-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "apiKey", :shape "String", :location "uri", :location-name "api_Key"})]}))

(clojure.core/defn- req-get-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-part-id)) #:http.request.field{:name "documentationPartId", :shape "String", :location "uri", :location-name "part_id"})]}))

(clojure.core/defn- req-get-base-path-mappings-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})]} (clojure.core/contains? input :api-key-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-api-key-source-type (input :api-key-source)) #:http.request.field{:name "apiKeySource", :shape "ApiKeySourceType"})) (clojure.core/contains? input :clone-from) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :clone-from)) #:http.request.field{:name "cloneFrom", :shape "String"})) (clojure.core/contains? input :binary-media-types) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :binary-media-types)) #:http.request.field{:name "binaryMediaTypes", :shape "ListOfString"})) (clojure.core/contains? input :endpoint-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-configuration (input :endpoint-configuration)) #:http.request.field{:name "endpointConfiguration", :shape "EndpointConfiguration"})) (clojure.core/contains? input :policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :policy)) #:http.request.field{:name "policy", :shape "String"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :version)) #:http.request.field{:name "version", :shape "String"})) (clojure.core/contains? input :minimum-compression-size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :minimum-compression-size)) #:http.request.field{:name "minimumCompressionSize", :shape "NullableInteger"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-put-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :selection-pattern) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :selection-pattern)) #:http.request.field{:name "selectionPattern", :shape "String"})) (clojure.core/contains? input :response-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-parameters)) #:http.request.field{:name "responseParameters", :shape "MapOfStringToString"})) (clojure.core/contains? input :response-templates) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-templates)) #:http.request.field{:name "responseTemplates", :shape "MapOfStringToString"})) (clojure.core/contains? input :content-handling) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-content-handling-strategy (input :content-handling)) #:http.request.field{:name "contentHandling", :shape "ContentHandlingStrategy"}))))

(clojure.core/defn- req-update-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]}))

(clojure.core/defn- req-get-export-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"}) (clojure.core/into (ser-string (input :export-type)) #:http.request.field{:name "exportType", :shape "String", :location "uri", :location-name "export_type"})]} (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"})) (clojure.core/contains? input :accepts) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :accepts)) #:http.request.field{:name "accepts", :shape "String", :location "header", :location-name "Accept"}))))

(clojure.core/defn- req-delete-client-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String", :location "uri", :location-name "clientcertificate_id"})]}))

(clojure.core/defn- req-get-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]} (clojure.core/contains? input :flatten) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :flatten)) #:http.request.field{:name "flatten", :shape "Boolean", :location "querystring", :location-name "flatten"}))))

(clojure.core/defn- req-create-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String"})]} (clojure.core/contains? input :stage-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-get-request-validators-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :api-stages) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-api-stage (input :api-stages)) #:http.request.field{:name "apiStages", :shape "ListOfApiStage"})) (clojure.core/contains? input :throttle) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-throttle-settings (input :throttle)) #:http.request.field{:name "throttle", :shape "ThrottleSettings"})) (clojure.core/contains? input :quota) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-quota-settings (input :quota)) #:http.request.field{:name "quota", :shape "QuotaSettings"}))))

(clojure.core/defn- req-get-usage-plan-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"}) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "uri", :location-name "keyId"})]}))

(clojure.core/defn- req-put-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]} (clojure.core/contains? input :status-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode"})) (clojure.core/contains? input :response-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-parameters)) #:http.request.field{:name "responseParameters", :shape "MapOfStringToString"})) (clojure.core/contains? input :response-templates) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-templates)) #:http.request.field{:name "responseTemplates", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-flush-stage-cache-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-update-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-delete-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-get-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-create-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}) (clojure.core/into (ser-string (input :content-type)) #:http.request.field{:name "contentType", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :schema) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schema)) #:http.request.field{:name "schema", :shape "String"}))))

(clojure.core/defn- req-delete-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]}))

(clojure.core/defn- req-update-account-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-rest-apis-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-delete-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]}))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "String", :location "uri", :location-name "resource_arn"})], :body [(clojure.core/into (ser-map-of-string-to-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOfStringToString"})]}))

(clojure.core/defn- req-get-model-template-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]}))

(clojure.core/defn- req-delete-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-get-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String", :location "uri", :location-name "requestvalidator_id"})]}))

(clojure.core/defn- req-get-authorizers-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-delete-usage-plan-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"}) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "uri", :location-name "keyId"})]}))

(clojure.core/defn- req-get-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"}) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String", :location "uri", :location-name "base_path"})]}))

(clojure.core/defn- req-update-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-update-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-put-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :response-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-boolean (input :response-parameters)) #:http.request.field{:name "responseParameters", :shape "MapOfStringToBoolean"})) (clojure.core/contains? input :response-models) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-models)) #:http.request.field{:name "responseModels", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-get-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]}))

(clojure.core/defn- req-update-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-gateway-responses-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :tracing-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :tracing-enabled)) #:http.request.field{:name "tracingEnabled", :shape "NullableBoolean"})) (clojure.core/contains? input :canary-settings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-deployment-canary-settings (input :canary-settings)) #:http.request.field{:name "canarySettings", :shape "DeploymentCanarySettings"})) (clojure.core/contains? input :stage-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-description)) #:http.request.field{:name "stageDescription", :shape "String"})) (clojure.core/contains? input :variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :variables)) #:http.request.field{:name "variables", :shape "MapOfStringToString"})) (clojure.core/contains? input :cache-cluster-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :cache-cluster-enabled)) #:http.request.field{:name "cacheClusterEnabled", :shape "NullableBoolean"})) (clojure.core/contains? input :stage-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :cache-cluster-size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-cluster-size (input :cache-cluster-size)) #:http.request.field{:name "cacheClusterSize", :shape "CacheClusterSize"}))))

(clojure.core/defn- req-get-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :vpc-link-id)) #:http.request.field{:name "vpcLinkId", :shape "String", :location "uri", :location-name "vpclink_id"})]}))

(clojure.core/defn- req-create-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})) (clojure.core/contains? input :validate-request-body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :validate-request-body)) #:http.request.field{:name "validateRequestBody", :shape "Boolean"})) (clojure.core/contains? input :validate-request-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :validate-request-parameters)) #:http.request.field{:name "validateRequestParameters", :shape "Boolean"}))))

(clojure.core/defn- req-get-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String", :location "uri", :location-name "doc_version"})]}))

(clojure.core/defn- req-get-api-keys-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :name-query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name-query)) #:http.request.field{:name "nameQuery", :shape "String", :location "querystring", :location-name "name"})) (clojure.core/contains? input :customer-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :customer-id)) #:http.request.field{:name "customerId", :shape "String", :location "querystring", :location-name "customerId"})) (clojure.core/contains? input :include-values) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :include-values)) #:http.request.field{:name "includeValues", :shape "NullableBoolean", :location "querystring", :location-name "includeValues"}))))

(clojure.core/defn- req-get-usage-plan-keys-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :name-query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name-query)) #:http.request.field{:name "nameQuery", :shape "String", :location "querystring", :location-name "name"}))))

(clojure.core/defn- req-update-client-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String", :location "uri", :location-name "clientcertificate_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-create-api-key-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "enabled", :shape "Boolean"})) (clojure.core/contains? input :generate-distinct-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :generate-distinct-id)) #:http.request.field{:name "generateDistinctId", :shape "Boolean"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "value", :shape "String"})) (clojure.core/contains? input :stage-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-stage-keys (input :stage-keys)) #:http.request.field{:name "stageKeys", :shape "ListOfStageKeys"})) (clojure.core/contains? input :customer-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :customer-id)) #:http.request.field{:name "customerId", :shape "String"}))))

(clojure.core/defn- req-get-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "uri", :location-name "deployment_id"})]} (clojure.core/contains? input :embed) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :embed)) #:http.request.field{:name "embed", :shape "ListOfString", :location "querystring", :location-name "embed"}))))

(clojure.core/defn- req-delete-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String", :location "uri", :location-name "doc_version"})]}))

(clojure.core/defn- req-get-client-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-delete-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"}) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String", :location "uri", :location-name "base_path"})]}))

(clojure.core/defn- req-update-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-update-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String", :location "uri", :location-name "doc_version"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-create-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}) (clojure.core/into (ser-authorizer-type (input :type)) #:http.request.field{:name "type", :shape "AuthorizerType"})]} (clojure.core/contains? input :authorizer-credentials) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :authorizer-credentials)) #:http.request.field{:name "authorizerCredentials", :shape "String"})) (clojure.core/contains? input :identity-validation-expression) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :identity-validation-expression)) #:http.request.field{:name "identityValidationExpression", :shape "String"})) (clojure.core/contains? input :authorizer-result-ttl-in-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :authorizer-result-ttl-in-seconds)) #:http.request.field{:name "authorizerResultTtlInSeconds", :shape "NullableInteger"})) (clojure.core/contains? input :authorizer-uri) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :authorizer-uri)) #:http.request.field{:name "authorizerUri", :shape "String"})) (clojure.core/contains? input :auth-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :auth-type)) #:http.request.field{:name "authType", :shape "String"})) (clojure.core/contains? input :identity-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :identity-source)) #:http.request.field{:name "identitySource", :shape "String"})) (clojure.core/contains? input :provider-ar-ns) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-ar-ns (input :provider-ar-ns)) #:http.request.field{:name "providerARNs", :shape "ListOfARNs"}))))

(clojure.core/defn- req-delete-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]}))

(clojure.core/defn- req-get-tags-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "String", :location "uri", :location-name "resource_arn"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]}))

(clojure.core/defn- req-get-domain-names-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})], :body [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String"})]} (clojure.core/contains? input :base-path) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String"})) (clojure.core/contains? input :stage) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage)) #:http.request.field{:name "stage", :shape "String"}))))

(clojure.core/defn- req-create-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String"})]} (clojure.core/contains? input :tracing-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :tracing-enabled)) #:http.request.field{:name "tracingEnabled", :shape "Boolean"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOfStringToString"})) (clojure.core/contains? input :documentation-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String"})) (clojure.core/contains? input :canary-settings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-canary-settings (input :canary-settings)) #:http.request.field{:name "canarySettings", :shape "CanarySettings"})) (clojure.core/contains? input :variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :variables)) #:http.request.field{:name "variables", :shape "MapOfStringToString"})) (clojure.core/contains? input :cache-cluster-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :cache-cluster-enabled)) #:http.request.field{:name "cacheClusterEnabled", :shape "Boolean"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :cache-cluster-size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-cluster-size (input :cache-cluster-size)) #:http.request.field{:name "cacheClusterSize", :shape "CacheClusterSize"}))))

(clojure.core/defn- req-get-models-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-api-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "apiKey", :shape "String", :location "uri", :location-name "api_Key"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-update-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-documentation-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-deployments-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-account-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-import-api-keys-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})], :querystring [(clojure.core/into (ser-api-keys-format (input :format)) #:http.request.field{:name "format", :shape "ApiKeysFormat", :location "querystring", :location-name "format"})]} (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"}))))

(clojure.core/defn- req-get-vpc-links-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-usage-plan-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})], :body [(clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String"}) (clojure.core/into (ser-string (input :key-type)) #:http.request.field{:name "keyType", :shape "String"})]}))

(clojure.core/defn- req-delete-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-import-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})]} (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"}))))

(clojure.core/defn- req-get-documentation-parts-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-documentation-part-type (input :type)) #:http.request.field{:name "type", :shape "DocumentationPartType", :location "querystring", :location-name "type"})) (clojure.core/contains? input :name-query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name-query)) #:http.request.field{:name "nameQuery", :shape "String", :location "querystring", :location-name "name"})) (clojure.core/contains? input :path) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path)) #:http.request.field{:name "path", :shape "String", :location "querystring", :location-name "path"})) (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :location-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-location-status-type (input :location-status)) #:http.request.field{:name "locationStatus", :shape "LocationStatusType", :location "querystring", :location-name "locationStatus"}))))

(clojure.core/defn- req-update-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-delete-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-get-api-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "apiKey", :shape "String", :location "uri", :location-name "api_Key"})]} (clojure.core/contains? input :include-value) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :include-value)) #:http.request.field{:name "includeValue", :shape "NullableBoolean", :location "querystring", :location-name "includeValue"}))))

(clojure.core/defn- req-update-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :vpc-link-id)) #:http.request.field{:name "vpcLinkId", :shape "String", :location "uri", :location-name "vpclink_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-create-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String"})]} (clojure.core/contains? input :certificate-chain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-chain)) #:http.request.field{:name "certificateChain", :shape "String"})) (clojure.core/contains? input :endpoint-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-configuration (input :endpoint-configuration)) #:http.request.field{:name "endpointConfiguration", :shape "EndpointConfiguration"})) (clojure.core/contains? input :certificate-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-arn)) #:http.request.field{:name "certificateArn", :shape "String"})) (clojure.core/contains? input :certificate-private-key) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-private-key)) #:http.request.field{:name "certificatePrivateKey", :shape "String"})) (clojure.core/contains? input :regional-certificate-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :regional-certificate-arn)) #:http.request.field{:name "regionalCertificateArn", :shape "String"})) (clojure.core/contains? input :regional-certificate-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :regional-certificate-name)) #:http.request.field{:name "regionalCertificateName", :shape "String"})) (clojure.core/contains? input :certificate-body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-body)) #:http.request.field{:name "certificateBody", :shape "String"})) (clojure.core/contains? input :certificate-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "String"}))))

(clojure.core/defn- req-flush-stage-authorizers-cache-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-get-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]}))

(clojure.core/defn- req-delete-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "uri", :location-name "deployment_id"})]}))

(clojure.core/defn- req-delete-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :vpc-link-id)) #:http.request.field{:name "vpcLinkId", :shape "String", :location "uri", :location-name "vpclink_id"})]}))

(clojure.core/defn- req-get-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]}))

(clojure.core/defn- req-update-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-put-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})], :body [(clojure.core/into (ser-string (input :authorization-type)) #:http.request.field{:name "authorizationType", :shape "String"})]} (clojure.core/contains? input :authorizer-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String"})) (clojure.core/contains? input :request-validator-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String"})) (clojure.core/contains? input :operation-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :operation-name)) #:http.request.field{:name "operationName", :shape "String"})) (clojure.core/contains? input :request-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-boolean (input :request-parameters)) #:http.request.field{:name "requestParameters", :shape "MapOfStringToBoolean"})) (clojure.core/contains? input :authorization-scopes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :authorization-scopes)) #:http.request.field{:name "authorizationScopes", :shape "ListOfString"})) (clojure.core/contains? input :api-key-required) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :api-key-required)) #:http.request.field{:name "apiKeyRequired", :shape "Boolean"})) (clojure.core/contains? input :request-models) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :request-models)) #:http.request.field{:name "requestModels", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-delete-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]}))

(clojure.core/defn- req-update-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "String", :location "uri", :location-name "resource_arn"})], :querystring [(clojure.core/into (ser-list-of-string (input :tag-keys)) #:http.request.field{:name "tagKeys", :shape "ListOfString", :location "querystring", :location-name "tagKeys"})]}))

(clojure.core/defn- req-delete-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String", :location "uri", :location-name "requestvalidator_id"})]}))

(clojure.core/defn- req-create-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-documentation-part-location (input :location)) #:http.request.field{:name "location", :shape "DocumentationPartLocation"}) (clojure.core/into (ser-string (input :properties)) #:http.request.field{:name "properties", :shape "String"})]}))

(clojure.core/defn- req-update-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String", :location "uri", :location-name "requestvalidator_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-usage-plans-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :key-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "querystring", :location-name "keyId"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-part-id)) #:http.request.field{:name "documentationPartId", :shape "String", :location "uri", :location-name "part_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/declare deser-documentation-part-location-status-code)

(clojure.core/declare deser-rest-api)

(clojure.core/declare deser-double)

(clojure.core/declare deser-list-of-documentation-part)

(clojure.core/declare deser-map-of-method-snapshot)

(clojure.core/declare deser-deployment)

(clojure.core/declare deser-gateway-response-type)

(clojure.core/declare deser-list-of-client-certificate)

(clojure.core/declare deser-method-setting)

(clojure.core/declare deser-status-code)

(clojure.core/declare deser-api-stage)

(clojure.core/declare deser-map-of-method)

(clojure.core/declare deser-list-of-vpc-link)

(clojure.core/declare deser-documentation-part)

(clojure.core/declare deser-map-of-string-to-list)

(clojure.core/declare deser-method-snapshot)

(clojure.core/declare deser-list-of-model)

(clojure.core/declare deser-endpoint-type)

(clojure.core/declare deser-list-of-sdk-configuration-property)

(clojure.core/declare deser-list-of-string)

(clojure.core/declare deser-documentation-part-type)

(clojure.core/declare deser-list-of-request-validator)

(clojure.core/declare deser-list-of-rest-api)

(clojure.core/declare deser-list-of-usage-plan-key)

(clojure.core/declare deser-nullable-boolean)

(clojure.core/declare deser-method-response)

(clojure.core/declare deser-list-of-deployment)

(clojure.core/declare deser-request-validator)

(clojure.core/declare deser-sdk-type)

(clojure.core/declare deser-cache-cluster-status)

(clojure.core/declare deser-list-of-gateway-response)

(clojure.core/declare deser-map-of-string-to-boolean)

(clojure.core/declare deser-map-of-method-settings)

(clojure.core/declare deser-quota-period-type)

(clojure.core/declare deser-usage-plan)

(clojure.core/declare deser-list-of-long)

(clojure.core/declare deser-api-key-source-type)

(clojure.core/declare deser-throttle-settings)

(clojure.core/declare deser-list-of-sdk-type)

(clojure.core/declare deser-cache-cluster-size)

(clojure.core/declare deser-gateway-response)

(clojure.core/declare deser-integration-type)

(clojure.core/declare deser-base-path-mapping)

(clojure.core/declare deser-list-of-resource)

(clojure.core/declare deser-model)

(clojure.core/declare deser-authorizer-type)

(clojure.core/declare deser-list-of-ar-ns)

(clojure.core/declare deser-list-of-api-stage)

(clojure.core/declare deser-method)

(clojure.core/declare deser-list-of-stage)

(clojure.core/declare deser-map-of-method-response)

(clojure.core/declare deser-canary-settings)

(clojure.core/declare deser-list-of-usage)

(clojure.core/declare deser-access-log-settings)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-string)

(clojure.core/declare deser-vpc-link-status)

(clojure.core/declare deser-list-of-documentation-version)

(clojure.core/declare deser-quota-settings)

(clojure.core/declare deser-provider-arn)

(clojure.core/declare deser-path-to-map-of-method-snapshot)

(clojure.core/declare deser-usage-plan-key)

(clojure.core/declare deser-map-of-string-to-string)

(clojure.core/declare deser-connection-type)

(clojure.core/declare deser-documentation-part-location)

(clojure.core/declare deser-client-certificate)

(clojure.core/declare deser-map-of-key-usages)

(clojure.core/declare deser-long)

(clojure.core/declare deser-list-of-authorizer)

(clojure.core/declare deser-timestamp)

(clojure.core/declare deser-list-of-usage-plan)

(clojure.core/declare deser-resource)

(clojure.core/declare deser-list-of-endpoint-type)

(clojure.core/declare deser-sdk-configuration-property)

(clojure.core/declare deser-api-key)

(clojure.core/declare deser-nullable-integer)

(clojure.core/declare deser-domain-name)

(clojure.core/declare deser-list-of-base-path-mapping)

(clojure.core/declare deser-map-of-api-stage-throttle-settings)

(clojure.core/declare deser-blob)

(clojure.core/declare deser-integration)

(clojure.core/declare deser-documentation-version)

(clojure.core/declare deser-unauthorized-cache-control-header-strategy)

(clojure.core/declare deser-list-of-api-key)

(clojure.core/declare deser-integration-response)

(clojure.core/declare deser-list-of-domain-name)

(clojure.core/declare deser-endpoint-configuration)

(clojure.core/declare deser-vpc-link)

(clojure.core/declare deser-stage)

(clojure.core/declare deser-content-handling-strategy)

(clojure.core/declare deser-map-of-integration-response)

(clojure.core/declare deser-authorizer)

(clojure.core/declare deser-boolean)

(clojure.core/defn- deser-documentation-part-location-status-code [input] input)

(clojure.core/defn- deser-rest-api [input] (clojure.core/cond-> {} (clojure.core/contains? input "apiKeySource") (clojure.core/assoc :api-key-source (deser-api-key-source-type (input "apiKeySource"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "binaryMediaTypes") (clojure.core/assoc :binary-media-types (deser-list-of-string (input "binaryMediaTypes"))) (clojure.core/contains? input "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (input "endpointConfiguration"))) (clojure.core/contains? input "policy") (clojure.core/assoc :policy (deser-string (input "policy"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-string (input "version"))) (clojure.core/contains? input "minimumCompressionSize") (clojure.core/assoc :minimum-compression-size (deser-nullable-integer (input "minimumCompressionSize"))) (clojure.core/contains? input "warnings") (clojure.core/assoc :warnings (deser-list-of-string (input "warnings"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description")))))

(clojure.core/defn- deser-double [input] input)

(clojure.core/defn- deser-list-of-documentation-part [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-documentation-part coll))) input))

(clojure.core/defn- deser-map-of-method-snapshot [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method-snapshot v)])) input))

(clojure.core/defn- deser-deployment [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "apiSummary") (clojure.core/assoc :api-summary (deser-path-to-map-of-method-snapshot (input "apiSummary")))))

(clojure.core/defn- deser-gateway-response-type [input] (clojure.core/get {"REQUEST_TOO_LARGE" :request-too-large, "INTEGRATION_TIMEOUT" :integration-timeout, "RESOURCE_NOT_FOUND" :resource-not-found, "AUTHORIZER_CONFIGURATION_ERROR" :authorizer-configuration-error, "INTEGRATION_FAILURE" :integration-failure, "DEFAULT_5XX" :default-5-xx, "UNAUTHORIZED" :unauthorized, "AUTHORIZER_FAILURE" :authorizer-failure, "INVALID_API_KEY" :invalid-api-key, "ACCESS_DENIED" :access-denied, "API_CONFIGURATION_ERROR" :api-configuration-error, "DEFAULT_4XX" :default-4-xx, "INVALID_SIGNATURE" :invalid-signature, "EXPIRED_TOKEN" :expired-token, "UNSUPPORTED_MEDIA_TYPE" :unsupported-media-type, "QUOTA_EXCEEDED" :quota-exceeded, "BAD_REQUEST_PARAMETERS" :bad-request-parameters, "MISSING_AUTHENTICATION_TOKEN" :missing-authentication-token, "BAD_REQUEST_BODY" :bad-request-body, "THROTTLED" :throttled} input))

(clojure.core/defn- deser-list-of-client-certificate [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-client-certificate coll))) input))

(clojure.core/defn- deser-method-setting [input] (clojure.core/cond-> {} (clojure.core/contains? input "loggingLevel") (clojure.core/assoc :logging-level (deser-string (input "loggingLevel"))) (clojure.core/contains? input "metricsEnabled") (clojure.core/assoc :metrics-enabled (deser-boolean (input "metricsEnabled"))) (clojure.core/contains? input "cachingEnabled") (clojure.core/assoc :caching-enabled (deser-boolean (input "cachingEnabled"))) (clojure.core/contains? input "throttlingRateLimit") (clojure.core/assoc :throttling-rate-limit (deser-double (input "throttlingRateLimit"))) (clojure.core/contains? input "cacheTtlInSeconds") (clojure.core/assoc :cache-ttl-in-seconds (deser-integer (input "cacheTtlInSeconds"))) (clojure.core/contains? input "unauthorizedCacheControlHeaderStrategy") (clojure.core/assoc :unauthorized-cache-control-header-strategy (deser-unauthorized-cache-control-header-strategy (input "unauthorizedCacheControlHeaderStrategy"))) (clojure.core/contains? input "cacheDataEncrypted") (clojure.core/assoc :cache-data-encrypted (deser-boolean (input "cacheDataEncrypted"))) (clojure.core/contains? input "throttlingBurstLimit") (clojure.core/assoc :throttling-burst-limit (deser-integer (input "throttlingBurstLimit"))) (clojure.core/contains? input "requireAuthorizationForCacheControl") (clojure.core/assoc :require-authorization-for-cache-control (deser-boolean (input "requireAuthorizationForCacheControl"))) (clojure.core/contains? input "dataTraceEnabled") (clojure.core/assoc :data-trace-enabled (deser-boolean (input "dataTraceEnabled")))))

(clojure.core/defn- deser-status-code [input] input)

(clojure.core/defn- deser-api-stage [input] (clojure.core/cond-> {} (clojure.core/contains? input "apiId") (clojure.core/assoc :api-id (deser-string (input "apiId"))) (clojure.core/contains? input "stage") (clojure.core/assoc :stage (deser-string (input "stage"))) (clojure.core/contains? input "throttle") (clojure.core/assoc :throttle (deser-map-of-api-stage-throttle-settings (input "throttle")))))

(clojure.core/defn- deser-map-of-method [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method v)])) input))

(clojure.core/defn- deser-list-of-vpc-link [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-link coll))) input))

(clojure.core/defn- deser-documentation-part [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-documentation-part-location (input "location"))) (clojure.core/contains? input "properties") (clojure.core/assoc :properties (deser-string (input "properties")))))

(clojure.core/defn- deser-map-of-string-to-list [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-list-of-string v)])) input))

(clojure.core/defn- deser-method-snapshot [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizationType") (clojure.core/assoc :authorization-type (deser-string (input "authorizationType"))) (clojure.core/contains? input "apiKeyRequired") (clojure.core/assoc :api-key-required (deser-boolean (input "apiKeyRequired")))))

(clojure.core/defn- deser-list-of-model [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-model coll))) input))

(clojure.core/defn- deser-endpoint-type [input] (clojure.core/get {"REGIONAL" :regional, "EDGE" :edge, "PRIVATE" :private} input))

(clojure.core/defn- deser-list-of-sdk-configuration-property [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-sdk-configuration-property coll))) input))

(clojure.core/defn- deser-list-of-string [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-documentation-part-type [input] (clojure.core/get {"PATH_PARAMETER" :path-parameter, "API" :api, "REQUEST_HEADER" :request-header, "METHOD" :method, "RESOURCE" :resource, "RESPONSE_HEADER" :response-header, "REQUEST_BODY" :request-body, "QUERY_PARAMETER" :query-parameter, "AUTHORIZER" :authorizer, "MODEL" :model, "RESPONSE" :response, "RESPONSE_BODY" :response-body} input))

(clojure.core/defn- deser-list-of-request-validator [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-request-validator coll))) input))

(clojure.core/defn- deser-list-of-rest-api [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-rest-api coll))) input))

(clojure.core/defn- deser-list-of-usage-plan-key [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-usage-plan-key coll))) input))

(clojure.core/defn- deser-nullable-boolean [input] input)

(clojure.core/defn- deser-method-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-status-code (input "statusCode"))) (clojure.core/contains? input "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-boolean (input "responseParameters"))) (clojure.core/contains? input "responseModels") (clojure.core/assoc :response-models (deser-map-of-string-to-string (input "responseModels")))))

(clojure.core/defn- deser-list-of-deployment [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-deployment coll))) input))

(clojure.core/defn- deser-request-validator [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "validateRequestBody") (clojure.core/assoc :validate-request-body (deser-boolean (input "validateRequestBody"))) (clojure.core/contains? input "validateRequestParameters") (clojure.core/assoc :validate-request-parameters (deser-boolean (input "validateRequestParameters")))))

(clojure.core/defn- deser-sdk-type [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "friendlyName") (clojure.core/assoc :friendly-name (deser-string (input "friendlyName"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "configurationProperties") (clojure.core/assoc :configuration-properties (deser-list-of-sdk-configuration-property (input "configurationProperties")))))

(clojure.core/defn- deser-cache-cluster-status [input] (clojure.core/get {"CREATE_IN_PROGRESS" :create-in-progress, "AVAILABLE" :available, "DELETE_IN_PROGRESS" :delete-in-progress, "NOT_AVAILABLE" :not-available, "FLUSH_IN_PROGRESS" :flush-in-progress} input))

(clojure.core/defn- deser-list-of-gateway-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-gateway-response coll))) input))

(clojure.core/defn- deser-map-of-string-to-boolean [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-nullable-boolean v)])) input))

(clojure.core/defn- deser-map-of-method-settings [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method-setting v)])) input))

(clojure.core/defn- deser-quota-period-type [input] (clojure.core/get {"DAY" :day, "WEEK" :week, "MONTH" :month} input))

(clojure.core/defn- deser-usage-plan [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "apiStages") (clojure.core/assoc :api-stages (deser-list-of-api-stage (input "apiStages"))) (clojure.core/contains? input "throttle") (clojure.core/assoc :throttle (deser-throttle-settings (input "throttle"))) (clojure.core/contains? input "quota") (clojure.core/assoc :quota (deser-quota-settings (input "quota"))) (clojure.core/contains? input "productCode") (clojure.core/assoc :product-code (deser-string (input "productCode")))))

(clojure.core/defn- deser-list-of-long [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-long coll))) input))

(clojure.core/defn- deser-api-key-source-type [input] (clojure.core/get {"HEADER" :header, "AUTHORIZER" :authorizer} input))

(clojure.core/defn- deser-throttle-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "burstLimit") (clojure.core/assoc :burst-limit (deser-integer (input "burstLimit"))) (clojure.core/contains? input "rateLimit") (clojure.core/assoc :rate-limit (deser-double (input "rateLimit")))))

(clojure.core/defn- deser-list-of-sdk-type [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-sdk-type coll))) input))

(clojure.core/defn- deser-cache-cluster-size [input] (clojure.core/get {"0.5" :05, "1.6" :16, "6.1" :61, "13.5" :135, "28.4" :284, "58.2" :582, "118" :118, "237" :237} input))

(clojure.core/defn- deser-gateway-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "responseType") (clojure.core/assoc :response-type (deser-gateway-response-type (input "responseType"))) (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-status-code (input "statusCode"))) (clojure.core/contains? input "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (input "responseParameters"))) (clojure.core/contains? input "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (input "responseTemplates"))) (clojure.core/contains? input "defaultResponse") (clojure.core/assoc :default-response (deser-boolean (input "defaultResponse")))))

(clojure.core/defn- deser-integration-type [input] (clojure.core/get {"HTTP" :http, "AWS" :aws, "MOCK" :mock, "HTTP_PROXY" :http-proxy, "AWS_PROXY" :aws-proxy} input))

(clojure.core/defn- deser-base-path-mapping [input] (clojure.core/cond-> {} (clojure.core/contains? input "basePath") (clojure.core/assoc :base-path (deser-string (input "basePath"))) (clojure.core/contains? input "restApiId") (clojure.core/assoc :rest-api-id (deser-string (input "restApiId"))) (clojure.core/contains? input "stage") (clojure.core/assoc :stage (deser-string (input "stage")))))

(clojure.core/defn- deser-list-of-resource [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource coll))) input))

(clojure.core/defn- deser-model [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "schema") (clojure.core/assoc :schema (deser-string (input "schema"))) (clojure.core/contains? input "contentType") (clojure.core/assoc :content-type (deser-string (input "contentType")))))

(clojure.core/defn- deser-authorizer-type [input] (clojure.core/get {"TOKEN" :token, "REQUEST" :request, "COGNITO_USER_POOLS" :cognito-user-pools} input))

(clojure.core/defn- deser-list-of-ar-ns [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-provider-arn coll))) input))

(clojure.core/defn- deser-list-of-api-stage [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-api-stage coll))) input))

(clojure.core/defn- deser-method [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerId") (clojure.core/assoc :authorizer-id (deser-string (input "authorizerId"))) (clojure.core/contains? input "requestValidatorId") (clojure.core/assoc :request-validator-id (deser-string (input "requestValidatorId"))) (clojure.core/contains? input "authorizationType") (clojure.core/assoc :authorization-type (deser-string (input "authorizationType"))) (clojure.core/contains? input "httpMethod") (clojure.core/assoc :http-method (deser-string (input "httpMethod"))) (clojure.core/contains? input "operationName") (clojure.core/assoc :operation-name (deser-string (input "operationName"))) (clojure.core/contains? input "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-boolean (input "requestParameters"))) (clojure.core/contains? input "authorizationScopes") (clojure.core/assoc :authorization-scopes (deser-list-of-string (input "authorizationScopes"))) (clojure.core/contains? input "apiKeyRequired") (clojure.core/assoc :api-key-required (deser-nullable-boolean (input "apiKeyRequired"))) (clojure.core/contains? input "requestModels") (clojure.core/assoc :request-models (deser-map-of-string-to-string (input "requestModels"))) (clojure.core/contains? input "methodIntegration") (clojure.core/assoc :method-integration (deser-integration (input "methodIntegration"))) (clojure.core/contains? input "methodResponses") (clojure.core/assoc :method-responses (deser-map-of-method-response (input "methodResponses")))))

(clojure.core/defn- deser-list-of-stage [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stage coll))) input))

(clojure.core/defn- deser-map-of-method-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method-response v)])) input))

(clojure.core/defn- deser-canary-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "percentTraffic") (clojure.core/assoc :percent-traffic (deser-double (input "percentTraffic"))) (clojure.core/contains? input "deploymentId") (clojure.core/assoc :deployment-id (deser-string (input "deploymentId"))) (clojure.core/contains? input "stageVariableOverrides") (clojure.core/assoc :stage-variable-overrides (deser-map-of-string-to-string (input "stageVariableOverrides"))) (clojure.core/contains? input "useStageCache") (clojure.core/assoc :use-stage-cache (deser-boolean (input "useStageCache")))))

(clojure.core/defn- deser-list-of-usage [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-list-of-long coll))) input))

(clojure.core/defn- deser-access-log-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "format") (clojure.core/assoc :format (deser-string (input "format"))) (clojure.core/contains? input "destinationArn") (clojure.core/assoc :destination-arn (deser-string (input "destinationArn")))))

(clojure.core/defn- deser-integer [input] input)

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-vpc-link-status [input] (clojure.core/get {"AVAILABLE" :available, "PENDING" :pending, "DELETING" :deleting, "FAILED" :failed} input))

(clojure.core/defn- deser-list-of-documentation-version [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-documentation-version coll))) input))

(clojure.core/defn- deser-quota-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "limit") (clojure.core/assoc :limit (deser-integer (input "limit"))) (clojure.core/contains? input "offset") (clojure.core/assoc :offset (deser-integer (input "offset"))) (clojure.core/contains? input "period") (clojure.core/assoc :period (deser-quota-period-type (input "period")))))

(clojure.core/defn- deser-provider-arn [input] input)

(clojure.core/defn- deser-path-to-map-of-method-snapshot [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-map-of-method-snapshot v)])) input))

(clojure.core/defn- deser-usage-plan-key [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-string (input "type"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-string (input "value"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name")))))

(clojure.core/defn- deser-map-of-string-to-string [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-connection-type [input] (clojure.core/get {"INTERNET" :internet, "VPC_LINK" :vpc-link} input))

(clojure.core/defn- deser-documentation-part-location [input] (clojure.core/cond-> {:type (deser-documentation-part-type (input "type"))} (clojure.core/contains? input "path") (clojure.core/assoc :path (deser-string (input "path"))) (clojure.core/contains? input "method") (clojure.core/assoc :method (deser-string (input "method"))) (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-documentation-part-location-status-code (input "statusCode"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name")))))

(clojure.core/defn- deser-client-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (input "clientCertificateId"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "pemEncodedCertificate") (clojure.core/assoc :pem-encoded-certificate (deser-string (input "pemEncodedCertificate"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "expirationDate") (clojure.core/assoc :expiration-date (deser-timestamp (input "expirationDate")))))

(clojure.core/defn- deser-map-of-key-usages [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-list-of-usage v)])) input))

(clojure.core/defn- deser-long [input] input)

(clojure.core/defn- deser-list-of-authorizer [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-authorizer coll))) input))

(clojure.core/defn- deser-timestamp [input] input)

(clojure.core/defn- deser-list-of-usage-plan [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-usage-plan coll))) input))

(clojure.core/defn- deser-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "parentId") (clojure.core/assoc :parent-id (deser-string (input "parentId"))) (clojure.core/contains? input "pathPart") (clojure.core/assoc :path-part (deser-string (input "pathPart"))) (clojure.core/contains? input "path") (clojure.core/assoc :path (deser-string (input "path"))) (clojure.core/contains? input "resourceMethods") (clojure.core/assoc :resource-methods (deser-map-of-method (input "resourceMethods")))))

(clojure.core/defn- deser-list-of-endpoint-type [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-endpoint-type coll))) input))

(clojure.core/defn- deser-sdk-configuration-property [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "friendlyName") (clojure.core/assoc :friendly-name (deser-string (input "friendlyName"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "required") (clojure.core/assoc :required (deser-boolean (input "required"))) (clojure.core/contains? input "defaultValue") (clojure.core/assoc :default-value (deser-string (input "defaultValue")))))

(clojure.core/defn- deser-api-key [input] (clojure.core/cond-> {} (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "enabled") (clojure.core/assoc :enabled (deser-boolean (input "enabled"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "stageKeys") (clojure.core/assoc :stage-keys (deser-list-of-string (input "stageKeys"))) (clojure.core/contains? input "customerId") (clojure.core/assoc :customer-id (deser-string (input "customerId"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-string (input "value"))) (clojure.core/contains? input "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (input "lastUpdatedDate"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description")))))

(clojure.core/defn- deser-nullable-integer [input] input)

(clojure.core/defn- deser-domain-name [input] (clojure.core/cond-> {} (clojure.core/contains? input "domainName") (clojure.core/assoc :domain-name (deser-string (input "domainName"))) (clojure.core/contains? input "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (input "endpointConfiguration"))) (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-string (input "certificateArn"))) (clojure.core/contains? input "regionalHostedZoneId") (clojure.core/assoc :regional-hosted-zone-id (deser-string (input "regionalHostedZoneId"))) (clojure.core/contains? input "regionalCertificateArn") (clojure.core/assoc :regional-certificate-arn (deser-string (input "regionalCertificateArn"))) (clojure.core/contains? input "regionalCertificateName") (clojure.core/assoc :regional-certificate-name (deser-string (input "regionalCertificateName"))) (clojure.core/contains? input "distributionHostedZoneId") (clojure.core/assoc :distribution-hosted-zone-id (deser-string (input "distributionHostedZoneId"))) (clojure.core/contains? input "certificateUploadDate") (clojure.core/assoc :certificate-upload-date (deser-timestamp (input "certificateUploadDate"))) (clojure.core/contains? input "certificateName") (clojure.core/assoc :certificate-name (deser-string (input "certificateName"))) (clojure.core/contains? input "distributionDomainName") (clojure.core/assoc :distribution-domain-name (deser-string (input "distributionDomainName"))) (clojure.core/contains? input "regionalDomainName") (clojure.core/assoc :regional-domain-name (deser-string (input "regionalDomainName")))))

(clojure.core/defn- deser-list-of-base-path-mapping [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-base-path-mapping coll))) input))

(clojure.core/defn- deser-map-of-api-stage-throttle-settings [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-throttle-settings v)])) input))

(clojure.core/defn- deser-blob [input] (portkey.aws/base64-decode input))

(clojure.core/defn- deser-integration [input] (clojure.core/cond-> {} (clojure.core/contains? input "integrationResponses") (clojure.core/assoc :integration-responses (deser-map-of-integration-response (input "integrationResponses"))) (clojure.core/contains? input "connectionId") (clojure.core/assoc :connection-id (deser-string (input "connectionId"))) (clojure.core/contains? input "uri") (clojure.core/assoc :uri (deser-string (input "uri"))) (clojure.core/contains? input "connectionType") (clojure.core/assoc :connection-type (deser-connection-type (input "connectionType"))) (clojure.core/contains? input "httpMethod") (clojure.core/assoc :http-method (deser-string (input "httpMethod"))) (clojure.core/contains? input "requestTemplates") (clojure.core/assoc :request-templates (deser-map-of-string-to-string (input "requestTemplates"))) (clojure.core/contains? input "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-string (input "requestParameters"))) (clojure.core/contains? input "cacheNamespace") (clojure.core/assoc :cache-namespace (deser-string (input "cacheNamespace"))) (clojure.core/contains? input "passthroughBehavior") (clojure.core/assoc :passthrough-behavior (deser-string (input "passthroughBehavior"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-integration-type (input "type"))) (clojure.core/contains? input "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (input "contentHandling"))) (clojure.core/contains? input "cacheKeyParameters") (clojure.core/assoc :cache-key-parameters (deser-list-of-string (input "cacheKeyParameters"))) (clojure.core/contains? input "credentials") (clojure.core/assoc :credentials (deser-string (input "credentials"))) (clojure.core/contains? input "timeoutInMillis") (clojure.core/assoc :timeout-in-millis (deser-integer (input "timeoutInMillis")))))

(clojure.core/defn- deser-documentation-version [input] (clojure.core/cond-> {} (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-string (input "version"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description")))))

(clojure.core/defn- deser-unauthorized-cache-control-header-strategy [input] (clojure.core/get {"FAIL_WITH_403" :fail-with-403, "SUCCEED_WITH_RESPONSE_HEADER" :succeed-with-response-header, "SUCCEED_WITHOUT_RESPONSE_HEADER" :succeed-without-response-header} input))

(clojure.core/defn- deser-list-of-api-key [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-api-key coll))) input))

(clojure.core/defn- deser-integration-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-status-code (input "statusCode"))) (clojure.core/contains? input "selectionPattern") (clojure.core/assoc :selection-pattern (deser-string (input "selectionPattern"))) (clojure.core/contains? input "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (input "responseParameters"))) (clojure.core/contains? input "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (input "responseTemplates"))) (clojure.core/contains? input "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (input "contentHandling")))))

(clojure.core/defn- deser-list-of-domain-name [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-domain-name coll))) input))

(clojure.core/defn- deser-endpoint-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "types") (clojure.core/assoc :types (deser-list-of-endpoint-type (input "types")))))

(clojure.core/defn- deser-vpc-link [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "targetArns") (clojure.core/assoc :target-arns (deser-list-of-string (input "targetArns"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-vpc-link-status (input "status"))) (clojure.core/contains? input "statusMessage") (clojure.core/assoc :status-message (deser-string (input "statusMessage")))))

(clojure.core/defn- deser-stage [input] (clojure.core/cond-> {} (clojure.core/contains? input "cacheClusterStatus") (clojure.core/assoc :cache-cluster-status (deser-cache-cluster-status (input "cacheClusterStatus"))) (clojure.core/contains? input "webAclArn") (clojure.core/assoc :web-acl-arn (deser-string (input "webAclArn"))) (clojure.core/contains? input "tracingEnabled") (clojure.core/assoc :tracing-enabled (deser-boolean (input "tracingEnabled"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "accessLogSettings") (clojure.core/assoc :access-log-settings (deser-access-log-settings (input "accessLogSettings"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-map-of-string-to-string (input "tags"))) (clojure.core/contains? input "documentationVersion") (clojure.core/assoc :documentation-version (deser-string (input "documentationVersion"))) (clojure.core/contains? input "methodSettings") (clojure.core/assoc :method-settings (deser-map-of-method-settings (input "methodSettings"))) (clojure.core/contains? input "canarySettings") (clojure.core/assoc :canary-settings (deser-canary-settings (input "canarySettings"))) (clojure.core/contains? input "deploymentId") (clojure.core/assoc :deployment-id (deser-string (input "deploymentId"))) (clojure.core/contains? input "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (input "clientCertificateId"))) (clojure.core/contains? input "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (input "lastUpdatedDate"))) (clojure.core/contains? input "variables") (clojure.core/assoc :variables (deser-map-of-string-to-string (input "variables"))) (clojure.core/contains? input "cacheClusterEnabled") (clojure.core/assoc :cache-cluster-enabled (deser-boolean (input "cacheClusterEnabled"))) (clojure.core/contains? input "stageName") (clojure.core/assoc :stage-name (deser-string (input "stageName"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "cacheClusterSize") (clojure.core/assoc :cache-cluster-size (deser-cache-cluster-size (input "cacheClusterSize")))))

(clojure.core/defn- deser-content-handling-strategy [input] (clojure.core/get {"CONVERT_TO_BINARY" :convert-to-binary, "CONVERT_TO_TEXT" :convert-to-text} input))

(clojure.core/defn- deser-map-of-integration-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-integration-response v)])) input))

(clojure.core/defn- deser-authorizer [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerCredentials") (clojure.core/assoc :authorizer-credentials (deser-string (input "authorizerCredentials"))) (clojure.core/contains? input "identityValidationExpression") (clojure.core/assoc :identity-validation-expression (deser-string (input "identityValidationExpression"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-authorizer-type (input "type"))) (clojure.core/contains? input "authorizerResultTtlInSeconds") (clojure.core/assoc :authorizer-result-ttl-in-seconds (deser-nullable-integer (input "authorizerResultTtlInSeconds"))) (clojure.core/contains? input "authorizerUri") (clojure.core/assoc :authorizer-uri (deser-string (input "authorizerUri"))) (clojure.core/contains? input "authType") (clojure.core/assoc :auth-type (deser-string (input "authType"))) (clojure.core/contains? input "identitySource") (clojure.core/assoc :identity-source (deser-string (input "identitySource"))) (clojure.core/contains? input "providerARNs") (clojure.core/assoc :provider-ar-ns (deser-list-of-ar-ns (input "providerARNs")))))

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- response-rest-api ([input] (response-rest-api nil input)) ([resultWrapper1025201 input] (clojure.core/let [rawinput1025200 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025202 {"apiKeySource" (rawinput1025200 "apiKeySource"), "createdDate" (rawinput1025200 "createdDate"), "id" (rawinput1025200 "id"), "name" (rawinput1025200 "name"), "binaryMediaTypes" (rawinput1025200 "binaryMediaTypes"), "endpointConfiguration" (rawinput1025200 "endpointConfiguration"), "policy" (rawinput1025200 "policy"), "version" (rawinput1025200 "version"), "minimumCompressionSize" (rawinput1025200 "minimumCompressionSize"), "warnings" (rawinput1025200 "warnings"), "description" (rawinput1025200 "description")}] (clojure.core/cond-> {} (letvar1025202 "apiKeySource") (clojure.core/assoc :api-key-source (deser-api-key-source-type (clojure.core/get-in letvar1025202 ["apiKeySource"]))) (letvar1025202 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar1025202 ["createdDate"]))) (letvar1025202 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025202 ["id"]))) (letvar1025202 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025202 ["name"]))) (letvar1025202 "binaryMediaTypes") (clojure.core/assoc :binary-media-types (deser-list-of-string (clojure.core/get-in letvar1025202 ["binaryMediaTypes"]))) (letvar1025202 "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (clojure.core/get-in letvar1025202 ["endpointConfiguration"]))) (letvar1025202 "policy") (clojure.core/assoc :policy (deser-string (clojure.core/get-in letvar1025202 ["policy"]))) (letvar1025202 "version") (clojure.core/assoc :version (deser-string (clojure.core/get-in letvar1025202 ["version"]))) (letvar1025202 "minimumCompressionSize") (clojure.core/assoc :minimum-compression-size (deser-nullable-integer (clojure.core/get-in letvar1025202 ["minimumCompressionSize"]))) (letvar1025202 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar1025202 ["warnings"]))) (letvar1025202 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025202 ["description"])))))))

(clojure.core/defn- response-unauthorized-exception ([input] (response-unauthorized-exception nil input)) ([resultWrapper1025204 input] (clojure.core/let [rawinput1025203 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025205 {"message" (rawinput1025203 "message")}] (clojure.core/cond-> {} (letvar1025205 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025205 ["message"])))))))

(clojure.core/defn- response-api-key-ids ([input] (response-api-key-ids nil input)) ([resultWrapper1025207 input] (clojure.core/let [rawinput1025206 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025208 {"ids" (rawinput1025206 "ids"), "warnings" (rawinput1025206 "warnings")}] (clojure.core/cond-> {} (letvar1025208 "ids") (clojure.core/assoc :ids (deser-list-of-string (clojure.core/get-in letvar1025208 ["ids"]))) (letvar1025208 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar1025208 ["warnings"])))))))

(clojure.core/defn- response-deployment ([input] (response-deployment nil input)) ([resultWrapper1025210 input] (clojure.core/let [rawinput1025209 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025211 {"id" (rawinput1025209 "id"), "description" (rawinput1025209 "description"), "createdDate" (rawinput1025209 "createdDate"), "apiSummary" (rawinput1025209 "apiSummary")}] (clojure.core/cond-> {} (letvar1025211 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025211 ["id"]))) (letvar1025211 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025211 ["description"]))) (letvar1025211 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar1025211 ["createdDate"]))) (letvar1025211 "apiSummary") (clojure.core/assoc :api-summary (deser-path-to-map-of-method-snapshot (clojure.core/get-in letvar1025211 ["apiSummary"])))))))

(clojure.core/defn- response-bad-request-exception ([input] (response-bad-request-exception nil input)) ([resultWrapper1025213 input] (clojure.core/let [rawinput1025212 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025214 {"message" (rawinput1025212 "message")}] (clojure.core/cond-> {} (letvar1025214 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025214 ["message"])))))))

(clojure.core/defn- response-test-invoke-authorizer-response ([input] (response-test-invoke-authorizer-response nil input)) ([resultWrapper1025216 input] (clojure.core/let [rawinput1025215 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025217 {"clientStatus" (rawinput1025215 "clientStatus"), "log" (rawinput1025215 "log"), "latency" (rawinput1025215 "latency"), "principalId" (rawinput1025215 "principalId"), "policy" (rawinput1025215 "policy"), "authorization" (rawinput1025215 "authorization"), "claims" (rawinput1025215 "claims")}] (clojure.core/cond-> {} (letvar1025217 "clientStatus") (clojure.core/assoc :client-status (deser-integer (clojure.core/get-in letvar1025217 ["clientStatus"]))) (letvar1025217 "log") (clojure.core/assoc :log (deser-string (clojure.core/get-in letvar1025217 ["log"]))) (letvar1025217 "latency") (clojure.core/assoc :latency (deser-long (clojure.core/get-in letvar1025217 ["latency"]))) (letvar1025217 "principalId") (clojure.core/assoc :principal-id (deser-string (clojure.core/get-in letvar1025217 ["principalId"]))) (letvar1025217 "policy") (clojure.core/assoc :policy (deser-string (clojure.core/get-in letvar1025217 ["policy"]))) (letvar1025217 "authorization") (clojure.core/assoc :authorization (deser-map-of-string-to-list (clojure.core/get-in letvar1025217 ["authorization"]))) (letvar1025217 "claims") (clojure.core/assoc :claims (deser-map-of-string-to-string (clojure.core/get-in letvar1025217 ["claims"])))))))

(clojure.core/defn- response-documentation-part ([input] (response-documentation-part nil input)) ([resultWrapper1025219 input] (clojure.core/let [rawinput1025218 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025220 {"id" (rawinput1025218 "id"), "location" (rawinput1025218 "location"), "properties" (rawinput1025218 "properties")}] (clojure.core/cond-> {} (letvar1025220 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025220 ["id"]))) (letvar1025220 "location") (clojure.core/assoc :location (deser-documentation-part-location (clojure.core/get-in letvar1025220 ["location"]))) (letvar1025220 "properties") (clojure.core/assoc :properties (deser-string (clojure.core/get-in letvar1025220 ["properties"])))))))

(clojure.core/defn- response-rest-apis ([input] (response-rest-apis nil input)) ([resultWrapper1025222 input] (clojure.core/let [rawinput1025221 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025223 {"position" (rawinput1025221 "position"), "item" (rawinput1025221 "item")}] (clojure.core/cond-> {} (letvar1025223 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025223 ["position"]))) (letvar1025223 "item") (clojure.core/assoc :items (deser-list-of-rest-api (clojure.core/get-in letvar1025223 ["item"])))))))

(clojure.core/defn- response-base-path-mappings ([input] (response-base-path-mappings nil input)) ([resultWrapper1025225 input] (clojure.core/let [rawinput1025224 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025226 {"position" (rawinput1025224 "position"), "item" (rawinput1025224 "item")}] (clojure.core/cond-> {} (letvar1025226 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025226 ["position"]))) (letvar1025226 "item") (clojure.core/assoc :items (deser-list-of-base-path-mapping (clojure.core/get-in letvar1025226 ["item"])))))))

(clojure.core/defn- response-documentation-versions ([input] (response-documentation-versions nil input)) ([resultWrapper1025228 input] (clojure.core/let [rawinput1025227 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025229 {"position" (rawinput1025227 "position"), "item" (rawinput1025227 "item")}] (clojure.core/cond-> {} (letvar1025229 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025229 ["position"]))) (letvar1025229 "item") (clojure.core/assoc :items (deser-list-of-documentation-version (clojure.core/get-in letvar1025229 ["item"])))))))

(clojure.core/defn- response-stages ([input] (response-stages nil input)) ([resultWrapper1025231 input] (clojure.core/let [rawinput1025230 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025232 {"item" (rawinput1025230 "item")}] (clojure.core/cond-> {} (letvar1025232 "item") (clojure.core/assoc :item (deser-list-of-stage (clojure.core/get-in letvar1025232 ["item"])))))))

(clojure.core/defn- response-tags ([input] (response-tags nil input)) ([resultWrapper1025234 input] (clojure.core/let [rawinput1025233 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025235 {"tags" (rawinput1025233 "tags")}] (clojure.core/cond-> {} (letvar1025235 "tags") (clojure.core/assoc :tags (deser-map-of-string-to-string (clojure.core/get-in letvar1025235 ["tags"])))))))

(clojure.core/defn- response-template ([input] (response-template nil input)) ([resultWrapper1025237 input] (clojure.core/let [rawinput1025236 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025238 {"value" (rawinput1025236 "value")}] (clojure.core/cond-> {} (letvar1025238 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar1025238 ["value"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper1025240 input] (clojure.core/let [rawinput1025239 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025241 {"Retry-After" (clojure.core/get-in input [:headers "Retry-After"]), "message" (rawinput1025239 "message")}] (clojure.core/cond-> {} (letvar1025241 "Retry-After") (clojure.core/assoc :retry-after-seconds (deser-string (clojure.core/get-in letvar1025241 ["Retry-After"]))) (letvar1025241 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025241 ["message"])))))))

(clojure.core/defn- response-method-response ([input] (response-method-response nil input)) ([resultWrapper1025243 input] (clojure.core/let [rawinput1025242 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025244 {"statusCode" (rawinput1025242 "statusCode"), "responseParameters" (rawinput1025242 "responseParameters"), "responseModels" (rawinput1025242 "responseModels")}] (clojure.core/cond-> {} (letvar1025244 "statusCode") (clojure.core/assoc :status-code (deser-status-code (clojure.core/get-in letvar1025244 ["statusCode"]))) (letvar1025244 "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-boolean (clojure.core/get-in letvar1025244 ["responseParameters"]))) (letvar1025244 "responseModels") (clojure.core/assoc :response-models (deser-map-of-string-to-string (clojure.core/get-in letvar1025244 ["responseModels"])))))))

(clojure.core/defn- response-request-validator ([input] (response-request-validator nil input)) ([resultWrapper1025246 input] (clojure.core/let [rawinput1025245 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025247 {"id" (rawinput1025245 "id"), "name" (rawinput1025245 "name"), "validateRequestBody" (rawinput1025245 "validateRequestBody"), "validateRequestParameters" (rawinput1025245 "validateRequestParameters")}] (clojure.core/cond-> {} (letvar1025247 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025247 ["id"]))) (letvar1025247 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025247 ["name"]))) (letvar1025247 "validateRequestBody") (clojure.core/assoc :validate-request-body (deser-boolean (clojure.core/get-in letvar1025247 ["validateRequestBody"]))) (letvar1025247 "validateRequestParameters") (clojure.core/assoc :validate-request-parameters (deser-boolean (clojure.core/get-in letvar1025247 ["validateRequestParameters"])))))))

(clojure.core/defn- response-sdk-type ([input] (response-sdk-type nil input)) ([resultWrapper1025249 input] (clojure.core/let [rawinput1025248 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025250 {"id" (rawinput1025248 "id"), "friendlyName" (rawinput1025248 "friendlyName"), "description" (rawinput1025248 "description"), "configurationProperties" (rawinput1025248 "configurationProperties")}] (clojure.core/cond-> {} (letvar1025250 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025250 ["id"]))) (letvar1025250 "friendlyName") (clojure.core/assoc :friendly-name (deser-string (clojure.core/get-in letvar1025250 ["friendlyName"]))) (letvar1025250 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025250 ["description"]))) (letvar1025250 "configurationProperties") (clojure.core/assoc :configuration-properties (deser-list-of-sdk-configuration-property (clojure.core/get-in letvar1025250 ["configurationProperties"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper1025252 input] (clojure.core/let [rawinput1025251 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025253 {"Retry-After" (clojure.core/get-in input [:headers "Retry-After"]), "message" (rawinput1025251 "message")}] (clojure.core/cond-> {} (letvar1025253 "Retry-After") (clojure.core/assoc :retry-after-seconds (deser-string (clojure.core/get-in letvar1025253 ["Retry-After"]))) (letvar1025253 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025253 ["message"])))))))

(clojure.core/defn- response-client-certificates ([input] (response-client-certificates nil input)) ([resultWrapper1025255 input] (clojure.core/let [rawinput1025254 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025256 {"position" (rawinput1025254 "position"), "item" (rawinput1025254 "item")}] (clojure.core/cond-> {} (letvar1025256 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025256 ["position"]))) (letvar1025256 "item") (clojure.core/assoc :items (deser-list-of-client-certificate (clojure.core/get-in letvar1025256 ["item"])))))))

(clojure.core/defn- response-request-validators ([input] (response-request-validators nil input)) ([resultWrapper1025258 input] (clojure.core/let [rawinput1025257 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025259 {"position" (rawinput1025257 "position"), "item" (rawinput1025257 "item")}] (clojure.core/cond-> {} (letvar1025259 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025259 ["position"]))) (letvar1025259 "item") (clojure.core/assoc :items (deser-list-of-request-validator (clojure.core/get-in letvar1025259 ["item"])))))))

(clojure.core/defn- response-usage-plan-keys ([input] (response-usage-plan-keys nil input)) ([resultWrapper1025261 input] (clojure.core/let [rawinput1025260 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025262 {"position" (rawinput1025260 "position"), "item" (rawinput1025260 "item")}] (clojure.core/cond-> {} (letvar1025262 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025262 ["position"]))) (letvar1025262 "item") (clojure.core/assoc :items (deser-list-of-usage-plan-key (clojure.core/get-in letvar1025262 ["item"])))))))

(clojure.core/defn- response-usage-plan ([input] (response-usage-plan nil input)) ([resultWrapper1025264 input] (clojure.core/let [rawinput1025263 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025265 {"id" (rawinput1025263 "id"), "name" (rawinput1025263 "name"), "description" (rawinput1025263 "description"), "apiStages" (rawinput1025263 "apiStages"), "throttle" (rawinput1025263 "throttle"), "quota" (rawinput1025263 "quota"), "productCode" (rawinput1025263 "productCode")}] (clojure.core/cond-> {} (letvar1025265 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025265 ["id"]))) (letvar1025265 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025265 ["name"]))) (letvar1025265 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025265 ["description"]))) (letvar1025265 "apiStages") (clojure.core/assoc :api-stages (deser-list-of-api-stage (clojure.core/get-in letvar1025265 ["apiStages"]))) (letvar1025265 "throttle") (clojure.core/assoc :throttle (deser-throttle-settings (clojure.core/get-in letvar1025265 ["throttle"]))) (letvar1025265 "quota") (clojure.core/assoc :quota (deser-quota-settings (clojure.core/get-in letvar1025265 ["quota"]))) (letvar1025265 "productCode") (clojure.core/assoc :product-code (deser-string (clojure.core/get-in letvar1025265 ["productCode"])))))))

(clojure.core/defn- response-too-many-requests-exception ([input] (response-too-many-requests-exception nil input)) ([resultWrapper1025267 input] (clojure.core/let [rawinput1025266 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025268 {"Retry-After" (clojure.core/get-in input [:headers "Retry-After"]), "message" (rawinput1025266 "message")}] (clojure.core/cond-> {} (letvar1025268 "Retry-After") (clojure.core/assoc :retry-after-seconds (deser-string (clojure.core/get-in letvar1025268 ["Retry-After"]))) (letvar1025268 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025268 ["message"])))))))

(clojure.core/defn- response-gateway-response ([input] (response-gateway-response nil input)) ([resultWrapper1025270 input] (clojure.core/let [rawinput1025269 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025271 {"responseType" (rawinput1025269 "responseType"), "statusCode" (rawinput1025269 "statusCode"), "responseParameters" (rawinput1025269 "responseParameters"), "responseTemplates" (rawinput1025269 "responseTemplates"), "defaultResponse" (rawinput1025269 "defaultResponse")}] (clojure.core/cond-> {} (letvar1025271 "responseType") (clojure.core/assoc :response-type (deser-gateway-response-type (clojure.core/get-in letvar1025271 ["responseType"]))) (letvar1025271 "statusCode") (clojure.core/assoc :status-code (deser-status-code (clojure.core/get-in letvar1025271 ["statusCode"]))) (letvar1025271 "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (clojure.core/get-in letvar1025271 ["responseParameters"]))) (letvar1025271 "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (clojure.core/get-in letvar1025271 ["responseTemplates"]))) (letvar1025271 "defaultResponse") (clojure.core/assoc :default-response (deser-boolean (clojure.core/get-in letvar1025271 ["defaultResponse"])))))))

(clojure.core/defn- response-base-path-mapping ([input] (response-base-path-mapping nil input)) ([resultWrapper1025273 input] (clojure.core/let [rawinput1025272 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025274 {"basePath" (rawinput1025272 "basePath"), "restApiId" (rawinput1025272 "restApiId"), "stage" (rawinput1025272 "stage")}] (clojure.core/cond-> {} (letvar1025274 "basePath") (clojure.core/assoc :base-path (deser-string (clojure.core/get-in letvar1025274 ["basePath"]))) (letvar1025274 "restApiId") (clojure.core/assoc :rest-api-id (deser-string (clojure.core/get-in letvar1025274 ["restApiId"]))) (letvar1025274 "stage") (clojure.core/assoc :stage (deser-string (clojure.core/get-in letvar1025274 ["stage"])))))))

(clojure.core/defn- response-documentation-part-ids ([input] (response-documentation-part-ids nil input)) ([resultWrapper1025276 input] (clojure.core/let [rawinput1025275 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025277 {"ids" (rawinput1025275 "ids"), "warnings" (rawinput1025275 "warnings")}] (clojure.core/cond-> {} (letvar1025277 "ids") (clojure.core/assoc :ids (deser-list-of-string (clojure.core/get-in letvar1025277 ["ids"]))) (letvar1025277 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar1025277 ["warnings"])))))))

(clojure.core/defn- response-model ([input] (response-model nil input)) ([resultWrapper1025279 input] (clojure.core/let [rawinput1025278 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025280 {"id" (rawinput1025278 "id"), "name" (rawinput1025278 "name"), "description" (rawinput1025278 "description"), "schema" (rawinput1025278 "schema"), "contentType" (rawinput1025278 "contentType")}] (clojure.core/cond-> {} (letvar1025280 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025280 ["id"]))) (letvar1025280 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025280 ["name"]))) (letvar1025280 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025280 ["description"]))) (letvar1025280 "schema") (clojure.core/assoc :schema (deser-string (clojure.core/get-in letvar1025280 ["schema"]))) (letvar1025280 "contentType") (clojure.core/assoc :content-type (deser-string (clojure.core/get-in letvar1025280 ["contentType"])))))))

(clojure.core/defn- response-domain-names ([input] (response-domain-names nil input)) ([resultWrapper1025282 input] (clojure.core/let [rawinput1025281 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025283 {"position" (rawinput1025281 "position"), "item" (rawinput1025281 "item")}] (clojure.core/cond-> {} (letvar1025283 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025283 ["position"]))) (letvar1025283 "item") (clojure.core/assoc :items (deser-list-of-domain-name (clojure.core/get-in letvar1025283 ["item"])))))))

(clojure.core/defn- response-conflict-exception ([input] (response-conflict-exception nil input)) ([resultWrapper1025285 input] (clojure.core/let [rawinput1025284 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025286 {"message" (rawinput1025284 "message")}] (clojure.core/cond-> {} (letvar1025286 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025286 ["message"])))))))

(clojure.core/defn- response-account ([input] (response-account nil input)) ([resultWrapper1025288 input] (clojure.core/let [rawinput1025287 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025289 {"cloudwatchRoleArn" (rawinput1025287 "cloudwatchRoleArn"), "throttleSettings" (rawinput1025287 "throttleSettings"), "features" (rawinput1025287 "features"), "apiKeyVersion" (rawinput1025287 "apiKeyVersion")}] (clojure.core/cond-> {} (letvar1025289 "cloudwatchRoleArn") (clojure.core/assoc :cloudwatch-role-arn (deser-string (clojure.core/get-in letvar1025289 ["cloudwatchRoleArn"]))) (letvar1025289 "throttleSettings") (clojure.core/assoc :throttle-settings (deser-throttle-settings (clojure.core/get-in letvar1025289 ["throttleSettings"]))) (letvar1025289 "features") (clojure.core/assoc :features (deser-list-of-string (clojure.core/get-in letvar1025289 ["features"]))) (letvar1025289 "apiKeyVersion") (clojure.core/assoc :api-key-version (deser-string (clojure.core/get-in letvar1025289 ["apiKeyVersion"])))))))

(clojure.core/defn- response-test-invoke-method-response ([input] (response-test-invoke-method-response nil input)) ([resultWrapper1025291 input] (clojure.core/let [rawinput1025290 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025292 {"status" (rawinput1025290 "status"), "body" (rawinput1025290 "body"), "headers" (rawinput1025290 "headers"), "multiValueHeaders" (rawinput1025290 "multiValueHeaders"), "log" (rawinput1025290 "log"), "latency" (rawinput1025290 "latency")}] (clojure.core/cond-> {} (letvar1025292 "status") (clojure.core/assoc :status (deser-integer (clojure.core/get-in letvar1025292 ["status"]))) (letvar1025292 "body") (clojure.core/assoc :body (deser-string (clojure.core/get-in letvar1025292 ["body"]))) (letvar1025292 "headers") (clojure.core/assoc :headers (deser-map-of-string-to-string (clojure.core/get-in letvar1025292 ["headers"]))) (letvar1025292 "multiValueHeaders") (clojure.core/assoc :multi-value-headers (deser-map-of-string-to-list (clojure.core/get-in letvar1025292 ["multiValueHeaders"]))) (letvar1025292 "log") (clojure.core/assoc :log (deser-string (clojure.core/get-in letvar1025292 ["log"]))) (letvar1025292 "latency") (clojure.core/assoc :latency (deser-long (clojure.core/get-in letvar1025292 ["latency"])))))))

(clojure.core/defn- response-method ([input] (response-method nil input)) ([resultWrapper1025294 input] (clojure.core/let [rawinput1025293 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025295 {"authorizerId" (rawinput1025293 "authorizerId"), "requestValidatorId" (rawinput1025293 "requestValidatorId"), "authorizationType" (rawinput1025293 "authorizationType"), "httpMethod" (rawinput1025293 "httpMethod"), "operationName" (rawinput1025293 "operationName"), "requestParameters" (rawinput1025293 "requestParameters"), "authorizationScopes" (rawinput1025293 "authorizationScopes"), "apiKeyRequired" (rawinput1025293 "apiKeyRequired"), "requestModels" (rawinput1025293 "requestModels"), "methodIntegration" (rawinput1025293 "methodIntegration"), "methodResponses" (rawinput1025293 "methodResponses")}] (clojure.core/cond-> {} (letvar1025295 "authorizerId") (clojure.core/assoc :authorizer-id (deser-string (clojure.core/get-in letvar1025295 ["authorizerId"]))) (letvar1025295 "requestValidatorId") (clojure.core/assoc :request-validator-id (deser-string (clojure.core/get-in letvar1025295 ["requestValidatorId"]))) (letvar1025295 "authorizationType") (clojure.core/assoc :authorization-type (deser-string (clojure.core/get-in letvar1025295 ["authorizationType"]))) (letvar1025295 "httpMethod") (clojure.core/assoc :http-method (deser-string (clojure.core/get-in letvar1025295 ["httpMethod"]))) (letvar1025295 "operationName") (clojure.core/assoc :operation-name (deser-string (clojure.core/get-in letvar1025295 ["operationName"]))) (letvar1025295 "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-boolean (clojure.core/get-in letvar1025295 ["requestParameters"]))) (letvar1025295 "authorizationScopes") (clojure.core/assoc :authorization-scopes (deser-list-of-string (clojure.core/get-in letvar1025295 ["authorizationScopes"]))) (letvar1025295 "apiKeyRequired") (clojure.core/assoc :api-key-required (deser-nullable-boolean (clojure.core/get-in letvar1025295 ["apiKeyRequired"]))) (letvar1025295 "requestModels") (clojure.core/assoc :request-models (deser-map-of-string-to-string (clojure.core/get-in letvar1025295 ["requestModels"]))) (letvar1025295 "methodIntegration") (clojure.core/assoc :method-integration (deser-integration (clojure.core/get-in letvar1025295 ["methodIntegration"]))) (letvar1025295 "methodResponses") (clojure.core/assoc :method-responses (deser-map-of-method-response (clojure.core/get-in letvar1025295 ["methodResponses"])))))))

(clojure.core/defn- response-resources ([input] (response-resources nil input)) ([resultWrapper1025297 input] (clojure.core/let [rawinput1025296 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025298 {"position" (rawinput1025296 "position"), "item" (rawinput1025296 "item")}] (clojure.core/cond-> {} (letvar1025298 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025298 ["position"]))) (letvar1025298 "item") (clojure.core/assoc :items (deser-list-of-resource (clojure.core/get-in letvar1025298 ["item"])))))))

(clojure.core/defn- response-not-found-exception ([input] (response-not-found-exception nil input)) ([resultWrapper1025300 input] (clojure.core/let [rawinput1025299 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025301 {"message" (rawinput1025299 "message")}] (clojure.core/cond-> {} (letvar1025301 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1025301 ["message"])))))))

(clojure.core/defn- response-sdk-types ([input] (response-sdk-types nil input)) ([resultWrapper1025303 input] (clojure.core/let [rawinput1025302 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025304 {"position" (rawinput1025302 "position"), "item" (rawinput1025302 "item")}] (clojure.core/cond-> {} (letvar1025304 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025304 ["position"]))) (letvar1025304 "item") (clojure.core/assoc :items (deser-list-of-sdk-type (clojure.core/get-in letvar1025304 ["item"])))))))

(clojure.core/defn- response-vpc-links ([input] (response-vpc-links nil input)) ([resultWrapper1025306 input] (clojure.core/let [rawinput1025305 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025307 {"position" (rawinput1025305 "position"), "item" (rawinput1025305 "item")}] (clojure.core/cond-> {} (letvar1025307 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025307 ["position"]))) (letvar1025307 "item") (clojure.core/assoc :items (deser-list-of-vpc-link (clojure.core/get-in letvar1025307 ["item"])))))))

(clojure.core/defn- response-usage-plan-key ([input] (response-usage-plan-key nil input)) ([resultWrapper1025309 input] (clojure.core/let [rawinput1025308 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025310 {"id" (rawinput1025308 "id"), "type" (rawinput1025308 "type"), "value" (rawinput1025308 "value"), "name" (rawinput1025308 "name")}] (clojure.core/cond-> {} (letvar1025310 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025310 ["id"]))) (letvar1025310 "type") (clojure.core/assoc :type (deser-string (clojure.core/get-in letvar1025310 ["type"]))) (letvar1025310 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar1025310 ["value"]))) (letvar1025310 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025310 ["name"])))))))

(clojure.core/defn- response-client-certificate ([input] (response-client-certificate nil input)) ([resultWrapper1025312 input] (clojure.core/let [rawinput1025311 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025313 {"clientCertificateId" (rawinput1025311 "clientCertificateId"), "description" (rawinput1025311 "description"), "pemEncodedCertificate" (rawinput1025311 "pemEncodedCertificate"), "createdDate" (rawinput1025311 "createdDate"), "expirationDate" (rawinput1025311 "expirationDate")}] (clojure.core/cond-> {} (letvar1025313 "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (clojure.core/get-in letvar1025313 ["clientCertificateId"]))) (letvar1025313 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025313 ["description"]))) (letvar1025313 "pemEncodedCertificate") (clojure.core/assoc :pem-encoded-certificate (deser-string (clojure.core/get-in letvar1025313 ["pemEncodedCertificate"]))) (letvar1025313 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar1025313 ["createdDate"]))) (letvar1025313 "expirationDate") (clojure.core/assoc :expiration-date (deser-timestamp (clojure.core/get-in letvar1025313 ["expirationDate"])))))))

(clojure.core/defn- response-api-keys ([input] (response-api-keys nil input)) ([resultWrapper1025315 input] (clojure.core/let [rawinput1025314 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025316 {"warnings" (rawinput1025314 "warnings"), "position" (rawinput1025314 "position"), "item" (rawinput1025314 "item")}] (clojure.core/cond-> {} (letvar1025316 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar1025316 ["warnings"]))) (letvar1025316 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025316 ["position"]))) (letvar1025316 "item") (clojure.core/assoc :items (deser-list-of-api-key (clojure.core/get-in letvar1025316 ["item"])))))))

(clojure.core/defn- response-usage-plans ([input] (response-usage-plans nil input)) ([resultWrapper1025318 input] (clojure.core/let [rawinput1025317 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025319 {"position" (rawinput1025317 "position"), "item" (rawinput1025317 "item")}] (clojure.core/cond-> {} (letvar1025319 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025319 ["position"]))) (letvar1025319 "item") (clojure.core/assoc :items (deser-list-of-usage-plan (clojure.core/get-in letvar1025319 ["item"])))))))

(clojure.core/defn- response-authorizers ([input] (response-authorizers nil input)) ([resultWrapper1025321 input] (clojure.core/let [rawinput1025320 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025322 {"position" (rawinput1025320 "position"), "item" (rawinput1025320 "item")}] (clojure.core/cond-> {} (letvar1025322 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025322 ["position"]))) (letvar1025322 "item") (clojure.core/assoc :items (deser-list-of-authorizer (clojure.core/get-in letvar1025322 ["item"])))))))

(clojure.core/defn- response-usage ([input] (response-usage nil input)) ([resultWrapper1025324 input] (clojure.core/let [rawinput1025323 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025325 {"usagePlanId" (rawinput1025323 "usagePlanId"), "startDate" (rawinput1025323 "startDate"), "endDate" (rawinput1025323 "endDate"), "position" (rawinput1025323 "position"), "values" (rawinput1025323 "values")}] (clojure.core/cond-> {} (letvar1025325 "usagePlanId") (clojure.core/assoc :usage-plan-id (deser-string (clojure.core/get-in letvar1025325 ["usagePlanId"]))) (letvar1025325 "startDate") (clojure.core/assoc :start-date (deser-string (clojure.core/get-in letvar1025325 ["startDate"]))) (letvar1025325 "endDate") (clojure.core/assoc :end-date (deser-string (clojure.core/get-in letvar1025325 ["endDate"]))) (letvar1025325 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025325 ["position"]))) (letvar1025325 "values") (clojure.core/assoc :items (deser-map-of-key-usages (clojure.core/get-in letvar1025325 ["values"])))))))

(clojure.core/defn- response-resource ([input] (response-resource nil input)) ([resultWrapper1025327 input] (clojure.core/let [rawinput1025326 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025328 {"id" (rawinput1025326 "id"), "parentId" (rawinput1025326 "parentId"), "pathPart" (rawinput1025326 "pathPart"), "path" (rawinput1025326 "path"), "resourceMethods" (rawinput1025326 "resourceMethods")}] (clojure.core/cond-> {} (letvar1025328 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025328 ["id"]))) (letvar1025328 "parentId") (clojure.core/assoc :parent-id (deser-string (clojure.core/get-in letvar1025328 ["parentId"]))) (letvar1025328 "pathPart") (clojure.core/assoc :path-part (deser-string (clojure.core/get-in letvar1025328 ["pathPart"]))) (letvar1025328 "path") (clojure.core/assoc :path (deser-string (clojure.core/get-in letvar1025328 ["path"]))) (letvar1025328 "resourceMethods") (clojure.core/assoc :resource-methods (deser-map-of-method (clojure.core/get-in letvar1025328 ["resourceMethods"])))))))

(clojure.core/defn- response-sdk-response ([input] (response-sdk-response nil input)) ([resultWrapper1025330 input] (clojure.core/let [rawinput1025329 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025331 {"Content-Type" (clojure.core/get-in input [:headers "Content-Type"]), "Content-Disposition" (clojure.core/get-in input [:headers "Content-Disposition"]), "body" (rawinput1025329 "body")}] (clojure.core/cond-> {} (letvar1025331 "Content-Type") (clojure.core/assoc :content-type (deser-string (clojure.core/get-in letvar1025331 ["Content-Type"]))) (letvar1025331 "Content-Disposition") (clojure.core/assoc :content-disposition (deser-string (clojure.core/get-in letvar1025331 ["Content-Disposition"]))) (letvar1025331 "body") (clojure.core/assoc :body (deser-blob (clojure.core/get-in letvar1025331 ["body"])))))))

(clojure.core/defn- response-api-key ([input] (response-api-key nil input)) ([resultWrapper1025333 input] (clojure.core/let [rawinput1025332 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025334 {"createdDate" (rawinput1025332 "createdDate"), "enabled" (rawinput1025332 "enabled"), "id" (rawinput1025332 "id"), "stageKeys" (rawinput1025332 "stageKeys"), "customerId" (rawinput1025332 "customerId"), "name" (rawinput1025332 "name"), "value" (rawinput1025332 "value"), "lastUpdatedDate" (rawinput1025332 "lastUpdatedDate"), "description" (rawinput1025332 "description")}] (clojure.core/cond-> {} (letvar1025334 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar1025334 ["createdDate"]))) (letvar1025334 "enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar1025334 ["enabled"]))) (letvar1025334 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025334 ["id"]))) (letvar1025334 "stageKeys") (clojure.core/assoc :stage-keys (deser-list-of-string (clojure.core/get-in letvar1025334 ["stageKeys"]))) (letvar1025334 "customerId") (clojure.core/assoc :customer-id (deser-string (clojure.core/get-in letvar1025334 ["customerId"]))) (letvar1025334 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025334 ["name"]))) (letvar1025334 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar1025334 ["value"]))) (letvar1025334 "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (clojure.core/get-in letvar1025334 ["lastUpdatedDate"]))) (letvar1025334 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025334 ["description"])))))))

(clojure.core/defn- response-domain-name ([input] (response-domain-name nil input)) ([resultWrapper1025336 input] (clojure.core/let [rawinput1025335 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025337 {"domainName" (rawinput1025335 "domainName"), "endpointConfiguration" (rawinput1025335 "endpointConfiguration"), "certificateArn" (rawinput1025335 "certificateArn"), "regionalHostedZoneId" (rawinput1025335 "regionalHostedZoneId"), "regionalCertificateArn" (rawinput1025335 "regionalCertificateArn"), "regionalCertificateName" (rawinput1025335 "regionalCertificateName"), "distributionHostedZoneId" (rawinput1025335 "distributionHostedZoneId"), "certificateUploadDate" (rawinput1025335 "certificateUploadDate"), "certificateName" (rawinput1025335 "certificateName"), "distributionDomainName" (rawinput1025335 "distributionDomainName"), "regionalDomainName" (rawinput1025335 "regionalDomainName")}] (clojure.core/cond-> {} (letvar1025337 "domainName") (clojure.core/assoc :domain-name (deser-string (clojure.core/get-in letvar1025337 ["domainName"]))) (letvar1025337 "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (clojure.core/get-in letvar1025337 ["endpointConfiguration"]))) (letvar1025337 "certificateArn") (clojure.core/assoc :certificate-arn (deser-string (clojure.core/get-in letvar1025337 ["certificateArn"]))) (letvar1025337 "regionalHostedZoneId") (clojure.core/assoc :regional-hosted-zone-id (deser-string (clojure.core/get-in letvar1025337 ["regionalHostedZoneId"]))) (letvar1025337 "regionalCertificateArn") (clojure.core/assoc :regional-certificate-arn (deser-string (clojure.core/get-in letvar1025337 ["regionalCertificateArn"]))) (letvar1025337 "regionalCertificateName") (clojure.core/assoc :regional-certificate-name (deser-string (clojure.core/get-in letvar1025337 ["regionalCertificateName"]))) (letvar1025337 "distributionHostedZoneId") (clojure.core/assoc :distribution-hosted-zone-id (deser-string (clojure.core/get-in letvar1025337 ["distributionHostedZoneId"]))) (letvar1025337 "certificateUploadDate") (clojure.core/assoc :certificate-upload-date (deser-timestamp (clojure.core/get-in letvar1025337 ["certificateUploadDate"]))) (letvar1025337 "certificateName") (clojure.core/assoc :certificate-name (deser-string (clojure.core/get-in letvar1025337 ["certificateName"]))) (letvar1025337 "distributionDomainName") (clojure.core/assoc :distribution-domain-name (deser-string (clojure.core/get-in letvar1025337 ["distributionDomainName"]))) (letvar1025337 "regionalDomainName") (clojure.core/assoc :regional-domain-name (deser-string (clojure.core/get-in letvar1025337 ["regionalDomainName"])))))))

(clojure.core/defn- response-documentation-parts ([input] (response-documentation-parts nil input)) ([resultWrapper1025339 input] (clojure.core/let [rawinput1025338 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025340 {"position" (rawinput1025338 "position"), "item" (rawinput1025338 "item")}] (clojure.core/cond-> {} (letvar1025340 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025340 ["position"]))) (letvar1025340 "item") (clojure.core/assoc :items (deser-list-of-documentation-part (clojure.core/get-in letvar1025340 ["item"])))))))

(clojure.core/defn- response-export-response ([input] (response-export-response nil input)) ([resultWrapper1025342 input] (clojure.core/let [rawinput1025341 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025343 {"Content-Type" (clojure.core/get-in input [:headers "Content-Type"]), "Content-Disposition" (clojure.core/get-in input [:headers "Content-Disposition"]), "body" (rawinput1025341 "body")}] (clojure.core/cond-> {} (letvar1025343 "Content-Type") (clojure.core/assoc :content-type (deser-string (clojure.core/get-in letvar1025343 ["Content-Type"]))) (letvar1025343 "Content-Disposition") (clojure.core/assoc :content-disposition (deser-string (clojure.core/get-in letvar1025343 ["Content-Disposition"]))) (letvar1025343 "body") (clojure.core/assoc :body (deser-blob (clojure.core/get-in letvar1025343 ["body"])))))))

(clojure.core/defn- response-gateway-responses ([input] (response-gateway-responses nil input)) ([resultWrapper1025345 input] (clojure.core/let [rawinput1025344 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025346 {"position" (rawinput1025344 "position"), "item" (rawinput1025344 "item")}] (clojure.core/cond-> {} (letvar1025346 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025346 ["position"]))) (letvar1025346 "item") (clojure.core/assoc :items (deser-list-of-gateway-response (clojure.core/get-in letvar1025346 ["item"])))))))

(clojure.core/defn- response-integration ([input] (response-integration nil input)) ([resultWrapper1025348 input] (clojure.core/let [rawinput1025347 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025349 {"integrationResponses" (rawinput1025347 "integrationResponses"), "connectionId" (rawinput1025347 "connectionId"), "uri" (rawinput1025347 "uri"), "connectionType" (rawinput1025347 "connectionType"), "httpMethod" (rawinput1025347 "httpMethod"), "requestTemplates" (rawinput1025347 "requestTemplates"), "requestParameters" (rawinput1025347 "requestParameters"), "cacheNamespace" (rawinput1025347 "cacheNamespace"), "passthroughBehavior" (rawinput1025347 "passthroughBehavior"), "type" (rawinput1025347 "type"), "contentHandling" (rawinput1025347 "contentHandling"), "cacheKeyParameters" (rawinput1025347 "cacheKeyParameters"), "credentials" (rawinput1025347 "credentials"), "timeoutInMillis" (rawinput1025347 "timeoutInMillis")}] (clojure.core/cond-> {} (letvar1025349 "integrationResponses") (clojure.core/assoc :integration-responses (deser-map-of-integration-response (clojure.core/get-in letvar1025349 ["integrationResponses"]))) (letvar1025349 "connectionId") (clojure.core/assoc :connection-id (deser-string (clojure.core/get-in letvar1025349 ["connectionId"]))) (letvar1025349 "uri") (clojure.core/assoc :uri (deser-string (clojure.core/get-in letvar1025349 ["uri"]))) (letvar1025349 "connectionType") (clojure.core/assoc :connection-type (deser-connection-type (clojure.core/get-in letvar1025349 ["connectionType"]))) (letvar1025349 "httpMethod") (clojure.core/assoc :http-method (deser-string (clojure.core/get-in letvar1025349 ["httpMethod"]))) (letvar1025349 "requestTemplates") (clojure.core/assoc :request-templates (deser-map-of-string-to-string (clojure.core/get-in letvar1025349 ["requestTemplates"]))) (letvar1025349 "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-string (clojure.core/get-in letvar1025349 ["requestParameters"]))) (letvar1025349 "cacheNamespace") (clojure.core/assoc :cache-namespace (deser-string (clojure.core/get-in letvar1025349 ["cacheNamespace"]))) (letvar1025349 "passthroughBehavior") (clojure.core/assoc :passthrough-behavior (deser-string (clojure.core/get-in letvar1025349 ["passthroughBehavior"]))) (letvar1025349 "type") (clojure.core/assoc :type (deser-integration-type (clojure.core/get-in letvar1025349 ["type"]))) (letvar1025349 "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (clojure.core/get-in letvar1025349 ["contentHandling"]))) (letvar1025349 "cacheKeyParameters") (clojure.core/assoc :cache-key-parameters (deser-list-of-string (clojure.core/get-in letvar1025349 ["cacheKeyParameters"]))) (letvar1025349 "credentials") (clojure.core/assoc :credentials (deser-string (clojure.core/get-in letvar1025349 ["credentials"]))) (letvar1025349 "timeoutInMillis") (clojure.core/assoc :timeout-in-millis (deser-integer (clojure.core/get-in letvar1025349 ["timeoutInMillis"])))))))

(clojure.core/defn- response-documentation-version ([input] (response-documentation-version nil input)) ([resultWrapper1025351 input] (clojure.core/let [rawinput1025350 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025352 {"version" (rawinput1025350 "version"), "createdDate" (rawinput1025350 "createdDate"), "description" (rawinput1025350 "description")}] (clojure.core/cond-> {} (letvar1025352 "version") (clojure.core/assoc :version (deser-string (clojure.core/get-in letvar1025352 ["version"]))) (letvar1025352 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar1025352 ["createdDate"]))) (letvar1025352 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025352 ["description"])))))))

(clojure.core/defn- response-integration-response ([input] (response-integration-response nil input)) ([resultWrapper1025354 input] (clojure.core/let [rawinput1025353 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025355 {"statusCode" (rawinput1025353 "statusCode"), "selectionPattern" (rawinput1025353 "selectionPattern"), "responseParameters" (rawinput1025353 "responseParameters"), "responseTemplates" (rawinput1025353 "responseTemplates"), "contentHandling" (rawinput1025353 "contentHandling")}] (clojure.core/cond-> {} (letvar1025355 "statusCode") (clojure.core/assoc :status-code (deser-status-code (clojure.core/get-in letvar1025355 ["statusCode"]))) (letvar1025355 "selectionPattern") (clojure.core/assoc :selection-pattern (deser-string (clojure.core/get-in letvar1025355 ["selectionPattern"]))) (letvar1025355 "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (clojure.core/get-in letvar1025355 ["responseParameters"]))) (letvar1025355 "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (clojure.core/get-in letvar1025355 ["responseTemplates"]))) (letvar1025355 "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (clojure.core/get-in letvar1025355 ["contentHandling"])))))))

(clojure.core/defn- response-vpc-link ([input] (response-vpc-link nil input)) ([resultWrapper1025357 input] (clojure.core/let [rawinput1025356 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025358 {"id" (rawinput1025356 "id"), "name" (rawinput1025356 "name"), "description" (rawinput1025356 "description"), "targetArns" (rawinput1025356 "targetArns"), "status" (rawinput1025356 "status"), "statusMessage" (rawinput1025356 "statusMessage")}] (clojure.core/cond-> {} (letvar1025358 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025358 ["id"]))) (letvar1025358 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025358 ["name"]))) (letvar1025358 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025358 ["description"]))) (letvar1025358 "targetArns") (clojure.core/assoc :target-arns (deser-list-of-string (clojure.core/get-in letvar1025358 ["targetArns"]))) (letvar1025358 "status") (clojure.core/assoc :status (deser-vpc-link-status (clojure.core/get-in letvar1025358 ["status"]))) (letvar1025358 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar1025358 ["statusMessage"])))))))

(clojure.core/defn- response-models ([input] (response-models nil input)) ([resultWrapper1025360 input] (clojure.core/let [rawinput1025359 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025361 {"position" (rawinput1025359 "position"), "item" (rawinput1025359 "item")}] (clojure.core/cond-> {} (letvar1025361 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025361 ["position"]))) (letvar1025361 "item") (clojure.core/assoc :items (deser-list-of-model (clojure.core/get-in letvar1025361 ["item"])))))))

(clojure.core/defn- response-stage ([input] (response-stage nil input)) ([resultWrapper1025363 input] (clojure.core/let [rawinput1025362 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025364 {"cacheClusterStatus" (rawinput1025362 "cacheClusterStatus"), "webAclArn" (rawinput1025362 "webAclArn"), "tracingEnabled" (rawinput1025362 "tracingEnabled"), "createdDate" (rawinput1025362 "createdDate"), "accessLogSettings" (rawinput1025362 "accessLogSettings"), "tags" (rawinput1025362 "tags"), "documentationVersion" (rawinput1025362 "documentationVersion"), "methodSettings" (rawinput1025362 "methodSettings"), "canarySettings" (rawinput1025362 "canarySettings"), "deploymentId" (rawinput1025362 "deploymentId"), "clientCertificateId" (rawinput1025362 "clientCertificateId"), "lastUpdatedDate" (rawinput1025362 "lastUpdatedDate"), "variables" (rawinput1025362 "variables"), "cacheClusterEnabled" (rawinput1025362 "cacheClusterEnabled"), "stageName" (rawinput1025362 "stageName"), "description" (rawinput1025362 "description"), "cacheClusterSize" (rawinput1025362 "cacheClusterSize")}] (clojure.core/cond-> {} (letvar1025364 "cacheClusterStatus") (clojure.core/assoc :cache-cluster-status (deser-cache-cluster-status (clojure.core/get-in letvar1025364 ["cacheClusterStatus"]))) (letvar1025364 "webAclArn") (clojure.core/assoc :web-acl-arn (deser-string (clojure.core/get-in letvar1025364 ["webAclArn"]))) (letvar1025364 "tracingEnabled") (clojure.core/assoc :tracing-enabled (deser-boolean (clojure.core/get-in letvar1025364 ["tracingEnabled"]))) (letvar1025364 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar1025364 ["createdDate"]))) (letvar1025364 "accessLogSettings") (clojure.core/assoc :access-log-settings (deser-access-log-settings (clojure.core/get-in letvar1025364 ["accessLogSettings"]))) (letvar1025364 "tags") (clojure.core/assoc :tags (deser-map-of-string-to-string (clojure.core/get-in letvar1025364 ["tags"]))) (letvar1025364 "documentationVersion") (clojure.core/assoc :documentation-version (deser-string (clojure.core/get-in letvar1025364 ["documentationVersion"]))) (letvar1025364 "methodSettings") (clojure.core/assoc :method-settings (deser-map-of-method-settings (clojure.core/get-in letvar1025364 ["methodSettings"]))) (letvar1025364 "canarySettings") (clojure.core/assoc :canary-settings (deser-canary-settings (clojure.core/get-in letvar1025364 ["canarySettings"]))) (letvar1025364 "deploymentId") (clojure.core/assoc :deployment-id (deser-string (clojure.core/get-in letvar1025364 ["deploymentId"]))) (letvar1025364 "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (clojure.core/get-in letvar1025364 ["clientCertificateId"]))) (letvar1025364 "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (clojure.core/get-in letvar1025364 ["lastUpdatedDate"]))) (letvar1025364 "variables") (clojure.core/assoc :variables (deser-map-of-string-to-string (clojure.core/get-in letvar1025364 ["variables"]))) (letvar1025364 "cacheClusterEnabled") (clojure.core/assoc :cache-cluster-enabled (deser-boolean (clojure.core/get-in letvar1025364 ["cacheClusterEnabled"]))) (letvar1025364 "stageName") (clojure.core/assoc :stage-name (deser-string (clojure.core/get-in letvar1025364 ["stageName"]))) (letvar1025364 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1025364 ["description"]))) (letvar1025364 "cacheClusterSize") (clojure.core/assoc :cache-cluster-size (deser-cache-cluster-size (clojure.core/get-in letvar1025364 ["cacheClusterSize"])))))))

(clojure.core/defn- response-authorizer ([input] (response-authorizer nil input)) ([resultWrapper1025366 input] (clojure.core/let [rawinput1025365 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025367 {"authorizerCredentials" (rawinput1025365 "authorizerCredentials"), "identityValidationExpression" (rawinput1025365 "identityValidationExpression"), "id" (rawinput1025365 "id"), "name" (rawinput1025365 "name"), "type" (rawinput1025365 "type"), "authorizerResultTtlInSeconds" (rawinput1025365 "authorizerResultTtlInSeconds"), "authorizerUri" (rawinput1025365 "authorizerUri"), "authType" (rawinput1025365 "authType"), "identitySource" (rawinput1025365 "identitySource"), "providerARNs" (rawinput1025365 "providerARNs")}] (clojure.core/cond-> {} (letvar1025367 "authorizerCredentials") (clojure.core/assoc :authorizer-credentials (deser-string (clojure.core/get-in letvar1025367 ["authorizerCredentials"]))) (letvar1025367 "identityValidationExpression") (clojure.core/assoc :identity-validation-expression (deser-string (clojure.core/get-in letvar1025367 ["identityValidationExpression"]))) (letvar1025367 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar1025367 ["id"]))) (letvar1025367 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1025367 ["name"]))) (letvar1025367 "type") (clojure.core/assoc :type (deser-authorizer-type (clojure.core/get-in letvar1025367 ["type"]))) (letvar1025367 "authorizerResultTtlInSeconds") (clojure.core/assoc :authorizer-result-ttl-in-seconds (deser-nullable-integer (clojure.core/get-in letvar1025367 ["authorizerResultTtlInSeconds"]))) (letvar1025367 "authorizerUri") (clojure.core/assoc :authorizer-uri (deser-string (clojure.core/get-in letvar1025367 ["authorizerUri"]))) (letvar1025367 "authType") (clojure.core/assoc :auth-type (deser-string (clojure.core/get-in letvar1025367 ["authType"]))) (letvar1025367 "identitySource") (clojure.core/assoc :identity-source (deser-string (clojure.core/get-in letvar1025367 ["identitySource"]))) (letvar1025367 "providerARNs") (clojure.core/assoc :provider-ar-ns (deser-list-of-ar-ns (clojure.core/get-in letvar1025367 ["providerARNs"])))))))

(clojure.core/defn- response-deployments ([input] (response-deployments nil input)) ([resultWrapper1025369 input] (clojure.core/let [rawinput1025368 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1025370 {"position" (rawinput1025368 "position"), "item" (rawinput1025368 "item")}] (clojure.core/cond-> {} (letvar1025370 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar1025370 ["position"]))) (letvar1025370 "item") (clojure.core/assoc :items (deser-list-of-deployment (clojure.core/get-in letvar1025370 ["item"])))))))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-resource-request/parent-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-resource-request/path-part (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-resource-request/rest-api-id :portkey.aws.apigateway.create-resource-request/parent-id :portkey.aws.apigateway.create-resource-request/path-part] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-location-status-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"^([1-5]\d\d|\*|\s*)$" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/mode (clojure.spec.alpha/and :portkey.aws.apigateway/put-mode))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-rest-api-request/rest-api-id :portkey.aws.apigateway.put-rest-api-request/body] :opt-un [:portkey.aws.apigateway.put-rest-api-request/mode :portkey.aws.apigateway.put-rest-api-request/fail-on-warnings :portkey.aws.apigateway.put-rest-api-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-stages-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-stages-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-stages-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-stages-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-stages-request/deployment-id]))

(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/api-key-source (clojure.spec.alpha/and :portkey.aws.apigateway/api-key-source-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/binary-media-types (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/policy (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/minimum-compression-size (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/rest-api (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.rest-api/api-key-source :portkey.aws.apigateway.rest-api/created-date :portkey.aws.apigateway.rest-api/id :portkey.aws.apigateway.rest-api/name :portkey.aws.apigateway.rest-api/binary-media-types :portkey.aws.apigateway.rest-api/endpoint-configuration :portkey.aws.apigateway.rest-api/policy :portkey.aws.apigateway.rest-api/version :portkey.aws.apigateway.rest-api/minimum-compression-size :portkey.aws.apigateway.rest-api/warnings :portkey.aws.apigateway.rest-api/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-domain-name-request/domain-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-resource-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-resource-request/rest-api-id :portkey.aws.apigateway.delete-resource-request/resource-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-usage-plan-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-usage-plan-request/usage-plan-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.unauthorized-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/unauthorized-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.unauthorized-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-vpc-link-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-vpc-link-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-vpc-link-request/target-arns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-vpc-link-request/name :portkey.aws.apigateway.create-vpc-link-request/target-arns] :opt-un [:portkey.aws.apigateway.create-vpc-link-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-documentation-part (clojure.spec.alpha/coll-of :portkey.aws.apigateway/documentation-part))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/embed (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-resources-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-resources-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-resources-request/position :portkey.aws.apigateway.get-resources-request/limit :portkey.aws.apigateway.get-resources-request/embed]))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-key-ids/ids (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key-ids/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-key-ids (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-key-ids/ids :portkey.aws.apigateway.api-key-ids/warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/multi-value-headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/path-with-query-string (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/stage-variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/additional-context (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.test-invoke-authorizer-request/rest-api-id :portkey.aws.apigateway.test-invoke-authorizer-request/authorizer-id] :opt-un [:portkey.aws.apigateway.test-invoke-authorizer-request/headers :portkey.aws.apigateway.test-invoke-authorizer-request/multi-value-headers :portkey.aws.apigateway.test-invoke-authorizer-request/path-with-query-string :portkey.aws.apigateway.test-invoke-authorizer-request/body :portkey.aws.apigateway.test-invoke-authorizer-request/stage-variables :portkey.aws.apigateway.test-invoke-authorizer-request/additional-context]))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/multi-value-headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/path-with-query-string (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/stage-variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.test-invoke-method-request/rest-api-id :portkey.aws.apigateway.test-invoke-method-request/resource-id :portkey.aws.apigateway.test-invoke-method-request/http-method] :opt-un [:portkey.aws.apigateway.test-invoke-method-request/body :portkey.aws.apigateway.test-invoke-method-request/multi-value-headers :portkey.aws.apigateway.test-invoke-method-request/path-with-query-string :portkey.aws.apigateway.test-invoke-method-request/client-certificate-id :portkey.aws.apigateway.test-invoke-method-request/stage-variables :portkey.aws.apigateway.test-invoke-method-request/headers]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method-snapshot (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method-snapshot))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-type-request/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-sdk-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-sdk-type-request/id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/api-summary (clojure.spec.alpha/and :portkey.aws.apigateway/path-to-map-of-method-snapshot))
(clojure.spec.alpha/def :portkey.aws.apigateway/deployment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.deployment/id :portkey.aws.apigateway.deployment/description :portkey.aws.apigateway.deployment/created-date :portkey.aws.apigateway.deployment/api-summary]))

(clojure.spec.alpha/def :portkey.aws.apigateway/gateway-response-type #{:integration-timeout "REQUEST_TOO_LARGE" :unauthorized "INTEGRATION_TIMEOUT" "RESOURCE_NOT_FOUND" :invalid-api-key :integration-failure "AUTHORIZER_CONFIGURATION_ERROR" "INTEGRATION_FAILURE" "DEFAULT_5XX" "UNAUTHORIZED" :quota-exceeded :invalid-signature :expired-token :bad-request-parameters "AUTHORIZER_FAILURE" :unsupported-media-type "INVALID_API_KEY" "ACCESS_DENIED" "API_CONFIGURATION_ERROR" "DEFAULT_4XX" "INVALID_SIGNATURE" :bad-request-body :api-configuration-error "EXPIRED_TOKEN" "UNSUPPORTED_MEDIA_TYPE" :authorizer-configuration-error :default-5-xx :request-too-large :default-4-xx :authorizer-failure :throttled "QUOTA_EXCEEDED" "BAD_REQUEST_PARAMETERS" "MISSING_AUTHENTICATION_TOKEN" :missing-authentication-token "BAD_REQUEST_BODY" :resource-not-found :access-denied "THROTTLED"})

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-client-certificate (clojure.spec.alpha/coll-of :portkey.aws.apigateway/client-certificate))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/sdk-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-sdk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-sdk-request/rest-api-id :portkey.aws.apigateway.get-sdk-request/stage-name :portkey.aws.apigateway.get-sdk-request/sdk-type] :opt-un [:portkey.aws.apigateway.get-sdk-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.bad-request-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/bad-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.bad-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-stage-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-stage-request/rest-api-id :portkey.aws.apigateway.update-stage-request/stage-name] :opt-un [:portkey.aws.apigateway.update-stage-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-method-response-request/rest-api-id :portkey.aws.apigateway.get-method-response-request/resource-id :portkey.aws.apigateway.get-method-response-request/http-method :portkey.aws.apigateway.get-method-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/client-status (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/log (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/latency (clojure.spec.alpha/and :portkey.aws.apigateway/long))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/principal-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/policy (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/authorization (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/claims (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.test-invoke-authorizer-response/client-status :portkey.aws.apigateway.test-invoke-authorizer-response/log :portkey.aws.apigateway.test-invoke-authorizer-response/latency :portkey.aws.apigateway.test-invoke-authorizer-response/principal-id :portkey.aws.apigateway.test-invoke-authorizer-response/policy :portkey.aws.apigateway.test-invoke-authorizer-response/authorization :portkey.aws.apigateway.test-invoke-authorizer-response/claims]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-stage-request/rest-api-id :portkey.aws.apigateway.delete-stage-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/logging-level (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/metrics-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/caching-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/throttling-rate-limit (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/cache-ttl-in-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/unauthorized-cache-control-header-strategy (clojure.spec.alpha/and :portkey.aws.apigateway/unauthorized-cache-control-header-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/cache-data-encrypted (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/throttling-burst-limit (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/require-authorization-for-cache-control (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/data-trace-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/method-setting (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method-setting/logging-level :portkey.aws.apigateway.method-setting/metrics-enabled :portkey.aws.apigateway.method-setting/caching-enabled :portkey.aws.apigateway.method-setting/throttling-rate-limit :portkey.aws.apigateway.method-setting/cache-ttl-in-seconds :portkey.aws.apigateway.method-setting/unauthorized-cache-control-header-strategy :portkey.aws.apigateway.method-setting/cache-data-encrypted :portkey.aws.apigateway.method-setting/throttling-burst-limit :portkey.aws.apigateway.method-setting/require-authorization-for-cache-control :portkey.aws.apigateway.method-setting/data-trace-enabled]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-part-request/documentation-part-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-documentation-part-request/rest-api-id :portkey.aws.apigateway.delete-documentation-part-request/documentation-part-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/status-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[1-5]\d\d" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-stage/api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-stage/stage (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-stage/throttle (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-api-stage-throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-stage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-stage/api-id :portkey.aws.apigateway.api-stage/stage :portkey.aws.apigateway.api-stage/throttle]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-integration-response-request/rest-api-id :portkey.aws.apigateway.get-integration-response-request/resource-id :portkey.aws.apigateway.get-integration-response-request/http-method :portkey.aws.apigateway.get-integration-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-vpc-link (clojure.spec.alpha/coll-of :portkey.aws.apigateway/vpc-link))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part/location (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-location))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part/properties (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-part/id :portkey.aws.apigateway.documentation-part/location :portkey.aws.apigateway.documentation-part/properties]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-string-to-list (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/list-of-string))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resource-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resource-request/embed (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-resource-request/rest-api-id :portkey.aws.apigateway.get-resource-request/resource-id] :opt-un [:portkey.aws.apigateway.get-resource-request/embed]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/start-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/end-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-request/usage-plan-id :portkey.aws.apigateway.get-usage-request/start-date :portkey.aws.apigateway.get-usage-request/end-date] :opt-un [:portkey.aws.apigateway.get-usage-request/key-id :portkey.aws.apigateway.get-usage-request/position :portkey.aws.apigateway.get-usage-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.method-snapshot/authorization-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-snapshot/api-key-required (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/method-snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method-snapshot/authorization-type :portkey.aws.apigateway.method-snapshot/api-key-required]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-base-path-mapping-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-base-path-mapping-request/domain-name :portkey.aws.apigateway.update-base-path-mapping-request/base-path] :opt-un [:portkey.aws.apigateway.update-base-path-mapping-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-model (clojure.spec.alpha/coll-of :portkey.aws.apigateway/model))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-types-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-types-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-sdk-types-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-sdk-types-request/position :portkey.aws.apigateway.get-sdk-types-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/mode (clojure.spec.alpha/and :portkey.aws.apigateway/put-mode))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/import-documentation-parts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.import-documentation-parts-request/rest-api-id :portkey.aws.apigateway.import-documentation-parts-request/body] :opt-un [:portkey.aws.apigateway.import-documentation-parts-request/mode :portkey.aws.apigateway.import-documentation-parts-request/fail-on-warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.generate-client-certificate-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/generate-client-certificate-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.generate-client-certificate-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway/endpoint-type #{:edge :private "REGIONAL" :regional "EDGE" "PRIVATE"})

(clojure.spec.alpha/def :portkey.aws.apigateway.rest-apis/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-apis/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-rest-api))
(clojure.spec.alpha/def :portkey.aws.apigateway/rest-apis (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.rest-apis/position :portkey.aws.apigateway.rest-apis/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-sdk-configuration-property (clojure.spec.alpha/coll-of :portkey.aws.apigateway/sdk-configuration-property))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-client-certificate-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-client-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-client-certificate-request/client-certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mappings/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mappings/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-base-path-mapping))
(clojure.spec.alpha/def :portkey.aws.apigateway/base-path-mappings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.base-path-mappings/position :portkey.aws.apigateway.base-path-mappings/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-deployment-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-deployment-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-deployment-request/rest-api-id :portkey.aws.apigateway.update-deployment-request/deployment-id] :opt-un [:portkey.aws.apigateway.update-deployment-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-versions/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-versions/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-documentation-version))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-versions (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-versions/position :portkey.aws.apigateway.documentation-versions/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-string (clojure.spec.alpha/coll-of :portkey.aws.apigateway/string))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/connection-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/integration-http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/connection-type (clojure.spec.alpha/and :portkey.aws.apigateway/connection-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/request-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/cache-namespace (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/passthrough-behavior (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/type (clojure.spec.alpha/and :portkey.aws.apigateway/integration-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/cache-key-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/timeout-in-millis (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-integration-request/rest-api-id :portkey.aws.apigateway.put-integration-request/resource-id :portkey.aws.apigateway.put-integration-request/http-method :portkey.aws.apigateway.put-integration-request/type] :opt-un [:portkey.aws.apigateway.put-integration-request/connection-id :portkey.aws.apigateway.put-integration-request/uri :portkey.aws.apigateway.put-integration-request/integration-http-method :portkey.aws.apigateway.put-integration-request/connection-type :portkey.aws.apigateway.put-integration-request/request-templates :portkey.aws.apigateway.put-integration-request/request-parameters :portkey.aws.apigateway.put-integration-request/cache-namespace :portkey.aws.apigateway.put-integration-request/passthrough-behavior :portkey.aws.apigateway.put-integration-request/content-handling :portkey.aws.apigateway.put-integration-request/cache-key-parameters :portkey.aws.apigateway.put-integration-request/credentials :portkey.aws.apigateway.put-integration-request/timeout-in-millis]))

(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-type #{:response "PATH_PARAMETER" :api :response-header :method "API" "REQUEST_HEADER" :path-parameter "METHOD" :request-body :resource :request-header "RESOURCE" :response-body :query-parameter "RESPONSE_HEADER" :authorizer "REQUEST_BODY" "QUERY_PARAMETER" "AUTHORIZER" "MODEL" "RESPONSE" "RESPONSE_BODY" :model})

(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-usage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-usage-request/usage-plan-id :portkey.aws.apigateway.update-usage-request/key-id] :opt-un [:portkey.aws.apigateway.update-usage-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-api-key-request/api-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-api-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-api-key-request/api-key] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-part-request/documentation-part-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-part-request/rest-api-id :portkey.aws.apigateway.get-documentation-part-request/documentation-part-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/op (clojure.spec.alpha/and :portkey.aws.apigateway/op))
(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/from (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/patch-operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.patch-operation/op :portkey.aws.apigateway.patch-operation/path :portkey.aws.apigateway.patch-operation/value :portkey.aws.apigateway.patch-operation/from]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mappings-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mappings-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mappings-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-base-path-mappings-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-base-path-mappings-request/domain-name] :opt-un [:portkey.aws.apigateway.get-base-path-mappings-request/position :portkey.aws.apigateway.get-base-path-mappings-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/api-key-source (clojure.spec.alpha/and :portkey.aws.apigateway/api-key-source-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/clone-from (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/binary-media-types (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/policy (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/minimum-compression-size (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-rest-api-request/name] :opt-un [:portkey.aws.apigateway.create-rest-api-request/api-key-source :portkey.aws.apigateway.create-rest-api-request/clone-from :portkey.aws.apigateway.create-rest-api-request/binary-media-types :portkey.aws.apigateway.create-rest-api-request/endpoint-configuration :portkey.aws.apigateway.create-rest-api-request/policy :portkey.aws.apigateway.create-rest-api-request/version :portkey.aws.apigateway.create-rest-api-request/minimum-compression-size :portkey.aws.apigateway.create-rest-api-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/selection-pattern (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-integration-response-request/rest-api-id :portkey.aws.apigateway.put-integration-response-request/resource-id :portkey.aws.apigateway.put-integration-response-request/http-method :portkey.aws.apigateway.put-integration-response-request/status-code] :opt-un [:portkey.aws.apigateway.put-integration-response-request/selection-pattern :portkey.aws.apigateway.put-integration-response-request/response-parameters :portkey.aws.apigateway.put-integration-response-request/response-templates :portkey.aws.apigateway.put-integration-response-request/content-handling]))

(clojure.spec.alpha/def :portkey.aws.apigateway.stages/item (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-stage))
(clojure.spec.alpha/def :portkey.aws.apigateway/stages (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.stages/item]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-request-validator (clojure.spec.alpha/coll-of :portkey.aws.apigateway/request-validator))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-gateway-response-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-gateway-response-request/rest-api-id :portkey.aws.apigateway.update-gateway-response-request/response-type] :opt-un [:portkey.aws.apigateway.update-gateway-response-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-authorizer-request/rest-api-id :portkey.aws.apigateway.get-authorizer-request/authorizer-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-rest-api (clojure.spec.alpha/coll-of :portkey.aws.apigateway/rest-api))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-usage-plan-key (clojure.spec.alpha/coll-of :portkey.aws.apigateway/usage-plan-key))

(clojure.spec.alpha/def :portkey.aws.apigateway.tags/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/tags (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.tags/tags]))

(clojure.spec.alpha/def :portkey.aws.apigateway.template/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/template (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.template/value]))

(clojure.spec.alpha/def :portkey.aws.apigateway.limit-exceeded-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.limit-exceeded-exception/retry-after-seconds :portkey.aws.apigateway.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/export-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/accepts (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-export-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-export-request/rest-api-id :portkey.aws.apigateway.get-export-request/stage-name :portkey.aws.apigateway.get-export-request/export-type] :opt-un [:portkey.aws.apigateway.get-export-request/parameters :portkey.aws.apigateway.get-export-request/accepts]))

(clojure.spec.alpha/def :portkey.aws.apigateway/nullable-boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-client-certificate-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-client-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-client-certificate-request/client-certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.method-response/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-response/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-response/response-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/method-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method-response/status-code :portkey.aws.apigateway.method-response/response-parameters :portkey.aws.apigateway.method-response/response-models]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-deployment (clojure.spec.alpha/coll-of :portkey.aws.apigateway/deployment))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-request/flatten (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-model-request/rest-api-id :portkey.aws.apigateway.get-model-request/model-name] :opt-un [:portkey.aws.apigateway.get-model-request/flatten]))

(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/validate-request-body (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/validate-request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/request-validator (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.request-validator/id :portkey.aws.apigateway.request-validator/name :portkey.aws.apigateway.request-validator/validate-request-body :portkey.aws.apigateway.request-validator/validate-request-parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-documentation-version-request/rest-api-id :portkey.aws.apigateway.create-documentation-version-request/documentation-version] :opt-un [:portkey.aws.apigateway.create-documentation-version-request/stage-name :portkey.aws.apigateway.create-documentation-version-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validators-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validators-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validators-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-request-validators-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-request-validators-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-request-validators-request/position :portkey.aws.apigateway.get-request-validators-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/api-stages (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-api-stage))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/throttle (clojure.spec.alpha/and :portkey.aws.apigateway/throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/quota (clojure.spec.alpha/and :portkey.aws.apigateway/quota-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-usage-plan-request/name] :opt-un [:portkey.aws.apigateway.create-usage-plan-request/description :portkey.aws.apigateway.create-usage-plan-request/api-stages :portkey.aws.apigateway.create-usage-plan-request/throttle :portkey.aws.apigateway.create-usage-plan-request/quota]))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/friendly-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/configuration-properties (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-sdk-configuration-property))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-type/id :portkey.aws.apigateway.sdk-type/friendly-name :portkey.aws.apigateway.sdk-type/description :portkey.aws.apigateway.sdk-type/configuration-properties]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-key-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-key-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plan-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-plan-key-request/usage-plan-id :portkey.aws.apigateway.get-usage-plan-key-request/key-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/cache-cluster-status #{"DELETE_IN_PROGRESS" "AVAILABLE" :flush-in-progress "CREATE_IN_PROGRESS" :delete-in-progress :create-in-progress "NOT_AVAILABLE" "FLUSH_IN_PROGRESS" :not-available :available})

(clojure.spec.alpha/def :portkey.aws.apigateway.service-unavailable-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/service-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.service-unavailable-exception/retry-after-seconds :portkey.aws.apigateway.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificates/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificates/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-client-certificate))
(clojure.spec.alpha/def :portkey.aws.apigateway/client-certificates (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.client-certificates/position :portkey.aws.apigateway.client-certificates/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-gateway-response-request/rest-api-id :portkey.aws.apigateway.put-gateway-response-request/response-type] :opt-un [:portkey.aws.apigateway.put-gateway-response-request/status-code :portkey.aws.apigateway.put-gateway-response-request/response-parameters :portkey.aws.apigateway.put-gateway-response-request/response-templates]))

(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-cache-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-cache-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/flush-stage-cache-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.flush-stage-cache-request/rest-api-id :portkey.aws.apigateway.flush-stage-cache-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-resource-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-resource-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-resource-request/rest-api-id :portkey.aws.apigateway.update-resource-request/resource-id] :opt-un [:portkey.aws.apigateway.update-resource-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-gateway-response (clojure.spec.alpha/coll-of :portkey.aws.apigateway/gateway-response))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-string-to-boolean (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/nullable-boolean))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method-settings (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method-setting))

(clojure.spec.alpha/def :portkey.aws.apigateway/quota-period-type #{"WEEK" :day "MONTH" :week :month "DAY"})

(clojure.spec.alpha/def :portkey.aws.apigateway/put-mode #{:merge :overwrite "overwrite" "merge"})

(clojure.spec.alpha/def :portkey.aws.apigateway.request-validators/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validators/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-request-validator))
(clojure.spec.alpha/def :portkey.aws.apigateway/request-validators (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.request-validators/position :portkey.aws.apigateway.request-validators/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-method-response-request/rest-api-id :portkey.aws.apigateway.delete-method-response-request/resource-id :portkey.aws.apigateway.delete-method-response-request/http-method :portkey.aws.apigateway.delete-method-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-method-request/rest-api-id :portkey.aws.apigateway.get-method-request/resource-id :portkey.aws.apigateway.get-method-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-keys/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-keys/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-usage-plan-key))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plan-keys (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plan-keys/position :portkey.aws.apigateway.usage-plan-keys/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/api-stages (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-api-stage))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/throttle (clojure.spec.alpha/and :portkey.aws.apigateway/throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/quota (clojure.spec.alpha/and :portkey.aws.apigateway/quota-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/product-code (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plan (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plan/id :portkey.aws.apigateway.usage-plan/name :portkey.aws.apigateway.usage-plan/description :portkey.aws.apigateway.usage-plan/api-stages :portkey.aws.apigateway.usage-plan/throttle :portkey.aws.apigateway.usage-plan/quota :portkey.aws.apigateway.usage-plan/product-code]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-long (clojure.spec.alpha/coll-of :portkey.aws.apigateway/long))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/schema (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-model-request/rest-api-id :portkey.aws.apigateway.create-model-request/name :portkey.aws.apigateway.create-model-request/content-type] :opt-un [:portkey.aws.apigateway.create-model-request/description :portkey.aws.apigateway.create-model-request/schema]))

(clojure.spec.alpha/def :portkey.aws.apigateway.too-many-requests-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.too-many-requests-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/too-many-requests-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.too-many-requests-exception/retry-after-seconds :portkey.aws.apigateway.too-many-requests-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.deployment-canary-settings/percent-traffic (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment-canary-settings/stage-variable-overrides (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment-canary-settings/use-stage-cache (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/deployment-canary-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.deployment-canary-settings/percent-traffic :portkey.aws.apigateway.deployment-canary-settings/stage-variable-overrides :portkey.aws.apigateway.deployment-canary-settings/use-stage-cache]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-rest-api-request/rest-api-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-account-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-account-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.update-account-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-rest-apis-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-rest-apis-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-rest-apis-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-rest-apis-request/position :portkey.aws.apigateway.get-rest-apis-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-model-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-model-request/rest-api-id :portkey.aws.apigateway.delete-model-request/model-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.tag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.tag-resource-request/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.tag-resource-request/resource-arn :portkey.aws.apigateway.tag-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/api-key-source-type #{:header "HEADER" :authorizer "AUTHORIZER"})

(clojure.spec.alpha/def :portkey.aws.apigateway.throttle-settings/burst-limit (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.throttle-settings/rate-limit (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway/throttle-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.throttle-settings/burst-limit :portkey.aws.apigateway.throttle-settings/rate-limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-sdk-type (clojure.spec.alpha/coll-of :portkey.aws.apigateway/sdk-type))

(clojure.spec.alpha/def :portkey.aws.apigateway/cache-cluster-size #{"118" "237" :05 "1.6" :118 :61 "0.5" :16 "28.4" :135 "58.2" :284 "6.1" :237 :582 "13.5"})

(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/default-response (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/gateway-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.gateway-response/response-type :portkey.aws.apigateway.gateway-response/status-code :portkey.aws.apigateway.gateway-response/response-parameters :portkey.aws.apigateway.gateway-response/response-templates :portkey.aws.apigateway.gateway-response/default-response]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-template-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-template-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-model-template-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-model-template-request/rest-api-id :portkey.aws.apigateway.get-model-template-request/model-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-integration-response-request/rest-api-id :portkey.aws.apigateway.delete-integration-response-request/resource-id :portkey.aws.apigateway.delete-integration-response-request/http-method :portkey.aws.apigateway.delete-integration-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/integration-type #{:aws "AWS" :aws-proxy "MOCK" "AWS_PROXY" "HTTP_PROXY" :http :http-proxy "HTTP" :mock})

(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mapping/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mapping/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mapping/stage (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/base-path-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.base-path-mapping/base-path :portkey.aws.apigateway.base-path-mapping/rest-api-id :portkey.aws.apigateway.base-path-mapping/stage]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validator-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-request-validator-request/rest-api-id :portkey.aws.apigateway.get-request-validator-request/request-validator-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-resource (clojure.spec.alpha/coll-of :portkey.aws.apigateway/resource))

(clojure.spec.alpha/def :portkey.aws.apigateway/op #{:remove :copy "copy" :replace :move "replace" "remove" "move" "add" :add :test "test"})

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-ids/ids (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-ids/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-ids (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-part-ids/ids :portkey.aws.apigateway.documentation-part-ids/warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizers-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizers-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizers-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-authorizers-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-authorizers-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-authorizers-request/position :portkey.aws.apigateway.get-authorizers-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.model/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/schema (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/model (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.model/id :portkey.aws.apigateway.model/name :portkey.aws.apigateway.model/description :portkey.aws.apigateway.model/schema :portkey.aws.apigateway.model/content-type]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-domain-name-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-domain-name-request/domain-name] :opt-un [:portkey.aws.apigateway.update-domain-name-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-usage-plan-key-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-usage-plan-key-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-usage-plan-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-usage-plan-key-request/usage-plan-id :portkey.aws.apigateway.delete-usage-plan-key-request/key-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-base-path-mapping-request/domain-name :portkey.aws.apigateway.get-base-path-mapping-request/base-path] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/authorizer-type #{:cognito-user-pools :request "TOKEN" :token "COGNITO_USER_POOLS" "REQUEST"})

(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-method-response-request/rest-api-id :portkey.aws.apigateway.update-method-response-request/resource-id :portkey.aws.apigateway.update-method-response-request/http-method :portkey.aws.apigateway.update-method-response-request/status-code] :opt-un [:portkey.aws.apigateway.update-method-response-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-ar-ns (clojure.spec.alpha/coll-of :portkey.aws.apigateway/provider-arn))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-api-stage (clojure.spec.alpha/coll-of :portkey.aws.apigateway/api-stage))

(clojure.spec.alpha/def :portkey.aws.apigateway.domain-names/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-names/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-domain-name))
(clojure.spec.alpha/def :portkey.aws.apigateway/domain-names (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.domain-names/position :portkey.aws.apigateway.domain-names/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-integration-response-request/rest-api-id :portkey.aws.apigateway.update-integration-response-request/resource-id :portkey.aws.apigateway.update-integration-response-request/http-method :portkey.aws.apigateway.update-integration-response-request/status-code] :opt-un [:portkey.aws.apigateway.update-integration-response-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.conflict-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/response-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-method-response-request/rest-api-id :portkey.aws.apigateway.put-method-response-request/resource-id :portkey.aws.apigateway.put-method-response-request/http-method :portkey.aws.apigateway.put-method-response-request/status-code] :opt-un [:portkey.aws.apigateway.put-method-response-request/response-parameters :portkey.aws.apigateway.put-method-response-request/response-models]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-domain-name-request/domain-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.account/cloudwatch-role-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.account/throttle-settings (clojure.spec.alpha/and :portkey.aws.apigateway/throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.account/features (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.account/api-key-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/account (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.account/cloudwatch-role-arn :portkey.aws.apigateway.account/throttle-settings :portkey.aws.apigateway.account/features :portkey.aws.apigateway.account/api-key-version]))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/status (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/multi-value-headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/log (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/latency (clojure.spec.alpha/and :portkey.aws.apigateway/long))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-method-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.test-invoke-method-response/status :portkey.aws.apigateway.test-invoke-method-response/body :portkey.aws.apigateway.test-invoke-method-response/headers :portkey.aws.apigateway.test-invoke-method-response/multi-value-headers :portkey.aws.apigateway.test-invoke-method-response/log :portkey.aws.apigateway.test-invoke-method-response/latency]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-plan-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-plan-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-usage-plan-request/usage-plan-id] :opt-un [:portkey.aws.apigateway.update-usage-plan-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-responses-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-responses-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-responses-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-gateway-responses-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-gateway-responses-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-gateway-responses-request/position :portkey.aws.apigateway.get-gateway-responses-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.method/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/authorization-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/operation-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/authorization-scopes (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/api-key-required (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/request-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/method-integration (clojure.spec.alpha/and :portkey.aws.apigateway/integration))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/method-responses (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-method-response))
(clojure.spec.alpha/def :portkey.aws.apigateway/method (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method/authorizer-id :portkey.aws.apigateway.method/request-validator-id :portkey.aws.apigateway.method/authorization-type :portkey.aws.apigateway.method/http-method :portkey.aws.apigateway.method/operation-name :portkey.aws.apigateway.method/request-parameters :portkey.aws.apigateway.method/authorization-scopes :portkey.aws.apigateway.method/api-key-required :portkey.aws.apigateway.method/request-models :portkey.aws.apigateway.method/method-integration :portkey.aws.apigateway.method/method-responses]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-stage (clojure.spec.alpha/coll-of :portkey.aws.apigateway/stage))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/tracing-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/canary-settings (clojure.spec.alpha/and :portkey.aws.apigateway/deployment-canary-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/stage-description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/cache-cluster-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/cache-cluster-size (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-size))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-deployment-request/rest-api-id] :opt-un [:portkey.aws.apigateway.create-deployment-request/tracing-enabled :portkey.aws.apigateway.create-deployment-request/canary-settings :portkey.aws.apigateway.create-deployment-request/stage-description :portkey.aws.apigateway.create-deployment-request/variables :portkey.aws.apigateway.create-deployment-request/cache-cluster-enabled :portkey.aws.apigateway.create-deployment-request/stage-name :portkey.aws.apigateway.create-deployment-request/description :portkey.aws.apigateway.create-deployment-request/cache-cluster-size]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method-response (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method-response))

(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/percent-traffic (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/stage-variable-overrides (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/use-stage-cache (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/canary-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.canary-settings/percent-traffic :portkey.aws.apigateway.canary-settings/deployment-id :portkey.aws.apigateway.canary-settings/stage-variable-overrides :portkey.aws.apigateway.canary-settings/use-stage-cache]))

(clojure.spec.alpha/def :portkey.aws.apigateway.resources/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resources/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-resource))
(clojure.spec.alpha/def :portkey.aws.apigateway/resources (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.resources/position :portkey.aws.apigateway.resources/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-vpc-link-request/vpc-link-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-vpc-link-request/vpc-link-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-usage (clojure.spec.alpha/coll-of :portkey.aws.apigateway/list-of-long))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/validate-request-body (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/validate-request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-request-validator-request/rest-api-id] :opt-un [:portkey.aws.apigateway.create-request-validator-request/name :portkey.aws.apigateway.create-request-validator-request/validate-request-body :portkey.aws.apigateway.create-request-validator-request/validate-request-parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-version-request/rest-api-id :portkey.aws.apigateway.get-documentation-version-request/documentation-version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.stage-key/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage-key/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/stage-key (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.stage-key/rest-api-id :portkey.aws.apigateway.stage-key/stage-name]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/name-query (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/customer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/include-values (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-api-keys-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-api-keys-request/position :portkey.aws.apigateway.get-api-keys-request/limit :portkey.aws.apigateway.get-api-keys-request/name-query :portkey.aws.apigateway.get-api-keys-request/customer-id :portkey.aws.apigateway.get-api-keys-request/include-values]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/name-query (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plan-keys-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-plan-keys-request/usage-plan-id] :opt-un [:portkey.aws.apigateway.get-usage-plan-keys-request/position :portkey.aws.apigateway.get-usage-plan-keys-request/limit :portkey.aws.apigateway.get-usage-plan-keys-request/name-query]))

(clojure.spec.alpha/def :portkey.aws.apigateway.not-found-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-client-certificate-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-client-certificate-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-client-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-client-certificate-request/client-certificate-id] :opt-un [:portkey.aws.apigateway.update-client-certificate-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/generate-distinct-id (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/stage-keys (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-stage-keys))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/customer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-api-key-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.create-api-key-request/name :portkey.aws.apigateway.create-api-key-request/description :portkey.aws.apigateway.create-api-key-request/enabled :portkey.aws.apigateway.create-api-key-request/generate-distinct-id :portkey.aws.apigateway.create-api-key-request/value :portkey.aws.apigateway.create-api-key-request/stage-keys :portkey.aws.apigateway.create-api-key-request/customer-id]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployment-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployment-request/embed (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-deployment-request/rest-api-id :portkey.aws.apigateway.get-deployment-request/deployment-id] :opt-un [:portkey.aws.apigateway.get-deployment-request/embed]))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-types/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-types/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-sdk-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-types (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-types/position :portkey.aws.apigateway.sdk-types/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.access-log-settings/format (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.access-log-settings/destination-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/access-log-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.access-log-settings/format :portkey.aws.apigateway.access-log-settings/destination-arn]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-documentation-version-request/rest-api-id :portkey.aws.apigateway.delete-documentation-version-request/documentation-version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-client-certificates-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-client-certificates-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-client-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-client-certificates-request/position :portkey.aws.apigateway.get-client-certificates-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.apigateway/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-base-path-mapping-request/domain-name :portkey.aws.apigateway.delete-base-path-mapping-request/base-path] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/vpc-link-status #{:pending "AVAILABLE" "PENDING" :deleting "DELETING" "FAILED" :available :failed})

(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-links/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-links/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-vpc-link))
(clojure.spec.alpha/def :portkey.aws.apigateway/vpc-links (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.vpc-links/position :portkey.aws.apigateway.vpc-links/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-documentation-version (clojure.spec.alpha/coll-of :portkey.aws.apigateway/documentation-version))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-model-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-model-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-model-request/rest-api-id :portkey.aws.apigateway.update-model-request/model-name] :opt-un [:portkey.aws.apigateway.update-model-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.quota-settings/limit (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.quota-settings/offset (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.quota-settings/period (clojure.spec.alpha/and :portkey.aws.apigateway/quota-period-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/quota-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.quota-settings/limit :portkey.aws.apigateway.quota-settings/offset :portkey.aws.apigateway.quota-settings/period]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-version-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-documentation-version-request/rest-api-id :portkey.aws.apigateway.update-documentation-version-request/documentation-version] :opt-un [:portkey.aws.apigateway.update-documentation-version-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-stage-request/rest-api-id :portkey.aws.apigateway.get-stage-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/provider-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.apigateway/path-to-map-of-method-snapshot (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/map-of-method-snapshot))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plan-key (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plan-key/id :portkey.aws.apigateway.usage-plan-key/type :portkey.aws.apigateway.usage-plan-key/value :portkey.aws.apigateway.usage-plan-key/name]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-string-to-string (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/string))

(clojure.spec.alpha/def :portkey.aws.apigateway/connection-type #{:vpc-link "INTERNET" :internet "VPC_LINK"})

(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/authorizer-credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/identity-validation-expression (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/type (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/authorizer-result-ttl-in-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/authorizer-uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/auth-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/identity-source (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/provider-ar-ns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-ar-ns))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-authorizer-request/rest-api-id :portkey.aws.apigateway.create-authorizer-request/name :portkey.aws.apigateway.create-authorizer-request/type] :opt-un [:portkey.aws.apigateway.create-authorizer-request/authorizer-credentials :portkey.aws.apigateway.create-authorizer-request/identity-validation-expression :portkey.aws.apigateway.create-authorizer-request/authorizer-result-ttl-in-seconds :portkey.aws.apigateway.create-authorizer-request/authorizer-uri :portkey.aws.apigateway.create-authorizer-request/auth-type :portkey.aws.apigateway.create-authorizer-request/identity-source :portkey.aws.apigateway.create-authorizer-request/provider-ar-ns]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-gateway-response-request/rest-api-id :portkey.aws.apigateway.delete-gateway-response-request/response-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-tags-request/resource-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-tags-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-tags-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-tags-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-tags-request/resource-arn] :opt-un [:portkey.aws.apigateway.get-tags-request/position :portkey.aws.apigateway.get-tags-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-gateway-response-request/rest-api-id :portkey.aws.apigateway.get-gateway-response-request/response-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-domain-names-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-domain-names-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-domain-names-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-domain-names-request/position :portkey.aws.apigateway.get-domain-names-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/type (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-location-status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-location (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.documentation-part-location/type] :opt-un [:portkey.aws.apigateway.documentation-part-location/path :portkey.aws.apigateway.documentation-part-location/method :portkey.aws.apigateway.documentation-part-location/status-code :portkey.aws.apigateway.documentation-part-location/name]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/stage (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-base-path-mapping-request/domain-name :portkey.aws.apigateway.create-base-path-mapping-request/rest-api-id] :opt-un [:portkey.aws.apigateway.create-base-path-mapping-request/base-path :portkey.aws.apigateway.create-base-path-mapping-request/stage]))

(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/pem-encoded-certificate (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/expiration-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway/client-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.client-certificate/client-certificate-id :portkey.aws.apigateway.client-certificate/description :portkey.aws.apigateway.client-certificate/pem-encoded-certificate :portkey.aws.apigateway.client-certificate/created-date :portkey.aws.apigateway.client-certificate/expiration-date]))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-keys/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-keys/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-keys/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-api-key))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-keys (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-keys/warnings :portkey.aws.apigateway.api-keys/position :portkey.aws.apigateway.api-keys/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plans/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plans/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-usage-plan))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plans (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plans/position :portkey.aws.apigateway.usage-plans/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-key-usages (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/list-of-usage))

(clojure.spec.alpha/def :portkey.aws.apigateway/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-authorizer (clojure.spec.alpha/coll-of :portkey.aws.apigateway/authorizer))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/tracing-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/canary-settings (clojure.spec.alpha/and :portkey.aws.apigateway/canary-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/cache-cluster-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/cache-cluster-size (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-size))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-stage-request/rest-api-id :portkey.aws.apigateway.create-stage-request/stage-name :portkey.aws.apigateway.create-stage-request/deployment-id] :opt-un [:portkey.aws.apigateway.create-stage-request/tracing-enabled :portkey.aws.apigateway.create-stage-request/tags :portkey.aws.apigateway.create-stage-request/documentation-version :portkey.aws.apigateway.create-stage-request/canary-settings :portkey.aws.apigateway.create-stage-request/variables :portkey.aws.apigateway.create-stage-request/cache-cluster-enabled :portkey.aws.apigateway.create-stage-request/description :portkey.aws.apigateway.create-stage-request/cache-cluster-size]))

(clojure.spec.alpha/def :portkey.aws.apigateway/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.apigateway.authorizers/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizers/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-authorizer))
(clojure.spec.alpha/def :portkey.aws.apigateway/authorizers (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.authorizers/position :portkey.aws.apigateway.authorizers/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-models-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-models-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-models-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-models-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-models-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-models-request/position :portkey.aws.apigateway.get-models-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-api-key-request/api-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-api-key-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-api-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-api-key-request/api-key] :opt-un [:portkey.aws.apigateway.update-api-key-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/start-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/end-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/items (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-key-usages))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage/usage-plan-id :portkey.aws.apigateway.usage/start-date :portkey.aws.apigateway.usage/end-date :portkey.aws.apigateway.usage/position :portkey.aws.apigateway.usage/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-rest-api-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-rest-api-request/rest-api-id] :opt-un [:portkey.aws.apigateway.update-rest-api-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/api-keys-format #{:csv "csv"})

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-versions-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-versions-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-versions-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-versions-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-documentation-versions-request/position :portkey.aws.apigateway.get-documentation-versions-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployments-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployments-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployments-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-deployments-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-deployments-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-deployments-request/position :portkey.aws.apigateway.get-deployments-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway/get-account-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-usage-plan (clojure.spec.alpha/coll-of :portkey.aws.apigateway/usage-plan))

(clojure.spec.alpha/def :portkey.aws.apigateway.import-api-keys-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-api-keys-request/format (clojure.spec.alpha/and :portkey.aws.apigateway/api-keys-format))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-api-keys-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/import-api-keys-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.import-api-keys-request/body :portkey.aws.apigateway.import-api-keys-request/format] :opt-un [:portkey.aws.apigateway.import-api-keys-request/fail-on-warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-vpc-links-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-vpc-links-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-vpc-links-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-vpc-links-request/position :portkey.aws.apigateway.get-vpc-links-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.resource/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/parent-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/path-part (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/resource-methods (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-method))
(clojure.spec.alpha/def :portkey.aws.apigateway/resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.resource/id :portkey.aws.apigateway.resource/parent-id :portkey.aws.apigateway.resource/path-part :portkey.aws.apigateway.resource/path :portkey.aws.apigateway.resource/resource-methods]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-endpoint-type (clojure.spec.alpha/coll-of :portkey.aws.apigateway/endpoint-type))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-key-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-key-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-key-request/key-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-usage-plan-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-usage-plan-key-request/usage-plan-id :portkey.aws.apigateway.create-usage-plan-key-request/key-id :portkey.aws.apigateway.create-usage-plan-key-request/key-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-patch-operation (clojure.spec.alpha/coll-of :portkey.aws.apigateway/patch-operation))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/friendly-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/required (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/default-value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-configuration-property (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-configuration-property/name :portkey.aws.apigateway.sdk-configuration-property/friendly-name :portkey.aws.apigateway.sdk-configuration-property/description :portkey.aws.apigateway.sdk-configuration-property/required :portkey.aws.apigateway.sdk-configuration-property/default-value]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-integration-request/rest-api-id :portkey.aws.apigateway.delete-integration-request/resource-id :portkey.aws.apigateway.delete-integration-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-response/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-response/content-disposition (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-response/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-response/content-type :portkey.aws.apigateway.sdk-response/content-disposition :portkey.aws.apigateway.sdk-response/body]))

(clojure.spec.alpha/def :portkey.aws.apigateway.import-rest-api-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-rest-api-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-rest-api-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/import-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.import-rest-api-request/body] :opt-un [:portkey.aws.apigateway.import-rest-api-request/fail-on-warnings :portkey.aws.apigateway.import-rest-api-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/type (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/name-query (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/location-status (clojure.spec.alpha/and :portkey.aws.apigateway/location-status-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-parts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-parts-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-documentation-parts-request/type :portkey.aws.apigateway.get-documentation-parts-request/name-query :portkey.aws.apigateway.get-documentation-parts-request/path :portkey.aws.apigateway.get-documentation-parts-request/position :portkey.aws.apigateway.get-documentation-parts-request/limit :portkey.aws.apigateway.get-documentation-parts-request/location-status]))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/stage-keys (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/customer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/last-updated-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-key (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-key/created-date :portkey.aws.apigateway.api-key/enabled :portkey.aws.apigateway.api-key/id :portkey.aws.apigateway.api-key/stage-keys :portkey.aws.apigateway.api-key/customer-id :portkey.aws.apigateway.api-key/name :portkey.aws.apigateway.api-key/value :portkey.aws.apigateway.api-key/last-updated-date :portkey.aws.apigateway.api-key/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway/nullable-integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-method-request/rest-api-id :portkey.aws.apigateway.update-method-request/resource-id :portkey.aws.apigateway.update-method-request/http-method] :opt-un [:portkey.aws.apigateway.update-method-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-hosted-zone-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/distribution-hosted-zone-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/certificate-upload-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/distribution-domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/domain-name (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.domain-name/domain-name :portkey.aws.apigateway.domain-name/endpoint-configuration :portkey.aws.apigateway.domain-name/certificate-arn :portkey.aws.apigateway.domain-name/regional-hosted-zone-id :portkey.aws.apigateway.domain-name/regional-certificate-arn :portkey.aws.apigateway.domain-name/regional-certificate-name :portkey.aws.apigateway.domain-name/distribution-hosted-zone-id :portkey.aws.apigateway.domain-name/certificate-upload-date :portkey.aws.apigateway.domain-name/certificate-name :portkey.aws.apigateway.domain-name/distribution-domain-name :portkey.aws.apigateway.domain-name/regional-domain-name]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-base-path-mapping (clojure.spec.alpha/coll-of :portkey.aws.apigateway/base-path-mapping))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-api-stage-throttle-settings (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/throttle-settings))

(clojure.spec.alpha/def :portkey.aws.apigateway/blob clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-integration-request/rest-api-id :portkey.aws.apigateway.get-integration-request/resource-id :portkey.aws.apigateway.get-integration-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-parts/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-parts/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-documentation-part))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-parts (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-parts/position :portkey.aws.apigateway.documentation-parts/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.export-response/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.export-response/content-disposition (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.export-response/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/export-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.export-response/content-type :portkey.aws.apigateway.export-response/content-disposition :portkey.aws.apigateway.export-response/body]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-method-request/rest-api-id :portkey.aws.apigateway.delete-method-request/resource-id :portkey.aws.apigateway.delete-method-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-key-request/api-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-key-request/include-value (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-api-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-api-key-request/api-key] :opt-un [:portkey.aws.apigateway.get-api-key-request/include-value]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-vpc-link-request/vpc-link-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-vpc-link-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-vpc-link-request/vpc-link-id] :opt-un [:portkey.aws.apigateway.update-vpc-link-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-responses/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-responses/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-gateway-response))
(clojure.spec.alpha/def :portkey.aws.apigateway/gateway-responses (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.gateway-responses/position :portkey.aws.apigateway.gateway-responses/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-chain (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-private-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/regional-certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/regional-certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-domain-name-request/domain-name] :opt-un [:portkey.aws.apigateway.create-domain-name-request/certificate-chain :portkey.aws.apigateway.create-domain-name-request/endpoint-configuration :portkey.aws.apigateway.create-domain-name-request/certificate-arn :portkey.aws.apigateway.create-domain-name-request/certificate-private-key :portkey.aws.apigateway.create-domain-name-request/regional-certificate-arn :portkey.aws.apigateway.create-domain-name-request/regional-certificate-name :portkey.aws.apigateway.create-domain-name-request/certificate-body :portkey.aws.apigateway.create-domain-name-request/certificate-name]))

(clojure.spec.alpha/def :portkey.aws.apigateway.integration/integration-responses (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-integration-response))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/connection-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/connection-type (clojure.spec.alpha/and :portkey.aws.apigateway/connection-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/request-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/cache-namespace (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/passthrough-behavior (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/type (clojure.spec.alpha/and :portkey.aws.apigateway/integration-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/cache-key-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/timeout-in-millis (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/integration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.integration/integration-responses :portkey.aws.apigateway.integration/connection-id :portkey.aws.apigateway.integration/uri :portkey.aws.apigateway.integration/connection-type :portkey.aws.apigateway.integration/http-method :portkey.aws.apigateway.integration/request-templates :portkey.aws.apigateway.integration/request-parameters :portkey.aws.apigateway.integration/cache-namespace :portkey.aws.apigateway.integration/passthrough-behavior :portkey.aws.apigateway.integration/type :portkey.aws.apigateway.integration/content-handling :portkey.aws.apigateway.integration/cache-key-parameters :portkey.aws.apigateway.integration/credentials :portkey.aws.apigateway.integration/timeout-in-millis]))

(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-authorizers-cache-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-authorizers-cache-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/flush-stage-authorizers-cache-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.flush-stage-authorizers-cache-request/rest-api-id :portkey.aws.apigateway.flush-stage-authorizers-cache-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-version/version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-version/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-version/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-version/version :portkey.aws.apigateway.documentation-version/created-date :portkey.aws.apigateway.documentation-version/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-plan-request/usage-plan-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/unauthorized-cache-control-header-strategy #{"SUCCEED_WITHOUT_RESPONSE_HEADER" :fail-with-403 :succeed-without-response-header "FAIL_WITH_403" :succeed-with-response-header "SUCCEED_WITH_RESPONSE_HEADER"})

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-deployment-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-deployment-request/rest-api-id :portkey.aws.apigateway.delete-deployment-request/deployment-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-vpc-link-request/vpc-link-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-vpc-link-request/vpc-link-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-api-key (clojure.spec.alpha/coll-of :portkey.aws.apigateway/api-key))

(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/selection-pattern (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway/integration-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.integration-response/status-code :portkey.aws.apigateway.integration-response/selection-pattern :portkey.aws.apigateway.integration-response/response-parameters :portkey.aws.apigateway.integration-response/response-templates :portkey.aws.apigateway.integration-response/content-handling]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-domain-name (clojure.spec.alpha/coll-of :portkey.aws.apigateway/domain-name))

(clojure.spec.alpha/def :portkey.aws.apigateway/location-status-type #{:undocumented "UNDOCUMENTED" "DOCUMENTED" :documented})

(clojure.spec.alpha/def :portkey.aws.apigateway.get-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-rest-api-request/rest-api-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.endpoint-configuration/types (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-endpoint-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/endpoint-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.endpoint-configuration/types]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-integration-request/rest-api-id :portkey.aws.apigateway.update-integration-request/resource-id :portkey.aws.apigateway.update-integration-request/http-method] :opt-un [:portkey.aws.apigateway.update-integration-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/authorization-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/operation-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/authorization-scopes (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/api-key-required (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/request-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-method-request/rest-api-id :portkey.aws.apigateway.put-method-request/resource-id :portkey.aws.apigateway.put-method-request/http-method :portkey.aws.apigateway.put-method-request/authorization-type] :opt-un [:portkey.aws.apigateway.put-method-request/authorizer-id :portkey.aws.apigateway.put-method-request/request-validator-id :portkey.aws.apigateway.put-method-request/operation-name :portkey.aws.apigateway.put-method-request/request-parameters :portkey.aws.apigateway.put-method-request/authorization-scopes :portkey.aws.apigateway.put-method-request/api-key-required :portkey.aws.apigateway.put-method-request/request-models]))

(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/target-arns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/status (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link-status))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/status-message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/vpc-link (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.vpc-link/id :portkey.aws.apigateway.vpc-link/name :portkey.aws.apigateway.vpc-link/description :portkey.aws.apigateway.vpc-link/target-arns :portkey.aws.apigateway.vpc-link/status :portkey.aws.apigateway.vpc-link/status-message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.models/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.models/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-model))
(clojure.spec.alpha/def :portkey.aws.apigateway/models (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.models/position :portkey.aws.apigateway.models/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-authorizer-request/rest-api-id :portkey.aws.apigateway.delete-authorizer-request/authorizer-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.stage/cache-cluster-status (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-status))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/web-acl-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/tracing-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/access-log-settings (clojure.spec.alpha/and :portkey.aws.apigateway/access-log-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/method-settings (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-method-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/canary-settings (clojure.spec.alpha/and :portkey.aws.apigateway/canary-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/last-updated-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/cache-cluster-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/cache-cluster-size (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-size))
(clojure.spec.alpha/def :portkey.aws.apigateway/stage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.stage/cache-cluster-status :portkey.aws.apigateway.stage/web-acl-arn :portkey.aws.apigateway.stage/tracing-enabled :portkey.aws.apigateway.stage/created-date :portkey.aws.apigateway.stage/access-log-settings :portkey.aws.apigateway.stage/tags :portkey.aws.apigateway.stage/documentation-version :portkey.aws.apigateway.stage/method-settings :portkey.aws.apigateway.stage/canary-settings :portkey.aws.apigateway.stage/deployment-id :portkey.aws.apigateway.stage/client-certificate-id :portkey.aws.apigateway.stage/last-updated-date :portkey.aws.apigateway.stage/variables :portkey.aws.apigateway.stage/cache-cluster-enabled :portkey.aws.apigateway.stage/stage-name :portkey.aws.apigateway.stage/description :portkey.aws.apigateway.stage/cache-cluster-size]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-authorizer-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-authorizer-request/rest-api-id :portkey.aws.apigateway.update-authorizer-request/authorizer-id] :opt-un [:portkey.aws.apigateway.update-authorizer-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-stage-keys (clojure.spec.alpha/coll-of :portkey.aws.apigateway/stage-key))

(clojure.spec.alpha/def :portkey.aws.apigateway/content-handling-strategy #{"CONVERT_TO_BINARY" :convert-to-text :convert-to-binary "CONVERT_TO_TEXT"})

(clojure.spec.alpha/def :portkey.aws.apigateway.untag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.untag-resource-request/resource-arn :portkey.aws.apigateway.untag-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-request-validator-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-request-validator-request/rest-api-id :portkey.aws.apigateway.delete-request-validator-request/request-validator-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-part-request/location (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-location))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-part-request/properties (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-documentation-part-request/rest-api-id :portkey.aws.apigateway.create-documentation-part-request/location :portkey.aws.apigateway.create-documentation-part-request/properties] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-request-validator-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-request-validator-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-request-validator-request/rest-api-id :portkey.aws.apigateway.update-request-validator-request/request-validator-id] :opt-un [:portkey.aws.apigateway.update-request-validator-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-integration-response (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/integration-response))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plans-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plans-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plans-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plans-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-usage-plans-request/position :portkey.aws.apigateway.get-usage-plans-request/key-id :portkey.aws.apigateway.get-usage-plans-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/authorizer-credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/identity-validation-expression (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/type (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/authorizer-result-ttl-in-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/authorizer-uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/auth-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/identity-source (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/provider-ar-ns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-ar-ns))
(clojure.spec.alpha/def :portkey.aws.apigateway/authorizer (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.authorizer/authorizer-credentials :portkey.aws.apigateway.authorizer/identity-validation-expression :portkey.aws.apigateway.authorizer/id :portkey.aws.apigateway.authorizer/name :portkey.aws.apigateway.authorizer/type :portkey.aws.apigateway.authorizer/authorizer-result-ttl-in-seconds :portkey.aws.apigateway.authorizer/authorizer-uri :portkey.aws.apigateway.authorizer/auth-type :portkey.aws.apigateway.authorizer/identity-source :portkey.aws.apigateway.authorizer/provider-ar-ns]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-part-request/documentation-part-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-part-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-documentation-part-request/rest-api-id :portkey.aws.apigateway.update-documentation-part-request/documentation-part-id] :opt-un [:portkey.aws.apigateway.update-documentation-part-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.deployments/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployments/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-deployment))
(clojure.spec.alpha/def :portkey.aws.apigateway/deployments (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.deployments/position :portkey.aws.apigateway.deployments/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/boolean clojure.core/boolean?)

(clojure.core/defn tag-resource ([tag-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resource_arn}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/tag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/tag-resource-request) :ret clojure.core/true?)

(clojure.core/defn flush-stage-cache ([flush-stage-cache-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-flush-stage-cache-request flush-stage-cache-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/cache/data", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/flush-stage-cache-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "FlushStageCache", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef flush-stage-cache :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/flush-stage-cache-request) :ret clojure.core/true?)

(clojure.core/defn delete-vpc-link ([delete-vpc-link-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-vpc-link-request delete-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks/{vpclink_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpcLink", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-vpc-link-request) :ret clojure.core/true?)

(clojure.core/defn get-usage-plan ([get-usage-plan-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-usage-plan-request get-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlan", :http.request.configuration/output-deser-fn response-usage-plan, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-plan-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan))

(clojure.core/defn update-rest-api ([update-rest-api-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-rest-api-request update-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn update-account ([] (update-account {})) ([update-account-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-account-request update-account-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/account, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/account", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-account-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAccount", :http.request.configuration/output-deser-fn response-account, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-account :args (clojure.spec.alpha/? :portkey.aws.apigateway/update-account-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/account))

(clojure.core/defn delete-rest-api ([delete-rest-api-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-rest-api-request delete-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRestApi", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-rest-api-request) :ret clojure.core/true?)

(clojure.core/defn delete-method ([delete-method-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-method-request delete-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteMethod", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-method-request) :ret clojure.core/true?)

(clojure.core/defn update-authorizer ([update-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-authorizer-request update-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizer, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAuthorizer", :http.request.configuration/output-deser-fn response-authorizer, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer))

(clojure.core/defn get-sdk-type ([get-sdk-type-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-sdk-type-request get-sdk-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/sdk-type, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/sdktypes/{sdktype_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-sdk-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSdkType", :http.request.configuration/output-deser-fn response-sdk-type, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sdk-type :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-sdk-type-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/sdk-type))

(clojure.core/defn update-domain-name ([update-domain-name-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-domain-name-request update-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-name, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDomainName", :http.request.configuration/output-deser-fn response-domain-name, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-domain-name-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-name))

(clojure.core/defn update-gateway-response ([update-gateway-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-gateway-response-request update-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateGatewayResponse", :http.request.configuration/output-deser-fn response-gateway-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-gateway-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response))

(clojure.core/defn get-rest-apis ([] (get-rest-apis {})) ([get-rest-apis-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-rest-apis-request get-rest-apis-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-apis, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-rest-apis-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRestApis", :http.request.configuration/output-deser-fn response-rest-apis, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-rest-apis :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-rest-apis-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-apis))

(clojure.core/defn get-documentation-parts ([get-documentation-parts-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-documentation-parts-request get-documentation-parts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-parts, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-parts-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationParts", :http.request.configuration/output-deser-fn response-documentation-parts, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-parts :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-parts-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-parts))

(clojure.core/defn get-deployment ([get-deployment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-deployment-request get-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployment, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments/{deployment_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDeployment", :http.request.configuration/output-deser-fn response-deployment, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-deployment-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployment))

(clojure.core/defn create-resource ([create-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-resource-request create-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resource, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{parent_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateResource", :http.request.configuration/output-deser-fn response-resource, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resource))

(clojure.core/defn delete-documentation-version ([delete-documentation-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-documentation-version-request delete-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions/{doc_version}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocumentationVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-documentation-version-request) :ret clojure.core/true?)

(clojure.core/defn delete-usage-plan ([delete-usage-plan-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-usage-plan-request delete-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUsagePlan", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef delete-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-usage-plan-request) :ret clojure.core/true?)

(clojure.core/defn get-stages ([get-stages-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-stages-request get-stages-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stages, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-stages-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetStages", :http.request.configuration/output-deser-fn response-stages, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-stages :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-stages-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stages))

(clojure.core/defn get-tags ([get-tags-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-tags-request get-tags-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/tags, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resource_arn}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-tags-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTags", :http.request.configuration/output-deser-fn response-tags, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef get-tags :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-tags-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/tags))

(clojure.core/defn get-resource ([get-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-resource-request get-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resource, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetResource", :http.request.configuration/output-deser-fn response-resource, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resource))

(clojure.core/defn update-documentation-part ([update-documentation-part-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-documentation-part-request update-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts/{part_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentationPart", :http.request.configuration/output-deser-fn response-documentation-part, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-documentation-part-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part))

(clojure.core/defn create-vpc-link ([create-vpc-link-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-vpc-link-request create-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-link, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpcLink", :http.request.configuration/output-deser-fn response-vpc-link, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-vpc-link-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link))

(clojure.core/defn import-api-keys ([import-api-keys-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-import-api-keys-request import-api-keys-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key-ids, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys?mode=import", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/import-api-keys-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportApiKeys", :http.request.configuration/output-deser-fn response-api-key-ids, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef import-api-keys :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/import-api-keys-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key-ids))

(clojure.core/defn get-client-certificate ([get-client-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-client-certificate-request get-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificate, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates/{clientcertificate_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetClientCertificate", :http.request.configuration/output-deser-fn response-client-certificate, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-client-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificate))

(clojure.core/defn create-authorizer ([create-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-authorizer-request create-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizer, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAuthorizer", :http.request.configuration/output-deser-fn response-authorizer, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer))

(clojure.core/defn get-usage-plan-keys ([get-usage-plan-keys-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-usage-plan-keys-request get-usage-plan-keys-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan-keys, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plan-keys-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlanKeys", :http.request.configuration/output-deser-fn response-usage-plan-keys, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage-plan-keys :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-plan-keys-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan-keys))

(clojure.core/defn get-gateway-response ([get-gateway-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-gateway-response-request get-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetGatewayResponse", :http.request.configuration/output-deser-fn response-gateway-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-gateway-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response))

(clojure.core/defn get-deployments ([get-deployments-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-deployments-request get-deployments-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployments, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-deployments-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDeployments", :http.request.configuration/output-deser-fn response-deployments, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-deployments :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-deployments-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployments))

(clojure.core/defn update-resource ([update-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-resource-request update-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resource, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateResource", :http.request.configuration/output-deser-fn response-resource, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resource))

(clojure.core/defn get-authorizers ([get-authorizers-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-authorizers-request get-authorizers-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizers, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-authorizers-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAuthorizers", :http.request.configuration/output-deser-fn response-authorizers, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-authorizers :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-authorizers-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizers))

(clojure.core/defn get-base-path-mapping ([get-base-path-mapping-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-base-path-mapping-request get-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mapping, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings/{base_path}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBasePathMapping", :http.request.configuration/output-deser-fn response-base-path-mapping, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-base-path-mapping-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mapping))

(clojure.core/defn update-vpc-link ([update-vpc-link-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-vpc-link-request update-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-link, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks/{vpclink_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateVpcLink", :http.request.configuration/output-deser-fn response-vpc-link, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-vpc-link-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link))

(clojure.core/defn get-vpc-links ([] (get-vpc-links {})) ([get-vpc-links-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-vpc-links-request get-vpc-links-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-links, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-vpc-links-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetVpcLinks", :http.request.configuration/output-deser-fn response-vpc-links, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-vpc-links :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-vpc-links-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-links))

(clojure.core/defn delete-integration ([delete-integration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-integration-request delete-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteIntegration", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-integration-request) :ret clojure.core/true?)

(clojure.core/defn get-request-validators ([get-request-validators-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-request-validators-request get-request-validators-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validators, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-request-validators-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRequestValidators", :http.request.configuration/output-deser-fn response-request-validators, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-request-validators :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-request-validators-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validators))

(clojure.core/defn create-domain-name ([create-domain-name-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-domain-name-request create-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-name, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDomainName", :http.request.configuration/output-deser-fn response-domain-name, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-domain-name-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-name))

(clojure.core/defn put-integration-response ([put-integration-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-integration-response-request put-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutIntegrationResponse", :http.request.configuration/output-deser-fn response-integration-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef put-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-integration-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration-response))

(clojure.core/defn create-usage-plan ([create-usage-plan-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-usage-plan-request create-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateUsagePlan", :http.request.configuration/output-deser-fn response-usage-plan, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef create-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-usage-plan-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan))

(clojure.core/defn create-api-key ([] (create-api-key {})) ([create-api-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-api-key-request create-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateApiKey", :http.request.configuration/output-deser-fn response-api-key, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef create-api-key :args (clojure.spec.alpha/? :portkey.aws.apigateway/create-api-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key))

(clojure.core/defn import-rest-api ([import-rest-api-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-import-rest-api-request import-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis?mode=import", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/import-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef import-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/import-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn delete-api-key ([delete-api-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-api-key-request delete-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys/{api_Key}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApiKey", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-api-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-api-key-request) :ret clojure.core/true?)

(clojure.core/defn get-integration ([get-integration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-integration-request get-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetIntegration", :http.request.configuration/output-deser-fn response-integration, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-integration-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration))

(clojure.core/defn get-export ([get-export-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-export-request get-export-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/export-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-export-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetExport", :http.request.configuration/output-deser-fn response-export-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-export :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-export-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/export-response))

(clojure.core/defn delete-stage ([delete-stage-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-stage-request delete-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteStage", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-stage-request) :ret clojure.core/true?)

(clojure.core/defn delete-request-validator ([delete-request-validator-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-request-validator-request delete-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRequestValidator", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-request-validator-request) :ret clojure.core/true?)

(clojure.core/defn get-gateway-responses ([get-gateway-responses-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-gateway-responses-request get-gateway-responses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-responses, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-gateway-responses-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetGatewayResponses", :http.request.configuration/output-deser-fn response-gateway-responses, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-gateway-responses :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-gateway-responses-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-responses))

(clojure.core/defn put-method-response ([put-method-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-method-response-request put-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutMethodResponse", :http.request.configuration/output-deser-fn response-method-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-method-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method-response))

(clojure.core/defn get-model ([get-model-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-model-request get-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/model, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetModel", :http.request.configuration/output-deser-fn response-model, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-model-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/model))

(clojure.core/defn create-model ([create-model-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-model-request create-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/model, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateModel", :http.request.configuration/output-deser-fn response-model, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-model-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/model))

(clojure.core/defn update-api-key ([update-api-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-api-key-request update-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys/{api_Key}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApiKey", :http.request.configuration/output-deser-fn response-api-key, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef update-api-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-api-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key))

(clojure.core/defn create-deployment ([create-deployment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-deployment-request create-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployment, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDeployment", :http.request.configuration/output-deser-fn response-deployment, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-deployment-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployment))

(clojure.core/defn update-method ([update-method-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-method-request update-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMethod", :http.request.configuration/output-deser-fn response-method, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method))

(clojure.core/defn test-invoke-authorizer ([test-invoke-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-test-invoke-authorizer-request test-invoke-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/test-invoke-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/test-invoke-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestInvokeAuthorizer", :http.request.configuration/output-deser-fn response-test-invoke-authorizer-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef test-invoke-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/test-invoke-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/test-invoke-authorizer-response))

(clojure.core/defn create-documentation-part ([create-documentation-part-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-documentation-part-request create-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDocumentationPart", :http.request.configuration/output-deser-fn response-documentation-part, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-documentation-part-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part))

(clojure.core/defn update-stage ([update-stage-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-stage-request update-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateStage", :http.request.configuration/output-deser-fn response-stage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-stage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stage))

(clojure.core/defn update-request-validator ([update-request-validator-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-request-validator-request update-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validator, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRequestValidator", :http.request.configuration/output-deser-fn response-request-validator, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-request-validator-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validator))

(clojure.core/defn get-sdk-types ([] (get-sdk-types {})) ([get-sdk-types-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-sdk-types-request get-sdk-types-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/sdk-types, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/sdktypes", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-sdk-types-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSdkTypes", :http.request.configuration/output-deser-fn response-sdk-types, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sdk-types :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-sdk-types-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/sdk-types))

(clojure.core/defn update-client-certificate ([update-client-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-client-certificate-request update-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificate, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates/{clientcertificate_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateClientCertificate", :http.request.configuration/output-deser-fn response-client-certificate, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef update-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-client-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificate))

(clojure.core/defn update-model ([update-model-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-model-request update-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/model, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateModel", :http.request.configuration/output-deser-fn response-model, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-model-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/model))

(clojure.core/defn get-documentation-versions ([get-documentation-versions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-documentation-versions-request get-documentation-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-versions, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationVersions", :http.request.configuration/output-deser-fn response-documentation-versions, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-versions :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-versions))

(clojure.core/defn update-usage ([update-usage-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-usage-request update-usage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys/{keyId}/usage", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-usage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateUsage", :http.request.configuration/output-deser-fn response-usage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef update-usage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-usage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage))

(clojure.core/defn create-usage-plan-key ([create-usage-plan-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-usage-plan-key-request create-usage-plan-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-usage-plan-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateUsagePlanKey", :http.request.configuration/output-deser-fn response-usage-plan-key, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-usage-plan-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-usage-plan-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan-key))

(clojure.core/defn put-integration ([put-integration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-integration-request put-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutIntegration", :http.request.configuration/output-deser-fn response-integration, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-integration-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration))

(clojure.core/defn get-usage ([get-usage-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-usage-request get-usage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/usage", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsage", :http.request.configuration/output-deser-fn response-usage, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage))

(clojure.core/defn update-documentation-version ([update-documentation-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-documentation-version-request update-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-version, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions/{doc_version}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentationVersion", :http.request.configuration/output-deser-fn response-documentation-version, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-documentation-version-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-version))

(clojure.core/defn get-stage ([get-stage-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-stage-request get-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetStage", :http.request.configuration/output-deser-fn response-stage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-stage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stage))

(clojure.core/defn update-method-response ([update-method-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-method-response-request update-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMethodResponse", :http.request.configuration/output-deser-fn response-method-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-method-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method-response))

(clojure.core/defn get-vpc-link ([get-vpc-link-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-vpc-link-request get-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-link, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks/{vpclink_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetVpcLink", :http.request.configuration/output-deser-fn response-vpc-link, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-vpc-link-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link))

(clojure.core/defn create-base-path-mapping ([create-base-path-mapping-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-base-path-mapping-request create-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mapping, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBasePathMapping", :http.request.configuration/output-deser-fn response-base-path-mapping, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-base-path-mapping-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mapping))

(clojure.core/defn get-documentation-part ([get-documentation-part-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-documentation-part-request get-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts/{part_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationPart", :http.request.configuration/output-deser-fn response-documentation-part, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-part-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part))

(clojure.core/defn delete-model ([delete-model-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-model-request delete-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteModel", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-model-request) :ret clojure.core/true?)

(clojure.core/defn import-documentation-parts ([import-documentation-parts-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-import-documentation-parts-request import-documentation-parts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part-ids, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/import-documentation-parts-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportDocumentationParts", :http.request.configuration/output-deser-fn response-documentation-part-ids, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef import-documentation-parts :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/import-documentation-parts-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-ids))

(clojure.core/defn delete-method-response ([delete-method-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-method-response-request delete-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteMethodResponse", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-method-response-request) :ret clojure.core/true?)

(clojure.core/defn get-client-certificates ([] (get-client-certificates {})) ([get-client-certificates-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-client-certificates-request get-client-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificates, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-client-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetClientCertificates", :http.request.configuration/output-deser-fn response-client-certificates, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-client-certificates :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-client-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificates))

(clojure.core/defn get-api-keys ([] (get-api-keys {})) ([get-api-keys-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-api-keys-request get-api-keys-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-keys, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-api-keys-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApiKeys", :http.request.configuration/output-deser-fn response-api-keys, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-api-keys :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-api-keys-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-keys))

(clojure.core/defn update-deployment ([update-deployment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-deployment-request update-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployment, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments/{deployment_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDeployment", :http.request.configuration/output-deser-fn response-deployment, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-deployment-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployment))

(clojure.core/defn delete-domain-name ([delete-domain-name-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-domain-name-request delete-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDomainName", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-domain-name-request) :ret clojure.core/true?)

(clojure.core/defn create-rest-api ([create-rest-api-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-rest-api-request create-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn delete-authorizer ([delete-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-authorizer-request delete-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAuthorizer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-authorizer-request) :ret clojure.core/true?)

(clojure.core/defn get-usage-plan-key ([get-usage-plan-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-usage-plan-key-request get-usage-plan-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys/{keyId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plan-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlanKey", :http.request.configuration/output-deser-fn response-usage-plan-key, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage-plan-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-plan-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan-key))

(clojure.core/defn delete-resource ([delete-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-resource-request delete-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-resource-request) :ret clojure.core/true?)

(clojure.core/defn test-invoke-method ([test-invoke-method-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-test-invoke-method-request test-invoke-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/test-invoke-method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/test-invoke-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestInvokeMethod", :http.request.configuration/output-deser-fn response-test-invoke-method-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef test-invoke-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/test-invoke-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/test-invoke-method-response))

(clojure.core/defn get-method-response ([get-method-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-method-response-request get-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMethodResponse", :http.request.configuration/output-deser-fn response-method-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-method-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method-response))

(clojure.core/defn get-request-validator ([get-request-validator-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-request-validator-request get-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validator, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRequestValidator", :http.request.configuration/output-deser-fn response-request-validator, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-request-validator-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validator))

(clojure.core/defn get-authorizer ([get-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-authorizer-request get-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizer, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAuthorizer", :http.request.configuration/output-deser-fn response-authorizer, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer))

(clojure.core/defn get-base-path-mappings ([get-base-path-mappings-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-base-path-mappings-request get-base-path-mappings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mappings, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-base-path-mappings-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBasePathMappings", :http.request.configuration/output-deser-fn response-base-path-mappings, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-base-path-mappings :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-base-path-mappings-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mappings))

(clojure.core/defn delete-base-path-mapping ([delete-base-path-mapping-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-base-path-mapping-request delete-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings/{base_path}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBasePathMapping", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-base-path-mapping-request) :ret clojure.core/true?)

(clojure.core/defn get-account ([] (get-account {})) ([get-account-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-account-request get-account-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/account, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/account", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-account-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAccount", :http.request.configuration/output-deser-fn response-account, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-account :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-account-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/account))

(clojure.core/defn get-integration-response ([get-integration-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-integration-response-request get-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetIntegrationResponse", :http.request.configuration/output-deser-fn response-integration-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-integration-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration-response))

(clojure.core/defn get-model-template ([get-model-template-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-model-template-request get-model-template-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/template, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}/default_template", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-model-template-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetModelTemplate", :http.request.configuration/output-deser-fn response-template, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-model-template :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-model-template-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/template))

(clojure.core/defn get-rest-api ([get-rest-api-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-rest-api-request get-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn delete-integration-response ([delete-integration-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-integration-response-request delete-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteIntegrationResponse", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-integration-response-request) :ret clojure.core/true?)

(clojure.core/defn delete-usage-plan-key ([delete-usage-plan-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-usage-plan-key-request delete-usage-plan-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys/{keyId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-usage-plan-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUsagePlanKey", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-usage-plan-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-usage-plan-key-request) :ret clojure.core/true?)

(clojure.core/defn delete-documentation-part ([delete-documentation-part-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-documentation-part-request delete-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts/{part_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocumentationPart", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-documentation-part-request) :ret clojure.core/true?)

(clojure.core/defn untag-resource ([untag-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resource_arn}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/untag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/untag-resource-request) :ret clojure.core/true?)

(clojure.core/defn generate-client-certificate ([] (generate-client-certificate {})) ([generate-client-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-generate-client-certificate-request generate-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificate, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/generate-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GenerateClientCertificate", :http.request.configuration/output-deser-fn response-client-certificate, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef generate-client-certificate :args (clojure.spec.alpha/? :portkey.aws.apigateway/generate-client-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificate))

(clojure.core/defn get-method ([get-method-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-method-request get-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMethod", :http.request.configuration/output-deser-fn response-method, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method))

(clojure.core/defn get-models ([get-models-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-models-request get-models-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/models, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-models-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetModels", :http.request.configuration/output-deser-fn response-models, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-models :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-models-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/models))

(clojure.core/defn get-documentation-version ([get-documentation-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-documentation-version-request get-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-version, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions/{doc_version}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationVersion", :http.request.configuration/output-deser-fn response-documentation-version, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-version-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-version))

(clojure.core/defn create-documentation-version ([create-documentation-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-documentation-version-request create-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-version, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDocumentationVersion", :http.request.configuration/output-deser-fn response-documentation-version, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-documentation-version-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-version))

(clojure.core/defn get-resources ([get-resources-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-resources-request get-resources-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resources, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-resources-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetResources", :http.request.configuration/output-deser-fn response-resources, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-resources :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-resources-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resources))

(clojure.core/defn get-api-key ([get-api-key-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-api-key-request get-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys/{api_Key}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApiKey", :http.request.configuration/output-deser-fn response-api-key, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-api-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-api-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key))

(clojure.core/defn create-stage ([create-stage-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-stage-request create-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateStage", :http.request.configuration/output-deser-fn response-stage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-stage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stage))

(clojure.core/defn delete-gateway-response ([delete-gateway-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-gateway-response-request delete-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteGatewayResponse", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-gateway-response-request) :ret clojure.core/true?)

(clojure.core/defn update-integration ([update-integration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-integration-request update-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateIntegration", :http.request.configuration/output-deser-fn response-integration, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef update-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-integration-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration))

(clojure.core/defn flush-stage-authorizers-cache ([flush-stage-authorizers-cache-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-flush-stage-authorizers-cache-request flush-stage-authorizers-cache-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/cache/authorizers", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/flush-stage-authorizers-cache-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "FlushStageAuthorizersCache", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef flush-stage-authorizers-cache :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/flush-stage-authorizers-cache-request) :ret clojure.core/true?)

(clojure.core/defn delete-client-certificate ([delete-client-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-client-certificate-request delete-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates/{clientcertificate_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClientCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef delete-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-client-certificate-request) :ret clojure.core/true?)

(clojure.core/defn put-gateway-response ([put-gateway-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-gateway-response-request put-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutGatewayResponse", :http.request.configuration/output-deser-fn response-gateway-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-gateway-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response))

(clojure.core/defn get-domain-name ([get-domain-name-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-domain-name-request get-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-name, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDomainName", :http.request.configuration/output-deser-fn response-domain-name, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-domain-name-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-name))

(clojure.core/defn update-base-path-mapping ([update-base-path-mapping-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-base-path-mapping-request update-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mapping, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings/{base_path}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateBasePathMapping", :http.request.configuration/output-deser-fn response-base-path-mapping, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-base-path-mapping-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mapping))

(clojure.core/defn get-usage-plans ([] (get-usage-plans {})) ([get-usage-plans-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-usage-plans-request get-usage-plans-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plans, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plans-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlans", :http.request.configuration/output-deser-fn response-usage-plans, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef get-usage-plans :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-usage-plans-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plans))

(clojure.core/defn update-usage-plan ([update-usage-plan-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-usage-plan-request update-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateUsagePlan", :http.request.configuration/output-deser-fn response-usage-plan, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef update-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-usage-plan-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan))

(clojure.core/defn get-sdk ([get-sdk-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-sdk-request get-sdk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/sdk-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-sdk-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSdk", :http.request.configuration/output-deser-fn response-sdk-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sdk :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-sdk-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/sdk-response))

(clojure.core/defn put-method ([put-method-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-method-request put-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutMethod", :http.request.configuration/output-deser-fn response-method, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method))

(clojure.core/defn update-integration-response ([update-integration-response-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-integration-response-request update-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateIntegrationResponse", :http.request.configuration/output-deser-fn response-integration-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-integration-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration-response))

(clojure.core/defn get-domain-names ([] (get-domain-names {})) ([get-domain-names-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-domain-names-request get-domain-names-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-names, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-domain-names-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDomainNames", :http.request.configuration/output-deser-fn response-domain-names, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-domain-names :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-domain-names-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-names))

(clojure.core/defn put-rest-api ([put-rest-api-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-rest-api-request put-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef put-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn create-request-validator ([create-request-validator-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-request-validator-request create-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validator, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRequestValidator", :http.request.configuration/output-deser-fn response-request-validator, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-request-validator-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validator))

(clojure.core/defn delete-deployment ([delete-deployment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-deployment-request delete-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments/{deployment_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDeployment", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-deployment-request) :ret clojure.core/true?)
