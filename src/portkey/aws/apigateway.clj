(ns portkey.aws.apigateway (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "apigateway", :region "us-gov-east-1"},
    :ssl-common-name "apigateway.us-gov-east-1.amazonaws.com",
    :endpoint "https://apigateway.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope
    {:service "apigateway", :region "ap-northeast-1"},
    :ssl-common-name "apigateway.ap-northeast-1.amazonaws.com",
    :endpoint "https://apigateway.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "apigateway", :region "eu-west-1"},
    :ssl-common-name "apigateway.eu-west-1.amazonaws.com",
    :endpoint "https://apigateway.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "apigateway", :region "us-east-2"},
    :ssl-common-name "apigateway.us-east-2.amazonaws.com",
    :endpoint "https://apigateway.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope
    {:service "apigateway", :region "ap-southeast-2"},
    :ssl-common-name "apigateway.ap-southeast-2.amazonaws.com",
    :endpoint "https://apigateway.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "apigateway", :region "cn-north-1"},
    :ssl-common-name "apigateway.cn-north-1.amazonaws.com.cn",
    :endpoint "https://apigateway.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "apigateway", :region "sa-east-1"},
    :ssl-common-name "apigateway.sa-east-1.amazonaws.com",
    :endpoint "https://apigateway.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope
    {:service "apigateway", :region "ap-southeast-1"},
    :ssl-common-name "apigateway.ap-southeast-1.amazonaws.com",
    :endpoint "https://apigateway.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope
    {:service "apigateway", :region "cn-northwest-1"},
    :ssl-common-name "apigateway.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://apigateway.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope
    {:service "apigateway", :region "ap-northeast-2"},
    :ssl-common-name "apigateway.ap-northeast-2.amazonaws.com",
    :endpoint "https://apigateway.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "apigateway", :region "eu-west-3"},
    :ssl-common-name "apigateway.eu-west-3.amazonaws.com",
    :endpoint "https://apigateway.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "apigateway", :region "ca-central-1"},
    :ssl-common-name "apigateway.ca-central-1.amazonaws.com",
    :endpoint "https://apigateway.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "apigateway", :region "eu-central-1"},
    :ssl-common-name "apigateway.eu-central-1.amazonaws.com",
    :endpoint "https://apigateway.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "apigateway", :region "eu-west-2"},
    :ssl-common-name "apigateway.eu-west-2.amazonaws.com",
    :endpoint "https://apigateway.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "apigateway", :region "us-gov-west-1"},
    :ssl-common-name "apigateway.us-gov-west-1.amazonaws.com",
    :endpoint "https://apigateway.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "apigateway", :region "us-west-2"},
    :ssl-common-name "apigateway.us-west-2.amazonaws.com",
    :endpoint "https://apigateway.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "apigateway", :region "us-east-1"},
    :ssl-common-name "apigateway.us-east-1.amazonaws.com",
    :endpoint "https://apigateway.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "apigateway", :region "us-west-1"},
    :ssl-common-name "apigateway.us-west-1.amazonaws.com",
    :endpoint "https://apigateway.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "apigateway", :region "ap-south-1"},
    :ssl-common-name "apigateway.ap-south-1.amazonaws.com",
    :endpoint "https://apigateway.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "apigateway", :region "eu-north-1"},
    :ssl-common-name "apigateway.eu-north-1.amazonaws.com",
    :endpoint "https://apigateway.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-documentation-part-location-status-code)

(clojure.core/declare ser-double)

(clojure.core/declare ser-gateway-response-type)

(clojure.core/declare ser-status-code)

(clojure.core/declare ser-api-stage)

(clojure.core/declare ser-map-of-string-to-list)

(clojure.core/declare ser-endpoint-type)

(clojure.core/declare ser-list-of-string)

(clojure.core/declare ser-documentation-part-type)

(clojure.core/declare ser-patch-operation)

(clojure.core/declare ser-nullable-boolean)

(clojure.core/declare ser-map-of-string-to-boolean)

(clojure.core/declare ser-quota-period-type)

(clojure.core/declare ser-put-mode)

(clojure.core/declare ser-deployment-canary-settings)

(clojure.core/declare ser-api-key-source-type)

(clojure.core/declare ser-throttle-settings)

(clojure.core/declare ser-cache-cluster-size)

(clojure.core/declare ser-integration-type)

(clojure.core/declare ser-op)

(clojure.core/declare ser-authorizer-type)

(clojure.core/declare ser-list-of-ar-ns)

(clojure.core/declare ser-list-of-api-stage)

(clojure.core/declare ser-canary-settings)

(clojure.core/declare ser-stage-key)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-string)

(clojure.core/declare ser-quota-settings)

(clojure.core/declare ser-provider-arn)

(clojure.core/declare ser-map-of-string-to-string)

(clojure.core/declare ser-connection-type)

(clojure.core/declare ser-documentation-part-location)

(clojure.core/declare ser-api-keys-format)

(clojure.core/declare ser-list-of-endpoint-type)

(clojure.core/declare ser-list-of-patch-operation)

(clojure.core/declare ser-nullable-integer)

(clojure.core/declare ser-map-of-api-stage-throttle-settings)

(clojure.core/declare ser-blob)

(clojure.core/declare ser-location-status-type)

(clojure.core/declare ser-endpoint-configuration)

(clojure.core/declare ser-list-of-stage-keys)

(clojure.core/declare ser-content-handling-strategy)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-documentation-part-location-status-code [input] #:http.request.field{:value input, :shape "DocumentationPartLocationStatusCode"})

(clojure.core/defn- ser-double [input] #:http.request.field{:value input, :shape "Double"})

(clojure.core/defn- ser-gateway-response-type [input] #:http.request.field{:value (clojure.core/get {:integration-timeout "INTEGRATION_TIMEOUT", "REQUEST_TOO_LARGE" "REQUEST_TOO_LARGE", :unauthorized "UNAUTHORIZED", "INTEGRATION_TIMEOUT" "INTEGRATION_TIMEOUT", "RESOURCE_NOT_FOUND" "RESOURCE_NOT_FOUND", :invalid-api-key "INVALID_API_KEY", :integration-failure "INTEGRATION_FAILURE", "AUTHORIZER_CONFIGURATION_ERROR" "AUTHORIZER_CONFIGURATION_ERROR", "INTEGRATION_FAILURE" "INTEGRATION_FAILURE", "DEFAULT_5XX" "DEFAULT_5XX", "UNAUTHORIZED" "UNAUTHORIZED", :quota-exceeded "QUOTA_EXCEEDED", :invalid-signature "INVALID_SIGNATURE", :expired-token "EXPIRED_TOKEN", :bad-request-parameters "BAD_REQUEST_PARAMETERS", "AUTHORIZER_FAILURE" "AUTHORIZER_FAILURE", :unsupported-media-type "UNSUPPORTED_MEDIA_TYPE", "INVALID_API_KEY" "INVALID_API_KEY", "ACCESS_DENIED" "ACCESS_DENIED", "API_CONFIGURATION_ERROR" "API_CONFIGURATION_ERROR", "DEFAULT_4XX" "DEFAULT_4XX", "INVALID_SIGNATURE" "INVALID_SIGNATURE", :bad-request-body "BAD_REQUEST_BODY", :api-configuration-error "API_CONFIGURATION_ERROR", "EXPIRED_TOKEN" "EXPIRED_TOKEN", "UNSUPPORTED_MEDIA_TYPE" "UNSUPPORTED_MEDIA_TYPE", :authorizer-configuration-error "AUTHORIZER_CONFIGURATION_ERROR", :default-5-xx "DEFAULT_5XX", :request-too-large "REQUEST_TOO_LARGE", :default-4-xx "DEFAULT_4XX", :authorizer-failure "AUTHORIZER_FAILURE", :throttled "THROTTLED", "QUOTA_EXCEEDED" "QUOTA_EXCEEDED", "BAD_REQUEST_PARAMETERS" "BAD_REQUEST_PARAMETERS", "MISSING_AUTHENTICATION_TOKEN" "MISSING_AUTHENTICATION_TOKEN", :missing-authentication-token "MISSING_AUTHENTICATION_TOKEN", "BAD_REQUEST_BODY" "BAD_REQUEST_BODY", :resource-not-found "RESOURCE_NOT_FOUND", :access-denied "ACCESS_DENIED", "THROTTLED" "THROTTLED"} input), :shape "GatewayResponseType"})

(clojure.core/defn- ser-status-code [input] #:http.request.field{:value input, :shape "StatusCode"})

(clojure.core/defn- ser-api-stage [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ApiStage", :type "structure"} (clojure.core/contains? input :api-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :api-id)) #:http.request.field{:name "apiId", :shape "String"})) (clojure.core/contains? input :stage) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage)) #:http.request.field{:name "stage", :shape "String"})) (clojure.core/contains? input :throttle) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-api-stage-throttle-settings (input :throttle)) #:http.request.field{:name "throttle", :shape "MapOfApiStageThrottleSettings"}))))

(clojure.core/defn- ser-map-of-string-to-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-list-of-string v) #:http.request.field{:map-info "value", :shape "ListOfString"})])) input), :shape "MapOfStringToList", :type "map"})

(clojure.core/defn- ser-endpoint-type [input] #:http.request.field{:value (clojure.core/get {"REGIONAL" "REGIONAL", :regional "REGIONAL", "EDGE" "EDGE", :edge "EDGE", "PRIVATE" "PRIVATE", :private "PRIVATE"} input), :shape "EndpointType"})

(clojure.core/defn- ser-list-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String"}))) input), :shape "ListOfString", :type "list"})

(clojure.core/defn- ser-documentation-part-type [input] #:http.request.field{:value (clojure.core/get {:response "RESPONSE", "PATH_PARAMETER" "PATH_PARAMETER", :api "API", :response-header "RESPONSE_HEADER", :method "METHOD", "API" "API", "REQUEST_HEADER" "REQUEST_HEADER", :path-parameter "PATH_PARAMETER", "METHOD" "METHOD", :request-body "REQUEST_BODY", :resource "RESOURCE", :request-header "REQUEST_HEADER", "RESOURCE" "RESOURCE", :response-body "RESPONSE_BODY", :query-parameter "QUERY_PARAMETER", "RESPONSE_HEADER" "RESPONSE_HEADER", :authorizer "AUTHORIZER", "REQUEST_BODY" "REQUEST_BODY", "QUERY_PARAMETER" "QUERY_PARAMETER", "AUTHORIZER" "AUTHORIZER", "MODEL" "MODEL", "RESPONSE" "RESPONSE", "RESPONSE_BODY" "RESPONSE_BODY", :model "MODEL"} input), :shape "DocumentationPartType"})

(clojure.core/defn- ser-patch-operation [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PatchOperation", :type "structure"} (clojure.core/contains? input :op) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-op (input :op)) #:http.request.field{:name "op", :shape "Op"})) (clojure.core/contains? input :path) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path)) #:http.request.field{:name "path", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "value", :shape "String"})) (clojure.core/contains? input :from) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :from)) #:http.request.field{:name "from", :shape "String"}))))

(clojure.core/defn- ser-nullable-boolean [input] #:http.request.field{:value input, :shape "NullableBoolean"})

(clojure.core/defn- ser-map-of-string-to-boolean [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-nullable-boolean v) #:http.request.field{:map-info "value", :shape "NullableBoolean"})])) input), :shape "MapOfStringToBoolean", :type "map"})

(clojure.core/defn- ser-quota-period-type [input] #:http.request.field{:value (clojure.core/get {"DAY" "DAY", :day "DAY", "WEEK" "WEEK", :week "WEEK", "MONTH" "MONTH", :month "MONTH"} input), :shape "QuotaPeriodType"})

(clojure.core/defn- ser-put-mode [input] #:http.request.field{:value (clojure.core/get {"merge" "merge", :merge "merge", "overwrite" "overwrite", :overwrite "overwrite"} input), :shape "PutMode"})

(clojure.core/defn- ser-deployment-canary-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DeploymentCanarySettings", :type "structure"} (clojure.core/contains? input :percent-traffic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :percent-traffic)) #:http.request.field{:name "percentTraffic", :shape "Double"})) (clojure.core/contains? input :stage-variable-overrides) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variable-overrides)) #:http.request.field{:name "stageVariableOverrides", :shape "MapOfStringToString"})) (clojure.core/contains? input :use-stage-cache) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :use-stage-cache)) #:http.request.field{:name "useStageCache", :shape "Boolean"}))))

(clojure.core/defn- ser-api-key-source-type [input] #:http.request.field{:value (clojure.core/get {"HEADER" "HEADER", :header "HEADER", "AUTHORIZER" "AUTHORIZER", :authorizer "AUTHORIZER"} input), :shape "ApiKeySourceType"})

(clojure.core/defn- ser-throttle-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ThrottleSettings", :type "structure"} (clojure.core/contains? input :burst-limit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :burst-limit)) #:http.request.field{:name "burstLimit", :shape "Integer"})) (clojure.core/contains? input :rate-limit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :rate-limit)) #:http.request.field{:name "rateLimit", :shape "Double"}))))

(clojure.core/defn- ser-cache-cluster-size [input] #:http.request.field{:value (clojure.core/get {"118" "118", "237" "237", :05 "0.5", "1.6" "1.6", :118 "118", :61 "6.1", "0.5" "0.5", :16 "1.6", "28.4" "28.4", :135 "13.5", "58.2" "58.2", :284 "28.4", "6.1" "6.1", :237 "237", :582 "58.2", "13.5" "13.5"} input), :shape "CacheClusterSize"})

(clojure.core/defn- ser-integration-type [input] #:http.request.field{:value (clojure.core/get {:aws "AWS", "AWS" "AWS", :aws-proxy "AWS_PROXY", "MOCK" "MOCK", "AWS_PROXY" "AWS_PROXY", "HTTP_PROXY" "HTTP_PROXY", :http "HTTP", :http-proxy "HTTP_PROXY", "HTTP" "HTTP", :mock "MOCK"} input), :shape "IntegrationType"})

(clojure.core/defn- ser-op [input] #:http.request.field{:value (clojure.core/get {:remove "remove", :copy "copy", "copy" "copy", :replace "replace", :move "move", "replace" "replace", "remove" "remove", "move" "move", "add" "add", :add "add", :test "test", "test" "test"} input), :shape "Op"})

(clojure.core/defn- ser-authorizer-type [input] #:http.request.field{:value (clojure.core/get {"TOKEN" "TOKEN", :token "TOKEN", "REQUEST" "REQUEST", :request "REQUEST", "COGNITO_USER_POOLS" "COGNITO_USER_POOLS", :cognito-user-pools "COGNITO_USER_POOLS"} input), :shape "AuthorizerType"})

(clojure.core/defn- ser-list-of-ar-ns [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-provider-arn coll) #:http.request.field{:shape "ProviderARN"}))) input), :shape "ListOfARNs", :type "list"})

(clojure.core/defn- ser-list-of-api-stage [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-api-stage coll) #:http.request.field{:shape "ApiStage"}))) input), :shape "ListOfApiStage", :type "list"})

(clojure.core/defn- ser-canary-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CanarySettings", :type "structure"} (clojure.core/contains? input :percent-traffic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :percent-traffic)) #:http.request.field{:name "percentTraffic", :shape "Double"})) (clojure.core/contains? input :deployment-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String"})) (clojure.core/contains? input :stage-variable-overrides) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variable-overrides)) #:http.request.field{:name "stageVariableOverrides", :shape "MapOfStringToString"})) (clojure.core/contains? input :use-stage-cache) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :use-stage-cache)) #:http.request.field{:name "useStageCache", :shape "Boolean"}))))

(clojure.core/defn- ser-stage-key [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StageKey", :type "structure"} (clojure.core/contains? input :rest-api-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String"})) (clojure.core/contains? input :stage-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"}))))

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-quota-settings [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "QuotaSettings", :type "structure"} (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :limit)) #:http.request.field{:name "limit", :shape "Integer"})) (clojure.core/contains? input :offset) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :offset)) #:http.request.field{:name "offset", :shape "Integer"})) (clojure.core/contains? input :period) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-quota-period-type (input :period)) #:http.request.field{:name "period", :shape "QuotaPeriodType"}))))

(clojure.core/defn- ser-provider-arn [input] #:http.request.field{:value input, :shape "ProviderARN"})

(clojure.core/defn- ser-map-of-string-to-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-string v) #:http.request.field{:map-info "value", :shape "String"})])) input), :shape "MapOfStringToString", :type "map"})

(clojure.core/defn- ser-connection-type [input] #:http.request.field{:value (clojure.core/get {"INTERNET" "INTERNET", :internet "INTERNET", "VPC_LINK" "VPC_LINK", :vpc-link "VPC_LINK"} input), :shape "ConnectionType"})

(clojure.core/defn- ser-documentation-part-location [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-documentation-part-type (:type input)) #:http.request.field{:name "type", :shape "DocumentationPartType"})], :shape "DocumentationPartLocation", :type "structure"} (clojure.core/contains? input :path) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path)) #:http.request.field{:name "path", :shape "String"})) (clojure.core/contains? input :method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :method)) #:http.request.field{:name "method", :shape "String"})) (clojure.core/contains? input :status-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-documentation-part-location-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "DocumentationPartLocationStatusCode"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}))))

(clojure.core/defn- ser-api-keys-format [input] #:http.request.field{:value (clojure.core/get {"csv" "csv", :csv "csv"} input), :shape "ApiKeysFormat"})

(clojure.core/defn- ser-list-of-endpoint-type [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-endpoint-type coll) #:http.request.field{:shape "EndpointType"}))) input), :shape "ListOfEndpointType", :type "list"})

(clojure.core/defn- ser-list-of-patch-operation [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-patch-operation coll) #:http.request.field{:shape "PatchOperation"}))) input), :shape "ListOfPatchOperation", :type "list"})

(clojure.core/defn- ser-nullable-integer [input] #:http.request.field{:value input, :shape "NullableInteger"})

(clojure.core/defn- ser-map-of-api-stage-throttle-settings [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "String"}) (clojure.core/into (ser-throttle-settings v) #:http.request.field{:map-info "value", :shape "ThrottleSettings"})])) input), :shape "MapOfApiStageThrottleSettings", :type "map"})

(clojure.core/defn- ser-blob [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "Blob"})

(clojure.core/defn- ser-location-status-type [input] #:http.request.field{:value (clojure.core/get {"DOCUMENTED" "DOCUMENTED", :documented "DOCUMENTED", "UNDOCUMENTED" "UNDOCUMENTED", :undocumented "UNDOCUMENTED"} input), :shape "LocationStatusType"})

(clojure.core/defn- ser-endpoint-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointConfiguration", :type "structure"} (clojure.core/contains? input :types) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-endpoint-type (input :types)) #:http.request.field{:name "types", :shape "ListOfEndpointType"}))))

(clojure.core/defn- ser-list-of-stage-keys [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-stage-key coll) #:http.request.field{:shape "StageKey"}))) input), :shape "ListOfStageKeys", :type "list"})

(clojure.core/defn- ser-content-handling-strategy [input] #:http.request.field{:value (clojure.core/get {"CONVERT_TO_BINARY" "CONVERT_TO_BINARY", :convert-to-binary "CONVERT_TO_BINARY", "CONVERT_TO_TEXT" "CONVERT_TO_TEXT", :convert-to-text "CONVERT_TO_TEXT"} input), :shape "ContentHandlingStrategy"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-create-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :parent-id)) #:http.request.field{:name "parentId", :shape "String", :location "uri", :location-name "parent_id"})], :body [(clojure.core/into (ser-string (input :path-part)) #:http.request.field{:name "pathPart", :shape "String"})]}))

(clojure.core/defn- req-put-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})]} (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-put-mode (input :mode)) #:http.request.field{:name "mode", :shape "PutMode", :location "querystring", :location-name "mode"})) (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"}))))

(clojure.core/defn- req-get-stages-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :deployment-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "querystring", :location-name "deploymentId"}))))

(clojure.core/defn- req-delete-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]}))

(clojure.core/defn- req-delete-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"})]}))

(clojure.core/defn- req-delete-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]}))

(clojure.core/defn- req-create-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}) (clojure.core/into (ser-list-of-string (input :target-arns)) #:http.request.field{:name "targetArns", :shape "ListOfString"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-get-resources-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :embed) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :embed)) #:http.request.field{:name "embed", :shape "ListOfString", :location "querystring", :location-name "embed"}))))

(clojure.core/defn- req-test-invoke-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]} (clojure.core/contains? input :headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :headers)) #:http.request.field{:name "headers", :shape "MapOfStringToString"})) (clojure.core/contains? input :multi-value-headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-list (input :multi-value-headers)) #:http.request.field{:name "multiValueHeaders", :shape "MapOfStringToList"})) (clojure.core/contains? input :path-with-query-string) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path-with-query-string)) #:http.request.field{:name "pathWithQueryString", :shape "String"})) (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "body", :shape "String"})) (clojure.core/contains? input :stage-variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variables)) #:http.request.field{:name "stageVariables", :shape "MapOfStringToString"})) (clojure.core/contains? input :additional-context) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :additional-context)) #:http.request.field{:name "additionalContext", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-test-invoke-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "body", :shape "String"})) (clojure.core/contains? input :multi-value-headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-list (input :multi-value-headers)) #:http.request.field{:name "multiValueHeaders", :shape "MapOfStringToList"})) (clojure.core/contains? input :path-with-query-string) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path-with-query-string)) #:http.request.field{:name "pathWithQueryString", :shape "String"})) (clojure.core/contains? input :client-certificate-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String"})) (clojure.core/contains? input :stage-variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :stage-variables)) #:http.request.field{:name "stageVariables", :shape "MapOfStringToString"})) (clojure.core/contains? input :headers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :headers)) #:http.request.field{:name "headers", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-get-sdk-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :id)) #:http.request.field{:name "id", :shape "String", :location "uri", :location-name "sdktype_id"})]}))

(clojure.core/defn- req-get-sdk-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"}) (clojure.core/into (ser-string (input :sdk-type)) #:http.request.field{:name "sdkType", :shape "String", :location "uri", :location-name "sdk_type"})]} (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"}))))

(clojure.core/defn- req-update-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-delete-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-delete-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-part-id)) #:http.request.field{:name "documentationPartId", :shape "String", :location "uri", :location-name "part_id"})]}))

(clojure.core/defn- req-get-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-get-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"})]} (clojure.core/contains? input :embed) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :embed)) #:http.request.field{:name "embed", :shape "ListOfString", :location "querystring", :location-name "embed"}))))

(clojure.core/defn- req-get-usage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})], :querystring [(clojure.core/into (ser-string (input :start-date)) #:http.request.field{:name "startDate", :shape "String", :location "querystring", :location-name "startDate"}) (clojure.core/into (ser-string (input :end-date)) #:http.request.field{:name "endDate", :shape "String", :location "querystring", :location-name "endDate"})]} (clojure.core/contains? input :key-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "querystring", :location-name "keyId"})) (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"}) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String", :location "uri", :location-name "base_path"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-sdk-types-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-import-documentation-parts-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})]} (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-put-mode (input :mode)) #:http.request.field{:name "mode", :shape "PutMode", :location "querystring", :location-name "mode"})) (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"}))))

(clojure.core/defn- req-generate-client-certificate-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-get-client-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String", :location "uri", :location-name "clientcertificate_id"})]}))

(clojure.core/defn- req-update-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "uri", :location-name "deployment_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-put-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})], :body [(clojure.core/into (ser-integration-type (input :type)) #:http.request.field{:name "type", :shape "IntegrationType"})]} (clojure.core/contains? input :connection-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :connection-id)) #:http.request.field{:name "connectionId", :shape "String"})) (clojure.core/contains? input :uri) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :uri)) #:http.request.field{:name "uri", :shape "String"})) (clojure.core/contains? input :integration-http-method) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :integration-http-method)) #:http.request.field{:name "integrationHttpMethod", :shape "String", :location-name "httpMethod"})) (clojure.core/contains? input :connection-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-connection-type (input :connection-type)) #:http.request.field{:name "connectionType", :shape "ConnectionType"})) (clojure.core/contains? input :request-templates) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :request-templates)) #:http.request.field{:name "requestTemplates", :shape "MapOfStringToString"})) (clojure.core/contains? input :request-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :request-parameters)) #:http.request.field{:name "requestParameters", :shape "MapOfStringToString"})) (clojure.core/contains? input :cache-namespace) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cache-namespace)) #:http.request.field{:name "cacheNamespace", :shape "String"})) (clojure.core/contains? input :passthrough-behavior) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :passthrough-behavior)) #:http.request.field{:name "passthroughBehavior", :shape "String"})) (clojure.core/contains? input :content-handling) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-content-handling-strategy (input :content-handling)) #:http.request.field{:name "contentHandling", :shape "ContentHandlingStrategy"})) (clojure.core/contains? input :cache-key-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :cache-key-parameters)) #:http.request.field{:name "cacheKeyParameters", :shape "ListOfString"})) (clojure.core/contains? input :credentials) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :credentials)) #:http.request.field{:name "credentials", :shape "String"})) (clojure.core/contains? input :timeout-in-millis) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :timeout-in-millis)) #:http.request.field{:name "timeoutInMillis", :shape "NullableInteger"}))))

(clojure.core/defn- req-update-usage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"}) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "uri", :location-name "keyId"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-delete-api-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "apiKey", :shape "String", :location "uri", :location-name "api_Key"})]}))

(clojure.core/defn- req-get-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-part-id)) #:http.request.field{:name "documentationPartId", :shape "String", :location "uri", :location-name "part_id"})]}))

(clojure.core/defn- req-get-base-path-mappings-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})]} (clojure.core/contains? input :api-key-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-api-key-source-type (input :api-key-source)) #:http.request.field{:name "apiKeySource", :shape "ApiKeySourceType"})) (clojure.core/contains? input :clone-from) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :clone-from)) #:http.request.field{:name "cloneFrom", :shape "String"})) (clojure.core/contains? input :binary-media-types) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :binary-media-types)) #:http.request.field{:name "binaryMediaTypes", :shape "ListOfString"})) (clojure.core/contains? input :endpoint-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-configuration (input :endpoint-configuration)) #:http.request.field{:name "endpointConfiguration", :shape "EndpointConfiguration"})) (clojure.core/contains? input :policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :policy)) #:http.request.field{:name "policy", :shape "String"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :version)) #:http.request.field{:name "version", :shape "String"})) (clojure.core/contains? input :minimum-compression-size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :minimum-compression-size)) #:http.request.field{:name "minimumCompressionSize", :shape "NullableInteger"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-put-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :selection-pattern) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :selection-pattern)) #:http.request.field{:name "selectionPattern", :shape "String"})) (clojure.core/contains? input :response-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-parameters)) #:http.request.field{:name "responseParameters", :shape "MapOfStringToString"})) (clojure.core/contains? input :response-templates) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-templates)) #:http.request.field{:name "responseTemplates", :shape "MapOfStringToString"})) (clojure.core/contains? input :content-handling) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-content-handling-strategy (input :content-handling)) #:http.request.field{:name "contentHandling", :shape "ContentHandlingStrategy"}))))

(clojure.core/defn- req-update-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]}))

(clojure.core/defn- req-get-export-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"}) (clojure.core/into (ser-string (input :export-type)) #:http.request.field{:name "exportType", :shape "String", :location "uri", :location-name "export_type"})]} (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"})) (clojure.core/contains? input :accepts) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :accepts)) #:http.request.field{:name "accepts", :shape "String", :location "header", :location-name "Accept"}))))

(clojure.core/defn- req-delete-client-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String", :location "uri", :location-name "clientcertificate_id"})]}))

(clojure.core/defn- req-get-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]} (clojure.core/contains? input :flatten) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :flatten)) #:http.request.field{:name "flatten", :shape "Boolean", :location "querystring", :location-name "flatten"}))))

(clojure.core/defn- req-create-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String"})]} (clojure.core/contains? input :stage-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"}))))

(clojure.core/defn- req-get-request-validators-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :api-stages) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-api-stage (input :api-stages)) #:http.request.field{:name "apiStages", :shape "ListOfApiStage"})) (clojure.core/contains? input :throttle) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-throttle-settings (input :throttle)) #:http.request.field{:name "throttle", :shape "ThrottleSettings"})) (clojure.core/contains? input :quota) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-quota-settings (input :quota)) #:http.request.field{:name "quota", :shape "QuotaSettings"}))))

(clojure.core/defn- req-get-usage-plan-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"}) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "uri", :location-name "keyId"})]}))

(clojure.core/defn- req-put-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]} (clojure.core/contains? input :status-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode"})) (clojure.core/contains? input :response-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-parameters)) #:http.request.field{:name "responseParameters", :shape "MapOfStringToString"})) (clojure.core/contains? input :response-templates) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-templates)) #:http.request.field{:name "responseTemplates", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-flush-stage-cache-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-update-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-delete-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-get-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-create-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}) (clojure.core/into (ser-string (input :content-type)) #:http.request.field{:name "contentType", :shape "String"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :schema) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schema)) #:http.request.field{:name "schema", :shape "String"}))))

(clojure.core/defn- req-delete-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]}))

(clojure.core/defn- req-update-account-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-rest-apis-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-delete-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]}))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "String", :location "uri", :location-name "resource_arn"})], :body [(clojure.core/into (ser-map-of-string-to-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOfStringToString"})]}))

(clojure.core/defn- req-get-model-template-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]}))

(clojure.core/defn- req-delete-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]}))

(clojure.core/defn- req-get-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String", :location "uri", :location-name "requestvalidator_id"})]}))

(clojure.core/defn- req-get-authorizers-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-delete-usage-plan-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"}) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "uri", :location-name "keyId"})]}))

(clojure.core/defn- req-get-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"}) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String", :location "uri", :location-name "base_path"})]}))

(clojure.core/defn- req-update-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-update-integration-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-put-method-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"}) (clojure.core/into (ser-status-code (input :status-code)) #:http.request.field{:name "statusCode", :shape "StatusCode", :location "uri", :location-name "status_code"})]} (clojure.core/contains? input :response-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-boolean (input :response-parameters)) #:http.request.field{:name "responseParameters", :shape "MapOfStringToBoolean"})) (clojure.core/contains? input :response-models) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :response-models)) #:http.request.field{:name "responseModels", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-get-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})]}))

(clojure.core/defn- req-update-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-gateway-responses-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :tracing-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :tracing-enabled)) #:http.request.field{:name "tracingEnabled", :shape "NullableBoolean"})) (clojure.core/contains? input :canary-settings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-deployment-canary-settings (input :canary-settings)) #:http.request.field{:name "canarySettings", :shape "DeploymentCanarySettings"})) (clojure.core/contains? input :stage-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-description)) #:http.request.field{:name "stageDescription", :shape "String"})) (clojure.core/contains? input :variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :variables)) #:http.request.field{:name "variables", :shape "MapOfStringToString"})) (clojure.core/contains? input :cache-cluster-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :cache-cluster-enabled)) #:http.request.field{:name "cacheClusterEnabled", :shape "NullableBoolean"})) (clojure.core/contains? input :stage-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :cache-cluster-size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-cluster-size (input :cache-cluster-size)) #:http.request.field{:name "cacheClusterSize", :shape "CacheClusterSize"}))))

(clojure.core/defn- req-get-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :vpc-link-id)) #:http.request.field{:name "vpcLinkId", :shape "String", :location "uri", :location-name "vpclink_id"})]}))

(clojure.core/defn- req-create-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})) (clojure.core/contains? input :validate-request-body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :validate-request-body)) #:http.request.field{:name "validateRequestBody", :shape "Boolean"})) (clojure.core/contains? input :validate-request-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :validate-request-parameters)) #:http.request.field{:name "validateRequestParameters", :shape "Boolean"}))))

(clojure.core/defn- req-get-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String", :location "uri", :location-name "doc_version"})]}))

(clojure.core/defn- req-get-api-keys-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :name-query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name-query)) #:http.request.field{:name "nameQuery", :shape "String", :location "querystring", :location-name "name"})) (clojure.core/contains? input :customer-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :customer-id)) #:http.request.field{:name "customerId", :shape "String", :location "querystring", :location-name "customerId"})) (clojure.core/contains? input :include-values) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :include-values)) #:http.request.field{:name "includeValues", :shape "NullableBoolean", :location "querystring", :location-name "includeValues"}))))

(clojure.core/defn- req-get-usage-plan-keys-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :name-query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name-query)) #:http.request.field{:name "nameQuery", :shape "String", :location "querystring", :location-name "name"}))))

(clojure.core/defn- req-update-client-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :client-certificate-id)) #:http.request.field{:name "clientCertificateId", :shape "String", :location "uri", :location-name "clientcertificate_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-create-api-key-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "enabled", :shape "Boolean"})) (clojure.core/contains? input :generate-distinct-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :generate-distinct-id)) #:http.request.field{:name "generateDistinctId", :shape "Boolean"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "value", :shape "String"})) (clojure.core/contains? input :stage-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-stage-keys (input :stage-keys)) #:http.request.field{:name "stageKeys", :shape "ListOfStageKeys"})) (clojure.core/contains? input :customer-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :customer-id)) #:http.request.field{:name "customerId", :shape "String"}))))

(clojure.core/defn- req-get-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "uri", :location-name "deployment_id"})]} (clojure.core/contains? input :embed) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :embed)) #:http.request.field{:name "embed", :shape "ListOfString", :location "querystring", :location-name "embed"}))))

(clojure.core/defn- req-delete-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String", :location "uri", :location-name "doc_version"})]}))

(clojure.core/defn- req-get-client-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-delete-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"}) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String", :location "uri", :location-name "base_path"})]}))

(clojure.core/defn- req-update-model-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :model-name)) #:http.request.field{:name "modelName", :shape "String", :location "uri", :location-name "model_name"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-update-documentation-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String", :location "uri", :location-name "doc_version"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-create-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :name)) #:http.request.field{:name "name", :shape "String"}) (clojure.core/into (ser-authorizer-type (input :type)) #:http.request.field{:name "type", :shape "AuthorizerType"})]} (clojure.core/contains? input :authorizer-credentials) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :authorizer-credentials)) #:http.request.field{:name "authorizerCredentials", :shape "String"})) (clojure.core/contains? input :identity-validation-expression) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :identity-validation-expression)) #:http.request.field{:name "identityValidationExpression", :shape "String"})) (clojure.core/contains? input :authorizer-result-ttl-in-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :authorizer-result-ttl-in-seconds)) #:http.request.field{:name "authorizerResultTtlInSeconds", :shape "NullableInteger"})) (clojure.core/contains? input :authorizer-uri) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :authorizer-uri)) #:http.request.field{:name "authorizerUri", :shape "String"})) (clojure.core/contains? input :auth-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :auth-type)) #:http.request.field{:name "authType", :shape "String"})) (clojure.core/contains? input :identity-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :identity-source)) #:http.request.field{:name "identitySource", :shape "String"})) (clojure.core/contains? input :provider-ar-ns) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-ar-ns (input :provider-ar-ns)) #:http.request.field{:name "providerARNs", :shape "ListOfARNs"}))))

(clojure.core/defn- req-delete-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]}))

(clojure.core/defn- req-get-tags-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "String", :location "uri", :location-name "resource_arn"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-gateway-response-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-gateway-response-type (input :response-type)) #:http.request.field{:name "responseType", :shape "GatewayResponseType", :location "uri", :location-name "response_type"})]}))

(clojure.core/defn- req-get-domain-names-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-base-path-mapping-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String", :location "uri", :location-name "domain_name"})], :body [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String"})]} (clojure.core/contains? input :base-path) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :base-path)) #:http.request.field{:name "basePath", :shape "String"})) (clojure.core/contains? input :stage) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stage)) #:http.request.field{:name "stage", :shape "String"}))))

(clojure.core/defn- req-create-stage-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String"})]} (clojure.core/contains? input :tracing-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :tracing-enabled)) #:http.request.field{:name "tracingEnabled", :shape "Boolean"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOfStringToString"})) (clojure.core/contains? input :documentation-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :documentation-version)) #:http.request.field{:name "documentationVersion", :shape "String"})) (clojure.core/contains? input :canary-settings) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-canary-settings (input :canary-settings)) #:http.request.field{:name "canarySettings", :shape "CanarySettings"})) (clojure.core/contains? input :variables) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :variables)) #:http.request.field{:name "variables", :shape "MapOfStringToString"})) (clojure.core/contains? input :cache-cluster-enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :cache-cluster-enabled)) #:http.request.field{:name "cacheClusterEnabled", :shape "Boolean"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "description", :shape "String"})) (clojure.core/contains? input :cache-cluster-size) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cache-cluster-size (input :cache-cluster-size)) #:http.request.field{:name "cacheClusterSize", :shape "CacheClusterSize"}))))

(clojure.core/defn- req-get-models-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-api-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "apiKey", :shape "String", :location "uri", :location-name "api_Key"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-update-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-documentation-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-deployments-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-account-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-import-api-keys-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})], :querystring [(clojure.core/into (ser-api-keys-format (input :format)) #:http.request.field{:name "format", :shape "ApiKeysFormat", :location "querystring", :location-name "format"})]} (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"}))))

(clojure.core/defn- req-get-vpc-links-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-create-usage-plan-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})], :body [(clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String"}) (clojure.core/into (ser-string (input :key-type)) #:http.request.field{:name "keyType", :shape "String"})]}))

(clojure.core/defn- req-delete-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-import-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-blob (input :body)) #:http.request.field{:name "body", :shape "Blob"})]} (clojure.core/contains? input :fail-on-warnings) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :fail-on-warnings)) #:http.request.field{:name "failOnWarnings", :shape "Boolean", :location "querystring", :location-name "failonwarnings"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :parameters)) #:http.request.field{:name "parameters", :shape "MapOfStringToString", :location "querystring"}))))

(clojure.core/defn- req-get-documentation-parts-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]} (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-documentation-part-type (input :type)) #:http.request.field{:name "type", :shape "DocumentationPartType", :location "querystring", :location-name "type"})) (clojure.core/contains? input :name-query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name-query)) #:http.request.field{:name "nameQuery", :shape "String", :location "querystring", :location-name "name"})) (clojure.core/contains? input :path) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :path)) #:http.request.field{:name "path", :shape "String", :location "querystring", :location-name "path"})) (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :location-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-location-status-type (input :location-status)) #:http.request.field{:name "locationStatus", :shape "LocationStatusType", :location "querystring", :location-name "locationStatus"}))))

(clojure.core/defn- req-update-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-delete-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]}))

(clojure.core/defn- req-get-api-key-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "apiKey", :shape "String", :location "uri", :location-name "api_Key"})]} (clojure.core/contains? input :include-value) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-boolean (input :include-value)) #:http.request.field{:name "includeValue", :shape "NullableBoolean", :location "querystring", :location-name "includeValue"}))))

(clojure.core/defn- req-update-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :vpc-link-id)) #:http.request.field{:name "vpcLinkId", :shape "String", :location "uri", :location-name "vpclink_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-create-domain-name-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :domain-name)) #:http.request.field{:name "domainName", :shape "String"})]} (clojure.core/contains? input :certificate-chain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-chain)) #:http.request.field{:name "certificateChain", :shape "String"})) (clojure.core/contains? input :endpoint-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-configuration (input :endpoint-configuration)) #:http.request.field{:name "endpointConfiguration", :shape "EndpointConfiguration"})) (clojure.core/contains? input :certificate-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-arn)) #:http.request.field{:name "certificateArn", :shape "String"})) (clojure.core/contains? input :certificate-private-key) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-private-key)) #:http.request.field{:name "certificatePrivateKey", :shape "String"})) (clojure.core/contains? input :regional-certificate-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :regional-certificate-arn)) #:http.request.field{:name "regionalCertificateArn", :shape "String"})) (clojure.core/contains? input :regional-certificate-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :regional-certificate-name)) #:http.request.field{:name "regionalCertificateName", :shape "String"})) (clojure.core/contains? input :certificate-body) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-body)) #:http.request.field{:name "certificateBody", :shape "String"})) (clojure.core/contains? input :certificate-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "String"}))))

(clojure.core/defn- req-flush-stage-authorizers-cache-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :stage-name)) #:http.request.field{:name "stageName", :shape "String", :location "uri", :location-name "stage_name"})]}))

(clojure.core/defn- req-get-usage-plan-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :usage-plan-id)) #:http.request.field{:name "usagePlanId", :shape "String", :location "uri", :location-name "usageplanId"})]}))

(clojure.core/defn- req-delete-deployment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :deployment-id)) #:http.request.field{:name "deploymentId", :shape "String", :location "uri", :location-name "deployment_id"})]}))

(clojure.core/defn- req-delete-vpc-link-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :vpc-link-id)) #:http.request.field{:name "vpcLinkId", :shape "String", :location "uri", :location-name "vpclink_id"})]}))

(clojure.core/defn- req-get-rest-api-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})]}))

(clojure.core/defn- req-update-integration-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-put-method-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :resource-id)) #:http.request.field{:name "resourceId", :shape "String", :location "uri", :location-name "resource_id"}) (clojure.core/into (ser-string (input :http-method)) #:http.request.field{:name "httpMethod", :shape "String", :location "uri", :location-name "http_method"})], :body [(clojure.core/into (ser-string (input :authorization-type)) #:http.request.field{:name "authorizationType", :shape "String"})]} (clojure.core/contains? input :authorizer-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String"})) (clojure.core/contains? input :request-validator-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String"})) (clojure.core/contains? input :operation-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :operation-name)) #:http.request.field{:name "operationName", :shape "String"})) (clojure.core/contains? input :request-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-boolean (input :request-parameters)) #:http.request.field{:name "requestParameters", :shape "MapOfStringToBoolean"})) (clojure.core/contains? input :authorization-scopes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :authorization-scopes)) #:http.request.field{:name "authorizationScopes", :shape "ListOfString"})) (clojure.core/contains? input :api-key-required) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :api-key-required)) #:http.request.field{:name "apiKeyRequired", :shape "Boolean"})) (clojure.core/contains? input :request-models) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string-to-string (input :request-models)) #:http.request.field{:name "requestModels", :shape "MapOfStringToString"}))))

(clojure.core/defn- req-delete-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]}))

(clojure.core/defn- req-update-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :authorizer-id)) #:http.request.field{:name "authorizerId", :shape "String", :location "uri", :location-name "authorizer_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "String", :location "uri", :location-name "resource_arn"})], :querystring [(clojure.core/into (ser-list-of-string (input :tag-keys)) #:http.request.field{:name "tagKeys", :shape "ListOfString", :location "querystring", :location-name "tagKeys"})]}))

(clojure.core/defn- req-delete-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String", :location "uri", :location-name "requestvalidator_id"})]}))

(clojure.core/defn- req-create-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"})], :body [(clojure.core/into (ser-documentation-part-location (input :location)) #:http.request.field{:name "location", :shape "DocumentationPartLocation"}) (clojure.core/into (ser-string (input :properties)) #:http.request.field{:name "properties", :shape "String"})]}))

(clojure.core/defn- req-update-request-validator-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :request-validator-id)) #:http.request.field{:name "requestValidatorId", :shape "String", :location "uri", :location-name "requestvalidator_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/defn- req-get-usage-plans-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :position) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :position)) #:http.request.field{:name "position", :shape "String", :location "querystring", :location-name "position"})) (clojure.core/contains? input :key-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key-id)) #:http.request.field{:name "keyId", :shape "String", :location "querystring", :location-name "keyId"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-nullable-integer (input :limit)) #:http.request.field{:name "limit", :shape "NullableInteger", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-update-documentation-part-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :rest-api-id)) #:http.request.field{:name "restApiId", :shape "String", :location "uri", :location-name "restapi_id"}) (clojure.core/into (ser-string (input :documentation-part-id)) #:http.request.field{:name "documentationPartId", :shape "String", :location "uri", :location-name "part_id"})]} (clojure.core/contains? input :patch-operations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-patch-operation (input :patch-operations)) #:http.request.field{:name "patchOperations", :shape "ListOfPatchOperation"}))))

(clojure.core/declare deser-documentation-part-location-status-code)

(clojure.core/declare deser-rest-api)

(clojure.core/declare deser-double)

(clojure.core/declare deser-list-of-documentation-part)

(clojure.core/declare deser-map-of-method-snapshot)

(clojure.core/declare deser-deployment)

(clojure.core/declare deser-gateway-response-type)

(clojure.core/declare deser-list-of-client-certificate)

(clojure.core/declare deser-method-setting)

(clojure.core/declare deser-status-code)

(clojure.core/declare deser-api-stage)

(clojure.core/declare deser-map-of-method)

(clojure.core/declare deser-list-of-vpc-link)

(clojure.core/declare deser-documentation-part)

(clojure.core/declare deser-map-of-string-to-list)

(clojure.core/declare deser-method-snapshot)

(clojure.core/declare deser-list-of-model)

(clojure.core/declare deser-endpoint-type)

(clojure.core/declare deser-list-of-sdk-configuration-property)

(clojure.core/declare deser-list-of-string)

(clojure.core/declare deser-documentation-part-type)

(clojure.core/declare deser-list-of-request-validator)

(clojure.core/declare deser-list-of-rest-api)

(clojure.core/declare deser-list-of-usage-plan-key)

(clojure.core/declare deser-nullable-boolean)

(clojure.core/declare deser-method-response)

(clojure.core/declare deser-list-of-deployment)

(clojure.core/declare deser-request-validator)

(clojure.core/declare deser-sdk-type)

(clojure.core/declare deser-cache-cluster-status)

(clojure.core/declare deser-list-of-gateway-response)

(clojure.core/declare deser-map-of-string-to-boolean)

(clojure.core/declare deser-map-of-method-settings)

(clojure.core/declare deser-quota-period-type)

(clojure.core/declare deser-usage-plan)

(clojure.core/declare deser-list-of-long)

(clojure.core/declare deser-api-key-source-type)

(clojure.core/declare deser-throttle-settings)

(clojure.core/declare deser-list-of-sdk-type)

(clojure.core/declare deser-cache-cluster-size)

(clojure.core/declare deser-gateway-response)

(clojure.core/declare deser-integration-type)

(clojure.core/declare deser-base-path-mapping)

(clojure.core/declare deser-list-of-resource)

(clojure.core/declare deser-model)

(clojure.core/declare deser-authorizer-type)

(clojure.core/declare deser-list-of-ar-ns)

(clojure.core/declare deser-list-of-api-stage)

(clojure.core/declare deser-method)

(clojure.core/declare deser-list-of-stage)

(clojure.core/declare deser-map-of-method-response)

(clojure.core/declare deser-canary-settings)

(clojure.core/declare deser-list-of-usage)

(clojure.core/declare deser-access-log-settings)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-string)

(clojure.core/declare deser-vpc-link-status)

(clojure.core/declare deser-list-of-documentation-version)

(clojure.core/declare deser-quota-settings)

(clojure.core/declare deser-provider-arn)

(clojure.core/declare deser-path-to-map-of-method-snapshot)

(clojure.core/declare deser-usage-plan-key)

(clojure.core/declare deser-map-of-string-to-string)

(clojure.core/declare deser-connection-type)

(clojure.core/declare deser-documentation-part-location)

(clojure.core/declare deser-client-certificate)

(clojure.core/declare deser-map-of-key-usages)

(clojure.core/declare deser-long)

(clojure.core/declare deser-list-of-authorizer)

(clojure.core/declare deser-timestamp)

(clojure.core/declare deser-list-of-usage-plan)

(clojure.core/declare deser-resource)

(clojure.core/declare deser-list-of-endpoint-type)

(clojure.core/declare deser-sdk-configuration-property)

(clojure.core/declare deser-api-key)

(clojure.core/declare deser-nullable-integer)

(clojure.core/declare deser-domain-name)

(clojure.core/declare deser-list-of-base-path-mapping)

(clojure.core/declare deser-map-of-api-stage-throttle-settings)

(clojure.core/declare deser-blob)

(clojure.core/declare deser-integration)

(clojure.core/declare deser-documentation-version)

(clojure.core/declare deser-unauthorized-cache-control-header-strategy)

(clojure.core/declare deser-list-of-api-key)

(clojure.core/declare deser-integration-response)

(clojure.core/declare deser-list-of-domain-name)

(clojure.core/declare deser-endpoint-configuration)

(clojure.core/declare deser-vpc-link)

(clojure.core/declare deser-stage)

(clojure.core/declare deser-content-handling-strategy)

(clojure.core/declare deser-map-of-integration-response)

(clojure.core/declare deser-authorizer)

(clojure.core/declare deser-boolean)

(clojure.core/defn- deser-documentation-part-location-status-code [input] input)

(clojure.core/defn- deser-rest-api [input] (clojure.core/cond-> {} (clojure.core/contains? input "apiKeySource") (clojure.core/assoc :api-key-source (deser-api-key-source-type (input "apiKeySource"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "binaryMediaTypes") (clojure.core/assoc :binary-media-types (deser-list-of-string (input "binaryMediaTypes"))) (clojure.core/contains? input "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (input "endpointConfiguration"))) (clojure.core/contains? input "policy") (clojure.core/assoc :policy (deser-string (input "policy"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-string (input "version"))) (clojure.core/contains? input "minimumCompressionSize") (clojure.core/assoc :minimum-compression-size (deser-nullable-integer (input "minimumCompressionSize"))) (clojure.core/contains? input "warnings") (clojure.core/assoc :warnings (deser-list-of-string (input "warnings"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description")))))

(clojure.core/defn- deser-double [input] input)

(clojure.core/defn- deser-list-of-documentation-part [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-documentation-part coll))) input))

(clojure.core/defn- deser-map-of-method-snapshot [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method-snapshot v)])) input))

(clojure.core/defn- deser-deployment [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "apiSummary") (clojure.core/assoc :api-summary (deser-path-to-map-of-method-snapshot (input "apiSummary")))))

(clojure.core/defn- deser-gateway-response-type [input] (clojure.core/get {"REQUEST_TOO_LARGE" :request-too-large, "INTEGRATION_TIMEOUT" :integration-timeout, "RESOURCE_NOT_FOUND" :resource-not-found, "AUTHORIZER_CONFIGURATION_ERROR" :authorizer-configuration-error, "INTEGRATION_FAILURE" :integration-failure, "DEFAULT_5XX" :default-5-xx, "UNAUTHORIZED" :unauthorized, "AUTHORIZER_FAILURE" :authorizer-failure, "INVALID_API_KEY" :invalid-api-key, "ACCESS_DENIED" :access-denied, "API_CONFIGURATION_ERROR" :api-configuration-error, "DEFAULT_4XX" :default-4-xx, "INVALID_SIGNATURE" :invalid-signature, "EXPIRED_TOKEN" :expired-token, "UNSUPPORTED_MEDIA_TYPE" :unsupported-media-type, "QUOTA_EXCEEDED" :quota-exceeded, "BAD_REQUEST_PARAMETERS" :bad-request-parameters, "MISSING_AUTHENTICATION_TOKEN" :missing-authentication-token, "BAD_REQUEST_BODY" :bad-request-body, "THROTTLED" :throttled} input))

(clojure.core/defn- deser-list-of-client-certificate [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-client-certificate coll))) input))

(clojure.core/defn- deser-method-setting [input] (clojure.core/cond-> {} (clojure.core/contains? input "loggingLevel") (clojure.core/assoc :logging-level (deser-string (input "loggingLevel"))) (clojure.core/contains? input "metricsEnabled") (clojure.core/assoc :metrics-enabled (deser-boolean (input "metricsEnabled"))) (clojure.core/contains? input "cachingEnabled") (clojure.core/assoc :caching-enabled (deser-boolean (input "cachingEnabled"))) (clojure.core/contains? input "throttlingRateLimit") (clojure.core/assoc :throttling-rate-limit (deser-double (input "throttlingRateLimit"))) (clojure.core/contains? input "cacheTtlInSeconds") (clojure.core/assoc :cache-ttl-in-seconds (deser-integer (input "cacheTtlInSeconds"))) (clojure.core/contains? input "unauthorizedCacheControlHeaderStrategy") (clojure.core/assoc :unauthorized-cache-control-header-strategy (deser-unauthorized-cache-control-header-strategy (input "unauthorizedCacheControlHeaderStrategy"))) (clojure.core/contains? input "cacheDataEncrypted") (clojure.core/assoc :cache-data-encrypted (deser-boolean (input "cacheDataEncrypted"))) (clojure.core/contains? input "throttlingBurstLimit") (clojure.core/assoc :throttling-burst-limit (deser-integer (input "throttlingBurstLimit"))) (clojure.core/contains? input "requireAuthorizationForCacheControl") (clojure.core/assoc :require-authorization-for-cache-control (deser-boolean (input "requireAuthorizationForCacheControl"))) (clojure.core/contains? input "dataTraceEnabled") (clojure.core/assoc :data-trace-enabled (deser-boolean (input "dataTraceEnabled")))))

(clojure.core/defn- deser-status-code [input] input)

(clojure.core/defn- deser-api-stage [input] (clojure.core/cond-> {} (clojure.core/contains? input "apiId") (clojure.core/assoc :api-id (deser-string (input "apiId"))) (clojure.core/contains? input "stage") (clojure.core/assoc :stage (deser-string (input "stage"))) (clojure.core/contains? input "throttle") (clojure.core/assoc :throttle (deser-map-of-api-stage-throttle-settings (input "throttle")))))

(clojure.core/defn- deser-map-of-method [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method v)])) input))

(clojure.core/defn- deser-list-of-vpc-link [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-link coll))) input))

(clojure.core/defn- deser-documentation-part [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "location") (clojure.core/assoc :location (deser-documentation-part-location (input "location"))) (clojure.core/contains? input "properties") (clojure.core/assoc :properties (deser-string (input "properties")))))

(clojure.core/defn- deser-map-of-string-to-list [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-list-of-string v)])) input))

(clojure.core/defn- deser-method-snapshot [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizationType") (clojure.core/assoc :authorization-type (deser-string (input "authorizationType"))) (clojure.core/contains? input "apiKeyRequired") (clojure.core/assoc :api-key-required (deser-boolean (input "apiKeyRequired")))))

(clojure.core/defn- deser-list-of-model [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-model coll))) input))

(clojure.core/defn- deser-endpoint-type [input] (clojure.core/get {"REGIONAL" :regional, "EDGE" :edge, "PRIVATE" :private} input))

(clojure.core/defn- deser-list-of-sdk-configuration-property [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-sdk-configuration-property coll))) input))

(clojure.core/defn- deser-list-of-string [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-documentation-part-type [input] (clojure.core/get {"PATH_PARAMETER" :path-parameter, "API" :api, "REQUEST_HEADER" :request-header, "METHOD" :method, "RESOURCE" :resource, "RESPONSE_HEADER" :response-header, "REQUEST_BODY" :request-body, "QUERY_PARAMETER" :query-parameter, "AUTHORIZER" :authorizer, "MODEL" :model, "RESPONSE" :response, "RESPONSE_BODY" :response-body} input))

(clojure.core/defn- deser-list-of-request-validator [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-request-validator coll))) input))

(clojure.core/defn- deser-list-of-rest-api [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-rest-api coll))) input))

(clojure.core/defn- deser-list-of-usage-plan-key [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-usage-plan-key coll))) input))

(clojure.core/defn- deser-nullable-boolean [input] input)

(clojure.core/defn- deser-method-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-status-code (input "statusCode"))) (clojure.core/contains? input "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-boolean (input "responseParameters"))) (clojure.core/contains? input "responseModels") (clojure.core/assoc :response-models (deser-map-of-string-to-string (input "responseModels")))))

(clojure.core/defn- deser-list-of-deployment [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-deployment coll))) input))

(clojure.core/defn- deser-request-validator [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "validateRequestBody") (clojure.core/assoc :validate-request-body (deser-boolean (input "validateRequestBody"))) (clojure.core/contains? input "validateRequestParameters") (clojure.core/assoc :validate-request-parameters (deser-boolean (input "validateRequestParameters")))))

(clojure.core/defn- deser-sdk-type [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "friendlyName") (clojure.core/assoc :friendly-name (deser-string (input "friendlyName"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "configurationProperties") (clojure.core/assoc :configuration-properties (deser-list-of-sdk-configuration-property (input "configurationProperties")))))

(clojure.core/defn- deser-cache-cluster-status [input] (clojure.core/get {"CREATE_IN_PROGRESS" :create-in-progress, "AVAILABLE" :available, "DELETE_IN_PROGRESS" :delete-in-progress, "NOT_AVAILABLE" :not-available, "FLUSH_IN_PROGRESS" :flush-in-progress} input))

(clojure.core/defn- deser-list-of-gateway-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-gateway-response coll))) input))

(clojure.core/defn- deser-map-of-string-to-boolean [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-nullable-boolean v)])) input))

(clojure.core/defn- deser-map-of-method-settings [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method-setting v)])) input))

(clojure.core/defn- deser-quota-period-type [input] (clojure.core/get {"DAY" :day, "WEEK" :week, "MONTH" :month} input))

(clojure.core/defn- deser-usage-plan [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "apiStages") (clojure.core/assoc :api-stages (deser-list-of-api-stage (input "apiStages"))) (clojure.core/contains? input "throttle") (clojure.core/assoc :throttle (deser-throttle-settings (input "throttle"))) (clojure.core/contains? input "quota") (clojure.core/assoc :quota (deser-quota-settings (input "quota"))) (clojure.core/contains? input "productCode") (clojure.core/assoc :product-code (deser-string (input "productCode")))))

(clojure.core/defn- deser-list-of-long [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-long coll))) input))

(clojure.core/defn- deser-api-key-source-type [input] (clojure.core/get {"HEADER" :header, "AUTHORIZER" :authorizer} input))

(clojure.core/defn- deser-throttle-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "burstLimit") (clojure.core/assoc :burst-limit (deser-integer (input "burstLimit"))) (clojure.core/contains? input "rateLimit") (clojure.core/assoc :rate-limit (deser-double (input "rateLimit")))))

(clojure.core/defn- deser-list-of-sdk-type [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-sdk-type coll))) input))

(clojure.core/defn- deser-cache-cluster-size [input] (clojure.core/get {"0.5" :05, "1.6" :16, "6.1" :61, "13.5" :135, "28.4" :284, "58.2" :582, "118" :118, "237" :237} input))

(clojure.core/defn- deser-gateway-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "responseType") (clojure.core/assoc :response-type (deser-gateway-response-type (input "responseType"))) (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-status-code (input "statusCode"))) (clojure.core/contains? input "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (input "responseParameters"))) (clojure.core/contains? input "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (input "responseTemplates"))) (clojure.core/contains? input "defaultResponse") (clojure.core/assoc :default-response (deser-boolean (input "defaultResponse")))))

(clojure.core/defn- deser-integration-type [input] (clojure.core/get {"HTTP" :http, "AWS" :aws, "MOCK" :mock, "HTTP_PROXY" :http-proxy, "AWS_PROXY" :aws-proxy} input))

(clojure.core/defn- deser-base-path-mapping [input] (clojure.core/cond-> {} (clojure.core/contains? input "basePath") (clojure.core/assoc :base-path (deser-string (input "basePath"))) (clojure.core/contains? input "restApiId") (clojure.core/assoc :rest-api-id (deser-string (input "restApiId"))) (clojure.core/contains? input "stage") (clojure.core/assoc :stage (deser-string (input "stage")))))

(clojure.core/defn- deser-list-of-resource [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource coll))) input))

(clojure.core/defn- deser-model [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "schema") (clojure.core/assoc :schema (deser-string (input "schema"))) (clojure.core/contains? input "contentType") (clojure.core/assoc :content-type (deser-string (input "contentType")))))

(clojure.core/defn- deser-authorizer-type [input] (clojure.core/get {"TOKEN" :token, "REQUEST" :request, "COGNITO_USER_POOLS" :cognito-user-pools} input))

(clojure.core/defn- deser-list-of-ar-ns [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-provider-arn coll))) input))

(clojure.core/defn- deser-list-of-api-stage [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-api-stage coll))) input))

(clojure.core/defn- deser-method [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerId") (clojure.core/assoc :authorizer-id (deser-string (input "authorizerId"))) (clojure.core/contains? input "requestValidatorId") (clojure.core/assoc :request-validator-id (deser-string (input "requestValidatorId"))) (clojure.core/contains? input "authorizationType") (clojure.core/assoc :authorization-type (deser-string (input "authorizationType"))) (clojure.core/contains? input "httpMethod") (clojure.core/assoc :http-method (deser-string (input "httpMethod"))) (clojure.core/contains? input "operationName") (clojure.core/assoc :operation-name (deser-string (input "operationName"))) (clojure.core/contains? input "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-boolean (input "requestParameters"))) (clojure.core/contains? input "authorizationScopes") (clojure.core/assoc :authorization-scopes (deser-list-of-string (input "authorizationScopes"))) (clojure.core/contains? input "apiKeyRequired") (clojure.core/assoc :api-key-required (deser-nullable-boolean (input "apiKeyRequired"))) (clojure.core/contains? input "requestModels") (clojure.core/assoc :request-models (deser-map-of-string-to-string (input "requestModels"))) (clojure.core/contains? input "methodIntegration") (clojure.core/assoc :method-integration (deser-integration (input "methodIntegration"))) (clojure.core/contains? input "methodResponses") (clojure.core/assoc :method-responses (deser-map-of-method-response (input "methodResponses")))))

(clojure.core/defn- deser-list-of-stage [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stage coll))) input))

(clojure.core/defn- deser-map-of-method-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-method-response v)])) input))

(clojure.core/defn- deser-canary-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "percentTraffic") (clojure.core/assoc :percent-traffic (deser-double (input "percentTraffic"))) (clojure.core/contains? input "deploymentId") (clojure.core/assoc :deployment-id (deser-string (input "deploymentId"))) (clojure.core/contains? input "stageVariableOverrides") (clojure.core/assoc :stage-variable-overrides (deser-map-of-string-to-string (input "stageVariableOverrides"))) (clojure.core/contains? input "useStageCache") (clojure.core/assoc :use-stage-cache (deser-boolean (input "useStageCache")))))

(clojure.core/defn- deser-list-of-usage [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-list-of-long coll))) input))

(clojure.core/defn- deser-access-log-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "format") (clojure.core/assoc :format (deser-string (input "format"))) (clojure.core/contains? input "destinationArn") (clojure.core/assoc :destination-arn (deser-string (input "destinationArn")))))

(clojure.core/defn- deser-integer [input] input)

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-vpc-link-status [input] (clojure.core/get {"AVAILABLE" :available, "PENDING" :pending, "DELETING" :deleting, "FAILED" :failed} input))

(clojure.core/defn- deser-list-of-documentation-version [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-documentation-version coll))) input))

(clojure.core/defn- deser-quota-settings [input] (clojure.core/cond-> {} (clojure.core/contains? input "limit") (clojure.core/assoc :limit (deser-integer (input "limit"))) (clojure.core/contains? input "offset") (clojure.core/assoc :offset (deser-integer (input "offset"))) (clojure.core/contains? input "period") (clojure.core/assoc :period (deser-quota-period-type (input "period")))))

(clojure.core/defn- deser-provider-arn [input] input)

(clojure.core/defn- deser-path-to-map-of-method-snapshot [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-map-of-method-snapshot v)])) input))

(clojure.core/defn- deser-usage-plan-key [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-string (input "type"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-string (input "value"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name")))))

(clojure.core/defn- deser-map-of-string-to-string [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-connection-type [input] (clojure.core/get {"INTERNET" :internet, "VPC_LINK" :vpc-link} input))

(clojure.core/defn- deser-documentation-part-location [input] (clojure.core/cond-> {:type (deser-documentation-part-type (input "type"))} (clojure.core/contains? input "path") (clojure.core/assoc :path (deser-string (input "path"))) (clojure.core/contains? input "method") (clojure.core/assoc :method (deser-string (input "method"))) (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-documentation-part-location-status-code (input "statusCode"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name")))))

(clojure.core/defn- deser-client-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (input "clientCertificateId"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "pemEncodedCertificate") (clojure.core/assoc :pem-encoded-certificate (deser-string (input "pemEncodedCertificate"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "expirationDate") (clojure.core/assoc :expiration-date (deser-timestamp (input "expirationDate")))))

(clojure.core/defn- deser-map-of-key-usages [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-list-of-usage v)])) input))

(clojure.core/defn- deser-long [input] input)

(clojure.core/defn- deser-list-of-authorizer [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-authorizer coll))) input))

(clojure.core/defn- deser-timestamp [input] input)

(clojure.core/defn- deser-list-of-usage-plan [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-usage-plan coll))) input))

(clojure.core/defn- deser-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "parentId") (clojure.core/assoc :parent-id (deser-string (input "parentId"))) (clojure.core/contains? input "pathPart") (clojure.core/assoc :path-part (deser-string (input "pathPart"))) (clojure.core/contains? input "path") (clojure.core/assoc :path (deser-string (input "path"))) (clojure.core/contains? input "resourceMethods") (clojure.core/assoc :resource-methods (deser-map-of-method (input "resourceMethods")))))

(clojure.core/defn- deser-list-of-endpoint-type [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-endpoint-type coll))) input))

(clojure.core/defn- deser-sdk-configuration-property [input] (clojure.core/cond-> {} (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "friendlyName") (clojure.core/assoc :friendly-name (deser-string (input "friendlyName"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "required") (clojure.core/assoc :required (deser-boolean (input "required"))) (clojure.core/contains? input "defaultValue") (clojure.core/assoc :default-value (deser-string (input "defaultValue")))))

(clojure.core/defn- deser-api-key [input] (clojure.core/cond-> {} (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "enabled") (clojure.core/assoc :enabled (deser-boolean (input "enabled"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "stageKeys") (clojure.core/assoc :stage-keys (deser-list-of-string (input "stageKeys"))) (clojure.core/contains? input "customerId") (clojure.core/assoc :customer-id (deser-string (input "customerId"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-string (input "value"))) (clojure.core/contains? input "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (input "lastUpdatedDate"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description")))))

(clojure.core/defn- deser-nullable-integer [input] input)

(clojure.core/defn- deser-domain-name [input] (clojure.core/cond-> {} (clojure.core/contains? input "domainName") (clojure.core/assoc :domain-name (deser-string (input "domainName"))) (clojure.core/contains? input "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (input "endpointConfiguration"))) (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-string (input "certificateArn"))) (clojure.core/contains? input "regionalHostedZoneId") (clojure.core/assoc :regional-hosted-zone-id (deser-string (input "regionalHostedZoneId"))) (clojure.core/contains? input "regionalCertificateArn") (clojure.core/assoc :regional-certificate-arn (deser-string (input "regionalCertificateArn"))) (clojure.core/contains? input "regionalCertificateName") (clojure.core/assoc :regional-certificate-name (deser-string (input "regionalCertificateName"))) (clojure.core/contains? input "distributionHostedZoneId") (clojure.core/assoc :distribution-hosted-zone-id (deser-string (input "distributionHostedZoneId"))) (clojure.core/contains? input "certificateUploadDate") (clojure.core/assoc :certificate-upload-date (deser-timestamp (input "certificateUploadDate"))) (clojure.core/contains? input "certificateName") (clojure.core/assoc :certificate-name (deser-string (input "certificateName"))) (clojure.core/contains? input "distributionDomainName") (clojure.core/assoc :distribution-domain-name (deser-string (input "distributionDomainName"))) (clojure.core/contains? input "regionalDomainName") (clojure.core/assoc :regional-domain-name (deser-string (input "regionalDomainName")))))

(clojure.core/defn- deser-list-of-base-path-mapping [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-base-path-mapping coll))) input))

(clojure.core/defn- deser-map-of-api-stage-throttle-settings [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-throttle-settings v)])) input))

(clojure.core/defn- deser-blob [input] (portkey.aws/base64-decode input))

(clojure.core/defn- deser-integration [input] (clojure.core/cond-> {} (clojure.core/contains? input "integrationResponses") (clojure.core/assoc :integration-responses (deser-map-of-integration-response (input "integrationResponses"))) (clojure.core/contains? input "connectionId") (clojure.core/assoc :connection-id (deser-string (input "connectionId"))) (clojure.core/contains? input "uri") (clojure.core/assoc :uri (deser-string (input "uri"))) (clojure.core/contains? input "connectionType") (clojure.core/assoc :connection-type (deser-connection-type (input "connectionType"))) (clojure.core/contains? input "httpMethod") (clojure.core/assoc :http-method (deser-string (input "httpMethod"))) (clojure.core/contains? input "requestTemplates") (clojure.core/assoc :request-templates (deser-map-of-string-to-string (input "requestTemplates"))) (clojure.core/contains? input "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-string (input "requestParameters"))) (clojure.core/contains? input "cacheNamespace") (clojure.core/assoc :cache-namespace (deser-string (input "cacheNamespace"))) (clojure.core/contains? input "passthroughBehavior") (clojure.core/assoc :passthrough-behavior (deser-string (input "passthroughBehavior"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-integration-type (input "type"))) (clojure.core/contains? input "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (input "contentHandling"))) (clojure.core/contains? input "cacheKeyParameters") (clojure.core/assoc :cache-key-parameters (deser-list-of-string (input "cacheKeyParameters"))) (clojure.core/contains? input "credentials") (clojure.core/assoc :credentials (deser-string (input "credentials"))) (clojure.core/contains? input "timeoutInMillis") (clojure.core/assoc :timeout-in-millis (deser-integer (input "timeoutInMillis")))))

(clojure.core/defn- deser-documentation-version [input] (clojure.core/cond-> {} (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-string (input "version"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description")))))

(clojure.core/defn- deser-unauthorized-cache-control-header-strategy [input] (clojure.core/get {"FAIL_WITH_403" :fail-with-403, "SUCCEED_WITH_RESPONSE_HEADER" :succeed-with-response-header, "SUCCEED_WITHOUT_RESPONSE_HEADER" :succeed-without-response-header} input))

(clojure.core/defn- deser-list-of-api-key [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-api-key coll))) input))

(clojure.core/defn- deser-integration-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "statusCode") (clojure.core/assoc :status-code (deser-status-code (input "statusCode"))) (clojure.core/contains? input "selectionPattern") (clojure.core/assoc :selection-pattern (deser-string (input "selectionPattern"))) (clojure.core/contains? input "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (input "responseParameters"))) (clojure.core/contains? input "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (input "responseTemplates"))) (clojure.core/contains? input "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (input "contentHandling")))))

(clojure.core/defn- deser-list-of-domain-name [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-domain-name coll))) input))

(clojure.core/defn- deser-endpoint-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "types") (clojure.core/assoc :types (deser-list-of-endpoint-type (input "types")))))

(clojure.core/defn- deser-vpc-link [input] (clojure.core/cond-> {} (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "targetArns") (clojure.core/assoc :target-arns (deser-list-of-string (input "targetArns"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-vpc-link-status (input "status"))) (clojure.core/contains? input "statusMessage") (clojure.core/assoc :status-message (deser-string (input "statusMessage")))))

(clojure.core/defn- deser-stage [input] (clojure.core/cond-> {} (clojure.core/contains? input "cacheClusterStatus") (clojure.core/assoc :cache-cluster-status (deser-cache-cluster-status (input "cacheClusterStatus"))) (clojure.core/contains? input "webAclArn") (clojure.core/assoc :web-acl-arn (deser-string (input "webAclArn"))) (clojure.core/contains? input "tracingEnabled") (clojure.core/assoc :tracing-enabled (deser-boolean (input "tracingEnabled"))) (clojure.core/contains? input "createdDate") (clojure.core/assoc :created-date (deser-timestamp (input "createdDate"))) (clojure.core/contains? input "accessLogSettings") (clojure.core/assoc :access-log-settings (deser-access-log-settings (input "accessLogSettings"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-map-of-string-to-string (input "tags"))) (clojure.core/contains? input "documentationVersion") (clojure.core/assoc :documentation-version (deser-string (input "documentationVersion"))) (clojure.core/contains? input "methodSettings") (clojure.core/assoc :method-settings (deser-map-of-method-settings (input "methodSettings"))) (clojure.core/contains? input "canarySettings") (clojure.core/assoc :canary-settings (deser-canary-settings (input "canarySettings"))) (clojure.core/contains? input "deploymentId") (clojure.core/assoc :deployment-id (deser-string (input "deploymentId"))) (clojure.core/contains? input "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (input "clientCertificateId"))) (clojure.core/contains? input "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (input "lastUpdatedDate"))) (clojure.core/contains? input "variables") (clojure.core/assoc :variables (deser-map-of-string-to-string (input "variables"))) (clojure.core/contains? input "cacheClusterEnabled") (clojure.core/assoc :cache-cluster-enabled (deser-boolean (input "cacheClusterEnabled"))) (clojure.core/contains? input "stageName") (clojure.core/assoc :stage-name (deser-string (input "stageName"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "cacheClusterSize") (clojure.core/assoc :cache-cluster-size (deser-cache-cluster-size (input "cacheClusterSize")))))

(clojure.core/defn- deser-content-handling-strategy [input] (clojure.core/get {"CONVERT_TO_BINARY" :convert-to-binary, "CONVERT_TO_TEXT" :convert-to-text} input))

(clojure.core/defn- deser-map-of-integration-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-integration-response v)])) input))

(clojure.core/defn- deser-authorizer [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerCredentials") (clojure.core/assoc :authorizer-credentials (deser-string (input "authorizerCredentials"))) (clojure.core/contains? input "identityValidationExpression") (clojure.core/assoc :identity-validation-expression (deser-string (input "identityValidationExpression"))) (clojure.core/contains? input "id") (clojure.core/assoc :id (deser-string (input "id"))) (clojure.core/contains? input "name") (clojure.core/assoc :name (deser-string (input "name"))) (clojure.core/contains? input "type") (clojure.core/assoc :type (deser-authorizer-type (input "type"))) (clojure.core/contains? input "authorizerResultTtlInSeconds") (clojure.core/assoc :authorizer-result-ttl-in-seconds (deser-nullable-integer (input "authorizerResultTtlInSeconds"))) (clojure.core/contains? input "authorizerUri") (clojure.core/assoc :authorizer-uri (deser-string (input "authorizerUri"))) (clojure.core/contains? input "authType") (clojure.core/assoc :auth-type (deser-string (input "authType"))) (clojure.core/contains? input "identitySource") (clojure.core/assoc :identity-source (deser-string (input "identitySource"))) (clojure.core/contains? input "providerARNs") (clojure.core/assoc :provider-ar-ns (deser-list-of-ar-ns (input "providerARNs")))))

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- response-rest-api ([input] (response-rest-api nil input)) ([resultWrapper32204 input] (clojure.core/let [rawinput32203 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32205 {"apiKeySource" (rawinput32203 "apiKeySource"), "createdDate" (rawinput32203 "createdDate"), "id" (rawinput32203 "id"), "name" (rawinput32203 "name"), "binaryMediaTypes" (rawinput32203 "binaryMediaTypes"), "endpointConfiguration" (rawinput32203 "endpointConfiguration"), "policy" (rawinput32203 "policy"), "version" (rawinput32203 "version"), "minimumCompressionSize" (rawinput32203 "minimumCompressionSize"), "warnings" (rawinput32203 "warnings"), "description" (rawinput32203 "description")}] (clojure.core/cond-> {} (letvar32205 "apiKeySource") (clojure.core/assoc :api-key-source (deser-api-key-source-type (clojure.core/get-in letvar32205 ["apiKeySource"]))) (letvar32205 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar32205 ["createdDate"]))) (letvar32205 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32205 ["id"]))) (letvar32205 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32205 ["name"]))) (letvar32205 "binaryMediaTypes") (clojure.core/assoc :binary-media-types (deser-list-of-string (clojure.core/get-in letvar32205 ["binaryMediaTypes"]))) (letvar32205 "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (clojure.core/get-in letvar32205 ["endpointConfiguration"]))) (letvar32205 "policy") (clojure.core/assoc :policy (deser-string (clojure.core/get-in letvar32205 ["policy"]))) (letvar32205 "version") (clojure.core/assoc :version (deser-string (clojure.core/get-in letvar32205 ["version"]))) (letvar32205 "minimumCompressionSize") (clojure.core/assoc :minimum-compression-size (deser-nullable-integer (clojure.core/get-in letvar32205 ["minimumCompressionSize"]))) (letvar32205 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar32205 ["warnings"]))) (letvar32205 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32205 ["description"])))))))

(clojure.core/defn- response-unauthorized-exception ([input] (response-unauthorized-exception nil input)) ([resultWrapper32207 input] (clojure.core/let [rawinput32206 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32208 {"message" (rawinput32206 "message")}] (clojure.core/cond-> {} (letvar32208 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32208 ["message"])))))))

(clojure.core/defn- response-api-key-ids ([input] (response-api-key-ids nil input)) ([resultWrapper32210 input] (clojure.core/let [rawinput32209 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32211 {"ids" (rawinput32209 "ids"), "warnings" (rawinput32209 "warnings")}] (clojure.core/cond-> {} (letvar32211 "ids") (clojure.core/assoc :ids (deser-list-of-string (clojure.core/get-in letvar32211 ["ids"]))) (letvar32211 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar32211 ["warnings"])))))))

(clojure.core/defn- response-deployment ([input] (response-deployment nil input)) ([resultWrapper32213 input] (clojure.core/let [rawinput32212 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32214 {"id" (rawinput32212 "id"), "description" (rawinput32212 "description"), "createdDate" (rawinput32212 "createdDate"), "apiSummary" (rawinput32212 "apiSummary")}] (clojure.core/cond-> {} (letvar32214 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32214 ["id"]))) (letvar32214 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32214 ["description"]))) (letvar32214 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar32214 ["createdDate"]))) (letvar32214 "apiSummary") (clojure.core/assoc :api-summary (deser-path-to-map-of-method-snapshot (clojure.core/get-in letvar32214 ["apiSummary"])))))))

(clojure.core/defn- response-bad-request-exception ([input] (response-bad-request-exception nil input)) ([resultWrapper32216 input] (clojure.core/let [rawinput32215 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32217 {"message" (rawinput32215 "message")}] (clojure.core/cond-> {} (letvar32217 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32217 ["message"])))))))

(clojure.core/defn- response-test-invoke-authorizer-response ([input] (response-test-invoke-authorizer-response nil input)) ([resultWrapper32219 input] (clojure.core/let [rawinput32218 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32220 {"clientStatus" (rawinput32218 "clientStatus"), "log" (rawinput32218 "log"), "latency" (rawinput32218 "latency"), "principalId" (rawinput32218 "principalId"), "policy" (rawinput32218 "policy"), "authorization" (rawinput32218 "authorization"), "claims" (rawinput32218 "claims")}] (clojure.core/cond-> {} (letvar32220 "clientStatus") (clojure.core/assoc :client-status (deser-integer (clojure.core/get-in letvar32220 ["clientStatus"]))) (letvar32220 "log") (clojure.core/assoc :log (deser-string (clojure.core/get-in letvar32220 ["log"]))) (letvar32220 "latency") (clojure.core/assoc :latency (deser-long (clojure.core/get-in letvar32220 ["latency"]))) (letvar32220 "principalId") (clojure.core/assoc :principal-id (deser-string (clojure.core/get-in letvar32220 ["principalId"]))) (letvar32220 "policy") (clojure.core/assoc :policy (deser-string (clojure.core/get-in letvar32220 ["policy"]))) (letvar32220 "authorization") (clojure.core/assoc :authorization (deser-map-of-string-to-list (clojure.core/get-in letvar32220 ["authorization"]))) (letvar32220 "claims") (clojure.core/assoc :claims (deser-map-of-string-to-string (clojure.core/get-in letvar32220 ["claims"])))))))

(clojure.core/defn- response-documentation-part ([input] (response-documentation-part nil input)) ([resultWrapper32222 input] (clojure.core/let [rawinput32221 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32223 {"id" (rawinput32221 "id"), "location" (rawinput32221 "location"), "properties" (rawinput32221 "properties")}] (clojure.core/cond-> {} (letvar32223 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32223 ["id"]))) (letvar32223 "location") (clojure.core/assoc :location (deser-documentation-part-location (clojure.core/get-in letvar32223 ["location"]))) (letvar32223 "properties") (clojure.core/assoc :properties (deser-string (clojure.core/get-in letvar32223 ["properties"])))))))

(clojure.core/defn- response-rest-apis ([input] (response-rest-apis nil input)) ([resultWrapper32225 input] (clojure.core/let [rawinput32224 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32226 {"position" (rawinput32224 "position"), "item" (rawinput32224 "item")}] (clojure.core/cond-> {} (letvar32226 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32226 ["position"]))) (letvar32226 "item") (clojure.core/assoc :items (deser-list-of-rest-api (clojure.core/get-in letvar32226 ["item"])))))))

(clojure.core/defn- response-base-path-mappings ([input] (response-base-path-mappings nil input)) ([resultWrapper32228 input] (clojure.core/let [rawinput32227 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32229 {"position" (rawinput32227 "position"), "item" (rawinput32227 "item")}] (clojure.core/cond-> {} (letvar32229 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32229 ["position"]))) (letvar32229 "item") (clojure.core/assoc :items (deser-list-of-base-path-mapping (clojure.core/get-in letvar32229 ["item"])))))))

(clojure.core/defn- response-documentation-versions ([input] (response-documentation-versions nil input)) ([resultWrapper32231 input] (clojure.core/let [rawinput32230 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32232 {"position" (rawinput32230 "position"), "item" (rawinput32230 "item")}] (clojure.core/cond-> {} (letvar32232 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32232 ["position"]))) (letvar32232 "item") (clojure.core/assoc :items (deser-list-of-documentation-version (clojure.core/get-in letvar32232 ["item"])))))))

(clojure.core/defn- response-stages ([input] (response-stages nil input)) ([resultWrapper32234 input] (clojure.core/let [rawinput32233 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32235 {"item" (rawinput32233 "item")}] (clojure.core/cond-> {} (letvar32235 "item") (clojure.core/assoc :item (deser-list-of-stage (clojure.core/get-in letvar32235 ["item"])))))))

(clojure.core/defn- response-tags ([input] (response-tags nil input)) ([resultWrapper32237 input] (clojure.core/let [rawinput32236 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32238 {"tags" (rawinput32236 "tags")}] (clojure.core/cond-> {} (letvar32238 "tags") (clojure.core/assoc :tags (deser-map-of-string-to-string (clojure.core/get-in letvar32238 ["tags"])))))))

(clojure.core/defn- response-template ([input] (response-template nil input)) ([resultWrapper32240 input] (clojure.core/let [rawinput32239 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32241 {"value" (rawinput32239 "value")}] (clojure.core/cond-> {} (letvar32241 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar32241 ["value"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper32243 input] (clojure.core/let [rawinput32242 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32244 {"Retry-After" (clojure.core/get-in input [:headers "Retry-After"]), "message" (rawinput32242 "message")}] (clojure.core/cond-> {} (letvar32244 "Retry-After") (clojure.core/assoc :retry-after-seconds (deser-string (clojure.core/get-in letvar32244 ["Retry-After"]))) (letvar32244 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32244 ["message"])))))))

(clojure.core/defn- response-method-response ([input] (response-method-response nil input)) ([resultWrapper32246 input] (clojure.core/let [rawinput32245 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32247 {"statusCode" (rawinput32245 "statusCode"), "responseParameters" (rawinput32245 "responseParameters"), "responseModels" (rawinput32245 "responseModels")}] (clojure.core/cond-> {} (letvar32247 "statusCode") (clojure.core/assoc :status-code (deser-status-code (clojure.core/get-in letvar32247 ["statusCode"]))) (letvar32247 "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-boolean (clojure.core/get-in letvar32247 ["responseParameters"]))) (letvar32247 "responseModels") (clojure.core/assoc :response-models (deser-map-of-string-to-string (clojure.core/get-in letvar32247 ["responseModels"])))))))

(clojure.core/defn- response-request-validator ([input] (response-request-validator nil input)) ([resultWrapper32249 input] (clojure.core/let [rawinput32248 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32250 {"id" (rawinput32248 "id"), "name" (rawinput32248 "name"), "validateRequestBody" (rawinput32248 "validateRequestBody"), "validateRequestParameters" (rawinput32248 "validateRequestParameters")}] (clojure.core/cond-> {} (letvar32250 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32250 ["id"]))) (letvar32250 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32250 ["name"]))) (letvar32250 "validateRequestBody") (clojure.core/assoc :validate-request-body (deser-boolean (clojure.core/get-in letvar32250 ["validateRequestBody"]))) (letvar32250 "validateRequestParameters") (clojure.core/assoc :validate-request-parameters (deser-boolean (clojure.core/get-in letvar32250 ["validateRequestParameters"])))))))

(clojure.core/defn- response-sdk-type ([input] (response-sdk-type nil input)) ([resultWrapper32252 input] (clojure.core/let [rawinput32251 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32253 {"id" (rawinput32251 "id"), "friendlyName" (rawinput32251 "friendlyName"), "description" (rawinput32251 "description"), "configurationProperties" (rawinput32251 "configurationProperties")}] (clojure.core/cond-> {} (letvar32253 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32253 ["id"]))) (letvar32253 "friendlyName") (clojure.core/assoc :friendly-name (deser-string (clojure.core/get-in letvar32253 ["friendlyName"]))) (letvar32253 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32253 ["description"]))) (letvar32253 "configurationProperties") (clojure.core/assoc :configuration-properties (deser-list-of-sdk-configuration-property (clojure.core/get-in letvar32253 ["configurationProperties"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper32255 input] (clojure.core/let [rawinput32254 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32256 {"Retry-After" (clojure.core/get-in input [:headers "Retry-After"]), "message" (rawinput32254 "message")}] (clojure.core/cond-> {} (letvar32256 "Retry-After") (clojure.core/assoc :retry-after-seconds (deser-string (clojure.core/get-in letvar32256 ["Retry-After"]))) (letvar32256 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32256 ["message"])))))))

(clojure.core/defn- response-client-certificates ([input] (response-client-certificates nil input)) ([resultWrapper32258 input] (clojure.core/let [rawinput32257 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32259 {"position" (rawinput32257 "position"), "item" (rawinput32257 "item")}] (clojure.core/cond-> {} (letvar32259 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32259 ["position"]))) (letvar32259 "item") (clojure.core/assoc :items (deser-list-of-client-certificate (clojure.core/get-in letvar32259 ["item"])))))))

(clojure.core/defn- response-request-validators ([input] (response-request-validators nil input)) ([resultWrapper32261 input] (clojure.core/let [rawinput32260 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32262 {"position" (rawinput32260 "position"), "item" (rawinput32260 "item")}] (clojure.core/cond-> {} (letvar32262 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32262 ["position"]))) (letvar32262 "item") (clojure.core/assoc :items (deser-list-of-request-validator (clojure.core/get-in letvar32262 ["item"])))))))

(clojure.core/defn- response-usage-plan-keys ([input] (response-usage-plan-keys nil input)) ([resultWrapper32264 input] (clojure.core/let [rawinput32263 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32265 {"position" (rawinput32263 "position"), "item" (rawinput32263 "item")}] (clojure.core/cond-> {} (letvar32265 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32265 ["position"]))) (letvar32265 "item") (clojure.core/assoc :items (deser-list-of-usage-plan-key (clojure.core/get-in letvar32265 ["item"])))))))

(clojure.core/defn- response-usage-plan ([input] (response-usage-plan nil input)) ([resultWrapper32267 input] (clojure.core/let [rawinput32266 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32268 {"id" (rawinput32266 "id"), "name" (rawinput32266 "name"), "description" (rawinput32266 "description"), "apiStages" (rawinput32266 "apiStages"), "throttle" (rawinput32266 "throttle"), "quota" (rawinput32266 "quota"), "productCode" (rawinput32266 "productCode")}] (clojure.core/cond-> {} (letvar32268 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32268 ["id"]))) (letvar32268 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32268 ["name"]))) (letvar32268 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32268 ["description"]))) (letvar32268 "apiStages") (clojure.core/assoc :api-stages (deser-list-of-api-stage (clojure.core/get-in letvar32268 ["apiStages"]))) (letvar32268 "throttle") (clojure.core/assoc :throttle (deser-throttle-settings (clojure.core/get-in letvar32268 ["throttle"]))) (letvar32268 "quota") (clojure.core/assoc :quota (deser-quota-settings (clojure.core/get-in letvar32268 ["quota"]))) (letvar32268 "productCode") (clojure.core/assoc :product-code (deser-string (clojure.core/get-in letvar32268 ["productCode"])))))))

(clojure.core/defn- response-too-many-requests-exception ([input] (response-too-many-requests-exception nil input)) ([resultWrapper32270 input] (clojure.core/let [rawinput32269 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32271 {"Retry-After" (clojure.core/get-in input [:headers "Retry-After"]), "message" (rawinput32269 "message")}] (clojure.core/cond-> {} (letvar32271 "Retry-After") (clojure.core/assoc :retry-after-seconds (deser-string (clojure.core/get-in letvar32271 ["Retry-After"]))) (letvar32271 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32271 ["message"])))))))

(clojure.core/defn- response-gateway-response ([input] (response-gateway-response nil input)) ([resultWrapper32273 input] (clojure.core/let [rawinput32272 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32274 {"responseType" (rawinput32272 "responseType"), "statusCode" (rawinput32272 "statusCode"), "responseParameters" (rawinput32272 "responseParameters"), "responseTemplates" (rawinput32272 "responseTemplates"), "defaultResponse" (rawinput32272 "defaultResponse")}] (clojure.core/cond-> {} (letvar32274 "responseType") (clojure.core/assoc :response-type (deser-gateway-response-type (clojure.core/get-in letvar32274 ["responseType"]))) (letvar32274 "statusCode") (clojure.core/assoc :status-code (deser-status-code (clojure.core/get-in letvar32274 ["statusCode"]))) (letvar32274 "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (clojure.core/get-in letvar32274 ["responseParameters"]))) (letvar32274 "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (clojure.core/get-in letvar32274 ["responseTemplates"]))) (letvar32274 "defaultResponse") (clojure.core/assoc :default-response (deser-boolean (clojure.core/get-in letvar32274 ["defaultResponse"])))))))

(clojure.core/defn- response-base-path-mapping ([input] (response-base-path-mapping nil input)) ([resultWrapper32276 input] (clojure.core/let [rawinput32275 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32277 {"basePath" (rawinput32275 "basePath"), "restApiId" (rawinput32275 "restApiId"), "stage" (rawinput32275 "stage")}] (clojure.core/cond-> {} (letvar32277 "basePath") (clojure.core/assoc :base-path (deser-string (clojure.core/get-in letvar32277 ["basePath"]))) (letvar32277 "restApiId") (clojure.core/assoc :rest-api-id (deser-string (clojure.core/get-in letvar32277 ["restApiId"]))) (letvar32277 "stage") (clojure.core/assoc :stage (deser-string (clojure.core/get-in letvar32277 ["stage"])))))))

(clojure.core/defn- response-documentation-part-ids ([input] (response-documentation-part-ids nil input)) ([resultWrapper32279 input] (clojure.core/let [rawinput32278 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32280 {"ids" (rawinput32278 "ids"), "warnings" (rawinput32278 "warnings")}] (clojure.core/cond-> {} (letvar32280 "ids") (clojure.core/assoc :ids (deser-list-of-string (clojure.core/get-in letvar32280 ["ids"]))) (letvar32280 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar32280 ["warnings"])))))))

(clojure.core/defn- response-model ([input] (response-model nil input)) ([resultWrapper32282 input] (clojure.core/let [rawinput32281 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32283 {"id" (rawinput32281 "id"), "name" (rawinput32281 "name"), "description" (rawinput32281 "description"), "schema" (rawinput32281 "schema"), "contentType" (rawinput32281 "contentType")}] (clojure.core/cond-> {} (letvar32283 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32283 ["id"]))) (letvar32283 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32283 ["name"]))) (letvar32283 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32283 ["description"]))) (letvar32283 "schema") (clojure.core/assoc :schema (deser-string (clojure.core/get-in letvar32283 ["schema"]))) (letvar32283 "contentType") (clojure.core/assoc :content-type (deser-string (clojure.core/get-in letvar32283 ["contentType"])))))))

(clojure.core/defn- response-domain-names ([input] (response-domain-names nil input)) ([resultWrapper32285 input] (clojure.core/let [rawinput32284 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32286 {"position" (rawinput32284 "position"), "item" (rawinput32284 "item")}] (clojure.core/cond-> {} (letvar32286 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32286 ["position"]))) (letvar32286 "item") (clojure.core/assoc :items (deser-list-of-domain-name (clojure.core/get-in letvar32286 ["item"])))))))

(clojure.core/defn- response-conflict-exception ([input] (response-conflict-exception nil input)) ([resultWrapper32288 input] (clojure.core/let [rawinput32287 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32289 {"message" (rawinput32287 "message")}] (clojure.core/cond-> {} (letvar32289 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32289 ["message"])))))))

(clojure.core/defn- response-account ([input] (response-account nil input)) ([resultWrapper32291 input] (clojure.core/let [rawinput32290 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32292 {"cloudwatchRoleArn" (rawinput32290 "cloudwatchRoleArn"), "throttleSettings" (rawinput32290 "throttleSettings"), "features" (rawinput32290 "features"), "apiKeyVersion" (rawinput32290 "apiKeyVersion")}] (clojure.core/cond-> {} (letvar32292 "cloudwatchRoleArn") (clojure.core/assoc :cloudwatch-role-arn (deser-string (clojure.core/get-in letvar32292 ["cloudwatchRoleArn"]))) (letvar32292 "throttleSettings") (clojure.core/assoc :throttle-settings (deser-throttle-settings (clojure.core/get-in letvar32292 ["throttleSettings"]))) (letvar32292 "features") (clojure.core/assoc :features (deser-list-of-string (clojure.core/get-in letvar32292 ["features"]))) (letvar32292 "apiKeyVersion") (clojure.core/assoc :api-key-version (deser-string (clojure.core/get-in letvar32292 ["apiKeyVersion"])))))))

(clojure.core/defn- response-test-invoke-method-response ([input] (response-test-invoke-method-response nil input)) ([resultWrapper32294 input] (clojure.core/let [rawinput32293 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32295 {"status" (rawinput32293 "status"), "body" (rawinput32293 "body"), "headers" (rawinput32293 "headers"), "multiValueHeaders" (rawinput32293 "multiValueHeaders"), "log" (rawinput32293 "log"), "latency" (rawinput32293 "latency")}] (clojure.core/cond-> {} (letvar32295 "status") (clojure.core/assoc :status (deser-integer (clojure.core/get-in letvar32295 ["status"]))) (letvar32295 "body") (clojure.core/assoc :body (deser-string (clojure.core/get-in letvar32295 ["body"]))) (letvar32295 "headers") (clojure.core/assoc :headers (deser-map-of-string-to-string (clojure.core/get-in letvar32295 ["headers"]))) (letvar32295 "multiValueHeaders") (clojure.core/assoc :multi-value-headers (deser-map-of-string-to-list (clojure.core/get-in letvar32295 ["multiValueHeaders"]))) (letvar32295 "log") (clojure.core/assoc :log (deser-string (clojure.core/get-in letvar32295 ["log"]))) (letvar32295 "latency") (clojure.core/assoc :latency (deser-long (clojure.core/get-in letvar32295 ["latency"])))))))

(clojure.core/defn- response-method ([input] (response-method nil input)) ([resultWrapper32297 input] (clojure.core/let [rawinput32296 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32298 {"authorizerId" (rawinput32296 "authorizerId"), "requestValidatorId" (rawinput32296 "requestValidatorId"), "authorizationType" (rawinput32296 "authorizationType"), "httpMethod" (rawinput32296 "httpMethod"), "operationName" (rawinput32296 "operationName"), "requestParameters" (rawinput32296 "requestParameters"), "authorizationScopes" (rawinput32296 "authorizationScopes"), "apiKeyRequired" (rawinput32296 "apiKeyRequired"), "requestModels" (rawinput32296 "requestModels"), "methodIntegration" (rawinput32296 "methodIntegration"), "methodResponses" (rawinput32296 "methodResponses")}] (clojure.core/cond-> {} (letvar32298 "authorizerId") (clojure.core/assoc :authorizer-id (deser-string (clojure.core/get-in letvar32298 ["authorizerId"]))) (letvar32298 "requestValidatorId") (clojure.core/assoc :request-validator-id (deser-string (clojure.core/get-in letvar32298 ["requestValidatorId"]))) (letvar32298 "authorizationType") (clojure.core/assoc :authorization-type (deser-string (clojure.core/get-in letvar32298 ["authorizationType"]))) (letvar32298 "httpMethod") (clojure.core/assoc :http-method (deser-string (clojure.core/get-in letvar32298 ["httpMethod"]))) (letvar32298 "operationName") (clojure.core/assoc :operation-name (deser-string (clojure.core/get-in letvar32298 ["operationName"]))) (letvar32298 "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-boolean (clojure.core/get-in letvar32298 ["requestParameters"]))) (letvar32298 "authorizationScopes") (clojure.core/assoc :authorization-scopes (deser-list-of-string (clojure.core/get-in letvar32298 ["authorizationScopes"]))) (letvar32298 "apiKeyRequired") (clojure.core/assoc :api-key-required (deser-nullable-boolean (clojure.core/get-in letvar32298 ["apiKeyRequired"]))) (letvar32298 "requestModels") (clojure.core/assoc :request-models (deser-map-of-string-to-string (clojure.core/get-in letvar32298 ["requestModels"]))) (letvar32298 "methodIntegration") (clojure.core/assoc :method-integration (deser-integration (clojure.core/get-in letvar32298 ["methodIntegration"]))) (letvar32298 "methodResponses") (clojure.core/assoc :method-responses (deser-map-of-method-response (clojure.core/get-in letvar32298 ["methodResponses"])))))))

(clojure.core/defn- response-resources ([input] (response-resources nil input)) ([resultWrapper32300 input] (clojure.core/let [rawinput32299 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32301 {"position" (rawinput32299 "position"), "item" (rawinput32299 "item")}] (clojure.core/cond-> {} (letvar32301 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32301 ["position"]))) (letvar32301 "item") (clojure.core/assoc :items (deser-list-of-resource (clojure.core/get-in letvar32301 ["item"])))))))

(clojure.core/defn- response-not-found-exception ([input] (response-not-found-exception nil input)) ([resultWrapper32303 input] (clojure.core/let [rawinput32302 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32304 {"message" (rawinput32302 "message")}] (clojure.core/cond-> {} (letvar32304 "message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar32304 ["message"])))))))

(clojure.core/defn- response-sdk-types ([input] (response-sdk-types nil input)) ([resultWrapper32306 input] (clojure.core/let [rawinput32305 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32307 {"position" (rawinput32305 "position"), "item" (rawinput32305 "item")}] (clojure.core/cond-> {} (letvar32307 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32307 ["position"]))) (letvar32307 "item") (clojure.core/assoc :items (deser-list-of-sdk-type (clojure.core/get-in letvar32307 ["item"])))))))

(clojure.core/defn- response-vpc-links ([input] (response-vpc-links nil input)) ([resultWrapper32309 input] (clojure.core/let [rawinput32308 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32310 {"position" (rawinput32308 "position"), "item" (rawinput32308 "item")}] (clojure.core/cond-> {} (letvar32310 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32310 ["position"]))) (letvar32310 "item") (clojure.core/assoc :items (deser-list-of-vpc-link (clojure.core/get-in letvar32310 ["item"])))))))

(clojure.core/defn- response-usage-plan-key ([input] (response-usage-plan-key nil input)) ([resultWrapper32312 input] (clojure.core/let [rawinput32311 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32313 {"id" (rawinput32311 "id"), "type" (rawinput32311 "type"), "value" (rawinput32311 "value"), "name" (rawinput32311 "name")}] (clojure.core/cond-> {} (letvar32313 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32313 ["id"]))) (letvar32313 "type") (clojure.core/assoc :type (deser-string (clojure.core/get-in letvar32313 ["type"]))) (letvar32313 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar32313 ["value"]))) (letvar32313 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32313 ["name"])))))))

(clojure.core/defn- response-client-certificate ([input] (response-client-certificate nil input)) ([resultWrapper32315 input] (clojure.core/let [rawinput32314 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32316 {"clientCertificateId" (rawinput32314 "clientCertificateId"), "description" (rawinput32314 "description"), "pemEncodedCertificate" (rawinput32314 "pemEncodedCertificate"), "createdDate" (rawinput32314 "createdDate"), "expirationDate" (rawinput32314 "expirationDate")}] (clojure.core/cond-> {} (letvar32316 "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (clojure.core/get-in letvar32316 ["clientCertificateId"]))) (letvar32316 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32316 ["description"]))) (letvar32316 "pemEncodedCertificate") (clojure.core/assoc :pem-encoded-certificate (deser-string (clojure.core/get-in letvar32316 ["pemEncodedCertificate"]))) (letvar32316 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar32316 ["createdDate"]))) (letvar32316 "expirationDate") (clojure.core/assoc :expiration-date (deser-timestamp (clojure.core/get-in letvar32316 ["expirationDate"])))))))

(clojure.core/defn- response-api-keys ([input] (response-api-keys nil input)) ([resultWrapper32318 input] (clojure.core/let [rawinput32317 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32319 {"warnings" (rawinput32317 "warnings"), "position" (rawinput32317 "position"), "item" (rawinput32317 "item")}] (clojure.core/cond-> {} (letvar32319 "warnings") (clojure.core/assoc :warnings (deser-list-of-string (clojure.core/get-in letvar32319 ["warnings"]))) (letvar32319 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32319 ["position"]))) (letvar32319 "item") (clojure.core/assoc :items (deser-list-of-api-key (clojure.core/get-in letvar32319 ["item"])))))))

(clojure.core/defn- response-usage-plans ([input] (response-usage-plans nil input)) ([resultWrapper32321 input] (clojure.core/let [rawinput32320 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32322 {"position" (rawinput32320 "position"), "item" (rawinput32320 "item")}] (clojure.core/cond-> {} (letvar32322 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32322 ["position"]))) (letvar32322 "item") (clojure.core/assoc :items (deser-list-of-usage-plan (clojure.core/get-in letvar32322 ["item"])))))))

(clojure.core/defn- response-authorizers ([input] (response-authorizers nil input)) ([resultWrapper32324 input] (clojure.core/let [rawinput32323 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32325 {"position" (rawinput32323 "position"), "item" (rawinput32323 "item")}] (clojure.core/cond-> {} (letvar32325 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32325 ["position"]))) (letvar32325 "item") (clojure.core/assoc :items (deser-list-of-authorizer (clojure.core/get-in letvar32325 ["item"])))))))

(clojure.core/defn- response-usage ([input] (response-usage nil input)) ([resultWrapper32327 input] (clojure.core/let [rawinput32326 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32328 {"usagePlanId" (rawinput32326 "usagePlanId"), "startDate" (rawinput32326 "startDate"), "endDate" (rawinput32326 "endDate"), "position" (rawinput32326 "position"), "values" (rawinput32326 "values")}] (clojure.core/cond-> {} (letvar32328 "usagePlanId") (clojure.core/assoc :usage-plan-id (deser-string (clojure.core/get-in letvar32328 ["usagePlanId"]))) (letvar32328 "startDate") (clojure.core/assoc :start-date (deser-string (clojure.core/get-in letvar32328 ["startDate"]))) (letvar32328 "endDate") (clojure.core/assoc :end-date (deser-string (clojure.core/get-in letvar32328 ["endDate"]))) (letvar32328 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32328 ["position"]))) (letvar32328 "values") (clojure.core/assoc :items (deser-map-of-key-usages (clojure.core/get-in letvar32328 ["values"])))))))

(clojure.core/defn- response-resource ([input] (response-resource nil input)) ([resultWrapper32330 input] (clojure.core/let [rawinput32329 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32331 {"id" (rawinput32329 "id"), "parentId" (rawinput32329 "parentId"), "pathPart" (rawinput32329 "pathPart"), "path" (rawinput32329 "path"), "resourceMethods" (rawinput32329 "resourceMethods")}] (clojure.core/cond-> {} (letvar32331 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32331 ["id"]))) (letvar32331 "parentId") (clojure.core/assoc :parent-id (deser-string (clojure.core/get-in letvar32331 ["parentId"]))) (letvar32331 "pathPart") (clojure.core/assoc :path-part (deser-string (clojure.core/get-in letvar32331 ["pathPart"]))) (letvar32331 "path") (clojure.core/assoc :path (deser-string (clojure.core/get-in letvar32331 ["path"]))) (letvar32331 "resourceMethods") (clojure.core/assoc :resource-methods (deser-map-of-method (clojure.core/get-in letvar32331 ["resourceMethods"])))))))

(clojure.core/defn- response-sdk-response ([input] (response-sdk-response nil input)) ([resultWrapper32333 input] (clojure.core/let [rawinput32332 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32334 {"Content-Type" (clojure.core/get-in input [:headers "Content-Type"]), "Content-Disposition" (clojure.core/get-in input [:headers "Content-Disposition"]), "body" (rawinput32332 "body")}] (clojure.core/cond-> {} (letvar32334 "Content-Type") (clojure.core/assoc :content-type (deser-string (clojure.core/get-in letvar32334 ["Content-Type"]))) (letvar32334 "Content-Disposition") (clojure.core/assoc :content-disposition (deser-string (clojure.core/get-in letvar32334 ["Content-Disposition"]))) (letvar32334 "body") (clojure.core/assoc :body (deser-blob (clojure.core/get-in letvar32334 ["body"])))))))

(clojure.core/defn- response-api-key ([input] (response-api-key nil input)) ([resultWrapper32336 input] (clojure.core/let [rawinput32335 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32337 {"createdDate" (rawinput32335 "createdDate"), "enabled" (rawinput32335 "enabled"), "id" (rawinput32335 "id"), "stageKeys" (rawinput32335 "stageKeys"), "customerId" (rawinput32335 "customerId"), "name" (rawinput32335 "name"), "value" (rawinput32335 "value"), "lastUpdatedDate" (rawinput32335 "lastUpdatedDate"), "description" (rawinput32335 "description")}] (clojure.core/cond-> {} (letvar32337 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar32337 ["createdDate"]))) (letvar32337 "enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar32337 ["enabled"]))) (letvar32337 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32337 ["id"]))) (letvar32337 "stageKeys") (clojure.core/assoc :stage-keys (deser-list-of-string (clojure.core/get-in letvar32337 ["stageKeys"]))) (letvar32337 "customerId") (clojure.core/assoc :customer-id (deser-string (clojure.core/get-in letvar32337 ["customerId"]))) (letvar32337 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32337 ["name"]))) (letvar32337 "value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar32337 ["value"]))) (letvar32337 "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (clojure.core/get-in letvar32337 ["lastUpdatedDate"]))) (letvar32337 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32337 ["description"])))))))

(clojure.core/defn- response-domain-name ([input] (response-domain-name nil input)) ([resultWrapper32339 input] (clojure.core/let [rawinput32338 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32340 {"domainName" (rawinput32338 "domainName"), "endpointConfiguration" (rawinput32338 "endpointConfiguration"), "certificateArn" (rawinput32338 "certificateArn"), "regionalHostedZoneId" (rawinput32338 "regionalHostedZoneId"), "regionalCertificateArn" (rawinput32338 "regionalCertificateArn"), "regionalCertificateName" (rawinput32338 "regionalCertificateName"), "distributionHostedZoneId" (rawinput32338 "distributionHostedZoneId"), "certificateUploadDate" (rawinput32338 "certificateUploadDate"), "certificateName" (rawinput32338 "certificateName"), "distributionDomainName" (rawinput32338 "distributionDomainName"), "regionalDomainName" (rawinput32338 "regionalDomainName")}] (clojure.core/cond-> {} (letvar32340 "domainName") (clojure.core/assoc :domain-name (deser-string (clojure.core/get-in letvar32340 ["domainName"]))) (letvar32340 "endpointConfiguration") (clojure.core/assoc :endpoint-configuration (deser-endpoint-configuration (clojure.core/get-in letvar32340 ["endpointConfiguration"]))) (letvar32340 "certificateArn") (clojure.core/assoc :certificate-arn (deser-string (clojure.core/get-in letvar32340 ["certificateArn"]))) (letvar32340 "regionalHostedZoneId") (clojure.core/assoc :regional-hosted-zone-id (deser-string (clojure.core/get-in letvar32340 ["regionalHostedZoneId"]))) (letvar32340 "regionalCertificateArn") (clojure.core/assoc :regional-certificate-arn (deser-string (clojure.core/get-in letvar32340 ["regionalCertificateArn"]))) (letvar32340 "regionalCertificateName") (clojure.core/assoc :regional-certificate-name (deser-string (clojure.core/get-in letvar32340 ["regionalCertificateName"]))) (letvar32340 "distributionHostedZoneId") (clojure.core/assoc :distribution-hosted-zone-id (deser-string (clojure.core/get-in letvar32340 ["distributionHostedZoneId"]))) (letvar32340 "certificateUploadDate") (clojure.core/assoc :certificate-upload-date (deser-timestamp (clojure.core/get-in letvar32340 ["certificateUploadDate"]))) (letvar32340 "certificateName") (clojure.core/assoc :certificate-name (deser-string (clojure.core/get-in letvar32340 ["certificateName"]))) (letvar32340 "distributionDomainName") (clojure.core/assoc :distribution-domain-name (deser-string (clojure.core/get-in letvar32340 ["distributionDomainName"]))) (letvar32340 "regionalDomainName") (clojure.core/assoc :regional-domain-name (deser-string (clojure.core/get-in letvar32340 ["regionalDomainName"])))))))

(clojure.core/defn- response-documentation-parts ([input] (response-documentation-parts nil input)) ([resultWrapper32342 input] (clojure.core/let [rawinput32341 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32343 {"position" (rawinput32341 "position"), "item" (rawinput32341 "item")}] (clojure.core/cond-> {} (letvar32343 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32343 ["position"]))) (letvar32343 "item") (clojure.core/assoc :items (deser-list-of-documentation-part (clojure.core/get-in letvar32343 ["item"])))))))

(clojure.core/defn- response-export-response ([input] (response-export-response nil input)) ([resultWrapper32345 input] (clojure.core/let [rawinput32344 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32346 {"Content-Type" (clojure.core/get-in input [:headers "Content-Type"]), "Content-Disposition" (clojure.core/get-in input [:headers "Content-Disposition"]), "body" (rawinput32344 "body")}] (clojure.core/cond-> {} (letvar32346 "Content-Type") (clojure.core/assoc :content-type (deser-string (clojure.core/get-in letvar32346 ["Content-Type"]))) (letvar32346 "Content-Disposition") (clojure.core/assoc :content-disposition (deser-string (clojure.core/get-in letvar32346 ["Content-Disposition"]))) (letvar32346 "body") (clojure.core/assoc :body (deser-blob (clojure.core/get-in letvar32346 ["body"])))))))

(clojure.core/defn- response-gateway-responses ([input] (response-gateway-responses nil input)) ([resultWrapper32348 input] (clojure.core/let [rawinput32347 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32349 {"position" (rawinput32347 "position"), "item" (rawinput32347 "item")}] (clojure.core/cond-> {} (letvar32349 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32349 ["position"]))) (letvar32349 "item") (clojure.core/assoc :items (deser-list-of-gateway-response (clojure.core/get-in letvar32349 ["item"])))))))

(clojure.core/defn- response-integration ([input] (response-integration nil input)) ([resultWrapper32351 input] (clojure.core/let [rawinput32350 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32352 {"integrationResponses" (rawinput32350 "integrationResponses"), "connectionId" (rawinput32350 "connectionId"), "uri" (rawinput32350 "uri"), "connectionType" (rawinput32350 "connectionType"), "httpMethod" (rawinput32350 "httpMethod"), "requestTemplates" (rawinput32350 "requestTemplates"), "requestParameters" (rawinput32350 "requestParameters"), "cacheNamespace" (rawinput32350 "cacheNamespace"), "passthroughBehavior" (rawinput32350 "passthroughBehavior"), "type" (rawinput32350 "type"), "contentHandling" (rawinput32350 "contentHandling"), "cacheKeyParameters" (rawinput32350 "cacheKeyParameters"), "credentials" (rawinput32350 "credentials"), "timeoutInMillis" (rawinput32350 "timeoutInMillis")}] (clojure.core/cond-> {} (letvar32352 "integrationResponses") (clojure.core/assoc :integration-responses (deser-map-of-integration-response (clojure.core/get-in letvar32352 ["integrationResponses"]))) (letvar32352 "connectionId") (clojure.core/assoc :connection-id (deser-string (clojure.core/get-in letvar32352 ["connectionId"]))) (letvar32352 "uri") (clojure.core/assoc :uri (deser-string (clojure.core/get-in letvar32352 ["uri"]))) (letvar32352 "connectionType") (clojure.core/assoc :connection-type (deser-connection-type (clojure.core/get-in letvar32352 ["connectionType"]))) (letvar32352 "httpMethod") (clojure.core/assoc :http-method (deser-string (clojure.core/get-in letvar32352 ["httpMethod"]))) (letvar32352 "requestTemplates") (clojure.core/assoc :request-templates (deser-map-of-string-to-string (clojure.core/get-in letvar32352 ["requestTemplates"]))) (letvar32352 "requestParameters") (clojure.core/assoc :request-parameters (deser-map-of-string-to-string (clojure.core/get-in letvar32352 ["requestParameters"]))) (letvar32352 "cacheNamespace") (clojure.core/assoc :cache-namespace (deser-string (clojure.core/get-in letvar32352 ["cacheNamespace"]))) (letvar32352 "passthroughBehavior") (clojure.core/assoc :passthrough-behavior (deser-string (clojure.core/get-in letvar32352 ["passthroughBehavior"]))) (letvar32352 "type") (clojure.core/assoc :type (deser-integration-type (clojure.core/get-in letvar32352 ["type"]))) (letvar32352 "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (clojure.core/get-in letvar32352 ["contentHandling"]))) (letvar32352 "cacheKeyParameters") (clojure.core/assoc :cache-key-parameters (deser-list-of-string (clojure.core/get-in letvar32352 ["cacheKeyParameters"]))) (letvar32352 "credentials") (clojure.core/assoc :credentials (deser-string (clojure.core/get-in letvar32352 ["credentials"]))) (letvar32352 "timeoutInMillis") (clojure.core/assoc :timeout-in-millis (deser-integer (clojure.core/get-in letvar32352 ["timeoutInMillis"])))))))

(clojure.core/defn- response-documentation-version ([input] (response-documentation-version nil input)) ([resultWrapper32354 input] (clojure.core/let [rawinput32353 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32355 {"version" (rawinput32353 "version"), "createdDate" (rawinput32353 "createdDate"), "description" (rawinput32353 "description")}] (clojure.core/cond-> {} (letvar32355 "version") (clojure.core/assoc :version (deser-string (clojure.core/get-in letvar32355 ["version"]))) (letvar32355 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar32355 ["createdDate"]))) (letvar32355 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32355 ["description"])))))))

(clojure.core/defn- response-integration-response ([input] (response-integration-response nil input)) ([resultWrapper32357 input] (clojure.core/let [rawinput32356 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32358 {"statusCode" (rawinput32356 "statusCode"), "selectionPattern" (rawinput32356 "selectionPattern"), "responseParameters" (rawinput32356 "responseParameters"), "responseTemplates" (rawinput32356 "responseTemplates"), "contentHandling" (rawinput32356 "contentHandling")}] (clojure.core/cond-> {} (letvar32358 "statusCode") (clojure.core/assoc :status-code (deser-status-code (clojure.core/get-in letvar32358 ["statusCode"]))) (letvar32358 "selectionPattern") (clojure.core/assoc :selection-pattern (deser-string (clojure.core/get-in letvar32358 ["selectionPattern"]))) (letvar32358 "responseParameters") (clojure.core/assoc :response-parameters (deser-map-of-string-to-string (clojure.core/get-in letvar32358 ["responseParameters"]))) (letvar32358 "responseTemplates") (clojure.core/assoc :response-templates (deser-map-of-string-to-string (clojure.core/get-in letvar32358 ["responseTemplates"]))) (letvar32358 "contentHandling") (clojure.core/assoc :content-handling (deser-content-handling-strategy (clojure.core/get-in letvar32358 ["contentHandling"])))))))

(clojure.core/defn- response-vpc-link ([input] (response-vpc-link nil input)) ([resultWrapper32360 input] (clojure.core/let [rawinput32359 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32361 {"id" (rawinput32359 "id"), "name" (rawinput32359 "name"), "description" (rawinput32359 "description"), "targetArns" (rawinput32359 "targetArns"), "status" (rawinput32359 "status"), "statusMessage" (rawinput32359 "statusMessage")}] (clojure.core/cond-> {} (letvar32361 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32361 ["id"]))) (letvar32361 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32361 ["name"]))) (letvar32361 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32361 ["description"]))) (letvar32361 "targetArns") (clojure.core/assoc :target-arns (deser-list-of-string (clojure.core/get-in letvar32361 ["targetArns"]))) (letvar32361 "status") (clojure.core/assoc :status (deser-vpc-link-status (clojure.core/get-in letvar32361 ["status"]))) (letvar32361 "statusMessage") (clojure.core/assoc :status-message (deser-string (clojure.core/get-in letvar32361 ["statusMessage"])))))))

(clojure.core/defn- response-models ([input] (response-models nil input)) ([resultWrapper32363 input] (clojure.core/let [rawinput32362 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32364 {"position" (rawinput32362 "position"), "item" (rawinput32362 "item")}] (clojure.core/cond-> {} (letvar32364 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32364 ["position"]))) (letvar32364 "item") (clojure.core/assoc :items (deser-list-of-model (clojure.core/get-in letvar32364 ["item"])))))))

(clojure.core/defn- response-stage ([input] (response-stage nil input)) ([resultWrapper32366 input] (clojure.core/let [rawinput32365 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32367 {"cacheClusterStatus" (rawinput32365 "cacheClusterStatus"), "webAclArn" (rawinput32365 "webAclArn"), "tracingEnabled" (rawinput32365 "tracingEnabled"), "createdDate" (rawinput32365 "createdDate"), "accessLogSettings" (rawinput32365 "accessLogSettings"), "tags" (rawinput32365 "tags"), "documentationVersion" (rawinput32365 "documentationVersion"), "methodSettings" (rawinput32365 "methodSettings"), "canarySettings" (rawinput32365 "canarySettings"), "deploymentId" (rawinput32365 "deploymentId"), "clientCertificateId" (rawinput32365 "clientCertificateId"), "lastUpdatedDate" (rawinput32365 "lastUpdatedDate"), "variables" (rawinput32365 "variables"), "cacheClusterEnabled" (rawinput32365 "cacheClusterEnabled"), "stageName" (rawinput32365 "stageName"), "description" (rawinput32365 "description"), "cacheClusterSize" (rawinput32365 "cacheClusterSize")}] (clojure.core/cond-> {} (letvar32367 "cacheClusterStatus") (clojure.core/assoc :cache-cluster-status (deser-cache-cluster-status (clojure.core/get-in letvar32367 ["cacheClusterStatus"]))) (letvar32367 "webAclArn") (clojure.core/assoc :web-acl-arn (deser-string (clojure.core/get-in letvar32367 ["webAclArn"]))) (letvar32367 "tracingEnabled") (clojure.core/assoc :tracing-enabled (deser-boolean (clojure.core/get-in letvar32367 ["tracingEnabled"]))) (letvar32367 "createdDate") (clojure.core/assoc :created-date (deser-timestamp (clojure.core/get-in letvar32367 ["createdDate"]))) (letvar32367 "accessLogSettings") (clojure.core/assoc :access-log-settings (deser-access-log-settings (clojure.core/get-in letvar32367 ["accessLogSettings"]))) (letvar32367 "tags") (clojure.core/assoc :tags (deser-map-of-string-to-string (clojure.core/get-in letvar32367 ["tags"]))) (letvar32367 "documentationVersion") (clojure.core/assoc :documentation-version (deser-string (clojure.core/get-in letvar32367 ["documentationVersion"]))) (letvar32367 "methodSettings") (clojure.core/assoc :method-settings (deser-map-of-method-settings (clojure.core/get-in letvar32367 ["methodSettings"]))) (letvar32367 "canarySettings") (clojure.core/assoc :canary-settings (deser-canary-settings (clojure.core/get-in letvar32367 ["canarySettings"]))) (letvar32367 "deploymentId") (clojure.core/assoc :deployment-id (deser-string (clojure.core/get-in letvar32367 ["deploymentId"]))) (letvar32367 "clientCertificateId") (clojure.core/assoc :client-certificate-id (deser-string (clojure.core/get-in letvar32367 ["clientCertificateId"]))) (letvar32367 "lastUpdatedDate") (clojure.core/assoc :last-updated-date (deser-timestamp (clojure.core/get-in letvar32367 ["lastUpdatedDate"]))) (letvar32367 "variables") (clojure.core/assoc :variables (deser-map-of-string-to-string (clojure.core/get-in letvar32367 ["variables"]))) (letvar32367 "cacheClusterEnabled") (clojure.core/assoc :cache-cluster-enabled (deser-boolean (clojure.core/get-in letvar32367 ["cacheClusterEnabled"]))) (letvar32367 "stageName") (clojure.core/assoc :stage-name (deser-string (clojure.core/get-in letvar32367 ["stageName"]))) (letvar32367 "description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar32367 ["description"]))) (letvar32367 "cacheClusterSize") (clojure.core/assoc :cache-cluster-size (deser-cache-cluster-size (clojure.core/get-in letvar32367 ["cacheClusterSize"])))))))

(clojure.core/defn- response-authorizer ([input] (response-authorizer nil input)) ([resultWrapper32369 input] (clojure.core/let [rawinput32368 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32370 {"authorizerCredentials" (rawinput32368 "authorizerCredentials"), "identityValidationExpression" (rawinput32368 "identityValidationExpression"), "id" (rawinput32368 "id"), "name" (rawinput32368 "name"), "type" (rawinput32368 "type"), "authorizerResultTtlInSeconds" (rawinput32368 "authorizerResultTtlInSeconds"), "authorizerUri" (rawinput32368 "authorizerUri"), "authType" (rawinput32368 "authType"), "identitySource" (rawinput32368 "identitySource"), "providerARNs" (rawinput32368 "providerARNs")}] (clojure.core/cond-> {} (letvar32370 "authorizerCredentials") (clojure.core/assoc :authorizer-credentials (deser-string (clojure.core/get-in letvar32370 ["authorizerCredentials"]))) (letvar32370 "identityValidationExpression") (clojure.core/assoc :identity-validation-expression (deser-string (clojure.core/get-in letvar32370 ["identityValidationExpression"]))) (letvar32370 "id") (clojure.core/assoc :id (deser-string (clojure.core/get-in letvar32370 ["id"]))) (letvar32370 "name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar32370 ["name"]))) (letvar32370 "type") (clojure.core/assoc :type (deser-authorizer-type (clojure.core/get-in letvar32370 ["type"]))) (letvar32370 "authorizerResultTtlInSeconds") (clojure.core/assoc :authorizer-result-ttl-in-seconds (deser-nullable-integer (clojure.core/get-in letvar32370 ["authorizerResultTtlInSeconds"]))) (letvar32370 "authorizerUri") (clojure.core/assoc :authorizer-uri (deser-string (clojure.core/get-in letvar32370 ["authorizerUri"]))) (letvar32370 "authType") (clojure.core/assoc :auth-type (deser-string (clojure.core/get-in letvar32370 ["authType"]))) (letvar32370 "identitySource") (clojure.core/assoc :identity-source (deser-string (clojure.core/get-in letvar32370 ["identitySource"]))) (letvar32370 "providerARNs") (clojure.core/assoc :provider-ar-ns (deser-list-of-ar-ns (clojure.core/get-in letvar32370 ["providerARNs"])))))))

(clojure.core/defn- response-deployments ([input] (response-deployments nil input)) ([resultWrapper32372 input] (clojure.core/let [rawinput32371 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar32373 {"position" (rawinput32371 "position"), "item" (rawinput32371 "item")}] (clojure.core/cond-> {} (letvar32373 "position") (clojure.core/assoc :position (deser-string (clojure.core/get-in letvar32373 ["position"]))) (letvar32373 "item") (clojure.core/assoc :items (deser-list-of-deployment (clojure.core/get-in letvar32373 ["item"])))))))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-resource-request/parent-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-resource-request/path-part (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-resource-request/rest-api-id :portkey.aws.apigateway.create-resource-request/parent-id :portkey.aws.apigateway.create-resource-request/path-part] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-location-status-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"^([1-5]\d\d|\*|\s*)$" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/mode (clojure.spec.alpha/and :portkey.aws.apigateway/put-mode))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-rest-api-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-rest-api-request/rest-api-id :portkey.aws.apigateway.put-rest-api-request/body] :opt-un [:portkey.aws.apigateway.put-rest-api-request/mode :portkey.aws.apigateway.put-rest-api-request/fail-on-warnings :portkey.aws.apigateway.put-rest-api-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-stages-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-stages-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-stages-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-stages-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-stages-request/deployment-id]))

(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/api-key-source (clojure.spec.alpha/and :portkey.aws.apigateway/api-key-source-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/binary-media-types (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/policy (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/minimum-compression-size (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-api/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/rest-api (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.rest-api/api-key-source :portkey.aws.apigateway.rest-api/created-date :portkey.aws.apigateway.rest-api/id :portkey.aws.apigateway.rest-api/name :portkey.aws.apigateway.rest-api/binary-media-types :portkey.aws.apigateway.rest-api/endpoint-configuration :portkey.aws.apigateway.rest-api/policy :portkey.aws.apigateway.rest-api/version :portkey.aws.apigateway.rest-api/minimum-compression-size :portkey.aws.apigateway.rest-api/warnings :portkey.aws.apigateway.rest-api/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-domain-name-request/domain-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-resource-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-resource-request/rest-api-id :portkey.aws.apigateway.delete-resource-request/resource-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-usage-plan-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-usage-plan-request/usage-plan-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.unauthorized-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/unauthorized-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.unauthorized-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-vpc-link-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-vpc-link-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-vpc-link-request/target-arns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-vpc-link-request/name :portkey.aws.apigateway.create-vpc-link-request/target-arns] :opt-un [:portkey.aws.apigateway.create-vpc-link-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-documentation-part (clojure.spec.alpha/coll-of :portkey.aws.apigateway/documentation-part))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resources-request/embed (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-resources-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-resources-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-resources-request/position :portkey.aws.apigateway.get-resources-request/limit :portkey.aws.apigateway.get-resources-request/embed]))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-key-ids/ids (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key-ids/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-key-ids (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-key-ids/ids :portkey.aws.apigateway.api-key-ids/warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/multi-value-headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/path-with-query-string (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/stage-variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-request/additional-context (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.test-invoke-authorizer-request/rest-api-id :portkey.aws.apigateway.test-invoke-authorizer-request/authorizer-id] :opt-un [:portkey.aws.apigateway.test-invoke-authorizer-request/headers :portkey.aws.apigateway.test-invoke-authorizer-request/multi-value-headers :portkey.aws.apigateway.test-invoke-authorizer-request/path-with-query-string :portkey.aws.apigateway.test-invoke-authorizer-request/body :portkey.aws.apigateway.test-invoke-authorizer-request/stage-variables :portkey.aws.apigateway.test-invoke-authorizer-request/additional-context]))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/multi-value-headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/path-with-query-string (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/stage-variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-request/headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.test-invoke-method-request/rest-api-id :portkey.aws.apigateway.test-invoke-method-request/resource-id :portkey.aws.apigateway.test-invoke-method-request/http-method] :opt-un [:portkey.aws.apigateway.test-invoke-method-request/body :portkey.aws.apigateway.test-invoke-method-request/multi-value-headers :portkey.aws.apigateway.test-invoke-method-request/path-with-query-string :portkey.aws.apigateway.test-invoke-method-request/client-certificate-id :portkey.aws.apigateway.test-invoke-method-request/stage-variables :portkey.aws.apigateway.test-invoke-method-request/headers]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method-snapshot (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method-snapshot))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-type-request/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-sdk-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-sdk-type-request/id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment/api-summary (clojure.spec.alpha/and :portkey.aws.apigateway/path-to-map-of-method-snapshot))
(clojure.spec.alpha/def :portkey.aws.apigateway/deployment (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.deployment/id :portkey.aws.apigateway.deployment/description :portkey.aws.apigateway.deployment/created-date :portkey.aws.apigateway.deployment/api-summary]))

(clojure.spec.alpha/def :portkey.aws.apigateway/gateway-response-type #{:integration-timeout "REQUEST_TOO_LARGE" :unauthorized "INTEGRATION_TIMEOUT" "RESOURCE_NOT_FOUND" :invalid-api-key :integration-failure "AUTHORIZER_CONFIGURATION_ERROR" "INTEGRATION_FAILURE" "DEFAULT_5XX" "UNAUTHORIZED" :quota-exceeded :invalid-signature :expired-token :bad-request-parameters "AUTHORIZER_FAILURE" :unsupported-media-type "INVALID_API_KEY" "ACCESS_DENIED" "API_CONFIGURATION_ERROR" "DEFAULT_4XX" "INVALID_SIGNATURE" :bad-request-body :api-configuration-error "EXPIRED_TOKEN" "UNSUPPORTED_MEDIA_TYPE" :authorizer-configuration-error :default-5-xx :request-too-large :default-4-xx :authorizer-failure :throttled "QUOTA_EXCEEDED" "BAD_REQUEST_PARAMETERS" "MISSING_AUTHENTICATION_TOKEN" :missing-authentication-token "BAD_REQUEST_BODY" :resource-not-found :access-denied "THROTTLED"})

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-client-certificate (clojure.spec.alpha/coll-of :portkey.aws.apigateway/client-certificate))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/sdk-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-sdk-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-sdk-request/rest-api-id :portkey.aws.apigateway.get-sdk-request/stage-name :portkey.aws.apigateway.get-sdk-request/sdk-type] :opt-un [:portkey.aws.apigateway.get-sdk-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.bad-request-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/bad-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.bad-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-stage-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-stage-request/rest-api-id :portkey.aws.apigateway.update-stage-request/stage-name] :opt-un [:portkey.aws.apigateway.update-stage-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-method-response-request/rest-api-id :portkey.aws.apigateway.get-method-response-request/resource-id :portkey.aws.apigateway.get-method-response-request/http-method :portkey.aws.apigateway.get-method-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/client-status (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/log (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/latency (clojure.spec.alpha/and :portkey.aws.apigateway/long))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/principal-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/policy (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/authorization (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-authorizer-response/claims (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.test-invoke-authorizer-response/client-status :portkey.aws.apigateway.test-invoke-authorizer-response/log :portkey.aws.apigateway.test-invoke-authorizer-response/latency :portkey.aws.apigateway.test-invoke-authorizer-response/principal-id :portkey.aws.apigateway.test-invoke-authorizer-response/policy :portkey.aws.apigateway.test-invoke-authorizer-response/authorization :portkey.aws.apigateway.test-invoke-authorizer-response/claims]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-stage-request/rest-api-id :portkey.aws.apigateway.delete-stage-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/logging-level (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/metrics-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/caching-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/throttling-rate-limit (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/cache-ttl-in-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/unauthorized-cache-control-header-strategy (clojure.spec.alpha/and :portkey.aws.apigateway/unauthorized-cache-control-header-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/cache-data-encrypted (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/throttling-burst-limit (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/require-authorization-for-cache-control (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-setting/data-trace-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/method-setting (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method-setting/logging-level :portkey.aws.apigateway.method-setting/metrics-enabled :portkey.aws.apigateway.method-setting/caching-enabled :portkey.aws.apigateway.method-setting/throttling-rate-limit :portkey.aws.apigateway.method-setting/cache-ttl-in-seconds :portkey.aws.apigateway.method-setting/unauthorized-cache-control-header-strategy :portkey.aws.apigateway.method-setting/cache-data-encrypted :portkey.aws.apigateway.method-setting/throttling-burst-limit :portkey.aws.apigateway.method-setting/require-authorization-for-cache-control :portkey.aws.apigateway.method-setting/data-trace-enabled]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-part-request/documentation-part-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-documentation-part-request/rest-api-id :portkey.aws.apigateway.delete-documentation-part-request/documentation-part-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/status-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[1-5]\d\d" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-stage/api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-stage/stage (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-stage/throttle (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-api-stage-throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-stage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-stage/api-id :portkey.aws.apigateway.api-stage/stage :portkey.aws.apigateway.api-stage/throttle]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-integration-response-request/rest-api-id :portkey.aws.apigateway.get-integration-response-request/resource-id :portkey.aws.apigateway.get-integration-response-request/http-method :portkey.aws.apigateway.get-integration-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-vpc-link (clojure.spec.alpha/coll-of :portkey.aws.apigateway/vpc-link))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part/location (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-location))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part/properties (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-part/id :portkey.aws.apigateway.documentation-part/location :portkey.aws.apigateway.documentation-part/properties]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-string-to-list (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/list-of-string))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resource-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-resource-request/embed (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-resource-request/rest-api-id :portkey.aws.apigateway.get-resource-request/resource-id] :opt-un [:portkey.aws.apigateway.get-resource-request/embed]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/start-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/end-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-request/usage-plan-id :portkey.aws.apigateway.get-usage-request/start-date :portkey.aws.apigateway.get-usage-request/end-date] :opt-un [:portkey.aws.apigateway.get-usage-request/key-id :portkey.aws.apigateway.get-usage-request/position :portkey.aws.apigateway.get-usage-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.method-snapshot/authorization-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-snapshot/api-key-required (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/method-snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method-snapshot/authorization-type :portkey.aws.apigateway.method-snapshot/api-key-required]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-base-path-mapping-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-base-path-mapping-request/domain-name :portkey.aws.apigateway.update-base-path-mapping-request/base-path] :opt-un [:portkey.aws.apigateway.update-base-path-mapping-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-model (clojure.spec.alpha/coll-of :portkey.aws.apigateway/model))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-types-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-sdk-types-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-sdk-types-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-sdk-types-request/position :portkey.aws.apigateway.get-sdk-types-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/mode (clojure.spec.alpha/and :portkey.aws.apigateway/put-mode))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-documentation-parts-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/import-documentation-parts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.import-documentation-parts-request/rest-api-id :portkey.aws.apigateway.import-documentation-parts-request/body] :opt-un [:portkey.aws.apigateway.import-documentation-parts-request/mode :portkey.aws.apigateway.import-documentation-parts-request/fail-on-warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.generate-client-certificate-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/generate-client-certificate-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.generate-client-certificate-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway/endpoint-type #{:edge :private "REGIONAL" :regional "EDGE" "PRIVATE"})

(clojure.spec.alpha/def :portkey.aws.apigateway.rest-apis/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.rest-apis/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-rest-api))
(clojure.spec.alpha/def :portkey.aws.apigateway/rest-apis (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.rest-apis/position :portkey.aws.apigateway.rest-apis/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-sdk-configuration-property (clojure.spec.alpha/coll-of :portkey.aws.apigateway/sdk-configuration-property))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-client-certificate-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-client-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-client-certificate-request/client-certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mappings/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mappings/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-base-path-mapping))
(clojure.spec.alpha/def :portkey.aws.apigateway/base-path-mappings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.base-path-mappings/position :portkey.aws.apigateway.base-path-mappings/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-deployment-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-deployment-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-deployment-request/rest-api-id :portkey.aws.apigateway.update-deployment-request/deployment-id] :opt-un [:portkey.aws.apigateway.update-deployment-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-versions/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-versions/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-documentation-version))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-versions (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-versions/position :portkey.aws.apigateway.documentation-versions/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-string (clojure.spec.alpha/coll-of :portkey.aws.apigateway/string))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/connection-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/integration-http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/connection-type (clojure.spec.alpha/and :portkey.aws.apigateway/connection-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/request-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/cache-namespace (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/passthrough-behavior (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/type (clojure.spec.alpha/and :portkey.aws.apigateway/integration-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/cache-key-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-request/timeout-in-millis (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-integration-request/rest-api-id :portkey.aws.apigateway.put-integration-request/resource-id :portkey.aws.apigateway.put-integration-request/http-method :portkey.aws.apigateway.put-integration-request/type] :opt-un [:portkey.aws.apigateway.put-integration-request/connection-id :portkey.aws.apigateway.put-integration-request/uri :portkey.aws.apigateway.put-integration-request/integration-http-method :portkey.aws.apigateway.put-integration-request/connection-type :portkey.aws.apigateway.put-integration-request/request-templates :portkey.aws.apigateway.put-integration-request/request-parameters :portkey.aws.apigateway.put-integration-request/cache-namespace :portkey.aws.apigateway.put-integration-request/passthrough-behavior :portkey.aws.apigateway.put-integration-request/content-handling :portkey.aws.apigateway.put-integration-request/cache-key-parameters :portkey.aws.apigateway.put-integration-request/credentials :portkey.aws.apigateway.put-integration-request/timeout-in-millis]))

(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-type #{:response "PATH_PARAMETER" :api :response-header :method "API" "REQUEST_HEADER" :path-parameter "METHOD" :request-body :resource :request-header "RESOURCE" :response-body :query-parameter "RESPONSE_HEADER" :authorizer "REQUEST_BODY" "QUERY_PARAMETER" "AUTHORIZER" "MODEL" "RESPONSE" "RESPONSE_BODY" :model})

(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-usage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-usage-request/usage-plan-id :portkey.aws.apigateway.update-usage-request/key-id] :opt-un [:portkey.aws.apigateway.update-usage-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-api-key-request/api-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-api-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-api-key-request/api-key] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-part-request/documentation-part-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-part-request/rest-api-id :portkey.aws.apigateway.get-documentation-part-request/documentation-part-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/op (clojure.spec.alpha/and :portkey.aws.apigateway/op))
(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.patch-operation/from (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/patch-operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.patch-operation/op :portkey.aws.apigateway.patch-operation/path :portkey.aws.apigateway.patch-operation/value :portkey.aws.apigateway.patch-operation/from]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mappings-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mappings-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mappings-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-base-path-mappings-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-base-path-mappings-request/domain-name] :opt-un [:portkey.aws.apigateway.get-base-path-mappings-request/position :portkey.aws.apigateway.get-base-path-mappings-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/api-key-source (clojure.spec.alpha/and :portkey.aws.apigateway/api-key-source-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/clone-from (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/binary-media-types (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/policy (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/minimum-compression-size (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-rest-api-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-rest-api-request/name] :opt-un [:portkey.aws.apigateway.create-rest-api-request/api-key-source :portkey.aws.apigateway.create-rest-api-request/clone-from :portkey.aws.apigateway.create-rest-api-request/binary-media-types :portkey.aws.apigateway.create-rest-api-request/endpoint-configuration :portkey.aws.apigateway.create-rest-api-request/policy :portkey.aws.apigateway.create-rest-api-request/version :portkey.aws.apigateway.create-rest-api-request/minimum-compression-size :portkey.aws.apigateway.create-rest-api-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/selection-pattern (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-integration-response-request/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-integration-response-request/rest-api-id :portkey.aws.apigateway.put-integration-response-request/resource-id :portkey.aws.apigateway.put-integration-response-request/http-method :portkey.aws.apigateway.put-integration-response-request/status-code] :opt-un [:portkey.aws.apigateway.put-integration-response-request/selection-pattern :portkey.aws.apigateway.put-integration-response-request/response-parameters :portkey.aws.apigateway.put-integration-response-request/response-templates :portkey.aws.apigateway.put-integration-response-request/content-handling]))

(clojure.spec.alpha/def :portkey.aws.apigateway.stages/item (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-stage))
(clojure.spec.alpha/def :portkey.aws.apigateway/stages (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.stages/item]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-request-validator (clojure.spec.alpha/coll-of :portkey.aws.apigateway/request-validator))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-gateway-response-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-gateway-response-request/rest-api-id :portkey.aws.apigateway.update-gateway-response-request/response-type] :opt-un [:portkey.aws.apigateway.update-gateway-response-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-authorizer-request/rest-api-id :portkey.aws.apigateway.get-authorizer-request/authorizer-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-rest-api (clojure.spec.alpha/coll-of :portkey.aws.apigateway/rest-api))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-usage-plan-key (clojure.spec.alpha/coll-of :portkey.aws.apigateway/usage-plan-key))

(clojure.spec.alpha/def :portkey.aws.apigateway.tags/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/tags (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.tags/tags]))

(clojure.spec.alpha/def :portkey.aws.apigateway.template/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/template (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.template/value]))

(clojure.spec.alpha/def :portkey.aws.apigateway.limit-exceeded-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.limit-exceeded-exception/retry-after-seconds :portkey.aws.apigateway.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/export-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-export-request/accepts (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-export-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-export-request/rest-api-id :portkey.aws.apigateway.get-export-request/stage-name :portkey.aws.apigateway.get-export-request/export-type] :opt-un [:portkey.aws.apigateway.get-export-request/parameters :portkey.aws.apigateway.get-export-request/accepts]))

(clojure.spec.alpha/def :portkey.aws.apigateway/nullable-boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-client-certificate-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-client-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-client-certificate-request/client-certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.method-response/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-response/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method-response/response-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/method-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method-response/status-code :portkey.aws.apigateway.method-response/response-parameters :portkey.aws.apigateway.method-response/response-models]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-deployment (clojure.spec.alpha/coll-of :portkey.aws.apigateway/deployment))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-request/flatten (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-model-request/rest-api-id :portkey.aws.apigateway.get-model-request/model-name] :opt-un [:portkey.aws.apigateway.get-model-request/flatten]))

(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/validate-request-body (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validator/validate-request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/request-validator (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.request-validator/id :portkey.aws.apigateway.request-validator/name :portkey.aws.apigateway.request-validator/validate-request-body :portkey.aws.apigateway.request-validator/validate-request-parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-version-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-documentation-version-request/rest-api-id :portkey.aws.apigateway.create-documentation-version-request/documentation-version] :opt-un [:portkey.aws.apigateway.create-documentation-version-request/stage-name :portkey.aws.apigateway.create-documentation-version-request/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validators-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validators-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validators-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-request-validators-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-request-validators-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-request-validators-request/position :portkey.aws.apigateway.get-request-validators-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/api-stages (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-api-stage))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/throttle (clojure.spec.alpha/and :portkey.aws.apigateway/throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-request/quota (clojure.spec.alpha/and :portkey.aws.apigateway/quota-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-usage-plan-request/name] :opt-un [:portkey.aws.apigateway.create-usage-plan-request/description :portkey.aws.apigateway.create-usage-plan-request/api-stages :portkey.aws.apigateway.create-usage-plan-request/throttle :portkey.aws.apigateway.create-usage-plan-request/quota]))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/friendly-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-type/configuration-properties (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-sdk-configuration-property))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-type/id :portkey.aws.apigateway.sdk-type/friendly-name :portkey.aws.apigateway.sdk-type/description :portkey.aws.apigateway.sdk-type/configuration-properties]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-key-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-key-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plan-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-plan-key-request/usage-plan-id :portkey.aws.apigateway.get-usage-plan-key-request/key-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/cache-cluster-status #{"DELETE_IN_PROGRESS" "AVAILABLE" :flush-in-progress "CREATE_IN_PROGRESS" :delete-in-progress :create-in-progress "NOT_AVAILABLE" "FLUSH_IN_PROGRESS" :not-available :available})

(clojure.spec.alpha/def :portkey.aws.apigateway.service-unavailable-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/service-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.service-unavailable-exception/retry-after-seconds :portkey.aws.apigateway.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificates/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificates/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-client-certificate))
(clojure.spec.alpha/def :portkey.aws.apigateway/client-certificates (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.client-certificates/position :portkey.aws.apigateway.client-certificates/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-gateway-response-request/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-gateway-response-request/rest-api-id :portkey.aws.apigateway.put-gateway-response-request/response-type] :opt-un [:portkey.aws.apigateway.put-gateway-response-request/status-code :portkey.aws.apigateway.put-gateway-response-request/response-parameters :portkey.aws.apigateway.put-gateway-response-request/response-templates]))

(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-cache-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-cache-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/flush-stage-cache-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.flush-stage-cache-request/rest-api-id :portkey.aws.apigateway.flush-stage-cache-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-resource-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-resource-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-resource-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-resource-request/rest-api-id :portkey.aws.apigateway.update-resource-request/resource-id] :opt-un [:portkey.aws.apigateway.update-resource-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-gateway-response (clojure.spec.alpha/coll-of :portkey.aws.apigateway/gateway-response))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-string-to-boolean (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/nullable-boolean))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method-settings (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method-setting))

(clojure.spec.alpha/def :portkey.aws.apigateway/quota-period-type #{"WEEK" :day "MONTH" :week :month "DAY"})

(clojure.spec.alpha/def :portkey.aws.apigateway/put-mode #{:merge :overwrite "overwrite" "merge"})

(clojure.spec.alpha/def :portkey.aws.apigateway.request-validators/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.request-validators/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-request-validator))
(clojure.spec.alpha/def :portkey.aws.apigateway/request-validators (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.request-validators/position :portkey.aws.apigateway.request-validators/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-method-response-request/rest-api-id :portkey.aws.apigateway.delete-method-response-request/resource-id :portkey.aws.apigateway.delete-method-response-request/http-method :portkey.aws.apigateway.delete-method-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-method-request/rest-api-id :portkey.aws.apigateway.get-method-request/resource-id :portkey.aws.apigateway.get-method-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-keys/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-keys/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-usage-plan-key))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plan-keys (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plan-keys/position :portkey.aws.apigateway.usage-plan-keys/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/api-stages (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-api-stage))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/throttle (clojure.spec.alpha/and :portkey.aws.apigateway/throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/quota (clojure.spec.alpha/and :portkey.aws.apigateway/quota-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan/product-code (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plan (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plan/id :portkey.aws.apigateway.usage-plan/name :portkey.aws.apigateway.usage-plan/description :portkey.aws.apigateway.usage-plan/api-stages :portkey.aws.apigateway.usage-plan/throttle :portkey.aws.apigateway.usage-plan/quota :portkey.aws.apigateway.usage-plan/product-code]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-long (clojure.spec.alpha/coll-of :portkey.aws.apigateway/long))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/schema (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-model-request/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-model-request/rest-api-id :portkey.aws.apigateway.create-model-request/name :portkey.aws.apigateway.create-model-request/content-type] :opt-un [:portkey.aws.apigateway.create-model-request/description :portkey.aws.apigateway.create-model-request/schema]))

(clojure.spec.alpha/def :portkey.aws.apigateway.too-many-requests-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.too-many-requests-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/too-many-requests-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.too-many-requests-exception/retry-after-seconds :portkey.aws.apigateway.too-many-requests-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.deployment-canary-settings/percent-traffic (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment-canary-settings/stage-variable-overrides (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployment-canary-settings/use-stage-cache (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/deployment-canary-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.deployment-canary-settings/percent-traffic :portkey.aws.apigateway.deployment-canary-settings/stage-variable-overrides :portkey.aws.apigateway.deployment-canary-settings/use-stage-cache]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-rest-api-request/rest-api-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-account-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-account-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.update-account-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-rest-apis-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-rest-apis-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-rest-apis-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-rest-apis-request/position :portkey.aws.apigateway.get-rest-apis-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-model-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-model-request/rest-api-id :portkey.aws.apigateway.delete-model-request/model-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.tag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.tag-resource-request/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.tag-resource-request/resource-arn :portkey.aws.apigateway.tag-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/api-key-source-type #{:header "HEADER" :authorizer "AUTHORIZER"})

(clojure.spec.alpha/def :portkey.aws.apigateway.throttle-settings/burst-limit (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.throttle-settings/rate-limit (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway/throttle-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.throttle-settings/burst-limit :portkey.aws.apigateway.throttle-settings/rate-limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-sdk-type (clojure.spec.alpha/coll-of :portkey.aws.apigateway/sdk-type))

(clojure.spec.alpha/def :portkey.aws.apigateway/cache-cluster-size #{"118" "237" :05 "1.6" :118 :61 "0.5" :16 "28.4" :135 "58.2" :284 "6.1" :237 :582 "13.5"})

(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-response/default-response (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/gateway-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.gateway-response/response-type :portkey.aws.apigateway.gateway-response/status-code :portkey.aws.apigateway.gateway-response/response-parameters :portkey.aws.apigateway.gateway-response/response-templates :portkey.aws.apigateway.gateway-response/default-response]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-template-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-model-template-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-model-template-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-model-template-request/rest-api-id :portkey.aws.apigateway.get-model-template-request/model-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-integration-response-request/rest-api-id :portkey.aws.apigateway.delete-integration-response-request/resource-id :portkey.aws.apigateway.delete-integration-response-request/http-method :portkey.aws.apigateway.delete-integration-response-request/status-code] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/integration-type #{:aws "AWS" :aws-proxy "MOCK" "AWS_PROXY" "HTTP_PROXY" :http :http-proxy "HTTP" :mock})

(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mapping/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mapping/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.base-path-mapping/stage (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/base-path-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.base-path-mapping/base-path :portkey.aws.apigateway.base-path-mapping/rest-api-id :portkey.aws.apigateway.base-path-mapping/stage]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-request-validator-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-request-validator-request/rest-api-id :portkey.aws.apigateway.get-request-validator-request/request-validator-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-resource (clojure.spec.alpha/coll-of :portkey.aws.apigateway/resource))

(clojure.spec.alpha/def :portkey.aws.apigateway/op #{:remove :copy "copy" :replace :move "replace" "remove" "move" "add" :add :test "test"})

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-ids/ids (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-ids/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-ids (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-part-ids/ids :portkey.aws.apigateway.documentation-part-ids/warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizers-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizers-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-authorizers-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-authorizers-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-authorizers-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-authorizers-request/position :portkey.aws.apigateway.get-authorizers-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.model/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/schema (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.model/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/model (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.model/id :portkey.aws.apigateway.model/name :portkey.aws.apigateway.model/description :portkey.aws.apigateway.model/schema :portkey.aws.apigateway.model/content-type]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-domain-name-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-domain-name-request/domain-name] :opt-un [:portkey.aws.apigateway.update-domain-name-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-usage-plan-key-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-usage-plan-key-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-usage-plan-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-usage-plan-key-request/usage-plan-id :portkey.aws.apigateway.delete-usage-plan-key-request/key-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-base-path-mapping-request/domain-name :portkey.aws.apigateway.get-base-path-mapping-request/base-path] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/authorizer-type #{:cognito-user-pools :request "TOKEN" :token "COGNITO_USER_POOLS" "REQUEST"})

(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-response-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-method-response-request/rest-api-id :portkey.aws.apigateway.update-method-response-request/resource-id :portkey.aws.apigateway.update-method-response-request/http-method :portkey.aws.apigateway.update-method-response-request/status-code] :opt-un [:portkey.aws.apigateway.update-method-response-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-ar-ns (clojure.spec.alpha/coll-of :portkey.aws.apigateway/provider-arn))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-api-stage (clojure.spec.alpha/coll-of :portkey.aws.apigateway/api-stage))

(clojure.spec.alpha/def :portkey.aws.apigateway.domain-names/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-names/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-domain-name))
(clojure.spec.alpha/def :portkey.aws.apigateway/domain-names (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.domain-names/position :portkey.aws.apigateway.domain-names/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-response-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-integration-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-integration-response-request/rest-api-id :portkey.aws.apigateway.update-integration-response-request/resource-id :portkey.aws.apigateway.update-integration-response-request/http-method :portkey.aws.apigateway.update-integration-response-request/status-code] :opt-un [:portkey.aws.apigateway.update-integration-response-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.conflict-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-response-request/response-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-method-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-method-response-request/rest-api-id :portkey.aws.apigateway.put-method-response-request/resource-id :portkey.aws.apigateway.put-method-response-request/http-method :portkey.aws.apigateway.put-method-response-request/status-code] :opt-un [:portkey.aws.apigateway.put-method-response-request/response-parameters :portkey.aws.apigateway.put-method-response-request/response-models]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-domain-name-request/domain-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.account/cloudwatch-role-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.account/throttle-settings (clojure.spec.alpha/and :portkey.aws.apigateway/throttle-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.account/features (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.account/api-key-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/account (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.account/cloudwatch-role-arn :portkey.aws.apigateway.account/throttle-settings :portkey.aws.apigateway.account/features :portkey.aws.apigateway.account/api-key-version]))

(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/status (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/multi-value-headers (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-list))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/log (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.test-invoke-method-response/latency (clojure.spec.alpha/and :portkey.aws.apigateway/long))
(clojure.spec.alpha/def :portkey.aws.apigateway/test-invoke-method-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.test-invoke-method-response/status :portkey.aws.apigateway.test-invoke-method-response/body :portkey.aws.apigateway.test-invoke-method-response/headers :portkey.aws.apigateway.test-invoke-method-response/multi-value-headers :portkey.aws.apigateway.test-invoke-method-response/log :portkey.aws.apigateway.test-invoke-method-response/latency]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-plan-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-usage-plan-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-usage-plan-request/usage-plan-id] :opt-un [:portkey.aws.apigateway.update-usage-plan-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-responses-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-responses-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-responses-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-gateway-responses-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-gateway-responses-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-gateway-responses-request/position :portkey.aws.apigateway.get-gateway-responses-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.method/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/authorization-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/operation-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/authorization-scopes (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/api-key-required (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/request-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/method-integration (clojure.spec.alpha/and :portkey.aws.apigateway/integration))
(clojure.spec.alpha/def :portkey.aws.apigateway.method/method-responses (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-method-response))
(clojure.spec.alpha/def :portkey.aws.apigateway/method (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.method/authorizer-id :portkey.aws.apigateway.method/request-validator-id :portkey.aws.apigateway.method/authorization-type :portkey.aws.apigateway.method/http-method :portkey.aws.apigateway.method/operation-name :portkey.aws.apigateway.method/request-parameters :portkey.aws.apigateway.method/authorization-scopes :portkey.aws.apigateway.method/api-key-required :portkey.aws.apigateway.method/request-models :portkey.aws.apigateway.method/method-integration :portkey.aws.apigateway.method/method-responses]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-stage (clojure.spec.alpha/coll-of :portkey.aws.apigateway/stage))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/tracing-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/canary-settings (clojure.spec.alpha/and :portkey.aws.apigateway/deployment-canary-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/stage-description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/cache-cluster-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-deployment-request/cache-cluster-size (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-size))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-deployment-request/rest-api-id] :opt-un [:portkey.aws.apigateway.create-deployment-request/tracing-enabled :portkey.aws.apigateway.create-deployment-request/canary-settings :portkey.aws.apigateway.create-deployment-request/stage-description :portkey.aws.apigateway.create-deployment-request/variables :portkey.aws.apigateway.create-deployment-request/cache-cluster-enabled :portkey.aws.apigateway.create-deployment-request/stage-name :portkey.aws.apigateway.create-deployment-request/description :portkey.aws.apigateway.create-deployment-request/cache-cluster-size]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-method-response (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/method-response))

(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/percent-traffic (clojure.spec.alpha/and :portkey.aws.apigateway/double))
(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/stage-variable-overrides (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.canary-settings/use-stage-cache (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/canary-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.canary-settings/percent-traffic :portkey.aws.apigateway.canary-settings/deployment-id :portkey.aws.apigateway.canary-settings/stage-variable-overrides :portkey.aws.apigateway.canary-settings/use-stage-cache]))

(clojure.spec.alpha/def :portkey.aws.apigateway.resources/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resources/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-resource))
(clojure.spec.alpha/def :portkey.aws.apigateway/resources (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.resources/position :portkey.aws.apigateway.resources/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-vpc-link-request/vpc-link-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-vpc-link-request/vpc-link-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-usage (clojure.spec.alpha/coll-of :portkey.aws.apigateway/list-of-long))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/validate-request-body (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-request-validator-request/validate-request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-request-validator-request/rest-api-id] :opt-un [:portkey.aws.apigateway.create-request-validator-request/name :portkey.aws.apigateway.create-request-validator-request/validate-request-body :portkey.aws.apigateway.create-request-validator-request/validate-request-parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-version-request/rest-api-id :portkey.aws.apigateway.get-documentation-version-request/documentation-version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.stage-key/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage-key/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/stage-key (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.stage-key/rest-api-id :portkey.aws.apigateway.stage-key/stage-name]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/name-query (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/customer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-keys-request/include-values (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-api-keys-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-api-keys-request/position :portkey.aws.apigateway.get-api-keys-request/limit :portkey.aws.apigateway.get-api-keys-request/name-query :portkey.aws.apigateway.get-api-keys-request/customer-id :portkey.aws.apigateway.get-api-keys-request/include-values]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-keys-request/name-query (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plan-keys-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-plan-keys-request/usage-plan-id] :opt-un [:portkey.aws.apigateway.get-usage-plan-keys-request/position :portkey.aws.apigateway.get-usage-plan-keys-request/limit :portkey.aws.apigateway.get-usage-plan-keys-request/name-query]))

(clojure.spec.alpha/def :portkey.aws.apigateway.not-found-exception/message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-client-certificate-request/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-client-certificate-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-client-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-client-certificate-request/client-certificate-id] :opt-un [:portkey.aws.apigateway.update-client-certificate-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/generate-distinct-id (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/stage-keys (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-stage-keys))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-api-key-request/customer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-api-key-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.create-api-key-request/name :portkey.aws.apigateway.create-api-key-request/description :portkey.aws.apigateway.create-api-key-request/enabled :portkey.aws.apigateway.create-api-key-request/generate-distinct-id :portkey.aws.apigateway.create-api-key-request/value :portkey.aws.apigateway.create-api-key-request/stage-keys :portkey.aws.apigateway.create-api-key-request/customer-id]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployment-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployment-request/embed (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-deployment-request/rest-api-id :portkey.aws.apigateway.get-deployment-request/deployment-id] :opt-un [:portkey.aws.apigateway.get-deployment-request/embed]))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-types/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-types/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-sdk-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-types (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-types/position :portkey.aws.apigateway.sdk-types/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.access-log-settings/format (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.access-log-settings/destination-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/access-log-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.access-log-settings/format :portkey.aws.apigateway.access-log-settings/destination-arn]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-documentation-version-request/rest-api-id :portkey.aws.apigateway.delete-documentation-version-request/documentation-version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-client-certificates-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-client-certificates-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-client-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-client-certificates-request/position :portkey.aws.apigateway.get-client-certificates-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.apigateway/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-base-path-mapping-request/domain-name :portkey.aws.apigateway.delete-base-path-mapping-request/base-path] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/vpc-link-status #{:pending "AVAILABLE" "PENDING" :deleting "DELETING" "FAILED" :available :failed})

(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-links/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-links/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-vpc-link))
(clojure.spec.alpha/def :portkey.aws.apigateway/vpc-links (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.vpc-links/position :portkey.aws.apigateway.vpc-links/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-documentation-version (clojure.spec.alpha/coll-of :portkey.aws.apigateway/documentation-version))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-model-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-model-request/model-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-model-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-model-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-model-request/rest-api-id :portkey.aws.apigateway.update-model-request/model-name] :opt-un [:portkey.aws.apigateway.update-model-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.quota-settings/limit (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.quota-settings/offset (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.quota-settings/period (clojure.spec.alpha/and :portkey.aws.apigateway/quota-period-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/quota-settings (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.quota-settings/limit :portkey.aws.apigateway.quota-settings/offset :portkey.aws.apigateway.quota-settings/period]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-version-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-version-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-version-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-documentation-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-documentation-version-request/rest-api-id :portkey.aws.apigateway.update-documentation-version-request/documentation-version] :opt-un [:portkey.aws.apigateway.update-documentation-version-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-stage-request/rest-api-id :portkey.aws.apigateway.get-stage-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/provider-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.apigateway/path-to-map-of-method-snapshot (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/map-of-method-snapshot))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plan-key/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plan-key (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plan-key/id :portkey.aws.apigateway.usage-plan-key/type :portkey.aws.apigateway.usage-plan-key/value :portkey.aws.apigateway.usage-plan-key/name]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-string-to-string (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/string))

(clojure.spec.alpha/def :portkey.aws.apigateway/connection-type #{:vpc-link "INTERNET" :internet "VPC_LINK"})

(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/authorizer-credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/identity-validation-expression (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/type (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/authorizer-result-ttl-in-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/authorizer-uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/auth-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/identity-source (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-authorizer-request/provider-ar-ns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-ar-ns))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-authorizer-request/rest-api-id :portkey.aws.apigateway.create-authorizer-request/name :portkey.aws.apigateway.create-authorizer-request/type] :opt-un [:portkey.aws.apigateway.create-authorizer-request/authorizer-credentials :portkey.aws.apigateway.create-authorizer-request/identity-validation-expression :portkey.aws.apigateway.create-authorizer-request/authorizer-result-ttl-in-seconds :portkey.aws.apigateway.create-authorizer-request/authorizer-uri :portkey.aws.apigateway.create-authorizer-request/auth-type :portkey.aws.apigateway.create-authorizer-request/identity-source :portkey.aws.apigateway.create-authorizer-request/provider-ar-ns]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-gateway-response-request/rest-api-id :portkey.aws.apigateway.delete-gateway-response-request/response-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-tags-request/resource-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-tags-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-tags-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-tags-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-tags-request/resource-arn] :opt-un [:portkey.aws.apigateway.get-tags-request/position :portkey.aws.apigateway.get-tags-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-response-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-gateway-response-request/response-type (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-gateway-response-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-gateway-response-request/rest-api-id :portkey.aws.apigateway.get-gateway-response-request/response-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-domain-names-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-domain-names-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-domain-names-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-domain-names-request/position :portkey.aws.apigateway.get-domain-names-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/type (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-location-status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-part-location/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-part-location (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.documentation-part-location/type] :opt-un [:portkey.aws.apigateway.documentation-part-location/path :portkey.aws.apigateway.documentation-part-location/method :portkey.aws.apigateway.documentation-part-location/status-code :portkey.aws.apigateway.documentation-part-location/name]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/base-path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-base-path-mapping-request/stage (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-base-path-mapping-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-base-path-mapping-request/domain-name :portkey.aws.apigateway.create-base-path-mapping-request/rest-api-id] :opt-un [:portkey.aws.apigateway.create-base-path-mapping-request/base-path :portkey.aws.apigateway.create-base-path-mapping-request/stage]))

(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/pem-encoded-certificate (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.client-certificate/expiration-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway/client-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.client-certificate/client-certificate-id :portkey.aws.apigateway.client-certificate/description :portkey.aws.apigateway.client-certificate/pem-encoded-certificate :portkey.aws.apigateway.client-certificate/created-date :portkey.aws.apigateway.client-certificate/expiration-date]))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-keys/warnings (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-keys/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-keys/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-api-key))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-keys (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-keys/warnings :portkey.aws.apigateway.api-keys/position :portkey.aws.apigateway.api-keys/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plans/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage-plans/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-usage-plan))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage-plans (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage-plans/position :portkey.aws.apigateway.usage-plans/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-key-usages (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/list-of-usage))

(clojure.spec.alpha/def :portkey.aws.apigateway/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-authorizer (clojure.spec.alpha/coll-of :portkey.aws.apigateway/authorizer))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/tracing-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/canary-settings (clojure.spec.alpha/and :portkey.aws.apigateway/canary-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/cache-cluster-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-stage-request/cache-cluster-size (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-size))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-stage-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-stage-request/rest-api-id :portkey.aws.apigateway.create-stage-request/stage-name :portkey.aws.apigateway.create-stage-request/deployment-id] :opt-un [:portkey.aws.apigateway.create-stage-request/tracing-enabled :portkey.aws.apigateway.create-stage-request/tags :portkey.aws.apigateway.create-stage-request/documentation-version :portkey.aws.apigateway.create-stage-request/canary-settings :portkey.aws.apigateway.create-stage-request/variables :portkey.aws.apigateway.create-stage-request/cache-cluster-enabled :portkey.aws.apigateway.create-stage-request/description :portkey.aws.apigateway.create-stage-request/cache-cluster-size]))

(clojure.spec.alpha/def :portkey.aws.apigateway/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.apigateway.authorizers/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizers/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-authorizer))
(clojure.spec.alpha/def :portkey.aws.apigateway/authorizers (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.authorizers/position :portkey.aws.apigateway.authorizers/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-models-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-models-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-models-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-models-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-models-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-models-request/position :portkey.aws.apigateway.get-models-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-api-key-request/api-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-api-key-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-api-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-api-key-request/api-key] :opt-un [:portkey.aws.apigateway.update-api-key-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.usage/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/start-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/end-date (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.usage/items (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-key-usages))
(clojure.spec.alpha/def :portkey.aws.apigateway/usage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.usage/usage-plan-id :portkey.aws.apigateway.usage/start-date :portkey.aws.apigateway.usage/end-date :portkey.aws.apigateway.usage/position :portkey.aws.apigateway.usage/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-rest-api-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-rest-api-request/rest-api-id] :opt-un [:portkey.aws.apigateway.update-rest-api-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/api-keys-format #{:csv "csv"})

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-versions-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-versions-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-versions-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-versions-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-documentation-versions-request/position :portkey.aws.apigateway.get-documentation-versions-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployments-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployments-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-deployments-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-deployments-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-deployments-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-deployments-request/position :portkey.aws.apigateway.get-deployments-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway/get-account-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-usage-plan (clojure.spec.alpha/coll-of :portkey.aws.apigateway/usage-plan))

(clojure.spec.alpha/def :portkey.aws.apigateway.import-api-keys-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-api-keys-request/format (clojure.spec.alpha/and :portkey.aws.apigateway/api-keys-format))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-api-keys-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/import-api-keys-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.import-api-keys-request/body :portkey.aws.apigateway.import-api-keys-request/format] :opt-un [:portkey.aws.apigateway.import-api-keys-request/fail-on-warnings]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-vpc-links-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-vpc-links-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-vpc-links-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-vpc-links-request/position :portkey.aws.apigateway.get-vpc-links-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.resource/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/parent-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/path-part (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.resource/resource-methods (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-method))
(clojure.spec.alpha/def :portkey.aws.apigateway/resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.resource/id :portkey.aws.apigateway.resource/parent-id :portkey.aws.apigateway.resource/path-part :portkey.aws.apigateway.resource/path :portkey.aws.apigateway.resource/resource-methods]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-endpoint-type (clojure.spec.alpha/coll-of :portkey.aws.apigateway/endpoint-type))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-key-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-key-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-usage-plan-key-request/key-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-usage-plan-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-usage-plan-key-request/usage-plan-id :portkey.aws.apigateway.create-usage-plan-key-request/key-id :portkey.aws.apigateway.create-usage-plan-key-request/key-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-patch-operation (clojure.spec.alpha/coll-of :portkey.aws.apigateway/patch-operation))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/friendly-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/required (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-configuration-property/default-value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-configuration-property (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-configuration-property/name :portkey.aws.apigateway.sdk-configuration-property/friendly-name :portkey.aws.apigateway.sdk-configuration-property/description :portkey.aws.apigateway.sdk-configuration-property/required :portkey.aws.apigateway.sdk-configuration-property/default-value]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-integration-request/rest-api-id :portkey.aws.apigateway.delete-integration-request/resource-id :portkey.aws.apigateway.delete-integration-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-response/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-response/content-disposition (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.sdk-response/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/sdk-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.sdk-response/content-type :portkey.aws.apigateway.sdk-response/content-disposition :portkey.aws.apigateway.sdk-response/body]))

(clojure.spec.alpha/def :portkey.aws.apigateway.import-rest-api-request/fail-on-warnings (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-rest-api-request/parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.import-rest-api-request/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/import-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.import-rest-api-request/body] :opt-un [:portkey.aws.apigateway.import-rest-api-request/fail-on-warnings :portkey.aws.apigateway.import-rest-api-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/type (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/name-query (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/path (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-documentation-parts-request/location-status (clojure.spec.alpha/and :portkey.aws.apigateway/location-status-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-documentation-parts-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-documentation-parts-request/rest-api-id] :opt-un [:portkey.aws.apigateway.get-documentation-parts-request/type :portkey.aws.apigateway.get-documentation-parts-request/name-query :portkey.aws.apigateway.get-documentation-parts-request/path :portkey.aws.apigateway.get-documentation-parts-request/position :portkey.aws.apigateway.get-documentation-parts-request/limit :portkey.aws.apigateway.get-documentation-parts-request/location-status]))

(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/stage-keys (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/customer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/value (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/last-updated-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.api-key/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/api-key (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.api-key/created-date :portkey.aws.apigateway.api-key/enabled :portkey.aws.apigateway.api-key/id :portkey.aws.apigateway.api-key/stage-keys :portkey.aws.apigateway.api-key/customer-id :portkey.aws.apigateway.api-key/name :portkey.aws.apigateway.api-key/value :portkey.aws.apigateway.api-key/last-updated-date :portkey.aws.apigateway.api-key/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway/nullable-integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-method-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-method-request/rest-api-id :portkey.aws.apigateway.update-method-request/resource-id :portkey.aws.apigateway.update-method-request/http-method] :opt-un [:portkey.aws.apigateway.update-method-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-hosted-zone-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/distribution-hosted-zone-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/certificate-upload-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/distribution-domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.domain-name/regional-domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/domain-name (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.domain-name/domain-name :portkey.aws.apigateway.domain-name/endpoint-configuration :portkey.aws.apigateway.domain-name/certificate-arn :portkey.aws.apigateway.domain-name/regional-hosted-zone-id :portkey.aws.apigateway.domain-name/regional-certificate-arn :portkey.aws.apigateway.domain-name/regional-certificate-name :portkey.aws.apigateway.domain-name/distribution-hosted-zone-id :portkey.aws.apigateway.domain-name/certificate-upload-date :portkey.aws.apigateway.domain-name/certificate-name :portkey.aws.apigateway.domain-name/distribution-domain-name :portkey.aws.apigateway.domain-name/regional-domain-name]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-base-path-mapping (clojure.spec.alpha/coll-of :portkey.aws.apigateway/base-path-mapping))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-api-stage-throttle-settings (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/throttle-settings))

(clojure.spec.alpha/def :portkey.aws.apigateway/blob clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-integration-request/rest-api-id :portkey.aws.apigateway.get-integration-request/resource-id :portkey.aws.apigateway.get-integration-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-parts/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-parts/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-documentation-part))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-parts (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-parts/position :portkey.aws.apigateway.documentation-parts/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.export-response/content-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.export-response/content-disposition (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.export-response/body (clojure.spec.alpha/and :portkey.aws.apigateway/blob))
(clojure.spec.alpha/def :portkey.aws.apigateway/export-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.export-response/content-type :portkey.aws.apigateway.export-response/content-disposition :portkey.aws.apigateway.export-response/body]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-method-request/rest-api-id :portkey.aws.apigateway.delete-method-request/resource-id :portkey.aws.apigateway.delete-method-request/http-method] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-key-request/api-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-api-key-request/include-value (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-api-key-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-api-key-request/api-key] :opt-un [:portkey.aws.apigateway.get-api-key-request/include-value]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-vpc-link-request/vpc-link-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-vpc-link-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-vpc-link-request/vpc-link-id] :opt-un [:portkey.aws.apigateway.update-vpc-link-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-responses/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.gateway-responses/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-gateway-response))
(clojure.spec.alpha/def :portkey.aws.apigateway/gateway-responses (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.gateway-responses/position :portkey.aws.apigateway.gateway-responses/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/domain-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-chain (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/endpoint-configuration (clojure.spec.alpha/and :portkey.aws.apigateway/endpoint-configuration))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-private-key (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/regional-certificate-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/regional-certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-body (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-domain-name-request/certificate-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-domain-name-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-domain-name-request/domain-name] :opt-un [:portkey.aws.apigateway.create-domain-name-request/certificate-chain :portkey.aws.apigateway.create-domain-name-request/endpoint-configuration :portkey.aws.apigateway.create-domain-name-request/certificate-arn :portkey.aws.apigateway.create-domain-name-request/certificate-private-key :portkey.aws.apigateway.create-domain-name-request/regional-certificate-arn :portkey.aws.apigateway.create-domain-name-request/regional-certificate-name :portkey.aws.apigateway.create-domain-name-request/certificate-body :portkey.aws.apigateway.create-domain-name-request/certificate-name]))

(clojure.spec.alpha/def :portkey.aws.apigateway.integration/integration-responses (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-integration-response))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/connection-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/connection-type (clojure.spec.alpha/and :portkey.aws.apigateway/connection-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/request-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/cache-namespace (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/passthrough-behavior (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/type (clojure.spec.alpha/and :portkey.aws.apigateway/integration-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/cache-key-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration/timeout-in-millis (clojure.spec.alpha/and :portkey.aws.apigateway/integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/integration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.integration/integration-responses :portkey.aws.apigateway.integration/connection-id :portkey.aws.apigateway.integration/uri :portkey.aws.apigateway.integration/connection-type :portkey.aws.apigateway.integration/http-method :portkey.aws.apigateway.integration/request-templates :portkey.aws.apigateway.integration/request-parameters :portkey.aws.apigateway.integration/cache-namespace :portkey.aws.apigateway.integration/passthrough-behavior :portkey.aws.apigateway.integration/type :portkey.aws.apigateway.integration/content-handling :portkey.aws.apigateway.integration/cache-key-parameters :portkey.aws.apigateway.integration/credentials :portkey.aws.apigateway.integration/timeout-in-millis]))

(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-authorizers-cache-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.flush-stage-authorizers-cache-request/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/flush-stage-authorizers-cache-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.flush-stage-authorizers-cache-request/rest-api-id :portkey.aws.apigateway.flush-stage-authorizers-cache-request/stage-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-version/version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-version/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.documentation-version/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/documentation-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.documentation-version/version :portkey.aws.apigateway.documentation-version/created-date :portkey.aws.apigateway.documentation-version/description]))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plan-request/usage-plan-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plan-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-usage-plan-request/usage-plan-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/unauthorized-cache-control-header-strategy #{"SUCCEED_WITHOUT_RESPONSE_HEADER" :fail-with-403 :succeed-without-response-header "FAIL_WITH_403" :succeed-with-response-header "SUCCEED_WITH_RESPONSE_HEADER"})

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-deployment-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-deployment-request/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-deployment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-deployment-request/rest-api-id :portkey.aws.apigateway.delete-deployment-request/deployment-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-vpc-link-request/vpc-link-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-vpc-link-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-vpc-link-request/vpc-link-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-api-key (clojure.spec.alpha/coll-of :portkey.aws.apigateway/api-key))

(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/status-code (clojure.spec.alpha/and :portkey.aws.apigateway/status-code))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/selection-pattern (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/response-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/response-templates (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.integration-response/content-handling (clojure.spec.alpha/and :portkey.aws.apigateway/content-handling-strategy))
(clojure.spec.alpha/def :portkey.aws.apigateway/integration-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.integration-response/status-code :portkey.aws.apigateway.integration-response/selection-pattern :portkey.aws.apigateway.integration-response/response-parameters :portkey.aws.apigateway.integration-response/response-templates :portkey.aws.apigateway.integration-response/content-handling]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-domain-name (clojure.spec.alpha/coll-of :portkey.aws.apigateway/domain-name))

(clojure.spec.alpha/def :portkey.aws.apigateway/location-status-type #{:undocumented "UNDOCUMENTED" "DOCUMENTED" :documented})

(clojure.spec.alpha/def :portkey.aws.apigateway.get-rest-api-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-rest-api-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.get-rest-api-request/rest-api-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.endpoint-configuration/types (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-endpoint-type))
(clojure.spec.alpha/def :portkey.aws.apigateway/endpoint-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.endpoint-configuration/types]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-integration-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-integration-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-integration-request/rest-api-id :portkey.aws.apigateway.update-integration-request/resource-id :portkey.aws.apigateway.update-integration-request/http-method] :opt-un [:portkey.aws.apigateway.update-integration-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/resource-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/authorization-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/http-method (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/operation-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/request-parameters (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/authorization-scopes (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/api-key-required (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.put-method-request/request-models (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/put-method-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.put-method-request/rest-api-id :portkey.aws.apigateway.put-method-request/resource-id :portkey.aws.apigateway.put-method-request/http-method :portkey.aws.apigateway.put-method-request/authorization-type] :opt-un [:portkey.aws.apigateway.put-method-request/authorizer-id :portkey.aws.apigateway.put-method-request/request-validator-id :portkey.aws.apigateway.put-method-request/operation-name :portkey.aws.apigateway.put-method-request/request-parameters :portkey.aws.apigateway.put-method-request/authorization-scopes :portkey.aws.apigateway.put-method-request/api-key-required :portkey.aws.apigateway.put-method-request/request-models]))

(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/target-arns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/status (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link-status))
(clojure.spec.alpha/def :portkey.aws.apigateway.vpc-link/status-message (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/vpc-link (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.vpc-link/id :portkey.aws.apigateway.vpc-link/name :portkey.aws.apigateway.vpc-link/description :portkey.aws.apigateway.vpc-link/target-arns :portkey.aws.apigateway.vpc-link/status :portkey.aws.apigateway.vpc-link/status-message]))

(clojure.spec.alpha/def :portkey.aws.apigateway.models/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.models/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-model))
(clojure.spec.alpha/def :portkey.aws.apigateway/models (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.models/position :portkey.aws.apigateway.models/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-authorizer-request/rest-api-id :portkey.aws.apigateway.delete-authorizer-request/authorizer-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.stage/cache-cluster-status (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-status))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/web-acl-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/tracing-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/created-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/access-log-settings (clojure.spec.alpha/and :portkey.aws.apigateway/access-log-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/tags (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/documentation-version (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/method-settings (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-method-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/canary-settings (clojure.spec.alpha/and :portkey.aws.apigateway/canary-settings))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/deployment-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/client-certificate-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/last-updated-date (clojure.spec.alpha/and :portkey.aws.apigateway/timestamp))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/variables (clojure.spec.alpha/and :portkey.aws.apigateway/map-of-string-to-string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/cache-cluster-enabled (clojure.spec.alpha/and :portkey.aws.apigateway/boolean))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/stage-name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/description (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.stage/cache-cluster-size (clojure.spec.alpha/and :portkey.aws.apigateway/cache-cluster-size))
(clojure.spec.alpha/def :portkey.aws.apigateway/stage (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.stage/cache-cluster-status :portkey.aws.apigateway.stage/web-acl-arn :portkey.aws.apigateway.stage/tracing-enabled :portkey.aws.apigateway.stage/created-date :portkey.aws.apigateway.stage/access-log-settings :portkey.aws.apigateway.stage/tags :portkey.aws.apigateway.stage/documentation-version :portkey.aws.apigateway.stage/method-settings :portkey.aws.apigateway.stage/canary-settings :portkey.aws.apigateway.stage/deployment-id :portkey.aws.apigateway.stage/client-certificate-id :portkey.aws.apigateway.stage/last-updated-date :portkey.aws.apigateway.stage/variables :portkey.aws.apigateway.stage/cache-cluster-enabled :portkey.aws.apigateway.stage/stage-name :portkey.aws.apigateway.stage/description :portkey.aws.apigateway.stage/cache-cluster-size]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-authorizer-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-authorizer-request/authorizer-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-authorizer-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-authorizer-request/rest-api-id :portkey.aws.apigateway.update-authorizer-request/authorizer-id] :opt-un [:portkey.aws.apigateway.update-authorizer-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/list-of-stage-keys (clojure.spec.alpha/coll-of :portkey.aws.apigateway/stage-key))

(clojure.spec.alpha/def :portkey.aws.apigateway/content-handling-strategy #{"CONVERT_TO_BINARY" :convert-to-text :convert-to-binary "CONVERT_TO_TEXT"})

(clojure.spec.alpha/def :portkey.aws.apigateway.untag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-string))
(clojure.spec.alpha/def :portkey.aws.apigateway/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.untag-resource-request/resource-arn :portkey.aws.apigateway.untag-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.delete-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.delete-request-validator-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/delete-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.delete-request-validator-request/rest-api-id :portkey.aws.apigateway.delete-request-validator-request/request-validator-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-part-request/location (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-location))
(clojure.spec.alpha/def :portkey.aws.apigateway.create-documentation-part-request/properties (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway/create-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.create-documentation-part-request/rest-api-id :portkey.aws.apigateway.create-documentation-part-request/location :portkey.aws.apigateway.create-documentation-part-request/properties] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-request-validator-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-request-validator-request/request-validator-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-request-validator-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-request-validator-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-request-validator-request/rest-api-id :portkey.aws.apigateway.update-request-validator-request/request-validator-id] :opt-un [:portkey.aws.apigateway.update-request-validator-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway/map-of-integration-response (clojure.spec.alpha/map-of :portkey.aws.apigateway/string :portkey.aws.apigateway/integration-response))

(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plans-request/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plans-request/key-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.get-usage-plans-request/limit (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway/get-usage-plans-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.get-usage-plans-request/position :portkey.aws.apigateway.get-usage-plans-request/key-id :portkey.aws.apigateway.get-usage-plans-request/limit]))

(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/authorizer-credentials (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/identity-validation-expression (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/name (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/type (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer-type))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/authorizer-result-ttl-in-seconds (clojure.spec.alpha/and :portkey.aws.apigateway/nullable-integer))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/authorizer-uri (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/auth-type (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/identity-source (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.authorizer/provider-ar-ns (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-ar-ns))
(clojure.spec.alpha/def :portkey.aws.apigateway/authorizer (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.authorizer/authorizer-credentials :portkey.aws.apigateway.authorizer/identity-validation-expression :portkey.aws.apigateway.authorizer/id :portkey.aws.apigateway.authorizer/name :portkey.aws.apigateway.authorizer/type :portkey.aws.apigateway.authorizer/authorizer-result-ttl-in-seconds :portkey.aws.apigateway.authorizer/authorizer-uri :portkey.aws.apigateway.authorizer/auth-type :portkey.aws.apigateway.authorizer/identity-source :portkey.aws.apigateway.authorizer/provider-ar-ns]))

(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-part-request/rest-api-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-part-request/documentation-part-id (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.update-documentation-part-request/patch-operations (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-patch-operation))
(clojure.spec.alpha/def :portkey.aws.apigateway/update-documentation-part-request (clojure.spec.alpha/keys :req-un [:portkey.aws.apigateway.update-documentation-part-request/rest-api-id :portkey.aws.apigateway.update-documentation-part-request/documentation-part-id] :opt-un [:portkey.aws.apigateway.update-documentation-part-request/patch-operations]))

(clojure.spec.alpha/def :portkey.aws.apigateway.deployments/position (clojure.spec.alpha/and :portkey.aws.apigateway/string))
(clojure.spec.alpha/def :portkey.aws.apigateway.deployments/items (clojure.spec.alpha/and :portkey.aws.apigateway/list-of-deployment))
(clojure.spec.alpha/def :portkey.aws.apigateway/deployments (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.apigateway.deployments/position :portkey.aws.apigateway.deployments/items]))

(clojure.spec.alpha/def :portkey.aws.apigateway/boolean clojure.core/boolean?)

(clojure.core/defn tag-resource "Adds or updates a tag on a given resource." ([tag-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resource_arn}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/tag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/tag-resource-request) :ret clojure.core/true?)

(clojure.core/defn flush-stage-cache "Flushes a stage's cache." ([flush-stage-cache-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-flush-stage-cache-request flush-stage-cache-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/cache/data", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/flush-stage-cache-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "FlushStageCache", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef flush-stage-cache :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/flush-stage-cache-request) :ret clojure.core/true?)

(clojure.core/defn delete-vpc-link "Deletes an existing VpcLink of a specified identifier." ([delete-vpc-link-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-vpc-link-request delete-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks/{vpclink_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVpcLink", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-vpc-link-request) :ret clojure.core/true?)

(clojure.core/defn get-usage-plan "Gets a usage plan of a given plan identifier." ([get-usage-plan-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-usage-plan-request get-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlan", :http.request.configuration/output-deser-fn response-usage-plan, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-plan-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan))

(clojure.core/defn update-rest-api "Changes information about the specified API." ([update-rest-api-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-rest-api-request update-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn update-account "Changes information about the current Account resource." ([] (update-account {})) ([update-account-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-account-request update-account-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/account, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/account", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-account-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAccount", :http.request.configuration/output-deser-fn response-account, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-account :args (clojure.spec.alpha/? :portkey.aws.apigateway/update-account-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/account))

(clojure.core/defn delete-rest-api "Deletes the specified API." ([delete-rest-api-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-rest-api-request delete-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRestApi", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-rest-api-request) :ret clojure.core/true?)

(clojure.core/defn delete-method "Deletes an existing Method resource." ([delete-method-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-method-request delete-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteMethod", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-method-request) :ret clojure.core/true?)

(clojure.core/defn update-authorizer "Updates an existing Authorizer resource.\n AWS CLI\n(https://docs.aws.amazon.com/cli/latest/reference/apigateway/update-authorizer.html)" ([update-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-authorizer-request update-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizer, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAuthorizer", :http.request.configuration/output-deser-fn response-authorizer, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer))

(clojure.core/defn get-sdk-type ([get-sdk-type-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-sdk-type-request get-sdk-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/sdk-type, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/sdktypes/{sdktype_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-sdk-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSdkType", :http.request.configuration/output-deser-fn response-sdk-type, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sdk-type :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-sdk-type-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/sdk-type))

(clojure.core/defn update-domain-name "Changes information about the DomainName resource." ([update-domain-name-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-domain-name-request update-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-name, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDomainName", :http.request.configuration/output-deser-fn response-domain-name, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-domain-name-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-name))

(clojure.core/defn update-gateway-response "Updates a GatewayResponse of a specified response type on the given RestApi." ([update-gateway-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-gateway-response-request update-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateGatewayResponse", :http.request.configuration/output-deser-fn response-gateway-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-gateway-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response))

(clojure.core/defn get-rest-apis "Lists the RestApis resources for your collection." ([] (get-rest-apis {})) ([get-rest-apis-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-rest-apis-request get-rest-apis-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-apis, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-rest-apis-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRestApis", :http.request.configuration/output-deser-fn response-rest-apis, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-rest-apis :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-rest-apis-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-apis))

(clojure.core/defn get-documentation-parts ([get-documentation-parts-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-documentation-parts-request get-documentation-parts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-parts, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-parts-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationParts", :http.request.configuration/output-deser-fn response-documentation-parts, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-parts :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-parts-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-parts))

(clojure.core/defn get-deployment "Gets information about a Deployment resource." ([get-deployment-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-deployment-request get-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployment, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments/{deployment_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDeployment", :http.request.configuration/output-deser-fn response-deployment, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-deployment-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployment))

(clojure.core/defn create-resource "Creates a Resource resource." ([create-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-resource-request create-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resource, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{parent_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateResource", :http.request.configuration/output-deser-fn response-resource, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resource))

(clojure.core/defn delete-documentation-version ([delete-documentation-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-documentation-version-request delete-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions/{doc_version}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocumentationVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-documentation-version-request) :ret clojure.core/true?)

(clojure.core/defn delete-usage-plan "Deletes a usage plan of a given plan Id." ([delete-usage-plan-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-usage-plan-request delete-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUsagePlan", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef delete-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-usage-plan-request) :ret clojure.core/true?)

(clojure.core/defn get-stages "Gets information about one or more Stage resources." ([get-stages-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-stages-request get-stages-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stages, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-stages-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetStages", :http.request.configuration/output-deser-fn response-stages, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-stages :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-stages-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stages))

(clojure.core/defn get-tags "Gets the Tags collection for a given resource." ([get-tags-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-tags-request get-tags-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/tags, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resource_arn}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-tags-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTags", :http.request.configuration/output-deser-fn response-tags, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef get-tags :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-tags-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/tags))

(clojure.core/defn get-resource "Lists information about a resource." ([get-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-resource-request get-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resource, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetResource", :http.request.configuration/output-deser-fn response-resource, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resource))

(clojure.core/defn update-documentation-part ([update-documentation-part-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-documentation-part-request update-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts/{part_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentationPart", :http.request.configuration/output-deser-fn response-documentation-part, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-documentation-part-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part))

(clojure.core/defn create-vpc-link "Creates a VPC link, under the caller's account in a selected region, in an\nasynchronous operation that typically takes 2-4 minutes to complete and become\noperational. The caller must have permissions to create and update VPC Endpoint\nservices." ([create-vpc-link-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-vpc-link-request create-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-link, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateVpcLink", :http.request.configuration/output-deser-fn response-vpc-link, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-vpc-link-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link))

(clojure.core/defn import-api-keys "Import API keys from an external source, such as a CSV-formatted file." ([import-api-keys-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-import-api-keys-request import-api-keys-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key-ids, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys?mode=import", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/import-api-keys-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportApiKeys", :http.request.configuration/output-deser-fn response-api-key-ids, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef import-api-keys :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/import-api-keys-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key-ids))

(clojure.core/defn get-client-certificate "Gets information about the current ClientCertificate resource." ([get-client-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-client-certificate-request get-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificate, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates/{clientcertificate_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetClientCertificate", :http.request.configuration/output-deser-fn response-client-certificate, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-client-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificate))

(clojure.core/defn create-authorizer "Adds a new Authorizer resource to an existing RestApi resource.\n AWS CLI\n(https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-authorizer.html)" ([create-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-authorizer-request create-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizer, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAuthorizer", :http.request.configuration/output-deser-fn response-authorizer, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer))

(clojure.core/defn get-usage-plan-keys "Gets all the usage plan keys representing the API keys added to a specified\nusage plan." ([get-usage-plan-keys-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-usage-plan-keys-request get-usage-plan-keys-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan-keys, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plan-keys-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlanKeys", :http.request.configuration/output-deser-fn response-usage-plan-keys, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage-plan-keys :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-plan-keys-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan-keys))

(clojure.core/defn get-gateway-response "Gets a GatewayResponse of a specified response type on the given RestApi." ([get-gateway-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-gateway-response-request get-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetGatewayResponse", :http.request.configuration/output-deser-fn response-gateway-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-gateway-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response))

(clojure.core/defn get-deployments "Gets information about a Deployments collection." ([get-deployments-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-deployments-request get-deployments-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployments, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-deployments-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDeployments", :http.request.configuration/output-deser-fn response-deployments, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-deployments :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-deployments-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployments))

(clojure.core/defn update-resource "Changes information about a Resource resource." ([update-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-resource-request update-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resource, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateResource", :http.request.configuration/output-deser-fn response-resource, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resource))

(clojure.core/defn get-authorizers "Describe an existing Authorizers resource.\n AWS CLI\n(https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizers.html)" ([get-authorizers-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-authorizers-request get-authorizers-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizers, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-authorizers-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAuthorizers", :http.request.configuration/output-deser-fn response-authorizers, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-authorizers :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-authorizers-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizers))

(clojure.core/defn get-base-path-mapping "Describe a BasePathMapping resource." ([get-base-path-mapping-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-base-path-mapping-request get-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mapping, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings/{base_path}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBasePathMapping", :http.request.configuration/output-deser-fn response-base-path-mapping, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-base-path-mapping-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mapping))

(clojure.core/defn update-vpc-link "Updates an existing VpcLink of a specified identifier." ([update-vpc-link-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-vpc-link-request update-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-link, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks/{vpclink_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateVpcLink", :http.request.configuration/output-deser-fn response-vpc-link, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-vpc-link-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link))

(clojure.core/defn get-vpc-links "Gets the VpcLinks collection under the caller's account in a selected region." ([] (get-vpc-links {})) ([get-vpc-links-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-vpc-links-request get-vpc-links-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-links, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-vpc-links-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetVpcLinks", :http.request.configuration/output-deser-fn response-vpc-links, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-vpc-links :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-vpc-links-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-links))

(clojure.core/defn delete-integration "Represents a delete integration." ([delete-integration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-integration-request delete-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteIntegration", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-integration-request) :ret clojure.core/true?)

(clojure.core/defn get-request-validators "Gets the RequestValidators collection of a given RestApi." ([get-request-validators-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-request-validators-request get-request-validators-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validators, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-request-validators-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRequestValidators", :http.request.configuration/output-deser-fn response-request-validators, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-request-validators :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-request-validators-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validators))

(clojure.core/defn create-domain-name "Creates a new domain name." ([create-domain-name-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-domain-name-request create-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-name, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDomainName", :http.request.configuration/output-deser-fn response-domain-name, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-domain-name-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-name))

(clojure.core/defn put-integration-response "Represents a put integration." ([put-integration-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-put-integration-response-request put-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutIntegrationResponse", :http.request.configuration/output-deser-fn response-integration-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef put-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-integration-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration-response))

(clojure.core/defn create-usage-plan "Creates a usage plan with the throttle and quota limits, as well as the\nassociated API stages, specified in the payload." ([create-usage-plan-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-usage-plan-request create-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateUsagePlan", :http.request.configuration/output-deser-fn response-usage-plan, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef create-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-usage-plan-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan))

(clojure.core/defn create-api-key "Create an ApiKey resource.\n AWS CLI\n(https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-api-key.html)" ([] (create-api-key {})) ([create-api-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-api-key-request create-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateApiKey", :http.request.configuration/output-deser-fn response-api-key, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef create-api-key :args (clojure.spec.alpha/? :portkey.aws.apigateway/create-api-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key))

(clojure.core/defn import-rest-api "A feature of the API Gateway control service for creating a new API from an\nexternal API definition file." ([import-rest-api-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-import-rest-api-request import-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis?mode=import", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/import-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef import-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/import-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn delete-api-key "Deletes the ApiKey resource." ([delete-api-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-api-key-request delete-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys/{api_Key}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApiKey", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-api-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-api-key-request) :ret clojure.core/true?)

(clojure.core/defn get-integration "Get the integration settings." ([get-integration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-integration-request get-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetIntegration", :http.request.configuration/output-deser-fn response-integration, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-integration-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration))

(clojure.core/defn get-export "Exports a deployed version of a RestApi in a specified format." ([get-export-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-export-request get-export-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/export-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-export-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetExport", :http.request.configuration/output-deser-fn response-export-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-export :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-export-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/export-response))

(clojure.core/defn delete-stage "Deletes a Stage resource." ([delete-stage-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-stage-request delete-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteStage", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-stage-request) :ret clojure.core/true?)

(clojure.core/defn delete-request-validator "Deletes a RequestValidator of a given RestApi." ([delete-request-validator-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-request-validator-request delete-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRequestValidator", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-request-validator-request) :ret clojure.core/true?)

(clojure.core/defn get-gateway-responses "Gets the GatewayResponses collection on the given RestApi. If an API developer\nhas not added any definitions for gateway responses, the result will be the API\nGateway-generated default GatewayResponses collection for the supported response\ntypes." ([get-gateway-responses-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-gateway-responses-request get-gateway-responses-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-responses, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-gateway-responses-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetGatewayResponses", :http.request.configuration/output-deser-fn response-gateway-responses, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-gateway-responses :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-gateway-responses-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-responses))

(clojure.core/defn put-method-response "Adds a MethodResponse to an existing Method resource." ([put-method-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-put-method-response-request put-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutMethodResponse", :http.request.configuration/output-deser-fn response-method-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-method-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method-response))

(clojure.core/defn get-model "Describes an existing model defined for a RestApi resource." ([get-model-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-model-request get-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/model, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetModel", :http.request.configuration/output-deser-fn response-model, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-model-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/model))

(clojure.core/defn create-model "Adds a new Model resource to an existing RestApi resource." ([create-model-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-model-request create-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/model, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateModel", :http.request.configuration/output-deser-fn response-model, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-model-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/model))

(clojure.core/defn update-api-key "Changes information about an ApiKey resource." ([update-api-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-api-key-request update-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys/{api_Key}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApiKey", :http.request.configuration/output-deser-fn response-api-key, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef update-api-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-api-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key))

(clojure.core/defn create-deployment "Creates a Deployment resource, which makes a specified RestApi callable over the\ninternet." ([create-deployment-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-deployment-request create-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployment, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDeployment", :http.request.configuration/output-deser-fn response-deployment, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-deployment-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployment))

(clojure.core/defn update-method "Updates an existing Method resource." ([update-method-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-method-request update-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMethod", :http.request.configuration/output-deser-fn response-method, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method))

(clojure.core/defn test-invoke-authorizer "Simulate the execution of an Authorizer in your RestApi with headers,\nparameters, and an incoming request body.\n Enable custom authorizers\n(https://docs.aws.amazon.com/apigateway/latest/developerguide/use-custom-authorizer.html)" ([test-invoke-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-test-invoke-authorizer-request test-invoke-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/test-invoke-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/test-invoke-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestInvokeAuthorizer", :http.request.configuration/output-deser-fn response-test-invoke-authorizer-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef test-invoke-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/test-invoke-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/test-invoke-authorizer-response))

(clojure.core/defn create-documentation-part ([create-documentation-part-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-documentation-part-request create-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDocumentationPart", :http.request.configuration/output-deser-fn response-documentation-part, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-documentation-part-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part))

(clojure.core/defn update-stage "Changes information about a Stage resource." ([update-stage-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-stage-request update-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateStage", :http.request.configuration/output-deser-fn response-stage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-stage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stage))

(clojure.core/defn update-request-validator "Updates a RequestValidator of a given RestApi." ([update-request-validator-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-request-validator-request update-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validator, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRequestValidator", :http.request.configuration/output-deser-fn response-request-validator, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-request-validator-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validator))

(clojure.core/defn get-sdk-types ([] (get-sdk-types {})) ([get-sdk-types-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-sdk-types-request get-sdk-types-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/sdk-types, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/sdktypes", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-sdk-types-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSdkTypes", :http.request.configuration/output-deser-fn response-sdk-types, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sdk-types :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-sdk-types-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/sdk-types))

(clojure.core/defn update-client-certificate "Changes information about an ClientCertificate resource." ([update-client-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-client-certificate-request update-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificate, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates/{clientcertificate_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateClientCertificate", :http.request.configuration/output-deser-fn response-client-certificate, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef update-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-client-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificate))

(clojure.core/defn update-model "Changes information about a model." ([update-model-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-model-request update-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/model, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateModel", :http.request.configuration/output-deser-fn response-model, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-model-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/model))

(clojure.core/defn get-documentation-versions ([get-documentation-versions-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-documentation-versions-request get-documentation-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-versions, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationVersions", :http.request.configuration/output-deser-fn response-documentation-versions, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-versions :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-versions))

(clojure.core/defn update-usage "Grants a temporary extension to the remaining quota of a usage plan associated\nwith a specified API key." ([update-usage-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-usage-request update-usage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys/{keyId}/usage", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-usage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateUsage", :http.request.configuration/output-deser-fn response-usage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef update-usage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-usage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage))

(clojure.core/defn create-usage-plan-key "Creates a usage plan key for adding an existing API key to a usage plan." ([create-usage-plan-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-usage-plan-key-request create-usage-plan-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-usage-plan-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateUsagePlanKey", :http.request.configuration/output-deser-fn response-usage-plan-key, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-usage-plan-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-usage-plan-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan-key))

(clojure.core/defn put-integration "Sets up a method's integration." ([put-integration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-put-integration-request put-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutIntegration", :http.request.configuration/output-deser-fn response-integration, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-integration-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration))

(clojure.core/defn get-usage "Gets the usage data of a usage plan in a specified time interval." ([get-usage-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-usage-request get-usage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/usage", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsage", :http.request.configuration/output-deser-fn response-usage, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage))

(clojure.core/defn update-documentation-version ([update-documentation-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-documentation-version-request update-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-version, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions/{doc_version}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentationVersion", :http.request.configuration/output-deser-fn response-documentation-version, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-documentation-version-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-version))

(clojure.core/defn get-stage "Gets information about a Stage resource." ([get-stage-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-stage-request get-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetStage", :http.request.configuration/output-deser-fn response-stage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-stage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stage))

(clojure.core/defn update-method-response "Updates an existing MethodResponse resource." ([update-method-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-method-response-request update-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateMethodResponse", :http.request.configuration/output-deser-fn response-method-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-method-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method-response))

(clojure.core/defn get-vpc-link "Gets a specified VPC link under the caller's account in a region." ([get-vpc-link-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-vpc-link-request get-vpc-link-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/vpc-link, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/vpclinks/{vpclink_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-vpc-link-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetVpcLink", :http.request.configuration/output-deser-fn response-vpc-link, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-vpc-link :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-vpc-link-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/vpc-link))

(clojure.core/defn create-base-path-mapping "Creates a new BasePathMapping resource." ([create-base-path-mapping-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-base-path-mapping-request create-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mapping, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBasePathMapping", :http.request.configuration/output-deser-fn response-base-path-mapping, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-base-path-mapping-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mapping))

(clojure.core/defn get-documentation-part ([get-documentation-part-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-documentation-part-request get-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts/{part_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationPart", :http.request.configuration/output-deser-fn response-documentation-part, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-part-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part))

(clojure.core/defn delete-model "Deletes a model." ([delete-model-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-model-request delete-model-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-model-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteModel", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-model :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-model-request) :ret clojure.core/true?)

(clojure.core/defn import-documentation-parts ([import-documentation-parts-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-import-documentation-parts-request import-documentation-parts-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-part-ids, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/import-documentation-parts-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ImportDocumentationParts", :http.request.configuration/output-deser-fn response-documentation-part-ids, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef import-documentation-parts :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/import-documentation-parts-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-part-ids))

(clojure.core/defn delete-method-response "Deletes an existing MethodResponse resource." ([delete-method-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-method-response-request delete-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteMethodResponse", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-method-response-request) :ret clojure.core/true?)

(clojure.core/defn get-client-certificates "Gets a collection of ClientCertificate resources." ([] (get-client-certificates {})) ([get-client-certificates-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-client-certificates-request get-client-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificates, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-client-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetClientCertificates", :http.request.configuration/output-deser-fn response-client-certificates, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-client-certificates :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-client-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificates))

(clojure.core/defn get-api-keys "Gets information about the current ApiKeys resource." ([] (get-api-keys {})) ([get-api-keys-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-api-keys-request get-api-keys-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-keys, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-api-keys-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApiKeys", :http.request.configuration/output-deser-fn response-api-keys, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-api-keys :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-api-keys-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-keys))

(clojure.core/defn update-deployment "Changes information about a Deployment resource." ([update-deployment-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-deployment-request update-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/deployment, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments/{deployment_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDeployment", :http.request.configuration/output-deser-fn response-deployment, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-deployment-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/deployment))

(clojure.core/defn delete-domain-name "Deletes the DomainName resource." ([delete-domain-name-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-domain-name-request delete-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDomainName", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-domain-name-request) :ret clojure.core/true?)

(clojure.core/defn create-rest-api "Creates a new RestApi resource." ([create-rest-api-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-rest-api-request create-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn delete-authorizer "Deletes an existing Authorizer resource.\n AWS CLI\n(https://docs.aws.amazon.com/cli/latest/reference/apigateway/delete-authorizer.html)" ([delete-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-authorizer-request delete-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAuthorizer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-authorizer-request) :ret clojure.core/true?)

(clojure.core/defn get-usage-plan-key "Gets a usage plan key of a given key identifier." ([get-usage-plan-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-usage-plan-key-request get-usage-plan-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys/{keyId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plan-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlanKey", :http.request.configuration/output-deser-fn response-usage-plan-key, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-usage-plan-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-usage-plan-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan-key))

(clojure.core/defn delete-resource "Deletes a Resource resource." ([delete-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-resource-request delete-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-resource-request) :ret clojure.core/true?)

(clojure.core/defn test-invoke-method "Simulate the execution of a Method in your RestApi with headers, parameters, and\nan incoming request body." ([test-invoke-method-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-test-invoke-method-request test-invoke-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/test-invoke-method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/test-invoke-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestInvokeMethod", :http.request.configuration/output-deser-fn response-test-invoke-method-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef test-invoke-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/test-invoke-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/test-invoke-method-response))

(clojure.core/defn get-method-response "Describes a MethodResponse resource." ([get-method-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-method-response-request get-method-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-method-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMethodResponse", :http.request.configuration/output-deser-fn response-method-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-method-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-method-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method-response))

(clojure.core/defn get-request-validator "Gets a RequestValidator of a given RestApi." ([get-request-validator-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-request-validator-request get-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validator, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRequestValidator", :http.request.configuration/output-deser-fn response-request-validator, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-request-validator-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validator))

(clojure.core/defn get-authorizer "Describe an existing Authorizer resource.\n AWS CLI\n(https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizer.html)" ([get-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-authorizer-request get-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/authorizer, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/authorizers/{authorizer_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAuthorizer", :http.request.configuration/output-deser-fn response-authorizer, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/authorizer))

(clojure.core/defn get-base-path-mappings "Represents a collection of BasePathMapping resources." ([get-base-path-mappings-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-base-path-mappings-request get-base-path-mappings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mappings, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-base-path-mappings-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBasePathMappings", :http.request.configuration/output-deser-fn response-base-path-mappings, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-base-path-mappings :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-base-path-mappings-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mappings))

(clojure.core/defn delete-base-path-mapping "Deletes the BasePathMapping resource." ([delete-base-path-mapping-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-base-path-mapping-request delete-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings/{base_path}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBasePathMapping", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-base-path-mapping-request) :ret clojure.core/true?)

(clojure.core/defn get-account "Gets information about the current Account resource." ([] (get-account {})) ([get-account-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-account-request get-account-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/account, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/account", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-account-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAccount", :http.request.configuration/output-deser-fn response-account, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-account :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-account-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/account))

(clojure.core/defn get-integration-response "Represents a get integration response." ([get-integration-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-integration-response-request get-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetIntegrationResponse", :http.request.configuration/output-deser-fn response-integration-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-integration-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration-response))

(clojure.core/defn get-model-template "Generates a sample mapping template that can be used to transform a payload into\nthe structure of a model." ([get-model-template-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-model-template-request get-model-template-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/template, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models/{model_name}/default_template", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-model-template-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetModelTemplate", :http.request.configuration/output-deser-fn response-template, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-model-template :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-model-template-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/template))

(clojure.core/defn get-rest-api "Lists the RestApi resource in the collection." ([get-rest-api-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-rest-api-request get-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn delete-integration-response "Represents a delete integration response." ([delete-integration-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-integration-response-request delete-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteIntegrationResponse", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-integration-response-request) :ret clojure.core/true?)

(clojure.core/defn delete-usage-plan-key "Deletes a usage plan key and remove the underlying API key from the associated\nusage plan." ([delete-usage-plan-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-usage-plan-key-request delete-usage-plan-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}/keys/{keyId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-usage-plan-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUsagePlanKey", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-usage-plan-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-usage-plan-key-request) :ret clojure.core/true?)

(clojure.core/defn delete-documentation-part ([delete-documentation-part-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-documentation-part-request delete-documentation-part-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/parts/{part_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-documentation-part-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocumentationPart", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception}})))))
(clojure.spec.alpha/fdef delete-documentation-part :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-documentation-part-request) :ret clojure.core/true?)

(clojure.core/defn untag-resource "Removes a tag from a given resource." ([untag-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resource_arn}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/untag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/untag-resource-request) :ret clojure.core/true?)

(clojure.core/defn generate-client-certificate "Generates a ClientCertificate resource." ([] (generate-client-certificate {})) ([generate-client-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-generate-client-certificate-request generate-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/client-certificate, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/generate-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GenerateClientCertificate", :http.request.configuration/output-deser-fn response-client-certificate, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef generate-client-certificate :args (clojure.spec.alpha/? :portkey.aws.apigateway/generate-client-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/client-certificate))

(clojure.core/defn get-method "Describe an existing Method resource." ([get-method-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-method-request get-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetMethod", :http.request.configuration/output-deser-fn response-method, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method))

(clojure.core/defn get-models "Describes existing Models defined for a RestApi resource." ([get-models-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-models-request get-models-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/models, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/models", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-models-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetModels", :http.request.configuration/output-deser-fn response-models, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-models :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-models-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/models))

(clojure.core/defn get-documentation-version ([get-documentation-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-documentation-version-request get-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-version, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions/{doc_version}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentationVersion", :http.request.configuration/output-deser-fn response-documentation-version, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-documentation-version-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-version))

(clojure.core/defn create-documentation-version ([create-documentation-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-documentation-version-request create-documentation-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/documentation-version, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/documentation/versions", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-documentation-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDocumentationVersion", :http.request.configuration/output-deser-fn response-documentation-version, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-documentation-version :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-documentation-version-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/documentation-version))

(clojure.core/defn get-resources "Lists information about a collection of Resource resources." ([get-resources-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-resources-request get-resources-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/resources, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-resources-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetResources", :http.request.configuration/output-deser-fn response-resources, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-resources :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-resources-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/resources))

(clojure.core/defn get-api-key "Gets information about the current ApiKey resource." ([get-api-key-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-api-key-request get-api-key-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/api-key, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/apikeys/{api_Key}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-api-key-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApiKey", :http.request.configuration/output-deser-fn response-api-key, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-api-key :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-api-key-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/api-key))

(clojure.core/defn create-stage "Creates a new Stage resource that references a pre-existing Deployment for the\nAPI." ([create-stage-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-stage-request create-stage-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/stage, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-stage-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateStage", :http.request.configuration/output-deser-fn response-stage, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-stage :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-stage-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/stage))

(clojure.core/defn delete-gateway-response "Clears any customization of a GatewayResponse of a specified response type on\nthe given RestApi and resets it with the default settings." ([delete-gateway-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-gateway-response-request delete-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteGatewayResponse", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef delete-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-gateway-response-request) :ret clojure.core/true?)

(clojure.core/defn update-integration "Represents an update integration." ([update-integration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-integration-request update-integration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-integration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateIntegration", :http.request.configuration/output-deser-fn response-integration, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef update-integration :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-integration-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration))

(clojure.core/defn flush-stage-authorizers-cache "Flushes all authorizer cache entries on a stage." ([flush-stage-authorizers-cache-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-flush-stage-authorizers-cache-request flush-stage-authorizers-cache-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/cache/authorizers", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/flush-stage-authorizers-cache-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "FlushStageAuthorizersCache", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef flush-stage-authorizers-cache :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/flush-stage-authorizers-cache-request) :ret clojure.core/true?)

(clojure.core/defn delete-client-certificate "Deletes the ClientCertificate resource." ([delete-client-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-client-certificate-request delete-client-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/clientcertificates/{clientcertificate_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-client-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClientCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef delete-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-client-certificate-request) :ret clojure.core/true?)

(clojure.core/defn put-gateway-response "Creates a customization of a GatewayResponse of a specified response type and\nstatus code on the given RestApi." ([put-gateway-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-put-gateway-response-request put-gateway-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/gateway-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/gatewayresponses/{response_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-gateway-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutGatewayResponse", :http.request.configuration/output-deser-fn response-gateway-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-gateway-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-gateway-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/gateway-response))

(clojure.core/defn get-domain-name "Represents a domain name that is contained in a simpler, more intuitive URL that\ncan be called." ([get-domain-name-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-domain-name-request get-domain-name-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-name, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-domain-name-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDomainName", :http.request.configuration/output-deser-fn response-domain-name, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ServiceUnavailableException" :portkey.aws.apigateway/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-domain-name :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-domain-name-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-name))

(clojure.core/defn update-base-path-mapping "Changes information about the BasePathMapping resource." ([update-base-path-mapping-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-base-path-mapping-request update-base-path-mapping-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/base-path-mapping, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames/{domain_name}/basepathmappings/{base_path}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-base-path-mapping-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateBasePathMapping", :http.request.configuration/output-deser-fn response-base-path-mapping, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-base-path-mapping :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-base-path-mapping-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/base-path-mapping))

(clojure.core/defn get-usage-plans "Gets all the usage plans of the caller's account." ([] (get-usage-plans {})) ([get-usage-plans-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-usage-plans-request get-usage-plans-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plans, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-usage-plans-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUsagePlans", :http.request.configuration/output-deser-fn response-usage-plans, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception}})))))
(clojure.spec.alpha/fdef get-usage-plans :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-usage-plans-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plans))

(clojure.core/defn update-usage-plan "Updates a usage plan of a given plan Id." ([update-usage-plan-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-usage-plan-request update-usage-plan-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/usage-plan, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/usageplans/{usageplanId}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-usage-plan-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateUsagePlan", :http.request.configuration/output-deser-fn response-usage-plan, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef update-usage-plan :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-usage-plan-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/usage-plan))

(clojure.core/defn get-sdk "Generates a client SDK for a RestApi and Stage." ([get-sdk-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-sdk-request get-sdk-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/sdk-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-sdk-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSdk", :http.request.configuration/output-deser-fn response-sdk-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sdk :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/get-sdk-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/sdk-response))

(clojure.core/defn put-method "Add a method to an existing Resource resource." ([put-method-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-put-method-request put-method-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/method, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-method-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutMethod", :http.request.configuration/output-deser-fn response-method, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-method :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-method-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/method))

(clojure.core/defn update-integration-response "Represents an update integration response." ([update-integration-response-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-integration-response-request update-integration-response-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/integration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/update-integration-response-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateIntegrationResponse", :http.request.configuration/output-deser-fn response-integration-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-integration-response :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/update-integration-response-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/integration-response))

(clojure.core/defn get-domain-names "Represents a collection of DomainName resources." ([] (get-domain-names {})) ([get-domain-names-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-domain-names-request get-domain-names-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/domain-names, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/domainnames", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/get-domain-names-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDomainNames", :http.request.configuration/output-deser-fn response-domain-names, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-domain-names :args (clojure.spec.alpha/? :portkey.aws.apigateway/get-domain-names-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/domain-names))

(clojure.core/defn put-rest-api "A feature of the API Gateway control service for updating an existing API with\nan input of external API definitions. The update can take the form of merging\nthe supplied definition into the existing API or overwriting the existing API." ([put-rest-api-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-put-rest-api-request put-rest-api-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/rest-api, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/put-rest-api-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutRestApi", :http.request.configuration/output-deser-fn response-rest-api, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception, "ConflictException" :portkey.aws.apigateway/conflict-exception}})))))
(clojure.spec.alpha/fdef put-rest-api :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/put-rest-api-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/rest-api))

(clojure.core/defn create-request-validator "Creates a ReqeustValidator of a given RestApi." ([create-request-validator-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-request-validator-request create-request-validator-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.apigateway/request-validator, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/requestvalidators", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/create-request-validator-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRequestValidator", :http.request.configuration/output-deser-fn response-request-validator, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.apigateway/bad-request-exception, "UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "LimitExceededException" :portkey.aws.apigateway/limit-exceeded-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-request-validator :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/create-request-validator-request) :ret (clojure.spec.alpha/and :portkey.aws.apigateway/request-validator))

(clojure.core/defn delete-deployment "Deletes a Deployment resource. Deleting a deployment will only succeed if there\nare no Stage resources associated with it." ([delete-deployment-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-deployment-request delete-deployment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.apigateway/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restapis/{restapi_id}/deployments/{deployment_id}", :http.request.configuration/version "2015-07-09", :http.request.configuration/service-id "API Gateway", :http.request.spec/input-spec :portkey.aws.apigateway/delete-deployment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDeployment", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.apigateway/unauthorized-exception, "NotFoundException" :portkey.aws.apigateway/not-found-exception, "BadRequestException" :portkey.aws.apigateway/bad-request-exception, "TooManyRequestsException" :portkey.aws.apigateway/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-deployment :args (clojure.spec.alpha/tuple :portkey.aws.apigateway/delete-deployment-request) :ret clojure.core/true?)
