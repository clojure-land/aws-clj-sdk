(ns portkey.aws.workdocs.-2016-05-01 (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope {:service "workdocs", :region "ap-northeast-1"},
    :ssl-common-name "workdocs.ap-northeast-1.amazonaws.com",
    :endpoint "https://workdocs.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "workdocs", :region "eu-west-1"},
    :ssl-common-name "workdocs.eu-west-1.amazonaws.com",
    :endpoint "https://workdocs.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "workdocs", :region "ap-southeast-2"},
    :ssl-common-name "workdocs.ap-southeast-2.amazonaws.com",
    :endpoint "https://workdocs.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "workdocs", :region "ap-southeast-1"},
    :ssl-common-name "workdocs.ap-southeast-1.amazonaws.com",
    :endpoint "https://workdocs.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "workdocs", :region "us-west-2"},
    :ssl-common-name "workdocs.us-west-2.amazonaws.com",
    :endpoint "https://workdocs.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "workdocs", :region "us-east-1"},
    :ssl-common-name "workdocs.us-east-1.amazonaws.com",
    :endpoint "https://workdocs.us-east-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-resource-id-type)

(clojure.core/declare ser-principal-type)

(clojure.core/declare ser-notification-options)

(clojure.core/declare ser-search-query-type)

(clojure.core/declare ser-marker-type)

(clojure.core/declare ser-positive-size-type)

(clojure.core/declare ser-document-content-type)

(clojure.core/declare ser-locale-type)

(clojure.core/declare ser-activity-names-filter-type)

(clojure.core/declare ser-custom-metadata-value-type)

(clojure.core/declare ser-email-address-type)

(clojure.core/declare ser-user-ids-type)

(clojure.core/declare ser-share-principal-list)

(clojure.core/declare ser-user-type)

(clojure.core/declare ser-username-type)

(clojure.core/declare ser-subscription-protocol-type)

(clojure.core/declare ser-size-type)

(clojure.core/declare ser-comment-visibility-type)

(clojure.core/declare ser-shared-label)

(clojure.core/declare ser-password-type)

(clojure.core/declare ser-user-sort-type)

(clojure.core/declare ser-page-marker-type)

(clojure.core/declare ser-timestamp-type)

(clojure.core/declare ser-subscription-end-point-type)

(clojure.core/declare ser-authentication-header-type)

(clojure.core/declare ser-custom-metadata-key-type)

(clojure.core/declare ser-resource-name-type)

(clojure.core/declare ser-resource-sort-type)

(clojure.core/declare ser-time-zone-id-type)

(clojure.core/declare ser-user-filter-type)

(clojure.core/declare ser-id-type)

(clojure.core/declare ser-subscription-type)

(clojure.core/declare ser-storage-rule-type)

(clojure.core/declare ser-comment-id-type)

(clojure.core/declare ser-resource-state-type)

(clojure.core/declare ser-storage-type)

(clojure.core/declare ser-message-type)

(clojure.core/declare ser-document-version-id-type)

(clojure.core/declare ser-positive-integer-type)

(clojure.core/declare ser-folder-content-type)

(clojure.core/declare ser-limit-type)

(clojure.core/declare ser-field-names-type)

(clojure.core/declare ser-document-version-status)

(clojure.core/declare ser-order-type)

(clojure.core/declare ser-share-principal)

(clojure.core/declare ser-boolean-enum-type)

(clojure.core/declare ser-comment-text-type)

(clojure.core/declare ser-resource-collection-type)

(clojure.core/declare ser-user-attribute-value-type)

(clojure.core/declare ser-custom-metadata-key-list)

(clojure.core/declare ser-shared-labels)

(clojure.core/declare ser-custom-metadata-map)

(clojure.core/declare ser-role-type)

(clojure.core/declare ser-boolean-type)

(clojure.core/defn- ser-resource-id-type [input] #:http.request.field{:value input, :shape "ResourceIdType"})

(clojure.core/defn- ser-principal-type [input] #:http.request.field{:value (clojure.core/get {"USER" "USER", "ORGANIZATION" "ORGANIZATION", :group "GROUP", :organization "ORGANIZATION", "INVITE" "INVITE", :anonymous "ANONYMOUS", :invite "INVITE", "ANONYMOUS" "ANONYMOUS", :user "USER", "GROUP" "GROUP"} input), :shape "PrincipalType"})

(clojure.core/defn- ser-notification-options [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NotificationOptions", :type "structure"} (clojure.core/contains? input :send-email) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :send-email)) #:http.request.field{:name "SendEmail", :shape "BooleanType"})) (clojure.core/contains? input :email-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-type (input :email-message)) #:http.request.field{:name "EmailMessage", :shape "MessageType"}))))

(clojure.core/defn- ser-search-query-type [input] #:http.request.field{:value input, :shape "SearchQueryType"})

(clojure.core/defn- ser-marker-type [input] #:http.request.field{:value input, :shape "MarkerType"})

(clojure.core/defn- ser-positive-size-type [input] #:http.request.field{:value input, :shape "PositiveSizeType"})

(clojure.core/defn- ser-document-content-type [input] #:http.request.field{:value input, :shape "DocumentContentType"})

(clojure.core/defn- ser-locale-type [input] #:http.request.field{:value (clojure.core/get {:fr "fr", :ja "ja", "en" "en", :es "es", "zh_CN" "zh_CN", :default "default", "zh_TW" "zh_TW", :ko "ko", :zh-tw "zh_TW", "fr" "fr", :pt-br "pt_BR", "de" "de", :en "en", "ru" "ru", "es" "es", :de "de", "ja" "ja", :ru "ru", :zh-cn "zh_CN", "ko" "ko", "default" "default", "pt_BR" "pt_BR"} input), :shape "LocaleType"})

(clojure.core/defn- ser-activity-names-filter-type [input] #:http.request.field{:value input, :shape "ActivityNamesFilterType"})

(clojure.core/defn- ser-custom-metadata-value-type [input] #:http.request.field{:value input, :shape "CustomMetadataValueType"})

(clojure.core/defn- ser-email-address-type [input] #:http.request.field{:value input, :shape "EmailAddressType"})

(clojure.core/defn- ser-user-ids-type [input] #:http.request.field{:value input, :shape "UserIdsType"})

(clojure.core/defn- ser-share-principal-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-share-principal coll) #:http.request.field{:shape "SharePrincipal"}))) input), :shape "SharePrincipalList", :type "list"})

(clojure.core/defn- ser-user-type [input] #:http.request.field{:value (clojure.core/get {"MINIMALUSER" "MINIMALUSER", "USER" "USER", :admin "ADMIN", :poweruser "POWERUSER", "POWERUSER" "POWERUSER", :workspacesuser "WORKSPACESUSER", "ADMIN" "ADMIN", :minimaluser "MINIMALUSER", "WORKSPACESUSER" "WORKSPACESUSER", :user "USER"} input), :shape "UserType"})

(clojure.core/defn- ser-username-type [input] #:http.request.field{:value input, :shape "UsernameType"})

(clojure.core/defn- ser-subscription-protocol-type [input] #:http.request.field{:value (clojure.core/get {"HTTPS" "HTTPS", :https "HTTPS"} input), :shape "SubscriptionProtocolType"})

(clojure.core/defn- ser-size-type [input] #:http.request.field{:value input, :shape "SizeType"})

(clojure.core/defn- ser-comment-visibility-type [input] #:http.request.field{:value (clojure.core/get {"PUBLIC" "PUBLIC", :public "PUBLIC", "PRIVATE" "PRIVATE", :private "PRIVATE"} input), :shape "CommentVisibilityType"})

(clojure.core/defn- ser-shared-label [input] #:http.request.field{:value input, :shape "SharedLabel"})

(clojure.core/defn- ser-password-type [input] #:http.request.field{:value input, :shape "PasswordType"})

(clojure.core/defn- ser-user-sort-type [input] #:http.request.field{:value (clojure.core/get {"STORAGE_LIMIT" "STORAGE_LIMIT", :user-status "USER_STATUS", :storage-limit "STORAGE_LIMIT", :user-name "USER_NAME", "USER_STATUS" "USER_STATUS", :storage-used "STORAGE_USED", :full-name "FULL_NAME", "FULL_NAME" "FULL_NAME", "STORAGE_USED" "STORAGE_USED", "USER_NAME" "USER_NAME"} input), :shape "UserSortType"})

(clojure.core/defn- ser-page-marker-type [input] #:http.request.field{:value input, :shape "PageMarkerType"})

(clojure.core/defn- ser-timestamp-type [input] #:http.request.field{:value input, :shape "TimestampType"})

(clojure.core/defn- ser-subscription-end-point-type [input] #:http.request.field{:value input, :shape "SubscriptionEndPointType"})

(clojure.core/defn- ser-authentication-header-type [input] #:http.request.field{:value input, :shape "AuthenticationHeaderType"})

(clojure.core/defn- ser-custom-metadata-key-type [input] #:http.request.field{:value input, :shape "CustomMetadataKeyType"})

(clojure.core/defn- ser-resource-name-type [input] #:http.request.field{:value input, :shape "ResourceNameType"})

(clojure.core/defn- ser-resource-sort-type [input] #:http.request.field{:value (clojure.core/get {"DATE" "DATE", :date "DATE", "NAME" "NAME", :name "NAME"} input), :shape "ResourceSortType"})

(clojure.core/defn- ser-time-zone-id-type [input] #:http.request.field{:value input, :shape "TimeZoneIdType"})

(clojure.core/defn- ser-user-filter-type [input] #:http.request.field{:value (clojure.core/get {"ALL" "ALL", :all "ALL", "ACTIVE_PENDING" "ACTIVE_PENDING", :active-pending "ACTIVE_PENDING"} input), :shape "UserFilterType"})

(clojure.core/defn- ser-id-type [input] #:http.request.field{:value input, :shape "IdType"})

(clojure.core/defn- ser-subscription-type [input] #:http.request.field{:value (clojure.core/get {"ALL" "ALL", :all "ALL"} input), :shape "SubscriptionType"})

(clojure.core/defn- ser-storage-rule-type [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StorageRuleType", :type "structure"} (clojure.core/contains? input :storage-allocated-in-bytes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-positive-size-type (input :storage-allocated-in-bytes)) #:http.request.field{:name "StorageAllocatedInBytes", :shape "PositiveSizeType"})) (clojure.core/contains? input :storage-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-storage-type (input :storage-type)) #:http.request.field{:name "StorageType", :shape "StorageType"}))))

(clojure.core/defn- ser-comment-id-type [input] #:http.request.field{:value input, :shape "CommentIdType"})

(clojure.core/defn- ser-resource-state-type [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE", "RESTORING" "RESTORING", :restoring "RESTORING", "RECYCLING" "RECYCLING", :recycling "RECYCLING", "RECYCLED" "RECYCLED", :recycled "RECYCLED"} input), :shape "ResourceStateType"})

(clojure.core/defn- ser-storage-type [input] #:http.request.field{:value (clojure.core/get {"UNLIMITED" "UNLIMITED", :unlimited "UNLIMITED", "QUOTA" "QUOTA", :quota "QUOTA"} input), :shape "StorageType"})

(clojure.core/defn- ser-message-type [input] #:http.request.field{:value input, :shape "MessageType"})

(clojure.core/defn- ser-document-version-id-type [input] #:http.request.field{:value input, :shape "DocumentVersionIdType"})

(clojure.core/defn- ser-positive-integer-type [input] #:http.request.field{:value input, :shape "PositiveIntegerType"})

(clojure.core/defn- ser-folder-content-type [input] #:http.request.field{:value (clojure.core/get {"ALL" "ALL", :all "ALL", "DOCUMENT" "DOCUMENT", :document "DOCUMENT", "FOLDER" "FOLDER", :folder "FOLDER"} input), :shape "FolderContentType"})

(clojure.core/defn- ser-limit-type [input] #:http.request.field{:value input, :shape "LimitType"})

(clojure.core/defn- ser-field-names-type [input] #:http.request.field{:value input, :shape "FieldNamesType"})

(clojure.core/defn- ser-document-version-status [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE"} input), :shape "DocumentVersionStatus"})

(clojure.core/defn- ser-order-type [input] #:http.request.field{:value (clojure.core/get {"ASCENDING" "ASCENDING", :ascending "ASCENDING", "DESCENDING" "DESCENDING", :descending "DESCENDING"} input), :shape "OrderType"})

(clojure.core/defn- ser-share-principal [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-id-type (:id input)) #:http.request.field{:name "Id", :shape "IdType"}) (clojure.core/into (ser-principal-type (:type input)) #:http.request.field{:name "Type", :shape "PrincipalType"}) (clojure.core/into (ser-role-type (:role input)) #:http.request.field{:name "Role", :shape "RoleType"})], :shape "SharePrincipal", :type "structure"}))

(clojure.core/defn- ser-boolean-enum-type [input] #:http.request.field{:value (clojure.core/get {"TRUE" "TRUE", :true "TRUE", "FALSE" "FALSE", :false "FALSE"} input), :shape "BooleanEnumType"})

(clojure.core/defn- ser-comment-text-type [input] #:http.request.field{:value input, :shape "CommentTextType"})

(clojure.core/defn- ser-resource-collection-type [input] #:http.request.field{:value (clojure.core/get {"SHARED_WITH_ME" "SHARED_WITH_ME", :shared-with-me "SHARED_WITH_ME"} input), :shape "ResourceCollectionType"})

(clojure.core/defn- ser-user-attribute-value-type [input] #:http.request.field{:value input, :shape "UserAttributeValueType"})

(clojure.core/defn- ser-custom-metadata-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-custom-metadata-key-type coll) #:http.request.field{:shape "CustomMetadataKeyType"}))) input), :shape "CustomMetadataKeyList", :type "list", :max 8})

(clojure.core/defn- ser-shared-labels [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-shared-label coll) #:http.request.field{:shape "SharedLabel"}))) input), :shape "SharedLabels", :type "list", :max 20})

(clojure.core/defn- ser-custom-metadata-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-custom-metadata-key-type k) #:http.request.field{:map-info "key", :shape "CustomMetadataKeyType"}) (clojure.core/into (ser-custom-metadata-value-type v) #:http.request.field{:map-info "value", :shape "CustomMetadataValueType"})])) input), :shape "CustomMetadataMap", :type "map", :max 8, :min 1})

(clojure.core/defn- ser-role-type [input] #:http.request.field{:value (clojure.core/get {"VIEWER" "VIEWER", :viewer "VIEWER", "CONTRIBUTOR" "CONTRIBUTOR", :contributor "CONTRIBUTOR", "OWNER" "OWNER", :owner "OWNER", "COOWNER" "COOWNER", :coowner "COOWNER"} input), :shape "RoleType"})

(clojure.core/defn- ser-boolean-type [input] #:http.request.field{:value input, :shape "BooleanType"})

(clojure.core/defn- req-create-comment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"}) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "uri", :location-name "VersionId"})], :body [(clojure.core/into (ser-comment-text-type (input :text)) #:http.request.field{:name "Text", :shape "CommentTextType"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :parent-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment-id-type (input :parent-id)) #:http.request.field{:name "ParentId", :shape "CommentIdType"})) (clojure.core/contains? input :thread-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment-id-type (input :thread-id)) #:http.request.field{:name "ThreadId", :shape "CommentIdType"})) (clojure.core/contains? input :visibility) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment-visibility-type (input :visibility)) #:http.request.field{:name "Visibility", :shape "CommentVisibilityType"})) (clojure.core/contains? input :notify-collaborators) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :notify-collaborators)) #:http.request.field{:name "NotifyCollaborators", :shape "BooleanType"}))))

(clojure.core/defn- req-deactivate-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :user-id)) #:http.request.field{:name "UserId", :shape "IdType", :location "uri", :location-name "UserId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-get-resources-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :user-id)) #:http.request.field{:name "UserId", :shape "IdType", :location "querystring", :location-name "userId"})) (clojure.core/contains? input :collection-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-collection-type (input :collection-type)) #:http.request.field{:name "CollectionType", :shape "ResourceCollectionType", :location "querystring", :location-name "collectionType"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"}))))

(clojure.core/defn- req-update-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :user-id)) #:http.request.field{:name "UserId", :shape "IdType", :location "uri", :location-name "UserId"})]} (clojure.core/contains? input :time-zone-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-time-zone-id-type (input :time-zone-id)) #:http.request.field{:name "TimeZoneId", :shape "TimeZoneIdType"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-type (input :type)) #:http.request.field{:name "Type", :shape "UserType"})) (clojure.core/contains? input :locale) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-locale-type (input :locale)) #:http.request.field{:name "Locale", :shape "LocaleType"})) (clojure.core/contains? input :surname) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-attribute-value-type (input :surname)) #:http.request.field{:name "Surname", :shape "UserAttributeValueType"})) (clojure.core/contains? input :grant-poweruser-privileges) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-enum-type (input :grant-poweruser-privileges)) #:http.request.field{:name "GrantPoweruserPrivileges", :shape "BooleanEnumType"})) (clojure.core/contains? input :given-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-attribute-value-type (input :given-name)) #:http.request.field{:name "GivenName", :shape "UserAttributeValueType"})) (clojure.core/contains? input :storage-rule) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-storage-rule-type (input :storage-rule)) #:http.request.field{:name "StorageRule", :shape "StorageRuleType"})) (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-get-document-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :include-custom-metadata) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :include-custom-metadata)) #:http.request.field{:name "IncludeCustomMetadata", :shape "BooleanType", :location "querystring", :location-name "includeCustomMetadata"}))))

(clojure.core/defn- req-describe-groups-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-search-query-type (input :search-query)) #:http.request.field{:name "SearchQuery", :shape "SearchQueryType", :location "querystring", :location-name "searchQuery"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :organization-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType", :location "querystring", :location-name "organizationId"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "MarkerType", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-positive-integer-type (input :limit)) #:http.request.field{:name "Limit", :shape "PositiveIntegerType", :location "querystring", :location-name "limit"}))))

(clojure.core/defn- req-get-folder-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :folder-id)) #:http.request.field{:name "FolderId", :shape "ResourceIdType", :location "uri", :location-name "FolderId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :include-custom-metadata) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :include-custom-metadata)) #:http.request.field{:name "IncludeCustomMetadata", :shape "BooleanType", :location "querystring", :location-name "includeCustomMetadata"}))))

(clojure.core/defn- req-describe-document-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :include) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :include)) #:http.request.field{:name "Include", :shape "FieldNamesType", :location "querystring", :location-name "include"})) (clojure.core/contains? input :fields) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :fields)) #:http.request.field{:name "Fields", :shape "FieldNamesType", :location "querystring", :location-name "fields"}))))

(clojure.core/defn- req-describe-activities-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp-type (input :end-time)) #:http.request.field{:name "EndTime", :shape "TimestampType", :location "querystring", :location-name "endTime"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp-type (input :start-time)) #:http.request.field{:name "StartTime", :shape "TimestampType", :location "querystring", :location-name "startTime"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :user-id)) #:http.request.field{:name "UserId", :shape "IdType", :location "querystring", :location-name "userId"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "MarkerType", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :organization-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType", :location "querystring", :location-name "organizationId"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :activity-types) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-activity-names-filter-type (input :activity-types)) #:http.request.field{:name "ActivityTypes", :shape "ActivityNamesFilterType", :location "querystring", :location-name "activityTypes"})) (clojure.core/contains? input :resource-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "IdType", :location "querystring", :location-name "resourceId"})) (clojure.core/contains? input :include-indirect-activities) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :include-indirect-activities)) #:http.request.field{:name "IncludeIndirectActivities", :shape "BooleanType", :location "querystring", :location-name "includeIndirectActivities"})) (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-activate-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :user-id)) #:http.request.field{:name "UserId", :shape "IdType", :location "uri", :location-name "UserId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-remove-all-resource-permissions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-get-document-path-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "IdType", :location "uri", :location-name "DocumentId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :fields) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :fields)) #:http.request.field{:name "Fields", :shape "FieldNamesType", :location "querystring", :location-name "fields"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"}))))

(clojure.core/defn- req-delete-comment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"}) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "uri", :location-name "VersionId"}) (clojure.core/into (ser-comment-id-type (input :comment-id)) #:http.request.field{:name "CommentId", :shape "CommentIdType", :location "uri", :location-name "CommentId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-delete-custom-metadata-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :version-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "querystring", :location-name "versionId"})) (clojure.core/contains? input :keys) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-custom-metadata-key-list (input :keys)) #:http.request.field{:name "Keys", :shape "CustomMetadataKeyList", :location "querystring", :location-name "keys"})) (clojure.core/contains? input :delete-all) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :delete-all)) #:http.request.field{:name "DeleteAll", :shape "BooleanType", :location "querystring", :location-name "deleteAll"}))))

(clojure.core/defn- req-add-resource-permissions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})], :body [(clojure.core/into (ser-share-principal-list (input :principals)) #:http.request.field{:name "Principals", :shape "SharePrincipalList"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :notification-options) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-notification-options (input :notification-options)) #:http.request.field{:name "NotificationOptions", :shape "NotificationOptions"}))))

(clojure.core/defn- req-describe-comments-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"}) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "uri", :location-name "VersionId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "MarkerType", :location "querystring", :location-name "marker"}))))

(clojure.core/defn- req-create-notification-subscription-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType", :location "uri", :location-name "OrganizationId"})], :body [(clojure.core/into (ser-subscription-end-point-type (input :endpoint)) #:http.request.field{:name "Endpoint", :shape "SubscriptionEndPointType"}) (clojure.core/into (ser-subscription-protocol-type (input :protocol)) #:http.request.field{:name "Protocol", :shape "SubscriptionProtocolType"}) (clojure.core/into (ser-subscription-type (input :subscription-type)) #:http.request.field{:name "SubscriptionType", :shape "SubscriptionType"})]}))

(clojure.core/defn- req-describe-resource-permissions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :principal-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :principal-id)) #:http.request.field{:name "PrincipalId", :shape "IdType", :location "querystring", :location-name "principalId"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"}))))

(clojure.core/defn- req-create-folder-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-id-type (input :parent-folder-id)) #:http.request.field{:name "ParentFolderId", :shape "ResourceIdType"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name-type (input :name)) #:http.request.field{:name "Name", :shape "ResourceNameType"}))))

(clojure.core/defn- req-update-document-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name-type (input :name)) #:http.request.field{:name "Name", :shape "ResourceNameType"})) (clojure.core/contains? input :parent-folder-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-id-type (input :parent-folder-id)) #:http.request.field{:name "ParentFolderId", :shape "ResourceIdType"})) (clojure.core/contains? input :resource-state) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-state-type (input :resource-state)) #:http.request.field{:name "ResourceState", :shape "ResourceStateType"}))))

(clojure.core/defn- req-remove-resource-permission-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"}) (clojure.core/into (ser-id-type (input :principal-id)) #:http.request.field{:name "PrincipalId", :shape "IdType", :location "uri", :location-name "PrincipalId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :principal-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-principal-type (input :principal-type)) #:http.request.field{:name "PrincipalType", :shape "PrincipalType", :location "querystring", :location-name "type"}))))

(clojure.core/defn- req-get-folder-path-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :folder-id)) #:http.request.field{:name "FolderId", :shape "IdType", :location "uri", :location-name "FolderId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :fields) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :fields)) #:http.request.field{:name "Fields", :shape "FieldNamesType", :location "querystring", :location-name "fields"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"}))))

(clojure.core/defn- req-delete-folder-contents-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :folder-id)) #:http.request.field{:name "FolderId", :shape "ResourceIdType", :location "uri", :location-name "FolderId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-get-current-user-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})]}))

(clojure.core/defn- req-delete-document-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-update-document-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"}) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "uri", :location-name "VersionId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :version-status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-status (input :version-status)) #:http.request.field{:name "VersionStatus", :shape "DocumentVersionStatus"}))))

(clojure.core/defn- req-delete-folder-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :folder-id)) #:http.request.field{:name "FolderId", :shape "ResourceIdType", :location "uri", :location-name "FolderId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-create-user-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-username-type (input :username)) #:http.request.field{:name "Username", :shape "UsernameType"}) (clojure.core/into (ser-user-attribute-value-type (input :given-name)) #:http.request.field{:name "GivenName", :shape "UserAttributeValueType"}) (clojure.core/into (ser-user-attribute-value-type (input :surname)) #:http.request.field{:name "Surname", :shape "UserAttributeValueType"}) (clojure.core/into (ser-password-type (input :password)) #:http.request.field{:name "Password", :shape "PasswordType"})]} (clojure.core/contains? input :time-zone-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-time-zone-id-type (input :time-zone-id)) #:http.request.field{:name "TimeZoneId", :shape "TimeZoneIdType"})) (clojure.core/contains? input :organization-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType"})) (clojure.core/contains? input :storage-rule) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-storage-rule-type (input :storage-rule)) #:http.request.field{:name "StorageRule", :shape "StorageRuleType"})) (clojure.core/contains? input :email-address) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-email-address-type (input :email-address)) #:http.request.field{:name "EmailAddress", :shape "EmailAddressType"})) (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-describe-root-folders-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})]} (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"}))))

(clojure.core/defn- req-create-labels-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})], :body [(clojure.core/into (ser-shared-labels (input :labels)) #:http.request.field{:name "Labels", :shape "SharedLabels"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-delete-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :user-id)) #:http.request.field{:name "UserId", :shape "IdType", :location "uri", :location-name "UserId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-initiate-document-version-upload-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-id-type (input :parent-folder-id)) #:http.request.field{:name "ParentFolderId", :shape "ResourceIdType"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-id-type (input :id)) #:http.request.field{:name "Id", :shape "ResourceIdType"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name-type (input :name)) #:http.request.field{:name "Name", :shape "ResourceNameType"})) (clojure.core/contains? input :content-created-timestamp) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp-type (input :content-created-timestamp)) #:http.request.field{:name "ContentCreatedTimestamp", :shape "TimestampType"})) (clojure.core/contains? input :content-modified-timestamp) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp-type (input :content-modified-timestamp)) #:http.request.field{:name "ContentModifiedTimestamp", :shape "TimestampType"})) (clojure.core/contains? input :content-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-content-type (input :content-type)) #:http.request.field{:name "ContentType", :shape "DocumentContentType"})) (clojure.core/contains? input :document-size-in-bytes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-size-type (input :document-size-in-bytes)) #:http.request.field{:name "DocumentSizeInBytes", :shape "SizeType"}))))

(clojure.core/defn- req-delete-notification-subscription-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :subscription-id)) #:http.request.field{:name "SubscriptionId", :shape "IdType", :location "uri", :location-name "SubscriptionId"}) (clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType", :location "uri", :location-name "OrganizationId"})]}))

(clojure.core/defn- req-create-custom-metadata-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})], :body [(clojure.core/into (ser-custom-metadata-map (input :custom-metadata)) #:http.request.field{:name "CustomMetadata", :shape "CustomMetadataMap"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :version-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "querystring", :location-name "versionid"}))))

(clojure.core/defn- req-describe-folder-contents-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :folder-id)) #:http.request.field{:name "FolderId", :shape "ResourceIdType", :location "uri", :location-name "FolderId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :sort) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-sort-type (input :sort)) #:http.request.field{:name "Sort", :shape "ResourceSortType", :location "querystring", :location-name "sort"})) (clojure.core/contains? input :order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-order-type (input :order)) #:http.request.field{:name "Order", :shape "OrderType", :location "querystring", :location-name "order"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-folder-content-type (input :type)) #:http.request.field{:name "Type", :shape "FolderContentType", :location "querystring", :location-name "type"})) (clojure.core/contains? input :include) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :include)) #:http.request.field{:name "Include", :shape "FieldNamesType", :location "querystring", :location-name "include"}))))

(clojure.core/defn- req-update-folder-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :folder-id)) #:http.request.field{:name "FolderId", :shape "ResourceIdType", :location "uri", :location-name "FolderId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-name-type (input :name)) #:http.request.field{:name "Name", :shape "ResourceNameType"})) (clojure.core/contains? input :parent-folder-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-id-type (input :parent-folder-id)) #:http.request.field{:name "ParentFolderId", :shape "ResourceIdType"})) (clojure.core/contains? input :resource-state) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-state-type (input :resource-state)) #:http.request.field{:name "ResourceState", :shape "ResourceStateType"}))))

(clojure.core/defn- req-delete-labels-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :resource-id)) #:http.request.field{:name "ResourceId", :shape "ResourceIdType", :location "uri", :location-name "ResourceId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :labels) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-shared-labels (input :labels)) #:http.request.field{:name "Labels", :shape "SharedLabels", :location "querystring", :location-name "labels"})) (clojure.core/contains? input :delete-all) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :delete-all)) #:http.request.field{:name "DeleteAll", :shape "BooleanType", :location "querystring", :location-name "deleteAll"}))))

(clojure.core/defn- req-describe-users-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :user-ids) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-ids-type (input :user-ids)) #:http.request.field{:name "UserIds", :shape "UserIdsType", :location "querystring", :location-name "userIds"})) (clojure.core/contains? input :sort) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-sort-type (input :sort)) #:http.request.field{:name "Sort", :shape "UserSortType", :location "querystring", :location-name "sort"})) (clojure.core/contains? input :order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-order-type (input :order)) #:http.request.field{:name "Order", :shape "OrderType", :location "querystring", :location-name "order"})) (clojure.core/contains? input :fields) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :fields)) #:http.request.field{:name "Fields", :shape "FieldNamesType", :location "querystring", :location-name "fields"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :organization-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType", :location "querystring", :location-name "organizationId"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"})) (clojure.core/contains? input :query) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-search-query-type (input :query)) #:http.request.field{:name "Query", :shape "SearchQueryType", :location "querystring", :location-name "query"})) (clojure.core/contains? input :include) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-filter-type (input :include)) #:http.request.field{:name "Include", :shape "UserFilterType", :location "querystring", :location-name "include"})) (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-get-document-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"}) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "uri", :location-name "VersionId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"})) (clojure.core/contains? input :fields) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-field-names-type (input :fields)) #:http.request.field{:name "Fields", :shape "FieldNamesType", :location "querystring", :location-name "fields"})) (clojure.core/contains? input :include-custom-metadata) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-type (input :include-custom-metadata)) #:http.request.field{:name "IncludeCustomMetadata", :shape "BooleanType", :location "querystring", :location-name "includeCustomMetadata"}))))

(clojure.core/defn- req-abort-document-version-upload-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-resource-id-type (input :document-id)) #:http.request.field{:name "DocumentId", :shape "ResourceIdType", :location "uri", :location-name "DocumentId"}) (clojure.core/into (ser-document-version-id-type (input :version-id)) #:http.request.field{:name "VersionId", :shape "DocumentVersionIdType", :location "uri", :location-name "VersionId"})]} (clojure.core/contains? input :authentication-token) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authentication-header-type (input :authentication-token)) #:http.request.field{:name "AuthenticationToken", :shape "AuthenticationHeaderType", :location "header", :location-name "Authentication"}))))

(clojure.core/defn- req-describe-notification-subscriptions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-id-type (input :organization-id)) #:http.request.field{:name "OrganizationId", :shape "IdType", :location "uri", :location-name "OrganizationId"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-marker-type (input :marker)) #:http.request.field{:name "Marker", :shape "PageMarkerType", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :limit) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-limit-type (input :limit)) #:http.request.field{:name "Limit", :shape "LimitType", :location "querystring", :location-name "limit"}))))

(clojure.core/declare deser-document-source-url-map)

(clojure.core/declare deser-resource-id-type)

(clojure.core/declare deser-principal-type)

(clojure.core/declare deser-folder-metadata)

(clojure.core/declare deser-resource-path-component)

(clojure.core/declare deser-role-permission-type)

(clojure.core/declare deser-group-metadata-list)

(clojure.core/declare deser-document-status-type)

(clojure.core/declare deser-document-metadata)

(clojure.core/declare deser-comment)

(clojure.core/declare deser-marker-type)

(clojure.core/declare deser-group-metadata)

(clojure.core/declare deser-resource-path-component-list)

(clojure.core/declare deser-positive-size-type)

(clojure.core/declare deser-document-content-type)

(clojure.core/declare deser-locale-type)

(clojure.core/declare deser-user-metadata-list)

(clojure.core/declare deser-custom-metadata-value-type)

(clojure.core/declare deser-resource-metadata)

(clojure.core/declare deser-user-activities)

(clojure.core/declare deser-email-address-type)

(clojure.core/declare deser-signed-header-map)

(clojure.core/declare deser-user-type)

(clojure.core/declare deser-comment-status-type)

(clojure.core/declare deser-activity)

(clojure.core/declare deser-user)

(clojure.core/declare deser-comment-list)

(clojure.core/declare deser-document-source-type)

(clojure.core/declare deser-username-type)

(clojure.core/declare deser-folder-metadata-list)

(clojure.core/declare deser-subscription-protocol-type)

(clojure.core/declare deser-document-version-metadata)

(clojure.core/declare deser-share-status-type)

(clojure.core/declare deser-size-type)

(clojure.core/declare deser-group-name-type)

(clojure.core/declare deser-error-message-type)

(clojure.core/declare deser-comment-visibility-type)

(clojure.core/declare deser-user-metadata)

(clojure.core/declare deser-principal-list)

(clojure.core/declare deser-url-type)

(clojure.core/declare deser-organization-user-list)

(clojure.core/declare deser-shared-label)

(clojure.core/declare deser-upload-metadata)

(clojure.core/declare deser-activity-type)

(clojure.core/declare deser-user-status-type)

(clojure.core/declare deser-page-marker-type)

(clojure.core/declare deser-timestamp-type)

(clojure.core/declare deser-subscription-list)

(clojure.core/declare deser-subscription-end-point-type)

(clojure.core/declare deser-document-thumbnail-type)

(clojure.core/declare deser-participants)

(clojure.core/declare deser-custom-metadata-key-type)

(clojure.core/declare deser-resource-name-type)

(clojure.core/declare deser-time-zone-id-type)

(clojure.core/declare deser-id-type)

(clojure.core/declare deser-storage-rule-type)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-comment-id-type)

(clojure.core/declare deser-resource-state-type)

(clojure.core/declare deser-resource-path)

(clojure.core/declare deser-storage-type)

(clojure.core/declare deser-document-version-metadata-list)

(clojure.core/declare deser-message-type)

(clojure.core/declare deser-document-metadata-list)

(clojure.core/declare deser-document-version-id-type)

(clojure.core/declare deser-subscription)

(clojure.core/declare deser-hash-type)

(clojure.core/declare deser-permission-info)

(clojure.core/declare deser-document-thumbnail-url-map)

(clojure.core/declare deser-permission-info-list)

(clojure.core/declare deser-header-name-type)

(clojure.core/declare deser-entity-id-list)

(clojure.core/declare deser-share-result)

(clojure.core/declare deser-principal)

(clojure.core/declare deser-comment-text-type)

(clojure.core/declare deser-user-attribute-value-type)

(clojure.core/declare deser-shared-labels)

(clojure.core/declare deser-share-results-list)

(clojure.core/declare deser-user-storage-metadata)

(clojure.core/declare deser-custom-metadata-map)

(clojure.core/declare deser-comment-metadata)

(clojure.core/declare deser-role-type)

(clojure.core/declare deser-header-value-type)

(clojure.core/declare deser-boolean-type)

(clojure.core/defn- deser-document-source-url-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-document-source-type k) (deser-url-type v)])) input))

(clojure.core/defn- deser-resource-id-type [input] input)

(clojure.core/defn- deser-principal-type [input] (clojure.core/get {"USER" :user, "GROUP" :group, "INVITE" :invite, "ANONYMOUS" :anonymous, "ORGANIZATION" :organization} input))

(clojure.core/defn- deser-folder-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "CreatedTimestamp") (clojure.core/assoc :created-timestamp (deser-timestamp-type (input "CreatedTimestamp"))) (clojure.core/contains? input "ParentFolderId") (clojure.core/assoc :parent-folder-id (deser-resource-id-type (input "ParentFolderId"))) (clojure.core/contains? input "ModifiedTimestamp") (clojure.core/assoc :modified-timestamp (deser-timestamp-type (input "ModifiedTimestamp"))) (clojure.core/contains? input "LatestVersionSize") (clojure.core/assoc :latest-version-size (deser-size-type (input "LatestVersionSize"))) (clojure.core/contains? input "Signature") (clojure.core/assoc :signature (deser-hash-type (input "Signature"))) (clojure.core/contains? input "Labels") (clojure.core/assoc :labels (deser-shared-labels (input "Labels"))) (clojure.core/contains? input "Size") (clojure.core/assoc :size (deser-size-type (input "Size"))) (clojure.core/contains? input "CreatorId") (clojure.core/assoc :creator-id (deser-id-type (input "CreatorId"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-resource-name-type (input "Name"))) (clojure.core/contains? input "ResourceState") (clojure.core/assoc :resource-state (deser-resource-state-type (input "ResourceState"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-resource-id-type (input "Id")))))

(clojure.core/defn- deser-resource-path-component [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-id-type (input "Id"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-resource-name-type (input "Name")))))

(clojure.core/defn- deser-role-permission-type [input] (clojure.core/get {"DIRECT" :direct, "INHERITED" :inherited} input))

(clojure.core/defn- deser-group-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-metadata coll))) input))

(clojure.core/defn- deser-document-status-type [input] (clojure.core/get {"INITIALIZED" :initialized, "ACTIVE" :active} input))

(clojure.core/defn- deser-document-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-resource-id-type (input "Id"))) (clojure.core/contains? input "CreatorId") (clojure.core/assoc :creator-id (deser-id-type (input "CreatorId"))) (clojure.core/contains? input "ParentFolderId") (clojure.core/assoc :parent-folder-id (deser-resource-id-type (input "ParentFolderId"))) (clojure.core/contains? input "CreatedTimestamp") (clojure.core/assoc :created-timestamp (deser-timestamp-type (input "CreatedTimestamp"))) (clojure.core/contains? input "ModifiedTimestamp") (clojure.core/assoc :modified-timestamp (deser-timestamp-type (input "ModifiedTimestamp"))) (clojure.core/contains? input "LatestVersionMetadata") (clojure.core/assoc :latest-version-metadata (deser-document-version-metadata (input "LatestVersionMetadata"))) (clojure.core/contains? input "ResourceState") (clojure.core/assoc :resource-state (deser-resource-state-type (input "ResourceState"))) (clojure.core/contains? input "Labels") (clojure.core/assoc :labels (deser-shared-labels (input "Labels")))))

(clojure.core/defn- deser-comment [input] (clojure.core/cond-> {:comment-id (deser-comment-id-type (input "CommentId"))} (clojure.core/contains? input "RecipientId") (clojure.core/assoc :recipient-id (deser-id-type (input "RecipientId"))) (clojure.core/contains? input "CreatedTimestamp") (clojure.core/assoc :created-timestamp (deser-timestamp-type (input "CreatedTimestamp"))) (clojure.core/contains? input "Visibility") (clojure.core/assoc :visibility (deser-comment-visibility-type (input "Visibility"))) (clojure.core/contains? input "ParentId") (clojure.core/assoc :parent-id (deser-comment-id-type (input "ParentId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-comment-status-type (input "Status"))) (clojure.core/contains? input "ThreadId") (clojure.core/assoc :thread-id (deser-comment-id-type (input "ThreadId"))) (clojure.core/contains? input "Text") (clojure.core/assoc :text (deser-comment-text-type (input "Text"))) (clojure.core/contains? input "Contributor") (clojure.core/assoc :contributor (deser-user (input "Contributor")))))

(clojure.core/defn- deser-marker-type [input] input)

(clojure.core/defn- deser-group-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-id-type (input "Id"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-group-name-type (input "Name")))))

(clojure.core/defn- deser-resource-path-component-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource-path-component coll))) input))

(clojure.core/defn- deser-positive-size-type [input] input)

(clojure.core/defn- deser-document-content-type [input] input)

(clojure.core/defn- deser-locale-type [input] (clojure.core/get {"en" :en, "zh_CN" :zh-cn, "zh_TW" :zh-tw, "fr" :fr, "de" :de, "ru" :ru, "es" :es, "ja" :ja, "ko" :ko, "default" :default, "pt_BR" :pt-br} input))

(clojure.core/defn- deser-user-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-user-metadata coll))) input))

(clojure.core/defn- deser-custom-metadata-value-type [input] input)

(clojure.core/defn- deser-resource-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-resource-type (input "Type"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-resource-name-type (input "Name"))) (clojure.core/contains? input "OriginalName") (clojure.core/assoc :original-name (deser-resource-name-type (input "OriginalName"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-resource-id-type (input "Id"))) (clojure.core/contains? input "VersionId") (clojure.core/assoc :version-id (deser-document-version-id-type (input "VersionId"))) (clojure.core/contains? input "Owner") (clojure.core/assoc :owner (deser-user-metadata (input "Owner"))) (clojure.core/contains? input "ParentId") (clojure.core/assoc :parent-id (deser-resource-id-type (input "ParentId")))))

(clojure.core/defn- deser-user-activities [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-activity coll))) input))

(clojure.core/defn- deser-email-address-type [input] input)

(clojure.core/defn- deser-signed-header-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-header-name-type k) (deser-header-value-type v)])) input))

(clojure.core/defn- deser-user-type [input] (clojure.core/get {"USER" :user, "ADMIN" :admin, "POWERUSER" :poweruser, "MINIMALUSER" :minimaluser, "WORKSPACESUSER" :workspacesuser} input))

(clojure.core/defn- deser-comment-status-type [input] (clojure.core/get {"DRAFT" :draft, "PUBLISHED" :published, "DELETED" :deleted} input))

(clojure.core/defn- deser-activity [input] (clojure.core/cond-> {} (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-activity-type (input "Type"))) (clojure.core/contains? input "ResourceMetadata") (clojure.core/assoc :resource-metadata (deser-resource-metadata (input "ResourceMetadata"))) (clojure.core/contains? input "OrganizationId") (clojure.core/assoc :organization-id (deser-id-type (input "OrganizationId"))) (clojure.core/contains? input "OriginalParent") (clojure.core/assoc :original-parent (deser-resource-metadata (input "OriginalParent"))) (clojure.core/contains? input "IsIndirectActivity") (clojure.core/assoc :is-indirect-activity (deser-boolean-type (input "IsIndirectActivity"))) (clojure.core/contains? input "Participants") (clojure.core/assoc :participants (deser-participants (input "Participants"))) (clojure.core/contains? input "Initiator") (clojure.core/assoc :initiator (deser-user-metadata (input "Initiator"))) (clojure.core/contains? input "TimeStamp") (clojure.core/assoc :time-stamp (deser-timestamp-type (input "TimeStamp"))) (clojure.core/contains? input "CommentMetadata") (clojure.core/assoc :comment-metadata (deser-comment-metadata (input "CommentMetadata")))))

(clojure.core/defn- deser-user [input] (clojure.core/cond-> {} (clojure.core/contains? input "Username") (clojure.core/assoc :username (deser-username-type (input "Username"))) (clojure.core/contains? input "Storage") (clojure.core/assoc :storage (deser-user-storage-metadata (input "Storage"))) (clojure.core/contains? input "CreatedTimestamp") (clojure.core/assoc :created-timestamp (deser-timestamp-type (input "CreatedTimestamp"))) (clojure.core/contains? input "TimeZoneId") (clojure.core/assoc :time-zone-id (deser-time-zone-id-type (input "TimeZoneId"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-user-type (input "Type"))) (clojure.core/contains? input "Locale") (clojure.core/assoc :locale (deser-locale-type (input "Locale"))) (clojure.core/contains? input "Surname") (clojure.core/assoc :surname (deser-user-attribute-value-type (input "Surname"))) (clojure.core/contains? input "RecycleBinFolderId") (clojure.core/assoc :recycle-bin-folder-id (deser-resource-id-type (input "RecycleBinFolderId"))) (clojure.core/contains? input "OrganizationId") (clojure.core/assoc :organization-id (deser-id-type (input "OrganizationId"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-user-status-type (input "Status"))) (clojure.core/contains? input "ModifiedTimestamp") (clojure.core/assoc :modified-timestamp (deser-timestamp-type (input "ModifiedTimestamp"))) (clojure.core/contains? input "GivenName") (clojure.core/assoc :given-name (deser-user-attribute-value-type (input "GivenName"))) (clojure.core/contains? input "RootFolderId") (clojure.core/assoc :root-folder-id (deser-resource-id-type (input "RootFolderId"))) (clojure.core/contains? input "EmailAddress") (clojure.core/assoc :email-address (deser-email-address-type (input "EmailAddress"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-id-type (input "Id")))))

(clojure.core/defn- deser-comment-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-comment coll))) input))

(clojure.core/defn- deser-document-source-type [input] (clojure.core/get {"ORIGINAL" :original, "WITH_COMMENTS" :with-comments} input))

(clojure.core/defn- deser-username-type [input] input)

(clojure.core/defn- deser-folder-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-folder-metadata coll))) input))

(clojure.core/defn- deser-subscription-protocol-type [input] (clojure.core/get {"HTTPS" :https} input))

(clojure.core/defn- deser-document-version-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "CreatedTimestamp") (clojure.core/assoc :created-timestamp (deser-timestamp-type (input "CreatedTimestamp"))) (clojure.core/contains? input "Source") (clojure.core/assoc :source (deser-document-source-url-map (input "Source"))) (clojure.core/contains? input "ContentModifiedTimestamp") (clojure.core/assoc :content-modified-timestamp (deser-timestamp-type (input "ContentModifiedTimestamp"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-document-status-type (input "Status"))) (clojure.core/contains? input "ModifiedTimestamp") (clojure.core/assoc :modified-timestamp (deser-timestamp-type (input "ModifiedTimestamp"))) (clojure.core/contains? input "ContentType") (clojure.core/assoc :content-type (deser-document-content-type (input "ContentType"))) (clojure.core/contains? input "Signature") (clojure.core/assoc :signature (deser-hash-type (input "Signature"))) (clojure.core/contains? input "ContentCreatedTimestamp") (clojure.core/assoc :content-created-timestamp (deser-timestamp-type (input "ContentCreatedTimestamp"))) (clojure.core/contains? input "Thumbnail") (clojure.core/assoc :thumbnail (deser-document-thumbnail-url-map (input "Thumbnail"))) (clojure.core/contains? input "Size") (clojure.core/assoc :size (deser-size-type (input "Size"))) (clojure.core/contains? input "CreatorId") (clojure.core/assoc :creator-id (deser-id-type (input "CreatorId"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-resource-name-type (input "Name"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-document-version-id-type (input "Id")))))

(clojure.core/defn- deser-share-status-type [input] (clojure.core/get {"SUCCESS" :success, "FAILURE" :failure} input))

(clojure.core/defn- deser-size-type [input] input)

(clojure.core/defn- deser-group-name-type [input] input)

(clojure.core/defn- deser-error-message-type [input] input)

(clojure.core/defn- deser-comment-visibility-type [input] (clojure.core/get {"PUBLIC" :public, "PRIVATE" :private} input))

(clojure.core/defn- deser-user-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-id-type (input "Id"))) (clojure.core/contains? input "Username") (clojure.core/assoc :username (deser-username-type (input "Username"))) (clojure.core/contains? input "GivenName") (clojure.core/assoc :given-name (deser-user-attribute-value-type (input "GivenName"))) (clojure.core/contains? input "Surname") (clojure.core/assoc :surname (deser-user-attribute-value-type (input "Surname"))) (clojure.core/contains? input "EmailAddress") (clojure.core/assoc :email-address (deser-email-address-type (input "EmailAddress")))))

(clojure.core/defn- deser-principal-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-principal coll))) input))

(clojure.core/defn- deser-url-type [input] input)

(clojure.core/defn- deser-organization-user-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-user coll))) input))

(clojure.core/defn- deser-shared-label [input] input)

(clojure.core/defn- deser-upload-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "UploadUrl") (clojure.core/assoc :upload-url (deser-url-type (input "UploadUrl"))) (clojure.core/contains? input "SignedHeaders") (clojure.core/assoc :signed-headers (deser-signed-header-map (input "SignedHeaders")))))

(clojure.core/defn- deser-activity-type [input] (clojure.core/get {"DOCUMENT_REVERTED" :document-reverted, "FOLDER_SHAREABLE_LINK_CREATED" :folder-shareable-link-created, "DOCUMENT_SHARE_PERMISSION_CHANGED" :document-share-permission-changed, "DOCUMENT_SHAREABLE_LINK_REMOVED" :document-shareable-link-removed, "FOLDER_RESTORED" :folder-restored, "FOLDER_SHAREABLE_LINK_REMOVED" :folder-shareable-link-removed, "DOCUMENT_COMMENT_DELETED" :document-comment-deleted, "FOLDER_RECYCLED" :folder-recycled, "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED" :document-shareable-link-permission-changed, "DOCUMENT_RESTORED" :document-restored, "DOCUMENT_UNSHARED" :document-unshared, "DOCUMENT_ANNOTATION_DELETED" :document-annotation-deleted, "DOCUMENT_RENAMED" :document-renamed, "FOLDER_CREATED" :folder-created, "FOLDER_MOVED" :folder-moved, "FOLDER_DELETED" :folder-deleted, "FOLDER_RENAMED" :folder-renamed, "DOCUMENT_SHARED" :document-shared, "FOLDER_SHARE_PERMISSION_CHANGED" :folder-share-permission-changed, "DOCUMENT_ANNOTATION_ADDED" :document-annotation-added, "DOCUMENT_VERSION_UPLOADED" :document-version-uploaded, "DOCUMENT_COMMENT_ADDED" :document-comment-added, "DOCUMENT_SHAREABLE_LINK_CREATED" :document-shareable-link-created, "DOCUMENT_VERSION_DOWNLOADED" :document-version-downloaded, "FOLDER_SHARED" :folder-shared, "DOCUMENT_VERSION_DELETED" :document-version-deleted, "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED" :folder-shareable-link-permission-changed, "DOCUMENT_CHECKED_IN" :document-checked-in, "FOLDER_UNSHARED" :folder-unshared, "DOCUMENT_RECYCLED" :document-recycled, "DOCUMENT_MOVED" :document-moved, "DOCUMENT_CHECKED_OUT" :document-checked-out, "DOCUMENT_VERSION_VIEWED" :document-version-viewed} input))

(clojure.core/defn- deser-user-status-type [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive, "PENDING" :pending} input))

(clojure.core/defn- deser-page-marker-type [input] input)

(clojure.core/defn- deser-timestamp-type [input] input)

(clojure.core/defn- deser-subscription-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-subscription coll))) input))

(clojure.core/defn- deser-subscription-end-point-type [input] input)

(clojure.core/defn- deser-document-thumbnail-type [input] (clojure.core/get {"SMALL" :small, "SMALL_HQ" :small-hq, "LARGE" :large} input))

(clojure.core/defn- deser-participants [input] (clojure.core/cond-> {} (clojure.core/contains? input "Users") (clojure.core/assoc :users (deser-user-metadata-list (input "Users"))) (clojure.core/contains? input "Groups") (clojure.core/assoc :groups (deser-group-metadata-list (input "Groups")))))

(clojure.core/defn- deser-custom-metadata-key-type [input] input)

(clojure.core/defn- deser-resource-name-type [input] input)

(clojure.core/defn- deser-time-zone-id-type [input] input)

(clojure.core/defn- deser-id-type [input] input)

(clojure.core/defn- deser-storage-rule-type [input] (clojure.core/cond-> {} (clojure.core/contains? input "StorageAllocatedInBytes") (clojure.core/assoc :storage-allocated-in-bytes (deser-positive-size-type (input "StorageAllocatedInBytes"))) (clojure.core/contains? input "StorageType") (clojure.core/assoc :storage-type (deser-storage-type (input "StorageType")))))

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"FOLDER" :folder, "DOCUMENT" :document} input))

(clojure.core/defn- deser-comment-id-type [input] input)

(clojure.core/defn- deser-resource-state-type [input] (clojure.core/get {"ACTIVE" :active, "RESTORING" :restoring, "RECYCLING" :recycling, "RECYCLED" :recycled} input))

(clojure.core/defn- deser-resource-path [input] (clojure.core/cond-> {} (clojure.core/contains? input "Components") (clojure.core/assoc :components (deser-resource-path-component-list (input "Components")))))

(clojure.core/defn- deser-storage-type [input] (clojure.core/get {"UNLIMITED" :unlimited, "QUOTA" :quota} input))

(clojure.core/defn- deser-document-version-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-version-metadata coll))) input))

(clojure.core/defn- deser-message-type [input] input)

(clojure.core/defn- deser-document-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-document-metadata coll))) input))

(clojure.core/defn- deser-document-version-id-type [input] input)

(clojure.core/defn- deser-subscription [input] (clojure.core/cond-> {} (clojure.core/contains? input "SubscriptionId") (clojure.core/assoc :subscription-id (deser-id-type (input "SubscriptionId"))) (clojure.core/contains? input "EndPoint") (clojure.core/assoc :end-point (deser-subscription-end-point-type (input "EndPoint"))) (clojure.core/contains? input "Protocol") (clojure.core/assoc :protocol (deser-subscription-protocol-type (input "Protocol")))))

(clojure.core/defn- deser-hash-type [input] input)

(clojure.core/defn- deser-permission-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "Role") (clojure.core/assoc :role (deser-role-type (input "Role"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-role-permission-type (input "Type")))))

(clojure.core/defn- deser-document-thumbnail-url-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-document-thumbnail-type k) (deser-url-type v)])) input))

(clojure.core/defn- deser-permission-info-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-permission-info coll))) input))

(clojure.core/defn- deser-header-name-type [input] input)

(clojure.core/defn- deser-entity-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-id-type coll))) input))

(clojure.core/defn- deser-share-result [input] (clojure.core/cond-> {} (clojure.core/contains? input "PrincipalId") (clojure.core/assoc :principal-id (deser-id-type (input "PrincipalId"))) (clojure.core/contains? input "InviteePrincipalId") (clojure.core/assoc :invitee-principal-id (deser-id-type (input "InviteePrincipalId"))) (clojure.core/contains? input "Role") (clojure.core/assoc :role (deser-role-type (input "Role"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-share-status-type (input "Status"))) (clojure.core/contains? input "ShareId") (clojure.core/assoc :share-id (deser-resource-id-type (input "ShareId"))) (clojure.core/contains? input "StatusMessage") (clojure.core/assoc :status-message (deser-message-type (input "StatusMessage")))))

(clojure.core/defn- deser-principal [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-id-type (input "Id"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-principal-type (input "Type"))) (clojure.core/contains? input "Roles") (clojure.core/assoc :roles (deser-permission-info-list (input "Roles")))))

(clojure.core/defn- deser-comment-text-type [input] input)

(clojure.core/defn- deser-user-attribute-value-type [input] input)

(clojure.core/defn- deser-shared-labels [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-shared-label coll))) input))

(clojure.core/defn- deser-share-results-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-share-result coll))) input))

(clojure.core/defn- deser-user-storage-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "StorageUtilizedInBytes") (clojure.core/assoc :storage-utilized-in-bytes (deser-size-type (input "StorageUtilizedInBytes"))) (clojure.core/contains? input "StorageRule") (clojure.core/assoc :storage-rule (deser-storage-rule-type (input "StorageRule")))))

(clojure.core/defn- deser-custom-metadata-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-custom-metadata-key-type k) (deser-custom-metadata-value-type v)])) input))

(clojure.core/defn- deser-comment-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "CommentId") (clojure.core/assoc :comment-id (deser-comment-id-type (input "CommentId"))) (clojure.core/contains? input "Contributor") (clojure.core/assoc :contributor (deser-user (input "Contributor"))) (clojure.core/contains? input "CreatedTimestamp") (clojure.core/assoc :created-timestamp (deser-timestamp-type (input "CreatedTimestamp"))) (clojure.core/contains? input "CommentStatus") (clojure.core/assoc :comment-status (deser-comment-status-type (input "CommentStatus"))) (clojure.core/contains? input "RecipientId") (clojure.core/assoc :recipient-id (deser-id-type (input "RecipientId")))))

(clojure.core/defn- deser-role-type [input] (clojure.core/get {"VIEWER" :viewer, "CONTRIBUTOR" :contributor, "OWNER" :owner, "COOWNER" :coowner} input))

(clojure.core/defn- deser-header-value-type [input] input)

(clojure.core/defn- deser-boolean-type [input] input)

(clojure.core/defn- response-create-user-response ([input] (response-create-user-response nil input)) ([resultWrapper1475584 input] (clojure.core/let [rawinput1475583 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475585 {"User" (rawinput1475583 "User")}] (clojure.core/cond-> {} (letvar1475585 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar1475585 ["User"])))))))

(clojure.core/defn- response-deactivating-last-system-user-exception ([input] (response-deactivating-last-system-user-exception nil input)) ([resultWrapper1475587 input] (clojure.core/let [rawinput1475586 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475588 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-folder-path-response ([input] (response-get-folder-path-response nil input)) ([resultWrapper1475590 input] (clojure.core/let [rawinput1475589 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475591 {"Path" (rawinput1475589 "Path")}] (clojure.core/cond-> {} (letvar1475591 "Path") (clojure.core/assoc :path (deser-resource-path (clojure.core/get-in letvar1475591 ["Path"])))))))

(clojure.core/defn- response-get-document-version-response ([input] (response-get-document-version-response nil input)) ([resultWrapper1475593 input] (clojure.core/let [rawinput1475592 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475594 {"Metadata" (rawinput1475592 "Metadata"), "CustomMetadata" (rawinput1475592 "CustomMetadata")}] (clojure.core/cond-> {} (letvar1475594 "Metadata") (clojure.core/assoc :metadata (deser-document-version-metadata (clojure.core/get-in letvar1475594 ["Metadata"]))) (letvar1475594 "CustomMetadata") (clojure.core/assoc :custom-metadata (deser-custom-metadata-map (clojure.core/get-in letvar1475594 ["CustomMetadata"])))))))

(clojure.core/defn- response-create-folder-response ([input] (response-create-folder-response nil input)) ([resultWrapper1475596 input] (clojure.core/let [rawinput1475595 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475597 {"Metadata" (rawinput1475595 "Metadata")}] (clojure.core/cond-> {} (letvar1475597 "Metadata") (clojure.core/assoc :metadata (deser-folder-metadata (clojure.core/get-in letvar1475597 ["Metadata"])))))))

(clojure.core/defn- response-add-resource-permissions-response ([input] (response-add-resource-permissions-response nil input)) ([resultWrapper1475599 input] (clojure.core/let [rawinput1475598 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475600 {"ShareResults" (rawinput1475598 "ShareResults")}] (clojure.core/cond-> {} (letvar1475600 "ShareResults") (clojure.core/assoc :share-results (deser-share-results-list (clojure.core/get-in letvar1475600 ["ShareResults"])))))))

(clojure.core/defn- response-create-custom-metadata-response ([input] (response-create-custom-metadata-response nil input)) ([resultWrapper1475602 input] (clojure.core/let [rawinput1475601 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475603 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-comments-response ([input] (response-describe-comments-response nil input)) ([resultWrapper1475605 input] (clojure.core/let [rawinput1475604 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475606 {"Comments" (rawinput1475604 "Comments"), "Marker" (rawinput1475604 "Marker")}] (clojure.core/cond-> {} (letvar1475606 "Comments") (clojure.core/assoc :comments (deser-comment-list (clojure.core/get-in letvar1475606 ["Comments"]))) (letvar1475606 "Marker") (clojure.core/assoc :marker (deser-marker-type (clojure.core/get-in letvar1475606 ["Marker"])))))))

(clojure.core/defn- response-describe-groups-response ([input] (response-describe-groups-response nil input)) ([resultWrapper1475608 input] (clojure.core/let [rawinput1475607 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475609 {"Groups" (rawinput1475607 "Groups"), "Marker" (rawinput1475607 "Marker")}] (clojure.core/cond-> {} (letvar1475609 "Groups") (clojure.core/assoc :groups (deser-group-metadata-list (clojure.core/get-in letvar1475609 ["Groups"]))) (letvar1475609 "Marker") (clojure.core/assoc :marker (deser-marker-type (clojure.core/get-in letvar1475609 ["Marker"])))))))

(clojure.core/defn- response-entity-not-exists-exception ([input] (response-entity-not-exists-exception nil input)) ([resultWrapper1475611 input] (clojure.core/let [rawinput1475610 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475612 {"Message" (rawinput1475610 "Message"), "EntityIds" (rawinput1475610 "EntityIds")}] (clojure.core/cond-> {} (letvar1475612 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475612 ["Message"]))) (letvar1475612 "EntityIds") (clojure.core/assoc :entity-ids (deser-entity-id-list (clojure.core/get-in letvar1475612 ["EntityIds"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper1475614 input] (clojure.core/let [rawinput1475613 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475615 {"Message" (rawinput1475613 "Message")}] (clojure.core/cond-> {} (letvar1475615 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475615 ["Message"])))))))

(clojure.core/defn- response-failed-dependency-exception ([input] (response-failed-dependency-exception nil input)) ([resultWrapper1475617 input] (clojure.core/let [rawinput1475616 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475618 {"Message" (rawinput1475616 "Message")}] (clojure.core/cond-> {} (letvar1475618 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475618 ["Message"])))))))

(clojure.core/defn- response-too-many-labels-exception ([input] (response-too-many-labels-exception nil input)) ([resultWrapper1475620 input] (clojure.core/let [rawinput1475619 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475621 {"Message" (rawinput1475619 "Message")}] (clojure.core/cond-> {} (letvar1475621 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475621 ["Message"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper1475623 input] (clojure.core/let [rawinput1475622 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475624 {"Message" (rawinput1475622 "Message")}] (clojure.core/cond-> {} (letvar1475624 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475624 ["Message"])))))))

(clojure.core/defn- response-invalid-password-exception ([input] (response-invalid-password-exception nil input)) ([resultWrapper1475626 input] (clojure.core/let [rawinput1475625 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475627 {"Message" (rawinput1475625 "Message")}] (clojure.core/cond-> {} (letvar1475627 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475627 ["Message"])))))))

(clojure.core/defn- response-invalid-comment-operation-exception ([input] (response-invalid-comment-operation-exception nil input)) ([resultWrapper1475629 input] (clojure.core/let [rawinput1475628 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475630 {"Message" (rawinput1475628 "Message")}] (clojure.core/cond-> {} (letvar1475630 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475630 ["Message"])))))))

(clojure.core/defn- response-custom-metadata-limit-exceeded-exception ([input] (response-custom-metadata-limit-exceeded-exception nil input)) ([resultWrapper1475632 input] (clojure.core/let [rawinput1475631 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475633 {"Message" (rawinput1475631 "Message")}] (clojure.core/cond-> {} (letvar1475633 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475633 ["Message"])))))))

(clojure.core/defn- response-describe-notification-subscriptions-response ([input] (response-describe-notification-subscriptions-response nil input)) ([resultWrapper1475635 input] (clojure.core/let [rawinput1475634 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475636 {"Subscriptions" (rawinput1475634 "Subscriptions"), "Marker" (rawinput1475634 "Marker")}] (clojure.core/cond-> {} (letvar1475636 "Subscriptions") (clojure.core/assoc :subscriptions (deser-subscription-list (clojure.core/get-in letvar1475636 ["Subscriptions"]))) (letvar1475636 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475636 ["Marker"])))))))

(clojure.core/defn- response-update-user-response ([input] (response-update-user-response nil input)) ([resultWrapper1475638 input] (clojure.core/let [rawinput1475637 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475639 {"User" (rawinput1475637 "User")}] (clojure.core/cond-> {} (letvar1475639 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar1475639 ["User"])))))))

(clojure.core/defn- response-entity-already-exists-exception ([input] (response-entity-already-exists-exception nil input)) ([resultWrapper1475641 input] (clojure.core/let [rawinput1475640 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475642 {"Message" (rawinput1475640 "Message")}] (clojure.core/cond-> {} (letvar1475642 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475642 ["Message"])))))))

(clojure.core/defn- response-invalid-operation-exception ([input] (response-invalid-operation-exception nil input)) ([resultWrapper1475644 input] (clojure.core/let [rawinput1475643 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475645 {"Message" (rawinput1475643 "Message")}] (clojure.core/cond-> {} (letvar1475645 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475645 ["Message"])))))))

(clojure.core/defn- response-too-many-subscriptions-exception ([input] (response-too-many-subscriptions-exception nil input)) ([resultWrapper1475647 input] (clojure.core/let [rawinput1475646 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475648 {"Message" (rawinput1475646 "Message")}] (clojure.core/cond-> {} (letvar1475648 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475648 ["Message"])))))))

(clojure.core/defn- response-unauthorized-resource-access-exception ([input] (response-unauthorized-resource-access-exception nil input)) ([resultWrapper1475650 input] (clojure.core/let [rawinput1475649 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475651 {"Message" (rawinput1475649 "Message")}] (clojure.core/cond-> {} (letvar1475651 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475651 ["Message"])))))))

(clojure.core/defn- response-activate-user-response ([input] (response-activate-user-response nil input)) ([resultWrapper1475653 input] (clojure.core/let [rawinput1475652 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475654 {"User" (rawinput1475652 "User")}] (clojure.core/cond-> {} (letvar1475654 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar1475654 ["User"])))))))

(clojure.core/defn- response-describe-activities-response ([input] (response-describe-activities-response nil input)) ([resultWrapper1475656 input] (clojure.core/let [rawinput1475655 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475657 {"UserActivities" (rawinput1475655 "UserActivities"), "Marker" (rawinput1475655 "Marker")}] (clojure.core/cond-> {} (letvar1475657 "UserActivities") (clojure.core/assoc :user-activities (deser-user-activities (clojure.core/get-in letvar1475657 ["UserActivities"]))) (letvar1475657 "Marker") (clojure.core/assoc :marker (deser-marker-type (clojure.core/get-in letvar1475657 ["Marker"])))))))

(clojure.core/defn- response-get-resources-response ([input] (response-get-resources-response nil input)) ([resultWrapper1475659 input] (clojure.core/let [rawinput1475658 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475660 {"Folders" (rawinput1475658 "Folders"), "Documents" (rawinput1475658 "Documents"), "Marker" (rawinput1475658 "Marker")}] (clojure.core/cond-> {} (letvar1475660 "Folders") (clojure.core/assoc :folders (deser-folder-metadata-list (clojure.core/get-in letvar1475660 ["Folders"]))) (letvar1475660 "Documents") (clojure.core/assoc :documents (deser-document-metadata-list (clojure.core/get-in letvar1475660 ["Documents"]))) (letvar1475660 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475660 ["Marker"])))))))

(clojure.core/defn- response-prohibited-state-exception ([input] (response-prohibited-state-exception nil input)) ([resultWrapper1475662 input] (clojure.core/let [rawinput1475661 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475663 {"Message" (rawinput1475661 "Message")}] (clojure.core/cond-> {} (letvar1475663 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475663 ["Message"])))))))

(clojure.core/defn- response-describe-resource-permissions-response ([input] (response-describe-resource-permissions-response nil input)) ([resultWrapper1475665 input] (clojure.core/let [rawinput1475664 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475666 {"Principals" (rawinput1475664 "Principals"), "Marker" (rawinput1475664 "Marker")}] (clojure.core/cond-> {} (letvar1475666 "Principals") (clojure.core/assoc :principals (deser-principal-list (clojure.core/get-in letvar1475666 ["Principals"]))) (letvar1475666 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475666 ["Marker"])))))))

(clojure.core/defn- response-create-notification-subscription-response ([input] (response-create-notification-subscription-response nil input)) ([resultWrapper1475668 input] (clojure.core/let [rawinput1475667 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475669 {"Subscription" (rawinput1475667 "Subscription")}] (clojure.core/cond-> {} (letvar1475669 "Subscription") (clojure.core/assoc :subscription (deser-subscription (clojure.core/get-in letvar1475669 ["Subscription"])))))))

(clojure.core/defn- response-resource-already-checked-out-exception ([input] (response-resource-already-checked-out-exception nil input)) ([resultWrapper1475671 input] (clojure.core/let [rawinput1475670 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475672 {"Message" (rawinput1475670 "Message")}] (clojure.core/cond-> {} (letvar1475672 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475672 ["Message"])))))))

(clojure.core/defn- response-get-folder-response ([input] (response-get-folder-response nil input)) ([resultWrapper1475674 input] (clojure.core/let [rawinput1475673 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475675 {"Metadata" (rawinput1475673 "Metadata"), "CustomMetadata" (rawinput1475673 "CustomMetadata")}] (clojure.core/cond-> {} (letvar1475675 "Metadata") (clojure.core/assoc :metadata (deser-folder-metadata (clojure.core/get-in letvar1475675 ["Metadata"]))) (letvar1475675 "CustomMetadata") (clojure.core/assoc :custom-metadata (deser-custom-metadata-map (clojure.core/get-in letvar1475675 ["CustomMetadata"])))))))

(clojure.core/defn- response-unauthorized-operation-exception ([input] (response-unauthorized-operation-exception nil input)) ([resultWrapper1475677 input] (clojure.core/let [rawinput1475676 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475678 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-labels-response ([input] (response-create-labels-response nil input)) ([resultWrapper1475680 input] (clojure.core/let [rawinput1475679 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475681 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-comment-response ([input] (response-create-comment-response nil input)) ([resultWrapper1475683 input] (clojure.core/let [rawinput1475682 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475684 {"Comment" (rawinput1475682 "Comment")}] (clojure.core/cond-> {} (letvar1475684 "Comment") (clojure.core/assoc :comment (deser-comment (clojure.core/get-in letvar1475684 ["Comment"])))))))

(clojure.core/defn- response-delete-labels-response ([input] (response-delete-labels-response nil input)) ([resultWrapper1475686 input] (clojure.core/let [rawinput1475685 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475687 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-users-response ([input] (response-describe-users-response nil input)) ([resultWrapper1475689 input] (clojure.core/let [rawinput1475688 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475690 {"Users" (rawinput1475688 "Users"), "TotalNumberOfUsers" (rawinput1475688 "TotalNumberOfUsers"), "Marker" (rawinput1475688 "Marker")}] (clojure.core/cond-> {} (letvar1475690 "Users") (clojure.core/assoc :users (deser-organization-user-list (clojure.core/get-in letvar1475690 ["Users"]))) (letvar1475690 "TotalNumberOfUsers") (clojure.core/assoc :total-number-of-users (deser-size-type (clojure.core/get-in letvar1475690 ["TotalNumberOfUsers"]))) (letvar1475690 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475690 ["Marker"])))))))

(clojure.core/defn- response-invalid-argument-exception ([input] (response-invalid-argument-exception nil input)) ([resultWrapper1475692 input] (clojure.core/let [rawinput1475691 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475693 {"Message" (rawinput1475691 "Message")}] (clojure.core/cond-> {} (letvar1475693 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475693 ["Message"])))))))

(clojure.core/defn- response-get-current-user-response ([input] (response-get-current-user-response nil input)) ([resultWrapper1475695 input] (clojure.core/let [rawinput1475694 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475696 {"User" (rawinput1475694 "User")}] (clojure.core/cond-> {} (letvar1475696 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar1475696 ["User"])))))))

(clojure.core/defn- response-conflicting-operation-exception ([input] (response-conflicting-operation-exception nil input)) ([resultWrapper1475698 input] (clojure.core/let [rawinput1475697 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475699 {"Message" (rawinput1475697 "Message")}] (clojure.core/cond-> {} (letvar1475699 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475699 ["Message"])))))))

(clojure.core/defn- response-requested-entity-too-large-exception ([input] (response-requested-entity-too-large-exception nil input)) ([resultWrapper1475701 input] (clojure.core/let [rawinput1475700 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475702 {"Message" (rawinput1475700 "Message")}] (clojure.core/cond-> {} (letvar1475702 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475702 ["Message"])))))))

(clojure.core/defn- response-describe-folder-contents-response ([input] (response-describe-folder-contents-response nil input)) ([resultWrapper1475704 input] (clojure.core/let [rawinput1475703 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475705 {"Folders" (rawinput1475703 "Folders"), "Documents" (rawinput1475703 "Documents"), "Marker" (rawinput1475703 "Marker")}] (clojure.core/cond-> {} (letvar1475705 "Folders") (clojure.core/assoc :folders (deser-folder-metadata-list (clojure.core/get-in letvar1475705 ["Folders"]))) (letvar1475705 "Documents") (clojure.core/assoc :documents (deser-document-metadata-list (clojure.core/get-in letvar1475705 ["Documents"]))) (letvar1475705 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475705 ["Marker"])))))))

(clojure.core/defn- response-storage-limit-exceeded-exception ([input] (response-storage-limit-exceeded-exception nil input)) ([resultWrapper1475707 input] (clojure.core/let [rawinput1475706 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475708 {"Message" (rawinput1475706 "Message")}] (clojure.core/cond-> {} (letvar1475708 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475708 ["Message"])))))))

(clojure.core/defn- response-initiate-document-version-upload-response ([input] (response-initiate-document-version-upload-response nil input)) ([resultWrapper1475710 input] (clojure.core/let [rawinput1475709 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475711 {"Metadata" (rawinput1475709 "Metadata"), "UploadMetadata" (rawinput1475709 "UploadMetadata")}] (clojure.core/cond-> {} (letvar1475711 "Metadata") (clojure.core/assoc :metadata (deser-document-metadata (clojure.core/get-in letvar1475711 ["Metadata"]))) (letvar1475711 "UploadMetadata") (clojure.core/assoc :upload-metadata (deser-upload-metadata (clojure.core/get-in letvar1475711 ["UploadMetadata"])))))))

(clojure.core/defn- response-get-document-response ([input] (response-get-document-response nil input)) ([resultWrapper1475713 input] (clojure.core/let [rawinput1475712 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475714 {"Metadata" (rawinput1475712 "Metadata"), "CustomMetadata" (rawinput1475712 "CustomMetadata")}] (clojure.core/cond-> {} (letvar1475714 "Metadata") (clojure.core/assoc :metadata (deser-document-metadata (clojure.core/get-in letvar1475714 ["Metadata"]))) (letvar1475714 "CustomMetadata") (clojure.core/assoc :custom-metadata (deser-custom-metadata-map (clojure.core/get-in letvar1475714 ["CustomMetadata"])))))))

(clojure.core/defn- response-concurrent-modification-exception ([input] (response-concurrent-modification-exception nil input)) ([resultWrapper1475716 input] (clojure.core/let [rawinput1475715 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475717 {"Message" (rawinput1475715 "Message")}] (clojure.core/cond-> {} (letvar1475717 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475717 ["Message"])))))))

(clojure.core/defn- response-document-locked-for-comments-exception ([input] (response-document-locked-for-comments-exception nil input)) ([resultWrapper1475719 input] (clojure.core/let [rawinput1475718 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475720 {"Message" (rawinput1475718 "Message")}] (clojure.core/cond-> {} (letvar1475720 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475720 ["Message"])))))))

(clojure.core/defn- response-get-document-path-response ([input] (response-get-document-path-response nil input)) ([resultWrapper1475722 input] (clojure.core/let [rawinput1475721 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475723 {"Path" (rawinput1475721 "Path")}] (clojure.core/cond-> {} (letvar1475723 "Path") (clojure.core/assoc :path (deser-resource-path (clojure.core/get-in letvar1475723 ["Path"])))))))

(clojure.core/defn- response-describe-root-folders-response ([input] (response-describe-root-folders-response nil input)) ([resultWrapper1475725 input] (clojure.core/let [rawinput1475724 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475726 {"Folders" (rawinput1475724 "Folders"), "Marker" (rawinput1475724 "Marker")}] (clojure.core/cond-> {} (letvar1475726 "Folders") (clojure.core/assoc :folders (deser-folder-metadata-list (clojure.core/get-in letvar1475726 ["Folders"]))) (letvar1475726 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475726 ["Marker"])))))))

(clojure.core/defn- response-describe-document-versions-response ([input] (response-describe-document-versions-response nil input)) ([resultWrapper1475728 input] (clojure.core/let [rawinput1475727 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475729 {"DocumentVersions" (rawinput1475727 "DocumentVersions"), "Marker" (rawinput1475727 "Marker")}] (clojure.core/cond-> {} (letvar1475729 "DocumentVersions") (clojure.core/assoc :document-versions (deser-document-version-metadata-list (clojure.core/get-in letvar1475729 ["DocumentVersions"]))) (letvar1475729 "Marker") (clojure.core/assoc :marker (deser-page-marker-type (clojure.core/get-in letvar1475729 ["Marker"])))))))

(clojure.core/defn- response-draft-upload-out-of-sync-exception ([input] (response-draft-upload-out-of-sync-exception nil input)) ([resultWrapper1475731 input] (clojure.core/let [rawinput1475730 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475732 {"Message" (rawinput1475730 "Message")}] (clojure.core/cond-> {} (letvar1475732 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475732 ["Message"])))))))

(clojure.core/defn- response-storage-limit-will-exceed-exception ([input] (response-storage-limit-will-exceed-exception nil input)) ([resultWrapper1475734 input] (clojure.core/let [rawinput1475733 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475735 {"Message" (rawinput1475733 "Message")}] (clojure.core/cond-> {} (letvar1475735 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475735 ["Message"])))))))

(clojure.core/defn- response-delete-custom-metadata-response ([input] (response-delete-custom-metadata-response nil input)) ([resultWrapper1475737 input] (clojure.core/let [rawinput1475736 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475738 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-illegal-user-state-exception ([input] (response-illegal-user-state-exception nil input)) ([resultWrapper1475740 input] (clojure.core/let [rawinput1475739 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1475741 {"Message" (rawinput1475739 "Message")}] (clojure.core/cond-> {} (letvar1475741 "Message") (clojure.core/assoc :message (deser-error-message-type (clojure.core/get-in letvar1475741 ["Message"])))))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/parent-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/thread-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/text (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-text-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/visibility (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-visibility-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-comment-request/notify-collaborators (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-comment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.create-comment-request/document-id :portkey.aws.workdocs.-2016-05-01.create-comment-request/version-id :portkey.aws.workdocs.-2016-05-01.create-comment-request/text] :opt-un [:portkey.aws.workdocs.-2016-05-01.create-comment-request/authentication-token :portkey.aws.workdocs.-2016-05-01.create-comment-request/parent-id :portkey.aws.workdocs.-2016-05-01.create-comment-request/thread-id :portkey.aws.workdocs.-2016-05-01.create-comment-request/visibility :portkey.aws.workdocs.-2016-05-01.create-comment-request/notify-collaborators]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.deactivate-user-request/user-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.deactivate-user-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/deactivate-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.deactivate-user-request/user-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.deactivate-user-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/user]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-source-url-map (clojure.spec.alpha/map-of :portkey.aws.workdocs.-2016-05-01/document-source-type :portkey.aws.workdocs.-2016-05-01/url-type))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-id-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w+-.@]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/principal-type #{"USER" "ORGANIZATION" :group :organization "INVITE" :anonymous :invite "ANONYMOUS" :user "GROUP"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/parent-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/modified-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/latest-version-size (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/signature (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/hash-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/labels (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/shared-labels))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/size (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/creator-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/resource-state (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-state-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.folder-metadata/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/folder-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.folder-metadata/created-timestamp :portkey.aws.workdocs.-2016-05-01.folder-metadata/parent-folder-id :portkey.aws.workdocs.-2016-05-01.folder-metadata/modified-timestamp :portkey.aws.workdocs.-2016-05-01.folder-metadata/latest-version-size :portkey.aws.workdocs.-2016-05-01.folder-metadata/signature :portkey.aws.workdocs.-2016-05-01.folder-metadata/labels :portkey.aws.workdocs.-2016-05-01.folder-metadata/size :portkey.aws.workdocs.-2016-05-01.folder-metadata/creator-id :portkey.aws.workdocs.-2016-05-01.folder-metadata/name :portkey.aws.workdocs.-2016-05-01.folder-metadata/resource-state :portkey.aws.workdocs.-2016-05-01.folder-metadata/id]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.notification-options/send-email (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.notification-options/email-message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/notification-options (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.notification-options/send-email :portkey.aws.workdocs.-2016-05-01.notification-options/email-message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-path-component/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-path-component/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-path-component (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.resource-path-component/id :portkey.aws.workdocs.-2016-05-01.resource-path-component/name]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/role-permission-type #{:direct :inherited "INHERITED" "DIRECT"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/group-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/group-metadata))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-request/user-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-request/collection-type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-collection-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-resources-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-resources-request/authentication-token :portkey.aws.workdocs.-2016-05-01.get-resources-request/user-id :portkey.aws.workdocs.-2016-05-01.get-resources-request/collection-type :portkey.aws.workdocs.-2016-05-01.get-resources-request/limit :portkey.aws.workdocs.-2016-05-01.get-resources-request/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/deactivating-last-system-user-exception (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/time-zone-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/time-zone-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/locale (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/locale-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/surname (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/user-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/grant-poweruser-privileges (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-enum-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/given-name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/storage-rule (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/storage-rule-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-user-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/update-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.update-user-request/user-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.update-user-request/time-zone-id :portkey.aws.workdocs.-2016-05-01.update-user-request/type :portkey.aws.workdocs.-2016-05-01.update-user-request/locale :portkey.aws.workdocs.-2016-05-01.update-user-request/surname :portkey.aws.workdocs.-2016-05-01.update-user-request/grant-poweruser-privileges :portkey.aws.workdocs.-2016-05-01.update-user-request/given-name :portkey.aws.workdocs.-2016-05-01.update-user-request/storage-rule :portkey.aws.workdocs.-2016-05-01.update-user-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-status-type #{:initialized "INITIALIZED" :active "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/creator-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/parent-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/modified-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/latest-version-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/resource-state (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-state-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-metadata/labels (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/shared-labels))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.document-metadata/id :portkey.aws.workdocs.-2016-05-01.document-metadata/creator-id :portkey.aws.workdocs.-2016-05-01.document-metadata/parent-folder-id :portkey.aws.workdocs.-2016-05-01.document-metadata/created-timestamp :portkey.aws.workdocs.-2016-05-01.document-metadata/modified-timestamp :portkey.aws.workdocs.-2016-05-01.document-metadata/latest-version-metadata :portkey.aws.workdocs.-2016-05-01.document-metadata/resource-state :portkey.aws.workdocs.-2016-05-01.document-metadata/labels]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-path-response/path (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-path))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-folder-path-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-folder-path-response/path]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-response/metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-response/custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/custom-metadata-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-document-version-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-document-version-response/metadata :portkey.aws.workdocs.-2016-05-01.get-document-version-response/custom-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-request/include-custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.get-document-request/document-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-document-request/authentication-token :portkey.aws.workdocs.-2016-05-01.get-document-request/include-custom-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-folder-response/metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/folder-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-folder-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.create-folder-response/metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-request/search-query (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/search-query-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/positive-integer-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-groups-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-groups-request/search-query] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-groups-request/authentication-token :portkey.aws.workdocs.-2016-05-01.describe-groups-request/organization-id :portkey.aws.workdocs.-2016-05-01.describe-groups-request/marker :portkey.aws.workdocs.-2016-05-01.describe-groups-request/limit]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/search-query-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 512)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\u0020-\uFFFF]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-request/folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-request/include-custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-folder-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.get-folder-request/folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-folder-request/authentication-token :portkey.aws.workdocs.-2016-05-01.get-folder-request/include-custom-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.add-resource-permissions-response/share-results (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/share-results-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/add-resource-permissions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.add-resource-permissions-response/share-results]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/include (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/fields (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-document-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/document-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/authentication-token :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/marker :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/limit :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/include :portkey.aws.workdocs.-2016-05-01.describe-document-versions-request/fields]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/recipient-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/visibility (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-visibility-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/parent-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/status (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-status-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/comment-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/thread-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/text (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-text-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment/contributor (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.comment/comment-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.comment/recipient-id :portkey.aws.workdocs.-2016-05-01.comment/created-timestamp :portkey.aws.workdocs.-2016-05-01.comment/visibility :portkey.aws.workdocs.-2016-05-01.comment/parent-id :portkey.aws.workdocs.-2016-05-01.comment/status :portkey.aws.workdocs.-2016-05-01.comment/thread-id :portkey.aws.workdocs.-2016-05-01.comment/text :portkey.aws.workdocs.-2016-05-01.comment/contributor]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/marker-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2048)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\u0000-\u00FF]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-custom-metadata-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.group-metadata/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.group-metadata/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/group-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/group-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.group-metadata/id :portkey.aws.workdocs.-2016-05-01.group-metadata/name]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/end-time (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/start-time (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/user-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/activity-types (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/activity-names-filter-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/include-indirect-activities (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-activities-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-activities-request/end-time :portkey.aws.workdocs.-2016-05-01.describe-activities-request/start-time :portkey.aws.workdocs.-2016-05-01.describe-activities-request/user-id :portkey.aws.workdocs.-2016-05-01.describe-activities-request/marker :portkey.aws.workdocs.-2016-05-01.describe-activities-request/organization-id :portkey.aws.workdocs.-2016-05-01.describe-activities-request/limit :portkey.aws.workdocs.-2016-05-01.describe-activities-request/activity-types :portkey.aws.workdocs.-2016-05-01.describe-activities-request/resource-id :portkey.aws.workdocs.-2016-05-01.describe-activities-request/include-indirect-activities :portkey.aws.workdocs.-2016-05-01.describe-activities-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-path-component-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/resource-path-component))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/positive-size-type clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activate-user-request/user-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activate-user-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/activate-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.activate-user-request/user-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.activate-user-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.remove-all-resource-permissions-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.remove-all-resource-permissions-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/remove-all-resource-permissions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.remove-all-resource-permissions-request/resource-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.remove-all-resource-permissions-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-content-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-path-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-path-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-path-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-path-request/fields (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-path-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-document-path-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.get-document-path-request/document-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-document-path-request/authentication-token :portkey.aws.workdocs.-2016-05-01.get-document-path-request/limit :portkey.aws.workdocs.-2016-05-01.get-document-path-request/fields :portkey.aws.workdocs.-2016-05-01.get-document-path-request/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-comment-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-comment-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-comment-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-comment-request/comment-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-comment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-comment-request/document-id :portkey.aws.workdocs.-2016-05-01.delete-comment-request/version-id :portkey.aws.workdocs.-2016-05-01.delete-comment-request/comment-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-comment-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/locale-type #{:fr :ja "en" :es "zh_CN" :default "zh_TW" :ko :zh-tw "fr" :pt-br "de" :en "ru" "es" :de "ja" :ru :zh-cn "ko" "default" "pt_BR"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/keys (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/custom-metadata-key-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/delete-all (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-custom-metadata-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/resource-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/authentication-token :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/version-id :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/keys :portkey.aws.workdocs.-2016-05-01.delete-custom-metadata-request/delete-all]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-response/comments (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-comments-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-comments-response/comments :portkey.aws.workdocs.-2016-05-01.describe-comments-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/activity-names-filter-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1024)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w,]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/user-metadata))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/custom-metadata-value-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-response/groups (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/group-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-groups-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-groups-response/groups :portkey.aws.workdocs.-2016-05-01.describe-groups-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.add-resource-permissions-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.add-resource-permissions-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.add-resource-permissions-request/principals (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/share-principal-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/add-resource-permissions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.add-resource-permissions-request/resource-id :portkey.aws.workdocs.-2016-05-01.add-resource-permissions-request/principals] :opt-un [:portkey.aws.workdocs.-2016-05-01.add-resource-permissions-request/authentication-token :portkey.aws.workdocs.-2016-05-01/notification-options]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/original-name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/owner (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-metadata/parent-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.resource-metadata/type :portkey.aws.workdocs.-2016-05-01.resource-metadata/name :portkey.aws.workdocs.-2016-05-01.resource-metadata/original-name :portkey.aws.workdocs.-2016-05-01.resource-metadata/id :portkey.aws.workdocs.-2016-05-01.resource-metadata/version-id :portkey.aws.workdocs.-2016-05-01.resource-metadata/owner :portkey.aws.workdocs.-2016-05-01.resource-metadata/parent-id]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-activities (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/activity))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-comments-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-comments-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-comments-request/document-id :portkey.aws.workdocs.-2016-05-01.describe-comments-request/version-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-comments-request/authentication-token :portkey.aws.workdocs.-2016-05-01.describe-comments-request/limit :portkey.aws.workdocs.-2016-05-01.describe-comments-request/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/email-address-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/signed-header-map (clojure.spec.alpha/map-of :portkey.aws.workdocs.-2016-05-01/header-name-type :portkey.aws.workdocs.-2016-05-01/header-value-type))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-ids-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2000)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[&\w+-.@, ]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.entity-not-exists-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.entity-not-exists-exception/entity-ids (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/entity-id-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.entity-not-exists-exception/message :portkey.aws.workdocs.-2016-05-01.entity-not-exists-exception/entity-ids]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/share-principal-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/share-principal))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.failed-dependency-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.failed-dependency-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-type #{"MINIMALUSER" "USER" :admin :poweruser "POWERUSER" :workspacesuser "ADMIN" :minimaluser "WORKSPACESUSER" :user})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.too-many-labels-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/too-many-labels-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.too-many-labels-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment-status-type #{"PUBLISHED" :deleted "DRAFT" :draft "DELETED" :published})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activity/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/activity-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activity/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activity/original-parent (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activity/is-indirect-activity (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activity/initiator (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.activity/time-stamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/activity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.activity/type :portkey.aws.workdocs.-2016-05-01/resource-metadata :portkey.aws.workdocs.-2016-05-01.activity/organization-id :portkey.aws.workdocs.-2016-05-01.activity/original-parent :portkey.aws.workdocs.-2016-05-01.activity/is-indirect-activity :portkey.aws.workdocs.-2016-05-01/participants :portkey.aws.workdocs.-2016-05-01.activity/initiator :portkey.aws.workdocs.-2016-05-01.activity/time-stamp :portkey.aws.workdocs.-2016-05-01/comment-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/username (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/username-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/storage (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-storage-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/time-zone-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/time-zone-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/locale (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/locale-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/surname (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/recycle-bin-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/status (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-status-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/modified-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/given-name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/root-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/email-address (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/email-address-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.user/username :portkey.aws.workdocs.-2016-05-01.user/storage :portkey.aws.workdocs.-2016-05-01.user/created-timestamp :portkey.aws.workdocs.-2016-05-01.user/time-zone-id :portkey.aws.workdocs.-2016-05-01.user/type :portkey.aws.workdocs.-2016-05-01.user/locale :portkey.aws.workdocs.-2016-05-01.user/surname :portkey.aws.workdocs.-2016-05-01.user/recycle-bin-folder-id :portkey.aws.workdocs.-2016-05-01.user/organization-id :portkey.aws.workdocs.-2016-05-01.user/status :portkey.aws.workdocs.-2016-05-01.user/modified-timestamp :portkey.aws.workdocs.-2016-05-01.user/given-name :portkey.aws.workdocs.-2016-05-01.user/root-folder-id :portkey.aws.workdocs.-2016-05-01.user/email-address :portkey.aws.workdocs.-2016-05-01.user/id]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-notification-subscription-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-notification-subscription-request/endpoint (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/subscription-end-point-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-notification-subscription-request/protocol (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/subscription-protocol-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-notification-subscription-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.create-notification-subscription-request/organization-id :portkey.aws.workdocs.-2016-05-01.create-notification-subscription-request/endpoint :portkey.aws.workdocs.-2016-05-01.create-notification-subscription-request/protocol :portkey.aws.workdocs.-2016-05-01/subscription-type] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/comment))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-source-type #{"WITH_COMMENTS" :original "ORIGINAL" :with-comments})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.invalid-password-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/invalid-password-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.invalid-password-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/username-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/folder-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/folder-metadata))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/subscription-protocol-type #{"HTTPS" :https})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/source (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-source-url-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/content-modified-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/status (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-status-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/modified-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/content-type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-content-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/signature (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/hash-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/content-created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/thumbnail (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-thumbnail-url-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/size (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/creator-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-version-metadata/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-version-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.document-version-metadata/created-timestamp :portkey.aws.workdocs.-2016-05-01.document-version-metadata/source :portkey.aws.workdocs.-2016-05-01.document-version-metadata/content-modified-timestamp :portkey.aws.workdocs.-2016-05-01.document-version-metadata/status :portkey.aws.workdocs.-2016-05-01.document-version-metadata/modified-timestamp :portkey.aws.workdocs.-2016-05-01.document-version-metadata/content-type :portkey.aws.workdocs.-2016-05-01.document-version-metadata/signature :portkey.aws.workdocs.-2016-05-01.document-version-metadata/content-created-timestamp :portkey.aws.workdocs.-2016-05-01.document-version-metadata/thumbnail :portkey.aws.workdocs.-2016-05-01.document-version-metadata/size :portkey.aws.workdocs.-2016-05-01.document-version-metadata/creator-id :portkey.aws.workdocs.-2016-05-01.document-version-metadata/name :portkey.aws.workdocs.-2016-05-01.document-version-metadata/id]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/share-status-type #{"SUCCESS" :failure "FAILURE" :success})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/size-type clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/group-name-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/principal-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-resource-permissions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/resource-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/authentication-token :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/principal-id :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/limit :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-request/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/error-message-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.invalid-comment-operation-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/invalid-comment-operation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.invalid-comment-operation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.custom-metadata-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/custom-metadata-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.custom-metadata-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment-visibility-type #{:private :public "PRIVATE" "PUBLIC"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-response/subscriptions (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/subscription-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-notification-subscriptions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-response/subscriptions :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-folder-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-folder-request/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-folder-request/parent-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-folder-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.create-folder-request/parent-folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.create-folder-request/authentication-token :portkey.aws.workdocs.-2016-05-01.create-folder-request/name]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-metadata/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-metadata/username (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/username-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-metadata/given-name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-metadata/surname (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-metadata/email-address (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/email-address-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.user-metadata/id :portkey.aws.workdocs.-2016-05-01.user-metadata/username :portkey.aws.workdocs.-2016-05-01.user-metadata/given-name :portkey.aws.workdocs.-2016-05-01.user-metadata/surname :portkey.aws.workdocs.-2016-05-01.user-metadata/email-address]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/update-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/user]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.entity-already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/entity-already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.entity-already-exists-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/principal-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/principal))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/url-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.invalid-operation-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/invalid-operation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.invalid-operation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.too-many-subscriptions-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/too-many-subscriptions-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.too-many-subscriptions-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/organization-user-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/user))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.unauthorized-resource-access-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.unauthorized-resource-access-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/activate-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/user]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/shared-label (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 32)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/password-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 4 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 32)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\u0020-\u00FF]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-activities-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-activities-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/user-activities :portkey.aws.workdocs.-2016-05-01.describe-activities-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-sort-type #{"STORAGE_LIMIT" :user-status :storage-limit :user-name "USER_STATUS" :storage-used :full-name "FULL_NAME" "STORAGE_USED" "USER_NAME"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-response/folders (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/folder-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-response/documents (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-resources-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-resources-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-resources-response/folders :portkey.aws.workdocs.-2016-05-01.get-resources-response/documents :portkey.aws.workdocs.-2016-05-01.get-resources-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.upload-metadata/upload-url (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/url-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.upload-metadata/signed-headers (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/signed-header-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/upload-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.upload-metadata/upload-url :portkey.aws.workdocs.-2016-05-01.upload-metadata/signed-headers]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.prohibited-state-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.prohibited-state-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/activity-type #{"DOCUMENT_REVERTED" :document-comment-added :folder-share-permission-changed "FOLDER_SHAREABLE_LINK_CREATED" "DOCUMENT_SHARE_PERMISSION_CHANGED" :folder-shareable-link-permission-changed :folder-recycled "DOCUMENT_SHAREABLE_LINK_REMOVED" "FOLDER_RESTORED" "FOLDER_SHAREABLE_LINK_REMOVED" "DOCUMENT_COMMENT_DELETED" "FOLDER_RECYCLED" :document-annotation-deleted :document-unshared :document-share-permission-changed "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED" :folder-moved :folder-shared :folder-renamed "DOCUMENT_RESTORED" "DOCUMENT_UNSHARED" :document-comment-deleted :document-annotation-added :folder-deleted :folder-unshared "DOCUMENT_ANNOTATION_DELETED" "DOCUMENT_RENAMED" :document-shared "FOLDER_CREATED" "FOLDER_MOVED" :document-version-uploaded "FOLDER_DELETED" :folder-shareable-link-removed "FOLDER_RENAMED" "DOCUMENT_SHARED" :document-version-deleted "FOLDER_SHARE_PERMISSION_CHANGED" :document-restored :document-shareable-link-permission-changed :folder-shareable-link-created :document-reverted "DOCUMENT_ANNOTATION_ADDED" "DOCUMENT_VERSION_UPLOADED" "DOCUMENT_COMMENT_ADDED" "DOCUMENT_SHAREABLE_LINK_CREATED" "DOCUMENT_VERSION_DOWNLOADED" :document-moved "FOLDER_SHARED" :document-shareable-link-created "DOCUMENT_VERSION_DELETED" "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED" :document-renamed :folder-created "DOCUMENT_CHECKED_IN" :document-checked-in "FOLDER_UNSHARED" :document-version-downloaded "DOCUMENT_RECYCLED" "DOCUMENT_MOVED" "DOCUMENT_CHECKED_OUT" :folder-restored :document-shareable-link-removed :document-recycled :document-version-viewed "DOCUMENT_VERSION_VIEWED" :document-checked-out})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-status-type #{:inactive :pending "PENDING" :active "INACTIVE" "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/page-marker-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-response/principals (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/principal-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-resource-permissions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-response/principals :portkey.aws.workdocs.-2016-05-01.describe-resource-permissions-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/timestamp-type clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-request/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-request/parent-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-request/resource-state (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-state-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/update-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.update-document-request/document-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.update-document-request/authentication-token :portkey.aws.workdocs.-2016-05-01.update-document-request/name :portkey.aws.workdocs.-2016-05-01.update-document-request/parent-folder-id :portkey.aws.workdocs.-2016-05-01.update-document-request/resource-state]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/subscription-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/subscription :max-count 256))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-notification-subscription-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/subscription]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.remove-resource-permission-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.remove-resource-permission-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.remove-resource-permission-request/principal-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/remove-resource-permission-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.remove-resource-permission-request/resource-id :portkey.aws.workdocs.-2016-05-01.remove-resource-permission-request/principal-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.remove-resource-permission-request/authentication-token :portkey.aws.workdocs.-2016-05-01/principal-type]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-already-checked-out-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-already-checked-out-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.resource-already-checked-out-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-response/metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/folder-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-response/custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/custom-metadata-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-folder-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-folder-response/metadata :portkey.aws.workdocs.-2016-05-01.get-folder-response/custom-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/subscription-end-point-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/authentication-header-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 8199))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/fields (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-folder-path-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.get-folder-path-request/folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-folder-path-request/authentication-token :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/limit :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/fields :portkey.aws.workdocs.-2016-05-01.get-folder-path-request/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-thumbnail-type #{:large "SMALL_HQ" "LARGE" :small-hq :small "SMALL"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.participants/users (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.participants/groups (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/group-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/participants (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.participants/users :portkey.aws.workdocs.-2016-05-01.participants/groups]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/custom-metadata-key-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 56)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9._+-/=][a-zA-Z0-9 ._+-/=]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-name-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 255)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\u0020-\u202D\u202F-\uFFFF]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-sort-type #{:date "NAME" :name "DATE"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-labels-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/time-zone-id-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-filter-type #{:active-pending :all "ACTIVE_PENDING" "ALL"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/id-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[&\w+-.@]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/subscription-type #{:all "ALL"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-comment-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/comment]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-labels-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-response/users (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/organization-user-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-response/total-number-of-users (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-users-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-users-response/users :portkey.aws.workdocs.-2016-05-01.describe-users-response/total-number-of-users :portkey.aws.workdocs.-2016-05-01.describe-users-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.storage-rule-type/storage-allocated-in-bytes (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/positive-size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/storage-rule-type (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.storage-rule-type/storage-allocated-in-bytes :portkey.aws.workdocs.-2016-05-01/storage-type]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-type #{:folder "DOCUMENT" :document "FOLDER"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.invalid-argument-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.invalid-argument-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-folder-contents-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-folder-contents-request/folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-folder-contents-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-folder-contents-request/folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-folder-contents-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment-id-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w+-.@]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-current-user-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-current-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.get-current-user-request/authentication-token] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-state-type #{"RESTORING" :restoring "RECYCLING" :active "ACTIVE" :recycling "RECYCLED" :recycled})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-document-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-document-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-document-request/document-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-document-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.resource-path/components (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-path-component-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-path (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.resource-path/components]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/storage-type #{"UNLIMITED" :unlimited :quota "QUOTA"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-version-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-version-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-version-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-document-version-request/version-status (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-status))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/update-document-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.update-document-version-request/document-id :portkey.aws.workdocs.-2016-05-01.update-document-version-request/version-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.update-document-version-request/authentication-token :portkey.aws.workdocs.-2016-05-01.update-document-version-request/version-status]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-current-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01/user]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.conflicting-operation-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.conflicting-operation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-folder-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-folder-request/folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-folder-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-folder-request/folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-folder-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-version-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/document-version-metadata))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/message-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 0 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/username (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/username-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/time-zone-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/time-zone-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/password (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/password-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/surname (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/given-name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/storage-rule (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/storage-rule-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/email-address (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/email-address-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-user-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.create-user-request/username :portkey.aws.workdocs.-2016-05-01.create-user-request/given-name :portkey.aws.workdocs.-2016-05-01.create-user-request/surname :portkey.aws.workdocs.-2016-05-01.create-user-request/password] :opt-un [:portkey.aws.workdocs.-2016-05-01.create-user-request/time-zone-id :portkey.aws.workdocs.-2016-05-01.create-user-request/organization-id :portkey.aws.workdocs.-2016-05-01.create-user-request/storage-rule :portkey.aws.workdocs.-2016-05-01.create-user-request/email-address :portkey.aws.workdocs.-2016-05-01.create-user-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/document-metadata))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-version-id-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w+-.@]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-root-folders-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-root-folders-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-root-folders-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-root-folders-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-root-folders-request/authentication-token] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-root-folders-request/limit :portkey.aws.workdocs.-2016-05-01.describe-root-folders-request/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.requested-entity-too-large-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/requested-entity-too-large-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.requested-entity-too-large-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-response/folders (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/folder-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-response/documents (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-folder-contents-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-folder-contents-response/folders :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-response/documents :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/positive-integer-type (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.storage-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/storage-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.storage-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-labels-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-labels-request/labels (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/shared-labels))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-labels-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-labels-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.create-labels-request/resource-id :portkey.aws.workdocs.-2016-05-01.create-labels-request/labels] :opt-un [:portkey.aws.workdocs.-2016-05-01.create-labels-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.subscription/subscription-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.subscription/end-point (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/subscription-end-point-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.subscription/protocol (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/subscription-protocol-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/subscription (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.subscription/subscription-id :portkey.aws.workdocs.-2016-05-01.subscription/end-point :portkey.aws.workdocs.-2016-05-01.subscription/protocol]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/hash-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 0 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[&\w+-.@]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-user-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-user-request/user-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-user-request/user-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-user-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.permission-info/role (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/role-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.permission-info/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/role-permission-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/permission-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.permission-info/role :portkey.aws.workdocs.-2016-05-01.permission-info/type]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/folder-content-type #{:folder "DOCUMENT" :all :document "FOLDER" "ALL"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-thumbnail-url-map (clojure.spec.alpha/map-of :portkey.aws.workdocs.-2016-05-01/document-thumbnail-type :portkey.aws.workdocs.-2016-05-01/url-type))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/permission-info-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/permission-info))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/limit-type (clojure.spec.alpha/int-in 1 999))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/field-names-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w,]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/header-name-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-response/metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/initiate-document-version-upload-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-response/metadata :portkey.aws.workdocs.-2016-05-01/upload-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-response/metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-metadata))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-response/custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/custom-metadata-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-document-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-document-response/metadata :portkey.aws.workdocs.-2016-05-01.get-document-response/custom-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-version-status #{:active "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/order-type #{:descending :ascending "ASCENDING" "DESCENDING"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/entity-id-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/id-type))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-principal/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-principal/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/principal-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-principal/role (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/role-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/share-principal (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.share-principal/id :portkey.aws.workdocs.-2016-05-01.share-principal/type :portkey.aws.workdocs.-2016-05-01.share-principal/role] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/boolean-enum-type #{:true :false "TRUE" "FALSE"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.concurrent-modification-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/concurrent-modification-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.concurrent-modification-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.document-locked-for-comments-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/document-locked-for-comments-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.document-locked-for-comments-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-path-response/path (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-path))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-document-path-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-document-path-response/path]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/content-created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/content-modified-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/content-type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-content-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/document-size-in-bytes (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/parent-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/initiate-document-version-upload-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/parent-folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/authentication-token :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/id :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/name :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/content-created-timestamp :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/content-modified-timestamp :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/content-type :portkey.aws.workdocs.-2016-05-01.initiate-document-version-upload-request/document-size-in-bytes]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-result/principal-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-result/invitee-principal-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-result/role (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/role-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-result/status (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/share-status-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-result/share-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.share-result/status-message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/share-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.share-result/principal-id :portkey.aws.workdocs.-2016-05-01.share-result/invitee-principal-id :portkey.aws.workdocs.-2016-05-01.share-result/role :portkey.aws.workdocs.-2016-05-01.share-result/status :portkey.aws.workdocs.-2016-05-01.share-result/share-id :portkey.aws.workdocs.-2016-05-01.share-result/status-message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.principal/id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.principal/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/principal-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.principal/roles (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/permission-info-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/principal (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.principal/id :portkey.aws.workdocs.-2016-05-01.principal/type :portkey.aws.workdocs.-2016-05-01.principal/roles]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment-text-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/resource-collection-type #{:shared-with-me "SHARED_WITH_ME"})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-attribute-value-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 64))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-root-folders-response/folders (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/folder-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-root-folders-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-root-folders-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-root-folders-response/folders :portkey.aws.workdocs.-2016-05-01.describe-root-folders-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/custom-metadata-key-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/custom-metadata-key-type :max-count 8))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-response/document-versions (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-metadata-list))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-document-versions-response/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-document-versions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-document-versions-response/document-versions :portkey.aws.workdocs.-2016-05-01.describe-document-versions-response/marker]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/shared-labels (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/shared-label :max-count 20))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-notification-subscription-request/subscription-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-notification-subscription-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-notification-subscription-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-notification-subscription-request/subscription-id :portkey.aws.workdocs.-2016-05-01.delete-notification-subscription-request/organization-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/share-results-list (clojure.spec.alpha/coll-of :portkey.aws.workdocs.-2016-05-01/share-result))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-storage-metadata/storage-utilized-in-bytes (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/size-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.user-storage-metadata/storage-rule (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/storage-rule-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/user-storage-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.user-storage-metadata/storage-utilized-in-bytes :portkey.aws.workdocs.-2016-05-01.user-storage-metadata/storage-rule]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.draft-upload-out-of-sync-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/draft-upload-out-of-sync-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.draft-upload-out-of-sync-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/custom-metadata-map))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/create-custom-metadata-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/resource-id :portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/custom-metadata] :opt-un [:portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/authentication-token :portkey.aws.workdocs.-2016-05-01.create-custom-metadata-request/version-id]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/sort (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-sort-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/order (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/order-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/type (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/folder-content-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/include (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-folder-contents-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/authentication-token :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/sort :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/order :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/limit :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/marker :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/type :portkey.aws.workdocs.-2016-05-01.describe-folder-contents-request/include]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-folder-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-folder-request/folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-folder-request/name (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-name-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-folder-request/parent-folder-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.update-folder-request/resource-state (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-state-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/update-folder-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.update-folder-request/folder-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.update-folder-request/authentication-token :portkey.aws.workdocs.-2016-05-01.update-folder-request/name :portkey.aws.workdocs.-2016-05-01.update-folder-request/parent-folder-id :portkey.aws.workdocs.-2016-05-01.update-folder-request/resource-state]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.storage-limit-will-exceed-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/storage-limit-will-exceed-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.storage-limit-will-exceed-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-labels-request/resource-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-labels-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-labels-request/labels (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/shared-labels))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.delete-labels-request/delete-all (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-labels-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.delete-labels-request/resource-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.delete-labels-request/authentication-token :portkey.aws.workdocs.-2016-05-01.delete-labels-request/labels :portkey.aws.workdocs.-2016-05-01.delete-labels-request/delete-all]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/delete-custom-metadata-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/user-ids (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-ids-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/sort (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-sort-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/order (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/order-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/fields (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/query (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/search-query-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/include (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user-filter-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-users-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-users-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-users-request/user-ids :portkey.aws.workdocs.-2016-05-01.describe-users-request/sort :portkey.aws.workdocs.-2016-05-01.describe-users-request/order :portkey.aws.workdocs.-2016-05-01.describe-users-request/fields :portkey.aws.workdocs.-2016-05-01.describe-users-request/marker :portkey.aws.workdocs.-2016-05-01.describe-users-request/organization-id :portkey.aws.workdocs.-2016-05-01.describe-users-request/limit :portkey.aws.workdocs.-2016-05-01.describe-users-request/query :portkey.aws.workdocs.-2016-05-01.describe-users-request/include :portkey.aws.workdocs.-2016-05-01.describe-users-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-request/fields (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/field-names-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.get-document-version-request/include-custom-metadata (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/boolean-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/get-document-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.get-document-version-request/document-id :portkey.aws.workdocs.-2016-05-01.get-document-version-request/version-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.get-document-version-request/authentication-token :portkey.aws.workdocs.-2016-05-01.get-document-version-request/fields :portkey.aws.workdocs.-2016-05-01.get-document-version-request/include-custom-metadata]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/custom-metadata-map (clojure.spec.alpha/map-of :portkey.aws.workdocs.-2016-05-01/custom-metadata-key-type :portkey.aws.workdocs.-2016-05-01/custom-metadata-value-type))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment-metadata/comment-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment-metadata/contributor (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/user))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment-metadata/created-timestamp (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/timestamp-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment-metadata/comment-status (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/comment-status-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.comment-metadata/recipient-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/comment-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.comment-metadata/comment-id :portkey.aws.workdocs.-2016-05-01.comment-metadata/contributor :portkey.aws.workdocs.-2016-05-01.comment-metadata/created-timestamp :portkey.aws.workdocs.-2016-05-01.comment-metadata/comment-status :portkey.aws.workdocs.-2016-05-01.comment-metadata/recipient-id]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/role-type #{"CONTRIBUTOR" :viewer "VIEWER" :coowner "OWNER" :contributor "COOWNER" :owner})

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.abort-document-version-upload-request/authentication-token (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/authentication-header-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.abort-document-version-upload-request/document-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/resource-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.abort-document-version-upload-request/version-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/document-version-id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/abort-document-version-upload-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.abort-document-version-upload-request/document-id :portkey.aws.workdocs.-2016-05-01.abort-document-version-upload-request/version-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.abort-document-version-upload-request/authentication-token]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/header-value-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1024))))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.illegal-user-state-exception/message (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/error-message-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/illegal-user-state-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.workdocs.-2016-05-01.illegal-user-state-exception/message]))

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/boolean-type clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-request/organization-id (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/id-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-request/marker (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/page-marker-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-request/limit (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/limit-type))
(clojure.spec.alpha/def :portkey.aws.workdocs.-2016-05-01/describe-notification-subscriptions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-request/organization-id] :opt-un [:portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-request/marker :portkey.aws.workdocs.-2016-05-01.describe-notification-subscriptions-request/limit]))

(clojure.core/defn create-folder ([create-folder-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-folder-request create-folder-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/create-folder-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/create-folder-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateFolder", :http.request.configuration/output-deser-fn response-create-folder-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "LimitExceededException" :portkey.aws.workdocs.-2016-05-01/limit-exceeded-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "EntityAlreadyExistsException" :portkey.aws.workdocs.-2016-05-01/entity-already-exists-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "ConflictingOperationException" :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception}})))))
(clojure.spec.alpha/fdef create-folder :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/create-folder-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/create-folder-response))

(clojure.core/defn get-folder-path ([get-folder-path-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-folder-path-request get-folder-path-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-folder-path-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders/{FolderId}/path", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-folder-path-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetFolderPath", :http.request.configuration/output-deser-fn response-get-folder-path-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-folder-path :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/get-folder-path-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-folder-path-response))

(clojure.core/defn remove-all-resource-permissions ([remove-all-resource-permissions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-remove-all-resource-permissions-request remove-all-resource-permissions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/permissions", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/remove-all-resource-permissions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveAllResourcePermissions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef remove-all-resource-permissions :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/remove-all-resource-permissions-request) :ret clojure.core/true?)

(clojure.core/defn get-document-version ([get-document-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-document-version-request get-document-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-document-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions/{VersionId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-document-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentVersion", :http.request.configuration/output-deser-fn response-get-document-version-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "InvalidPasswordException" :portkey.aws.workdocs.-2016-05-01/invalid-password-exception}})))))
(clojure.spec.alpha/fdef get-document-version :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/get-document-version-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-document-version-response))

(clojure.core/defn get-document ([get-document-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-document-request get-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-document-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-document-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocument", :http.request.configuration/output-deser-fn response-get-document-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "InvalidPasswordException" :portkey.aws.workdocs.-2016-05-01/invalid-password-exception}})))))
(clojure.spec.alpha/fdef get-document :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/get-document-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-document-response))

(clojure.core/defn describe-folder-contents ([describe-folder-contents-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-folder-contents-request describe-folder-contents-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-folder-contents-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders/{FolderId}/contents", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-folder-contents-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFolderContents", :http.request.configuration/output-deser-fn response-describe-folder-contents-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception}})))))
(clojure.spec.alpha/fdef describe-folder-contents :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-folder-contents-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-folder-contents-response))

(clojure.core/defn delete-labels ([delete-labels-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-labels-request delete-labels-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/delete-labels-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/labels", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-labels-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteLabels", :http.request.configuration/output-deser-fn response-delete-labels-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-labels :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-labels-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/delete-labels-response))

(clojure.core/defn describe-notification-subscriptions ([describe-notification-subscriptions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-notification-subscriptions-request describe-notification-subscriptions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-notification-subscriptions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/organizations/{OrganizationId}/subscriptions", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-notification-subscriptions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeNotificationSubscriptions", :http.request.configuration/output-deser-fn response-describe-notification-subscriptions-response, :http.request.spec/error-spec {"UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-notification-subscriptions :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-notification-subscriptions-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-notification-subscriptions-response))

(clojure.core/defn describe-root-folders ([describe-root-folders-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-root-folders-request describe-root-folders-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-root-folders-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/me/root", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-root-folders-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRootFolders", :http.request.configuration/output-deser-fn response-describe-root-folders-response, :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-root-folders :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-root-folders-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-root-folders-response))

(clojure.core/defn add-resource-permissions ([add-resource-permissions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-add-resource-permissions-request add-resource-permissions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/add-resource-permissions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/permissions", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/add-resource-permissions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddResourcePermissions", :http.request.configuration/output-deser-fn response-add-resource-permissions-response, :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef add-resource-permissions :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/add-resource-permissions-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/add-resource-permissions-response))

(clojure.core/defn describe-document-versions ([describe-document-versions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-document-versions-request describe-document-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-document-versions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-document-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDocumentVersions", :http.request.configuration/output-deser-fn response-describe-document-versions-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception}})))))
(clojure.spec.alpha/fdef describe-document-versions :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-document-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-document-versions-response))

(clojure.core/defn delete-user ([delete-user-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-user-request delete-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/users/{UserId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUser", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-user :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-user-request) :ret clojure.core/true?)

(clojure.core/defn create-user ([create-user-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-user-request create-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/create-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/users", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/create-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateUser", :http.request.configuration/output-deser-fn response-create-user-response, :http.request.spec/error-spec {"EntityAlreadyExistsException" :portkey.aws.workdocs.-2016-05-01/entity-already-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-user :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/create-user-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/create-user-response))

(clojure.core/defn describe-resource-permissions ([describe-resource-permissions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-resource-permissions-request describe-resource-permissions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-resource-permissions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/permissions", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-resource-permissions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeResourcePermissions", :http.request.configuration/output-deser-fn response-describe-resource-permissions-response, :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-resource-permissions :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-resource-permissions-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-resource-permissions-response))

(clojure.core/defn describe-users ([] (describe-users {})) ([describe-users-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-users-request describe-users-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-users-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/users", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-users-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeUsers", :http.request.configuration/output-deser-fn response-describe-users-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "RequestedEntityTooLargeException" :portkey.aws.workdocs.-2016-05-01/requested-entity-too-large-exception}})))))
(clojure.spec.alpha/fdef describe-users :args (clojure.spec.alpha/? :portkey.aws.workdocs.-2016-05-01/describe-users-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-users-response))

(clojure.core/defn get-document-path ([get-document-path-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-document-path-request get-document-path-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-document-path-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/path", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-document-path-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDocumentPath", :http.request.configuration/output-deser-fn response-get-document-path-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-document-path :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/get-document-path-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-document-path-response))

(clojure.core/defn remove-resource-permission ([remove-resource-permission-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-remove-resource-permission-request remove-resource-permission-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/permissions/{PrincipalId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/remove-resource-permission-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveResourcePermission", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef remove-resource-permission :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/remove-resource-permission-request) :ret clojure.core/true?)

(clojure.core/defn update-document-version ([update-document-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-document-version-request update-document-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions/{VersionId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/update-document-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocumentVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "ConcurrentModificationException" :portkey.aws.workdocs.-2016-05-01/concurrent-modification-exception, "InvalidOperationException" :portkey.aws.workdocs.-2016-05-01/invalid-operation-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-document-version :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/update-document-version-request) :ret clojure.core/true?)

(clojure.core/defn get-folder ([get-folder-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-folder-request get-folder-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-folder-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders/{FolderId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-folder-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetFolder", :http.request.configuration/output-deser-fn response-get-folder-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception}})))))
(clojure.spec.alpha/fdef get-folder :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/get-folder-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-folder-response))

(clojure.core/defn abort-document-version-upload ([abort-document-version-upload-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-abort-document-version-upload-request abort-document-version-upload-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions/{VersionId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/abort-document-version-upload-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AbortDocumentVersionUpload", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef abort-document-version-upload :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/abort-document-version-upload-request) :ret clojure.core/true?)

(clojure.core/defn describe-comments ([describe-comments-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-comments-request describe-comments-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-comments-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions/{VersionId}/comments", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-comments-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeComments", :http.request.configuration/output-deser-fn response-describe-comments-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-comments :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-comments-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-comments-response))

(clojure.core/defn create-comment ([create-comment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-comment-request create-comment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/create-comment-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions/{VersionId}/comment", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/create-comment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateComment", :http.request.configuration/output-deser-fn response-create-comment-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "DocumentLockedForCommentsException" :portkey.aws.workdocs.-2016-05-01/document-locked-for-comments-exception, "InvalidCommentOperationException" :portkey.aws.workdocs.-2016-05-01/invalid-comment-operation-exception}})))))
(clojure.spec.alpha/fdef create-comment :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/create-comment-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/create-comment-response))

(clojure.core/defn delete-notification-subscription ([delete-notification-subscription-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-notification-subscription-request delete-notification-subscription-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/organizations/{OrganizationId}/subscriptions/{SubscriptionId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-notification-subscription-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteNotificationSubscription", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception}})))))
(clojure.spec.alpha/fdef delete-notification-subscription :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-notification-subscription-request) :ret clojure.core/true?)

(clojure.core/defn initiate-document-version-upload ([initiate-document-version-upload-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-initiate-document-version-upload-request initiate-document-version-upload-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/initiate-document-version-upload-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/initiate-document-version-upload-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "InitiateDocumentVersionUpload", :http.request.configuration/output-deser-fn response-initiate-document-version-upload-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "EntityAlreadyExistsException" :portkey.aws.workdocs.-2016-05-01/entity-already-exists-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "ResourceAlreadyCheckedOutException" :portkey.aws.workdocs.-2016-05-01/resource-already-checked-out-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "StorageLimitExceededException" :portkey.aws.workdocs.-2016-05-01/storage-limit-exceeded-exception, "DraftUploadOutOfSyncException" :portkey.aws.workdocs.-2016-05-01/draft-upload-out-of-sync-exception, "StorageLimitWillExceedException" :portkey.aws.workdocs.-2016-05-01/storage-limit-will-exceed-exception}})))))
(clojure.spec.alpha/fdef initiate-document-version-upload :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/initiate-document-version-upload-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/initiate-document-version-upload-response))

(clojure.core/defn create-notification-subscription ([create-notification-subscription-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-notification-subscription-request create-notification-subscription-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/create-notification-subscription-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/organizations/{OrganizationId}/subscriptions", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/create-notification-subscription-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateNotificationSubscription", :http.request.configuration/output-deser-fn response-create-notification-subscription-response, :http.request.spec/error-spec {"UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "TooManySubscriptionsException" :portkey.aws.workdocs.-2016-05-01/too-many-subscriptions-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-notification-subscription :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/create-notification-subscription-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/create-notification-subscription-response))

(clojure.core/defn get-current-user ([get-current-user-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-current-user-request get-current-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-current-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/me", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-current-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCurrentUser", :http.request.configuration/output-deser-fn response-get-current-user-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-current-user :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/get-current-user-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-current-user-response))

(clojure.core/defn create-labels ([create-labels-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-labels-request create-labels-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/create-labels-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/labels", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/create-labels-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateLabels", :http.request.configuration/output-deser-fn response-create-labels-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "TooManyLabelsException" :portkey.aws.workdocs.-2016-05-01/too-many-labels-exception}})))))
(clojure.spec.alpha/fdef create-labels :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/create-labels-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/create-labels-response))

(clojure.core/defn create-custom-metadata ([create-custom-metadata-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-custom-metadata-request create-custom-metadata-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/create-custom-metadata-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/customMetadata", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/create-custom-metadata-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCustomMetadata", :http.request.configuration/output-deser-fn response-create-custom-metadata-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "CustomMetadataLimitExceededException" :portkey.aws.workdocs.-2016-05-01/custom-metadata-limit-exceeded-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-custom-metadata :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/create-custom-metadata-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/create-custom-metadata-response))

(clojure.core/defn delete-folder-contents ([delete-folder-contents-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-folder-contents-request delete-folder-contents-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders/{FolderId}/contents", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-folder-contents-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteFolderContents", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "ConflictingOperationException" :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-folder-contents :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-folder-contents-request) :ret clojure.core/true?)

(clojure.core/defn describe-groups ([describe-groups-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-groups-request describe-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/groups", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeGroups", :http.request.configuration/output-deser-fn response-describe-groups-response, :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-groups :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/describe-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-groups-response))

(clojure.core/defn activate-user ([activate-user-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-activate-user-request activate-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/activate-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/users/{UserId}/activation", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/activate-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ActivateUser", :http.request.configuration/output-deser-fn response-activate-user-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef activate-user :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/activate-user-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/activate-user-response))

(clojure.core/defn deactivate-user ([deactivate-user-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-deactivate-user-request deactivate-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/users/{UserId}/activation", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/deactivate-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeactivateUser", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef deactivate-user :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/deactivate-user-request) :ret clojure.core/true?)

(clojure.core/defn update-document ([update-document-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-document-request update-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/update-document-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDocument", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "LimitExceededException" :portkey.aws.workdocs.-2016-05-01/limit-exceeded-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "EntityAlreadyExistsException" :portkey.aws.workdocs.-2016-05-01/entity-already-exists-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "ConflictingOperationException" :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception, "ConcurrentModificationException" :portkey.aws.workdocs.-2016-05-01/concurrent-modification-exception}})))))
(clojure.spec.alpha/fdef update-document :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/update-document-request) :ret clojure.core/true?)

(clojure.core/defn get-resources ([] (get-resources {})) ([get-resources-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-resources-request get-resources-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/get-resources-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/get-resources-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetResources", :http.request.configuration/output-deser-fn response-get-resources-response, :http.request.spec/error-spec {"UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-resources :args (clojure.spec.alpha/? :portkey.aws.workdocs.-2016-05-01/get-resources-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/get-resources-response))

(clojure.core/defn delete-folder ([delete-folder-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-folder-request delete-folder-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders/{FolderId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-folder-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteFolder", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "ConflictingOperationException" :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception, "ConcurrentModificationException" :portkey.aws.workdocs.-2016-05-01/concurrent-modification-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-folder :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-folder-request) :ret clojure.core/true?)

(clojure.core/defn delete-document ([delete-document-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-document-request delete-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-document-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDocument", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "ConflictingOperationException" :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception, "ConcurrentModificationException" :portkey.aws.workdocs.-2016-05-01/concurrent-modification-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-document :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-document-request) :ret clojure.core/true?)

(clojure.core/defn delete-custom-metadata ([delete-custom-metadata-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-custom-metadata-request delete-custom-metadata-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/delete-custom-metadata-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/resources/{ResourceId}/customMetadata", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-custom-metadata-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCustomMetadata", :http.request.configuration/output-deser-fn response-delete-custom-metadata-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-custom-metadata :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-custom-metadata-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/delete-custom-metadata-response))

(clojure.core/defn delete-comment ([delete-comment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-comment-request delete-comment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/documents/{DocumentId}/versions/{VersionId}/comment/{CommentId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/delete-comment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteComment", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "DocumentLockedForCommentsException" :portkey.aws.workdocs.-2016-05-01/document-locked-for-comments-exception}})))))
(clojure.spec.alpha/fdef delete-comment :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/delete-comment-request) :ret clojure.core/true?)

(clojure.core/defn update-user ([update-user-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-user-request update-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/update-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/users/{UserId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/update-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateUser", :http.request.configuration/output-deser-fn response-update-user-response, :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "IllegalUserStateException" :portkey.aws.workdocs.-2016-05-01/illegal-user-state-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "DeactivatingLastSystemUserException" :portkey.aws.workdocs.-2016-05-01/deactivating-last-system-user-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception}})))))
(clojure.spec.alpha/fdef update-user :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/update-user-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/update-user-response))

(clojure.core/defn update-folder ([update-folder-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-folder-request update-folder-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/folders/{FolderId}", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/update-folder-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateFolder", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"EntityNotExistsException" :portkey.aws.workdocs.-2016-05-01/entity-not-exists-exception, "LimitExceededException" :portkey.aws.workdocs.-2016-05-01/limit-exceeded-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception, "EntityAlreadyExistsException" :portkey.aws.workdocs.-2016-05-01/entity-already-exists-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "ProhibitedStateException" :portkey.aws.workdocs.-2016-05-01/prohibited-state-exception, "UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "ConflictingOperationException" :portkey.aws.workdocs.-2016-05-01/conflicting-operation-exception, "ConcurrentModificationException" :portkey.aws.workdocs.-2016-05-01/concurrent-modification-exception}})))))
(clojure.spec.alpha/fdef update-folder :args (clojure.spec.alpha/tuple :portkey.aws.workdocs.-2016-05-01/update-folder-request) :ret clojure.core/true?)

(clojure.core/defn describe-activities ([] (describe-activities {})) ([describe-activities-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-activities-request describe-activities-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.workdocs.-2016-05-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.workdocs.-2016-05-01/describe-activities-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/api/v1/activities", :http.request.configuration/version "2016-05-01", :http.request.configuration/service-id "WorkDocs", :http.request.spec/input-spec :portkey.aws.workdocs.-2016-05-01/describe-activities-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeActivities", :http.request.configuration/output-deser-fn response-describe-activities-response, :http.request.spec/error-spec {"UnauthorizedOperationException" :portkey.aws.workdocs.-2016-05-01/unauthorized-operation-exception, "UnauthorizedResourceAccessException" :portkey.aws.workdocs.-2016-05-01/unauthorized-resource-access-exception, "InvalidArgumentException" :portkey.aws.workdocs.-2016-05-01/invalid-argument-exception, "FailedDependencyException" :portkey.aws.workdocs.-2016-05-01/failed-dependency-exception, "ServiceUnavailableException" :portkey.aws.workdocs.-2016-05-01/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-activities :args (clojure.spec.alpha/? :portkey.aws.workdocs.-2016-05-01/describe-activities-request) :ret (clojure.spec.alpha/and :portkey.aws.workdocs.-2016-05-01/describe-activities-response))
