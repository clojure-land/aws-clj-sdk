(ns portkey.aws.redshift.-2012-12-01 (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "redshift", :region "us-gov-east-1"},
    :ssl-common-name "redshift.us-gov-east-1.amazonaws.com",
    :endpoint "https://redshift.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope {:service "redshift", :region "ap-northeast-1"},
    :ssl-common-name "redshift.ap-northeast-1.amazonaws.com",
    :endpoint "https://redshift.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "redshift", :region "eu-west-1"},
    :ssl-common-name "redshift.eu-west-1.amazonaws.com",
    :endpoint "https://redshift.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "redshift", :region "us-east-2"},
    :ssl-common-name "redshift.us-east-2.amazonaws.com",
    :endpoint "https://redshift.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "redshift", :region "ap-southeast-2"},
    :ssl-common-name "redshift.ap-southeast-2.amazonaws.com",
    :endpoint "https://redshift.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "redshift", :region "cn-north-1"},
    :ssl-common-name "redshift.cn-north-1.amazonaws.com.cn",
    :endpoint "https://redshift.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "redshift", :region "sa-east-1"},
    :ssl-common-name "redshift.sa-east-1.amazonaws.com",
    :endpoint "https://redshift.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "redshift", :region "ap-southeast-1"},
    :ssl-common-name "redshift.ap-southeast-1.amazonaws.com",
    :endpoint "https://redshift.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "redshift", :region "cn-northwest-1"},
    :ssl-common-name "redshift.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://redshift.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "redshift", :region "ap-northeast-2"},
    :ssl-common-name "redshift.ap-northeast-2.amazonaws.com",
    :endpoint "https://redshift.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "redshift", :region "eu-west-3"},
    :ssl-common-name "redshift.eu-west-3.amazonaws.com",
    :endpoint "https://redshift.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "redshift", :region "ca-central-1"},
    :ssl-common-name "redshift.ca-central-1.amazonaws.com",
    :endpoint "https://redshift.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "redshift", :region "eu-central-1"},
    :ssl-common-name "redshift.eu-central-1.amazonaws.com",
    :endpoint "https://redshift.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "redshift", :region "eu-west-2"},
    :ssl-common-name "redshift.eu-west-2.amazonaws.com",
    :endpoint "https://redshift.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "redshift", :region "us-gov-west-1"},
    :ssl-common-name "redshift.us-gov-west-1.amazonaws.com",
    :endpoint "https://redshift.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "redshift", :region "us-west-2"},
    :ssl-common-name "redshift.us-west-2.amazonaws.com",
    :endpoint "https://redshift.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "redshift", :region "us-east-1"},
    :ssl-common-name "redshift.us-east-1.amazonaws.com",
    :endpoint "https://redshift.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "redshift", :region "us-west-1"},
    :ssl-common-name "redshift.us-west-1.amazonaws.com",
    :endpoint "https://redshift.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "redshift", :region "ap-south-1"},
    :ssl-common-name "redshift.ap-south-1.amazonaws.com",
    :endpoint "https://redshift.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "redshift", :region "eu-north-1"},
    :ssl-common-name "redshift.eu-north-1.amazonaws.com",
    :endpoint "https://redshift.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-subnet-identifier-list)

(clojure.core/declare ser-parameters-list)

(clojure.core/declare ser-tag-value-list)

(clojure.core/declare ser-snapshot-sorting-entity)

(clojure.core/declare ser-source-ids-list)

(clojure.core/declare ser-schedule-definition-list)

(clojure.core/declare ser-parameter-apply-type)

(clojure.core/declare ser-source-type)

(clojure.core/declare ser-sort-by-order)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-snapshot-identifier-list)

(clojure.core/declare ser-attribute-name-list)

(clojure.core/declare ser-delete-cluster-snapshot-message)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-iam-role-arn-list)

(clojure.core/declare ser-string)

(clojure.core/declare ser-parameter)

(clojure.core/declare ser-vpc-security-group-id-list)

(clojure.core/declare ser-t-stamp)

(clojure.core/declare ser-event-categories-list)

(clojure.core/declare ser-snapshot-sorting-entity-list)

(clojure.core/declare ser-snapshot-attribute-to-sort-by)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-boolean-optional)

(clojure.core/declare ser-cluster-security-group-name-list)

(clojure.core/declare ser-delete-cluster-snapshot-message-list)

(clojure.core/declare ser-db-group-list)

(clojure.core/declare ser-integer-optional)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-subnet-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SubnetIdentifier"}))) input), :shape "SubnetIdentifierList", :type "list"})

(clojure.core/defn- ser-parameters-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter coll) #:http.request.field{:shape "Parameter", :location-name "Parameter"}))) input), :shape "ParametersList", :type "list"})

(clojure.core/defn- ser-tag-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "TagValue"}))) input), :shape "TagValueList", :type "list"})

(clojure.core/defn- ser-snapshot-sorting-entity [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-snapshot-attribute-to-sort-by (:attribute input)) #:http.request.field{:name "Attribute", :shape "SnapshotAttributeToSortBy"})], :shape "SnapshotSortingEntity", :type "structure"} (clojure.core/contains? input :sort-order) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sort-by-order (input :sort-order)) #:http.request.field{:name "SortOrder", :shape "SortByOrder"}))))

(clojure.core/defn- ser-source-ids-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SourceId"}))) input), :shape "SourceIdsList", :type "list"})

(clojure.core/defn- ser-schedule-definition-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ScheduleDefinition"}))) input), :shape "ScheduleDefinitionList", :type "list"})

(clojure.core/defn- ser-parameter-apply-type [input] #:http.request.field{:value (clojure.core/get {"static" "static", :static "static", "dynamic" "dynamic", :dynamic "dynamic"} input), :shape "ParameterApplyType"})

(clojure.core/defn- ser-source-type [input] #:http.request.field{:value (clojure.core/get {"cluster" "cluster", :cluster "cluster", "cluster-parameter-group" "cluster-parameter-group", :clusterparametergroup "cluster-parameter-group", "cluster-security-group" "cluster-security-group", :clustersecuritygroup "cluster-security-group", "cluster-snapshot" "cluster-snapshot", :clustersnapshot "cluster-snapshot"} input), :shape "SourceType"})

(clojure.core/defn- ser-sort-by-order [input] #:http.request.field{:value (clojure.core/get {"ASC" "ASC", :asc "ASC", "DESC" "DESC", :desc "DESC"} input), :shape "SortByOrder"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag", :location-name "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "TagKey"}))) input), :shape "TagKeyList", :type "list"})

(clojure.core/defn- ser-snapshot-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "String"}))) input), :shape "SnapshotIdentifierList", :type "list"})

(clojure.core/defn- ser-attribute-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "AttributeName"}))) input), :shape "AttributeNameList", :type "list"})

(clojure.core/defn- ser-delete-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:snapshot-identifier input)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})], :shape "DeleteClusterSnapshotMessage", :type "structure"} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-iam-role-arn-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "IamRoleArn"}))) input), :shape "IamRoleArnList", :type "list"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Parameter", :type "structure"} (clojure.core/contains? input :data-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :data-type)) #:http.request.field{:name "DataType", :shape "String"})) (clojure.core/contains? input :parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-name)) #:http.request.field{:name "ParameterName", :shape "String"})) (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :minimum-engine-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :minimum-engine-version)) #:http.request.field{:name "MinimumEngineVersion", :shape "String"})) (clojure.core/contains? input :allowed-values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :allowed-values)) #:http.request.field{:name "AllowedValues", :shape "String"})) (clojure.core/contains? input :apply-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-apply-type (input :apply-type)) #:http.request.field{:name "ApplyType", :shape "ParameterApplyType"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :is-modifiable) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :is-modifiable)) #:http.request.field{:name "IsModifiable", :shape "Boolean"})) (clojure.core/contains? input :parameter-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-value)) #:http.request.field{:name "ParameterValue", :shape "String"}))))

(clojure.core/defn- ser-vpc-security-group-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpcSecurityGroupId"}))) input), :shape "VpcSecurityGroupIdList", :type "list"})

(clojure.core/defn- ser-t-stamp [input] #:http.request.field{:value input, :shape "TStamp"})

(clojure.core/defn- ser-event-categories-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "EventCategory"}))) input), :shape "EventCategoriesList", :type "list"})

(clojure.core/defn- ser-snapshot-sorting-entity-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-snapshot-sorting-entity coll) #:http.request.field{:shape "SnapshotSortingEntity", :location-name "SnapshotSortingEntity"}))) input), :shape "SnapshotSortingEntityList", :type "list"})

(clojure.core/defn- ser-snapshot-attribute-to-sort-by [input] #:http.request.field{:value (clojure.core/get {"SOURCE_TYPE" "SOURCE_TYPE", :source-type "SOURCE_TYPE", "TOTAL_SIZE" "TOTAL_SIZE", :total-size "TOTAL_SIZE", "CREATE_TIME" "CREATE_TIME", :create-time "CREATE_TIME"} input), :shape "SnapshotAttributeToSortBy"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String"}))))

(clojure.core/defn- ser-boolean-optional [input] #:http.request.field{:value input, :shape "BooleanOptional"})

(clojure.core/defn- ser-cluster-security-group-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ClusterSecurityGroupName"}))) input), :shape "ClusterSecurityGroupNameList", :type "list"})

(clojure.core/defn- ser-delete-cluster-snapshot-message-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-delete-cluster-snapshot-message coll) #:http.request.field{:shape "DeleteClusterSnapshotMessage", :location-name "DeleteClusterSnapshotMessage"}))) input), :shape "DeleteClusterSnapshotMessageList", :type "list"})

(clojure.core/defn- ser-db-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "DbGroup"}))) input), :shape "DbGroupList", :type "list"})

(clojure.core/defn- ser-integer-optional [input] #:http.request.field{:value input, :shape "IntegerOptional"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-describe-table-restore-status-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :table-restore-request-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :table-restore-request-id)) #:http.request.field{:name "TableRestoreRequestId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"}) (clojure.core/into (ser-string (input :master-username)) #:http.request.field{:name "MasterUsername", :shape "String"}) (clojure.core/into (ser-string (input :master-user-password)) #:http.request.field{:name "MasterUserPassword", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "BooleanOptional"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :number-of-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :db-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :db-name)) #:http.request.field{:name "DBName", :shape "String"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :iam-roles)) #:http.request.field{:name "IamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :snapshot-schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-schedule-identifier)) #:http.request.field{:name "SnapshotScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-enable-logging-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :bucket-name)) #:http.request.field{:name "BucketName", :shape "String"})]} (clojure.core/contains? input :s-3-key-prefix) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-key-prefix)) #:http.request.field{:name "S3KeyPrefix", :shape "String"}))))

(clojure.core/defn- req-describe-hsm-client-certificates-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-snapshot-schedule-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :disassociate-schedule) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :disassociate-schedule)) #:http.request.field{:name "DisassociateSchedule", :shape "BooleanOptional"}))))

(clojure.core/defn- req-resize-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-integer (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "Integer"})]} (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :classic) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :classic)) #:http.request.field{:name "Classic", :shape "BooleanOptional"}))))

(clojure.core/defn- req-enable-snapshot-copy-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :destination-region)) #:http.request.field{:name "DestinationRegion", :shape "String"})]} (clojure.core/contains? input :retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :retention-period)) #:http.request.field{:name "RetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :snapshot-copy-grant-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"}))))

(clojure.core/defn- req-describe-clusters-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-revoke-snapshot-access-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :account-with-restore-access)) #:http.request.field{:name "AccountWithRestoreAccess", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-event-subscriptions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :subscription-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-restore-from-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :owner-account) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :owner-account)) #:http.request.field{:name "OwnerAccount", :shape "String"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :iam-roles)) #:http.request.field{:name "IamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :snapshot-schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-schedule-identifier)) #:http.request.field{:name "SnapshotScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-hsm-configurations-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-describe-cluster-parameter-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-db-revision-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :revision-target)) #:http.request.field{:name "RevisionTarget", :shape "String"})]}))

(clojure.core/defn- req-authorize-cluster-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]} (clojure.core/contains? input :cidrip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidrip)) #:http.request.field{:name "CIDRIP", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"}))))

(clojure.core/defn- req-describe-resize-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-cancel-resize-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-cluster-db-revisions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-default-cluster-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-family)) #:http.request.field{:name "ParameterGroupFamily", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-modify-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean"}))))

(clojure.core/defn- req-modify-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}))))

(clojure.core/defn- req-disable-logging-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-reserved-node-offerings-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-node-offering-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-node-offering-id)) #:http.request.field{:name "ReservedNodeOfferingId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-snapshot-schedules-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"}))))

(clojure.core/defn- req-accept-reserved-node-exchange-input-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"}) (clojure.core/into (ser-string (input :target-reserved-node-offering-id)) #:http.request.field{:name "TargetReservedNodeOfferingId", :shape "String"})]}))

(clojure.core/defn- req-describe-events-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-identifier)) #:http.request.field{:name "SourceIdentifier", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-type (input :source-type)) #:http.request.field{:name "SourceType", :shape "SourceType"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration)) #:http.request.field{:name "Duration", :shape "IntegerOptional"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-batch-delete-cluster-snapshots-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-delete-cluster-snapshot-message-list (input :identifiers)) #:http.request.field{:name "Identifiers", :shape "DeleteClusterSnapshotMessageList"})]}))

(clojure.core/defn- req-revoke-cluster-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]} (clojure.core/contains? input :cidrip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidrip)) #:http.request.field{:name "CIDRIP", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"}))))

(clojure.core/defn- req-disable-snapshot-copy-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-delete-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})]}))

(clojure.core/defn- req-describe-cluster-security-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"}) (clojure.core/into (ser-parameters-list (input :parameters)) #:http.request.field{:name "Parameters", :shape "ParametersList"})]}))

(clojure.core/defn- req-create-tags-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})]}))

(clojure.core/defn- req-describe-cluster-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]} (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-tags-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :resource-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"})) (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-describe-cluster-snapshots-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"})) (clojure.core/contains? input :snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :owner-account) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :owner-account)) #:http.request.field{:name "OwnerAccount", :shape "String"})) (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :snapshot-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-type)) #:http.request.field{:name "SnapshotType", :shape "String"})) (clojure.core/contains? input :cluster-exists) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :cluster-exists)) #:http.request.field{:name "ClusterExists", :shape "BooleanOptional"})) (clojure.core/contains? input :sorting-entities) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-sorting-entity-list (input :sorting-entities)) #:http.request.field{:name "SortingEntities", :shape "SnapshotSortingEntityList"}))))

(clojure.core/defn- req-describe-logging-status-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-delete-snapshot-copy-grant-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-cluster-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-reserved-nodes-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-node-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})]}))

(clojure.core/defn- req-delete-snapshot-schedule-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-modify-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "BooleanOptional"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :number-of-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :master-user-password) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :master-user-password)) #:http.request.field{:name "MasterUserPassword", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :new-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :new-cluster-identifier)) #:http.request.field{:name "NewClusterIdentifier", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-snapshot-copy-grants-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :snapshot-copy-grant-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-delete-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :skip-final-cluster-snapshot) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :skip-final-cluster-snapshot)) #:http.request.field{:name "SkipFinalClusterSnapshot", :shape "Boolean"})) (clojure.core/contains? input :final-cluster-snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :final-cluster-snapshot-identifier)) #:http.request.field{:name "FinalClusterSnapshotIdentifier", :shape "String"})) (clojure.core/contains? input :final-cluster-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :final-cluster-snapshot-retention-period)) #:http.request.field{:name "FinalClusterSnapshotRetentionPeriod", :shape "IntegerOptional"}))))

(clojure.core/defn- req-describe-cluster-tracks-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-reboot-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"}) (clojure.core/into (ser-string (input :sns-topic-arn)) #:http.request.field{:name "SnsTopicArn", :shape "String"})]} (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"})) (clojure.core/contains? input :source-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-ids-list (input :source-ids)) #:http.request.field{:name "SourceIds", :shape "SourceIdsList"})) (clojure.core/contains? input :event-categories) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-categories-list (input :event-categories)) #:http.request.field{:name "EventCategories", :shape "EventCategoriesList"})) (clojure.core/contains? input :severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :severity)) #:http.request.field{:name "Severity", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enabled)) #:http.request.field{:name "Enabled", :shape "BooleanOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-orderable-cluster-options-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-rotate-encryption-key-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-modify-snapshot-schedule-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"}) (clojure.core/into (ser-schedule-definition-list (input :schedule-definitions)) #:http.request.field{:name "ScheduleDefinitions", :shape "ScheduleDefinitionList"})]}))

(clojure.core/defn- req-create-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"}) (clojure.core/into (ser-string (input :parameter-group-family)) #:http.request.field{:name "ParameterGroupFamily", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-create-hsm-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}) (clojure.core/into (ser-string (input :hsm-ip-address)) #:http.request.field{:name "HsmIpAddress", :shape "String"}) (clojure.core/into (ser-string (input :hsm-partition-name)) #:http.request.field{:name "HsmPartitionName", :shape "String"}) (clojure.core/into (ser-string (input :hsm-partition-password)) #:http.request.field{:name "HsmPartitionPassword", :shape "String"}) (clojure.core/into (ser-string (input :hsm-server-public-certificate)) #:http.request.field{:name "HsmServerPublicCertificate", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-tags-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})]}))

(clojure.core/defn- req-modify-snapshot-copy-retention-period-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-integer (input :retention-period)) #:http.request.field{:name "RetentionPeriod", :shape "Integer"})]} (clojure.core/contains? input :manual) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :manual)) #:http.request.field{:name "Manual", :shape "Boolean"}))))

(clojure.core/defn- req-delete-hsm-client-certificate-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-event-categories-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"}))))

(clojure.core/defn- req-describe-account-attributes-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :attribute-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-name-list (input :attribute-names)) #:http.request.field{:name "AttributeNames", :shape "AttributeNameList"}))))

(clojure.core/defn- req-copy-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :source-snapshot-identifier)) #:http.request.field{:name "SourceSnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :target-snapshot-identifier)) #:http.request.field{:name "TargetSnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :source-snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-snapshot-cluster-identifier)) #:http.request.field{:name "SourceSnapshotClusterIdentifier", :shape "String"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"}))))

(clojure.core/defn- req-get-reserved-node-exchange-offerings-input-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-cluster-subnet-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-create-hsm-client-certificate-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-restore-table-from-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :source-database-name)) #:http.request.field{:name "SourceDatabaseName", :shape "String"}) (clojure.core/into (ser-string (input :source-table-name)) #:http.request.field{:name "SourceTableName", :shape "String"}) (clojure.core/into (ser-string (input :new-table-name)) #:http.request.field{:name "NewTableName", :shape "String"})]} (clojure.core/contains? input :source-schema-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-schema-name)) #:http.request.field{:name "SourceSchemaName", :shape "String"})) (clojure.core/contains? input :target-database-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-database-name)) #:http.request.field{:name "TargetDatabaseName", :shape "String"})) (clojure.core/contains? input :target-schema-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-schema-name)) #:http.request.field{:name "TargetSchemaName", :shape "String"}))))

(clojure.core/defn- req-modify-cluster-iam-roles-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :add-iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :add-iam-roles)) #:http.request.field{:name "AddIamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :remove-iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :remove-iam-roles)) #:http.request.field{:name "RemoveIamRoles", :shape "IamRoleArnList"}))))

(clojure.core/defn- req-describe-cluster-versions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-family) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-family)) #:http.request.field{:name "ClusterParameterGroupFamily", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-snapshot-schedule-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :schedule-definitions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-definition-list (input :schedule-definitions)) #:http.request.field{:name "ScheduleDefinitions", :shape "ScheduleDefinitionList"})) (clojure.core/contains? input :schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :schedule-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-description)) #:http.request.field{:name "ScheduleDescription", :shape "String"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :dry-run)) #:http.request.field{:name "DryRun", :shape "BooleanOptional"})) (clojure.core/contains? input :next-invocations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :next-invocations)) #:http.request.field{:name "NextInvocations", :shape "IntegerOptional"}))))

(clojure.core/defn- req-create-snapshot-copy-grant-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})]} (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-purchase-reserved-node-offering-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-offering-id)) #:http.request.field{:name "ReservedNodeOfferingId", :shape "String"})]} (clojure.core/contains? input :node-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :node-count)) #:http.request.field{:name "NodeCount", :shape "IntegerOptional"}))))

(clojure.core/defn- req-authorize-snapshot-access-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :account-with-restore-access)) #:http.request.field{:name "AccountWithRestoreAccess", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-reset-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]} (clojure.core/contains? input :reset-all-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reset-all-parameters)) #:http.request.field{:name "ResetAllParameters", :shape "Boolean"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters-list (input :parameters)) #:http.request.field{:name "Parameters", :shape "ParametersList"}))))

(clojure.core/defn- req-batch-modify-cluster-snapshots-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-snapshot-identifier-list (input :snapshot-identifier-list)) #:http.request.field{:name "SnapshotIdentifierList", :shape "SnapshotIdentifierList"})]} (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean"}))))

(clojure.core/defn- req-delete-hsm-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-modify-cluster-maintenance-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :defer-maintenance) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :defer-maintenance)) #:http.request.field{:name "DeferMaintenance", :shape "BooleanOptional"})) (clojure.core/contains? input :defer-maintenance-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :defer-maintenance-identifier)) #:http.request.field{:name "DeferMaintenanceIdentifier", :shape "String"})) (clojure.core/contains? input :defer-maintenance-start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :defer-maintenance-start-time)) #:http.request.field{:name "DeferMaintenanceStartTime", :shape "TStamp"})) (clojure.core/contains? input :defer-maintenance-end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :defer-maintenance-end-time)) #:http.request.field{:name "DeferMaintenanceEndTime", :shape "TStamp"})) (clojure.core/contains? input :defer-maintenance-duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :defer-maintenance-duration)) #:http.request.field{:name "DeferMaintenanceDuration", :shape "IntegerOptional"}))))

(clojure.core/defn- req-get-cluster-credentials-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :db-user)) #:http.request.field{:name "DbUser", :shape "String"}) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :db-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :db-name)) #:http.request.field{:name "DbName", :shape "String"})) (clojure.core/contains? input :duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration-seconds)) #:http.request.field{:name "DurationSeconds", :shape "IntegerOptional"})) (clojure.core/contains? input :auto-create) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-create)) #:http.request.field{:name "AutoCreate", :shape "BooleanOptional"})) (clojure.core/contains? input :db-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-db-group-list (input :db-groups)) #:http.request.field{:name "DbGroups", :shape "DbGroupList"}))))

(clojure.core/defn- req-modify-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})]} (clojure.core/contains? input :sns-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sns-topic-arn)) #:http.request.field{:name "SnsTopicArn", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"})) (clojure.core/contains? input :source-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-ids-list (input :source-ids)) #:http.request.field{:name "SourceIds", :shape "SourceIdsList"})) (clojure.core/contains? input :event-categories) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-categories-list (input :event-categories)) #:http.request.field{:name "EventCategories", :shape "EventCategoriesList"})) (clojure.core/contains? input :severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :severity)) #:http.request.field{:name "Severity", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enabled)) #:http.request.field{:name "Enabled", :shape "BooleanOptional"}))))

(clojure.core/declare deser-vpc-security-group-membership-list)

(clojure.core/declare deser-snapshot-copy-grant-list)

(clojure.core/declare deser-hsm-configuration)

(clojure.core/declare deser-double)

(clojure.core/declare deser-maintenance-track)

(clojure.core/declare deser-parameters-list)

(clojure.core/declare deser-ec-2-security-group-list)

(clojure.core/declare deser-table-restore-status-type)

(clojure.core/declare deser-import-tables-not-started)

(clojure.core/declare deser-cluster-node)

(clojure.core/declare deser-attribute-list)

(clojure.core/declare deser-supported-operation-list)

(clojure.core/declare deser-reserved-node)

(clojure.core/declare deser-double-optional)

(clojure.core/declare deser-source-ids-list)

(clojure.core/declare deser-schedule-definition-list)

(clojure.core/declare deser-cluster-parameter-status-list)

(clojure.core/declare deser-snapshot-list)

(clojure.core/declare deser-associated-cluster-list)

(clojure.core/declare deser-subnet)

(clojure.core/declare deser-attribute-value-target)

(clojure.core/declare deser-event-info-map-list)

(clojure.core/declare deser-supported-platforms-list)

(clojure.core/declare deser-event-subscription)

(clojure.core/declare deser-cluster-snapshot-copy-status)

(clojure.core/declare deser-deferred-maintenance-windows-list)

(clojure.core/declare deser-reserved-node-offering-type)

(clojure.core/declare deser-orderable-cluster-options-list)

(clojure.core/declare deser-supported-operation)

(clojure.core/declare deser-reserved-node-offering-list)

(clojure.core/declare deser-parameter-apply-type)

(clojure.core/declare deser-ip-range-list)

(clojure.core/declare deser-snapshot-schedule-list)

(clojure.core/declare deser-event-list)

(clojure.core/declare deser-hsm-client-certificate)

(clojure.core/declare deser-source-type)

(clojure.core/declare deser-batch-snapshot-operation-error-list)

(clojure.core/declare deser-event)

(clojure.core/declare deser-availability-zone-list)

(clojure.core/declare deser-availability-zone)

(clojure.core/declare deser-revision-targets-list)

(clojure.core/declare deser-supported-platform)

(clojure.core/declare deser-sensitive-string)

(clojure.core/declare deser-cluster-list)

(clojure.core/declare deser-cluster-security-groups)

(clojure.core/declare deser-recurring-charge)

(clojure.core/declare deser-track-list)

(clojure.core/declare deser-batch-snapshot-operation-errors)

(clojure.core/declare deser-cluster-security-group-membership)

(clojure.core/declare deser-cluster-iam-role)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-cluster-db-revisions-list)

(clojure.core/declare deser-cluster)

(clojure.core/declare deser-hsm-client-certificate-list)

(clojure.core/declare deser-reserved-node-offering)

(clojure.core/declare deser-accounts-with-restore-access-list)

(clojure.core/declare deser-vpc-security-group-membership)

(clojure.core/declare deser-event-info-map)

(clojure.core/declare deser-update-target)

(clojure.core/declare deser-data-transfer-progress)

(clojure.core/declare deser-pending-actions-list)

(clojure.core/declare deser-snapshot-identifier-list)

(clojure.core/declare deser-ec-2-security-group)

(clojure.core/declare deser-event-categories-map-list)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-string)

(clojure.core/declare deser-parameter)

(clojure.core/declare deser-cluster-parameter-status)

(clojure.core/declare deser-cluster-parameter-group-status)

(clojure.core/declare deser-cluster-security-group-membership-list)

(clojure.core/declare deser-restore-status)

(clojure.core/declare deser-snapshot)

(clojure.core/declare deser-t-stamp)

(clojure.core/declare deser-cluster-subnet-groups)

(clojure.core/declare deser-event-categories-map)

(clojure.core/declare deser-cluster-parameter-group-status-list)

(clojure.core/declare deser-recurring-charge-list)

(clojure.core/declare deser-event-categories-list)

(clojure.core/declare deser-account-with-restore-access)

(clojure.core/declare deser-table-restore-status-list)

(clojure.core/declare deser-cluster-version)

(clojure.core/declare deser-snapshot-schedule)

(clojure.core/declare deser-endpoint)

(clojure.core/declare deser-table-restore-status)

(clojure.core/declare deser-long)

(clojure.core/declare deser-import-tables-completed)

(clojure.core/declare deser-reserved-node-list)

(clojure.core/declare deser-import-tables-in-progress)

(clojure.core/declare deser-snapshot-error-message)

(clojure.core/declare deser-attribute-value-list)

(clojure.core/declare deser-ip-range)

(clojure.core/declare deser-cluster-subnet-group)

(clojure.core/declare deser-cluster-nodes-list)

(clojure.core/declare deser-resize-info)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-cluster-db-revision)

(clojure.core/declare deser-schedule-state)

(clojure.core/declare deser-boolean-optional)

(clojure.core/declare deser-cluster-iam-role-list)

(clojure.core/declare deser-deferred-maintenance-window)

(clojure.core/declare deser-tagged-resource)

(clojure.core/declare deser-restorable-node-type-list)

(clojure.core/declare deser-cluster-associated-to-schedule)

(clojure.core/declare deser-eligible-tracks-to-update-list)

(clojure.core/declare deser-scheduled-snapshot-time-list)

(clojure.core/declare deser-cluster-parameter-group)

(clojure.core/declare deser-event-subscriptions-list)

(clojure.core/declare deser-hsm-configuration-list)

(clojure.core/declare deser-long-optional)

(clojure.core/declare deser-cluster-version-list)

(clojure.core/declare deser-integer-optional)

(clojure.core/declare deser-hsm-status)

(clojure.core/declare deser-elastic-ip-status)

(clojure.core/declare deser-orderable-cluster-option)

(clojure.core/declare deser-revision-target)

(clojure.core/declare deser-cluster-security-group)

(clojure.core/declare deser-pending-modified-values)

(clojure.core/declare deser-subnet-list)

(clojure.core/declare deser-account-attribute)

(clojure.core/declare deser-snapshot-copy-grant)

(clojure.core/declare deser-parameter-group-list)

(clojure.core/declare deser-tagged-resource-list)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-default-cluster-parameters)

(clojure.core/defn- deser-vpc-security-group-membership-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-security-group-membership coll))) input))

(clojure.core/defn- deser-snapshot-copy-grant-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-copy-grant coll))) input))

(clojure.core/defn- deser-hsm-configuration [input] (clojure.core/let [letvar513613 {"HsmConfigurationIdentifier" (portkey.aws/search-for-tag input "HsmConfigurationIdentifier" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "HsmIpAddress" (portkey.aws/search-for-tag input "HsmIpAddress" :flattened? nil :xmlAttribute? nil), "HsmPartitionName" (portkey.aws/search-for-tag input "HsmPartitionName" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar513613 "HsmConfigurationIdentifier") (clojure.core/assoc :hsm-configuration-identifier (deser-string (clojure.core/get-in letvar513613 ["HsmConfigurationIdentifier" :content]))) (letvar513613 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar513613 ["Description" :content]))) (letvar513613 "HsmIpAddress") (clojure.core/assoc :hsm-ip-address (deser-string (clojure.core/get-in letvar513613 ["HsmIpAddress" :content]))) (letvar513613 "HsmPartitionName") (clojure.core/assoc :hsm-partition-name (deser-string (clojure.core/get-in letvar513613 ["HsmPartitionName" :content]))) (letvar513613 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar513613 ["Tags" :content]))))))

(clojure.core/defn- deser-double [input] (java.lang.Double. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-maintenance-track [input] (clojure.core/let [letvar513723 {"MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "DatabaseVersion" (portkey.aws/search-for-tag input "DatabaseVersion" :flattened? nil :xmlAttribute? nil), "UpdateTargets" (portkey.aws/search-for-tag input "UpdateTargets" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar513723 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar513723 ["MaintenanceTrackName" :content]))) (letvar513723 "DatabaseVersion") (clojure.core/assoc :database-version (deser-string (clojure.core/get-in letvar513723 ["DatabaseVersion" :content]))) (letvar513723 "UpdateTargets") (clojure.core/assoc :update-targets (deser-eligible-tracks-to-update-list (clojure.core/get-in letvar513723 ["UpdateTargets" :content]))))))

(clojure.core/defn- deser-parameters-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter coll))) input))

(clojure.core/defn- deser-ec-2-security-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ec-2-security-group coll))) input))

(clojure.core/defn- deser-table-restore-status-type [input] (clojure.core/get {"PENDING" :pending, "IN_PROGRESS" :in-progress, "SUCCEEDED" :succeeded, "FAILED" :failed, "CANCELED" :canceled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-import-tables-not-started [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cluster-node [input] (clojure.core/let [letvar513887 {"NodeRole" (portkey.aws/search-for-tag input "NodeRole" :flattened? nil :xmlAttribute? nil), "PrivateIPAddress" (portkey.aws/search-for-tag input "PrivateIPAddress" :flattened? nil :xmlAttribute? nil), "PublicIPAddress" (portkey.aws/search-for-tag input "PublicIPAddress" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar513887 "NodeRole") (clojure.core/assoc :node-role (deser-string (clojure.core/get-in letvar513887 ["NodeRole" :content]))) (letvar513887 "PrivateIPAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar513887 ["PrivateIPAddress" :content]))) (letvar513887 "PublicIPAddress") (clojure.core/assoc :public-ip-address (deser-string (clojure.core/get-in letvar513887 ["PublicIPAddress" :content]))))))

(clojure.core/defn- deser-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-attribute coll))) input))

(clojure.core/defn- deser-supported-operation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-supported-operation coll))) input))

(clojure.core/defn- deser-reserved-node [input] (clojure.core/let [letvar514029 {"CurrencyCode" (portkey.aws/search-for-tag input "CurrencyCode" :flattened? nil :xmlAttribute? nil), "StartTime" (portkey.aws/search-for-tag input "StartTime" :flattened? nil :xmlAttribute? nil), "NodeCount" (portkey.aws/search-for-tag input "NodeCount" :flattened? nil :xmlAttribute? nil), "FixedPrice" (portkey.aws/search-for-tag input "FixedPrice" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingType" (portkey.aws/search-for-tag input "ReservedNodeOfferingType" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingId" (portkey.aws/search-for-tag input "ReservedNodeOfferingId" :flattened? nil :xmlAttribute? nil), "Duration" (portkey.aws/search-for-tag input "Duration" :flattened? nil :xmlAttribute? nil), "ReservedNodeId" (portkey.aws/search-for-tag input "ReservedNodeId" :flattened? nil :xmlAttribute? nil), "UsagePrice" (portkey.aws/search-for-tag input "UsagePrice" :flattened? nil :xmlAttribute? nil), "State" (portkey.aws/search-for-tag input "State" :flattened? nil :xmlAttribute? nil), "RecurringCharges" (portkey.aws/search-for-tag input "RecurringCharges" :flattened? nil :xmlAttribute? nil), "OfferingType" (portkey.aws/search-for-tag input "OfferingType" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514029 "CurrencyCode") (clojure.core/assoc :currency-code (deser-string (clojure.core/get-in letvar514029 ["CurrencyCode" :content]))) (letvar514029 "StartTime") (clojure.core/assoc :start-time (deser-t-stamp (clojure.core/get-in letvar514029 ["StartTime" :content]))) (letvar514029 "NodeCount") (clojure.core/assoc :node-count (deser-integer (clojure.core/get-in letvar514029 ["NodeCount" :content]))) (letvar514029 "FixedPrice") (clojure.core/assoc :fixed-price (deser-double (clojure.core/get-in letvar514029 ["FixedPrice" :content]))) (letvar514029 "ReservedNodeOfferingType") (clojure.core/assoc :reserved-node-offering-type (deser-reserved-node-offering-type (clojure.core/get-in letvar514029 ["ReservedNodeOfferingType" :content]))) (letvar514029 "ReservedNodeOfferingId") (clojure.core/assoc :reserved-node-offering-id (deser-string (clojure.core/get-in letvar514029 ["ReservedNodeOfferingId" :content]))) (letvar514029 "Duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar514029 ["Duration" :content]))) (letvar514029 "ReservedNodeId") (clojure.core/assoc :reserved-node-id (deser-string (clojure.core/get-in letvar514029 ["ReservedNodeId" :content]))) (letvar514029 "UsagePrice") (clojure.core/assoc :usage-price (deser-double (clojure.core/get-in letvar514029 ["UsagePrice" :content]))) (letvar514029 "State") (clojure.core/assoc :state (deser-string (clojure.core/get-in letvar514029 ["State" :content]))) (letvar514029 "RecurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charge-list (clojure.core/get-in letvar514029 ["RecurringCharges" :content]))) (letvar514029 "OfferingType") (clojure.core/assoc :offering-type (deser-string (clojure.core/get-in letvar514029 ["OfferingType" :content]))) (letvar514029 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar514029 ["NodeType" :content]))))))

(clojure.core/defn- deser-double-optional [input] (java.lang.Double. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-source-ids-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-schedule-definition-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cluster-parameter-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-parameter-status coll))) input))

(clojure.core/defn- deser-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot coll))) input))

(clojure.core/defn- deser-associated-cluster-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-associated-to-schedule coll))) input))

(clojure.core/defn- deser-subnet [input] (clojure.core/let [letvar514224 {"SubnetIdentifier" (portkey.aws/search-for-tag input "SubnetIdentifier" :flattened? nil :xmlAttribute? nil), "SubnetAvailabilityZone" (portkey.aws/search-for-tag input "SubnetAvailabilityZone" :flattened? nil :xmlAttribute? nil), "SubnetStatus" (portkey.aws/search-for-tag input "SubnetStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514224 "SubnetIdentifier") (clojure.core/assoc :subnet-identifier (deser-string (clojure.core/get-in letvar514224 ["SubnetIdentifier" :content]))) (letvar514224 "SubnetAvailabilityZone") (clojure.core/assoc :subnet-availability-zone (deser-availability-zone (clojure.core/get-in letvar514224 ["SubnetAvailabilityZone" :content]))) (letvar514224 "SubnetStatus") (clojure.core/assoc :subnet-status (deser-string (clojure.core/get-in letvar514224 ["SubnetStatus" :content]))))))

(clojure.core/defn- deser-attribute-value-target [input] (clojure.core/let [letvar514332 {"AttributeValue" (portkey.aws/search-for-tag input "AttributeValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514332 "AttributeValue") (clojure.core/assoc :attribute-value (deser-string (clojure.core/get-in letvar514332 ["AttributeValue" :content]))))))

(clojure.core/defn- deser-event-info-map-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event-info-map coll))) input))

(clojure.core/defn- deser-supported-platforms-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-supported-platform coll))) input))

(clojure.core/defn- deser-event-subscription [input] (clojure.core/let [letvar514474 {"Severity" (portkey.aws/search-for-tag input "Severity" :flattened? nil :xmlAttribute? nil), "SourceIdsList" (portkey.aws/search-for-tag input "SourceIdsList" :flattened? nil :xmlAttribute? nil), "CustomerAwsId" (portkey.aws/search-for-tag input "CustomerAwsId" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Enabled" (portkey.aws/search-for-tag input "Enabled" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "SnsTopicArn" (portkey.aws/search-for-tag input "SnsTopicArn" :flattened? nil :xmlAttribute? nil), "EventCategoriesList" (portkey.aws/search-for-tag input "EventCategoriesList" :flattened? nil :xmlAttribute? nil), "CustSubscriptionId" (portkey.aws/search-for-tag input "CustSubscriptionId" :flattened? nil :xmlAttribute? nil), "SubscriptionCreationTime" (portkey.aws/search-for-tag input "SubscriptionCreationTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514474 "Severity") (clojure.core/assoc :severity (deser-string (clojure.core/get-in letvar514474 ["Severity" :content]))) (letvar514474 "SourceIdsList") (clojure.core/assoc :source-ids-list (deser-source-ids-list (clojure.core/get-in letvar514474 ["SourceIdsList" :content]))) (letvar514474 "CustomerAwsId") (clojure.core/assoc :customer-aws-id (deser-string (clojure.core/get-in letvar514474 ["CustomerAwsId" :content]))) (letvar514474 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar514474 ["Tags" :content]))) (letvar514474 "SourceType") (clojure.core/assoc :source-type (deser-string (clojure.core/get-in letvar514474 ["SourceType" :content]))) (letvar514474 "Enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar514474 ["Enabled" :content]))) (letvar514474 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar514474 ["Status" :content]))) (letvar514474 "SnsTopicArn") (clojure.core/assoc :sns-topic-arn (deser-string (clojure.core/get-in letvar514474 ["SnsTopicArn" :content]))) (letvar514474 "EventCategoriesList") (clojure.core/assoc :event-categories-list (deser-event-categories-list (clojure.core/get-in letvar514474 ["EventCategoriesList" :content]))) (letvar514474 "CustSubscriptionId") (clojure.core/assoc :cust-subscription-id (deser-string (clojure.core/get-in letvar514474 ["CustSubscriptionId" :content]))) (letvar514474 "SubscriptionCreationTime") (clojure.core/assoc :subscription-creation-time (deser-t-stamp (clojure.core/get-in letvar514474 ["SubscriptionCreationTime" :content]))))))

(clojure.core/defn- deser-cluster-snapshot-copy-status [input] (clojure.core/let [letvar514582 {"DestinationRegion" (portkey.aws/search-for-tag input "DestinationRegion" :flattened? nil :xmlAttribute? nil), "RetentionPeriod" (portkey.aws/search-for-tag input "RetentionPeriod" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "ManualSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "SnapshotCopyGrantName" (portkey.aws/search-for-tag input "SnapshotCopyGrantName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514582 "DestinationRegion") (clojure.core/assoc :destination-region (deser-string (clojure.core/get-in letvar514582 ["DestinationRegion" :content]))) (letvar514582 "RetentionPeriod") (clojure.core/assoc :retention-period (deser-long (clojure.core/get-in letvar514582 ["RetentionPeriod" :content]))) (letvar514582 "ManualSnapshotRetentionPeriod") (clojure.core/assoc :manual-snapshot-retention-period (deser-integer (clojure.core/get-in letvar514582 ["ManualSnapshotRetentionPeriod" :content]))) (letvar514582 "SnapshotCopyGrantName") (clojure.core/assoc :snapshot-copy-grant-name (deser-string (clojure.core/get-in letvar514582 ["SnapshotCopyGrantName" :content]))))))

(clojure.core/defn- deser-deferred-maintenance-windows-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-deferred-maintenance-window coll))) input))

(clojure.core/defn- deser-reserved-node-offering-type [input] (clojure.core/get {"Regular" :regular, "Upgradable" :upgradable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-orderable-cluster-options-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-orderable-cluster-option coll))) input))

(clojure.core/defn- deser-supported-operation [input] (clojure.core/let [letvar514729 {"OperationName" (portkey.aws/search-for-tag input "OperationName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514729 "OperationName") (clojure.core/assoc :operation-name (deser-string (clojure.core/get-in letvar514729 ["OperationName" :content]))))))

(clojure.core/defn- deser-reserved-node-offering-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-node-offering coll))) input))

(clojure.core/defn- deser-parameter-apply-type [input] (clojure.core/get {"static" :static, "dynamic" :dynamic} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ip-range-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ip-range coll))) input))

(clojure.core/defn- deser-snapshot-schedule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-schedule coll))) input))

(clojure.core/defn- deser-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event coll))) input))

(clojure.core/defn- deser-hsm-client-certificate [input] (clojure.core/let [letvar514910 {"HsmClientCertificateIdentifier" (portkey.aws/search-for-tag input "HsmClientCertificateIdentifier" :flattened? nil :xmlAttribute? nil), "HsmClientCertificatePublicKey" (portkey.aws/search-for-tag input "HsmClientCertificatePublicKey" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar514910 "HsmClientCertificateIdentifier") (clojure.core/assoc :hsm-client-certificate-identifier (deser-string (clojure.core/get-in letvar514910 ["HsmClientCertificateIdentifier" :content]))) (letvar514910 "HsmClientCertificatePublicKey") (clojure.core/assoc :hsm-client-certificate-public-key (deser-string (clojure.core/get-in letvar514910 ["HsmClientCertificatePublicKey" :content]))) (letvar514910 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar514910 ["Tags" :content]))))))

(clojure.core/defn- deser-source-type [input] (clojure.core/get {"cluster" :cluster, "cluster-parameter-group" :clusterparametergroup, "cluster-security-group" :clustersecuritygroup, "cluster-snapshot" :clustersnapshot} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-batch-snapshot-operation-error-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-error-message coll))) input))

(clojure.core/defn- deser-event [input] (clojure.core/let [letvar515040 {"SourceIdentifier" (portkey.aws/search-for-tag input "SourceIdentifier" :flattened? nil :xmlAttribute? nil), "SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Message" (portkey.aws/search-for-tag input "Message" :flattened? nil :xmlAttribute? nil), "EventCategories" (portkey.aws/search-for-tag input "EventCategories" :flattened? nil :xmlAttribute? nil), "Severity" (portkey.aws/search-for-tag input "Severity" :flattened? nil :xmlAttribute? nil), "Date" (portkey.aws/search-for-tag input "Date" :flattened? nil :xmlAttribute? nil), "EventId" (portkey.aws/search-for-tag input "EventId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515040 "SourceIdentifier") (clojure.core/assoc :source-identifier (deser-string (clojure.core/get-in letvar515040 ["SourceIdentifier" :content]))) (letvar515040 "SourceType") (clojure.core/assoc :source-type (deser-source-type (clojure.core/get-in letvar515040 ["SourceType" :content]))) (letvar515040 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar515040 ["Message" :content]))) (letvar515040 "EventCategories") (clojure.core/assoc :event-categories (deser-event-categories-list (clojure.core/get-in letvar515040 ["EventCategories" :content]))) (letvar515040 "Severity") (clojure.core/assoc :severity (deser-string (clojure.core/get-in letvar515040 ["Severity" :content]))) (letvar515040 "Date") (clojure.core/assoc :date (deser-t-stamp (clojure.core/get-in letvar515040 ["Date" :content]))) (letvar515040 "EventId") (clojure.core/assoc :event-id (deser-string (clojure.core/get-in letvar515040 ["EventId" :content]))))))

(clojure.core/defn- deser-availability-zone-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-availability-zone coll))) input))

(clojure.core/defn- deser-availability-zone [input] (clojure.core/let [letvar515165 {"Name" (portkey.aws/search-for-tag input "Name" :flattened? nil :xmlAttribute? nil), "SupportedPlatforms" (portkey.aws/search-for-tag input "SupportedPlatforms" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515165 "Name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar515165 ["Name" :content]))) (letvar515165 "SupportedPlatforms") (clojure.core/assoc :supported-platforms (deser-supported-platforms-list (clojure.core/get-in letvar515165 ["SupportedPlatforms" :content]))))))

(clojure.core/defn- deser-revision-targets-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-revision-target coll))) input))

(clojure.core/defn- deser-supported-platform [input] (clojure.core/let [letvar515290 {"Name" (portkey.aws/search-for-tag input "Name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515290 "Name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar515290 ["Name" :content]))))))

(clojure.core/defn- deser-sensitive-string [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-cluster-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster coll))) input))

(clojure.core/defn- deser-cluster-security-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-security-group coll))) input))

(clojure.core/defn- deser-recurring-charge [input] (clojure.core/let [letvar515437 {"RecurringChargeAmount" (portkey.aws/search-for-tag input "RecurringChargeAmount" :flattened? nil :xmlAttribute? nil), "RecurringChargeFrequency" (portkey.aws/search-for-tag input "RecurringChargeFrequency" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515437 "RecurringChargeAmount") (clojure.core/assoc :recurring-charge-amount (deser-double (clojure.core/get-in letvar515437 ["RecurringChargeAmount" :content]))) (letvar515437 "RecurringChargeFrequency") (clojure.core/assoc :recurring-charge-frequency (deser-string (clojure.core/get-in letvar515437 ["RecurringChargeFrequency" :content]))))))

(clojure.core/defn- deser-track-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-track coll))) input))

(clojure.core/defn- deser-batch-snapshot-operation-errors [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-error-message coll))) input))

(clojure.core/defn- deser-cluster-security-group-membership [input] (clojure.core/let [letvar515579 {"ClusterSecurityGroupName" (portkey.aws/search-for-tag input "ClusterSecurityGroupName" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515579 "ClusterSecurityGroupName") (clojure.core/assoc :cluster-security-group-name (deser-string (clojure.core/get-in letvar515579 ["ClusterSecurityGroupName" :content]))) (letvar515579 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar515579 ["Status" :content]))))))

(clojure.core/defn- deser-cluster-iam-role [input] (clojure.core/let [letvar515687 {"IamRoleArn" (portkey.aws/search-for-tag input "IamRoleArn" :flattened? nil :xmlAttribute? nil), "ApplyStatus" (portkey.aws/search-for-tag input "ApplyStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515687 "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-string (clojure.core/get-in letvar515687 ["IamRoleArn" :content]))) (letvar515687 "ApplyStatus") (clojure.core/assoc :apply-status (deser-string (clojure.core/get-in letvar515687 ["ApplyStatus" :content]))))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-cluster-db-revisions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-db-revision coll))) input))

(clojure.core/defn- deser-cluster [input] (clojure.core/let [letvar515829 {"ClusterPublicKey" (portkey.aws/search-for-tag input "ClusterPublicKey" :flattened? nil :xmlAttribute? nil), "EnhancedVpcRouting" (portkey.aws/search-for-tag input "EnhancedVpcRouting" :flattened? nil :xmlAttribute? nil), "PubliclyAccessible" (portkey.aws/search-for-tag input "PubliclyAccessible" :flattened? nil :xmlAttribute? nil), "PreferredMaintenanceWindow" (portkey.aws/search-for-tag input "PreferredMaintenanceWindow" :flattened? nil :xmlAttribute? nil), "Encrypted" (portkey.aws/search-for-tag input "Encrypted" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "ClusterSnapshotCopyStatus" (portkey.aws/search-for-tag input "ClusterSnapshotCopyStatus" :flattened? nil :xmlAttribute? nil), "ClusterSubnetGroupName" (portkey.aws/search-for-tag input "ClusterSubnetGroupName" :flattened? nil :xmlAttribute? nil), "NumberOfNodes" (portkey.aws/search-for-tag input "NumberOfNodes" :flattened? nil :xmlAttribute? nil), "ElasticResizeNumberOfNodeOptions" (portkey.aws/search-for-tag input "ElasticResizeNumberOfNodeOptions" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "DBName" (portkey.aws/search-for-tag input "DBName" :flattened? nil :xmlAttribute? nil), "ClusterParameterGroups" (portkey.aws/search-for-tag input "ClusterParameterGroups" :flattened? nil :xmlAttribute? nil), "AvailabilityZone" (portkey.aws/search-for-tag input "AvailabilityZone" :flattened? nil :xmlAttribute? nil), "PendingActions" (portkey.aws/search-for-tag input "PendingActions" :flattened? nil :xmlAttribute? nil), "ClusterSecurityGroups" (portkey.aws/search-for-tag input "ClusterSecurityGroups" :flattened? nil :xmlAttribute? nil), "MasterUsername" (portkey.aws/search-for-tag input "MasterUsername" :flattened? nil :xmlAttribute? nil), "SnapshotScheduleState" (portkey.aws/search-for-tag input "SnapshotScheduleState" :flattened? nil :xmlAttribute? nil), "DataTransferProgress" (portkey.aws/search-for-tag input "DataTransferProgress" :flattened? nil :xmlAttribute? nil), "ClusterStatus" (portkey.aws/search-for-tag input "ClusterStatus" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil), "RestoreStatus" (portkey.aws/search-for-tag input "RestoreStatus" :flattened? nil :xmlAttribute? nil), "ClusterCreateTime" (portkey.aws/search-for-tag input "ClusterCreateTime" :flattened? nil :xmlAttribute? nil), "ClusterRevisionNumber" (portkey.aws/search-for-tag input "ClusterRevisionNumber" :flattened? nil :xmlAttribute? nil), "AllowVersionUpgrade" (portkey.aws/search-for-tag input "AllowVersionUpgrade" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "ManualSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ModifyStatus" (portkey.aws/search-for-tag input "ModifyStatus" :flattened? nil :xmlAttribute? nil), "Endpoint" (portkey.aws/search-for-tag input "Endpoint" :flattened? nil :xmlAttribute? nil), "AutomatedSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "AutomatedSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "IamRoles" (portkey.aws/search-for-tag input "IamRoles" :flattened? nil :xmlAttribute? nil), "ResizeInfo" (portkey.aws/search-for-tag input "ResizeInfo" :flattened? nil :xmlAttribute? nil), "VpcSecurityGroups" (portkey.aws/search-for-tag input "VpcSecurityGroups" :flattened? nil :xmlAttribute? nil), "SnapshotScheduleIdentifier" (portkey.aws/search-for-tag input "SnapshotScheduleIdentifier" :flattened? nil :xmlAttribute? nil), "DeferredMaintenanceWindows" (portkey.aws/search-for-tag input "DeferredMaintenanceWindows" :flattened? nil :xmlAttribute? nil), "ClusterNodes" (portkey.aws/search-for-tag input "ClusterNodes" :flattened? nil :xmlAttribute? nil), "HsmStatus" (portkey.aws/search-for-tag input "HsmStatus" :flattened? nil :xmlAttribute? nil), "ElasticIpStatus" (portkey.aws/search-for-tag input "ElasticIpStatus" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil), "PendingModifiedValues" (portkey.aws/search-for-tag input "PendingModifiedValues" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515829 "ClusterPublicKey") (clojure.core/assoc :cluster-public-key (deser-string (clojure.core/get-in letvar515829 ["ClusterPublicKey" :content]))) (letvar515829 "EnhancedVpcRouting") (clojure.core/assoc :enhanced-vpc-routing (deser-boolean (clojure.core/get-in letvar515829 ["EnhancedVpcRouting" :content]))) (letvar515829 "PubliclyAccessible") (clojure.core/assoc :publicly-accessible (deser-boolean (clojure.core/get-in letvar515829 ["PubliclyAccessible" :content]))) (letvar515829 "PreferredMaintenanceWindow") (clojure.core/assoc :preferred-maintenance-window (deser-string (clojure.core/get-in letvar515829 ["PreferredMaintenanceWindow" :content]))) (letvar515829 "Encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar515829 ["Encrypted" :content]))) (letvar515829 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar515829 ["ClusterIdentifier" :content]))) (letvar515829 "ClusterSnapshotCopyStatus") (clojure.core/assoc :cluster-snapshot-copy-status (deser-cluster-snapshot-copy-status (clojure.core/get-in letvar515829 ["ClusterSnapshotCopyStatus" :content]))) (letvar515829 "ClusterSubnetGroupName") (clojure.core/assoc :cluster-subnet-group-name (deser-string (clojure.core/get-in letvar515829 ["ClusterSubnetGroupName" :content]))) (letvar515829 "NumberOfNodes") (clojure.core/assoc :number-of-nodes (deser-integer (clojure.core/get-in letvar515829 ["NumberOfNodes" :content]))) (letvar515829 "ElasticResizeNumberOfNodeOptions") (clojure.core/assoc :elastic-resize-number-of-node-options (deser-string (clojure.core/get-in letvar515829 ["ElasticResizeNumberOfNodeOptions" :content]))) (letvar515829 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar515829 ["Tags" :content]))) (letvar515829 "DBName") (clojure.core/assoc :db-name (deser-string (clojure.core/get-in letvar515829 ["DBName" :content]))) (letvar515829 "ClusterParameterGroups") (clojure.core/assoc :cluster-parameter-groups (deser-cluster-parameter-group-status-list (clojure.core/get-in letvar515829 ["ClusterParameterGroups" :content]))) (letvar515829 "AvailabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar515829 ["AvailabilityZone" :content]))) (letvar515829 "PendingActions") (clojure.core/assoc :pending-actions (deser-pending-actions-list (clojure.core/get-in letvar515829 ["PendingActions" :content]))) (letvar515829 "ClusterSecurityGroups") (clojure.core/assoc :cluster-security-groups (deser-cluster-security-group-membership-list (clojure.core/get-in letvar515829 ["ClusterSecurityGroups" :content]))) (letvar515829 "MasterUsername") (clojure.core/assoc :master-username (deser-string (clojure.core/get-in letvar515829 ["MasterUsername" :content]))) (letvar515829 "SnapshotScheduleState") (clojure.core/assoc :snapshot-schedule-state (deser-schedule-state (clojure.core/get-in letvar515829 ["SnapshotScheduleState" :content]))) (letvar515829 "DataTransferProgress") (clojure.core/assoc :data-transfer-progress (deser-data-transfer-progress (clojure.core/get-in letvar515829 ["DataTransferProgress" :content]))) (letvar515829 "ClusterStatus") (clojure.core/assoc :cluster-status (deser-string (clojure.core/get-in letvar515829 ["ClusterStatus" :content]))) (letvar515829 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar515829 ["VpcId" :content]))) (letvar515829 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar515829 ["MaintenanceTrackName" :content]))) (letvar515829 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar515829 ["KmsKeyId" :content]))) (letvar515829 "RestoreStatus") (clojure.core/assoc :restore-status (deser-restore-status (clojure.core/get-in letvar515829 ["RestoreStatus" :content]))) (letvar515829 "ClusterCreateTime") (clojure.core/assoc :cluster-create-time (deser-t-stamp (clojure.core/get-in letvar515829 ["ClusterCreateTime" :content]))) (letvar515829 "ClusterRevisionNumber") (clojure.core/assoc :cluster-revision-number (deser-string (clojure.core/get-in letvar515829 ["ClusterRevisionNumber" :content]))) (letvar515829 "AllowVersionUpgrade") (clojure.core/assoc :allow-version-upgrade (deser-boolean (clojure.core/get-in letvar515829 ["AllowVersionUpgrade" :content]))) (letvar515829 "ManualSnapshotRetentionPeriod") (clojure.core/assoc :manual-snapshot-retention-period (deser-integer (clojure.core/get-in letvar515829 ["ManualSnapshotRetentionPeriod" :content]))) (letvar515829 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar515829 ["ClusterVersion" :content]))) (letvar515829 "ModifyStatus") (clojure.core/assoc :modify-status (deser-string (clojure.core/get-in letvar515829 ["ModifyStatus" :content]))) (letvar515829 "Endpoint") (clojure.core/assoc :endpoint (deser-endpoint (clojure.core/get-in letvar515829 ["Endpoint" :content]))) (letvar515829 "AutomatedSnapshotRetentionPeriod") (clojure.core/assoc :automated-snapshot-retention-period (deser-integer (clojure.core/get-in letvar515829 ["AutomatedSnapshotRetentionPeriod" :content]))) (letvar515829 "IamRoles") (clojure.core/assoc :iam-roles (deser-cluster-iam-role-list (clojure.core/get-in letvar515829 ["IamRoles" :content]))) (letvar515829 "ResizeInfo") (clojure.core/assoc :resize-info (deser-resize-info (clojure.core/get-in letvar515829 ["ResizeInfo" :content]))) (letvar515829 "VpcSecurityGroups") (clojure.core/assoc :vpc-security-groups (deser-vpc-security-group-membership-list (clojure.core/get-in letvar515829 ["VpcSecurityGroups" :content]))) (letvar515829 "SnapshotScheduleIdentifier") (clojure.core/assoc :snapshot-schedule-identifier (deser-string (clojure.core/get-in letvar515829 ["SnapshotScheduleIdentifier" :content]))) (letvar515829 "DeferredMaintenanceWindows") (clojure.core/assoc :deferred-maintenance-windows (deser-deferred-maintenance-windows-list (clojure.core/get-in letvar515829 ["DeferredMaintenanceWindows" :content]))) (letvar515829 "ClusterNodes") (clojure.core/assoc :cluster-nodes (deser-cluster-nodes-list (clojure.core/get-in letvar515829 ["ClusterNodes" :content]))) (letvar515829 "HsmStatus") (clojure.core/assoc :hsm-status (deser-hsm-status (clojure.core/get-in letvar515829 ["HsmStatus" :content]))) (letvar515829 "ElasticIpStatus") (clojure.core/assoc :elastic-ip-status (deser-elastic-ip-status (clojure.core/get-in letvar515829 ["ElasticIpStatus" :content]))) (letvar515829 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar515829 ["NodeType" :content]))) (letvar515829 "PendingModifiedValues") (clojure.core/assoc :pending-modified-values (deser-pending-modified-values (clojure.core/get-in letvar515829 ["PendingModifiedValues" :content]))))))

(clojure.core/defn- deser-hsm-client-certificate-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-hsm-client-certificate coll))) input))

(clojure.core/defn- deser-reserved-node-offering [input] (clojure.core/let [letvar515954 {"CurrencyCode" (portkey.aws/search-for-tag input "CurrencyCode" :flattened? nil :xmlAttribute? nil), "FixedPrice" (portkey.aws/search-for-tag input "FixedPrice" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingType" (portkey.aws/search-for-tag input "ReservedNodeOfferingType" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingId" (portkey.aws/search-for-tag input "ReservedNodeOfferingId" :flattened? nil :xmlAttribute? nil), "Duration" (portkey.aws/search-for-tag input "Duration" :flattened? nil :xmlAttribute? nil), "UsagePrice" (portkey.aws/search-for-tag input "UsagePrice" :flattened? nil :xmlAttribute? nil), "RecurringCharges" (portkey.aws/search-for-tag input "RecurringCharges" :flattened? nil :xmlAttribute? nil), "OfferingType" (portkey.aws/search-for-tag input "OfferingType" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar515954 "CurrencyCode") (clojure.core/assoc :currency-code (deser-string (clojure.core/get-in letvar515954 ["CurrencyCode" :content]))) (letvar515954 "FixedPrice") (clojure.core/assoc :fixed-price (deser-double (clojure.core/get-in letvar515954 ["FixedPrice" :content]))) (letvar515954 "ReservedNodeOfferingType") (clojure.core/assoc :reserved-node-offering-type (deser-reserved-node-offering-type (clojure.core/get-in letvar515954 ["ReservedNodeOfferingType" :content]))) (letvar515954 "ReservedNodeOfferingId") (clojure.core/assoc :reserved-node-offering-id (deser-string (clojure.core/get-in letvar515954 ["ReservedNodeOfferingId" :content]))) (letvar515954 "Duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar515954 ["Duration" :content]))) (letvar515954 "UsagePrice") (clojure.core/assoc :usage-price (deser-double (clojure.core/get-in letvar515954 ["UsagePrice" :content]))) (letvar515954 "RecurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charge-list (clojure.core/get-in letvar515954 ["RecurringCharges" :content]))) (letvar515954 "OfferingType") (clojure.core/assoc :offering-type (deser-string (clojure.core/get-in letvar515954 ["OfferingType" :content]))) (letvar515954 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar515954 ["NodeType" :content]))))))

(clojure.core/defn- deser-accounts-with-restore-access-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-with-restore-access coll))) input))

(clojure.core/defn- deser-vpc-security-group-membership [input] (clojure.core/let [letvar516079 {"VpcSecurityGroupId" (portkey.aws/search-for-tag input "VpcSecurityGroupId" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516079 "VpcSecurityGroupId") (clojure.core/assoc :vpc-security-group-id (deser-string (clojure.core/get-in letvar516079 ["VpcSecurityGroupId" :content]))) (letvar516079 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar516079 ["Status" :content]))))))

(clojure.core/defn- deser-event-info-map [input] (clojure.core/let [letvar516187 {"EventId" (portkey.aws/search-for-tag input "EventId" :flattened? nil :xmlAttribute? nil), "EventCategories" (portkey.aws/search-for-tag input "EventCategories" :flattened? nil :xmlAttribute? nil), "EventDescription" (portkey.aws/search-for-tag input "EventDescription" :flattened? nil :xmlAttribute? nil), "Severity" (portkey.aws/search-for-tag input "Severity" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516187 "EventId") (clojure.core/assoc :event-id (deser-string (clojure.core/get-in letvar516187 ["EventId" :content]))) (letvar516187 "EventCategories") (clojure.core/assoc :event-categories (deser-event-categories-list (clojure.core/get-in letvar516187 ["EventCategories" :content]))) (letvar516187 "EventDescription") (clojure.core/assoc :event-description (deser-string (clojure.core/get-in letvar516187 ["EventDescription" :content]))) (letvar516187 "Severity") (clojure.core/assoc :severity (deser-string (clojure.core/get-in letvar516187 ["Severity" :content]))))))

(clojure.core/defn- deser-update-target [input] (clojure.core/let [letvar516295 {"MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "DatabaseVersion" (portkey.aws/search-for-tag input "DatabaseVersion" :flattened? nil :xmlAttribute? nil), "SupportedOperations" (portkey.aws/search-for-tag input "SupportedOperations" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516295 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar516295 ["MaintenanceTrackName" :content]))) (letvar516295 "DatabaseVersion") (clojure.core/assoc :database-version (deser-string (clojure.core/get-in letvar516295 ["DatabaseVersion" :content]))) (letvar516295 "SupportedOperations") (clojure.core/assoc :supported-operations (deser-supported-operation-list (clojure.core/get-in letvar516295 ["SupportedOperations" :content]))))))

(clojure.core/defn- deser-data-transfer-progress [input] (clojure.core/let [letvar516403 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "CurrentRateInMegaBytesPerSecond" (portkey.aws/search-for-tag input "CurrentRateInMegaBytesPerSecond" :flattened? nil :xmlAttribute? nil), "TotalDataInMegaBytes" (portkey.aws/search-for-tag input "TotalDataInMegaBytes" :flattened? nil :xmlAttribute? nil), "DataTransferredInMegaBytes" (portkey.aws/search-for-tag input "DataTransferredInMegaBytes" :flattened? nil :xmlAttribute? nil), "EstimatedTimeToCompletionInSeconds" (portkey.aws/search-for-tag input "EstimatedTimeToCompletionInSeconds" :flattened? nil :xmlAttribute? nil), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag input "ElapsedTimeInSeconds" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516403 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar516403 ["Status" :content]))) (letvar516403 "CurrentRateInMegaBytesPerSecond") (clojure.core/assoc :current-rate-in-mega-bytes-per-second (deser-double-optional (clojure.core/get-in letvar516403 ["CurrentRateInMegaBytesPerSecond" :content]))) (letvar516403 "TotalDataInMegaBytes") (clojure.core/assoc :total-data-in-mega-bytes (deser-long (clojure.core/get-in letvar516403 ["TotalDataInMegaBytes" :content]))) (letvar516403 "DataTransferredInMegaBytes") (clojure.core/assoc :data-transferred-in-mega-bytes (deser-long (clojure.core/get-in letvar516403 ["DataTransferredInMegaBytes" :content]))) (letvar516403 "EstimatedTimeToCompletionInSeconds") (clojure.core/assoc :estimated-time-to-completion-in-seconds (deser-long-optional (clojure.core/get-in letvar516403 ["EstimatedTimeToCompletionInSeconds" :content]))) (letvar516403 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long-optional (clojure.core/get-in letvar516403 ["ElapsedTimeInSeconds" :content]))))))

(clojure.core/defn- deser-pending-actions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-snapshot-identifier-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-ec-2-security-group [input] (clojure.core/let [letvar516545 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroupName" (portkey.aws/search-for-tag input "EC2SecurityGroupName" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroupOwnerId" (portkey.aws/search-for-tag input "EC2SecurityGroupOwnerId" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516545 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar516545 ["Status" :content]))) (letvar516545 "EC2SecurityGroupName") (clojure.core/assoc :ec-2-security-group-name (deser-string (clojure.core/get-in letvar516545 ["EC2SecurityGroupName" :content]))) (letvar516545 "EC2SecurityGroupOwnerId") (clojure.core/assoc :ec-2-security-group-owner-id (deser-string (clojure.core/get-in letvar516545 ["EC2SecurityGroupOwnerId" :content]))) (letvar516545 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar516545 ["Tags" :content]))))))

(clojure.core/defn- deser-event-categories-map-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event-categories-map coll))) input))

(clojure.core/defn- deser-integer [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-string [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-parameter [input] (clojure.core/let [letvar516677 {"DataType" (portkey.aws/search-for-tag input "DataType" :flattened? nil :xmlAttribute? nil), "ParameterName" (portkey.aws/search-for-tag input "ParameterName" :flattened? nil :xmlAttribute? nil), "Source" (portkey.aws/search-for-tag input "Source" :flattened? nil :xmlAttribute? nil), "MinimumEngineVersion" (portkey.aws/search-for-tag input "MinimumEngineVersion" :flattened? nil :xmlAttribute? nil), "AllowedValues" (portkey.aws/search-for-tag input "AllowedValues" :flattened? nil :xmlAttribute? nil), "ApplyType" (portkey.aws/search-for-tag input "ApplyType" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "IsModifiable" (portkey.aws/search-for-tag input "IsModifiable" :flattened? nil :xmlAttribute? nil), "ParameterValue" (portkey.aws/search-for-tag input "ParameterValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516677 "DataType") (clojure.core/assoc :data-type (deser-string (clojure.core/get-in letvar516677 ["DataType" :content]))) (letvar516677 "ParameterName") (clojure.core/assoc :parameter-name (deser-string (clojure.core/get-in letvar516677 ["ParameterName" :content]))) (letvar516677 "Source") (clojure.core/assoc :source (deser-string (clojure.core/get-in letvar516677 ["Source" :content]))) (letvar516677 "MinimumEngineVersion") (clojure.core/assoc :minimum-engine-version (deser-string (clojure.core/get-in letvar516677 ["MinimumEngineVersion" :content]))) (letvar516677 "AllowedValues") (clojure.core/assoc :allowed-values (deser-string (clojure.core/get-in letvar516677 ["AllowedValues" :content]))) (letvar516677 "ApplyType") (clojure.core/assoc :apply-type (deser-parameter-apply-type (clojure.core/get-in letvar516677 ["ApplyType" :content]))) (letvar516677 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar516677 ["Description" :content]))) (letvar516677 "IsModifiable") (clojure.core/assoc :is-modifiable (deser-boolean (clojure.core/get-in letvar516677 ["IsModifiable" :content]))) (letvar516677 "ParameterValue") (clojure.core/assoc :parameter-value (deser-string (clojure.core/get-in letvar516677 ["ParameterValue" :content]))))))

(clojure.core/defn- deser-cluster-parameter-status [input] (clojure.core/let [letvar516785 {"ParameterName" (portkey.aws/search-for-tag input "ParameterName" :flattened? nil :xmlAttribute? nil), "ParameterApplyStatus" (portkey.aws/search-for-tag input "ParameterApplyStatus" :flattened? nil :xmlAttribute? nil), "ParameterApplyErrorDescription" (portkey.aws/search-for-tag input "ParameterApplyErrorDescription" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516785 "ParameterName") (clojure.core/assoc :parameter-name (deser-string (clojure.core/get-in letvar516785 ["ParameterName" :content]))) (letvar516785 "ParameterApplyStatus") (clojure.core/assoc :parameter-apply-status (deser-string (clojure.core/get-in letvar516785 ["ParameterApplyStatus" :content]))) (letvar516785 "ParameterApplyErrorDescription") (clojure.core/assoc :parameter-apply-error-description (deser-string (clojure.core/get-in letvar516785 ["ParameterApplyErrorDescription" :content]))))))

(clojure.core/defn- deser-cluster-parameter-group-status [input] (clojure.core/let [letvar516893 {"ParameterGroupName" (portkey.aws/search-for-tag input "ParameterGroupName" :flattened? nil :xmlAttribute? nil), "ParameterApplyStatus" (portkey.aws/search-for-tag input "ParameterApplyStatus" :flattened? nil :xmlAttribute? nil), "ClusterParameterStatusList" (portkey.aws/search-for-tag input "ClusterParameterStatusList" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar516893 "ParameterGroupName") (clojure.core/assoc :parameter-group-name (deser-string (clojure.core/get-in letvar516893 ["ParameterGroupName" :content]))) (letvar516893 "ParameterApplyStatus") (clojure.core/assoc :parameter-apply-status (deser-string (clojure.core/get-in letvar516893 ["ParameterApplyStatus" :content]))) (letvar516893 "ClusterParameterStatusList") (clojure.core/assoc :cluster-parameter-status-list (deser-cluster-parameter-status-list (clojure.core/get-in letvar516893 ["ClusterParameterStatusList" :content]))))))

(clojure.core/defn- deser-cluster-security-group-membership-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-security-group-membership coll))) input))

(clojure.core/defn- deser-restore-status [input] (clojure.core/let [letvar517018 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "CurrentRestoreRateInMegaBytesPerSecond" (portkey.aws/search-for-tag input "CurrentRestoreRateInMegaBytesPerSecond" :flattened? nil :xmlAttribute? nil), "SnapshotSizeInMegaBytes" (portkey.aws/search-for-tag input "SnapshotSizeInMegaBytes" :flattened? nil :xmlAttribute? nil), "ProgressInMegaBytes" (portkey.aws/search-for-tag input "ProgressInMegaBytes" :flattened? nil :xmlAttribute? nil), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag input "ElapsedTimeInSeconds" :flattened? nil :xmlAttribute? nil), "EstimatedTimeToCompletionInSeconds" (portkey.aws/search-for-tag input "EstimatedTimeToCompletionInSeconds" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517018 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar517018 ["Status" :content]))) (letvar517018 "CurrentRestoreRateInMegaBytesPerSecond") (clojure.core/assoc :current-restore-rate-in-mega-bytes-per-second (deser-double (clojure.core/get-in letvar517018 ["CurrentRestoreRateInMegaBytesPerSecond" :content]))) (letvar517018 "SnapshotSizeInMegaBytes") (clojure.core/assoc :snapshot-size-in-mega-bytes (deser-long (clojure.core/get-in letvar517018 ["SnapshotSizeInMegaBytes" :content]))) (letvar517018 "ProgressInMegaBytes") (clojure.core/assoc :progress-in-mega-bytes (deser-long (clojure.core/get-in letvar517018 ["ProgressInMegaBytes" :content]))) (letvar517018 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long (clojure.core/get-in letvar517018 ["ElapsedTimeInSeconds" :content]))) (letvar517018 "EstimatedTimeToCompletionInSeconds") (clojure.core/assoc :estimated-time-to-completion-in-seconds (deser-long (clojure.core/get-in letvar517018 ["EstimatedTimeToCompletionInSeconds" :content]))))))

(clojure.core/defn- deser-snapshot [input] (clojure.core/let [letvar517126 {"SnapshotIdentifier" (portkey.aws/search-for-tag input "SnapshotIdentifier" :flattened? nil :xmlAttribute? nil), "RestorableNodeTypes" (portkey.aws/search-for-tag input "RestorableNodeTypes" :flattened? nil :xmlAttribute? nil), "SnapshotCreateTime" (portkey.aws/search-for-tag input "SnapshotCreateTime" :flattened? nil :xmlAttribute? nil), "EnhancedVpcRouting" (portkey.aws/search-for-tag input "EnhancedVpcRouting" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRemainingDays" (portkey.aws/search-for-tag input "ManualSnapshotRemainingDays" :flattened? nil :xmlAttribute? nil), "SourceRegion" (portkey.aws/search-for-tag input "SourceRegion" :flattened? nil :xmlAttribute? nil), "EncryptedWithHSM" (portkey.aws/search-for-tag input "EncryptedWithHSM" :flattened? nil :xmlAttribute? nil), "Encrypted" (portkey.aws/search-for-tag input "Encrypted" :flattened? nil :xmlAttribute? nil), "OwnerAccount" (portkey.aws/search-for-tag input "OwnerAccount" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "NumberOfNodes" (portkey.aws/search-for-tag input "NumberOfNodes" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "DBName" (portkey.aws/search-for-tag input "DBName" :flattened? nil :xmlAttribute? nil), "EstimatedSecondsToCompletion" (portkey.aws/search-for-tag input "EstimatedSecondsToCompletion" :flattened? nil :xmlAttribute? nil), "AvailabilityZone" (portkey.aws/search-for-tag input "AvailabilityZone" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "SnapshotType" (portkey.aws/search-for-tag input "SnapshotType" :flattened? nil :xmlAttribute? nil), "ActualIncrementalBackupSizeInMegaBytes" (portkey.aws/search-for-tag input "ActualIncrementalBackupSizeInMegaBytes" :flattened? nil :xmlAttribute? nil), "MasterUsername" (portkey.aws/search-for-tag input "MasterUsername" :flattened? nil :xmlAttribute? nil), "BackupProgressInMegaBytes" (portkey.aws/search-for-tag input "BackupProgressInMegaBytes" :flattened? nil :xmlAttribute? nil), "AccountsWithRestoreAccess" (portkey.aws/search-for-tag input "AccountsWithRestoreAccess" :flattened? nil :xmlAttribute? nil), "Port" (portkey.aws/search-for-tag input "Port" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil), "ClusterCreateTime" (portkey.aws/search-for-tag input "ClusterCreateTime" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "ManualSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag input "ElapsedTimeInSeconds" :flattened? nil :xmlAttribute? nil), "SnapshotRetentionStartTime" (portkey.aws/search-for-tag input "SnapshotRetentionStartTime" :flattened? nil :xmlAttribute? nil), "CurrentBackupRateInMegaBytesPerSecond" (portkey.aws/search-for-tag input "CurrentBackupRateInMegaBytesPerSecond" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil), "TotalBackupSizeInMegaBytes" (portkey.aws/search-for-tag input "TotalBackupSizeInMegaBytes" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517126 "SnapshotIdentifier") (clojure.core/assoc :snapshot-identifier (deser-string (clojure.core/get-in letvar517126 ["SnapshotIdentifier" :content]))) (letvar517126 "RestorableNodeTypes") (clojure.core/assoc :restorable-node-types (deser-restorable-node-type-list (clojure.core/get-in letvar517126 ["RestorableNodeTypes" :content]))) (letvar517126 "SnapshotCreateTime") (clojure.core/assoc :snapshot-create-time (deser-t-stamp (clojure.core/get-in letvar517126 ["SnapshotCreateTime" :content]))) (letvar517126 "EnhancedVpcRouting") (clojure.core/assoc :enhanced-vpc-routing (deser-boolean (clojure.core/get-in letvar517126 ["EnhancedVpcRouting" :content]))) (letvar517126 "ManualSnapshotRemainingDays") (clojure.core/assoc :manual-snapshot-remaining-days (deser-integer-optional (clojure.core/get-in letvar517126 ["ManualSnapshotRemainingDays" :content]))) (letvar517126 "SourceRegion") (clojure.core/assoc :source-region (deser-string (clojure.core/get-in letvar517126 ["SourceRegion" :content]))) (letvar517126 "EncryptedWithHSM") (clojure.core/assoc :encrypted-with-hsm (deser-boolean (clojure.core/get-in letvar517126 ["EncryptedWithHSM" :content]))) (letvar517126 "Encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar517126 ["Encrypted" :content]))) (letvar517126 "OwnerAccount") (clojure.core/assoc :owner-account (deser-string (clojure.core/get-in letvar517126 ["OwnerAccount" :content]))) (letvar517126 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar517126 ["ClusterIdentifier" :content]))) (letvar517126 "NumberOfNodes") (clojure.core/assoc :number-of-nodes (deser-integer (clojure.core/get-in letvar517126 ["NumberOfNodes" :content]))) (letvar517126 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar517126 ["Tags" :content]))) (letvar517126 "DBName") (clojure.core/assoc :db-name (deser-string (clojure.core/get-in letvar517126 ["DBName" :content]))) (letvar517126 "EstimatedSecondsToCompletion") (clojure.core/assoc :estimated-seconds-to-completion (deser-long (clojure.core/get-in letvar517126 ["EstimatedSecondsToCompletion" :content]))) (letvar517126 "AvailabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar517126 ["AvailabilityZone" :content]))) (letvar517126 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar517126 ["Status" :content]))) (letvar517126 "SnapshotType") (clojure.core/assoc :snapshot-type (deser-string (clojure.core/get-in letvar517126 ["SnapshotType" :content]))) (letvar517126 "ActualIncrementalBackupSizeInMegaBytes") (clojure.core/assoc :actual-incremental-backup-size-in-mega-bytes (deser-double (clojure.core/get-in letvar517126 ["ActualIncrementalBackupSizeInMegaBytes" :content]))) (letvar517126 "MasterUsername") (clojure.core/assoc :master-username (deser-string (clojure.core/get-in letvar517126 ["MasterUsername" :content]))) (letvar517126 "BackupProgressInMegaBytes") (clojure.core/assoc :backup-progress-in-mega-bytes (deser-double (clojure.core/get-in letvar517126 ["BackupProgressInMegaBytes" :content]))) (letvar517126 "AccountsWithRestoreAccess") (clojure.core/assoc :accounts-with-restore-access (deser-accounts-with-restore-access-list (clojure.core/get-in letvar517126 ["AccountsWithRestoreAccess" :content]))) (letvar517126 "Port") (clojure.core/assoc :port (deser-integer (clojure.core/get-in letvar517126 ["Port" :content]))) (letvar517126 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar517126 ["VpcId" :content]))) (letvar517126 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar517126 ["MaintenanceTrackName" :content]))) (letvar517126 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar517126 ["KmsKeyId" :content]))) (letvar517126 "ClusterCreateTime") (clojure.core/assoc :cluster-create-time (deser-t-stamp (clojure.core/get-in letvar517126 ["ClusterCreateTime" :content]))) (letvar517126 "ManualSnapshotRetentionPeriod") (clojure.core/assoc :manual-snapshot-retention-period (deser-integer-optional (clojure.core/get-in letvar517126 ["ManualSnapshotRetentionPeriod" :content]))) (letvar517126 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar517126 ["ClusterVersion" :content]))) (letvar517126 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long (clojure.core/get-in letvar517126 ["ElapsedTimeInSeconds" :content]))) (letvar517126 "SnapshotRetentionStartTime") (clojure.core/assoc :snapshot-retention-start-time (deser-t-stamp (clojure.core/get-in letvar517126 ["SnapshotRetentionStartTime" :content]))) (letvar517126 "CurrentBackupRateInMegaBytesPerSecond") (clojure.core/assoc :current-backup-rate-in-mega-bytes-per-second (deser-double (clojure.core/get-in letvar517126 ["CurrentBackupRateInMegaBytesPerSecond" :content]))) (letvar517126 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar517126 ["NodeType" :content]))) (letvar517126 "TotalBackupSizeInMegaBytes") (clojure.core/assoc :total-backup-size-in-mega-bytes (deser-double (clojure.core/get-in letvar517126 ["TotalBackupSizeInMegaBytes" :content]))))))

(clojure.core/defn- deser-t-stamp [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-cluster-subnet-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-subnet-group coll))) input))

(clojure.core/defn- deser-event-categories-map [input] (clojure.core/let [letvar517253 {"SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Events" (portkey.aws/search-for-tag input "Events" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517253 "SourceType") (clojure.core/assoc :source-type (deser-string (clojure.core/get-in letvar517253 ["SourceType" :content]))) (letvar517253 "Events") (clojure.core/assoc :events (deser-event-info-map-list (clojure.core/get-in letvar517253 ["Events" :content]))))))

(clojure.core/defn- deser-cluster-parameter-group-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-parameter-group-status coll))) input))

(clojure.core/defn- deser-recurring-charge-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-recurring-charge coll))) input))

(clojure.core/defn- deser-event-categories-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-account-with-restore-access [input] (clojure.core/let [letvar517412 {"AccountId" (portkey.aws/search-for-tag input "AccountId" :flattened? nil :xmlAttribute? nil), "AccountAlias" (portkey.aws/search-for-tag input "AccountAlias" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517412 "AccountId") (clojure.core/assoc :account-id (deser-string (clojure.core/get-in letvar517412 ["AccountId" :content]))) (letvar517412 "AccountAlias") (clojure.core/assoc :account-alias (deser-string (clojure.core/get-in letvar517412 ["AccountAlias" :content]))))))

(clojure.core/defn- deser-table-restore-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-table-restore-status coll))) input))

(clojure.core/defn- deser-cluster-version [input] (clojure.core/let [letvar517537 {"ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ClusterParameterGroupFamily" (portkey.aws/search-for-tag input "ClusterParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517537 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar517537 ["ClusterVersion" :content]))) (letvar517537 "ClusterParameterGroupFamily") (clojure.core/assoc :cluster-parameter-group-family (deser-string (clojure.core/get-in letvar517537 ["ClusterParameterGroupFamily" :content]))) (letvar517537 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar517537 ["Description" :content]))))))

(clojure.core/defn- deser-snapshot-schedule [input] (clojure.core/let [letvar517645 {"ScheduleDefinitions" (portkey.aws/search-for-tag input "ScheduleDefinitions" :flattened? nil :xmlAttribute? nil), "ScheduleIdentifier" (portkey.aws/search-for-tag input "ScheduleIdentifier" :flattened? nil :xmlAttribute? nil), "ScheduleDescription" (portkey.aws/search-for-tag input "ScheduleDescription" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "NextInvocations" (portkey.aws/search-for-tag input "NextInvocations" :flattened? nil :xmlAttribute? nil), "AssociatedClusterCount" (portkey.aws/search-for-tag input "AssociatedClusterCount" :flattened? nil :xmlAttribute? nil), "AssociatedClusters" (portkey.aws/search-for-tag input "AssociatedClusters" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517645 "ScheduleDefinitions") (clojure.core/assoc :schedule-definitions (deser-schedule-definition-list (clojure.core/get-in letvar517645 ["ScheduleDefinitions" :content]))) (letvar517645 "ScheduleIdentifier") (clojure.core/assoc :schedule-identifier (deser-string (clojure.core/get-in letvar517645 ["ScheduleIdentifier" :content]))) (letvar517645 "ScheduleDescription") (clojure.core/assoc :schedule-description (deser-string (clojure.core/get-in letvar517645 ["ScheduleDescription" :content]))) (letvar517645 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar517645 ["Tags" :content]))) (letvar517645 "NextInvocations") (clojure.core/assoc :next-invocations (deser-scheduled-snapshot-time-list (clojure.core/get-in letvar517645 ["NextInvocations" :content]))) (letvar517645 "AssociatedClusterCount") (clojure.core/assoc :associated-cluster-count (deser-integer-optional (clojure.core/get-in letvar517645 ["AssociatedClusterCount" :content]))) (letvar517645 "AssociatedClusters") (clojure.core/assoc :associated-clusters (deser-associated-cluster-list (clojure.core/get-in letvar517645 ["AssociatedClusters" :content]))))))

(clojure.core/defn- deser-endpoint [input] (clojure.core/let [letvar517753 {"Address" (portkey.aws/search-for-tag input "Address" :flattened? nil :xmlAttribute? nil), "Port" (portkey.aws/search-for-tag input "Port" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517753 "Address") (clojure.core/assoc :address (deser-string (clojure.core/get-in letvar517753 ["Address" :content]))) (letvar517753 "Port") (clojure.core/assoc :port (deser-integer (clojure.core/get-in letvar517753 ["Port" :content]))))))

(clojure.core/defn- deser-table-restore-status [input] (clojure.core/let [letvar517861 {"SnapshotIdentifier" (portkey.aws/search-for-tag input "SnapshotIdentifier" :flattened? nil :xmlAttribute? nil), "TargetSchemaName" (portkey.aws/search-for-tag input "TargetSchemaName" :flattened? nil :xmlAttribute? nil), "SourceSchemaName" (portkey.aws/search-for-tag input "SourceSchemaName" :flattened? nil :xmlAttribute? nil), "TotalDataInMegaBytes" (portkey.aws/search-for-tag input "TotalDataInMegaBytes" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "RequestTime" (portkey.aws/search-for-tag input "RequestTime" :flattened? nil :xmlAttribute? nil), "NewTableName" (portkey.aws/search-for-tag input "NewTableName" :flattened? nil :xmlAttribute? nil), "ProgressInMegaBytes" (portkey.aws/search-for-tag input "ProgressInMegaBytes" :flattened? nil :xmlAttribute? nil), "SourceDatabaseName" (portkey.aws/search-for-tag input "SourceDatabaseName" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "Message" (portkey.aws/search-for-tag input "Message" :flattened? nil :xmlAttribute? nil), "SourceTableName" (portkey.aws/search-for-tag input "SourceTableName" :flattened? nil :xmlAttribute? nil), "TableRestoreRequestId" (portkey.aws/search-for-tag input "TableRestoreRequestId" :flattened? nil :xmlAttribute? nil), "TargetDatabaseName" (portkey.aws/search-for-tag input "TargetDatabaseName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar517861 "SnapshotIdentifier") (clojure.core/assoc :snapshot-identifier (deser-string (clojure.core/get-in letvar517861 ["SnapshotIdentifier" :content]))) (letvar517861 "TargetSchemaName") (clojure.core/assoc :target-schema-name (deser-string (clojure.core/get-in letvar517861 ["TargetSchemaName" :content]))) (letvar517861 "SourceSchemaName") (clojure.core/assoc :source-schema-name (deser-string (clojure.core/get-in letvar517861 ["SourceSchemaName" :content]))) (letvar517861 "TotalDataInMegaBytes") (clojure.core/assoc :total-data-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar517861 ["TotalDataInMegaBytes" :content]))) (letvar517861 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar517861 ["ClusterIdentifier" :content]))) (letvar517861 "RequestTime") (clojure.core/assoc :request-time (deser-t-stamp (clojure.core/get-in letvar517861 ["RequestTime" :content]))) (letvar517861 "NewTableName") (clojure.core/assoc :new-table-name (deser-string (clojure.core/get-in letvar517861 ["NewTableName" :content]))) (letvar517861 "ProgressInMegaBytes") (clojure.core/assoc :progress-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar517861 ["ProgressInMegaBytes" :content]))) (letvar517861 "SourceDatabaseName") (clojure.core/assoc :source-database-name (deser-string (clojure.core/get-in letvar517861 ["SourceDatabaseName" :content]))) (letvar517861 "Status") (clojure.core/assoc :status (deser-table-restore-status-type (clojure.core/get-in letvar517861 ["Status" :content]))) (letvar517861 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar517861 ["Message" :content]))) (letvar517861 "SourceTableName") (clojure.core/assoc :source-table-name (deser-string (clojure.core/get-in letvar517861 ["SourceTableName" :content]))) (letvar517861 "TableRestoreRequestId") (clojure.core/assoc :table-restore-request-id (deser-string (clojure.core/get-in letvar517861 ["TableRestoreRequestId" :content]))) (letvar517861 "TargetDatabaseName") (clojure.core/assoc :target-database-name (deser-string (clojure.core/get-in letvar517861 ["TargetDatabaseName" :content]))))))

(clojure.core/defn- deser-long [input] (java.lang.Long. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-import-tables-completed [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-reserved-node-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-node coll))) input))

(clojure.core/defn- deser-import-tables-in-progress [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-snapshot-error-message [input] (clojure.core/let [letvar518022 {"SnapshotIdentifier" (portkey.aws/search-for-tag input "SnapshotIdentifier" :flattened? nil :xmlAttribute? nil), "SnapshotClusterIdentifier" (portkey.aws/search-for-tag input "SnapshotClusterIdentifier" :flattened? nil :xmlAttribute? nil), "FailureCode" (portkey.aws/search-for-tag input "FailureCode" :flattened? nil :xmlAttribute? nil), "FailureReason" (portkey.aws/search-for-tag input "FailureReason" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518022 "SnapshotIdentifier") (clojure.core/assoc :snapshot-identifier (deser-string (clojure.core/get-in letvar518022 ["SnapshotIdentifier" :content]))) (letvar518022 "SnapshotClusterIdentifier") (clojure.core/assoc :snapshot-cluster-identifier (deser-string (clojure.core/get-in letvar518022 ["SnapshotClusterIdentifier" :content]))) (letvar518022 "FailureCode") (clojure.core/assoc :failure-code (deser-string (clojure.core/get-in letvar518022 ["FailureCode" :content]))) (letvar518022 "FailureReason") (clojure.core/assoc :failure-reason (deser-string (clojure.core/get-in letvar518022 ["FailureReason" :content]))))))

(clojure.core/defn- deser-attribute-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attribute-value-target coll))) input))

(clojure.core/defn- deser-ip-range [input] (clojure.core/let [letvar518147 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "CIDRIP" (portkey.aws/search-for-tag input "CIDRIP" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518147 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar518147 ["Status" :content]))) (letvar518147 "CIDRIP") (clojure.core/assoc :cidrip (deser-string (clojure.core/get-in letvar518147 ["CIDRIP" :content]))) (letvar518147 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar518147 ["Tags" :content]))))))

(clojure.core/defn- deser-cluster-subnet-group [input] (clojure.core/let [letvar518255 {"ClusterSubnetGroupName" (portkey.aws/search-for-tag input "ClusterSubnetGroupName" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "SubnetGroupStatus" (portkey.aws/search-for-tag input "SubnetGroupStatus" :flattened? nil :xmlAttribute? nil), "Subnets" (portkey.aws/search-for-tag input "Subnets" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518255 "ClusterSubnetGroupName") (clojure.core/assoc :cluster-subnet-group-name (deser-string (clojure.core/get-in letvar518255 ["ClusterSubnetGroupName" :content]))) (letvar518255 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar518255 ["Description" :content]))) (letvar518255 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar518255 ["VpcId" :content]))) (letvar518255 "SubnetGroupStatus") (clojure.core/assoc :subnet-group-status (deser-string (clojure.core/get-in letvar518255 ["SubnetGroupStatus" :content]))) (letvar518255 "Subnets") (clojure.core/assoc :subnets (deser-subnet-list (clojure.core/get-in letvar518255 ["Subnets" :content]))) (letvar518255 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar518255 ["Tags" :content]))))))

(clojure.core/defn- deser-cluster-nodes-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-node coll))) input))

(clojure.core/defn- deser-resize-info [input] (clojure.core/let [letvar518380 {"ResizeType" (portkey.aws/search-for-tag input "ResizeType" :flattened? nil :xmlAttribute? nil), "AllowCancelResize" (portkey.aws/search-for-tag input "AllowCancelResize" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518380 "ResizeType") (clojure.core/assoc :resize-type (deser-string (clojure.core/get-in letvar518380 ["ResizeType" :content]))) (letvar518380 "AllowCancelResize") (clojure.core/assoc :allow-cancel-resize (deser-boolean (clojure.core/get-in letvar518380 ["AllowCancelResize" :content]))))))

(clojure.core/defn- deser-tag [input] (clojure.core/let [letvar518488 {"Key" (portkey.aws/search-for-tag input "Key" :flattened? nil :xmlAttribute? nil), "Value" (portkey.aws/search-for-tag input "Value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518488 "Key") (clojure.core/assoc :key (deser-string (clojure.core/get-in letvar518488 ["Key" :content]))) (letvar518488 "Value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar518488 ["Value" :content]))))))

(clojure.core/defn- deser-cluster-db-revision [input] (clojure.core/let [letvar518596 {"ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "CurrentDatabaseRevision" (portkey.aws/search-for-tag input "CurrentDatabaseRevision" :flattened? nil :xmlAttribute? nil), "DatabaseRevisionReleaseDate" (portkey.aws/search-for-tag input "DatabaseRevisionReleaseDate" :flattened? nil :xmlAttribute? nil), "RevisionTargets" (portkey.aws/search-for-tag input "RevisionTargets" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518596 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar518596 ["ClusterIdentifier" :content]))) (letvar518596 "CurrentDatabaseRevision") (clojure.core/assoc :current-database-revision (deser-string (clojure.core/get-in letvar518596 ["CurrentDatabaseRevision" :content]))) (letvar518596 "DatabaseRevisionReleaseDate") (clojure.core/assoc :database-revision-release-date (deser-t-stamp (clojure.core/get-in letvar518596 ["DatabaseRevisionReleaseDate" :content]))) (letvar518596 "RevisionTargets") (clojure.core/assoc :revision-targets (deser-revision-targets-list (clojure.core/get-in letvar518596 ["RevisionTargets" :content]))))))

(clojure.core/defn- deser-schedule-state [input] (clojure.core/get {"MODIFYING" :modifying, "ACTIVE" :active, "FAILED" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-boolean-optional [input] (clojure.core/when-let [boolstr__283693__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__283693__auto__) true (clojure.core/= "false" boolstr__283693__auto__) false)))

(clojure.core/defn- deser-cluster-iam-role-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-iam-role coll))) input))

(clojure.core/defn- deser-deferred-maintenance-window [input] (clojure.core/let [letvar518728 {"DeferMaintenanceIdentifier" (portkey.aws/search-for-tag input "DeferMaintenanceIdentifier" :flattened? nil :xmlAttribute? nil), "DeferMaintenanceStartTime" (portkey.aws/search-for-tag input "DeferMaintenanceStartTime" :flattened? nil :xmlAttribute? nil), "DeferMaintenanceEndTime" (portkey.aws/search-for-tag input "DeferMaintenanceEndTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518728 "DeferMaintenanceIdentifier") (clojure.core/assoc :defer-maintenance-identifier (deser-string (clojure.core/get-in letvar518728 ["DeferMaintenanceIdentifier" :content]))) (letvar518728 "DeferMaintenanceStartTime") (clojure.core/assoc :defer-maintenance-start-time (deser-t-stamp (clojure.core/get-in letvar518728 ["DeferMaintenanceStartTime" :content]))) (letvar518728 "DeferMaintenanceEndTime") (clojure.core/assoc :defer-maintenance-end-time (deser-t-stamp (clojure.core/get-in letvar518728 ["DeferMaintenanceEndTime" :content]))))))

(clojure.core/defn- deser-tagged-resource [input] (clojure.core/let [letvar518836 {"Tag" (portkey.aws/search-for-tag input "Tag" :flattened? nil :xmlAttribute? nil), "ResourceName" (portkey.aws/search-for-tag input "ResourceName" :flattened? nil :xmlAttribute? nil), "ResourceType" (portkey.aws/search-for-tag input "ResourceType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518836 "Tag") (clojure.core/assoc :tag (deser-tag (clojure.core/get-in letvar518836 ["Tag" :content]))) (letvar518836 "ResourceName") (clojure.core/assoc :resource-name (deser-string (clojure.core/get-in letvar518836 ["ResourceName" :content]))) (letvar518836 "ResourceType") (clojure.core/assoc :resource-type (deser-string (clojure.core/get-in letvar518836 ["ResourceType" :content]))))))

(clojure.core/defn- deser-restorable-node-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cluster-associated-to-schedule [input] (clojure.core/let [letvar518961 {"ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "ScheduleAssociationState" (portkey.aws/search-for-tag input "ScheduleAssociationState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar518961 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar518961 ["ClusterIdentifier" :content]))) (letvar518961 "ScheduleAssociationState") (clojure.core/assoc :schedule-association-state (deser-schedule-state (clojure.core/get-in letvar518961 ["ScheduleAssociationState" :content]))))))

(clojure.core/defn- deser-eligible-tracks-to-update-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-update-target coll))) input))

(clojure.core/defn- deser-scheduled-snapshot-time-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-t-stamp coll))) input))

(clojure.core/defn- deser-cluster-parameter-group [input] (clojure.core/let [letvar519103 {"ParameterGroupName" (portkey.aws/search-for-tag input "ParameterGroupName" :flattened? nil :xmlAttribute? nil), "ParameterGroupFamily" (portkey.aws/search-for-tag input "ParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519103 "ParameterGroupName") (clojure.core/assoc :parameter-group-name (deser-string (clojure.core/get-in letvar519103 ["ParameterGroupName" :content]))) (letvar519103 "ParameterGroupFamily") (clojure.core/assoc :parameter-group-family (deser-string (clojure.core/get-in letvar519103 ["ParameterGroupFamily" :content]))) (letvar519103 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar519103 ["Description" :content]))) (letvar519103 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar519103 ["Tags" :content]))))))

(clojure.core/defn- deser-event-subscriptions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event-subscription coll))) input))

(clojure.core/defn- deser-hsm-configuration-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-hsm-configuration coll))) input))

(clojure.core/defn- deser-long-optional [input] (java.lang.Long. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cluster-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-version coll))) input))

(clojure.core/defn- deser-integer-optional [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-hsm-status [input] (clojure.core/let [letvar519266 {"HsmClientCertificateIdentifier" (portkey.aws/search-for-tag input "HsmClientCertificateIdentifier" :flattened? nil :xmlAttribute? nil), "HsmConfigurationIdentifier" (portkey.aws/search-for-tag input "HsmConfigurationIdentifier" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519266 "HsmClientCertificateIdentifier") (clojure.core/assoc :hsm-client-certificate-identifier (deser-string (clojure.core/get-in letvar519266 ["HsmClientCertificateIdentifier" :content]))) (letvar519266 "HsmConfigurationIdentifier") (clojure.core/assoc :hsm-configuration-identifier (deser-string (clojure.core/get-in letvar519266 ["HsmConfigurationIdentifier" :content]))) (letvar519266 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar519266 ["Status" :content]))))))

(clojure.core/defn- deser-elastic-ip-status [input] (clojure.core/let [letvar519374 {"ElasticIp" (portkey.aws/search-for-tag input "ElasticIp" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519374 "ElasticIp") (clojure.core/assoc :elastic-ip (deser-string (clojure.core/get-in letvar519374 ["ElasticIp" :content]))) (letvar519374 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar519374 ["Status" :content]))))))

(clojure.core/defn- deser-orderable-cluster-option [input] (clojure.core/let [letvar519482 {"ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ClusterType" (portkey.aws/search-for-tag input "ClusterType" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil), "AvailabilityZones" (portkey.aws/search-for-tag input "AvailabilityZones" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519482 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar519482 ["ClusterVersion" :content]))) (letvar519482 "ClusterType") (clojure.core/assoc :cluster-type (deser-string (clojure.core/get-in letvar519482 ["ClusterType" :content]))) (letvar519482 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar519482 ["NodeType" :content]))) (letvar519482 "AvailabilityZones") (clojure.core/assoc :availability-zones (deser-availability-zone-list (clojure.core/get-in letvar519482 ["AvailabilityZones" :content]))))))

(clojure.core/defn- deser-revision-target [input] (clojure.core/let [letvar519590 {"DatabaseRevision" (portkey.aws/search-for-tag input "DatabaseRevision" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "DatabaseRevisionReleaseDate" (portkey.aws/search-for-tag input "DatabaseRevisionReleaseDate" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519590 "DatabaseRevision") (clojure.core/assoc :database-revision (deser-string (clojure.core/get-in letvar519590 ["DatabaseRevision" :content]))) (letvar519590 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar519590 ["Description" :content]))) (letvar519590 "DatabaseRevisionReleaseDate") (clojure.core/assoc :database-revision-release-date (deser-t-stamp (clojure.core/get-in letvar519590 ["DatabaseRevisionReleaseDate" :content]))))))

(clojure.core/defn- deser-cluster-security-group [input] (clojure.core/let [letvar519698 {"ClusterSecurityGroupName" (portkey.aws/search-for-tag input "ClusterSecurityGroupName" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroups" (portkey.aws/search-for-tag input "EC2SecurityGroups" :flattened? nil :xmlAttribute? nil), "IPRanges" (portkey.aws/search-for-tag input "IPRanges" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519698 "ClusterSecurityGroupName") (clojure.core/assoc :cluster-security-group-name (deser-string (clojure.core/get-in letvar519698 ["ClusterSecurityGroupName" :content]))) (letvar519698 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar519698 ["Description" :content]))) (letvar519698 "EC2SecurityGroups") (clojure.core/assoc :ec-2-security-groups (deser-ec-2-security-group-list (clojure.core/get-in letvar519698 ["EC2SecurityGroups" :content]))) (letvar519698 "IPRanges") (clojure.core/assoc :ip-ranges (deser-ip-range-list (clojure.core/get-in letvar519698 ["IPRanges" :content]))) (letvar519698 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar519698 ["Tags" :content]))))))

(clojure.core/defn- deser-pending-modified-values [input] (clojure.core/let [letvar519806 {"EnhancedVpcRouting" (portkey.aws/search-for-tag input "EnhancedVpcRouting" :flattened? nil :xmlAttribute? nil), "PubliclyAccessible" (portkey.aws/search-for-tag input "PubliclyAccessible" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "NumberOfNodes" (portkey.aws/search-for-tag input "NumberOfNodes" :flattened? nil :xmlAttribute? nil), "ClusterType" (portkey.aws/search-for-tag input "ClusterType" :flattened? nil :xmlAttribute? nil), "MasterUserPassword" (portkey.aws/search-for-tag input "MasterUserPassword" :flattened? nil :xmlAttribute? nil), "EncryptionType" (portkey.aws/search-for-tag input "EncryptionType" :flattened? nil :xmlAttribute? nil), "MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "AutomatedSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "AutomatedSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519806 "EnhancedVpcRouting") (clojure.core/assoc :enhanced-vpc-routing (deser-boolean-optional (clojure.core/get-in letvar519806 ["EnhancedVpcRouting" :content]))) (letvar519806 "PubliclyAccessible") (clojure.core/assoc :publicly-accessible (deser-boolean-optional (clojure.core/get-in letvar519806 ["PubliclyAccessible" :content]))) (letvar519806 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar519806 ["ClusterIdentifier" :content]))) (letvar519806 "NumberOfNodes") (clojure.core/assoc :number-of-nodes (deser-integer-optional (clojure.core/get-in letvar519806 ["NumberOfNodes" :content]))) (letvar519806 "ClusterType") (clojure.core/assoc :cluster-type (deser-string (clojure.core/get-in letvar519806 ["ClusterType" :content]))) (letvar519806 "MasterUserPassword") (clojure.core/assoc :master-user-password (deser-string (clojure.core/get-in letvar519806 ["MasterUserPassword" :content]))) (letvar519806 "EncryptionType") (clojure.core/assoc :encryption-type (deser-string (clojure.core/get-in letvar519806 ["EncryptionType" :content]))) (letvar519806 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar519806 ["MaintenanceTrackName" :content]))) (letvar519806 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar519806 ["ClusterVersion" :content]))) (letvar519806 "AutomatedSnapshotRetentionPeriod") (clojure.core/assoc :automated-snapshot-retention-period (deser-integer-optional (clojure.core/get-in letvar519806 ["AutomatedSnapshotRetentionPeriod" :content]))) (letvar519806 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar519806 ["NodeType" :content]))))))

(clojure.core/defn- deser-subnet-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-subnet coll))) input))

(clojure.core/defn- deser-account-attribute [input] (clojure.core/let [letvar519931 {"AttributeName" (portkey.aws/search-for-tag input "AttributeName" :flattened? nil :xmlAttribute? nil), "AttributeValues" (portkey.aws/search-for-tag input "AttributeValues" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar519931 "AttributeName") (clojure.core/assoc :attribute-name (deser-string (clojure.core/get-in letvar519931 ["AttributeName" :content]))) (letvar519931 "AttributeValues") (clojure.core/assoc :attribute-values (deser-attribute-value-list (clojure.core/get-in letvar519931 ["AttributeValues" :content]))))))

(clojure.core/defn- deser-snapshot-copy-grant [input] (clojure.core/let [letvar520039 {"SnapshotCopyGrantName" (portkey.aws/search-for-tag input "SnapshotCopyGrantName" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar520039 "SnapshotCopyGrantName") (clojure.core/assoc :snapshot-copy-grant-name (deser-string (clojure.core/get-in letvar520039 ["SnapshotCopyGrantName" :content]))) (letvar520039 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar520039 ["KmsKeyId" :content]))) (letvar520039 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar520039 ["Tags" :content]))))))

(clojure.core/defn- deser-parameter-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-parameter-group coll))) input))

(clojure.core/defn- deser-tagged-resource-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tagged-resource coll))) input))

(clojure.core/defn- deser-boolean [input] (clojure.core/when-let [boolstr__283693__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__283693__auto__) true (clojure.core/= "false" boolstr__283693__auto__) false)))

(clojure.core/defn- deser-default-cluster-parameters [input] (clojure.core/let [letvar520183 {"ParameterGroupFamily" (portkey.aws/search-for-tag input "ParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Marker" (portkey.aws/search-for-tag input "Marker" :flattened? nil :xmlAttribute? nil), "Parameters" (portkey.aws/search-for-tag input "Parameters" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar520183 "ParameterGroupFamily") (clojure.core/assoc :parameter-group-family (deser-string (clojure.core/get-in letvar520183 ["ParameterGroupFamily" :content]))) (letvar520183 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520183 ["Marker" :content]))) (letvar520183 "Parameters") (clojure.core/assoc :parameters (deser-parameters-list (clojure.core/get-in letvar520183 ["Parameters" :content]))))))

(clojure.core/defn- response-source-not-found-fault ([input] (response-source-not-found-fault nil input)) ([resultWrapper520185 input] (clojure.core/let [rawinput520184 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520186 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-dependent-service-request-throttling-fault ([input] (response-dependent-service-request-throttling-fault nil input)) ([resultWrapper520188 input] (clojure.core/let [rawinput520187 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520189 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-insufficient-cluster-capacity-fault ([input] (response-insufficient-cluster-capacity-fault nil input)) ([resultWrapper520191 input] (clojure.core/let [rawinput520190 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520192 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-resize-progress-message ([input] (response-resize-progress-message nil input)) ([resultWrapper520194 input] (clojure.core/let [rawinput520193 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520195 {"AvgResizeRateInMegaBytesPerSecond" (portkey.aws/search-for-tag rawinput520193 "AvgResizeRateInMegaBytesPerSecond" :flattened? nil :result-wrapper resultWrapper520194), "ImportTablesNotStarted" (portkey.aws/search-for-tag rawinput520193 "ImportTablesNotStarted" :flattened? nil :result-wrapper resultWrapper520194), "TotalResizeDataInMegaBytes" (portkey.aws/search-for-tag rawinput520193 "TotalResizeDataInMegaBytes" :flattened? nil :result-wrapper resultWrapper520194), "TargetClusterType" (portkey.aws/search-for-tag rawinput520193 "TargetClusterType" :flattened? nil :result-wrapper resultWrapper520194), "ProgressInMegaBytes" (portkey.aws/search-for-tag rawinput520193 "ProgressInMegaBytes" :flattened? nil :result-wrapper resultWrapper520194), "Status" (portkey.aws/search-for-tag rawinput520193 "Status" :flattened? nil :result-wrapper resultWrapper520194), "ResizeType" (portkey.aws/search-for-tag rawinput520193 "ResizeType" :flattened? nil :result-wrapper resultWrapper520194), "Message" (portkey.aws/search-for-tag rawinput520193 "Message" :flattened? nil :result-wrapper resultWrapper520194), "TargetNodeType" (portkey.aws/search-for-tag rawinput520193 "TargetNodeType" :flattened? nil :result-wrapper resultWrapper520194), "ImportTablesCompleted" (portkey.aws/search-for-tag rawinput520193 "ImportTablesCompleted" :flattened? nil :result-wrapper resultWrapper520194), "ImportTablesInProgress" (portkey.aws/search-for-tag rawinput520193 "ImportTablesInProgress" :flattened? nil :result-wrapper resultWrapper520194), "TargetEncryptionType" (portkey.aws/search-for-tag rawinput520193 "TargetEncryptionType" :flattened? nil :result-wrapper resultWrapper520194), "EstimatedTimeToCompletionInSeconds" (portkey.aws/search-for-tag rawinput520193 "EstimatedTimeToCompletionInSeconds" :flattened? nil :result-wrapper resultWrapper520194), "TargetNumberOfNodes" (portkey.aws/search-for-tag rawinput520193 "TargetNumberOfNodes" :flattened? nil :result-wrapper resultWrapper520194), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag rawinput520193 "ElapsedTimeInSeconds" :flattened? nil :result-wrapper resultWrapper520194)}] (clojure.core/cond-> {} (letvar520195 "AvgResizeRateInMegaBytesPerSecond") (clojure.core/assoc :avg-resize-rate-in-mega-bytes-per-second (deser-double-optional (clojure.core/get-in letvar520195 ["AvgResizeRateInMegaBytesPerSecond" :content]))) (letvar520195 "ImportTablesNotStarted") (clojure.core/assoc :import-tables-not-started (deser-import-tables-not-started (clojure.core/get-in letvar520195 ["ImportTablesNotStarted" :content]))) (letvar520195 "TotalResizeDataInMegaBytes") (clojure.core/assoc :total-resize-data-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar520195 ["TotalResizeDataInMegaBytes" :content]))) (letvar520195 "TargetClusterType") (clojure.core/assoc :target-cluster-type (deser-string (clojure.core/get-in letvar520195 ["TargetClusterType" :content]))) (letvar520195 "ProgressInMegaBytes") (clojure.core/assoc :progress-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar520195 ["ProgressInMegaBytes" :content]))) (letvar520195 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar520195 ["Status" :content]))) (letvar520195 "ResizeType") (clojure.core/assoc :resize-type (deser-string (clojure.core/get-in letvar520195 ["ResizeType" :content]))) (letvar520195 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar520195 ["Message" :content]))) (letvar520195 "TargetNodeType") (clojure.core/assoc :target-node-type (deser-string (clojure.core/get-in letvar520195 ["TargetNodeType" :content]))) (letvar520195 "ImportTablesCompleted") (clojure.core/assoc :import-tables-completed (deser-import-tables-completed (clojure.core/get-in letvar520195 ["ImportTablesCompleted" :content]))) (letvar520195 "ImportTablesInProgress") (clojure.core/assoc :import-tables-in-progress (deser-import-tables-in-progress (clojure.core/get-in letvar520195 ["ImportTablesInProgress" :content]))) (letvar520195 "TargetEncryptionType") (clojure.core/assoc :target-encryption-type (deser-string (clojure.core/get-in letvar520195 ["TargetEncryptionType" :content]))) (letvar520195 "EstimatedTimeToCompletionInSeconds") (clojure.core/assoc :estimated-time-to-completion-in-seconds (deser-long-optional (clojure.core/get-in letvar520195 ["EstimatedTimeToCompletionInSeconds" :content]))) (letvar520195 "TargetNumberOfNodes") (clojure.core/assoc :target-number-of-nodes (deser-integer-optional (clojure.core/get-in letvar520195 ["TargetNumberOfNodes" :content]))) (letvar520195 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long-optional (clojure.core/get-in letvar520195 ["ElapsedTimeInSeconds" :content])))))))

(clojure.core/defn- response-batch-modify-cluster-snapshots-limit-exceeded-fault ([input] (response-batch-modify-cluster-snapshots-limit-exceeded-fault nil input)) ([resultWrapper520197 input] (clojure.core/let [rawinput520196 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520198 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-account-attribute-list ([input] (response-account-attribute-list nil input)) ([resultWrapper520200 input] (clojure.core/let [rawinput520199 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520201 {"AccountAttributes" (portkey.aws/search-for-tag rawinput520199 "AccountAttributes" :flattened? nil :result-wrapper resultWrapper520200)}] (clojure.core/cond-> {} (letvar520201 "AccountAttributes") (clojure.core/assoc :account-attributes (deser-attribute-list (clojure.core/get-in letvar520201 ["AccountAttributes" :content])))))))

(clojure.core/defn- response-snapshot-schedule-already-exists-fault ([input] (response-snapshot-schedule-already-exists-fault nil input)) ([resultWrapper520203 input] (clojure.core/let [rawinput520202 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520204 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-already-exists-fault ([input] (response-reserved-node-already-exists-fault nil input)) ([resultWrapper520206 input] (clojure.core/let [rawinput520205 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520207 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-nodes-message ([input] (response-reserved-nodes-message nil input)) ([resultWrapper520209 input] (clojure.core/let [rawinput520208 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520210 {"Marker" (portkey.aws/search-for-tag rawinput520208 "Marker" :flattened? nil :result-wrapper resultWrapper520209), "ReservedNodes" (portkey.aws/search-for-tag rawinput520208 "ReservedNodes" :flattened? nil :result-wrapper resultWrapper520209)}] (clojure.core/cond-> {} (letvar520210 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520210 ["Marker" :content]))) (letvar520210 "ReservedNodes") (clojure.core/assoc :reserved-nodes (deser-reserved-node-list (clojure.core/get-in letvar520210 ["ReservedNodes" :content])))))))

(clojure.core/defn- response-invalid-schedule-fault ([input] (response-invalid-schedule-fault nil input)) ([resultWrapper520212 input] (clojure.core/let [rawinput520211 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520213 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-number-of-nodes-per-cluster-limit-exceeded-fault ([input] (response-number-of-nodes-per-cluster-limit-exceeded-fault nil input)) ([resultWrapper520215 input] (clojure.core/let [rawinput520214 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520216 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-track-list-message ([input] (response-track-list-message nil input)) ([resultWrapper520218 input] (clojure.core/let [rawinput520217 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520219 {"MaintenanceTracks" (portkey.aws/search-for-tag rawinput520217 "MaintenanceTracks" :flattened? nil :result-wrapper resultWrapper520218), "Marker" (portkey.aws/search-for-tag rawinput520217 "Marker" :flattened? nil :result-wrapper resultWrapper520218)}] (clojure.core/cond-> {} (letvar520219 "MaintenanceTracks") (clojure.core/assoc :maintenance-tracks (deser-track-list (clojure.core/get-in letvar520219 ["MaintenanceTracks" :content]))) (letvar520219 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520219 ["Marker" :content])))))))

(clojure.core/defn- response-sns-no-authorization-fault ([input] (response-sns-no-authorization-fault nil input)) ([resultWrapper520221 input] (clojure.core/let [rawinput520220 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520222 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-offerings-message ([input] (response-reserved-node-offerings-message nil input)) ([resultWrapper520224 input] (clojure.core/let [rawinput520223 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520225 {"Marker" (portkey.aws/search-for-tag rawinput520223 "Marker" :flattened? nil :result-wrapper resultWrapper520224), "ReservedNodeOfferings" (portkey.aws/search-for-tag rawinput520223 "ReservedNodeOfferings" :flattened? nil :result-wrapper resultWrapper520224)}] (clojure.core/cond-> {} (letvar520225 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520225 ["Marker" :content]))) (letvar520225 "ReservedNodeOfferings") (clojure.core/assoc :reserved-node-offerings (deser-reserved-node-offering-list (clojure.core/get-in letvar520225 ["ReservedNodeOfferings" :content])))))))

(clojure.core/defn- response-cluster-parameter-group-quota-exceeded-fault ([input] (response-cluster-parameter-group-quota-exceeded-fault nil input)) ([resultWrapper520227 input] (clojure.core/let [rawinput520226 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520228 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-elastic-ip-fault ([input] (response-invalid-elastic-ip-fault nil input)) ([resultWrapper520230 input] (clojure.core/let [rawinput520229 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520231 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-disable-snapshot-copy-result ([input] (response-disable-snapshot-copy-result nil input)) ([resultWrapper520233 input] (clojure.core/let [rawinput520232 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520234 {"Cluster" (portkey.aws/search-for-tag rawinput520232 "Cluster" :flattened? nil :result-wrapper resultWrapper520233)}] (clojure.core/cond-> {} (letvar520234 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520234 ["Cluster" :content])))))))

(clojure.core/defn- response-snapshot-schedule-update-in-progress-fault ([input] (response-snapshot-schedule-update-in-progress-fault nil input)) ([resultWrapper520236 input] (clojure.core/let [rawinput520235 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520237 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorize-snapshot-access-result ([input] (response-authorize-snapshot-access-result nil input)) ([resultWrapper520239 input] (clojure.core/let [rawinput520238 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520240 {"Snapshot" (portkey.aws/search-for-tag rawinput520238 "Snapshot" :flattened? nil :result-wrapper resultWrapper520239)}] (clojure.core/cond-> {} (letvar520240 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar520240 ["Snapshot" :content])))))))

(clojure.core/defn- response-hsm-client-certificate-quota-exceeded-fault ([input] (response-hsm-client-certificate-quota-exceeded-fault nil input)) ([resultWrapper520242 input] (clojure.core/let [rawinput520241 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520243 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-quota-exceeded-fault ([input] (response-cluster-subnet-quota-exceeded-fault nil input)) ([resultWrapper520245 input] (clojure.core/let [rawinput520244 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520246 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-db-revisions-message ([input] (response-cluster-db-revisions-message nil input)) ([resultWrapper520248 input] (clojure.core/let [rawinput520247 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520249 {"Marker" (portkey.aws/search-for-tag rawinput520247 "Marker" :flattened? nil :result-wrapper resultWrapper520248), "ClusterDbRevisions" (portkey.aws/search-for-tag rawinput520247 "ClusterDbRevisions" :flattened? nil :result-wrapper resultWrapper520248)}] (clojure.core/cond-> {} (letvar520249 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520249 ["Marker" :content]))) (letvar520249 "ClusterDbRevisions") (clojure.core/assoc :cluster-db-revisions (deser-cluster-db-revisions-list (clojure.core/get-in letvar520249 ["ClusterDbRevisions" :content])))))))

(clojure.core/defn- response-create-cluster-parameter-group-result ([input] (response-create-cluster-parameter-group-result nil input)) ([resultWrapper520251 input] (clojure.core/let [rawinput520250 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520252 {"ClusterParameterGroup" (portkey.aws/search-for-tag rawinput520250 "ClusterParameterGroup" :flattened? nil :result-wrapper resultWrapper520251)}] (clojure.core/cond-> {} (letvar520252 "ClusterParameterGroup") (clojure.core/assoc :cluster-parameter-group (deser-cluster-parameter-group (clojure.core/get-in letvar520252 ["ClusterParameterGroup" :content])))))))

(clojure.core/defn- response-cluster-parameter-group-already-exists-fault ([input] (response-cluster-parameter-group-already-exists-fault nil input)) ([resultWrapper520254 input] (clojure.core/let [rawinput520253 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520255 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-not-found-fault ([input] (response-reserved-node-not-found-fault nil input)) ([resultWrapper520257 input] (clojure.core/let [rawinput520256 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520258 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-hsm-configuration-message ([input] (response-hsm-configuration-message nil input)) ([resultWrapper520260 input] (clojure.core/let [rawinput520259 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520261 {"Marker" (portkey.aws/search-for-tag rawinput520259 "Marker" :flattened? nil :result-wrapper resultWrapper520260), "HsmConfigurations" (portkey.aws/search-for-tag rawinput520259 "HsmConfigurations" :flattened? nil :result-wrapper resultWrapper520260)}] (clojure.core/cond-> {} (letvar520261 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520261 ["Marker" :content]))) (letvar520261 "HsmConfigurations") (clojure.core/assoc :hsm-configurations (deser-hsm-configuration-list (clojure.core/get-in letvar520261 ["HsmConfigurations" :content])))))))

(clojure.core/defn- response-invalid-hsm-configuration-state-fault ([input] (response-invalid-hsm-configuration-state-fault nil input)) ([resultWrapper520263 input] (clojure.core/let [rawinput520262 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520264 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-already-exists-fault ([input] (response-cluster-already-exists-fault nil input)) ([resultWrapper520266 input] (clojure.core/let [rawinput520265 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520267 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-s-3-bucket-name-fault ([input] (response-invalid-s-3-bucket-name-fault nil input)) ([resultWrapper520269 input] (clojure.core/let [rawinput520268 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520270 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-customer-storage-message ([input] (response-customer-storage-message nil input)) ([resultWrapper520272 input] (clojure.core/let [rawinput520271 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520273 {"TotalBackupSizeInMegaBytes" (portkey.aws/search-for-tag rawinput520271 "TotalBackupSizeInMegaBytes" :flattened? nil :result-wrapper resultWrapper520272), "TotalProvisionedStorageInMegaBytes" (portkey.aws/search-for-tag rawinput520271 "TotalProvisionedStorageInMegaBytes" :flattened? nil :result-wrapper resultWrapper520272)}] (clojure.core/cond-> {} (letvar520273 "TotalBackupSizeInMegaBytes") (clojure.core/assoc :total-backup-size-in-mega-bytes (deser-double (clojure.core/get-in letvar520273 ["TotalBackupSizeInMegaBytes" :content]))) (letvar520273 "TotalProvisionedStorageInMegaBytes") (clojure.core/assoc :total-provisioned-storage-in-mega-bytes (deser-double (clojure.core/get-in letvar520273 ["TotalProvisionedStorageInMegaBytes" :content])))))))

(clojure.core/defn- response-describe-default-cluster-parameters-result ([input] (response-describe-default-cluster-parameters-result nil input)) ([resultWrapper520275 input] (clojure.core/let [rawinput520274 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520276 {"DefaultClusterParameters" (portkey.aws/search-for-tag rawinput520274 "DefaultClusterParameters" :flattened? nil :result-wrapper resultWrapper520275)}] (clojure.core/cond-> {} (letvar520276 "DefaultClusterParameters") (clojure.core/assoc :default-cluster-parameters (deser-default-cluster-parameters (clojure.core/get-in letvar520276 ["DefaultClusterParameters" :content])))))))

(clojure.core/defn- response-invalid-retention-period-fault ([input] (response-invalid-retention-period-fault nil input)) ([resultWrapper520278 input] (clojure.core/let [rawinput520277 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520279 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-message ([input] (response-snapshot-message nil input)) ([resultWrapper520281 input] (clojure.core/let [rawinput520280 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520282 {"Marker" (portkey.aws/search-for-tag rawinput520280 "Marker" :flattened? nil :result-wrapper resultWrapper520281), "Snapshots" (portkey.aws/search-for-tag rawinput520280 "Snapshots" :flattened? nil :result-wrapper resultWrapper520281)}] (clojure.core/cond-> {} (letvar520282 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520282 ["Marker" :content]))) (letvar520282 "Snapshots") (clojure.core/assoc :snapshots (deser-snapshot-list (clojure.core/get-in letvar520282 ["Snapshots" :content])))))))

(clojure.core/defn- response-subscription-severity-not-found-fault ([input] (response-subscription-severity-not-found-fault nil input)) ([resultWrapper520284 input] (clojure.core/let [rawinput520283 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520285 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-vpc-network-state-fault ([input] (response-invalid-vpc-network-state-fault nil input)) ([resultWrapper520287 input] (clojure.core/let [rawinput520286 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520288 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-batch-modify-cluster-snapshots-output-message ([input] (response-batch-modify-cluster-snapshots-output-message nil input)) ([resultWrapper520290 input] (clojure.core/let [rawinput520289 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520291 {"Resources" (portkey.aws/search-for-tag rawinput520289 "Resources" :flattened? nil :result-wrapper resultWrapper520290), "Errors" (portkey.aws/search-for-tag rawinput520289 "Errors" :flattened? nil :result-wrapper resultWrapper520290)}] (clojure.core/cond-> {} (letvar520291 "Resources") (clojure.core/assoc :resources (deser-snapshot-identifier-list (clojure.core/get-in letvar520291 ["Resources" :content]))) (letvar520291 "Errors") (clojure.core/assoc :errors (deser-batch-snapshot-operation-errors (clojure.core/get-in letvar520291 ["Errors" :content])))))))

(clojure.core/defn- response-revoke-cluster-security-group-ingress-result ([input] (response-revoke-cluster-security-group-ingress-result nil input)) ([resultWrapper520293 input] (clojure.core/let [rawinput520292 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520294 {"ClusterSecurityGroup" (portkey.aws/search-for-tag rawinput520292 "ClusterSecurityGroup" :flattened? nil :result-wrapper resultWrapper520293)}] (clojure.core/cond-> {} (letvar520294 "ClusterSecurityGroup") (clojure.core/assoc :cluster-security-group (deser-cluster-security-group (clojure.core/get-in letvar520294 ["ClusterSecurityGroup" :content])))))))

(clojure.core/defn- response-invalid-table-restore-argument-fault ([input] (response-invalid-table-restore-argument-fault nil input)) ([resultWrapper520296 input] (clojure.core/let [rawinput520295 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520297 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-logging-status ([input] (response-logging-status nil input)) ([resultWrapper520299 input] (clojure.core/let [rawinput520298 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520300 {"LoggingEnabled" (portkey.aws/search-for-tag rawinput520298 "LoggingEnabled" :flattened? nil :result-wrapper resultWrapper520299), "BucketName" (portkey.aws/search-for-tag rawinput520298 "BucketName" :flattened? nil :result-wrapper resultWrapper520299), "S3KeyPrefix" (portkey.aws/search-for-tag rawinput520298 "S3KeyPrefix" :flattened? nil :result-wrapper resultWrapper520299), "LastSuccessfulDeliveryTime" (portkey.aws/search-for-tag rawinput520298 "LastSuccessfulDeliveryTime" :flattened? nil :result-wrapper resultWrapper520299), "LastFailureTime" (portkey.aws/search-for-tag rawinput520298 "LastFailureTime" :flattened? nil :result-wrapper resultWrapper520299), "LastFailureMessage" (portkey.aws/search-for-tag rawinput520298 "LastFailureMessage" :flattened? nil :result-wrapper resultWrapper520299)}] (clojure.core/cond-> {} (letvar520300 "LoggingEnabled") (clojure.core/assoc :logging-enabled (deser-boolean (clojure.core/get-in letvar520300 ["LoggingEnabled" :content]))) (letvar520300 "BucketName") (clojure.core/assoc :bucket-name (deser-string (clojure.core/get-in letvar520300 ["BucketName" :content]))) (letvar520300 "S3KeyPrefix") (clojure.core/assoc :s-3-key-prefix (deser-string (clojure.core/get-in letvar520300 ["S3KeyPrefix" :content]))) (letvar520300 "LastSuccessfulDeliveryTime") (clojure.core/assoc :last-successful-delivery-time (deser-t-stamp (clojure.core/get-in letvar520300 ["LastSuccessfulDeliveryTime" :content]))) (letvar520300 "LastFailureTime") (clojure.core/assoc :last-failure-time (deser-t-stamp (clojure.core/get-in letvar520300 ["LastFailureTime" :content]))) (letvar520300 "LastFailureMessage") (clojure.core/assoc :last-failure-message (deser-string (clojure.core/get-in letvar520300 ["LastFailureMessage" :content])))))))

(clojure.core/defn- response-snapshot-schedule-not-found-fault ([input] (response-snapshot-schedule-not-found-fault nil input)) ([resultWrapper520302 input] (clojure.core/let [rawinput520301 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520303 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-security-group-message ([input] (response-cluster-security-group-message nil input)) ([resultWrapper520305 input] (clojure.core/let [rawinput520304 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520306 {"Marker" (portkey.aws/search-for-tag rawinput520304 "Marker" :flattened? nil :result-wrapper resultWrapper520305), "ClusterSecurityGroups" (portkey.aws/search-for-tag rawinput520304 "ClusterSecurityGroups" :flattened? nil :result-wrapper resultWrapper520305)}] (clojure.core/cond-> {} (letvar520306 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520306 ["Marker" :content]))) (letvar520306 "ClusterSecurityGroups") (clojure.core/assoc :cluster-security-groups (deser-cluster-security-groups (clojure.core/get-in letvar520306 ["ClusterSecurityGroups" :content])))))))

(clojure.core/defn- response-event-categories-message ([input] (response-event-categories-message nil input)) ([resultWrapper520308 input] (clojure.core/let [rawinput520307 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520309 {"EventCategoriesMapList" (portkey.aws/search-for-tag rawinput520307 "EventCategoriesMapList" :flattened? nil :result-wrapper resultWrapper520308)}] (clojure.core/cond-> {} (letvar520309 "EventCategoriesMapList") (clojure.core/assoc :event-categories-map-list (deser-event-categories-map-list (clojure.core/get-in letvar520309 ["EventCategoriesMapList" :content])))))))

(clojure.core/defn- response-hsm-configuration-already-exists-fault ([input] (response-hsm-configuration-already-exists-fault nil input)) ([resultWrapper520311 input] (clojure.core/let [rawinput520310 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520312 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-not-found-fault ([input] (response-subscription-not-found-fault nil input)) ([resultWrapper520314 input] (clojure.core/let [rawinput520313 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520315 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorization-already-exists-fault ([input] (response-authorization-already-exists-fault nil input)) ([resultWrapper520317 input] (clojure.core/let [rawinput520316 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520318 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-bucket-not-found-fault ([input] (response-bucket-not-found-fault nil input)) ([resultWrapper520320 input] (clojure.core/let [rawinput520319 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520321 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-copy-to-region-disabled-fault ([input] (response-copy-to-region-disabled-fault nil input)) ([resultWrapper520323 input] (clojure.core/let [rawinput520322 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520324 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-sns-topic-arn-not-found-fault ([input] (response-sns-topic-arn-not-found-fault nil input)) ([resultWrapper520326 input] (clojure.core/let [rawinput520325 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520327 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-events-message ([input] (response-events-message nil input)) ([resultWrapper520329 input] (clojure.core/let [rawinput520328 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520330 {"Marker" (portkey.aws/search-for-tag rawinput520328 "Marker" :flattened? nil :result-wrapper resultWrapper520329), "Events" (portkey.aws/search-for-tag rawinput520328 "Events" :flattened? nil :result-wrapper resultWrapper520329)}] (clojure.core/cond-> {} (letvar520330 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520330 ["Marker" :content]))) (letvar520330 "Events") (clojure.core/assoc :events (deser-event-list (clojure.core/get-in letvar520330 ["Events" :content])))))))

(clojure.core/defn- response-create-cluster-snapshot-result ([input] (response-create-cluster-snapshot-result nil input)) ([resultWrapper520332 input] (clojure.core/let [rawinput520331 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520333 {"Snapshot" (portkey.aws/search-for-tag rawinput520331 "Snapshot" :flattened? nil :result-wrapper resultWrapper520332)}] (clojure.core/cond-> {} (letvar520333 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar520333 ["Snapshot" :content])))))))

(clojure.core/defn- response-cluster-security-group-quota-exceeded-fault ([input] (response-cluster-security-group-quota-exceeded-fault nil input)) ([resultWrapper520335 input] (clojure.core/let [rawinput520334 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520336 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unauthorized-operation ([input] (response-unauthorized-operation nil input)) ([resultWrapper520338 input] (clojure.core/let [rawinput520337 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520339 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-category-not-found-fault ([input] (response-subscription-category-not-found-fault nil input)) ([resultWrapper520341 input] (clojure.core/let [rawinput520340 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520342 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-rotate-encryption-key-result ([input] (response-rotate-encryption-key-result nil input)) ([resultWrapper520344 input] (clojure.core/let [rawinput520343 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520345 {"Cluster" (portkey.aws/search-for-tag rawinput520343 "Cluster" :flattened? nil :result-wrapper resultWrapper520344)}] (clojure.core/cond-> {} (letvar520345 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520345 ["Cluster" :content])))))))

(clojure.core/defn- response-invalid-hsm-client-certificate-state-fault ([input] (response-invalid-hsm-client-certificate-state-fault nil input)) ([resultWrapper520347 input] (clojure.core/let [rawinput520346 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520348 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-accept-reserved-node-exchange-output-message ([input] (response-accept-reserved-node-exchange-output-message nil input)) ([resultWrapper520350 input] (clojure.core/let [rawinput520349 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520351 {"ExchangedReservedNode" (portkey.aws/search-for-tag rawinput520349 "ExchangedReservedNode" :flattened? nil :result-wrapper resultWrapper520350)}] (clojure.core/cond-> {} (letvar520351 "ExchangedReservedNode") (clojure.core/assoc :exchanged-reserved-node (deser-reserved-node (clojure.core/get-in letvar520351 ["ExchangedReservedNode" :content])))))))

(clojure.core/defn- response-event-subscriptions-message ([input] (response-event-subscriptions-message nil input)) ([resultWrapper520353 input] (clojure.core/let [rawinput520352 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520354 {"Marker" (portkey.aws/search-for-tag rawinput520352 "Marker" :flattened? nil :result-wrapper resultWrapper520353), "EventSubscriptionsList" (portkey.aws/search-for-tag rawinput520352 "EventSubscriptionsList" :flattened? nil :result-wrapper resultWrapper520353)}] (clojure.core/cond-> {} (letvar520354 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520354 ["Marker" :content]))) (letvar520354 "EventSubscriptionsList") (clojure.core/assoc :event-subscriptions-list (deser-event-subscriptions-list (clojure.core/get-in letvar520354 ["EventSubscriptionsList" :content])))))))

(clojure.core/defn- response-create-event-subscription-result ([input] (response-create-event-subscription-result nil input)) ([resultWrapper520356 input] (clojure.core/let [rawinput520355 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520357 {"EventSubscription" (portkey.aws/search-for-tag rawinput520355 "EventSubscription" :flattened? nil :result-wrapper resultWrapper520356)}] (clojure.core/cond-> {} (letvar520357 "EventSubscription") (clojure.core/assoc :event-subscription (deser-event-subscription (clojure.core/get-in letvar520357 ["EventSubscription" :content])))))))

(clojure.core/defn- response-restore-table-from-cluster-snapshot-result ([input] (response-restore-table-from-cluster-snapshot-result nil input)) ([resultWrapper520359 input] (clojure.core/let [rawinput520358 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520360 {"TableRestoreStatus" (portkey.aws/search-for-tag rawinput520358 "TableRestoreStatus" :flattened? nil :result-wrapper resultWrapper520359)}] (clojure.core/cond-> {} (letvar520360 "TableRestoreStatus") (clojure.core/assoc :table-restore-status (deser-table-restore-status (clojure.core/get-in letvar520360 ["TableRestoreStatus" :content])))))))

(clojure.core/defn- response-invalid-subscription-state-fault ([input] (response-invalid-subscription-state-fault nil input)) ([resultWrapper520362 input] (clojure.core/let [rawinput520361 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520363 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-reserved-node-exchange-offerings-output-message ([input] (response-get-reserved-node-exchange-offerings-output-message nil input)) ([resultWrapper520365 input] (clojure.core/let [rawinput520364 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520366 {"Marker" (portkey.aws/search-for-tag rawinput520364 "Marker" :flattened? nil :result-wrapper resultWrapper520365), "ReservedNodeOfferings" (portkey.aws/search-for-tag rawinput520364 "ReservedNodeOfferings" :flattened? nil :result-wrapper resultWrapper520365)}] (clojure.core/cond-> {} (letvar520366 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520366 ["Marker" :content]))) (letvar520366 "ReservedNodeOfferings") (clojure.core/assoc :reserved-node-offerings (deser-reserved-node-offering-list (clojure.core/get-in letvar520366 ["ReservedNodeOfferings" :content])))))))

(clojure.core/defn- response-resize-not-found-fault ([input] (response-resize-not-found-fault nil input)) ([resultWrapper520368 input] (clojure.core/let [rawinput520367 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520369 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-restore-from-cluster-snapshot-result ([input] (response-restore-from-cluster-snapshot-result nil input)) ([resultWrapper520371 input] (clojure.core/let [rawinput520370 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520372 {"Cluster" (portkey.aws/search-for-tag rawinput520370 "Cluster" :flattened? nil :result-wrapper resultWrapper520371)}] (clojure.core/cond-> {} (letvar520372 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520372 ["Cluster" :content])))))))

(clojure.core/defn- response-authorization-not-found-fault ([input] (response-authorization-not-found-fault nil input)) ([resultWrapper520374 input] (clojure.core/let [rawinput520373 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520375 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-batch-delete-request-size-exceeded-fault ([input] (response-batch-delete-request-size-exceeded-fault nil input)) ([resultWrapper520377 input] (clojure.core/let [rawinput520376 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520378 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-snapshot-not-found-fault ([input] (response-cluster-snapshot-not-found-fault nil input)) ([resultWrapper520380 input] (clojure.core/let [rawinput520379 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520381 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reboot-cluster-result ([input] (response-reboot-cluster-result nil input)) ([resultWrapper520383 input] (clojure.core/let [rawinput520382 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520384 {"Cluster" (portkey.aws/search-for-tag rawinput520382 "Cluster" :flattened? nil :result-wrapper resultWrapper520383)}] (clojure.core/cond-> {} (letvar520384 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520384 ["Cluster" :content])))))))

(clojure.core/defn- response-subnet-already-in-use ([input] (response-subnet-already-in-use nil input)) ([resultWrapper520386 input] (clojure.core/let [rawinput520385 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520387 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-quota-exceeded-fault ([input] (response-cluster-subnet-group-quota-exceeded-fault nil input)) ([resultWrapper520389 input] (clojure.core/let [rawinput520388 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520390 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-subnet ([input] (response-invalid-subnet nil input)) ([resultWrapper520392 input] (clojure.core/let [rawinput520391 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520393 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-cluster-security-group-result ([input] (response-create-cluster-security-group-result nil input)) ([resultWrapper520395 input] (clojure.core/let [rawinput520394 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520396 {"ClusterSecurityGroup" (portkey.aws/search-for-tag rawinput520394 "ClusterSecurityGroup" :flattened? nil :result-wrapper resultWrapper520395)}] (clojure.core/cond-> {} (letvar520396 "ClusterSecurityGroup") (clojure.core/assoc :cluster-security-group (deser-cluster-security-group (clojure.core/get-in letvar520396 ["ClusterSecurityGroup" :content])))))))

(clojure.core/defn- response-hsm-client-certificate-message ([input] (response-hsm-client-certificate-message nil input)) ([resultWrapper520398 input] (clojure.core/let [rawinput520397 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520399 {"Marker" (portkey.aws/search-for-tag rawinput520397 "Marker" :flattened? nil :result-wrapper resultWrapper520398), "HsmClientCertificates" (portkey.aws/search-for-tag rawinput520397 "HsmClientCertificates" :flattened? nil :result-wrapper resultWrapper520398)}] (clojure.core/cond-> {} (letvar520399 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520399 ["Marker" :content]))) (letvar520399 "HsmClientCertificates") (clojure.core/assoc :hsm-client-certificates (deser-hsm-client-certificate-list (clojure.core/get-in letvar520399 ["HsmClientCertificates" :content])))))))

(clojure.core/defn- response-invalid-cluster-snapshot-schedule-state-fault ([input] (response-invalid-cluster-snapshot-schedule-state-fault nil input)) ([resultWrapper520401 input] (clojure.core/let [rawinput520400 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520402 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-snapshot-quota-exceeded-fault ([input] (response-cluster-snapshot-quota-exceeded-fault nil input)) ([resultWrapper520404 input] (clojure.core/let [rawinput520403 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520405 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-quota-exceeded-fault ([input] (response-reserved-node-quota-exceeded-fault nil input)) ([resultWrapper520407 input] (clojure.core/let [rawinput520406 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520408 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-hsm-client-certificate-not-found-fault ([input] (response-hsm-client-certificate-not-found-fault nil input)) ([resultWrapper520410 input] (clojure.core/let [rawinput520409 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520411 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-not-found-fault ([input] (response-cluster-subnet-group-not-found-fault nil input)) ([resultWrapper520413 input] (clojure.core/let [rawinput520412 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520414 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unsupported-option-fault ([input] (response-unsupported-option-fault nil input)) ([resultWrapper520416 input] (clojure.core/let [rawinput520415 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520417 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-hsm-configuration-not-found-fault ([input] (response-hsm-configuration-not-found-fault nil input)) ([resultWrapper520419 input] (clojure.core/let [rawinput520418 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520420 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-already-exist-fault ([input] (response-subscription-already-exist-fault nil input)) ([resultWrapper520422 input] (clojure.core/let [rawinput520421 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520423 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-s-3-key-prefix-fault ([input] (response-invalid-s-3-key-prefix-fault nil input)) ([resultWrapper520425 input] (clojure.core/let [rawinput520424 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520426 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-grant-not-found-fault ([input] (response-snapshot-copy-grant-not-found-fault nil input)) ([resultWrapper520428 input] (clojure.core/let [rawinput520427 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520429 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-in-progress-table-restore-quota-exceeded-fault ([input] (response-in-progress-table-restore-quota-exceeded-fault nil input)) ([resultWrapper520431 input] (clojure.core/let [rawinput520430 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520432 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-quota-exceeded-fault ([input] (response-cluster-quota-exceeded-fault nil input)) ([resultWrapper520434 input] (clojure.core/let [rawinput520433 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520435 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-snapshot-copy-grant-state-fault ([input] (response-invalid-snapshot-copy-grant-state-fault nil input)) ([resultWrapper520437 input] (clojure.core/let [rawinput520436 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520438 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-subnet-group-state-fault ([input] (response-invalid-cluster-subnet-group-state-fault nil input)) ([resultWrapper520440 input] (clojure.core/let [rawinput520439 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520441 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-result ([input] (response-modify-cluster-result nil input)) ([resultWrapper520443 input] (clojure.core/let [rawinput520442 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520444 {"Cluster" (portkey.aws/search-for-tag rawinput520442 "Cluster" :flattened? nil :result-wrapper resultWrapper520443)}] (clojure.core/cond-> {} (letvar520444 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520444 ["Cluster" :content])))))))

(clojure.core/defn- response-limit-exceeded-fault ([input] (response-limit-exceeded-fault nil input)) ([resultWrapper520446 input] (clojure.core/let [rawinput520445 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520447 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-resize-cluster-result ([input] (response-resize-cluster-result nil input)) ([resultWrapper520449 input] (clojure.core/let [rawinput520448 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520450 {"Cluster" (portkey.aws/search-for-tag rawinput520448 "Cluster" :flattened? nil :result-wrapper resultWrapper520449)}] (clojure.core/cond-> {} (letvar520450 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520450 ["Cluster" :content])))))))

(clojure.core/defn- response-schedule-definition-type-unsupported-fault ([input] (response-schedule-definition-type-unsupported-fault nil input)) ([resultWrapper520452 input] (clojure.core/let [rawinput520451 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520453 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorization-quota-exceeded-fault ([input] (response-authorization-quota-exceeded-fault nil input)) ([resultWrapper520455 input] (clojure.core/let [rawinput520454 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520456 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-security-group-state-fault ([input] (response-invalid-cluster-security-group-state-fault nil input)) ([resultWrapper520458 input] (clojure.core/let [rawinput520457 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520459 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-parameter-group-not-found-fault ([input] (response-cluster-parameter-group-not-found-fault nil input)) ([resultWrapper520461 input] (clojure.core/let [rawinput520460 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520462 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-event-id-not-found-fault ([input] (response-subscription-event-id-not-found-fault nil input)) ([resultWrapper520464 input] (clojure.core/let [rawinput520463 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520465 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-insufficient-s-3-bucket-policy-fault ([input] (response-insufficient-s-3-bucket-policy-fault nil input)) ([resultWrapper520467 input] (clojure.core/let [rawinput520466 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520468 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-credentials ([input] (response-cluster-credentials nil input)) ([resultWrapper520470 input] (clojure.core/let [rawinput520469 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520471 {"DbUser" (portkey.aws/search-for-tag rawinput520469 "DbUser" :flattened? nil :result-wrapper resultWrapper520470), "DbPassword" (portkey.aws/search-for-tag rawinput520469 "DbPassword" :flattened? nil :result-wrapper resultWrapper520470), "Expiration" (portkey.aws/search-for-tag rawinput520469 "Expiration" :flattened? nil :result-wrapper resultWrapper520470)}] (clojure.core/cond-> {} (letvar520471 "DbUser") (clojure.core/assoc :db-user (deser-string (clojure.core/get-in letvar520471 ["DbUser" :content]))) (letvar520471 "DbPassword") (clojure.core/assoc :db-password (deser-sensitive-string (clojure.core/get-in letvar520471 ["DbPassword" :content]))) (letvar520471 "Expiration") (clojure.core/assoc :expiration (deser-t-stamp (clojure.core/get-in letvar520471 ["Expiration" :content])))))))

(clojure.core/defn- response-hsm-configuration-quota-exceeded-fault ([input] (response-hsm-configuration-quota-exceeded-fault nil input)) ([resultWrapper520473 input] (clojure.core/let [rawinput520472 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520474 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-snapshot-state-fault ([input] (response-invalid-cluster-snapshot-state-fault nil input)) ([resultWrapper520476 input] (clojure.core/let [rawinput520475 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520477 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-already-enabled-fault ([input] (response-snapshot-copy-already-enabled-fault nil input)) ([resultWrapper520479 input] (clojure.core/let [rawinput520478 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520480 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-resource-not-found-fault ([input] (response-resource-not-found-fault nil input)) ([resultWrapper520482 input] (clojure.core/let [rawinput520481 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520483 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-copy-cluster-snapshot-result ([input] (response-copy-cluster-snapshot-result nil input)) ([resultWrapper520485 input] (clojure.core/let [rawinput520484 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520486 {"Snapshot" (portkey.aws/search-for-tag rawinput520484 "Snapshot" :flattened? nil :result-wrapper resultWrapper520485)}] (clojure.core/cond-> {} (letvar520486 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar520486 ["Snapshot" :content])))))))

(clojure.core/defn- response-create-snapshot-copy-grant-result ([input] (response-create-snapshot-copy-grant-result nil input)) ([resultWrapper520488 input] (clojure.core/let [rawinput520487 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520489 {"SnapshotCopyGrant" (portkey.aws/search-for-tag rawinput520487 "SnapshotCopyGrant" :flattened? nil :result-wrapper resultWrapper520488)}] (clojure.core/cond-> {} (letvar520489 "SnapshotCopyGrant") (clojure.core/assoc :snapshot-copy-grant (deser-snapshot-copy-grant (clojure.core/get-in letvar520489 ["SnapshotCopyGrant" :content])))))))

(clojure.core/defn- response-reserved-node-already-migrated-fault ([input] (response-reserved-node-already-migrated-fault nil input)) ([resultWrapper520491 input] (clojure.core/let [rawinput520490 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520492 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-grant-quota-exceeded-fault ([input] (response-snapshot-copy-grant-quota-exceeded-fault nil input)) ([resultWrapper520494 input] (clojure.core/let [rawinput520493 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520495 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-table-restore-not-found-fault ([input] (response-table-restore-not-found-fault nil input)) ([resultWrapper520497 input] (clojure.core/let [rawinput520496 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520498 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-security-group-already-exists-fault ([input] (response-cluster-security-group-already-exists-fault nil input)) ([resultWrapper520500 input] (clojure.core/let [rawinput520499 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520501 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-schedule-quota-exceeded-fault ([input] (response-snapshot-schedule-quota-exceeded-fault nil input)) ([resultWrapper520503 input] (clojure.core/let [rawinput520502 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520504 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-offering-not-found-fault ([input] (response-reserved-node-offering-not-found-fault nil input)) ([resultWrapper520506 input] (clojure.core/let [rawinput520505 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520507 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-security-group-not-found-fault ([input] (response-cluster-security-group-not-found-fault nil input)) ([resultWrapper520509 input] (clojure.core/let [rawinput520508 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520510 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-incompatible-orderable-options ([input] (response-incompatible-orderable-options nil input)) ([resultWrapper520512 input] (clojure.core/let [rawinput520511 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520513 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-cluster-snapshot-result ([input] (response-delete-cluster-snapshot-result nil input)) ([resultWrapper520515 input] (clojure.core/let [rawinput520514 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520516 {"Snapshot" (portkey.aws/search-for-tag rawinput520514 "Snapshot" :flattened? nil :result-wrapper resultWrapper520515)}] (clojure.core/cond-> {} (letvar520516 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar520516 ["Snapshot" :content])))))))

(clojure.core/defn- response-event-subscription-quota-exceeded-fault ([input] (response-event-subscription-quota-exceeded-fault nil input)) ([resultWrapper520518 input] (clojure.core/let [rawinput520517 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520519 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-db-revision-result ([input] (response-modify-cluster-db-revision-result nil input)) ([resultWrapper520521 input] (clojure.core/let [rawinput520520 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520522 {"Cluster" (portkey.aws/search-for-tag rawinput520520 "Cluster" :flattened? nil :result-wrapper resultWrapper520521)}] (clojure.core/cond-> {} (letvar520522 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520522 ["Cluster" :content])))))))

(clojure.core/defn- response-create-cluster-result ([input] (response-create-cluster-result nil input)) ([resultWrapper520524 input] (clojure.core/let [rawinput520523 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520525 {"Cluster" (portkey.aws/search-for-tag rawinput520523 "Cluster" :flattened? nil :result-wrapper resultWrapper520524)}] (clojure.core/cond-> {} (letvar520525 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520525 ["Cluster" :content])))))))

(clojure.core/defn- response-snapshot-copy-grant-message ([input] (response-snapshot-copy-grant-message nil input)) ([resultWrapper520527 input] (clojure.core/let [rawinput520526 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520528 {"Marker" (portkey.aws/search-for-tag rawinput520526 "Marker" :flattened? nil :result-wrapper resultWrapper520527), "SnapshotCopyGrants" (portkey.aws/search-for-tag rawinput520526 "SnapshotCopyGrants" :flattened? nil :result-wrapper resultWrapper520527)}] (clojure.core/cond-> {} (letvar520528 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520528 ["Marker" :content]))) (letvar520528 "SnapshotCopyGrants") (clojure.core/assoc :snapshot-copy-grants (deser-snapshot-copy-grant-list (clojure.core/get-in letvar520528 ["SnapshotCopyGrants" :content])))))))

(clojure.core/defn- response-tagged-resource-list-message ([input] (response-tagged-resource-list-message nil input)) ([resultWrapper520530 input] (clojure.core/let [rawinput520529 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520531 {"TaggedResources" (portkey.aws/search-for-tag rawinput520529 "TaggedResources" :flattened? nil :result-wrapper resultWrapper520530), "Marker" (portkey.aws/search-for-tag rawinput520529 "Marker" :flattened? nil :result-wrapper resultWrapper520530)}] (clojure.core/cond-> {} (letvar520531 "TaggedResources") (clojure.core/assoc :tagged-resources (deser-tagged-resource-list (clojure.core/get-in letvar520531 ["TaggedResources" :content]))) (letvar520531 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520531 ["Marker" :content])))))))

(clojure.core/defn- response-invalid-tag-fault ([input] (response-invalid-tag-fault nil input)) ([resultWrapper520533 input] (clojure.core/let [rawinput520532 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520534 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-dependent-service-unavailable-fault ([input] (response-dependent-service-unavailable-fault nil input)) ([resultWrapper520536 input] (clojure.core/let [rawinput520535 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520537 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-already-exists-fault ([input] (response-cluster-subnet-group-already-exists-fault nil input)) ([resultWrapper520539 input] (clojure.core/let [rawinput520538 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520540 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-parameter-group-details ([input] (response-cluster-parameter-group-details nil input)) ([resultWrapper520542 input] (clojure.core/let [rawinput520541 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520543 {"Parameters" (portkey.aws/search-for-tag rawinput520541 "Parameters" :flattened? nil :result-wrapper resultWrapper520542), "Marker" (portkey.aws/search-for-tag rawinput520541 "Marker" :flattened? nil :result-wrapper resultWrapper520542)}] (clojure.core/cond-> {} (letvar520543 "Parameters") (clojure.core/assoc :parameters (deser-parameters-list (clojure.core/get-in letvar520543 ["Parameters" :content]))) (letvar520543 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520543 ["Marker" :content])))))))

(clojure.core/defn- response-orderable-cluster-options-message ([input] (response-orderable-cluster-options-message nil input)) ([resultWrapper520545 input] (clojure.core/let [rawinput520544 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520546 {"OrderableClusterOptions" (portkey.aws/search-for-tag rawinput520544 "OrderableClusterOptions" :flattened? nil :result-wrapper resultWrapper520545), "Marker" (portkey.aws/search-for-tag rawinput520544 "Marker" :flattened? nil :result-wrapper resultWrapper520545)}] (clojure.core/cond-> {} (letvar520546 "OrderableClusterOptions") (clojure.core/assoc :orderable-cluster-options (deser-orderable-cluster-options-list (clojure.core/get-in letvar520546 ["OrderableClusterOptions" :content]))) (letvar520546 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520546 ["Marker" :content])))))))

(clojure.core/defn- response-snapshot-schedule ([input] (response-snapshot-schedule nil input)) ([resultWrapper520548 input] (clojure.core/let [rawinput520547 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520549 {"ScheduleDefinitions" (portkey.aws/search-for-tag rawinput520547 "ScheduleDefinitions" :flattened? nil :result-wrapper resultWrapper520548), "ScheduleIdentifier" (portkey.aws/search-for-tag rawinput520547 "ScheduleIdentifier" :flattened? nil :result-wrapper resultWrapper520548), "ScheduleDescription" (portkey.aws/search-for-tag rawinput520547 "ScheduleDescription" :flattened? nil :result-wrapper resultWrapper520548), "Tags" (portkey.aws/search-for-tag rawinput520547 "Tags" :flattened? nil :result-wrapper resultWrapper520548), "NextInvocations" (portkey.aws/search-for-tag rawinput520547 "NextInvocations" :flattened? nil :result-wrapper resultWrapper520548), "AssociatedClusterCount" (portkey.aws/search-for-tag rawinput520547 "AssociatedClusterCount" :flattened? nil :result-wrapper resultWrapper520548), "AssociatedClusters" (portkey.aws/search-for-tag rawinput520547 "AssociatedClusters" :flattened? nil :result-wrapper resultWrapper520548)}] (clojure.core/cond-> {} (letvar520549 "ScheduleDefinitions") (clojure.core/assoc :schedule-definitions (deser-schedule-definition-list (clojure.core/get-in letvar520549 ["ScheduleDefinitions" :content]))) (letvar520549 "ScheduleIdentifier") (clojure.core/assoc :schedule-identifier (deser-string (clojure.core/get-in letvar520549 ["ScheduleIdentifier" :content]))) (letvar520549 "ScheduleDescription") (clojure.core/assoc :schedule-description (deser-string (clojure.core/get-in letvar520549 ["ScheduleDescription" :content]))) (letvar520549 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar520549 ["Tags" :content]))) (letvar520549 "NextInvocations") (clojure.core/assoc :next-invocations (deser-scheduled-snapshot-time-list (clojure.core/get-in letvar520549 ["NextInvocations" :content]))) (letvar520549 "AssociatedClusterCount") (clojure.core/assoc :associated-cluster-count (deser-integer-optional (clojure.core/get-in letvar520549 ["AssociatedClusterCount" :content]))) (letvar520549 "AssociatedClusters") (clojure.core/assoc :associated-clusters (deser-associated-cluster-list (clojure.core/get-in letvar520549 ["AssociatedClusters" :content])))))))

(clojure.core/defn- response-describe-snapshot-schedules-output-message ([input] (response-describe-snapshot-schedules-output-message nil input)) ([resultWrapper520551 input] (clojure.core/let [rawinput520550 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520552 {"SnapshotSchedules" (portkey.aws/search-for-tag rawinput520550 "SnapshotSchedules" :flattened? nil :result-wrapper resultWrapper520551), "Marker" (portkey.aws/search-for-tag rawinput520550 "Marker" :flattened? nil :result-wrapper resultWrapper520551)}] (clojure.core/cond-> {} (letvar520552 "SnapshotSchedules") (clojure.core/assoc :snapshot-schedules (deser-snapshot-schedule-list (clojure.core/get-in letvar520552 ["SnapshotSchedules" :content]))) (letvar520552 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520552 ["Marker" :content])))))))

(clojure.core/defn- response-invalid-restore-fault ([input] (response-invalid-restore-fault nil input)) ([resultWrapper520554 input] (clojure.core/let [rawinput520553 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520555 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-state-fault ([input] (response-invalid-cluster-state-fault nil input)) ([resultWrapper520557 input] (clojure.core/let [rawinput520556 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520558 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-already-disabled-fault ([input] (response-snapshot-copy-already-disabled-fault nil input)) ([resultWrapper520560 input] (clojure.core/let [rawinput520559 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520561 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-disabled-fault ([input] (response-snapshot-copy-disabled-fault nil input)) ([resultWrapper520563 input] (clojure.core/let [rawinput520562 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520564 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-not-found-fault ([input] (response-cluster-not-found-fault nil input)) ([resultWrapper520566 input] (clojure.core/let [rawinput520565 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520567 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-message ([input] (response-cluster-subnet-group-message nil input)) ([resultWrapper520569 input] (clojure.core/let [rawinput520568 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520570 {"Marker" (portkey.aws/search-for-tag rawinput520568 "Marker" :flattened? nil :result-wrapper resultWrapper520569), "ClusterSubnetGroups" (portkey.aws/search-for-tag rawinput520568 "ClusterSubnetGroups" :flattened? nil :result-wrapper resultWrapper520569)}] (clojure.core/cond-> {} (letvar520570 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520570 ["Marker" :content]))) (letvar520570 "ClusterSubnetGroups") (clojure.core/assoc :cluster-subnet-groups (deser-cluster-subnet-groups (clojure.core/get-in letvar520570 ["ClusterSubnetGroups" :content])))))))

(clojure.core/defn- response-number-of-nodes-quota-exceeded-fault ([input] (response-number-of-nodes-quota-exceeded-fault nil input)) ([resultWrapper520572 input] (clojure.core/let [rawinput520571 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520573 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-purchase-reserved-node-offering-result ([input] (response-purchase-reserved-node-offering-result nil input)) ([resultWrapper520575 input] (clojure.core/let [rawinput520574 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520576 {"ReservedNode" (portkey.aws/search-for-tag rawinput520574 "ReservedNode" :flattened? nil :result-wrapper resultWrapper520575)}] (clojure.core/cond-> {} (letvar520576 "ReservedNode") (clojure.core/assoc :reserved-node (deser-reserved-node (clojure.core/get-in letvar520576 ["ReservedNode" :content])))))))

(clojure.core/defn- response-clusters-message ([input] (response-clusters-message nil input)) ([resultWrapper520578 input] (clojure.core/let [rawinput520577 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520579 {"Marker" (portkey.aws/search-for-tag rawinput520577 "Marker" :flattened? nil :result-wrapper resultWrapper520578), "Clusters" (portkey.aws/search-for-tag rawinput520577 "Clusters" :flattened? nil :result-wrapper resultWrapper520578)}] (clojure.core/cond-> {} (letvar520579 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520579 ["Marker" :content]))) (letvar520579 "Clusters") (clojure.core/assoc :clusters (deser-cluster-list (clojure.core/get-in letvar520579 ["Clusters" :content])))))))

(clojure.core/defn- response-create-hsm-client-certificate-result ([input] (response-create-hsm-client-certificate-result nil input)) ([resultWrapper520581 input] (clojure.core/let [rawinput520580 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520582 {"HsmClientCertificate" (portkey.aws/search-for-tag rawinput520580 "HsmClientCertificate" :flattened? nil :result-wrapper resultWrapper520581)}] (clojure.core/cond-> {} (letvar520582 "HsmClientCertificate") (clojure.core/assoc :hsm-client-certificate (deser-hsm-client-certificate (clojure.core/get-in letvar520582 ["HsmClientCertificate" :content])))))))

(clojure.core/defn- response-revoke-snapshot-access-result ([input] (response-revoke-snapshot-access-result nil input)) ([resultWrapper520584 input] (clojure.core/let [rawinput520583 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520585 {"Snapshot" (portkey.aws/search-for-tag rawinput520583 "Snapshot" :flattened? nil :result-wrapper resultWrapper520584)}] (clojure.core/cond-> {} (letvar520585 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar520585 ["Snapshot" :content])))))))

(clojure.core/defn- response-invalid-cluster-subnet-state-fault ([input] (response-invalid-cluster-subnet-state-fault nil input)) ([resultWrapper520587 input] (clojure.core/let [rawinput520586 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520588 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-cluster-result ([input] (response-delete-cluster-result nil input)) ([resultWrapper520590 input] (clojure.core/let [rawinput520589 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520591 {"Cluster" (portkey.aws/search-for-tag rawinput520589 "Cluster" :flattened? nil :result-wrapper resultWrapper520590)}] (clojure.core/cond-> {} (letvar520591 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520591 ["Cluster" :content])))))))

(clojure.core/defn- response-modify-snapshot-copy-retention-period-result ([input] (response-modify-snapshot-copy-retention-period-result nil input)) ([resultWrapper520593 input] (clojure.core/let [rawinput520592 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520594 {"Cluster" (portkey.aws/search-for-tag rawinput520592 "Cluster" :flattened? nil :result-wrapper resultWrapper520593)}] (clojure.core/cond-> {} (letvar520594 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520594 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-parameter-group-name-message ([input] (response-cluster-parameter-group-name-message nil input)) ([resultWrapper520596 input] (clojure.core/let [rawinput520595 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520597 {"ParameterGroupName" (portkey.aws/search-for-tag rawinput520595 "ParameterGroupName" :flattened? nil :result-wrapper resultWrapper520596), "ParameterGroupStatus" (portkey.aws/search-for-tag rawinput520595 "ParameterGroupStatus" :flattened? nil :result-wrapper resultWrapper520596)}] (clojure.core/cond-> {} (letvar520597 "ParameterGroupName") (clojure.core/assoc :parameter-group-name (deser-string (clojure.core/get-in letvar520597 ["ParameterGroupName" :content]))) (letvar520597 "ParameterGroupStatus") (clojure.core/assoc :parameter-group-status (deser-string (clojure.core/get-in letvar520597 ["ParameterGroupStatus" :content])))))))

(clojure.core/defn- response-modify-event-subscription-result ([input] (response-modify-event-subscription-result nil input)) ([resultWrapper520599 input] (clojure.core/let [rawinput520598 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520600 {"EventSubscription" (portkey.aws/search-for-tag rawinput520598 "EventSubscription" :flattened? nil :result-wrapper resultWrapper520599)}] (clojure.core/cond-> {} (letvar520600 "EventSubscription") (clojure.core/assoc :event-subscription (deser-event-subscription (clojure.core/get-in letvar520600 ["EventSubscription" :content])))))))

(clojure.core/defn- response-modify-cluster-maintenance-result ([input] (response-modify-cluster-maintenance-result nil input)) ([resultWrapper520602 input] (clojure.core/let [rawinput520601 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520603 {"Cluster" (portkey.aws/search-for-tag rawinput520601 "Cluster" :flattened? nil :result-wrapper resultWrapper520602)}] (clojure.core/cond-> {} (letvar520603 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520603 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-versions-message ([input] (response-cluster-versions-message nil input)) ([resultWrapper520605 input] (clojure.core/let [rawinput520604 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520606 {"Marker" (portkey.aws/search-for-tag rawinput520604 "Marker" :flattened? nil :result-wrapper resultWrapper520605), "ClusterVersions" (portkey.aws/search-for-tag rawinput520604 "ClusterVersions" :flattened? nil :result-wrapper resultWrapper520605)}] (clojure.core/cond-> {} (letvar520606 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520606 ["Marker" :content]))) (letvar520606 "ClusterVersions") (clojure.core/assoc :cluster-versions (deser-cluster-version-list (clojure.core/get-in letvar520606 ["ClusterVersions" :content])))))))

(clojure.core/defn- response-snapshot-copy-grant-already-exists-fault ([input] (response-snapshot-copy-grant-already-exists-fault nil input)) ([resultWrapper520608 input] (clojure.core/let [rawinput520607 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520609 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-sns-invalid-topic-fault ([input] (response-sns-invalid-topic-fault nil input)) ([resultWrapper520611 input] (clojure.core/let [rawinput520610 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520612 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unknown-snapshot-copy-region-fault ([input] (response-unknown-snapshot-copy-region-fault nil input)) ([resultWrapper520614 input] (clojure.core/let [rawinput520613 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520615 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-table-limit-exceeded-fault ([input] (response-table-limit-exceeded-fault nil input)) ([resultWrapper520617 input] (clojure.core/let [rawinput520616 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520618 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-subnet-group-result ([input] (response-modify-cluster-subnet-group-result nil input)) ([resultWrapper520620 input] (clojure.core/let [rawinput520619 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520621 {"ClusterSubnetGroup" (portkey.aws/search-for-tag rawinput520619 "ClusterSubnetGroup" :flattened? nil :result-wrapper resultWrapper520620)}] (clojure.core/cond-> {} (letvar520621 "ClusterSubnetGroup") (clojure.core/assoc :cluster-subnet-group (deser-cluster-subnet-group (clojure.core/get-in letvar520621 ["ClusterSubnetGroup" :content])))))))

(clojure.core/defn- response-access-to-snapshot-denied-fault ([input] (response-access-to-snapshot-denied-fault nil input)) ([resultWrapper520623 input] (clojure.core/let [rawinput520622 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520624 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-batch-delete-cluster-snapshots-result ([input] (response-batch-delete-cluster-snapshots-result nil input)) ([resultWrapper520626 input] (clojure.core/let [rawinput520625 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520627 {"Resources" (portkey.aws/search-for-tag rawinput520625 "Resources" :flattened? nil :result-wrapper resultWrapper520626), "Errors" (portkey.aws/search-for-tag rawinput520625 "Errors" :flattened? nil :result-wrapper resultWrapper520626)}] (clojure.core/cond-> {} (letvar520627 "Resources") (clojure.core/assoc :resources (deser-snapshot-identifier-list (clojure.core/get-in letvar520627 ["Resources" :content]))) (letvar520627 "Errors") (clojure.core/assoc :errors (deser-batch-snapshot-operation-error-list (clojure.core/get-in letvar520627 ["Errors" :content])))))))

(clojure.core/defn- response-hsm-client-certificate-already-exists-fault ([input] (response-hsm-client-certificate-already-exists-fault nil input)) ([resultWrapper520629 input] (clojure.core/let [rawinput520628 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520630 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-cluster-subnet-group-result ([input] (response-create-cluster-subnet-group-result nil input)) ([resultWrapper520632 input] (clojure.core/let [rawinput520631 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520633 {"ClusterSubnetGroup" (portkey.aws/search-for-tag rawinput520631 "ClusterSubnetGroup" :flattened? nil :result-wrapper resultWrapper520632)}] (clojure.core/cond-> {} (letvar520633 "ClusterSubnetGroup") (clojure.core/assoc :cluster-subnet-group (deser-cluster-subnet-group (clojure.core/get-in letvar520633 ["ClusterSubnetGroup" :content])))))))

(clojure.core/defn- response-invalid-cluster-parameter-group-state-fault ([input] (response-invalid-cluster-parameter-group-state-fault nil input)) ([resultWrapper520635 input] (clojure.core/let [rawinput520634 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520636 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorize-cluster-security-group-ingress-result ([input] (response-authorize-cluster-security-group-ingress-result nil input)) ([resultWrapper520638 input] (clojure.core/let [rawinput520637 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520639 {"ClusterSecurityGroup" (portkey.aws/search-for-tag rawinput520637 "ClusterSecurityGroup" :flattened? nil :result-wrapper resultWrapper520638)}] (clojure.core/cond-> {} (letvar520639 "ClusterSecurityGroup") (clojure.core/assoc :cluster-security-group (deser-cluster-security-group (clojure.core/get-in letvar520639 ["ClusterSecurityGroup" :content])))))))

(clojure.core/defn- response-tag-limit-exceeded-fault ([input] (response-tag-limit-exceeded-fault nil input)) ([resultWrapper520641 input] (clojure.core/let [rawinput520640 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520642 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-iam-roles-result ([input] (response-modify-cluster-iam-roles-result nil input)) ([resultWrapper520644 input] (clojure.core/let [rawinput520643 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520645 {"Cluster" (portkey.aws/search-for-tag rawinput520643 "Cluster" :flattened? nil :result-wrapper resultWrapper520644)}] (clojure.core/cond-> {} (letvar520645 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520645 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-on-latest-revision-fault ([input] (response-cluster-on-latest-revision-fault nil input)) ([resultWrapper520647 input] (clojure.core/let [rawinput520646 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520648 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-snapshot-already-exists-fault ([input] (response-cluster-snapshot-already-exists-fault nil input)) ([resultWrapper520650 input] (clojure.core/let [rawinput520649 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520651 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unsupported-operation-fault ([input] (response-unsupported-operation-fault nil input)) ([resultWrapper520653 input] (clojure.core/let [rawinput520652 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520654 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-hsm-configuration-result ([input] (response-create-hsm-configuration-result nil input)) ([resultWrapper520656 input] (clojure.core/let [rawinput520655 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520657 {"HsmConfiguration" (portkey.aws/search-for-tag rawinput520655 "HsmConfiguration" :flattened? nil :result-wrapper resultWrapper520656)}] (clojure.core/cond-> {} (letvar520657 "HsmConfiguration") (clojure.core/assoc :hsm-configuration (deser-hsm-configuration (clojure.core/get-in letvar520657 ["HsmConfiguration" :content])))))))

(clojure.core/defn- response-modify-cluster-snapshot-result ([input] (response-modify-cluster-snapshot-result nil input)) ([resultWrapper520659 input] (clojure.core/let [rawinput520658 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520660 {"Snapshot" (portkey.aws/search-for-tag rawinput520658 "Snapshot" :flattened? nil :result-wrapper resultWrapper520659)}] (clojure.core/cond-> {} (letvar520660 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar520660 ["Snapshot" :content])))))))

(clojure.core/defn- response-invalid-reserved-node-state-fault ([input] (response-invalid-reserved-node-state-fault nil input)) ([resultWrapper520662 input] (clojure.core/let [rawinput520661 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520663 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-enable-snapshot-copy-result ([input] (response-enable-snapshot-copy-result nil input)) ([resultWrapper520665 input] (clojure.core/let [rawinput520664 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520666 {"Cluster" (portkey.aws/search-for-tag rawinput520664 "Cluster" :flattened? nil :result-wrapper resultWrapper520665)}] (clojure.core/cond-> {} (letvar520666 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar520666 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-parameter-groups-message ([input] (response-cluster-parameter-groups-message nil input)) ([resultWrapper520668 input] (clojure.core/let [rawinput520667 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520669 {"Marker" (portkey.aws/search-for-tag rawinput520667 "Marker" :flattened? nil :result-wrapper resultWrapper520668), "ParameterGroups" (portkey.aws/search-for-tag rawinput520667 "ParameterGroups" :flattened? nil :result-wrapper resultWrapper520668)}] (clojure.core/cond-> {} (letvar520669 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520669 ["Marker" :content]))) (letvar520669 "ParameterGroups") (clojure.core/assoc :parameter-groups (deser-parameter-group-list (clojure.core/get-in letvar520669 ["ParameterGroups" :content])))))))

(clojure.core/defn- response-invalid-cluster-track-fault ([input] (response-invalid-cluster-track-fault nil input)) ([resultWrapper520671 input] (clojure.core/let [rawinput520670 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520672 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-table-restore-status-message ([input] (response-table-restore-status-message nil input)) ([resultWrapper520674 input] (clojure.core/let [rawinput520673 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar520675 {"TableRestoreStatusDetails" (portkey.aws/search-for-tag rawinput520673 "TableRestoreStatusDetails" :flattened? nil :result-wrapper resultWrapper520674), "Marker" (portkey.aws/search-for-tag rawinput520673 "Marker" :flattened? nil :result-wrapper resultWrapper520674)}] (clojure.core/cond-> {} (letvar520675 "TableRestoreStatusDetails") (clojure.core/assoc :table-restore-status-details (deser-table-restore-status-list (clojure.core/get-in letvar520675 ["TableRestoreStatusDetails" :content]))) (letvar520675 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar520675 ["Marker" :content])))))))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/table-restore-request-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-table-restore-status-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/table-restore-request-id :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/max-records :portkey.aws.redshift.-2012-12-01.describe-table-restore-status-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/source-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/vpc-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/vpc-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/encrypted (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/db-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/additional-info (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/master-username (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/port (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/snapshot-schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.create-cluster-message/node-type :portkey.aws.redshift.-2012-12-01.create-cluster-message/master-username :portkey.aws.redshift.-2012-12-01.create-cluster-message/master-user-password] :opt-un [:portkey.aws.redshift.-2012-12-01.create-cluster-message/enhanced-vpc-routing :portkey.aws.redshift.-2012-12-01.create-cluster-message/publicly-accessible :portkey.aws.redshift.-2012-12-01.create-cluster-message/preferred-maintenance-window :portkey.aws.redshift.-2012-12-01.create-cluster-message/encrypted :portkey.aws.redshift.-2012-12-01.create-cluster-message/hsm-client-certificate-identifier :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.create-cluster-message/number-of-nodes :portkey.aws.redshift.-2012-12-01.create-cluster-message/tags :portkey.aws.redshift.-2012-12-01.create-cluster-message/db-name :portkey.aws.redshift.-2012-12-01.create-cluster-message/vpc-security-group-ids :portkey.aws.redshift.-2012-12-01.create-cluster-message/availability-zone :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-type :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-security-groups :portkey.aws.redshift.-2012-12-01.create-cluster-message/additional-info :portkey.aws.redshift.-2012-12-01.create-cluster-message/elastic-ip :portkey.aws.redshift.-2012-12-01.create-cluster-message/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.create-cluster-message/port :portkey.aws.redshift.-2012-12-01.create-cluster-message/maintenance-track-name :portkey.aws.redshift.-2012-12-01.create-cluster-message/kms-key-id :portkey.aws.redshift.-2012-12-01.create-cluster-message/allow-version-upgrade :portkey.aws.redshift.-2012-12-01.create-cluster-message/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-version :portkey.aws.redshift.-2012-12-01.create-cluster-message/automated-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.create-cluster-message/iam-roles :portkey.aws.redshift.-2012-12-01.create-cluster-message/snapshot-schedule-identifier :portkey.aws.redshift.-2012-12-01.create-cluster-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/insufficient-cluster-capacity-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subnet-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-logging-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-logging-message/bucket-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-logging-message/s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/enable-logging-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.enable-logging-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.enable-logging-message/bucket-name] :opt-un [:portkey.aws.redshift.-2012-12-01.enable-logging-message/s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration/hsm-ip-address (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration/hsm-partition-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.hsm-configuration/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.hsm-configuration/description :portkey.aws.redshift.-2012-12-01.hsm-configuration/hsm-ip-address :portkey.aws.redshift.-2012-12-01.hsm-configuration/hsm-partition-name :portkey.aws.redshift.-2012-12-01.hsm-configuration/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/avg-resize-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/total-resize-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-cluster-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/resize-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/message (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-encryption-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-progress-message/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/resize-progress-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.resize-progress-message/avg-resize-rate-in-mega-bytes-per-second :portkey.aws.redshift.-2012-12-01/import-tables-not-started :portkey.aws.redshift.-2012-12-01.resize-progress-message/total-resize-data-in-mega-bytes :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-cluster-type :portkey.aws.redshift.-2012-12-01.resize-progress-message/progress-in-mega-bytes :portkey.aws.redshift.-2012-12-01.resize-progress-message/status :portkey.aws.redshift.-2012-12-01.resize-progress-message/resize-type :portkey.aws.redshift.-2012-12-01.resize-progress-message/message :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-node-type :portkey.aws.redshift.-2012-12-01/import-tables-completed :portkey.aws.redshift.-2012-12-01/import-tables-in-progress :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-encryption-type :portkey.aws.redshift.-2012-12-01.resize-progress-message/estimated-time-to-completion-in-seconds :portkey.aws.redshift.-2012-12-01.resize-progress-message/target-number-of-nodes :portkey.aws.redshift.-2012-12-01.resize-progress-message/elapsed-time-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-hsm-client-certificates-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/hsm-client-certificate-identifier :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/max-records :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/marker :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-hsm-client-certificates-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.maintenance-track/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.maintenance-track/database-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.maintenance-track/update-targets (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/eligible-tracks-to-update-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/maintenance-track (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.maintenance-track/maintenance-track-name :portkey.aws.redshift.-2012-12-01.maintenance-track/database-version :portkey.aws.redshift.-2012-12-01.maintenance-track/update-targets]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/parameters-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/parameter))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/ec-2-security-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/ec-2-security-group))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tag-value-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-schedule-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-schedule-message/disassociate-schedule (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-schedule-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-schedule-message/schedule-identifier :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-schedule-message/disassociate-schedule]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/table-restore-status-type #{"CANCELED" "IN_PROGRESS" :in-progress :pending "PENDING" :canceled "SUCCEEDED" "FAILED" :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/import-tables-not-started (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-node/node-role (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-node/private-ip-address (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-node/public-ip-address (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-node/node-role :portkey.aws.redshift.-2012-12-01.cluster-node/private-ip-address :portkey.aws.redshift.-2012-12-01.cluster-node/public-ip-address]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/attribute-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/account-attribute))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/supported-operation-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/supported-operation))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-cluster-message/classic (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/resize-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.resize-cluster-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.resize-cluster-message/number-of-nodes] :opt-un [:portkey.aws.redshift.-2012-12-01.resize-cluster-message/cluster-type :portkey.aws.redshift.-2012-12-01.resize-cluster-message/node-type :portkey.aws.redshift.-2012-12-01.resize-cluster-message/classic]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/currency-code (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/start-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/node-count (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/fixed-price (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/duration (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/usage-price (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/state (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/recurring-charges (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/offering-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.reserved-node/currency-code :portkey.aws.redshift.-2012-12-01.reserved-node/start-time :portkey.aws.redshift.-2012-12-01.reserved-node/node-count :portkey.aws.redshift.-2012-12-01.reserved-node/fixed-price :portkey.aws.redshift.-2012-12-01/reserved-node-offering-type :portkey.aws.redshift.-2012-12-01.reserved-node/reserved-node-offering-id :portkey.aws.redshift.-2012-12-01.reserved-node/duration :portkey.aws.redshift.-2012-12-01.reserved-node/reserved-node-id :portkey.aws.redshift.-2012-12-01.reserved-node/usage-price :portkey.aws.redshift.-2012-12-01.reserved-node/state :portkey.aws.redshift.-2012-12-01.reserved-node/recurring-charges :portkey.aws.redshift.-2012-12-01.reserved-node/offering-type :portkey.aws.redshift.-2012-12-01.reserved-node/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.account-attribute-list/account-attributes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/attribute-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/account-attribute-list (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.account-attribute-list/account-attributes]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-schedule-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/destination-region (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/enable-snapshot-copy-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/destination-region] :opt-un [:portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/retention-period :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/snapshot-copy-grant-name :portkey.aws.redshift.-2012-12-01.enable-snapshot-copy-message/manual-snapshot-retention-period]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-nodes-message/reserved-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reserved-node-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.reserved-nodes-message/marker :portkey.aws.redshift.-2012-12-01.reserved-nodes-message/reserved-nodes]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/double-optional clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-sorting-entity/attribute (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-attribute-to-sort-by))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-sorting-entity/sort-order (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/sort-by-order))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-sorting-entity (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.snapshot-sorting-entity/attribute] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot-sorting-entity/sort-order]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/source-ids-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-schedule-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/number-of-nodes-per-cluster-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.track-list-message/maintenance-tracks (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/track-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.track-list-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/track-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.track-list-message/maintenance-tracks :portkey.aws.redshift.-2012-12-01.track-list-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/sns-no-authorization-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offerings-message/reserved-node-offerings (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reserved-node-offering-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.reserved-node-offerings-message/marker :portkey.aws.redshift.-2012-12-01.reserved-node-offerings-message/reserved-node-offerings]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/schedule-definition-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-elastic-ip-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-parameter-status))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/disable-snapshot-copy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-schedule-update-in-progress-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorize-snapshot-access-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-clusters-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-clusters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-clusters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-clusters-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-clusters-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-clusters-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.describe-clusters-message/max-records :portkey.aws.redshift.-2012-12-01.describe-clusters-message/marker :portkey.aws.redshift.-2012-12-01.describe-clusters-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-clusters-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-snapshot-access-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-snapshot-access-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-snapshot-access-message/account-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/revoke-snapshot-access-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.revoke-snapshot-access-message/snapshot-identifier :portkey.aws.redshift.-2012-12-01.revoke-snapshot-access-message/account-with-restore-access] :opt-un [:portkey.aws.redshift.-2012-12-01.revoke-snapshot-access-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/snapshot))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-event-subscriptions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/subscription-name :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/max-records :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/marker :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-event-subscriptions-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/associated-cluster-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-associated-to-schedule))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/owner-account (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/additional-info (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/port (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/snapshot-schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/restore-from-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/enhanced-vpc-routing :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/publicly-accessible :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/preferred-maintenance-window :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/owner-account :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/hsm-client-certificate-identifier :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/vpc-security-group-ids :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/availability-zone :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-security-groups :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/additional-info :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/elastic-ip :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/port :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/maintenance-track-name :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/kms-key-id :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/allow-version-upgrade :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/automated-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/iam-roles :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/snapshot-schedule-identifier :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/node-type :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/snapshot-cluster-identifier :portkey.aws.redshift.-2012-12-01.restore-from-cluster-snapshot-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-parameter-group-message/parameter-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.subnet/subnet-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.subnet/subnet-availability-zone (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/availability-zone))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.subnet/subnet-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subnet (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.subnet/subnet-identifier :portkey.aws.redshift.-2012-12-01.subnet/subnet-availability-zone :portkey.aws.redshift.-2012-12-01.subnet/subnet-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-hsm-configurations-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/max-records :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/marker :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-hsm-configurations-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/parameter-group-name :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/marker :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-cluster-parameter-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-db-revision-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-db-revision-message/revision-target (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-db-revision-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-db-revision-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.modify-cluster-db-revision-message/revision-target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.attribute-value-target/attribute-value (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/attribute-value-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.attribute-value-target/attribute-value]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-db-revisions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-db-revisions-message/cluster-db-revisions (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-db-revisions-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-db-revisions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-db-revisions-message/marker :portkey.aws.redshift.-2012-12-01.cluster-db-revisions-message/cluster-db-revisions]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-parameter-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster-parameter-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-info-map-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/event-info-map))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/cidrip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorize-cluster-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/cluster-security-group-name] :opt-un [:portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/cidrip :portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/ec-2-security-group-name :portkey.aws.redshift.-2012-12-01.authorize-cluster-security-group-ingress-message/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-configuration-message/hsm-configurations (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/hsm-configuration-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-configuration-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.hsm-configuration-message/marker :portkey.aws.redshift.-2012-12-01.hsm-configuration-message/hsm-configurations]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-hsm-configuration-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-resize-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-resize-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.describe-resize-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-s-3-bucket-name-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cancel-resize-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cancel-resize-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.cancel-resize-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/supported-platforms-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/supported-platform))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.customer-storage-message/total-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.customer-storage-message/total-provisioned-storage-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/customer-storage-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.customer-storage-message/total-backup-size-in-mega-bytes :portkey.aws.redshift.-2012-12-01.customer-storage-message/total-provisioned-storage-in-mega-bytes]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/severity (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/customer-aws-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/source-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/enabled (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/cust-subscription-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscription/subscription-creation-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-subscription (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.event-subscription/severity :portkey.aws.redshift.-2012-12-01/source-ids-list :portkey.aws.redshift.-2012-12-01.event-subscription/customer-aws-id :portkey.aws.redshift.-2012-12-01.event-subscription/tags :portkey.aws.redshift.-2012-12-01.event-subscription/source-type :portkey.aws.redshift.-2012-12-01.event-subscription/enabled :portkey.aws.redshift.-2012-12-01.event-subscription/status :portkey.aws.redshift.-2012-12-01.event-subscription/sns-topic-arn :portkey.aws.redshift.-2012-12-01/event-categories-list :portkey.aws.redshift.-2012-12-01.event-subscription/cust-subscription-id :portkey.aws.redshift.-2012-12-01.event-subscription/subscription-creation-time]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-db-revisions-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-db-revisions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-db-revisions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-db-revisions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-db-revisions-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.describe-cluster-db-revisions-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-db-revisions-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/destination-region (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-snapshot-copy-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/destination-region :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/retention-period :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.cluster-snapshot-copy-status/snapshot-copy-grant-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-default-cluster-parameters-message/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-default-cluster-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-default-cluster-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-default-cluster-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.describe-default-cluster-parameters-message/parameter-group-family] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-default-cluster-parameters-message/max-records :portkey.aws.redshift.-2012-12-01.describe-default-cluster-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-default-cluster-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/default-cluster-parameters]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-message/snapshots (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot-message/marker :portkey.aws.redshift.-2012-12-01.snapshot-message/snapshots]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-message/force (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-message/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.modify-cluster-snapshot-message/force]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subscription-severity-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-vpc-network-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-subnet-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-subnet-group-message/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.modify-cluster-subnet-group-message/subnet-ids] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-subnet-group-message/description]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-output-message/resources (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-output-message/errors (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/batch-snapshot-operation-errors))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-output-message/resources :portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-output-message/errors]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.disable-logging-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/disable-logging-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.disable-logging-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-reserved-node-offerings-message/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-reserved-node-offerings-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-reserved-node-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-reserved-node-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-reserved-node-offerings-message/reserved-node-offering-id :portkey.aws.redshift.-2012-12-01.describe-reserved-node-offerings-message/max-records :portkey.aws.redshift.-2012-12-01.describe-reserved-node-offerings-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/deferred-maintenance-windows-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/deferred-maintenance-window))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-offering-type #{:regular :upgradable "Regular" "Upgradable"})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-snapshot-schedules-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/schedule-identifier :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/tag-values :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/marker :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-message/max-records]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/revoke-cluster-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-table-restore-argument-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.accept-reserved-node-exchange-input-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.accept-reserved-node-exchange-input-message/target-reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/accept-reserved-node-exchange-input-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.accept-reserved-node-exchange-input-message/reserved-node-id :portkey.aws.redshift.-2012-12-01.accept-reserved-node-exchange-input-message/target-reserved-node-offering-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/orderable-cluster-options-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/orderable-cluster-option))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.logging-status/logging-enabled (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.logging-status/bucket-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.logging-status/s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.logging-status/last-successful-delivery-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.logging-status/last-failure-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.logging-status/last-failure-message (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/logging-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.logging-status/logging-enabled :portkey.aws.redshift.-2012-12-01.logging-status/bucket-name :portkey.aws.redshift.-2012-12-01.logging-status/s-3-key-prefix :portkey.aws.redshift.-2012-12-01.logging-status/last-successful-delivery-time :portkey.aws.redshift.-2012-12-01.logging-status/last-failure-time :portkey.aws.redshift.-2012-12-01.logging-status/last-failure-message]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-schedule-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-security-group-message/marker :portkey.aws.redshift.-2012-12-01/cluster-security-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.supported-operation/operation-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/supported-operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.supported-operation/operation-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-offering-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/reserved-node-offering))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-categories-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/event-categories-map-list]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-configuration-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-events-message/source-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-events-message/start-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-events-message/end-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-events-message/duration (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-events-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-events-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-events-message/source-identifier :portkey.aws.redshift.-2012-12-01/source-type :portkey.aws.redshift.-2012-12-01.describe-events-message/start-time :portkey.aws.redshift.-2012-12-01.describe-events-message/end-time :portkey.aws.redshift.-2012-12-01.describe-events-message/duration :portkey.aws.redshift.-2012-12-01.describe-events-message/max-records :portkey.aws.redshift.-2012-12-01.describe-events-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/parameter-apply-type #{"dynamic" "static" :static :dynamic})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subscription-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorization-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/bucket-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-delete-cluster-snapshots-request/identifiers (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-message-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-delete-cluster-snapshots-request (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.batch-delete-cluster-snapshots-request/identifiers] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/ip-range-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/ip-range))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/copy-to-region-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-schedule-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/snapshot-schedule))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/sns-topic-arn-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/event))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-client-certificate/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-client-certificate/hsm-client-certificate-public-key (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-client-certificate/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-client-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.hsm-client-certificate/hsm-client-certificate-identifier :portkey.aws.redshift.-2012-12-01.hsm-client-certificate/hsm-client-certificate-public-key :portkey.aws.redshift.-2012-12-01.hsm-client-certificate/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.events-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.events-message/events (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.events-message/marker :portkey.aws.redshift.-2012-12-01.events-message/events]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/source-type #{:clustersecuritygroup "cluster-parameter-group" "cluster" :cluster :clusterparametergroup :clustersnapshot "cluster-snapshot" "cluster-security-group"})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/unauthorized-operation (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-snapshot-operation-error-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/snapshot-error-message))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subscription-category-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event/source-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event/message (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event/event-categories (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event/severity (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event/date (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event/event-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.event/source-identifier :portkey.aws.redshift.-2012-12-01/source-type :portkey.aws.redshift.-2012-12-01.event/message :portkey.aws.redshift.-2012-12-01.event/event-categories :portkey.aws.redshift.-2012-12-01.event/severity :portkey.aws.redshift.-2012-12-01.event/date :portkey.aws.redshift.-2012-12-01.event/event-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/cidrip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/revoke-cluster-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/cluster-security-group-name] :opt-un [:portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/cidrip :portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/ec-2-security-group-name :portkey.aws.redshift.-2012-12-01.revoke-cluster-security-group-ingress-message/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/rotate-encryption-key-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-hsm-client-certificate-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.disable-snapshot-copy-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/disable-snapshot-copy-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.disable-snapshot-copy-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.accept-reserved-node-exchange-output-message/exchanged-reserved-node (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reserved-node))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/accept-reserved-node-exchange-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.accept-reserved-node-exchange-output-message/exchanged-reserved-node]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/availability-zone-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/availability-zone))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.availability-zone/name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.availability-zone/supported-platforms (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/supported-platforms-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/availability-zone (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.availability-zone/name :portkey.aws.redshift.-2012-12-01.availability-zone/supported-platforms]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-subscriptions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-subscriptions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.event-subscriptions-message/marker :portkey.aws.redshift.-2012-12-01/event-subscriptions-list]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-event-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/event-subscription]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/sort-by-order #{:desc "DESC" :asc "ASC"})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/revision-targets-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/revision-target))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/restore-table-from-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/table-restore-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-event-subscription-message/subscription-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.supported-platform/name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/supported-platform (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.supported-platform/name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/sensitive-string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-subscription-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-output-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-output-message/reserved-node-offerings (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reserved-node-offering-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/get-reserved-node-exchange-offerings-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-output-message/marker :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-output-message/reserved-node-offerings]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-security-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/cluster-security-group-name :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/marker :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-cluster-security-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-groups (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-security-group))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.recurring-charge/recurring-charge-amount (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.recurring-charge/recurring-charge-frequency (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/recurring-charge (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.recurring-charge/recurring-charge-amount :portkey.aws.redshift.-2012-12-01.recurring-charge/recurring-charge-frequency]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/track-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/maintenance-track))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/resize-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-parameter-group-message/parameters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-parameter-group-message/parameter-group-name :portkey.aws.redshift.-2012-12-01.modify-cluster-parameter-group-message/parameters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/restore-from-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorization-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-delete-request-size-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-tags-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-tags-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-tags-message/resource-name :portkey.aws.redshift.-2012-12-01.create-tags-message/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reboot-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subnet-already-in-use (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-snapshot-operation-errors (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/snapshot-error-message))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group-membership/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-security-group-membership/cluster-security-group-name :portkey.aws.redshift.-2012-12-01.cluster-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-iam-role/iam-role-arn (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-iam-role/apply-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-iam-role (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-iam-role/iam-role-arn :portkey.aws.redshift.-2012-12-01.cluster-iam-role/apply-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-subnet (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tag-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/tag))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-security-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-client-certificate-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-client-certificate-message/hsm-client-certificates (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.hsm-client-certificate-message/marker :portkey.aws.redshift.-2012-12-01.hsm-client-certificate-message/hsm-client-certificates]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/source (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/parameter-group-name] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/source :portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-schedule-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-snapshot-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-tags-message/resource-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-tags-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-tags-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-tags-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-tags-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-tags-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-tags-message/resource-name :portkey.aws.redshift.-2012-12-01.describe-tags-message/resource-type :portkey.aws.redshift.-2012-12-01.describe-tags-message/max-records :portkey.aws.redshift.-2012-12-01.describe-tags-message/marker :portkey.aws.redshift.-2012-12-01.describe-tags-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-tags-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/end-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/start-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/owner-account (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/snapshot-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/cluster-exists (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/sorting-entities (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-sorting-entity-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-snapshots-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/tag-values :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/snapshot-identifier :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/end-time :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/start-time :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/owner-account :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/marker :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/snapshot-type :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/cluster-exists :portkey.aws.redshift.-2012-12-01.describe-cluster-snapshots-message/sorting-entities]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/unsupported-option-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-configuration-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-logging-status-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-logging-status-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.describe-logging-status-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subscription-already-exist-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-db-revisions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-db-revision))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-s-3-key-prefix-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-snapshot-copy-grant-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-snapshot-copy-grant-message/snapshot-copy-grant-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-public-key (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/encrypted (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/elastic-resize-number-of-node-options (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/db-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-parameter-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-status-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/pending-actions (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/pending-actions-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/master-username (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/snapshot-schedule-state (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/schedule-state))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-create-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-revision-number (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/modify-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-iam-role-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/vpc-security-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/vpc-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/snapshot-schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/deferred-maintenance-windows (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/deferred-maintenance-windows-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/cluster-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-nodes-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster/cluster-public-key :portkey.aws.redshift.-2012-12-01.cluster/enhanced-vpc-routing :portkey.aws.redshift.-2012-12-01.cluster/publicly-accessible :portkey.aws.redshift.-2012-12-01.cluster/preferred-maintenance-window :portkey.aws.redshift.-2012-12-01.cluster/encrypted :portkey.aws.redshift.-2012-12-01.cluster/cluster-identifier :portkey.aws.redshift.-2012-12-01/cluster-snapshot-copy-status :portkey.aws.redshift.-2012-12-01.cluster/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.cluster/number-of-nodes :portkey.aws.redshift.-2012-12-01.cluster/elastic-resize-number-of-node-options :portkey.aws.redshift.-2012-12-01.cluster/tags :portkey.aws.redshift.-2012-12-01.cluster/db-name :portkey.aws.redshift.-2012-12-01.cluster/cluster-parameter-groups :portkey.aws.redshift.-2012-12-01.cluster/availability-zone :portkey.aws.redshift.-2012-12-01.cluster/pending-actions :portkey.aws.redshift.-2012-12-01.cluster/cluster-security-groups :portkey.aws.redshift.-2012-12-01.cluster/master-username :portkey.aws.redshift.-2012-12-01.cluster/snapshot-schedule-state :portkey.aws.redshift.-2012-12-01/data-transfer-progress :portkey.aws.redshift.-2012-12-01.cluster/cluster-status :portkey.aws.redshift.-2012-12-01.cluster/vpc-id :portkey.aws.redshift.-2012-12-01.cluster/maintenance-track-name :portkey.aws.redshift.-2012-12-01.cluster/kms-key-id :portkey.aws.redshift.-2012-12-01/restore-status :portkey.aws.redshift.-2012-12-01.cluster/cluster-create-time :portkey.aws.redshift.-2012-12-01.cluster/cluster-revision-number :portkey.aws.redshift.-2012-12-01.cluster/allow-version-upgrade :portkey.aws.redshift.-2012-12-01.cluster/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.cluster/cluster-version :portkey.aws.redshift.-2012-12-01.cluster/modify-status :portkey.aws.redshift.-2012-12-01/endpoint :portkey.aws.redshift.-2012-12-01.cluster/automated-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.cluster/iam-roles :portkey.aws.redshift.-2012-12-01/resize-info :portkey.aws.redshift.-2012-12-01.cluster/vpc-security-groups :portkey.aws.redshift.-2012-12-01.cluster/snapshot-schedule-identifier :portkey.aws.redshift.-2012-12-01.cluster/deferred-maintenance-windows :portkey.aws.redshift.-2012-12-01.cluster/cluster-nodes :portkey.aws.redshift.-2012-12-01/hsm-status :portkey.aws.redshift.-2012-12-01/elastic-ip-status :portkey.aws.redshift.-2012-12-01.cluster/node-type :portkey.aws.redshift.-2012-12-01/pending-modified-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/in-progress-table-restore-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/hsm-client-certificate))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-snapshot-copy-grant-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/currency-code (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/fixed-price (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/duration (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/usage-price (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/recurring-charges (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/offering-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reserved-node-offering/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-offering (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.reserved-node-offering/currency-code :portkey.aws.redshift.-2012-12-01.reserved-node-offering/fixed-price :portkey.aws.redshift.-2012-12-01/reserved-node-offering-type :portkey.aws.redshift.-2012-12-01.reserved-node-offering/reserved-node-offering-id :portkey.aws.redshift.-2012-12-01.reserved-node-offering/duration :portkey.aws.redshift.-2012-12-01.reserved-node-offering/usage-price :portkey.aws.redshift.-2012-12-01.reserved-node-offering/recurring-charges :portkey.aws.redshift.-2012-12-01.reserved-node-offering/offering-type :portkey.aws.redshift.-2012-12-01.reserved-node-offering/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/snapshot-identifier :portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.create-cluster-snapshot-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-subnet-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/resize-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-security-group-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-security-group-message/cluster-security-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/accounts-with-restore-access-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/account-with-restore-access))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.vpc-security-group-membership/vpc-security-group-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.vpc-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/vpc-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.vpc-security-group-membership/vpc-security-group-id :portkey.aws.redshift.-2012-12-01.vpc-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/schedule-definition-type-unsupported-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorization-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-reserved-nodes-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-reserved-nodes-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-reserved-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-reserved-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-reserved-nodes-message/reserved-node-id :portkey.aws.redshift.-2012-12-01.describe-reserved-nodes-message/max-records :portkey.aws.redshift.-2012-12-01.describe-reserved-nodes-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-security-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-info-map/event-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-info-map/event-categories (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-info-map/event-description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-info-map/severity (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-info-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.event-info-map/event-id :portkey.aws.redshift.-2012-12-01.event-info-map/event-categories :portkey.aws.redshift.-2012-12-01.event-info-map/event-description :portkey.aws.redshift.-2012-12-01.event-info-map/severity]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.update-target/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.update-target/database-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.update-target/supported-operations (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/supported-operation-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/update-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.update-target/maintenance-track-name :portkey.aws.redshift.-2012-12-01.update-target/database-version :portkey.aws.redshift.-2012-12-01.update-target/supported-operations]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subscription-event-id-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.data-transfer-progress/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.data-transfer-progress/current-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.data-transfer-progress/total-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.data-transfer-progress/data-transferred-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.data-transfer-progress/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.data-transfer-progress/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/data-transfer-progress (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.data-transfer-progress/status :portkey.aws.redshift.-2012-12-01.data-transfer-progress/current-rate-in-mega-bytes-per-second :portkey.aws.redshift.-2012-12-01.data-transfer-progress/total-data-in-mega-bytes :portkey.aws.redshift.-2012-12-01.data-transfer-progress/data-transferred-in-mega-bytes :portkey.aws.redshift.-2012-12-01.data-transfer-progress/estimated-time-to-completion-in-seconds :portkey.aws.redshift.-2012-12-01.data-transfer-progress/elapsed-time-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-subnet-group-message/cluster-subnet-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/pending-actions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/insufficient-s-3-bucket-policy-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-credentials/db-user (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-credentials/db-password (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/sensitive-string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-credentials/expiration (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-credentials (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-credentials/db-user :portkey.aws.redshift.-2012-12-01.cluster-credentials/db-password :portkey.aws.redshift.-2012-12-01.cluster-credentials/expiration]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-snapshot-schedule-message/schedule-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/attribute-name-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-configuration-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-already-enabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/resource-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ec-2-security-group/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ec-2-security-group/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ec-2-security-group/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ec-2-security-group/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/ec-2-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.ec-2-security-group/status :portkey.aws.redshift.-2012-12-01.ec-2-security-group/ec-2-security-group-name :portkey.aws.redshift.-2012-12-01.ec-2-security-group/ec-2-security-group-owner-id :portkey.aws.redshift.-2012-12-01.ec-2-security-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/description :portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/subnet-ids] :opt-un [:portkey.aws.redshift.-2012-12-01.create-cluster-subnet-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/encrypted (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/new-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-message/enhanced-vpc-routing :portkey.aws.redshift.-2012-12-01.modify-cluster-message/publicly-accessible :portkey.aws.redshift.-2012-12-01.modify-cluster-message/preferred-maintenance-window :portkey.aws.redshift.-2012-12-01.modify-cluster-message/encrypted :portkey.aws.redshift.-2012-12-01.modify-cluster-message/hsm-client-certificate-identifier :portkey.aws.redshift.-2012-12-01.modify-cluster-message/number-of-nodes :portkey.aws.redshift.-2012-12-01.modify-cluster-message/vpc-security-group-ids :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-type :portkey.aws.redshift.-2012-12-01.modify-cluster-message/master-user-password :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-security-groups :portkey.aws.redshift.-2012-12-01.modify-cluster-message/elastic-ip :portkey.aws.redshift.-2012-12-01.modify-cluster-message/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.modify-cluster-message/maintenance-track-name :portkey.aws.redshift.-2012-12-01.modify-cluster-message/kms-key-id :portkey.aws.redshift.-2012-12-01.modify-cluster-message/allow-version-upgrade :portkey.aws.redshift.-2012-12-01.modify-cluster-message/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-version :portkey.aws.redshift.-2012-12-01.modify-cluster-message/automated-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.modify-cluster-message/new-cluster-identifier :portkey.aws.redshift.-2012-12-01.modify-cluster-message/node-type :portkey.aws.redshift.-2012-12-01.modify-cluster-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/copy-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-snapshot-copy-grant-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot-copy-grant]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-snapshot-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-snapshot-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-already-migrated-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-categories-map-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/event-categories-map))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/iam-role-arn-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/data-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/parameter-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/source (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/minimum-engine-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/allowed-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/apply-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/parameter-apply-type))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/is-modifiable (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.parameter/parameter-value (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.parameter/data-type :portkey.aws.redshift.-2012-12-01.parameter/parameter-name :portkey.aws.redshift.-2012-12-01.parameter/source :portkey.aws.redshift.-2012-12-01.parameter/minimum-engine-version :portkey.aws.redshift.-2012-12-01.parameter/allowed-values :portkey.aws.redshift.-2012-12-01.parameter/apply-type :portkey.aws.redshift.-2012-12-01.parameter/description :portkey.aws.redshift.-2012-12-01.parameter/is-modifiable :portkey.aws.redshift.-2012-12-01.parameter/parameter-value]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-status/parameter-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-status/parameter-apply-error-description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-parameter-status/parameter-name :portkey.aws.redshift.-2012-12-01.cluster-parameter-status/parameter-apply-status :portkey.aws.redshift.-2012-12-01.cluster-parameter-status/parameter-apply-error-description]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/vpc-security-group-id-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/table-restore-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-status/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-parameter-group-status/parameter-group-name :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-status/parameter-apply-status :portkey.aws.redshift.-2012-12-01/cluster-parameter-status-list]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-status/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-status/current-restore-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-status/snapshot-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-status/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-status/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-status/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/restore-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.restore-status/status :portkey.aws.redshift.-2012-12-01.restore-status/current-restore-rate-in-mega-bytes-per-second :portkey.aws.redshift.-2012-12-01.restore-status/snapshot-size-in-mega-bytes :portkey.aws.redshift.-2012-12-01.restore-status/progress-in-mega-bytes :portkey.aws.redshift.-2012-12-01.restore-status/elapsed-time-in-seconds :portkey.aws.redshift.-2012-12-01.restore-status/estimated-time-to-completion-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-snapshot-copy-grants-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/snapshot-copy-grant-name :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/max-records :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/marker :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-snapshot-copy-grants-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-message/skip-final-cluster-snapshot (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-message/final-cluster-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-cluster-message/final-cluster-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.delete-cluster-message/skip-final-cluster-snapshot :portkey.aws.redshift.-2012-12-01.delete-cluster-message/final-cluster-snapshot-identifier :portkey.aws.redshift.-2012-12-01.delete-cluster-message/final-cluster-snapshot-retention-period]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-tracks-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-tracks-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-tracks-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-tracks-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-tracks-message/maintenance-track-name :portkey.aws.redshift.-2012-12-01.describe-cluster-tracks-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-tracks-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-schedule-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reboot-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reboot-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.reboot-cluster-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-offering-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/incompatible-orderable-options (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/restorable-node-types (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/restorable-node-type-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-create-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/manual-snapshot-remaining-days (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/source-region (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/encrypted-with-hsm (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/encrypted (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/owner-account (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/db-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/estimated-seconds-to-completion (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/actual-incremental-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/master-username (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/backup-progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/accounts-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/accounts-with-restore-access-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/port (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/cluster-create-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-retention-start-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/current-backup-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot/total-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/double))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot/snapshot-identifier :portkey.aws.redshift.-2012-12-01.snapshot/restorable-node-types :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-create-time :portkey.aws.redshift.-2012-12-01.snapshot/enhanced-vpc-routing :portkey.aws.redshift.-2012-12-01.snapshot/manual-snapshot-remaining-days :portkey.aws.redshift.-2012-12-01.snapshot/source-region :portkey.aws.redshift.-2012-12-01.snapshot/encrypted-with-hsm :portkey.aws.redshift.-2012-12-01.snapshot/encrypted :portkey.aws.redshift.-2012-12-01.snapshot/owner-account :portkey.aws.redshift.-2012-12-01.snapshot/cluster-identifier :portkey.aws.redshift.-2012-12-01.snapshot/number-of-nodes :portkey.aws.redshift.-2012-12-01.snapshot/tags :portkey.aws.redshift.-2012-12-01.snapshot/db-name :portkey.aws.redshift.-2012-12-01.snapshot/estimated-seconds-to-completion :portkey.aws.redshift.-2012-12-01.snapshot/availability-zone :portkey.aws.redshift.-2012-12-01.snapshot/status :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-type :portkey.aws.redshift.-2012-12-01.snapshot/actual-incremental-backup-size-in-mega-bytes :portkey.aws.redshift.-2012-12-01.snapshot/master-username :portkey.aws.redshift.-2012-12-01.snapshot/backup-progress-in-mega-bytes :portkey.aws.redshift.-2012-12-01.snapshot/accounts-with-restore-access :portkey.aws.redshift.-2012-12-01.snapshot/port :portkey.aws.redshift.-2012-12-01.snapshot/vpc-id :portkey.aws.redshift.-2012-12-01.snapshot/maintenance-track-name :portkey.aws.redshift.-2012-12-01.snapshot/kms-key-id :portkey.aws.redshift.-2012-12-01.snapshot/cluster-create-time :portkey.aws.redshift.-2012-12-01.snapshot/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.snapshot/cluster-version :portkey.aws.redshift.-2012-12-01.snapshot/elapsed-time-in-seconds :portkey.aws.redshift.-2012-12-01.snapshot/snapshot-retention-start-time :portkey.aws.redshift.-2012-12-01.snapshot/current-backup-rate-in-mega-bytes-per-second :portkey.aws.redshift.-2012-12-01.snapshot/node-type :portkey.aws.redshift.-2012-12-01.snapshot/total-backup-size-in-mega-bytes]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/t-stamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-groups (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-subnet-group))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-categories-map/source-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.event-categories-map/events (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-info-map-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-categories-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.event-categories-map/source-type :portkey.aws.redshift.-2012-12-01.event-categories-map/events]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-subscription-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/source-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/source-ids-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/event-categories (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/severity (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/enabled (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-event-subscription-message/subscription-name :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/sns-topic-arn] :opt-un [:portkey.aws.redshift.-2012-12-01.create-event-subscription-message/source-type :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/source-ids :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/event-categories :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/severity :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/enabled :portkey.aws.redshift.-2012-12-01.create-event-subscription-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-status))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-db-revision-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/recurring-charge-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/recurring-charge))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant-message/snapshot-copy-grants (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot-copy-grant-message/marker :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant-message/snapshot-copy-grants]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.tagged-resource-list-message/tagged-resources (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tagged-resource-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.tagged-resource-list-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tagged-resource-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.tagged-resource-list-message/tagged-resources :portkey.aws.redshift.-2012-12-01.tagged-resource-list-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-orderable-cluster-options-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/cluster-version :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/node-type :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/max-records :portkey.aws.redshift.-2012-12-01.describe-orderable-cluster-options-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-categories-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-tag-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/dependent-service-unavailable-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.account-with-restore-access/account-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.account-with-restore-access/account-alias (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/account-with-restore-access (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.account-with-restore-access/account-id :portkey.aws.redshift.-2012-12-01.account-with-restore-access/account-alias]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/table-restore-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/table-restore-status))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-details/parameters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-details/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-parameter-group-details/parameters :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-details/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-version/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-version/cluster-parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-version/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-version/cluster-version :portkey.aws.redshift.-2012-12-01.cluster-version/cluster-parameter-group-family :portkey.aws.redshift.-2012-12-01.cluster-version/description]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.orderable-cluster-options-message/orderable-cluster-options (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/orderable-cluster-options-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.orderable-cluster-options-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/orderable-cluster-options-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.orderable-cluster-options-message/orderable-cluster-options :portkey.aws.redshift.-2012-12-01.orderable-cluster-options-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/schedule-definitions (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/schedule-definition-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/schedule-description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/next-invocations (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/scheduled-snapshot-time-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/associated-cluster-count (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-schedule/associated-clusters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/associated-cluster-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot-schedule/schedule-definitions :portkey.aws.redshift.-2012-12-01.snapshot-schedule/schedule-identifier :portkey.aws.redshift.-2012-12-01.snapshot-schedule/schedule-description :portkey.aws.redshift.-2012-12-01.snapshot-schedule/tags :portkey.aws.redshift.-2012-12-01.snapshot-schedule/next-invocations :portkey.aws.redshift.-2012-12-01.snapshot-schedule/associated-cluster-count :portkey.aws.redshift.-2012-12-01.snapshot-schedule/associated-clusters]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.rotate-encryption-key-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/rotate-encryption-key-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.rotate-encryption-key-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-output-message/snapshot-schedules (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-schedule-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-output-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-snapshot-schedules-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-output-message/snapshot-schedules :portkey.aws.redshift.-2012-12-01.describe-snapshot-schedules-output-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-snapshot-schedule-message/schedule-definitions (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/schedule-definition-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-snapshot-schedule-message/schedule-identifier :portkey.aws.redshift.-2012-12-01.modify-snapshot-schedule-message/schedule-definitions] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.endpoint/address (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.endpoint/port (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.endpoint/address :portkey.aws.redshift.-2012-12-01.endpoint/port]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/parameter-group-name :portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/parameter-group-family :portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/description] :opt-un [:portkey.aws.redshift.-2012-12-01.create-cluster-parameter-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/target-schema-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/source-schema-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/total-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/request-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/new-table-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/source-database-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/table-restore-status-type))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/message (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/source-table-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/table-restore-request-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status/target-database-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/table-restore-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.table-restore-status/snapshot-identifier :portkey.aws.redshift.-2012-12-01.table-restore-status/target-schema-name :portkey.aws.redshift.-2012-12-01.table-restore-status/source-schema-name :portkey.aws.redshift.-2012-12-01.table-restore-status/total-data-in-mega-bytes :portkey.aws.redshift.-2012-12-01.table-restore-status/cluster-identifier :portkey.aws.redshift.-2012-12-01.table-restore-status/request-time :portkey.aws.redshift.-2012-12-01.table-restore-status/new-table-name :portkey.aws.redshift.-2012-12-01.table-restore-status/progress-in-mega-bytes :portkey.aws.redshift.-2012-12-01.table-restore-status/source-database-name :portkey.aws.redshift.-2012-12-01.table-restore-status/status :portkey.aws.redshift.-2012-12-01.table-restore-status/message :portkey.aws.redshift.-2012-12-01.table-restore-status/source-table-name :portkey.aws.redshift.-2012-12-01.table-restore-status/table-restore-request-id :portkey.aws.redshift.-2012-12-01.table-restore-status/target-database-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-restore-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/import-tables-completed (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reserved-node-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/reserved-node))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-sorting-entity-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/snapshot-sorting-entity))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-already-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-ip-address (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-partition-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-partition-password (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-server-public-certificate (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-hsm-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/description :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-ip-address :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-partition-name :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-partition-password :portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/hsm-server-public-certificate] :opt-un [:portkey.aws.redshift.-2012-12-01.create-hsm-configuration-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/import-tables-in-progress (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-subnet-group-message/marker :portkey.aws.redshift.-2012-12-01/cluster-subnet-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-tags-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-tags-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-tags-message/resource-name :portkey.aws.redshift.-2012-12-01.delete-tags-message/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-error-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-error-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-error-message/failure-code (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-error-message/failure-reason (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-error-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot-error-message/snapshot-identifier :portkey.aws.redshift.-2012-12-01.snapshot-error-message/snapshot-cluster-identifier :portkey.aws.redshift.-2012-12-01.snapshot-error-message/failure-code :portkey.aws.redshift.-2012-12-01.snapshot-error-message/failure-reason]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/attribute-value-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/attribute-value-target))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/number-of-nodes-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-attribute-to-sort-by #{:total-size "CREATE_TIME" :source-type :create-time "SOURCE_TYPE" "TOTAL_SIZE"})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/purchase-reserved-node-offering-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/reserved-node]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ip-range/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ip-range/cidrip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.ip-range/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/ip-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.ip-range/status :portkey.aws.redshift.-2012-12-01.ip-range/cidrip :portkey.aws.redshift.-2012-12-01.ip-range/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.clusters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.clusters-message/clusters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.clusters-message/marker :portkey.aws.redshift.-2012-12-01.clusters-message/clusters]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/subnet-group-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/subnets (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/subnet-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-subnet-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-subnet-group/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/description :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/vpc-id :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/subnet-group-status :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/subnets :portkey.aws.redshift.-2012-12-01.cluster-subnet-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-hsm-client-certificate-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/hsm-client-certificate]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-nodes-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-node))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/revoke-snapshot-access-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-subnet-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-snapshot-copy-retention-period-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-snapshot-copy-retention-period-message/retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-snapshot-copy-retention-period-message/manual (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-snapshot-copy-retention-period-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-snapshot-copy-retention-period-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.modify-snapshot-copy-retention-period-message/retention-period] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-snapshot-copy-retention-period-message/manual]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-snapshot-copy-retention-period-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-name-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-name-message/parameter-group-status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-name-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-parameter-group-name-message/parameter-group-name :portkey.aws.redshift.-2012-12-01.cluster-parameter-group-name-message/parameter-group-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-hsm-client-certificate-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-hsm-client-certificate-message/hsm-client-certificate-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-info/resize-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.resize-info/allow-cancel-resize (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/resize-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.resize-info/resize-type :portkey.aws.redshift.-2012-12-01.resize-info/allow-cancel-resize]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-event-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/event-subscription]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.tag/key (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.tag/value (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.tag/key :portkey.aws.redshift.-2012-12-01.tag/value]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-maintenance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-event-categories-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-event-categories-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-event-categories-message/source-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-db-revision/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-db-revision/current-database-revision (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-db-revision/database-revision-release-date (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-db-revision/revision-targets (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/revision-targets-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-db-revision (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-db-revision/cluster-identifier :portkey.aws.redshift.-2012-12-01.cluster-db-revision/current-database-revision :portkey.aws.redshift.-2012-12-01.cluster-db-revision/database-revision-release-date :portkey.aws.redshift.-2012-12-01.cluster-db-revision/revision-targets]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/schedule-state #{:modifying :active "ACTIVE" "FAILED" :failed "MODIFYING"})

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-versions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-versions-message/cluster-versions (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-version-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-versions-message/marker :portkey.aws.redshift.-2012-12-01.cluster-versions-message/cluster-versions]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/boolean-optional clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/sns-invalid-topic-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-iam-role-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-iam-role))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group-name-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.deferred-maintenance-window/defer-maintenance-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.deferred-maintenance-window/defer-maintenance-start-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.deferred-maintenance-window/defer-maintenance-end-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/deferred-maintenance-window (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.deferred-maintenance-window/defer-maintenance-identifier :portkey.aws.redshift.-2012-12-01.deferred-maintenance-window/defer-maintenance-start-time :portkey.aws.redshift.-2012-12-01.deferred-maintenance-window/defer-maintenance-end-time]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.tagged-resource/resource-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.tagged-resource/resource-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tagged-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/tag :portkey.aws.redshift.-2012-12-01.tagged-resource/resource-name :portkey.aws.redshift.-2012-12-01.tagged-resource/resource-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/unknown-snapshot-copy-region-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/table-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/access-to-snapshot-denied-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/restorable-node-type-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-account-attributes-message/attribute-names (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/attribute-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-account-attributes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-account-attributes-message/attribute-names]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-delete-cluster-snapshots-result/resources (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-delete-cluster-snapshots-result/errors (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/batch-snapshot-operation-error-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-delete-cluster-snapshots-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.batch-delete-cluster-snapshots-result/resources :portkey.aws.redshift.-2012-12-01.batch-delete-cluster-snapshots-result/errors]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/source-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/source-snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/target-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/copy-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/source-snapshot-identifier :portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/target-snapshot-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/source-snapshot-cluster-identifier :portkey.aws.redshift.-2012-12-01.copy-cluster-snapshot-message/manual-snapshot-retention-period]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-associated-to-schedule/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-associated-to-schedule/schedule-association-state (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/schedule-state))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-associated-to-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-associated-to-schedule/cluster-identifier :portkey.aws.redshift.-2012-12-01.cluster-associated-to-schedule/schedule-association-state]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/eligible-tracks-to-update-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/update-target))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/scheduled-snapshot-time-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/t-stamp))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-parameter-group/parameter-group-name :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/parameter-group-family :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/description :portkey.aws.redshift.-2012-12-01.cluster-parameter-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-message-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-message))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-input-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-input-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-input-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/get-reserved-node-exchange-offerings-input-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-input-message/reserved-node-id] :opt-un [:portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-input-message/max-records :portkey.aws.redshift.-2012-12-01.get-reserved-node-exchange-offerings-input-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-parameter-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/event-subscriptions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/event-subscription))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/hsm-configuration))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorize-cluster-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-subnet-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/cluster-subnet-group-name :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/marker :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/tag-keys :portkey.aws.redshift.-2012-12-01.describe-cluster-subnet-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-client-certificate-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-hsm-client-certificate-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-hsm-client-certificate-message/hsm-client-certificate-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.create-hsm-client-certificate-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/long-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-iam-roles-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/db-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/string))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-version-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-version))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-on-latest-revision-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/integer-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-status/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-status/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.hsm-status/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/hsm-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.hsm-status/hsm-client-certificate-identifier :portkey.aws.redshift.-2012-12-01.hsm-status/hsm-configuration-identifier :portkey.aws.redshift.-2012-12-01.hsm-status/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.elastic-ip-status/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.elastic-ip-status/status (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/elastic-ip-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.elastic-ip-status/elastic-ip :portkey.aws.redshift.-2012-12-01.elastic-ip-status/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/availability-zones (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/orderable-cluster-option (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.orderable-cluster-option/cluster-version :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/cluster-type :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/node-type :portkey.aws.redshift.-2012-12-01.orderable-cluster-option/availability-zones]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/source-database-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/source-schema-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/source-table-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/target-database-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/target-schema-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/new-table-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/restore-table-from-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/cluster-identifier :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/snapshot-identifier :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/source-database-name :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/source-table-name :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/new-table-name] :opt-un [:portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/source-schema-name :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/target-database-name :portkey.aws.redshift.-2012-12-01.restore-table-from-cluster-snapshot-message/target-schema-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-snapshot-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-iam-roles-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-iam-roles-message/add-iam-roles (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-iam-roles-message/remove-iam-roles (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-iam-roles-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-iam-roles-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-iam-roles-message/add-iam-roles :portkey.aws.redshift.-2012-12-01.modify-cluster-iam-roles-message/remove-iam-roles]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/cluster-parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/describe-cluster-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/cluster-version :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/cluster-parameter-group-family :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/max-records :portkey.aws.redshift.-2012-12-01.describe-cluster-versions-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revision-target/database-revision (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revision-target/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.revision-target/database-revision-release-date (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/revision-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.revision-target/database-revision :portkey.aws.redshift.-2012-12-01.revision-target/description :portkey.aws.redshift.-2012-12-01.revision-target/database-revision-release-date]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/schedule-definitions (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/schedule-definition-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/schedule-description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/dry-run (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/next-invocations (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/schedule-definitions :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/schedule-identifier :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/schedule-description :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/tags :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/dry-run :portkey.aws.redshift.-2012-12-01.create-snapshot-schedule-message/next-invocations]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-copy-grant-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-copy-grant-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-snapshot-copy-grant-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-snapshot-copy-grant-message/snapshot-copy-grant-name] :opt-un [:portkey.aws.redshift.-2012-12-01.create-snapshot-copy-grant-message/kms-key-id :portkey.aws.redshift.-2012-12-01.create-snapshot-copy-grant-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-hsm-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/hsm-configuration]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.purchase-reserved-node-offering-message/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.purchase-reserved-node-offering-message/node-count (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/purchase-reserved-node-offering-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.purchase-reserved-node-offering-message/reserved-node-offering-id] :opt-un [:portkey.aws.redshift.-2012-12-01.purchase-reserved-node-offering-message/node-count]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group/ec-2-security-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/ec-2-security-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group/ip-ranges (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/ip-range-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-security-group/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-security-group/cluster-security-group-name :portkey.aws.redshift.-2012-12-01.cluster-security-group/description :portkey.aws.redshift.-2012-12-01.cluster-security-group/ec-2-security-groups :portkey.aws.redshift.-2012-12-01.cluster-security-group/ip-ranges :portkey.aws.redshift.-2012-12-01.cluster-security-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/encryption-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.pending-modified-values/node-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/pending-modified-values (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.pending-modified-values/enhanced-vpc-routing :portkey.aws.redshift.-2012-12-01.pending-modified-values/publicly-accessible :portkey.aws.redshift.-2012-12-01.pending-modified-values/cluster-identifier :portkey.aws.redshift.-2012-12-01.pending-modified-values/number-of-nodes :portkey.aws.redshift.-2012-12-01.pending-modified-values/cluster-type :portkey.aws.redshift.-2012-12-01.pending-modified-values/master-user-password :portkey.aws.redshift.-2012-12-01.pending-modified-values/encryption-type :portkey.aws.redshift.-2012-12-01.pending-modified-values/maintenance-track-name :portkey.aws.redshift.-2012-12-01.pending-modified-values/cluster-version :portkey.aws.redshift.-2012-12-01.pending-modified-values/automated-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.pending-modified-values/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/subnet-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/subnet))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-reserved-node-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-snapshot-access-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-snapshot-access-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.authorize-snapshot-access-message/account-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/authorize-snapshot-access-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.authorize-snapshot-access-message/snapshot-identifier :portkey.aws.redshift.-2012-12-01.authorize-snapshot-access-message/account-with-restore-access] :opt-un [:portkey.aws.redshift.-2012-12-01.authorize-snapshot-access-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reset-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reset-cluster-parameter-group-message/reset-all-parameters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.reset-cluster-parameter-group-message/parameters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/reset-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.reset-cluster-parameter-group-message/parameter-group-name] :opt-un [:portkey.aws.redshift.-2012-12-01.reset-cluster-parameter-group-message/reset-all-parameters :portkey.aws.redshift.-2012-12-01.reset-cluster-parameter-group-message/parameters]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-message/force (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01/snapshot-identifier-list] :opt-un [:portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-message/manual-snapshot-retention-period :portkey.aws.redshift.-2012-12-01.batch-modify-cluster-snapshots-message/force]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.account-attribute/attribute-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.account-attribute/attribute-values (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/attribute-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/account-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.account-attribute/attribute-name :portkey.aws.redshift.-2012-12-01.account-attribute/attribute-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/enable-snapshot-copy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.cluster-parameter-groups-message/parameter-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/parameter-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/cluster-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.cluster-parameter-groups-message/marker :portkey.aws.redshift.-2012-12-01.cluster-parameter-groups-message/parameter-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.snapshot-copy-grant/snapshot-copy-grant-name :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant/kms-key-id :portkey.aws.redshift.-2012-12-01.snapshot-copy-grant/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.delete-hsm-configuration-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/delete-hsm-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.delete-hsm-configuration-message/hsm-configuration-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-security-group-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-security-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.create-cluster-security-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/create-cluster-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.create-cluster-security-group-message/cluster-security-group-name :portkey.aws.redshift.-2012-12-01.create-cluster-security-group-message/description] :opt-un [:portkey.aws.redshift.-2012-12-01.create-cluster-security-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/parameter-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/cluster-parameter-group))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/tagged-resource-list (clojure.spec.alpha/coll-of :portkey.aws.redshift.-2012-12-01/tagged-resource))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/invalid-cluster-track-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status-message/table-restore-status-details (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/table-restore-status-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.table-restore-status-message/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/table-restore-status-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.table-restore-status-message/table-restore-status-details :portkey.aws.redshift.-2012-12-01.table-restore-status-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-start-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-end-time (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-duration (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-cluster-maintenance-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-identifier :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-start-time :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-end-time :portkey.aws.redshift.-2012-12-01.modify-cluster-maintenance-message/defer-maintenance-duration]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/db-user (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/db-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/duration-seconds (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/auto-create (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/db-groups (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/db-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/get-cluster-credentials-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/db-user :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/cluster-identifier] :opt-un [:portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/db-name :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/duration-seconds :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/auto-create :portkey.aws.redshift.-2012-12-01.get-cluster-credentials-message/db-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/source-ids (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/source-ids-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/event-categories (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/severity (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/enabled (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/modify-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/subscription-name] :opt-un [:portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/sns-topic-arn :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/source-type :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/source-ids :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/event-categories :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/severity :portkey.aws.redshift.-2012-12-01.modify-event-subscription-message/enabled]))

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.default-cluster-parameters/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.default-cluster-parameters/marker (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/string))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01.default-cluster-parameters/parameters (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift.-2012-12-01/default-cluster-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.-2012-12-01.default-cluster-parameters/parameter-group-family :portkey.aws.redshift.-2012-12-01.default-cluster-parameters/marker :portkey.aws.redshift.-2012-12-01.default-cluster-parameters/parameters]))

(clojure.core/defn cancel-resize ([cancel-resize-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-cancel-resize-message cancel-resize-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/resize-progress-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/cancel-resize-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CancelResizeResult", :http.request.configuration/action "CancelResize", :http.request.configuration/output-deser-fn response-resize-progress-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "ResizeNotFoundFault" :portkey.aws.redshift.-2012-12-01/resize-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef cancel-resize :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/cancel-resize-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/resize-progress-message))

(clojure.core/defn describe-cluster-parameters ([describe-cluster-parameters-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-parameters-message describe-cluster-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-details, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterParametersResult", :http.request.configuration/action "DescribeClusterParameters", :http.request.configuration/output-deser-fn response-cluster-parameter-group-details, :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-parameters :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/describe-cluster-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-details))

(clojure.core/defn enable-snapshot-copy ([enable-snapshot-copy-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-enable-snapshot-copy-message enable-snapshot-copy-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/enable-snapshot-copy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/enable-snapshot-copy-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "EnableSnapshotCopyResult", :http.request.configuration/action "EnableSnapshotCopy", :http.request.configuration/output-deser-fn response-enable-snapshot-copy-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault, "CopyToRegionDisabledFault" :portkey.aws.redshift.-2012-12-01/copy-to-region-disabled-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-not-found-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault, "SnapshotCopyAlreadyEnabledFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-already-enabled-fault, "IncompatibleOrderableOptions" :portkey.aws.redshift.-2012-12-01/incompatible-orderable-options, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "UnknownSnapshotCopyRegionFault" :portkey.aws.redshift.-2012-12-01/unknown-snapshot-copy-region-fault}})))))
(clojure.spec.alpha/fdef enable-snapshot-copy :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/enable-snapshot-copy-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/enable-snapshot-copy-result))

(clojure.core/defn disable-snapshot-copy ([disable-snapshot-copy-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-disable-snapshot-copy-message disable-snapshot-copy-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/disable-snapshot-copy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/disable-snapshot-copy-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DisableSnapshotCopyResult", :http.request.configuration/action "DisableSnapshotCopy", :http.request.configuration/output-deser-fn response-disable-snapshot-copy-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "SnapshotCopyAlreadyDisabledFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-already-disabled-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation}})))))
(clojure.spec.alpha/fdef disable-snapshot-copy :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/disable-snapshot-copy-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/disable-snapshot-copy-result))

(clojure.core/defn create-cluster ([create-cluster-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-cluster-message create-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterResult", :http.request.configuration/action "CreateCluster", :http.request.configuration/output-deser-fn response-create-cluster-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift.-2012-12-01/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift.-2012-12-01/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-already-exists-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault, "InvalidVPCNetworkStateFault" :portkey.aws.redshift.-2012-12-01/invalid-vpc-network-state-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-not-found-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "InvalidSubnet" :portkey.aws.redshift.-2012-12-01/invalid-subnet, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-not-found-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-not-found-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-not-found-fault, "ClusterQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-quota-exceeded-fault, "InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-subnet-group-state-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidClusterTrackFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef create-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-cluster-result))

(clojure.core/defn describe-cluster-snapshots ([] (describe-cluster-snapshots {})) ([describe-cluster-snapshots-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-snapshots-message describe-cluster-snapshots-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/snapshot-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-snapshots-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterSnapshotsResult", :http.request.configuration/action "DescribeClusterSnapshots", :http.request.configuration/output-deser-fn response-snapshot-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-snapshots :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-snapshots-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-message))

(clojure.core/defn describe-snapshot-schedules ([] (describe-snapshot-schedules {})) ([describe-snapshot-schedules-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-snapshot-schedules-message describe-snapshot-schedules-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/describe-snapshot-schedules-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-snapshot-schedules-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeSnapshotSchedulesResult", :http.request.configuration/action "DescribeSnapshotSchedules", :http.request.configuration/output-deser-fn response-describe-snapshot-schedules-output-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-snapshot-schedules :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-snapshot-schedules-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/describe-snapshot-schedules-output-message))

(clojure.core/defn create-hsm-client-certificate ([create-hsm-client-certificate-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-hsm-client-certificate-message create-hsm-client-certificate-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-hsm-client-certificate-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-hsm-client-certificate-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateHsmClientCertificateResult", :http.request.configuration/action "CreateHsmClientCertificate", :http.request.configuration/output-deser-fn response-create-hsm-client-certificate-result, :http.request.spec/error-spec {"HsmClientCertificateAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-already-exists-fault, "HsmClientCertificateQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-hsm-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-hsm-client-certificate-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-hsm-client-certificate-result))

(clojure.core/defn delete-tags ([delete-tags-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-tags-message delete-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTags", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundFault" :portkey.aws.redshift.-2012-12-01/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef delete-tags :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-tags-message) :ret clojure.core/true?)

(clojure.core/defn describe-cluster-subnet-groups ([] (describe-cluster-subnet-groups {})) ([describe-cluster-subnet-groups-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-subnet-groups-message describe-cluster-subnet-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-subnet-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterSubnetGroupsResult", :http.request.configuration/action "DescribeClusterSubnetGroups", :http.request.configuration/output-deser-fn response-cluster-subnet-group-message, :http.request.spec/error-spec {"ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-subnet-groups :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-subnet-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-message))

(clojure.core/defn delete-cluster-subnet-group ([delete-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-cluster-subnet-group-message delete-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClusterSubnetGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-subnet-group-state-fault, "InvalidClusterSubnetStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-subnet-state-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-cluster-subnet-group-message) :ret clojure.core/true?)

(clojure.core/defn describe-events ([] (describe-events {})) ([describe-events-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-events-message describe-events-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/events-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-events-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventsResult", :http.request.configuration/action "DescribeEvents", :http.request.configuration/output-deser-fn response-events-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-events :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-events-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/events-message))

(clojure.core/defn rotate-encryption-key ([rotate-encryption-key-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-rotate-encryption-key-message rotate-encryption-key-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/rotate-encryption-key-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/rotate-encryption-key-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RotateEncryptionKeyResult", :http.request.configuration/action "RotateEncryptionKey", :http.request.configuration/output-deser-fn response-rotate-encryption-key-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef rotate-encryption-key :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/rotate-encryption-key-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/rotate-encryption-key-result))

(clojure.core/defn describe-hsm-configurations ([] (describe-hsm-configurations {})) ([describe-hsm-configurations-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-hsm-configurations-message describe-hsm-configurations-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/hsm-configuration-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-hsm-configurations-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeHsmConfigurationsResult", :http.request.configuration/action "DescribeHsmConfigurations", :http.request.configuration/output-deser-fn response-hsm-configuration-message, :http.request.spec/error-spec {"HsmConfigurationNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-hsm-configurations :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-hsm-configurations-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/hsm-configuration-message))

(clojure.core/defn revoke-snapshot-access ([revoke-snapshot-access-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-revoke-snapshot-access-message revoke-snapshot-access-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/revoke-snapshot-access-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/revoke-snapshot-access-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RevokeSnapshotAccessResult", :http.request.configuration/action "RevokeSnapshotAccess", :http.request.configuration/output-deser-fn response-revoke-snapshot-access-result, :http.request.spec/error-spec {"AccessToSnapshotDeniedFault" :portkey.aws.redshift.-2012-12-01/access-to-snapshot-denied-fault, "AuthorizationNotFoundFault" :portkey.aws.redshift.-2012-12-01/authorization-not-found-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault}})))))
(clojure.spec.alpha/fdef revoke-snapshot-access :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/revoke-snapshot-access-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/revoke-snapshot-access-result))

(clojure.core/defn create-tags ([create-tags-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-tags-message create-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTags", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "ResourceNotFoundFault" :portkey.aws.redshift.-2012-12-01/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-tags :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-tags-message) :ret clojure.core/true?)

(clojure.core/defn restore-from-cluster-snapshot ([restore-from-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-restore-from-cluster-snapshot-message restore-from-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/restore-from-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/restore-from-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RestoreFromClusterSnapshotResult", :http.request.configuration/action "RestoreFromClusterSnapshot", :http.request.configuration/output-deser-fn response-restore-from-cluster-snapshot-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift.-2012-12-01/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift.-2012-12-01/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-already-exists-fault, "InvalidVPCNetworkStateFault" :portkey.aws.redshift.-2012-12-01/invalid-vpc-network-state-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-not-found-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault, "InvalidSubnet" :portkey.aws.redshift.-2012-12-01/invalid-subnet, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-not-found-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-not-found-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-not-found-fault, "ClusterQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-quota-exceeded-fault, "InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-subnet-group-state-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault, "InvalidRestoreFault" :portkey.aws.redshift.-2012-12-01/invalid-restore-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-quota-exceeded-fault, "AccessToSnapshotDeniedFault" :portkey.aws.redshift.-2012-12-01/access-to-snapshot-denied-fault, "InvalidClusterTrackFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef restore-from-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/restore-from-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/restore-from-cluster-snapshot-result))

(clojure.core/defn modify-cluster-parameter-group ([modify-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-parameter-group-message modify-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterParameterGroupResult", :http.request.configuration/action "ModifyClusterParameterGroup", :http.request.configuration/output-deser-fn response-cluster-parameter-group-name-message, :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault, "InvalidClusterParameterGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-parameter-group-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-name-message))

(clojure.core/defn describe-cluster-db-revisions ([] (describe-cluster-db-revisions {})) ([describe-cluster-db-revisions-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-db-revisions-message describe-cluster-db-revisions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-db-revisions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-db-revisions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterDbRevisionsResult", :http.request.configuration/action "DescribeClusterDbRevisions", :http.request.configuration/output-deser-fn response-cluster-db-revisions-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-db-revisions :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-db-revisions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-db-revisions-message))

(clojure.core/defn describe-table-restore-status ([] (describe-table-restore-status {})) ([describe-table-restore-status-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-table-restore-status-message describe-table-restore-status-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/table-restore-status-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-table-restore-status-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeTableRestoreStatusResult", :http.request.configuration/action "DescribeTableRestoreStatus", :http.request.configuration/output-deser-fn response-table-restore-status-message, :http.request.spec/error-spec {"TableRestoreNotFoundFault" :portkey.aws.redshift.-2012-12-01/table-restore-not-found-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-table-restore-status :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-table-restore-status-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/table-restore-status-message))

(clojure.core/defn revoke-cluster-security-group-ingress ([revoke-cluster-security-group-ingress-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-revoke-cluster-security-group-ingress-message revoke-cluster-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/revoke-cluster-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/revoke-cluster-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RevokeClusterSecurityGroupIngressResult", :http.request.configuration/action "RevokeClusterSecurityGroupIngress", :http.request.configuration/output-deser-fn response-revoke-cluster-security-group-ingress-result, :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault, "AuthorizationNotFoundFault" :portkey.aws.redshift.-2012-12-01/authorization-not-found-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-security-group-state-fault}})))))
(clojure.spec.alpha/fdef revoke-cluster-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/revoke-cluster-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/revoke-cluster-security-group-ingress-result))

(clojure.core/defn describe-cluster-tracks ([] (describe-cluster-tracks {})) ([describe-cluster-tracks-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-tracks-message describe-cluster-tracks-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/track-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-tracks-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterTracksResult", :http.request.configuration/action "DescribeClusterTracks", :http.request.configuration/output-deser-fn response-track-list-message, :http.request.spec/error-spec {"InvalidClusterTrackFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-track-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation}})))))
(clojure.spec.alpha/fdef describe-cluster-tracks :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-tracks-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/track-list-message))

(clojure.core/defn create-cluster-snapshot ([create-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-cluster-snapshot-message create-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterSnapshotResult", :http.request.configuration/action "CreateClusterSnapshot", :http.request.configuration/output-deser-fn response-create-cluster-snapshot-result, :http.request.spec/error-spec {"ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-already-exists-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef create-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-cluster-snapshot-result))

(clojure.core/defn get-reserved-node-exchange-offerings ([get-reserved-node-exchange-offerings-input-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-get-reserved-node-exchange-offerings-input-message get-reserved-node-exchange-offerings-input-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/get-reserved-node-exchange-offerings-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/get-reserved-node-exchange-offerings-input-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "GetReservedNodeExchangeOfferingsResult", :http.request.configuration/action "GetReservedNodeExchangeOfferings", :http.request.configuration/output-deser-fn response-get-reserved-node-exchange-offerings-output-message, :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-not-found-fault, "InvalidReservedNodeStateFault" :portkey.aws.redshift.-2012-12-01/invalid-reserved-node-state-fault, "ReservedNodeAlreadyMigratedFault" :portkey.aws.redshift.-2012-12-01/reserved-node-already-migrated-fault, "ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift.-2012-12-01/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef get-reserved-node-exchange-offerings :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/get-reserved-node-exchange-offerings-input-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/get-reserved-node-exchange-offerings-output-message))

(clojure.core/defn create-hsm-configuration ([create-hsm-configuration-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-hsm-configuration-message create-hsm-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-hsm-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-hsm-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateHsmConfigurationResult", :http.request.configuration/action "CreateHsmConfiguration", :http.request.configuration/output-deser-fn response-create-hsm-configuration-result, :http.request.spec/error-spec {"HsmConfigurationAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-already-exists-fault, "HsmConfigurationQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-hsm-configuration :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-hsm-configuration-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-hsm-configuration-result))

(clojure.core/defn modify-snapshot-schedule ([modify-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-snapshot-schedule-message modify-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/snapshot-schedule, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifySnapshotScheduleResult", :http.request.configuration/action "ModifySnapshotSchedule", :http.request.configuration/output-deser-fn response-snapshot-schedule, :http.request.spec/error-spec {"InvalidScheduleFault" :portkey.aws.redshift.-2012-12-01/invalid-schedule-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-not-found-fault, "SnapshotScheduleUpdateInProgressFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-update-in-progress-fault}})))))
(clojure.spec.alpha/fdef modify-snapshot-schedule :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-snapshot-schedule-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-schedule))

(clojure.core/defn delete-hsm-client-certificate ([delete-hsm-client-certificate-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-hsm-client-certificate-message delete-hsm-client-certificate-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-hsm-client-certificate-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteHsmClientCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidHsmClientCertificateStateFault" :portkey.aws.redshift.-2012-12-01/invalid-hsm-client-certificate-state-fault, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-hsm-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-hsm-client-certificate-message) :ret clojure.core/true?)

(clojure.core/defn delete-snapshot-schedule ([delete-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-snapshot-schedule-message delete-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSnapshotSchedule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidClusterSnapshotScheduleStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-schedule-state-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-snapshot-schedule :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-snapshot-schedule-message) :ret clojure.core/true?)

(clojure.core/defn modify-cluster-maintenance ([modify-cluster-maintenance-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-maintenance-message modify-cluster-maintenance-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-maintenance-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-maintenance-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterMaintenanceResult", :http.request.configuration/action "ModifyClusterMaintenance", :http.request.configuration/output-deser-fn response-modify-cluster-maintenance-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-maintenance :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-maintenance-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-cluster-maintenance-result))

(clojure.core/defn describe-clusters ([] (describe-clusters {})) ([describe-clusters-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-clusters-message describe-clusters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/clusters-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-clusters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClustersResult", :http.request.configuration/action "DescribeClusters", :http.request.configuration/output-deser-fn response-clusters-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-clusters :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-clusters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/clusters-message))

(clojure.core/defn disable-logging ([disable-logging-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-disable-logging-message disable-logging-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/disable-logging-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DisableLoggingResult", :http.request.configuration/action "DisableLogging", :http.request.configuration/output-deser-fn response-logging-status, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef disable-logging :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/disable-logging-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/logging-status))

(clojure.core/defn batch-modify-cluster-snapshots ([batch-modify-cluster-snapshots-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-batch-modify-cluster-snapshots-message batch-modify-cluster-snapshots-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "BatchModifyClusterSnapshotsResult", :http.request.configuration/action "BatchModifyClusterSnapshots", :http.request.configuration/output-deser-fn response-batch-modify-cluster-snapshots-output-message, :http.request.spec/error-spec {"InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault, "BatchModifyClusterSnapshotsLimitExceededFault" :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef batch-modify-cluster-snapshots :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/batch-modify-cluster-snapshots-output-message))

(clojure.core/defn delete-cluster-snapshot ([delete-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-cluster-snapshot-message delete-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteClusterSnapshotResult", :http.request.configuration/action "DeleteClusterSnapshot", :http.request.configuration/output-deser-fn response-delete-cluster-snapshot-result, :http.request.spec/error-spec {"InvalidClusterSnapshotStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/delete-cluster-snapshot-result))

(clojure.core/defn create-snapshot-copy-grant ([create-snapshot-copy-grant-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-snapshot-copy-grant-message create-snapshot-copy-grant-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-snapshot-copy-grant-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-snapshot-copy-grant-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateSnapshotCopyGrantResult", :http.request.configuration/action "CreateSnapshotCopyGrant", :http.request.configuration/output-deser-fn response-create-snapshot-copy-grant-result, :http.request.spec/error-spec {"SnapshotCopyGrantAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-already-exists-fault, "SnapshotCopyGrantQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-quota-exceeded-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef create-snapshot-copy-grant :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-snapshot-copy-grant-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-snapshot-copy-grant-result))

(clojure.core/defn describe-tags ([] (describe-tags {})) ([describe-tags-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-tags-message describe-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/tagged-resource-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeTagsResult", :http.request.configuration/action "DescribeTags", :http.request.configuration/output-deser-fn response-tagged-resource-list-message, :http.request.spec/error-spec {"ResourceNotFoundFault" :portkey.aws.redshift.-2012-12-01/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-tags :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-tags-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/tagged-resource-list-message))

(clojure.core/defn modify-snapshot-copy-retention-period ([modify-snapshot-copy-retention-period-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-snapshot-copy-retention-period-message modify-snapshot-copy-retention-period-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-snapshot-copy-retention-period-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-snapshot-copy-retention-period-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifySnapshotCopyRetentionPeriodResult", :http.request.configuration/action "ModifySnapshotCopyRetentionPeriod", :http.request.configuration/output-deser-fn response-modify-snapshot-copy-retention-period-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "SnapshotCopyDisabledFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-disabled-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef modify-snapshot-copy-retention-period :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-snapshot-copy-retention-period-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-snapshot-copy-retention-period-result))

(clojure.core/defn modify-cluster-snapshot ([modify-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-snapshot-message modify-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterSnapshotResult", :http.request.configuration/action "ModifyClusterSnapshot", :http.request.configuration/output-deser-fn response-modify-cluster-snapshot-result, :http.request.spec/error-spec {"InvalidClusterSnapshotStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-result))

(clojure.core/defn delete-event-subscription ([delete-event-subscription-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-event-subscription-message delete-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteEventSubscription", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"SubscriptionNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-not-found-fault, "InvalidSubscriptionStateFault" :portkey.aws.redshift.-2012-12-01/invalid-subscription-state-fault}})))))
(clojure.spec.alpha/fdef delete-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-event-subscription-message) :ret clojure.core/true?)

(clojure.core/defn describe-default-cluster-parameters ([describe-default-cluster-parameters-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-default-cluster-parameters-message describe-default-cluster-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/describe-default-cluster-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-default-cluster-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeDefaultClusterParametersResult", :http.request.configuration/action "DescribeDefaultClusterParameters", :http.request.configuration/output-deser-fn response-describe-default-cluster-parameters-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-default-cluster-parameters :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/describe-default-cluster-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/describe-default-cluster-parameters-result))

(clojure.core/defn copy-cluster-snapshot ([copy-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-copy-cluster-snapshot-message copy-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/copy-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/copy-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CopyClusterSnapshotResult", :http.request.configuration/action "CopyClusterSnapshot", :http.request.configuration/output-deser-fn response-copy-cluster-snapshot-result, :http.request.spec/error-spec {"ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-already-exists-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-quota-exceeded-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef copy-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/copy-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/copy-cluster-snapshot-result))

(clojure.core/defn get-cluster-credentials ([get-cluster-credentials-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-get-cluster-credentials-message get-cluster-credentials-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-credentials, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/get-cluster-credentials-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "GetClusterCredentialsResult", :http.request.configuration/action "GetClusterCredentials", :http.request.configuration/output-deser-fn response-cluster-credentials, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef get-cluster-credentials :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/get-cluster-credentials-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-credentials))

(clojure.core/defn resize-cluster ([resize-cluster-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-resize-cluster-message resize-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/resize-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/resize-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ResizeClusterResult", :http.request.configuration/action "ResizeCluster", :http.request.configuration/output-deser-fn response-resize-cluster-result, :http.request.spec/error-spec {"InsufficientClusterCapacityFault" :portkey.aws.redshift.-2012-12-01/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-per-cluster-limit-exceeded-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "UnsupportedOptionFault" :portkey.aws.redshift.-2012-12-01/unsupported-option-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-quota-exceeded-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef resize-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/resize-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/resize-cluster-result))

(clojure.core/defn restore-table-from-cluster-snapshot ([restore-table-from-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-restore-table-from-cluster-snapshot-message restore-table-from-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/restore-table-from-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/restore-table-from-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RestoreTableFromClusterSnapshotResult", :http.request.configuration/action "RestoreTableFromClusterSnapshot", :http.request.configuration/output-deser-fn response-restore-table-from-cluster-snapshot-result, :http.request.spec/error-spec {"ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault, "InProgressTableRestoreQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/in-progress-table-restore-quota-exceeded-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault, "InvalidTableRestoreArgumentFault" :portkey.aws.redshift.-2012-12-01/invalid-table-restore-argument-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef restore-table-from-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/restore-table-from-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/restore-table-from-cluster-snapshot-result))

(clojure.core/defn reset-cluster-parameter-group ([reset-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-reset-cluster-parameter-group-message reset-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/reset-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ResetClusterParameterGroupResult", :http.request.configuration/action "ResetClusterParameterGroup", :http.request.configuration/output-deser-fn response-cluster-parameter-group-name-message, :http.request.spec/error-spec {"InvalidClusterParameterGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-parameter-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef reset-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/reset-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-name-message))

(clojure.core/defn enable-logging ([enable-logging-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-enable-logging-message enable-logging-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/enable-logging-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "EnableLoggingResult", :http.request.configuration/action "EnableLogging", :http.request.configuration/output-deser-fn response-logging-status, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "BucketNotFoundFault" :portkey.aws.redshift.-2012-12-01/bucket-not-found-fault, "InsufficientS3BucketPolicyFault" :portkey.aws.redshift.-2012-12-01/insufficient-s-3-bucket-policy-fault, "InvalidS3KeyPrefixFault" :portkey.aws.redshift.-2012-12-01/invalid-s-3-key-prefix-fault, "InvalidS3BucketNameFault" :portkey.aws.redshift.-2012-12-01/invalid-s-3-bucket-name-fault}})))))
(clojure.spec.alpha/fdef enable-logging :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/enable-logging-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/logging-status))

(clojure.core/defn describe-event-categories ([] (describe-event-categories {})) ([describe-event-categories-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-event-categories-message describe-event-categories-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/event-categories-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-event-categories-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventCategoriesResult", :http.request.configuration/action "DescribeEventCategories", :http.request.configuration/output-deser-fn response-event-categories-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-event-categories :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-event-categories-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-categories-message))

(clojure.core/defn describe-account-attributes ([] (describe-account-attributes {})) ([describe-account-attributes-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-account-attributes-message describe-account-attributes-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/account-attribute-list, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-account-attributes-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeAccountAttributesResult", :http.request.configuration/action "DescribeAccountAttributes", :http.request.configuration/output-deser-fn response-account-attribute-list, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-account-attributes :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-account-attributes-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/account-attribute-list))

(clojure.core/defn describe-cluster-versions ([] (describe-cluster-versions {})) ([describe-cluster-versions-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-versions-message describe-cluster-versions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-versions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-versions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterVersionsResult", :http.request.configuration/action "DescribeClusterVersions", :http.request.configuration/output-deser-fn response-cluster-versions-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-cluster-versions :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-versions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-versions-message))

(clojure.core/defn describe-reserved-nodes ([] (describe-reserved-nodes {})) ([describe-reserved-nodes-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-reserved-nodes-message describe-reserved-nodes-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/reserved-nodes-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-reserved-nodes-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReservedNodesResult", :http.request.configuration/action "DescribeReservedNodes", :http.request.configuration/output-deser-fn response-reserved-nodes-message, :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-not-found-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift.-2012-12-01/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef describe-reserved-nodes :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-reserved-nodes-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reserved-nodes-message))

(clojure.core/defn modify-cluster ([modify-cluster-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-message modify-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterResult", :http.request.configuration/action "ModifyCluster", :http.request.configuration/output-deser-fn response-modify-cluster-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift.-2012-12-01/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift.-2012-12-01/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-already-exists-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-not-found-fault, "UnsupportedOptionFault" :portkey.aws.redshift.-2012-12-01/unsupported-option-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-not-found-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-security-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/number-of-nodes-quota-exceeded-fault, "TableLimitExceededFault" :portkey.aws.redshift.-2012-12-01/table-limit-exceeded-fault, "InvalidClusterTrackFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef modify-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-cluster-result))

(clojure.core/defn purchase-reserved-node-offering ([purchase-reserved-node-offering-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-purchase-reserved-node-offering-message purchase-reserved-node-offering-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/purchase-reserved-node-offering-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/purchase-reserved-node-offering-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "PurchaseReservedNodeOfferingResult", :http.request.configuration/action "PurchaseReservedNodeOffering", :http.request.configuration/output-deser-fn response-purchase-reserved-node-offering-result, :http.request.spec/error-spec {"ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-offering-not-found-fault, "ReservedNodeAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/reserved-node-already-exists-fault, "ReservedNodeQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/reserved-node-quota-exceeded-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef purchase-reserved-node-offering :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/purchase-reserved-node-offering-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/purchase-reserved-node-offering-result))

(clojure.core/defn describe-reserved-node-offerings ([] (describe-reserved-node-offerings {})) ([describe-reserved-node-offerings-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-reserved-node-offerings-message describe-reserved-node-offerings-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/reserved-node-offerings-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-reserved-node-offerings-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReservedNodeOfferingsResult", :http.request.configuration/action "DescribeReservedNodeOfferings", :http.request.configuration/output-deser-fn response-reserved-node-offerings-message, :http.request.spec/error-spec {"ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift.-2012-12-01/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef describe-reserved-node-offerings :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-reserved-node-offerings-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reserved-node-offerings-message))

(clojure.core/defn modify-cluster-db-revision ([modify-cluster-db-revision-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-db-revision-message modify-cluster-db-revision-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-db-revision-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-db-revision-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterDbRevisionResult", :http.request.configuration/action "ModifyClusterDbRevision", :http.request.configuration/output-deser-fn response-modify-cluster-db-revision-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "ClusterOnLatestRevisionFault" :portkey.aws.redshift.-2012-12-01/cluster-on-latest-revision-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-db-revision :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-db-revision-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-cluster-db-revision-result))

(clojure.core/defn delete-cluster-parameter-group ([delete-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-cluster-parameter-group-message delete-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClusterParameterGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidClusterParameterGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-parameter-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-cluster-parameter-group-message) :ret clojure.core/true?)

(clojure.core/defn accept-reserved-node-exchange ([accept-reserved-node-exchange-input-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-accept-reserved-node-exchange-input-message accept-reserved-node-exchange-input-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/accept-reserved-node-exchange-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/accept-reserved-node-exchange-input-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AcceptReservedNodeExchangeResult", :http.request.configuration/action "AcceptReservedNodeExchange", :http.request.configuration/output-deser-fn response-accept-reserved-node-exchange-output-message, :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-not-found-fault, "InvalidReservedNodeStateFault" :portkey.aws.redshift.-2012-12-01/invalid-reserved-node-state-fault, "ReservedNodeAlreadyMigratedFault" :portkey.aws.redshift.-2012-12-01/reserved-node-already-migrated-fault, "ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift.-2012-12-01/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift.-2012-12-01/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift.-2012-12-01/dependent-service-unavailable-fault, "ReservedNodeAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/reserved-node-already-exists-fault}})))))
(clojure.spec.alpha/fdef accept-reserved-node-exchange :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/accept-reserved-node-exchange-input-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/accept-reserved-node-exchange-output-message))

(clojure.core/defn delete-snapshot-copy-grant ([delete-snapshot-copy-grant-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-snapshot-copy-grant-message delete-snapshot-copy-grant-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-snapshot-copy-grant-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSnapshotCopyGrant", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidSnapshotCopyGrantStateFault" :portkey.aws.redshift.-2012-12-01/invalid-snapshot-copy-grant-state-fault, "SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-snapshot-copy-grant :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-snapshot-copy-grant-message) :ret clojure.core/true?)

(clojure.core/defn delete-cluster ([delete-cluster-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-cluster-message delete-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteClusterResult", :http.request.configuration/action "DeleteCluster", :http.request.configuration/output-deser-fn response-delete-cluster-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-already-exists-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-quota-exceeded-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift.-2012-12-01/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef delete-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/delete-cluster-result))

(clojure.core/defn modify-event-subscription ([modify-event-subscription-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-event-subscription-message modify-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-event-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyEventSubscriptionResult", :http.request.configuration/action "ModifyEventSubscription", :http.request.configuration/output-deser-fn response-modify-event-subscription-result, :http.request.spec/error-spec {"SourceNotFoundFault" :portkey.aws.redshift.-2012-12-01/source-not-found-fault, "SNSNoAuthorizationFault" :portkey.aws.redshift.-2012-12-01/sns-no-authorization-fault, "SubscriptionSeverityNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-severity-not-found-fault, "SubscriptionNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-not-found-fault, "SNSTopicArnNotFoundFault" :portkey.aws.redshift.-2012-12-01/sns-topic-arn-not-found-fault, "SubscriptionCategoryNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-category-not-found-fault, "InvalidSubscriptionStateFault" :portkey.aws.redshift.-2012-12-01/invalid-subscription-state-fault, "SubscriptionEventIdNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-event-id-not-found-fault, "SNSInvalidTopicFault" :portkey.aws.redshift.-2012-12-01/sns-invalid-topic-fault}})))))
(clojure.spec.alpha/fdef modify-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-event-subscription-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-event-subscription-result))

(clojure.core/defn describe-hsm-client-certificates ([] (describe-hsm-client-certificates {})) ([describe-hsm-client-certificates-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-hsm-client-certificates-message describe-hsm-client-certificates-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-hsm-client-certificates-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeHsmClientCertificatesResult", :http.request.configuration/action "DescribeHsmClientCertificates", :http.request.configuration/output-deser-fn response-hsm-client-certificate-message, :http.request.spec/error-spec {"HsmClientCertificateNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-hsm-client-certificates :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-hsm-client-certificates-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/hsm-client-certificate-message))

(clojure.core/defn create-event-subscription ([create-event-subscription-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-event-subscription-message create-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-event-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateEventSubscriptionResult", :http.request.configuration/action "CreateEventSubscription", :http.request.configuration/output-deser-fn response-create-event-subscription-result, :http.request.spec/error-spec {"SourceNotFoundFault" :portkey.aws.redshift.-2012-12-01/source-not-found-fault, "SNSNoAuthorizationFault" :portkey.aws.redshift.-2012-12-01/sns-no-authorization-fault, "SubscriptionSeverityNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-severity-not-found-fault, "SNSTopicArnNotFoundFault" :portkey.aws.redshift.-2012-12-01/sns-topic-arn-not-found-fault, "SubscriptionCategoryNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-category-not-found-fault, "SubscriptionAlreadyExistFault" :portkey.aws.redshift.-2012-12-01/subscription-already-exist-fault, "SubscriptionEventIdNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-event-id-not-found-fault, "EventSubscriptionQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/event-subscription-quota-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault, "SNSInvalidTopicFault" :portkey.aws.redshift.-2012-12-01/sns-invalid-topic-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef create-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-event-subscription-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-event-subscription-result))

(clojure.core/defn create-cluster-security-group ([create-cluster-security-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-cluster-security-group-message create-cluster-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-cluster-security-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-cluster-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterSecurityGroupResult", :http.request.configuration/action "CreateClusterSecurityGroup", :http.request.configuration/output-deser-fn response-create-cluster-security-group-result, :http.request.spec/error-spec {"ClusterSecurityGroupAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-already-exists-fault, "ClusterSecurityGroupQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-security-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-cluster-security-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-cluster-security-group-result))

(clojure.core/defn describe-snapshot-copy-grants ([] (describe-snapshot-copy-grants {})) ([describe-snapshot-copy-grants-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-snapshot-copy-grants-message describe-snapshot-copy-grants-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-snapshot-copy-grants-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeSnapshotCopyGrantsResult", :http.request.configuration/action "DescribeSnapshotCopyGrants", :http.request.configuration/output-deser-fn response-snapshot-copy-grant-message, :http.request.spec/error-spec {"SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-snapshot-copy-grants :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-snapshot-copy-grants-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-copy-grant-message))

(clojure.core/defn modify-cluster-snapshot-schedule ([modify-cluster-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-snapshot-schedule-message modify-cluster-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyClusterSnapshotSchedule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-not-found-fault, "InvalidClusterSnapshotScheduleStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-schedule-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-snapshot-schedule :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-snapshot-schedule-message) :ret clojure.core/true?)

(clojure.core/defn authorize-cluster-security-group-ingress ([authorize-cluster-security-group-ingress-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-authorize-cluster-security-group-ingress-message authorize-cluster-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/authorize-cluster-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/authorize-cluster-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AuthorizeClusterSecurityGroupIngressResult", :http.request.configuration/action "AuthorizeClusterSecurityGroupIngress", :http.request.configuration/output-deser-fn response-authorize-cluster-security-group-ingress-result, :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-security-group-state-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/authorization-already-exists-fault, "AuthorizationQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/authorization-quota-exceeded-fault}})))))
(clojure.spec.alpha/fdef authorize-cluster-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/authorize-cluster-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/authorize-cluster-security-group-ingress-result))

(clojure.core/defn modify-cluster-subnet-group ([modify-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-subnet-group-message modify-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterSubnetGroupResult", :http.request.configuration/action "ModifyClusterSubnetGroup", :http.request.configuration/output-deser-fn response-modify-cluster-subnet-group-result, :http.request.spec/error-spec {"ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-not-found-fault, "ClusterSubnetQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-quota-exceeded-fault, "SubnetAlreadyInUse" :portkey.aws.redshift.-2012-12-01/subnet-already-in-use, "InvalidSubnet" :portkey.aws.redshift.-2012-12-01/invalid-subnet, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-cluster-subnet-group-result))

(clojure.core/defn delete-hsm-configuration ([delete-hsm-configuration-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-hsm-configuration-message delete-hsm-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-hsm-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteHsmConfiguration", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidHsmConfigurationStateFault" :portkey.aws.redshift.-2012-12-01/invalid-hsm-configuration-state-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift.-2012-12-01/hsm-configuration-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-hsm-configuration :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-hsm-configuration-message) :ret clojure.core/true?)

(clojure.core/defn describe-event-subscriptions ([] (describe-event-subscriptions {})) ([describe-event-subscriptions-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-event-subscriptions-message describe-event-subscriptions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/event-subscriptions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-event-subscriptions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventSubscriptionsResult", :http.request.configuration/action "DescribeEventSubscriptions", :http.request.configuration/output-deser-fn response-event-subscriptions-message, :http.request.spec/error-spec {"SubscriptionNotFoundFault" :portkey.aws.redshift.-2012-12-01/subscription-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-event-subscriptions :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-event-subscriptions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/event-subscriptions-message))

(clojure.core/defn describe-storage ([] (describe-storage {})) ([_] (clojure.core/let [request-function-result__284154__auto__ {}] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/customer-storage-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec nil, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeStorageResult", :http.request.configuration/action "DescribeStorage", :http.request.configuration/output-deser-fn response-customer-storage-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-storage :args clojure.core/empty? :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/customer-storage-message))

(clojure.core/defn create-cluster-parameter-group ([create-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-cluster-parameter-group-message create-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-cluster-parameter-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterParameterGroupResult", :http.request.configuration/action "CreateClusterParameterGroup", :http.request.configuration/output-deser-fn response-create-cluster-parameter-group-result, :http.request.spec/error-spec {"ClusterParameterGroupQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-quota-exceeded-fault, "ClusterParameterGroupAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-already-exists-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-cluster-parameter-group-result))

(clojure.core/defn describe-cluster-parameter-groups ([] (describe-cluster-parameter-groups {})) ([describe-cluster-parameter-groups-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-parameter-groups-message describe-cluster-parameter-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-parameter-groups-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-parameter-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterParameterGroupsResult", :http.request.configuration/action "DescribeClusterParameterGroups", :http.request.configuration/output-deser-fn response-cluster-parameter-groups-message, :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-parameter-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-parameter-groups :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-parameter-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-parameter-groups-message))

(clojure.core/defn authorize-snapshot-access ([authorize-snapshot-access-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-authorize-snapshot-access-message authorize-snapshot-access-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/authorize-snapshot-access-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/authorize-snapshot-access-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AuthorizeSnapshotAccessResult", :http.request.configuration/action "AuthorizeSnapshotAccess", :http.request.configuration/output-deser-fn response-authorize-snapshot-access-result, :http.request.spec/error-spec {"ClusterSnapshotNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-snapshot-not-found-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/authorization-already-exists-fault, "AuthorizationQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/authorization-quota-exceeded-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-snapshot-state-fault, "LimitExceededFault" :portkey.aws.redshift.-2012-12-01/limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef authorize-snapshot-access :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/authorize-snapshot-access-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/authorize-snapshot-access-result))

(clojure.core/defn describe-logging-status ([describe-logging-status-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-logging-status-message describe-logging-status-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-logging-status-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeLoggingStatusResult", :http.request.configuration/action "DescribeLoggingStatus", :http.request.configuration/output-deser-fn response-logging-status, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-logging-status :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/describe-logging-status-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/logging-status))

(clojure.core/defn describe-resize ([describe-resize-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-resize-message describe-resize-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/resize-progress-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-resize-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeResizeResult", :http.request.configuration/action "DescribeResize", :http.request.configuration/output-deser-fn response-resize-progress-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault, "ResizeNotFoundFault" :portkey.aws.redshift.-2012-12-01/resize-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-resize :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/describe-resize-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/resize-progress-message))

(clojure.core/defn reboot-cluster ([reboot-cluster-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-reboot-cluster-message reboot-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/reboot-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/reboot-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RebootClusterResult", :http.request.configuration/action "RebootCluster", :http.request.configuration/output-deser-fn response-reboot-cluster-result, :http.request.spec/error-spec {"InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef reboot-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/reboot-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/reboot-cluster-result))

(clojure.core/defn describe-orderable-cluster-options ([] (describe-orderable-cluster-options {})) ([describe-orderable-cluster-options-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-orderable-cluster-options-message describe-orderable-cluster-options-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/orderable-cluster-options-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-orderable-cluster-options-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeOrderableClusterOptionsResult", :http.request.configuration/action "DescribeOrderableClusterOptions", :http.request.configuration/output-deser-fn response-orderable-cluster-options-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-orderable-cluster-options :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-orderable-cluster-options-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/orderable-cluster-options-message))

(clojure.core/defn create-snapshot-schedule ([] (create-snapshot-schedule {})) ([create-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-snapshot-schedule-message create-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/snapshot-schedule, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateSnapshotScheduleResult", :http.request.configuration/action "CreateSnapshotSchedule", :http.request.configuration/output-deser-fn response-snapshot-schedule, :http.request.spec/error-spec {"SnapshotScheduleAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-already-exists-fault, "InvalidScheduleFault" :portkey.aws.redshift.-2012-12-01/invalid-schedule-fault, "SnapshotScheduleQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/snapshot-schedule-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "ScheduleDefinitionTypeUnsupportedFault" :portkey.aws.redshift.-2012-12-01/schedule-definition-type-unsupported-fault}})))))
(clojure.spec.alpha/fdef create-snapshot-schedule :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/create-snapshot-schedule-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/snapshot-schedule))

(clojure.core/defn create-cluster-subnet-group ([create-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-create-cluster-subnet-group-message create-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/create-cluster-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/create-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterSubnetGroupResult", :http.request.configuration/action "CreateClusterSubnetGroup", :http.request.configuration/output-deser-fn response-create-cluster-subnet-group-result, :http.request.spec/error-spec {"ClusterSubnetGroupAlreadyExistsFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-already-exists-fault, "ClusterSubnetGroupQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-group-quota-exceeded-fault, "ClusterSubnetQuotaExceededFault" :portkey.aws.redshift.-2012-12-01/cluster-subnet-quota-exceeded-fault, "InvalidSubnet" :portkey.aws.redshift.-2012-12-01/invalid-subnet, "UnauthorizedOperation" :portkey.aws.redshift.-2012-12-01/unauthorized-operation, "TagLimitExceededFault" :portkey.aws.redshift.-2012-12-01/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift.-2012-12-01/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef create-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/create-cluster-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/create-cluster-subnet-group-result))

(clojure.core/defn modify-cluster-iam-roles ([modify-cluster-iam-roles-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-modify-cluster-iam-roles-message modify-cluster-iam-roles-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-iam-roles-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/modify-cluster-iam-roles-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterIamRolesResult", :http.request.configuration/action "ModifyClusterIamRoles", :http.request.configuration/output-deser-fn response-modify-cluster-iam-roles-result, :http.request.spec/error-spec {"InvalidClusterStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-iam-roles :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/modify-cluster-iam-roles-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/modify-cluster-iam-roles-result))

(clojure.core/defn batch-delete-cluster-snapshots ([batch-delete-cluster-snapshots-requestinput] (clojure.core/let [request-function-result__284154__auto__ (req-batch-delete-cluster-snapshots-request batch-delete-cluster-snapshots-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/batch-delete-cluster-snapshots-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/batch-delete-cluster-snapshots-request, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "BatchDeleteClusterSnapshotsResult", :http.request.configuration/action "BatchDeleteClusterSnapshots", :http.request.configuration/output-deser-fn response-batch-delete-cluster-snapshots-result, :http.request.spec/error-spec {"BatchDeleteRequestSizeExceededFault" :portkey.aws.redshift.-2012-12-01/batch-delete-request-size-exceeded-fault}})))))
(clojure.spec.alpha/fdef batch-delete-cluster-snapshots :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/batch-delete-cluster-snapshots-request) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/batch-delete-cluster-snapshots-result))

(clojure.core/defn delete-cluster-security-group ([delete-cluster-security-group-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-delete-cluster-security-group-message delete-cluster-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/delete-cluster-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClusterSecurityGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__284153__auto__] {}), :http.request.spec/error-spec {"InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift.-2012-12-01/invalid-cluster-security-group-state-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-security-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift.-2012-12-01/delete-cluster-security-group-message) :ret clojure.core/true?)

(clojure.core/defn describe-cluster-security-groups ([] (describe-cluster-security-groups {})) ([describe-cluster-security-groups-messageinput] (clojure.core/let [request-function-result__284154__auto__ (req-describe-cluster-security-groups-message describe-cluster-security-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__284154__auto__ {:http.request.configuration/endpoints portkey.aws.redshift.-2012-12-01/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift.-2012-12-01/cluster-security-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift.-2012-12-01/describe-cluster-security-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterSecurityGroupsResult", :http.request.configuration/action "DescribeClusterSecurityGroups", :http.request.configuration/output-deser-fn response-cluster-security-group-message, :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift.-2012-12-01/cluster-security-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift.-2012-12-01/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-security-groups :args (clojure.spec.alpha/? :portkey.aws.redshift.-2012-12-01/describe-cluster-security-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift.-2012-12-01/cluster-security-group-message))
