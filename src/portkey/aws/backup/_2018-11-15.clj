(ns portkey.aws.backup.-2018-11-15 (:require [portkey.aws]))

(def endpoints 'nil)

(clojure.core/declare ser-list-of-tags)

(clojure.core/declare ser-iam-role-arn)

(clojure.core/declare serstring)

(clojure.core/declare ser-backup-rule-name)

(clojure.core/declare ser-cron-expression)

(clojure.core/declare ser-backup-vault-events)

(clojure.core/declare ser-tag-key)

(clojure.core/declare ser-tags)

(clojure.core/declare ser-arn)

(clojure.core/declare ser-metadata-key)

(clojure.core/declare ser-resource-arns)

(clojure.core/declare sertimestamp)

(clojure.core/declare ser-backup-rules-input)

(clojure.core/declare ser-condition-key)

(clojure.core/declare ser-metadata-value)

(clojure.core/declare ser-backup-vault-event)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-backup-job-state)

(clojure.core/declare ser-backup-vault-name)

(clojure.core/declare ser-tag-value)

(clojure.core/declare ser-condition-value)

(clojure.core/declare ser-restore-job-id)

(clojure.core/declare ser-condition-type)

(clojure.core/declare ser-backup-plan-name)

(clojure.core/declare ser-resource-type)

(clojure.core/declare ser-long)

(clojure.core/declare ser-metadata)

(clojure.core/declare ser-backup-selection-name)

(clojure.core/declare ser-backup-plan-input)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-condition)

(clojure.core/declare ser-lifecycle)

(clojure.core/declare ser-backup-selection)

(clojure.core/declare ser-iam-policy)

(clojure.core/declare ser-window-minutes)

(clojure.core/declare ser-backup-rule-input)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-list-of-tags [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-condition coll) #:http.request.field{:shape "Condition"}))) input), :shape "ListOfTags", :type "list"})

(clojure.core/defn- ser-iam-role-arn [input] #:http.request.field{:value input, :shape "IAMRoleArn"})

(clojure.core/defn- serstring [input] #:http.request.field{:value input, :shape "string"})

(clojure.core/defn- ser-backup-rule-name [input] #:http.request.field{:value input, :shape "BackupRuleName"})

(clojure.core/defn- ser-cron-expression [input] #:http.request.field{:value input, :shape "CronExpression"})

(clojure.core/defn- ser-backup-vault-events [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-backup-vault-event coll) #:http.request.field{:shape "BackupVaultEvent"}))) input), :shape "BackupVaultEvents", :type "list"})

(clojure.core/defn- ser-tag-key [input] #:http.request.field{:value input, :shape "TagKey"})

(clojure.core/defn- ser-tags [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-tag-key k) #:http.request.field{:map-info "key", :shape "TagKey"}) (clojure.core/into (ser-tag-value v) #:http.request.field{:map-info "value", :shape "TagValue"})])) input), :shape "Tags", :type "map", :sensitive true})

(clojure.core/defn- ser-arn [input] #:http.request.field{:value input, :shape "ARN"})

(clojure.core/defn- ser-metadata-key [input] #:http.request.field{:value input, :shape "MetadataKey"})

(clojure.core/defn- ser-resource-arns [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-arn coll) #:http.request.field{:shape "ARN"}))) input), :shape "ResourceArns", :type "list"})

(clojure.core/defn- sertimestamp [input] #:http.request.field{:value input, :shape "timestamp"})

(clojure.core/defn- ser-backup-rules-input [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-backup-rule-input coll) #:http.request.field{:shape "BackupRuleInput"}))) input), :shape "BackupRulesInput", :type "list"})

(clojure.core/defn- ser-condition-key [input] #:http.request.field{:value input, :shape "ConditionKey"})

(clojure.core/defn- ser-metadata-value [input] #:http.request.field{:value input, :shape "MetadataValue"})

(clojure.core/defn- ser-backup-vault-event [input] #:http.request.field{:value (clojure.core/get {"RESTORE_JOB_STARTED" "RESTORE_JOB_STARTED", "BACKUP_PLAN_CREATED" "BACKUP_PLAN_CREATED", :backup-job-started "BACKUP_JOB_STARTED", "BACKUP_JOB_STARTED" "BACKUP_JOB_STARTED", :restore-job-started "RESTORE_JOB_STARTED", "RESTORE_JOB_COMPLETED" "RESTORE_JOB_COMPLETED", :backup-plan-created "BACKUP_PLAN_CREATED", "BACKUP_JOB_COMPLETED" "BACKUP_JOB_COMPLETED", "BACKUP_PLAN_MODIFIED" "BACKUP_PLAN_MODIFIED", :recovery-point-modified "RECOVERY_POINT_MODIFIED", "RECOVERY_POINT_MODIFIED" "RECOVERY_POINT_MODIFIED", :backup-job-completed "BACKUP_JOB_COMPLETED", :backup-plan-modified "BACKUP_PLAN_MODIFIED", :restore-job-completed "RESTORE_JOB_COMPLETED"} input), :shape "BackupVaultEvent"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (serstring coll) #:http.request.field{:shape "string"}))) input), :shape "TagKeyList", :type "list", :sensitive true})

(clojure.core/defn- ser-backup-job-state [input] #:http.request.field{:value (clojure.core/get {"COMPLETED" "COMPLETED", "EXPIRED" "EXPIRED", :pending "PENDING", :completed "COMPLETED", :aborted "ABORTED", :created "CREATED", "PENDING" "PENDING", :running "RUNNING", "ABORTING" "ABORTING", "FAILED" "FAILED", :aborting "ABORTING", :expired "EXPIRED", "ABORTED" "ABORTED", :failed "FAILED", "RUNNING" "RUNNING", "CREATED" "CREATED"} input), :shape "BackupJobState"})

(clojure.core/defn- ser-backup-vault-name [input] #:http.request.field{:value input, :shape "BackupVaultName"})

(clojure.core/defn- ser-tag-value [input] #:http.request.field{:value input, :shape "TagValue"})

(clojure.core/defn- ser-condition-value [input] #:http.request.field{:value input, :shape "ConditionValue"})

(clojure.core/defn- ser-restore-job-id [input] #:http.request.field{:value input, :shape "RestoreJobId"})

(clojure.core/defn- ser-condition-type [input] #:http.request.field{:value (clojure.core/get {"STRINGEQUALS" "STRINGEQUALS", :stringequals "STRINGEQUALS"} input), :shape "ConditionType"})

(clojure.core/defn- ser-backup-plan-name [input] #:http.request.field{:value input, :shape "BackupPlanName"})

(clojure.core/defn- ser-resource-type [input] #:http.request.field{:value input, :shape "ResourceType"})

(clojure.core/defn- ser-long [input] #:http.request.field{:value input, :shape "Long"})

(clojure.core/defn- ser-metadata [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-metadata-key k) #:http.request.field{:map-info "key", :shape "MetadataKey"}) (clojure.core/into (ser-metadata-value v) #:http.request.field{:map-info "value", :shape "MetadataValue"})])) input), :shape "Metadata", :type "map"})

(clojure.core/defn- ser-backup-selection-name [input] #:http.request.field{:value input, :shape "BackupSelectionName"})

(clojure.core/defn- ser-backup-plan-input [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-backup-plan-name (:backup-plan-name input)) #:http.request.field{:name "BackupPlanName", :shape "BackupPlanName"}) (clojure.core/into (ser-backup-rules-input (:rules input)) #:http.request.field{:name "Rules", :shape "BackupRulesInput"})], :shape "BackupPlanInput", :type "structure"}))

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-condition [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-condition-type (:condition-type input)) #:http.request.field{:name "ConditionType", :shape "ConditionType"}) (clojure.core/into (ser-condition-key (:condition-key input)) #:http.request.field{:name "ConditionKey", :shape "ConditionKey"}) (clojure.core/into (ser-condition-value (:condition-value input)) #:http.request.field{:name "ConditionValue", :shape "ConditionValue"})], :shape "Condition", :type "structure"}))

(clojure.core/defn- ser-lifecycle [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Lifecycle", :type "structure"} (clojure.core/contains? input :move-to-cold-storage-after-days) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :move-to-cold-storage-after-days)) #:http.request.field{:name "MoveToColdStorageAfterDays", :shape "Long"})) (clojure.core/contains? input :delete-after-days) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-long (input :delete-after-days)) #:http.request.field{:name "DeleteAfterDays", :shape "Long"}))))

(clojure.core/defn- ser-backup-selection [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-backup-selection-name (:selection-name input)) #:http.request.field{:name "SelectionName", :shape "BackupSelectionName"}) (clojure.core/into (ser-iam-role-arn (:iam-role-arn input)) #:http.request.field{:name "IamRoleArn", :shape "IAMRoleArn"})], :shape "BackupSelection", :type "structure"} (clojure.core/contains? input :resources) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-arns (input :resources)) #:http.request.field{:name "Resources", :shape "ResourceArns"})) (clojure.core/contains? input :list-of-tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-tags (input :list-of-tags)) #:http.request.field{:name "ListOfTags", :shape "ListOfTags"}))))

(clojure.core/defn- ser-iam-policy [input] #:http.request.field{:value input, :shape "IAMPolicy"})

(clojure.core/defn- ser-window-minutes [input] #:http.request.field{:value input, :shape "WindowMinutes"})

(clojure.core/defn- ser-backup-rule-input [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-backup-rule-name (:rule-name input)) #:http.request.field{:name "RuleName", :shape "BackupRuleName"}) (clojure.core/into (ser-backup-vault-name (:target-backup-vault-name input)) #:http.request.field{:name "TargetBackupVaultName", :shape "BackupVaultName"})], :shape "BackupRuleInput", :type "structure"} (clojure.core/contains? input :schedule-expression) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cron-expression (input :schedule-expression)) #:http.request.field{:name "ScheduleExpression", :shape "CronExpression"})) (clojure.core/contains? input :start-window-minutes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-window-minutes (input :start-window-minutes)) #:http.request.field{:name "StartWindowMinutes", :shape "WindowMinutes"})) (clojure.core/contains? input :completion-window-minutes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-window-minutes (input :completion-window-minutes)) #:http.request.field{:name "CompletionWindowMinutes", :shape "WindowMinutes"})) (clojure.core/contains? input :lifecycle) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-lifecycle (input :lifecycle)) #:http.request.field{:name "Lifecycle", :shape "Lifecycle"})) (clojure.core/contains? input :recovery-point-tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tags (input :recovery-point-tags)) #:http.request.field{:name "RecoveryPointTags", :shape "Tags"}))))

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-list-backup-plan-versions-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-backup-vault-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "string", :location "uri", :location-name "backupVaultName"})]}))

(clojure.core/defn- req-create-backup-vault-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]} (clojure.core/contains? input :backup-vault-tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tags (input :backup-vault-tags)) #:http.request.field{:name "BackupVaultTags", :shape "Tags"})) (clojure.core/contains? input :encryption-key-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-arn (input :encryption-key-arn)) #:http.request.field{:name "EncryptionKeyArn", :shape "ARN"})) (clojure.core/contains? input :creator-request-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :creator-request-id)) #:http.request.field{:name "CreatorRequestId", :shape "string"}))))

(clojure.core/defn- req-list-backup-selections-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-protected-resources-input [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-protected-resource-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-arn (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "ARN", :location "uri", :location-name "resourceArn"})]}))

(clojure.core/defn- req-delete-recovery-point-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"}) (clojure.core/into (ser-arn (input :recovery-point-arn)) #:http.request.field{:name "RecoveryPointArn", :shape "ARN", :location "uri", :location-name "recoveryPointArn"})]}))

(clojure.core/defn- req-export-backup-plan-template-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})]}))

(clojure.core/defn- req-get-backup-plan-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})]} (clojure.core/contains? input :version-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :version-id)) #:http.request.field{:name "VersionId", :shape "string", :location "querystring", :location-name "versionId"}))))

(clojure.core/defn- req-delete-backup-vault-notifications-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]}))

(clojure.core/defn- req-create-backup-selection-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})], :body [(clojure.core/into (ser-backup-selection (input :backup-selection)) #:http.request.field{:name "BackupSelection", :shape "BackupSelection"})]} (clojure.core/contains? input :creator-request-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :creator-request-id)) #:http.request.field{:name "CreatorRequestId", :shape "string"}))))

(clojure.core/defn- req-list-restore-jobs-input [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-delete-backup-vault-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "string", :location "uri", :location-name "backupVaultName"})]}))

(clojure.core/defn- req-tag-resource-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-arn (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "ARN", :location "uri", :location-name "resourceArn"})], :body [(clojure.core/into (ser-tags (input :tags)) #:http.request.field{:name "Tags", :shape "Tags"})]}))

(clojure.core/defn- req-list-recovery-points-by-resource-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-arn (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "ARN", :location "uri", :location-name "resourceArn"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-put-backup-vault-access-policy-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]} (clojure.core/contains? input :policy) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-policy (input :policy)) #:http.request.field{:name "Policy", :shape "IAMPolicy"}))))

(clojure.core/defn- req-get-backup-plan-from-json-input [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (serstring (input :backup-plan-template-json)) #:http.request.field{:name "BackupPlanTemplateJson", :shape "string"})]}))

(clojure.core/defn- req-list-backup-vaults-input [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-recovery-points-by-backup-vault-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :by-resource-arn) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-arn (input :by-resource-arn)) #:http.request.field{:name "ByResourceArn", :shape "ARN", :location "querystring", :location-name "resourceArn"})) (clojure.core/contains? input :by-resource-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-type (input :by-resource-type)) #:http.request.field{:name "ByResourceType", :shape "ResourceType", :location "querystring", :location-name "resourceType"})) (clojure.core/contains? input :by-backup-plan-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :by-backup-plan-id)) #:http.request.field{:name "ByBackupPlanId", :shape "string", :location "querystring", :location-name "backupPlanId"})) (clojure.core/contains? input :by-created-before) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (sertimestamp (input :by-created-before)) #:http.request.field{:name "ByCreatedBefore", :shape "timestamp", :location "querystring", :location-name "createdBefore"})) (clojure.core/contains? input :by-created-after) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (sertimestamp (input :by-created-after)) #:http.request.field{:name "ByCreatedAfter", :shape "timestamp", :location "querystring", :location-name "createdAfter"}))))

(clojure.core/defn- req-get-backup-selection-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"}) (clojure.core/into (serstring (input :selection-id)) #:http.request.field{:name "SelectionId", :shape "string", :location "uri", :location-name "selectionId"})]}))

(clojure.core/defn- req-update-recovery-point-lifecycle-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"}) (clojure.core/into (ser-arn (input :recovery-point-arn)) #:http.request.field{:name "RecoveryPointArn", :shape "ARN", :location "uri", :location-name "recoveryPointArn"})]} (clojure.core/contains? input :lifecycle) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-lifecycle (input :lifecycle)) #:http.request.field{:name "Lifecycle", :shape "Lifecycle"}))))

(clojure.core/defn- req-create-backup-plan-input [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-backup-plan-input (input :backup-plan)) #:http.request.field{:name "BackupPlan", :shape "BackupPlanInput"})]} (clojure.core/contains? input :backup-plan-tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tags (input :backup-plan-tags)) #:http.request.field{:name "BackupPlanTags", :shape "Tags"})) (clojure.core/contains? input :creator-request-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :creator-request-id)) #:http.request.field{:name "CreatorRequestId", :shape "string"}))))

(clojure.core/defn- req-get-backup-vault-access-policy-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]}))

(clojure.core/defn- req-get-backup-plan-from-template-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-template-id)) #:http.request.field{:name "BackupPlanTemplateId", :shape "string", :location "uri", :location-name "templateId"})]}))

(clojure.core/defn- req-describe-restore-job-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-restore-job-id (input :restore-job-id)) #:http.request.field{:name "RestoreJobId", :shape "RestoreJobId", :location "uri", :location-name "restoreJobId"})]}))

(clojure.core/defn- req-untag-resource-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-arn (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "ARN", :location "uri", :location-name "resourceArn"})], :body [(clojure.core/into (ser-tag-key-list (input :tag-key-list)) #:http.request.field{:name "TagKeyList", :shape "TagKeyList"})]}))

(clojure.core/defn- req-delete-backup-vault-access-policy-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]}))

(clojure.core/defn- req-list-backup-plans-input [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :include-deleted) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :include-deleted)) #:http.request.field{:name "IncludeDeleted", :shape "Boolean", :location "querystring", :location-name "includeDeleted"}))))

(clojure.core/defn- req-start-backup-job-input [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName"}) (clojure.core/into (ser-arn (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "ARN"}) (clojure.core/into (ser-iam-role-arn (input :iam-role-arn)) #:http.request.field{:name "IamRoleArn", :shape "IAMRoleArn"})]} (clojure.core/contains? input :idempotency-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :idempotency-token)) #:http.request.field{:name "IdempotencyToken", :shape "string"})) (clojure.core/contains? input :start-window-minutes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-window-minutes (input :start-window-minutes)) #:http.request.field{:name "StartWindowMinutes", :shape "WindowMinutes"})) (clojure.core/contains? input :complete-window-minutes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-window-minutes (input :complete-window-minutes)) #:http.request.field{:name "CompleteWindowMinutes", :shape "WindowMinutes"})) (clojure.core/contains? input :lifecycle) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-lifecycle (input :lifecycle)) #:http.request.field{:name "Lifecycle", :shape "Lifecycle"})) (clojure.core/contains? input :recovery-point-tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tags (input :recovery-point-tags)) #:http.request.field{:name "RecoveryPointTags", :shape "Tags"}))))

(clojure.core/defn- req-update-backup-plan-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})], :body [(clojure.core/into (ser-backup-plan-input (input :backup-plan)) #:http.request.field{:name "BackupPlan", :shape "BackupPlanInput"})]}))

(clojure.core/defn- req-list-backup-plan-templates-input [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-put-backup-vault-notifications-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})], :body [(clojure.core/into (ser-arn (input :sns-topic-arn)) #:http.request.field{:name "SNSTopicArn", :shape "ARN"}) (clojure.core/into (ser-backup-vault-events (input :backup-vault-events)) #:http.request.field{:name "BackupVaultEvents", :shape "BackupVaultEvents"})]}))

(clojure.core/defn- req-delete-backup-plan-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"})]}))

(clojure.core/defn- req-stop-backup-job-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-job-id)) #:http.request.field{:name "BackupJobId", :shape "string", :location "uri", :location-name "backupJobId"})]}))

(clojure.core/defn- req-get-recovery-point-restore-metadata-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"}) (clojure.core/into (ser-arn (input :recovery-point-arn)) #:http.request.field{:name "RecoveryPointArn", :shape "ARN", :location "uri", :location-name "recoveryPointArn"})]}))

(clojure.core/defn- req-describe-recovery-point-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"}) (clojure.core/into (ser-arn (input :recovery-point-arn)) #:http.request.field{:name "RecoveryPointArn", :shape "ARN", :location "uri", :location-name "recoveryPointArn"})]}))

(clojure.core/defn- req-get-backup-vault-notifications-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-backup-vault-name (input :backup-vault-name)) #:http.request.field{:name "BackupVaultName", :shape "BackupVaultName", :location "uri", :location-name "backupVaultName"})]}))

(clojure.core/defn- req-start-restore-job-input [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-arn (input :recovery-point-arn)) #:http.request.field{:name "RecoveryPointArn", :shape "ARN"}) (clojure.core/into (ser-metadata (input :metadata)) #:http.request.field{:name "Metadata", :shape "Metadata"}) (clojure.core/into (ser-iam-role-arn (input :iam-role-arn)) #:http.request.field{:name "IamRoleArn", :shape "IAMRoleArn"})]} (clojure.core/contains? input :idempotency-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :idempotency-token)) #:http.request.field{:name "IdempotencyToken", :shape "string"})) (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-type (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "ResourceType"}))))

(clojure.core/defn- req-list-backup-jobs-input [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :by-resource-arn) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-arn (input :by-resource-arn)) #:http.request.field{:name "ByResourceArn", :shape "ARN", :location "querystring", :location-name "resourceArn"})) (clojure.core/contains? input :by-state) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-backup-job-state (input :by-state)) #:http.request.field{:name "ByState", :shape "BackupJobState", :location "querystring", :location-name "state"})) (clojure.core/contains? input :by-backup-vault-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-backup-vault-name (input :by-backup-vault-name)) #:http.request.field{:name "ByBackupVaultName", :shape "BackupVaultName", :location "querystring", :location-name "backupVaultName"})) (clojure.core/contains? input :by-created-before) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (sertimestamp (input :by-created-before)) #:http.request.field{:name "ByCreatedBefore", :shape "timestamp", :location "querystring", :location-name "createdBefore"})) (clojure.core/contains? input :by-created-after) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (sertimestamp (input :by-created-after)) #:http.request.field{:name "ByCreatedAfter", :shape "timestamp", :location "querystring", :location-name "createdAfter"})) (clojure.core/contains? input :by-resource-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-type (input :by-resource-type)) #:http.request.field{:name "ByResourceType", :shape "ResourceType", :location "querystring", :location-name "resourceType"}))))

(clojure.core/defn- req-delete-backup-selection-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-plan-id)) #:http.request.field{:name "BackupPlanId", :shape "string", :location "uri", :location-name "backupPlanId"}) (clojure.core/into (serstring (input :selection-id)) #:http.request.field{:name "SelectionId", :shape "string", :location "uri", :location-name "selectionId"})]}))

(clojure.core/defn- req-list-tags-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-arn (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "ARN", :location "uri", :location-name "resourceArn"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serstring (input :next-token)) #:http.request.field{:name "NextToken", :shape "string", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-backup-job-input [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (serstring (input :backup-job-id)) #:http.request.field{:name "BackupJobId", :shape "string", :location "uri", :location-name "backupJobId"})]}))

(clojure.core/declare deserboolean)

(clojure.core/declare deser-backup-vault-list-member)

(clojure.core/declare deser-list-of-tags)

(clojure.core/declare deser-iam-role-arn)

(clojure.core/declare deser-recovery-point-creator)

(clojure.core/declare deser-backup-plan-templates-list)

(clojure.core/declare deserstring)

(clojure.core/declare deser-backup-rule-name)

(clojure.core/declare deser-cron-expression)

(clojure.core/declare deser-backup-rules)

(clojure.core/declare deser-backup-vault-events)

(clojure.core/declare deserlong)

(clojure.core/declare deser-tag-key)

(clojure.core/declare deser-recovery-point-by-resource-list)

(clojure.core/declare deser-tags)

(clojure.core/declare deser-arn)

(clojure.core/declare deser-backup-vault-list)

(clojure.core/declare deser-metadata-key)

(clojure.core/declare deser-resource-arns)

(clojure.core/declare desertimestamp)

(clojure.core/declare deser-recovery-point-status)

(clojure.core/declare deser-backup-selections-list-member)

(clojure.core/declare deser-condition-key)

(clojure.core/declare deser-metadata-value)

(clojure.core/declare deser-backup-vault-event)

(clojure.core/declare deser-backup-plan)

(clojure.core/declare deser-backup-job-state)

(clojure.core/declare deser-backup-vault-name)

(clojure.core/declare deser-tag-value)

(clojure.core/declare deser-backup-plan-versions-list)

(clojure.core/declare deser-condition-value)

(clojure.core/declare deser-restore-job-id)

(clojure.core/declare deser-condition-type)

(clojure.core/declare deser-recovery-point-by-backup-vault)

(clojure.core/declare deser-backup-plans-list-member)

(clojure.core/declare deser-backup-plan-name)

(clojure.core/declare deser-backup-plans-list)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-recovery-point-by-resource)

(clojure.core/declare deser-long)

(clojure.core/declare deser-backup-job)

(clojure.core/declare deser-protected-resources-list)

(clojure.core/declare deser-metadata)

(clojure.core/declare deser-backup-selection-name)

(clojure.core/declare deser-condition)

(clojure.core/declare deser-resource-types)

(clojure.core/declare deser-lifecycle)

(clojure.core/declare deser-backup-selections-list)

(clojure.core/declare deser-storage-class)

(clojure.core/declare deser-recovery-point-by-backup-vault-list)

(clojure.core/declare deser-backup-selection)

(clojure.core/declare deser-backup-rule)

(clojure.core/declare deser-iam-policy)

(clojure.core/declare deser-restore-jobs-list)

(clojure.core/declare deser-restore-job-status)

(clojure.core/declare deser-window-minutes)

(clojure.core/declare deser-backup-jobs-list)

(clojure.core/declare deser-protected-resource)

(clojure.core/declare deser-calculated-lifecycle)

(clojure.core/declare deser-backup-plan-templates-list-member)

(clojure.core/declare deser-restore-jobs-list-member)

(clojure.core/defn- deserboolean [input] input)

(clojure.core/defn- deser-backup-vault-list-member [input] (clojure.core/cond-> {} (clojure.core/contains? input "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (input "BackupVaultName"))) (clojure.core/contains? input "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (input "BackupVaultArn"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "EncryptionKeyArn") (clojure.core/assoc :encryption-key-arn (deser-arn (input "EncryptionKeyArn"))) (clojure.core/contains? input "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (input "CreatorRequestId"))) (clojure.core/contains? input "NumberOfRecoveryPoints") (clojure.core/assoc :number-of-recovery-points (deserlong (input "NumberOfRecoveryPoints")))))

(clojure.core/defn- deser-list-of-tags [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-condition coll))) input))

(clojure.core/defn- deser-iam-role-arn [input] input)

(clojure.core/defn- deser-recovery-point-creator [input] (clojure.core/cond-> {} (clojure.core/contains? input "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (input "BackupPlanId"))) (clojure.core/contains? input "BackupPlanArn") (clojure.core/assoc :backup-plan-arn (deser-arn (input "BackupPlanArn"))) (clojure.core/contains? input "BackupPlanVersion") (clojure.core/assoc :backup-plan-version (deserstring (input "BackupPlanVersion"))) (clojure.core/contains? input "BackupRuleId") (clojure.core/assoc :backup-rule-id (deserstring (input "BackupRuleId")))))

(clojure.core/defn- deser-backup-plan-templates-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-plan-templates-list-member coll))) input))

(clojure.core/defn- deserstring [input] input)

(clojure.core/defn- deser-backup-rule-name [input] input)

(clojure.core/defn- deser-cron-expression [input] input)

(clojure.core/defn- deser-backup-rules [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-rule coll))) input))

(clojure.core/defn- deser-backup-vault-events [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-vault-event coll))) input))

(clojure.core/defn- deserlong [input] input)

(clojure.core/defn- deser-tag-key [input] input)

(clojure.core/defn- deser-recovery-point-by-resource-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-recovery-point-by-resource coll))) input))

(clojure.core/defn- deser-tags [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-tag-key k) (deser-tag-value v)])) input))

(clojure.core/defn- deser-arn [input] input)

(clojure.core/defn- deser-backup-vault-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-vault-list-member coll))) input))

(clojure.core/defn- deser-metadata-key [input] input)

(clojure.core/defn- deser-resource-arns [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-arn coll))) input))

(clojure.core/defn- desertimestamp [input] input)

(clojure.core/defn- deser-recovery-point-status [input] (clojure.core/get {"COMPLETED" :completed, "PARTIAL" :partial, "DELETING" :deleting, "EXPIRED" :expired} input))

(clojure.core/defn- deser-backup-selections-list-member [input] (clojure.core/cond-> {} (clojure.core/contains? input "SelectionId") (clojure.core/assoc :selection-id (deserstring (input "SelectionId"))) (clojure.core/contains? input "SelectionName") (clojure.core/assoc :selection-name (deser-backup-selection-name (input "SelectionName"))) (clojure.core/contains? input "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (input "BackupPlanId"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (input "CreatorRequestId"))) (clojure.core/contains? input "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (input "IamRoleArn")))))

(clojure.core/defn- deser-condition-key [input] input)

(clojure.core/defn- deser-metadata-value [input] input)

(clojure.core/defn- deser-backup-vault-event [input] (clojure.core/get {"BACKUP_JOB_STARTED" :backup-job-started, "BACKUP_JOB_COMPLETED" :backup-job-completed, "RESTORE_JOB_STARTED" :restore-job-started, "RESTORE_JOB_COMPLETED" :restore-job-completed, "RECOVERY_POINT_MODIFIED" :recovery-point-modified, "BACKUP_PLAN_CREATED" :backup-plan-created, "BACKUP_PLAN_MODIFIED" :backup-plan-modified} input))

(clojure.core/defn- deser-backup-plan [input] (clojure.core/cond-> {:backup-plan-name (deser-backup-plan-name (input "BackupPlanName")), :rules (deser-backup-rules (input "Rules"))}))

(clojure.core/defn- deser-backup-job-state [input] (clojure.core/get {"CREATED" :created, "PENDING" :pending, "RUNNING" :running, "ABORTING" :aborting, "ABORTED" :aborted, "COMPLETED" :completed, "FAILED" :failed, "EXPIRED" :expired} input))

(clojure.core/defn- deser-backup-vault-name [input] input)

(clojure.core/defn- deser-tag-value [input] input)

(clojure.core/defn- deser-backup-plan-versions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-plans-list-member coll))) input))

(clojure.core/defn- deser-condition-value [input] input)

(clojure.core/defn- deser-restore-job-id [input] input)

(clojure.core/defn- deser-condition-type [input] (clojure.core/get {"STRINGEQUALS" :stringequals} input))

(clojure.core/defn- deser-recovery-point-by-backup-vault [input] (clojure.core/cond-> {} (clojure.core/contains? input "LastRestoreTime") (clojure.core/assoc :last-restore-time (desertimestamp (input "LastRestoreTime"))) (clojure.core/contains? input "CompletionDate") (clojure.core/assoc :completion-date (desertimestamp (input "CompletionDate"))) (clojure.core/contains? input "IsEncrypted") (clojure.core/assoc :is-encrypted (deserboolean (input "IsEncrypted"))) (clojure.core/contains? input "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (input "BackupVaultArn"))) (clojure.core/contains? input "EncryptionKeyArn") (clojure.core/assoc :encryption-key-arn (deser-arn (input "EncryptionKeyArn"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-recovery-point-status (input "Status"))) (clojure.core/contains? input "CreatedBy") (clojure.core/assoc :created-by (deser-recovery-point-creator (input "CreatedBy"))) (clojure.core/contains? input "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (input "IamRoleArn"))) (clojure.core/contains? input "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (input "BackupVaultName"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "ResourceType"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "ResourceArn") (clojure.core/assoc :resource-arn (deser-arn (input "ResourceArn"))) (clojure.core/contains? input "Lifecycle") (clojure.core/assoc :lifecycle (deser-lifecycle (input "Lifecycle"))) (clojure.core/contains? input "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (input "RecoveryPointArn"))) (clojure.core/contains? input "BackupSizeInBytes") (clojure.core/assoc :backup-size-in-bytes (deser-long (input "BackupSizeInBytes"))) (clojure.core/contains? input "CalculatedLifecycle") (clojure.core/assoc :calculated-lifecycle (deser-calculated-lifecycle (input "CalculatedLifecycle")))))

(clojure.core/defn- deser-backup-plans-list-member [input] (clojure.core/cond-> {} (clojure.core/contains? input "BackupPlanArn") (clojure.core/assoc :backup-plan-arn (deser-arn (input "BackupPlanArn"))) (clojure.core/contains? input "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (input "BackupPlanId"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "DeletionDate") (clojure.core/assoc :deletion-date (desertimestamp (input "DeletionDate"))) (clojure.core/contains? input "VersionId") (clojure.core/assoc :version-id (deserstring (input "VersionId"))) (clojure.core/contains? input "BackupPlanName") (clojure.core/assoc :backup-plan-name (deser-backup-plan-name (input "BackupPlanName"))) (clojure.core/contains? input "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (input "CreatorRequestId"))) (clojure.core/contains? input "LastExecutionDate") (clojure.core/assoc :last-execution-date (desertimestamp (input "LastExecutionDate")))))

(clojure.core/defn- deser-backup-plan-name [input] input)

(clojure.core/defn- deser-backup-plans-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-plans-list-member coll))) input))

(clojure.core/defn- deser-resource-type [input] input)

(clojure.core/defn- deser-recovery-point-by-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (input "RecoveryPointArn"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-recovery-point-status (input "Status"))) (clojure.core/contains? input "EncryptionKeyArn") (clojure.core/assoc :encryption-key-arn (deser-arn (input "EncryptionKeyArn"))) (clojure.core/contains? input "BackupSizeBytes") (clojure.core/assoc :backup-size-bytes (deser-long (input "BackupSizeBytes"))) (clojure.core/contains? input "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (input "BackupVaultName")))))

(clojure.core/defn- deser-long [input] input)

(clojure.core/defn- deser-backup-job [input] (clojure.core/cond-> {} (clojure.core/contains? input "BytesTransferred") (clojure.core/assoc :bytes-transferred (deser-long (input "BytesTransferred"))) (clojure.core/contains? input "BackupJobId") (clojure.core/assoc :backup-job-id (deserstring (input "BackupJobId"))) (clojure.core/contains? input "CompletionDate") (clojure.core/assoc :completion-date (desertimestamp (input "CompletionDate"))) (clojure.core/contains? input "StatusMessage") (clojure.core/assoc :status-message (deserstring (input "StatusMessage"))) (clojure.core/contains? input "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (input "BackupVaultArn"))) (clojure.core/contains? input "CreatedBy") (clojure.core/assoc :created-by (deser-recovery-point-creator (input "CreatedBy"))) (clojure.core/contains? input "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (input "IamRoleArn"))) (clojure.core/contains? input "StartBy") (clojure.core/assoc :start-by (desertimestamp (input "StartBy"))) (clojure.core/contains? input "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (input "BackupVaultName"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "ResourceType"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "ResourceArn") (clojure.core/assoc :resource-arn (deser-arn (input "ResourceArn"))) (clojure.core/contains? input "State") (clojure.core/assoc :state (deser-backup-job-state (input "State"))) (clojure.core/contains? input "PercentDone") (clojure.core/assoc :percent-done (deserstring (input "PercentDone"))) (clojure.core/contains? input "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (input "RecoveryPointArn"))) (clojure.core/contains? input "BackupSizeInBytes") (clojure.core/assoc :backup-size-in-bytes (deser-long (input "BackupSizeInBytes"))) (clojure.core/contains? input "ExpectedCompletionDate") (clojure.core/assoc :expected-completion-date (desertimestamp (input "ExpectedCompletionDate")))))

(clojure.core/defn- deser-protected-resources-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-protected-resource coll))) input))

(clojure.core/defn- deser-metadata [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-metadata-key k) (deser-metadata-value v)])) input))

(clojure.core/defn- deser-backup-selection-name [input] input)

(clojure.core/defn- deser-condition [input] (clojure.core/cond-> {:condition-type (deser-condition-type (input "ConditionType")), :condition-key (deser-condition-key (input "ConditionKey")), :condition-value (deser-condition-value (input "ConditionValue"))}))

(clojure.core/defn- deser-resource-types [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource-type coll))) input))

(clojure.core/defn- deser-lifecycle [input] (clojure.core/cond-> {} (clojure.core/contains? input "MoveToColdStorageAfterDays") (clojure.core/assoc :move-to-cold-storage-after-days (deser-long (input "MoveToColdStorageAfterDays"))) (clojure.core/contains? input "DeleteAfterDays") (clojure.core/assoc :delete-after-days (deser-long (input "DeleteAfterDays")))))

(clojure.core/defn- deser-backup-selections-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-selections-list-member coll))) input))

(clojure.core/defn- deser-storage-class [input] (clojure.core/get {"WARM" :warm, "COLD" :cold, "DELETED" :deleted} input))

(clojure.core/defn- deser-recovery-point-by-backup-vault-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-recovery-point-by-backup-vault coll))) input))

(clojure.core/defn- deser-backup-selection [input] (clojure.core/cond-> {:selection-name (deser-backup-selection-name (input "SelectionName")), :iam-role-arn (deser-iam-role-arn (input "IamRoleArn"))} (clojure.core/contains? input "Resources") (clojure.core/assoc :resources (deser-resource-arns (input "Resources"))) (clojure.core/contains? input "ListOfTags") (clojure.core/assoc :list-of-tags (deser-list-of-tags (input "ListOfTags")))))

(clojure.core/defn- deser-backup-rule [input] (clojure.core/cond-> {:rule-name (deser-backup-rule-name (input "RuleName")), :target-backup-vault-name (deser-backup-vault-name (input "TargetBackupVaultName"))} (clojure.core/contains? input "ScheduleExpression") (clojure.core/assoc :schedule-expression (deser-cron-expression (input "ScheduleExpression"))) (clojure.core/contains? input "StartWindowMinutes") (clojure.core/assoc :start-window-minutes (deser-window-minutes (input "StartWindowMinutes"))) (clojure.core/contains? input "CompletionWindowMinutes") (clojure.core/assoc :completion-window-minutes (deser-window-minutes (input "CompletionWindowMinutes"))) (clojure.core/contains? input "Lifecycle") (clojure.core/assoc :lifecycle (deser-lifecycle (input "Lifecycle"))) (clojure.core/contains? input "RecoveryPointTags") (clojure.core/assoc :recovery-point-tags (deser-tags (input "RecoveryPointTags"))) (clojure.core/contains? input "RuleId") (clojure.core/assoc :rule-id (deserstring (input "RuleId")))))

(clojure.core/defn- deser-iam-policy [input] input)

(clojure.core/defn- deser-restore-jobs-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-restore-jobs-list-member coll))) input))

(clojure.core/defn- deser-restore-job-status [input] (clojure.core/get {"PENDING" :pending, "RUNNING" :running, "COMPLETED" :completed, "ABORTED" :aborted, "FAILED" :failed} input))

(clojure.core/defn- deser-window-minutes [input] input)

(clojure.core/defn- deser-backup-jobs-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-backup-job coll))) input))

(clojure.core/defn- deser-protected-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "ResourceArn") (clojure.core/assoc :resource-arn (deser-arn (input "ResourceArn"))) (clojure.core/contains? input "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "ResourceType"))) (clojure.core/contains? input "LastBackupTime") (clojure.core/assoc :last-backup-time (desertimestamp (input "LastBackupTime")))))

(clojure.core/defn- deser-calculated-lifecycle [input] (clojure.core/cond-> {} (clojure.core/contains? input "MoveToColdStorageAt") (clojure.core/assoc :move-to-cold-storage-at (desertimestamp (input "MoveToColdStorageAt"))) (clojure.core/contains? input "DeleteAt") (clojure.core/assoc :delete-at (desertimestamp (input "DeleteAt")))))

(clojure.core/defn- deser-backup-plan-templates-list-member [input] (clojure.core/cond-> {} (clojure.core/contains? input "BackupPlanTemplateId") (clojure.core/assoc :backup-plan-template-id (deserstring (input "BackupPlanTemplateId"))) (clojure.core/contains? input "BackupPlanTemplateName") (clojure.core/assoc :backup-plan-template-name (deserstring (input "BackupPlanTemplateName")))))

(clojure.core/defn- deser-restore-jobs-list-member [input] (clojure.core/cond-> {} (clojure.core/contains? input "CompletionDate") (clojure.core/assoc :completion-date (desertimestamp (input "CompletionDate"))) (clojure.core/contains? input "StatusMessage") (clojure.core/assoc :status-message (deserstring (input "StatusMessage"))) (clojure.core/contains? input "ExpectedCompletionTimeMinutes") (clojure.core/assoc :expected-completion-time-minutes (deser-long (input "ExpectedCompletionTimeMinutes"))) (clojure.core/contains? input "Status") (clojure.core/assoc :status (deser-restore-job-status (input "Status"))) (clojure.core/contains? input "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (input "IamRoleArn"))) (clojure.core/contains? input "CreatedResourceArn") (clojure.core/assoc :created-resource-arn (deser-arn (input "CreatedResourceArn"))) (clojure.core/contains? input "RestoreJobId") (clojure.core/assoc :restore-job-id (deserstring (input "RestoreJobId"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (input "CreationDate"))) (clojure.core/contains? input "PercentDone") (clojure.core/assoc :percent-done (deserstring (input "PercentDone"))) (clojure.core/contains? input "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (input "RecoveryPointArn"))) (clojure.core/contains? input "BackupSizeInBytes") (clojure.core/assoc :backup-size-in-bytes (deser-long (input "BackupSizeInBytes")))))

(clojure.core/defn- response-create-backup-plan-output ([input] (response-create-backup-plan-output nil input)) ([resultWrapper140867 input] (clojure.core/let [rawinput140866 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140868 {"BackupPlanId" (rawinput140866 "BackupPlanId"), "BackupPlanArn" (rawinput140866 "BackupPlanArn"), "CreationDate" (rawinput140866 "CreationDate"), "VersionId" (rawinput140866 "VersionId")}] (clojure.core/cond-> {} (letvar140868 "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (clojure.core/get-in letvar140868 ["BackupPlanId"]))) (letvar140868 "BackupPlanArn") (clojure.core/assoc :backup-plan-arn (deser-arn (clojure.core/get-in letvar140868 ["BackupPlanArn"]))) (letvar140868 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140868 ["CreationDate"]))) (letvar140868 "VersionId") (clojure.core/assoc :version-id (deserstring (clojure.core/get-in letvar140868 ["VersionId"])))))))

(clojure.core/defn- response-describe-restore-job-output ([input] (response-describe-restore-job-output nil input)) ([resultWrapper140870 input] (clojure.core/let [rawinput140869 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140871 {"CompletionDate" (rawinput140869 "CompletionDate"), "StatusMessage" (rawinput140869 "StatusMessage"), "ExpectedCompletionTimeMinutes" (rawinput140869 "ExpectedCompletionTimeMinutes"), "Status" (rawinput140869 "Status"), "IamRoleArn" (rawinput140869 "IamRoleArn"), "CreatedResourceArn" (rawinput140869 "CreatedResourceArn"), "RestoreJobId" (rawinput140869 "RestoreJobId"), "CreationDate" (rawinput140869 "CreationDate"), "PercentDone" (rawinput140869 "PercentDone"), "RecoveryPointArn" (rawinput140869 "RecoveryPointArn"), "BackupSizeInBytes" (rawinput140869 "BackupSizeInBytes")}] (clojure.core/cond-> {} (letvar140871 "CompletionDate") (clojure.core/assoc :completion-date (desertimestamp (clojure.core/get-in letvar140871 ["CompletionDate"]))) (letvar140871 "StatusMessage") (clojure.core/assoc :status-message (deserstring (clojure.core/get-in letvar140871 ["StatusMessage"]))) (letvar140871 "ExpectedCompletionTimeMinutes") (clojure.core/assoc :expected-completion-time-minutes (deser-long (clojure.core/get-in letvar140871 ["ExpectedCompletionTimeMinutes"]))) (letvar140871 "Status") (clojure.core/assoc :status (deser-restore-job-status (clojure.core/get-in letvar140871 ["Status"]))) (letvar140871 "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (clojure.core/get-in letvar140871 ["IamRoleArn"]))) (letvar140871 "CreatedResourceArn") (clojure.core/assoc :created-resource-arn (deser-arn (clojure.core/get-in letvar140871 ["CreatedResourceArn"]))) (letvar140871 "RestoreJobId") (clojure.core/assoc :restore-job-id (deserstring (clojure.core/get-in letvar140871 ["RestoreJobId"]))) (letvar140871 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140871 ["CreationDate"]))) (letvar140871 "PercentDone") (clojure.core/assoc :percent-done (deserstring (clojure.core/get-in letvar140871 ["PercentDone"]))) (letvar140871 "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (clojure.core/get-in letvar140871 ["RecoveryPointArn"]))) (letvar140871 "BackupSizeInBytes") (clojure.core/assoc :backup-size-in-bytes (deser-long (clojure.core/get-in letvar140871 ["BackupSizeInBytes"])))))))

(clojure.core/defn- response-already-exists-exception ([input] (response-already-exists-exception nil input)) ([resultWrapper140873 input] (clojure.core/let [rawinput140872 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140874 {"Code" (rawinput140872 "Code"), "Message" (rawinput140872 "Message"), "CreatorRequestId" (rawinput140872 "CreatorRequestId"), "Arn" (rawinput140872 "Arn"), "Type" (rawinput140872 "Type"), "Context" (rawinput140872 "Context")}] (clojure.core/cond-> {} (letvar140874 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140874 ["Code"]))) (letvar140874 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140874 ["Message"]))) (letvar140874 "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (clojure.core/get-in letvar140874 ["CreatorRequestId"]))) (letvar140874 "Arn") (clojure.core/assoc :arn (deserstring (clojure.core/get-in letvar140874 ["Arn"]))) (letvar140874 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140874 ["Type"]))) (letvar140874 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140874 ["Context"])))))))

(clojure.core/defn- response-describe-backup-job-output ([input] (response-describe-backup-job-output nil input)) ([resultWrapper140876 input] (clojure.core/let [rawinput140875 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140877 {"BytesTransferred" (rawinput140875 "BytesTransferred"), "BackupJobId" (rawinput140875 "BackupJobId"), "CompletionDate" (rawinput140875 "CompletionDate"), "StatusMessage" (rawinput140875 "StatusMessage"), "BackupVaultArn" (rawinput140875 "BackupVaultArn"), "CreatedBy" (rawinput140875 "CreatedBy"), "IamRoleArn" (rawinput140875 "IamRoleArn"), "StartBy" (rawinput140875 "StartBy"), "BackupVaultName" (rawinput140875 "BackupVaultName"), "ResourceType" (rawinput140875 "ResourceType"), "CreationDate" (rawinput140875 "CreationDate"), "ResourceArn" (rawinput140875 "ResourceArn"), "State" (rawinput140875 "State"), "PercentDone" (rawinput140875 "PercentDone"), "RecoveryPointArn" (rawinput140875 "RecoveryPointArn"), "BackupSizeInBytes" (rawinput140875 "BackupSizeInBytes"), "ExpectedCompletionDate" (rawinput140875 "ExpectedCompletionDate")}] (clojure.core/cond-> {} (letvar140877 "BytesTransferred") (clojure.core/assoc :bytes-transferred (deser-long (clojure.core/get-in letvar140877 ["BytesTransferred"]))) (letvar140877 "BackupJobId") (clojure.core/assoc :backup-job-id (deserstring (clojure.core/get-in letvar140877 ["BackupJobId"]))) (letvar140877 "CompletionDate") (clojure.core/assoc :completion-date (desertimestamp (clojure.core/get-in letvar140877 ["CompletionDate"]))) (letvar140877 "StatusMessage") (clojure.core/assoc :status-message (deserstring (clojure.core/get-in letvar140877 ["StatusMessage"]))) (letvar140877 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140877 ["BackupVaultArn"]))) (letvar140877 "CreatedBy") (clojure.core/assoc :created-by (deser-recovery-point-creator (clojure.core/get-in letvar140877 ["CreatedBy"]))) (letvar140877 "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (clojure.core/get-in letvar140877 ["IamRoleArn"]))) (letvar140877 "StartBy") (clojure.core/assoc :start-by (desertimestamp (clojure.core/get-in letvar140877 ["StartBy"]))) (letvar140877 "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (clojure.core/get-in letvar140877 ["BackupVaultName"]))) (letvar140877 "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (clojure.core/get-in letvar140877 ["ResourceType"]))) (letvar140877 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140877 ["CreationDate"]))) (letvar140877 "ResourceArn") (clojure.core/assoc :resource-arn (deser-arn (clojure.core/get-in letvar140877 ["ResourceArn"]))) (letvar140877 "State") (clojure.core/assoc :state (deser-backup-job-state (clojure.core/get-in letvar140877 ["State"]))) (letvar140877 "PercentDone") (clojure.core/assoc :percent-done (deserstring (clojure.core/get-in letvar140877 ["PercentDone"]))) (letvar140877 "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (clojure.core/get-in letvar140877 ["RecoveryPointArn"]))) (letvar140877 "BackupSizeInBytes") (clojure.core/assoc :backup-size-in-bytes (deser-long (clojure.core/get-in letvar140877 ["BackupSizeInBytes"]))) (letvar140877 "ExpectedCompletionDate") (clojure.core/assoc :expected-completion-date (desertimestamp (clojure.core/get-in letvar140877 ["ExpectedCompletionDate"])))))))

(clojure.core/defn- response-get-backup-plan-from-template-output ([input] (response-get-backup-plan-from-template-output nil input)) ([resultWrapper140879 input] (clojure.core/let [rawinput140878 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140880 {"BackupPlanDocument" (rawinput140878 "BackupPlanDocument")}] (clojure.core/cond-> {} (letvar140880 "BackupPlanDocument") (clojure.core/assoc :backup-plan-document (deser-backup-plan (clojure.core/get-in letvar140880 ["BackupPlanDocument"])))))))

(clojure.core/defn- response-list-recovery-points-by-backup-vault-output ([input] (response-list-recovery-points-by-backup-vault-output nil input)) ([resultWrapper140882 input] (clojure.core/let [rawinput140881 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140883 {"NextToken" (rawinput140881 "NextToken"), "RecoveryPoints" (rawinput140881 "RecoveryPoints")}] (clojure.core/cond-> {} (letvar140883 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140883 ["NextToken"]))) (letvar140883 "RecoveryPoints") (clojure.core/assoc :recovery-points (deser-recovery-point-by-backup-vault-list (clojure.core/get-in letvar140883 ["RecoveryPoints"])))))))

(clojure.core/defn- response-invalid-request-exception ([input] (response-invalid-request-exception nil input)) ([resultWrapper140885 input] (clojure.core/let [rawinput140884 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140886 {"Code" (rawinput140884 "Code"), "Message" (rawinput140884 "Message"), "Type" (rawinput140884 "Type"), "Context" (rawinput140884 "Context")}] (clojure.core/cond-> {} (letvar140886 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140886 ["Code"]))) (letvar140886 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140886 ["Message"]))) (letvar140886 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140886 ["Type"]))) (letvar140886 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140886 ["Context"])))))))

(clojure.core/defn- response-update-recovery-point-lifecycle-output ([input] (response-update-recovery-point-lifecycle-output nil input)) ([resultWrapper140888 input] (clojure.core/let [rawinput140887 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140889 {"BackupVaultArn" (rawinput140887 "BackupVaultArn"), "RecoveryPointArn" (rawinput140887 "RecoveryPointArn"), "Lifecycle" (rawinput140887 "Lifecycle"), "CalculatedLifecycle" (rawinput140887 "CalculatedLifecycle")}] (clojure.core/cond-> {} (letvar140889 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140889 ["BackupVaultArn"]))) (letvar140889 "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (clojure.core/get-in letvar140889 ["RecoveryPointArn"]))) (letvar140889 "Lifecycle") (clojure.core/assoc :lifecycle (deser-lifecycle (clojure.core/get-in letvar140889 ["Lifecycle"]))) (letvar140889 "CalculatedLifecycle") (clojure.core/assoc :calculated-lifecycle (deser-calculated-lifecycle (clojure.core/get-in letvar140889 ["CalculatedLifecycle"])))))))

(clojure.core/defn- response-update-backup-plan-output ([input] (response-update-backup-plan-output nil input)) ([resultWrapper140891 input] (clojure.core/let [rawinput140890 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140892 {"BackupPlanId" (rawinput140890 "BackupPlanId"), "BackupPlanArn" (rawinput140890 "BackupPlanArn"), "CreationDate" (rawinput140890 "CreationDate"), "VersionId" (rawinput140890 "VersionId")}] (clojure.core/cond-> {} (letvar140892 "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (clojure.core/get-in letvar140892 ["BackupPlanId"]))) (letvar140892 "BackupPlanArn") (clojure.core/assoc :backup-plan-arn (deser-arn (clojure.core/get-in letvar140892 ["BackupPlanArn"]))) (letvar140892 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140892 ["CreationDate"]))) (letvar140892 "VersionId") (clojure.core/assoc :version-id (deserstring (clojure.core/get-in letvar140892 ["VersionId"])))))))

(clojure.core/defn- response-export-backup-plan-template-output ([input] (response-export-backup-plan-template-output nil input)) ([resultWrapper140894 input] (clojure.core/let [rawinput140893 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140895 {"BackupPlanTemplateJson" (rawinput140893 "BackupPlanTemplateJson")}] (clojure.core/cond-> {} (letvar140895 "BackupPlanTemplateJson") (clojure.core/assoc :backup-plan-template-json (deserstring (clojure.core/get-in letvar140895 ["BackupPlanTemplateJson"])))))))

(clojure.core/defn- response-get-backup-selection-output ([input] (response-get-backup-selection-output nil input)) ([resultWrapper140897 input] (clojure.core/let [rawinput140896 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140898 {"BackupSelection" (rawinput140896 "BackupSelection"), "SelectionId" (rawinput140896 "SelectionId"), "BackupPlanId" (rawinput140896 "BackupPlanId"), "CreationDate" (rawinput140896 "CreationDate"), "CreatorRequestId" (rawinput140896 "CreatorRequestId")}] (clojure.core/cond-> {} (letvar140898 "BackupSelection") (clojure.core/assoc :backup-selection (deser-backup-selection (clojure.core/get-in letvar140898 ["BackupSelection"]))) (letvar140898 "SelectionId") (clojure.core/assoc :selection-id (deserstring (clojure.core/get-in letvar140898 ["SelectionId"]))) (letvar140898 "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (clojure.core/get-in letvar140898 ["BackupPlanId"]))) (letvar140898 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140898 ["CreationDate"]))) (letvar140898 "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (clojure.core/get-in letvar140898 ["CreatorRequestId"])))))))

(clojure.core/defn- response-describe-protected-resource-output ([input] (response-describe-protected-resource-output nil input)) ([resultWrapper140900 input] (clojure.core/let [rawinput140899 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140901 {"ResourceArn" (rawinput140899 "ResourceArn"), "ResourceType" (rawinput140899 "ResourceType"), "LastBackupTime" (rawinput140899 "LastBackupTime")}] (clojure.core/cond-> {} (letvar140901 "ResourceArn") (clojure.core/assoc :resource-arn (deser-arn (clojure.core/get-in letvar140901 ["ResourceArn"]))) (letvar140901 "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (clojure.core/get-in letvar140901 ["ResourceType"]))) (letvar140901 "LastBackupTime") (clojure.core/assoc :last-backup-time (desertimestamp (clojure.core/get-in letvar140901 ["LastBackupTime"])))))))

(clojure.core/defn- response-start-restore-job-output ([input] (response-start-restore-job-output nil input)) ([resultWrapper140903 input] (clojure.core/let [rawinput140902 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140904 {"RestoreJobId" (rawinput140902 "RestoreJobId")}] (clojure.core/cond-> {} (letvar140904 "RestoreJobId") (clojure.core/assoc :restore-job-id (deser-restore-job-id (clojure.core/get-in letvar140904 ["RestoreJobId"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper140906 input] (clojure.core/let [rawinput140905 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140907 {"Code" (rawinput140905 "Code"), "Message" (rawinput140905 "Message"), "Type" (rawinput140905 "Type"), "Context" (rawinput140905 "Context")}] (clojure.core/cond-> {} (letvar140907 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140907 ["Code"]))) (letvar140907 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140907 ["Message"]))) (letvar140907 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140907 ["Type"]))) (letvar140907 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140907 ["Context"])))))))

(clojure.core/defn- response-get-backup-plan-from-json-output ([input] (response-get-backup-plan-from-json-output nil input)) ([resultWrapper140909 input] (clojure.core/let [rawinput140908 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140910 {"BackupPlan" (rawinput140908 "BackupPlan")}] (clojure.core/cond-> {} (letvar140910 "BackupPlan") (clojure.core/assoc :backup-plan (deser-backup-plan (clojure.core/get-in letvar140910 ["BackupPlan"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper140912 input] (clojure.core/let [rawinput140911 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140913 {"Code" (rawinput140911 "Code"), "Message" (rawinput140911 "Message"), "Type" (rawinput140911 "Type"), "Context" (rawinput140911 "Context")}] (clojure.core/cond-> {} (letvar140913 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140913 ["Code"]))) (letvar140913 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140913 ["Message"]))) (letvar140913 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140913 ["Type"]))) (letvar140913 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140913 ["Context"])))))))

(clojure.core/defn- response-list-restore-jobs-output ([input] (response-list-restore-jobs-output nil input)) ([resultWrapper140915 input] (clojure.core/let [rawinput140914 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140916 {"RestoreJobs" (rawinput140914 "RestoreJobs"), "NextToken" (rawinput140914 "NextToken")}] (clojure.core/cond-> {} (letvar140916 "RestoreJobs") (clojure.core/assoc :restore-jobs (deser-restore-jobs-list (clojure.core/get-in letvar140916 ["RestoreJobs"]))) (letvar140916 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140916 ["NextToken"])))))))

(clojure.core/defn- response-list-backup-selections-output ([input] (response-list-backup-selections-output nil input)) ([resultWrapper140918 input] (clojure.core/let [rawinput140917 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140919 {"NextToken" (rawinput140917 "NextToken"), "BackupSelectionsList" (rawinput140917 "BackupSelectionsList")}] (clojure.core/cond-> {} (letvar140919 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140919 ["NextToken"]))) (letvar140919 "BackupSelectionsList") (clojure.core/assoc :backup-selections-list (deser-backup-selections-list (clojure.core/get-in letvar140919 ["BackupSelectionsList"])))))))

(clojure.core/defn- response-dependency-failure-exception ([input] (response-dependency-failure-exception nil input)) ([resultWrapper140921 input] (clojure.core/let [rawinput140920 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140922 {"Code" (rawinput140920 "Code"), "Message" (rawinput140920 "Message"), "Type" (rawinput140920 "Type"), "Context" (rawinput140920 "Context")}] (clojure.core/cond-> {} (letvar140922 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140922 ["Code"]))) (letvar140922 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140922 ["Message"]))) (letvar140922 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140922 ["Type"]))) (letvar140922 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140922 ["Context"])))))))

(clojure.core/defn- response-get-supported-resource-types-output ([input] (response-get-supported-resource-types-output nil input)) ([resultWrapper140924 input] (clojure.core/let [rawinput140923 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140925 {"ResourceTypes" (rawinput140923 "ResourceTypes")}] (clojure.core/cond-> {} (letvar140925 "ResourceTypes") (clojure.core/assoc :resource-types (deser-resource-types (clojure.core/get-in letvar140925 ["ResourceTypes"])))))))

(clojure.core/defn- response-resource-not-found-exception ([input] (response-resource-not-found-exception nil input)) ([resultWrapper140927 input] (clojure.core/let [rawinput140926 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140928 {"Code" (rawinput140926 "Code"), "Message" (rawinput140926 "Message"), "Type" (rawinput140926 "Type"), "Context" (rawinput140926 "Context")}] (clojure.core/cond-> {} (letvar140928 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140928 ["Code"]))) (letvar140928 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140928 ["Message"]))) (letvar140928 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140928 ["Type"]))) (letvar140928 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140928 ["Context"])))))))

(clojure.core/defn- response-start-backup-job-output ([input] (response-start-backup-job-output nil input)) ([resultWrapper140930 input] (clojure.core/let [rawinput140929 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140931 {"BackupJobId" (rawinput140929 "BackupJobId"), "RecoveryPointArn" (rawinput140929 "RecoveryPointArn"), "CreationDate" (rawinput140929 "CreationDate")}] (clojure.core/cond-> {} (letvar140931 "BackupJobId") (clojure.core/assoc :backup-job-id (deserstring (clojure.core/get-in letvar140931 ["BackupJobId"]))) (letvar140931 "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (clojure.core/get-in letvar140931 ["RecoveryPointArn"]))) (letvar140931 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140931 ["CreationDate"])))))))

(clojure.core/defn- response-get-backup-plan-output ([input] (response-get-backup-plan-output nil input)) ([resultWrapper140933 input] (clojure.core/let [rawinput140932 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140934 {"BackupPlan" (rawinput140932 "BackupPlan"), "BackupPlanId" (rawinput140932 "BackupPlanId"), "BackupPlanArn" (rawinput140932 "BackupPlanArn"), "VersionId" (rawinput140932 "VersionId"), "CreatorRequestId" (rawinput140932 "CreatorRequestId"), "CreationDate" (rawinput140932 "CreationDate"), "DeletionDate" (rawinput140932 "DeletionDate"), "LastExecutionDate" (rawinput140932 "LastExecutionDate")}] (clojure.core/cond-> {} (letvar140934 "BackupPlan") (clojure.core/assoc :backup-plan (deser-backup-plan (clojure.core/get-in letvar140934 ["BackupPlan"]))) (letvar140934 "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (clojure.core/get-in letvar140934 ["BackupPlanId"]))) (letvar140934 "BackupPlanArn") (clojure.core/assoc :backup-plan-arn (deser-arn (clojure.core/get-in letvar140934 ["BackupPlanArn"]))) (letvar140934 "VersionId") (clojure.core/assoc :version-id (deserstring (clojure.core/get-in letvar140934 ["VersionId"]))) (letvar140934 "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (clojure.core/get-in letvar140934 ["CreatorRequestId"]))) (letvar140934 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140934 ["CreationDate"]))) (letvar140934 "DeletionDate") (clojure.core/assoc :deletion-date (desertimestamp (clojure.core/get-in letvar140934 ["DeletionDate"]))) (letvar140934 "LastExecutionDate") (clojure.core/assoc :last-execution-date (desertimestamp (clojure.core/get-in letvar140934 ["LastExecutionDate"])))))))

(clojure.core/defn- response-list-backup-vaults-output ([input] (response-list-backup-vaults-output nil input)) ([resultWrapper140936 input] (clojure.core/let [rawinput140935 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140937 {"BackupVaultList" (rawinput140935 "BackupVaultList"), "NextToken" (rawinput140935 "NextToken")}] (clojure.core/cond-> {} (letvar140937 "BackupVaultList") (clojure.core/assoc :backup-vault-list (deser-backup-vault-list (clojure.core/get-in letvar140937 ["BackupVaultList"]))) (letvar140937 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140937 ["NextToken"])))))))

(clojure.core/defn- response-list-backup-plan-templates-output ([input] (response-list-backup-plan-templates-output nil input)) ([resultWrapper140939 input] (clojure.core/let [rawinput140938 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140940 {"NextToken" (rawinput140938 "NextToken"), "BackupPlanTemplatesList" (rawinput140938 "BackupPlanTemplatesList")}] (clojure.core/cond-> {} (letvar140940 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140940 ["NextToken"]))) (letvar140940 "BackupPlanTemplatesList") (clojure.core/assoc :backup-plan-templates-list (deser-backup-plan-templates-list (clojure.core/get-in letvar140940 ["BackupPlanTemplatesList"])))))))

(clojure.core/defn- response-delete-backup-plan-output ([input] (response-delete-backup-plan-output nil input)) ([resultWrapper140942 input] (clojure.core/let [rawinput140941 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140943 {"BackupPlanId" (rawinput140941 "BackupPlanId"), "BackupPlanArn" (rawinput140941 "BackupPlanArn"), "DeletionDate" (rawinput140941 "DeletionDate"), "VersionId" (rawinput140941 "VersionId")}] (clojure.core/cond-> {} (letvar140943 "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (clojure.core/get-in letvar140943 ["BackupPlanId"]))) (letvar140943 "BackupPlanArn") (clojure.core/assoc :backup-plan-arn (deser-arn (clojure.core/get-in letvar140943 ["BackupPlanArn"]))) (letvar140943 "DeletionDate") (clojure.core/assoc :deletion-date (desertimestamp (clojure.core/get-in letvar140943 ["DeletionDate"]))) (letvar140943 "VersionId") (clojure.core/assoc :version-id (deserstring (clojure.core/get-in letvar140943 ["VersionId"])))))))

(clojure.core/defn- response-list-backup-plans-output ([input] (response-list-backup-plans-output nil input)) ([resultWrapper140945 input] (clojure.core/let [rawinput140944 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140946 {"NextToken" (rawinput140944 "NextToken"), "BackupPlansList" (rawinput140944 "BackupPlansList")}] (clojure.core/cond-> {} (letvar140946 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140946 ["NextToken"]))) (letvar140946 "BackupPlansList") (clojure.core/assoc :backup-plans-list (deser-backup-plans-list (clojure.core/get-in letvar140946 ["BackupPlansList"])))))))

(clojure.core/defn- response-create-backup-selection-output ([input] (response-create-backup-selection-output nil input)) ([resultWrapper140948 input] (clojure.core/let [rawinput140947 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140949 {"SelectionId" (rawinput140947 "SelectionId"), "BackupPlanId" (rawinput140947 "BackupPlanId"), "CreationDate" (rawinput140947 "CreationDate")}] (clojure.core/cond-> {} (letvar140949 "SelectionId") (clojure.core/assoc :selection-id (deserstring (clojure.core/get-in letvar140949 ["SelectionId"]))) (letvar140949 "BackupPlanId") (clojure.core/assoc :backup-plan-id (deserstring (clojure.core/get-in letvar140949 ["BackupPlanId"]))) (letvar140949 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140949 ["CreationDate"])))))))

(clojure.core/defn- response-get-backup-vault-notifications-output ([input] (response-get-backup-vault-notifications-output nil input)) ([resultWrapper140951 input] (clojure.core/let [rawinput140950 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140952 {"BackupVaultName" (rawinput140950 "BackupVaultName"), "BackupVaultArn" (rawinput140950 "BackupVaultArn"), "SNSTopicArn" (rawinput140950 "SNSTopicArn"), "BackupVaultEvents" (rawinput140950 "BackupVaultEvents")}] (clojure.core/cond-> {} (letvar140952 "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (clojure.core/get-in letvar140952 ["BackupVaultName"]))) (letvar140952 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140952 ["BackupVaultArn"]))) (letvar140952 "SNSTopicArn") (clojure.core/assoc :sns-topic-arn (deser-arn (clojure.core/get-in letvar140952 ["SNSTopicArn"]))) (letvar140952 "BackupVaultEvents") (clojure.core/assoc :backup-vault-events (deser-backup-vault-events (clojure.core/get-in letvar140952 ["BackupVaultEvents"])))))))

(clojure.core/defn- response-list-backup-plan-versions-output ([input] (response-list-backup-plan-versions-output nil input)) ([resultWrapper140954 input] (clojure.core/let [rawinput140953 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140955 {"NextToken" (rawinput140953 "NextToken"), "BackupPlanVersionsList" (rawinput140953 "BackupPlanVersionsList")}] (clojure.core/cond-> {} (letvar140955 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140955 ["NextToken"]))) (letvar140955 "BackupPlanVersionsList") (clojure.core/assoc :backup-plan-versions-list (deser-backup-plan-versions-list (clojure.core/get-in letvar140955 ["BackupPlanVersionsList"])))))))

(clojure.core/defn- response-missing-parameter-value-exception ([input] (response-missing-parameter-value-exception nil input)) ([resultWrapper140957 input] (clojure.core/let [rawinput140956 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140958 {"Code" (rawinput140956 "Code"), "Message" (rawinput140956 "Message"), "Type" (rawinput140956 "Type"), "Context" (rawinput140956 "Context")}] (clojure.core/cond-> {} (letvar140958 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140958 ["Code"]))) (letvar140958 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140958 ["Message"]))) (letvar140958 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140958 ["Type"]))) (letvar140958 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140958 ["Context"])))))))

(clojure.core/defn- response-list-protected-resources-output ([input] (response-list-protected-resources-output nil input)) ([resultWrapper140960 input] (clojure.core/let [rawinput140959 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140961 {"Results" (rawinput140959 "Results"), "NextToken" (rawinput140959 "NextToken")}] (clojure.core/cond-> {} (letvar140961 "Results") (clojure.core/assoc :results (deser-protected-resources-list (clojure.core/get-in letvar140961 ["Results"]))) (letvar140961 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140961 ["NextToken"])))))))

(clojure.core/defn- response-describe-recovery-point-output ([input] (response-describe-recovery-point-output nil input)) ([resultWrapper140963 input] (clojure.core/let [rawinput140962 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140964 {"LastRestoreTime" (rawinput140962 "LastRestoreTime"), "CompletionDate" (rawinput140962 "CompletionDate"), "IsEncrypted" (rawinput140962 "IsEncrypted"), "BackupVaultArn" (rawinput140962 "BackupVaultArn"), "EncryptionKeyArn" (rawinput140962 "EncryptionKeyArn"), "Status" (rawinput140962 "Status"), "CreatedBy" (rawinput140962 "CreatedBy"), "IamRoleArn" (rawinput140962 "IamRoleArn"), "BackupVaultName" (rawinput140962 "BackupVaultName"), "ResourceType" (rawinput140962 "ResourceType"), "CreationDate" (rawinput140962 "CreationDate"), "ResourceArn" (rawinput140962 "ResourceArn"), "Lifecycle" (rawinput140962 "Lifecycle"), "StorageClass" (rawinput140962 "StorageClass"), "RecoveryPointArn" (rawinput140962 "RecoveryPointArn"), "BackupSizeInBytes" (rawinput140962 "BackupSizeInBytes"), "CalculatedLifecycle" (rawinput140962 "CalculatedLifecycle")}] (clojure.core/cond-> {} (letvar140964 "LastRestoreTime") (clojure.core/assoc :last-restore-time (desertimestamp (clojure.core/get-in letvar140964 ["LastRestoreTime"]))) (letvar140964 "CompletionDate") (clojure.core/assoc :completion-date (desertimestamp (clojure.core/get-in letvar140964 ["CompletionDate"]))) (letvar140964 "IsEncrypted") (clojure.core/assoc :is-encrypted (deserboolean (clojure.core/get-in letvar140964 ["IsEncrypted"]))) (letvar140964 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140964 ["BackupVaultArn"]))) (letvar140964 "EncryptionKeyArn") (clojure.core/assoc :encryption-key-arn (deser-arn (clojure.core/get-in letvar140964 ["EncryptionKeyArn"]))) (letvar140964 "Status") (clojure.core/assoc :status (deser-recovery-point-status (clojure.core/get-in letvar140964 ["Status"]))) (letvar140964 "CreatedBy") (clojure.core/assoc :created-by (deser-recovery-point-creator (clojure.core/get-in letvar140964 ["CreatedBy"]))) (letvar140964 "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-iam-role-arn (clojure.core/get-in letvar140964 ["IamRoleArn"]))) (letvar140964 "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (clojure.core/get-in letvar140964 ["BackupVaultName"]))) (letvar140964 "ResourceType") (clojure.core/assoc :resource-type (deser-resource-type (clojure.core/get-in letvar140964 ["ResourceType"]))) (letvar140964 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140964 ["CreationDate"]))) (letvar140964 "ResourceArn") (clojure.core/assoc :resource-arn (deser-arn (clojure.core/get-in letvar140964 ["ResourceArn"]))) (letvar140964 "Lifecycle") (clojure.core/assoc :lifecycle (deser-lifecycle (clojure.core/get-in letvar140964 ["Lifecycle"]))) (letvar140964 "StorageClass") (clojure.core/assoc :storage-class (deser-storage-class (clojure.core/get-in letvar140964 ["StorageClass"]))) (letvar140964 "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (clojure.core/get-in letvar140964 ["RecoveryPointArn"]))) (letvar140964 "BackupSizeInBytes") (clojure.core/assoc :backup-size-in-bytes (deser-long (clojure.core/get-in letvar140964 ["BackupSizeInBytes"]))) (letvar140964 "CalculatedLifecycle") (clojure.core/assoc :calculated-lifecycle (deser-calculated-lifecycle (clojure.core/get-in letvar140964 ["CalculatedLifecycle"])))))))

(clojure.core/defn- response-list-recovery-points-by-resource-output ([input] (response-list-recovery-points-by-resource-output nil input)) ([resultWrapper140966 input] (clojure.core/let [rawinput140965 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140967 {"NextToken" (rawinput140965 "NextToken"), "RecoveryPoints" (rawinput140965 "RecoveryPoints")}] (clojure.core/cond-> {} (letvar140967 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140967 ["NextToken"]))) (letvar140967 "RecoveryPoints") (clojure.core/assoc :recovery-points (deser-recovery-point-by-resource-list (clojure.core/get-in letvar140967 ["RecoveryPoints"])))))))

(clojure.core/defn- response-invalid-parameter-value-exception ([input] (response-invalid-parameter-value-exception nil input)) ([resultWrapper140969 input] (clojure.core/let [rawinput140968 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140970 {"Code" (rawinput140968 "Code"), "Message" (rawinput140968 "Message"), "Type" (rawinput140968 "Type"), "Context" (rawinput140968 "Context")}] (clojure.core/cond-> {} (letvar140970 "Code") (clojure.core/assoc :code (deserstring (clojure.core/get-in letvar140970 ["Code"]))) (letvar140970 "Message") (clojure.core/assoc :message (deserstring (clojure.core/get-in letvar140970 ["Message"]))) (letvar140970 "Type") (clojure.core/assoc :type (deserstring (clojure.core/get-in letvar140970 ["Type"]))) (letvar140970 "Context") (clojure.core/assoc :context (deserstring (clojure.core/get-in letvar140970 ["Context"])))))))

(clojure.core/defn- response-get-recovery-point-restore-metadata-output ([input] (response-get-recovery-point-restore-metadata-output nil input)) ([resultWrapper140972 input] (clojure.core/let [rawinput140971 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140973 {"BackupVaultArn" (rawinput140971 "BackupVaultArn"), "RecoveryPointArn" (rawinput140971 "RecoveryPointArn"), "RestoreMetadata" (rawinput140971 "RestoreMetadata")}] (clojure.core/cond-> {} (letvar140973 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140973 ["BackupVaultArn"]))) (letvar140973 "RecoveryPointArn") (clojure.core/assoc :recovery-point-arn (deser-arn (clojure.core/get-in letvar140973 ["RecoveryPointArn"]))) (letvar140973 "RestoreMetadata") (clojure.core/assoc :restore-metadata (deser-metadata (clojure.core/get-in letvar140973 ["RestoreMetadata"])))))))

(clojure.core/defn- response-list-backup-jobs-output ([input] (response-list-backup-jobs-output nil input)) ([resultWrapper140975 input] (clojure.core/let [rawinput140974 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140976 {"BackupJobs" (rawinput140974 "BackupJobs"), "NextToken" (rawinput140974 "NextToken")}] (clojure.core/cond-> {} (letvar140976 "BackupJobs") (clojure.core/assoc :backup-jobs (deser-backup-jobs-list (clojure.core/get-in letvar140976 ["BackupJobs"]))) (letvar140976 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140976 ["NextToken"])))))))

(clojure.core/defn- response-describe-backup-vault-output ([input] (response-describe-backup-vault-output nil input)) ([resultWrapper140978 input] (clojure.core/let [rawinput140977 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140979 {"BackupVaultName" (rawinput140977 "BackupVaultName"), "BackupVaultArn" (rawinput140977 "BackupVaultArn"), "EncryptionKeyArn" (rawinput140977 "EncryptionKeyArn"), "CreationDate" (rawinput140977 "CreationDate"), "CreatorRequestId" (rawinput140977 "CreatorRequestId"), "NumberOfRecoveryPoints" (rawinput140977 "NumberOfRecoveryPoints")}] (clojure.core/cond-> {} (letvar140979 "BackupVaultName") (clojure.core/assoc :backup-vault-name (deserstring (clojure.core/get-in letvar140979 ["BackupVaultName"]))) (letvar140979 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140979 ["BackupVaultArn"]))) (letvar140979 "EncryptionKeyArn") (clojure.core/assoc :encryption-key-arn (deser-arn (clojure.core/get-in letvar140979 ["EncryptionKeyArn"]))) (letvar140979 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140979 ["CreationDate"]))) (letvar140979 "CreatorRequestId") (clojure.core/assoc :creator-request-id (deserstring (clojure.core/get-in letvar140979 ["CreatorRequestId"]))) (letvar140979 "NumberOfRecoveryPoints") (clojure.core/assoc :number-of-recovery-points (deserlong (clojure.core/get-in letvar140979 ["NumberOfRecoveryPoints"])))))))

(clojure.core/defn- response-list-tags-output ([input] (response-list-tags-output nil input)) ([resultWrapper140981 input] (clojure.core/let [rawinput140980 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140982 {"NextToken" (rawinput140980 "NextToken"), "Tags" (rawinput140980 "Tags")}] (clojure.core/cond-> {} (letvar140982 "NextToken") (clojure.core/assoc :next-token (deserstring (clojure.core/get-in letvar140982 ["NextToken"]))) (letvar140982 "Tags") (clojure.core/assoc :tags (deser-tags (clojure.core/get-in letvar140982 ["Tags"])))))))

(clojure.core/defn- response-create-backup-vault-output ([input] (response-create-backup-vault-output nil input)) ([resultWrapper140984 input] (clojure.core/let [rawinput140983 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140985 {"BackupVaultName" (rawinput140983 "BackupVaultName"), "BackupVaultArn" (rawinput140983 "BackupVaultArn"), "CreationDate" (rawinput140983 "CreationDate")}] (clojure.core/cond-> {} (letvar140985 "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (clojure.core/get-in letvar140985 ["BackupVaultName"]))) (letvar140985 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140985 ["BackupVaultArn"]))) (letvar140985 "CreationDate") (clojure.core/assoc :creation-date (desertimestamp (clojure.core/get-in letvar140985 ["CreationDate"])))))))

(clojure.core/defn- response-get-backup-vault-access-policy-output ([input] (response-get-backup-vault-access-policy-output nil input)) ([resultWrapper140987 input] (clojure.core/let [rawinput140986 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar140988 {"BackupVaultName" (rawinput140986 "BackupVaultName"), "BackupVaultArn" (rawinput140986 "BackupVaultArn"), "Policy" (rawinput140986 "Policy")}] (clojure.core/cond-> {} (letvar140988 "BackupVaultName") (clojure.core/assoc :backup-vault-name (deser-backup-vault-name (clojure.core/get-in letvar140988 ["BackupVaultName"]))) (letvar140988 "BackupVaultArn") (clojure.core/assoc :backup-vault-arn (deser-arn (clojure.core/get-in letvar140988 ["BackupVaultArn"]))) (letvar140988 "Policy") (clojure.core/assoc :policy (deser-iam-policy (clojure.core/get-in letvar140988 ["Policy"])))))))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-output/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-output/backup-plan-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-output/version-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/create-backup-plan-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.create-backup-plan-output/backup-plan-id :portkey.aws.backup.-2018-11-15.create-backup-plan-output/backup-plan-arn :portkey.aws.backup.-2018-11-15.create-backup-plan-output/creation-date :portkey.aws.backup.-2018-11-15.create-backup-plan-output/version-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-vault-list-member/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-vault-list-member/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-vault-list-member/encryption-key-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-vault-list-member/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-vault-list-member/number-of-recovery-points (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-vault-list-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.backup-vault-list-member/backup-vault-arn :portkey.aws.backup.-2018-11-15.backup-vault-list-member/creation-date :portkey.aws.backup.-2018-11-15.backup-vault-list-member/encryption-key-arn :portkey.aws.backup.-2018-11-15.backup-vault-list-member/creator-request-id :portkey.aws.backup.-2018-11-15.backup-vault-list-member/number-of-recovery-points]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-of-tags (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/condition))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/status-message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/expected-completion-time-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/status (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/restore-job-status))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/created-resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/restore-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/percent-done (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-restore-job-output/backup-size-in-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-restore-job-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.describe-restore-job-output/completion-date :portkey.aws.backup.-2018-11-15.describe-restore-job-output/status-message :portkey.aws.backup.-2018-11-15.describe-restore-job-output/expected-completion-time-minutes :portkey.aws.backup.-2018-11-15.describe-restore-job-output/status :portkey.aws.backup.-2018-11-15.describe-restore-job-output/iam-role-arn :portkey.aws.backup.-2018-11-15.describe-restore-job-output/created-resource-arn :portkey.aws.backup.-2018-11-15.describe-restore-job-output/restore-job-id :portkey.aws.backup.-2018-11-15.describe-restore-job-output/creation-date :portkey.aws.backup.-2018-11-15.describe-restore-job-output/percent-done :portkey.aws.backup.-2018-11-15.describe-restore-job-output/recovery-point-arn :portkey.aws.backup.-2018-11-15.describe-restore-job-output/backup-size-in-bytes]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/iam-role-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plan-versions-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plan-versions-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-plan-versions-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.list-backup-plan-versions-input/backup-plan-id] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-plan-versions-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.already-exists-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.already-exists-exception/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.already-exists-exception/arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.already-exists-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.already-exists-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.already-exists-exception/code :portkey.aws.backup.-2018-11-15.already-exists-exception/message :portkey.aws.backup.-2018-11-15.already-exists-exception/creator-request-id :portkey.aws.backup.-2018-11-15.already-exists-exception/arn :portkey.aws.backup.-2018-11-15.already-exists-exception/type :portkey.aws.backup.-2018-11-15.already-exists-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-plan-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-plan-version (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-rule-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/recovery-point-creator (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-plan-id :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-plan-arn :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-plan-version :portkey.aws.backup.-2018-11-15.recovery-point-creator/backup-rule-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-input/backup-vault-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-backup-vault-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.describe-backup-vault-input/backup-vault-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-vault-input/backup-vault-tags (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/tags))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-vault-input/encryption-key-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-vault-input/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/create-backup-vault-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un [:portkey.aws.backup.-2018-11-15.create-backup-vault-input/backup-vault-tags :portkey.aws.backup.-2018-11-15.create-backup-vault-input/encryption-key-arn :portkey.aws.backup.-2018-11-15.create-backup-vault-input/creator-request-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/bytes-transferred (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/backup-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/status-message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/created-by (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-creator))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/start-by (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/state (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-job-state))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/percent-done (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/backup-size-in-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-output/expected-completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-backup-job-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.describe-backup-job-output/bytes-transferred :portkey.aws.backup.-2018-11-15.describe-backup-job-output/backup-job-id :portkey.aws.backup.-2018-11-15.describe-backup-job-output/completion-date :portkey.aws.backup.-2018-11-15.describe-backup-job-output/status-message :portkey.aws.backup.-2018-11-15.describe-backup-job-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.describe-backup-job-output/created-by :portkey.aws.backup.-2018-11-15.describe-backup-job-output/iam-role-arn :portkey.aws.backup.-2018-11-15.describe-backup-job-output/start-by :portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15/resource-type :portkey.aws.backup.-2018-11-15.describe-backup-job-output/creation-date :portkey.aws.backup.-2018-11-15.describe-backup-job-output/resource-arn :portkey.aws.backup.-2018-11-15.describe-backup-job-output/state :portkey.aws.backup.-2018-11-15.describe-backup-job-output/percent-done :portkey.aws.backup.-2018-11-15.describe-backup-job-output/recovery-point-arn :portkey.aws.backup.-2018-11-15.describe-backup-job-output/backup-size-in-bytes :portkey.aws.backup.-2018-11-15.describe-backup-job-output/expected-completion-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-selections-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-selections-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-selections-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.list-backup-selections-input/backup-plan-id] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-selections-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plan-templates-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-plan-templates-list-member))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-from-template-output/backup-plan-document (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-plan))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-plan-from-template-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.get-backup-plan-from-template-output/backup-plan-document]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-output/recovery-points (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-by-backup-vault-list))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-recovery-points-by-backup-vault-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-output/next-token :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-output/recovery-points]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-request-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-request-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-request-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-request-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/invalid-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.invalid-request-exception/code :portkey.aws.backup.-2018-11-15.invalid-request-exception/message :portkey.aws.backup.-2018-11-15.invalid-request-exception/type :portkey.aws.backup.-2018-11-15.invalid-request-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-protected-resources-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-protected-resources-input (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-protected-resources-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-protected-resource-input/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-protected-resource-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.describe-protected-resource-input/resource-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-recovery-point-input/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-recovery-point-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.delete-recovery-point-input/recovery-point-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-recovery-point-lifecycle-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-recovery-point-lifecycle-output/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/update-recovery-point-lifecycle-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.update-recovery-point-lifecycle-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.update-recovery-point-lifecycle-output/recovery-point-arn :portkey.aws.backup.-2018-11-15/lifecycle :portkey.aws.backup.-2018-11-15/calculated-lifecycle]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-rule-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21078__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9\-\_\.]{1,50}$" s__21078__auto__))))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-backup-plan-output/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-backup-plan-output/backup-plan-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-backup-plan-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-backup-plan-output/version-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/update-backup-plan-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.update-backup-plan-output/backup-plan-id :portkey.aws.backup.-2018-11-15.update-backup-plan-output/backup-plan-arn :portkey.aws.backup.-2018-11-15.update-backup-plan-output/creation-date :portkey.aws.backup.-2018-11-15.update-backup-plan-output/version-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.export-backup-plan-template-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/export-backup-plan-template-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.export-backup-plan-template-input/backup-plan-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-input/version-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-plan-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.get-backup-plan-input/backup-plan-id] :opt-un [:portkey.aws.backup.-2018-11-15.get-backup-plan-input/version-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-backup-vault-notifications-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.export-backup-plan-template-output/backup-plan-template-json (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/export-backup-plan-template-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.export-backup-plan-template-output/backup-plan-template-json]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-selection-output/selection-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-selection-output/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-selection-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-selection-output/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-selection-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-selection :portkey.aws.backup.-2018-11-15.get-backup-selection-output/selection-id :portkey.aws.backup.-2018-11-15.get-backup-selection-output/backup-plan-id :portkey.aws.backup.-2018-11-15.get-backup-selection-output/creation-date :portkey.aws.backup.-2018-11-15.get-backup-selection-output/creator-request-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/cron-expression (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-rules (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-rule))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-protected-resource-output/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-protected-resource-output/last-backup-time (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-protected-resource-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.describe-protected-resource-output/resource-arn :portkey.aws.backup.-2018-11-15/resource-type :portkey.aws.backup.-2018-11-15.describe-protected-resource-output/last-backup-time]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-vault-events (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-vault-event))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-selection-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-selection-input/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/create-backup-selection-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.create-backup-selection-input/backup-plan-id :portkey.aws.backup.-2018-11-15/backup-selection] :opt-un [:portkey.aws.backup.-2018-11-15.create-backup-selection-input/creator-request-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-restore-jobs-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-restore-jobs-input (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-restore-jobs-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-vault-input/backup-vault-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-backup-vault-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.delete-backup-vault-input/backup-vault-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/start-restore-job-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/restore-job-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/tag-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.tag-resource-input/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/tag-resource-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.tag-resource-input/resource-arn :portkey.aws.backup.-2018-11-15/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/recovery-point-by-resource-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/recovery-point-by-resource))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/tags (clojure.spec.alpha/map-of :portkey.aws.backup.-2018-11-15/tag-key :portkey.aws.backup.-2018-11-15/tag-value))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-input/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-recovery-points-by-resource-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-input/resource-arn] :opt-un [:portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.limit-exceeded-exception/code :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/message :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/type :portkey.aws.backup.-2018-11-15.limit-exceeded-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-vault-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-vault-list-member))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/metadata-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.put-backup-vault-access-policy-input/policy (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-policy))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/put-backup-vault-access-policy-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un [:portkey.aws.backup.-2018-11-15.put-backup-vault-access-policy-input/policy]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-from-json-input/backup-plan-template-json (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-plan-from-json-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.get-backup-plan-from-json-input/backup-plan-template-json] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/resource-arns (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/arn))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-vaults-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-vaults-input (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-vaults-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-resource-type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/resource-type))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-created-before (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-created-after (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-recovery-points-by-backup-vault-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un [:portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/next-token :portkey.aws.backup.-2018-11-15/max-results :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-resource-arn :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-resource-type :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-backup-plan-id :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-created-before :portkey.aws.backup.-2018-11-15.list-recovery-points-by-backup-vault-input/by-created-after]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-plan-from-json-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-plan]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.service-unavailable-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.service-unavailable-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.service-unavailable-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/service-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.service-unavailable-exception/code :portkey.aws.backup.-2018-11-15.service-unavailable-exception/message :portkey.aws.backup.-2018-11-15.service-unavailable-exception/type :portkey.aws.backup.-2018-11-15.service-unavailable-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/recovery-point-status #{"COMPLETED" "EXPIRED" :completed "PARTIAL" :deleting :partial "DELETING" :expired})

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-rules-input (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-rule-input))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-selection-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-selection-input/selection-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-selection-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.get-backup-selection-input/backup-plan-id :portkey.aws.backup.-2018-11-15.get-backup-selection-input/selection-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selections-list-member/selection-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selections-list-member/selection-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-selection-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selections-list-member/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selections-list-member/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selections-list-member/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selections-list-member/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-selections-list-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.backup-selections-list-member/selection-id :portkey.aws.backup.-2018-11-15.backup-selections-list-member/selection-name :portkey.aws.backup.-2018-11-15.backup-selections-list-member/backup-plan-id :portkey.aws.backup.-2018-11-15.backup-selections-list-member/creation-date :portkey.aws.backup.-2018-11-15.backup-selections-list-member/creator-request-id :portkey.aws.backup.-2018-11-15.backup-selections-list-member/iam-role-arn]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/condition-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-recovery-point-lifecycle-input/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/update-recovery-point-lifecycle-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.update-recovery-point-lifecycle-input/recovery-point-arn] :opt-un [:portkey.aws.backup.-2018-11-15/lifecycle]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-restore-jobs-output/restore-jobs (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/restore-jobs-list))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-restore-jobs-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-restore-jobs-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-restore-jobs-output/restore-jobs :portkey.aws.backup.-2018-11-15.list-restore-jobs-output/next-token]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/metadata-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-selections-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-selections-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-selections-output/next-token :portkey.aws.backup.-2018-11-15/backup-selections-list]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.dependency-failure-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.dependency-failure-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.dependency-failure-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.dependency-failure-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/dependency-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.dependency-failure-exception/code :portkey.aws.backup.-2018-11-15.dependency-failure-exception/message :portkey.aws.backup.-2018-11-15.dependency-failure-exception/type :portkey.aws.backup.-2018-11-15.dependency-failure-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-vault-event #{"RESTORE_JOB_STARTED" "BACKUP_PLAN_CREATED" :backup-job-started "BACKUP_JOB_STARTED" :restore-job-started "RESTORE_JOB_COMPLETED" :backup-plan-created "BACKUP_JOB_COMPLETED" "BACKUP_PLAN_MODIFIED" :recovery-point-modified "RECOVERY_POINT_MODIFIED" :backup-job-completed :backup-plan-modified :restore-job-completed})

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-input/backup-plan (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-plan-input))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-input/backup-plan-tags (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/tags))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-plan-input/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/create-backup-plan-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.create-backup-plan-input/backup-plan] :opt-un [:portkey.aws.backup.-2018-11-15.create-backup-plan-input/backup-plan-tags :portkey.aws.backup.-2018-11-15.create-backup-plan-input/creator-request-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-vault-access-policy-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/string))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-supported-resource-types-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/resource-types]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.resource-not-found-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.resource-not-found-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.resource-not-found-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/resource-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.resource-not-found-exception/code :portkey.aws.backup.-2018-11-15.resource-not-found-exception/message :portkey.aws.backup.-2018-11-15.resource-not-found-exception/type :portkey.aws.backup.-2018-11-15.resource-not-found-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-output/backup-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-output/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/start-backup-job-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.start-backup-job-output/backup-job-id :portkey.aws.backup.-2018-11-15.start-backup-job-output/recovery-point-arn :portkey.aws.backup.-2018-11-15.start-backup-job-output/creation-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plan/rules (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-rules))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plan (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-plan-name :portkey.aws.backup.-2018-11-15.backup-plan/rules] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-job-state #{"COMPLETED" "EXPIRED" :pending :completed :aborted :created "PENDING" :running "ABORTING" "FAILED" :aborting :expired "ABORTED" :failed "RUNNING" "CREATED"})

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-vault-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21078__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9\-\_\.]{1,50}$" s__21078__auto__))))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/backup-plan-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/version-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/deletion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-output/last-execution-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-plan-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-plan :portkey.aws.backup.-2018-11-15.get-backup-plan-output/backup-plan-id :portkey.aws.backup.-2018-11-15.get-backup-plan-output/backup-plan-arn :portkey.aws.backup.-2018-11-15.get-backup-plan-output/version-id :portkey.aws.backup.-2018-11-15.get-backup-plan-output/creator-request-id :portkey.aws.backup.-2018-11-15.get-backup-plan-output/creation-date :portkey.aws.backup.-2018-11-15.get-backup-plan-output/deletion-date :portkey.aws.backup.-2018-11-15.get-backup-plan-output/last-execution-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-vaults-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-vaults-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-vault-list :portkey.aws.backup.-2018-11-15.list-backup-vaults-output/next-token]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/tag-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-plan-from-template-input/backup-plan-template-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-plan-from-template-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.get-backup-plan-from-template-input/backup-plan-template-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plan-versions-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-plans-list-member))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-restore-job-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/restore-job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.untag-resource-input/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/untag-resource-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.untag-resource-input/resource-arn :portkey.aws.backup.-2018-11-15/tag-key-list] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/condition-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/restore-job-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-backup-vault-access-policy-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/condition-type #{"STRINGEQUALS" :stringequals})

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plans-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plans-input/include-deleted (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/boolean))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-plans-input (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-plans-input/next-token :portkey.aws.backup.-2018-11-15/max-results :portkey.aws.backup.-2018-11-15.list-backup-plans-input/include-deleted]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/last-restore-time (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/is-encrypted (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/boolean))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/encryption-key-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/status (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-status))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/created-by (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-creator))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/backup-size-in-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/recovery-point-by-backup-vault (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/last-restore-time :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/completion-date :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/is-encrypted :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/backup-vault-arn :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/encryption-key-arn :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/status :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/created-by :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/iam-role-arn :portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15/resource-type :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/creation-date :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/resource-arn :portkey.aws.backup.-2018-11-15/lifecycle :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/recovery-point-arn :portkey.aws.backup.-2018-11-15.recovery-point-by-backup-vault/backup-size-in-bytes :portkey.aws.backup.-2018-11-15/calculated-lifecycle]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/backup-plan-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/deletion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/version-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plans-list-member/last-execution-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plans-list-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.backup-plans-list-member/backup-plan-arn :portkey.aws.backup.-2018-11-15.backup-plans-list-member/backup-plan-id :portkey.aws.backup.-2018-11-15.backup-plans-list-member/creation-date :portkey.aws.backup.-2018-11-15.backup-plans-list-member/deletion-date :portkey.aws.backup.-2018-11-15.backup-plans-list-member/version-id :portkey.aws.backup.-2018-11-15/backup-plan-name :portkey.aws.backup.-2018-11-15.backup-plans-list-member/creator-request-id :portkey.aws.backup.-2018-11-15.backup-plans-list-member/last-execution-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plan-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plans-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-plans-list-member))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plan-templates-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-plan-templates-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-plan-templates-output/next-token :portkey.aws.backup.-2018-11-15/backup-plan-templates-list]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/resource-type (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21078__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9\-\_\.]{1,50}$" s__21078__auto__))))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/backup-plan-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/deletion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/version-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-backup-plan-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.delete-backup-plan-output/backup-plan-id :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/backup-plan-arn :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/deletion-date :portkey.aws.backup.-2018-11-15.delete-backup-plan-output/version-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-input/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-input/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-input/idempotency-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-input/start-window-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/window-minutes))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-input/complete-window-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/window-minutes))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-backup-job-input/recovery-point-tags (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/tags))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/start-backup-job-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.start-backup-job-input/resource-arn :portkey.aws.backup.-2018-11-15.start-backup-job-input/iam-role-arn] :opt-un [:portkey.aws.backup.-2018-11-15.start-backup-job-input/idempotency-token :portkey.aws.backup.-2018-11-15.start-backup-job-input/start-window-minutes :portkey.aws.backup.-2018-11-15.start-backup-job-input/complete-window-minutes :portkey.aws.backup.-2018-11-15/lifecycle :portkey.aws.backup.-2018-11-15.start-backup-job-input/recovery-point-tags]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-backup-plan-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.update-backup-plan-input/backup-plan (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-plan-input))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/update-backup-plan-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.update-backup-plan-input/backup-plan-id :portkey.aws.backup.-2018-11-15.update-backup-plan-input/backup-plan] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plan-templates-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-plan-templates-input (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-plan-templates-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/status (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-status))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/encryption-key-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/backup-size-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/recovery-point-by-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.recovery-point-by-resource/recovery-point-arn :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/creation-date :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/status :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/encryption-key-arn :portkey.aws.backup.-2018-11-15.recovery-point-by-resource/backup-size-bytes :portkey.aws.backup.-2018-11-15/backup-vault-name]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plans-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-plans-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-plans-output/next-token :portkey.aws.backup.-2018-11-15/backup-plans-list]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/bytes-transferred (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/backup-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/status-message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/created-by (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-creator))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/start-by (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/state (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-job-state))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/percent-done (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/backup-size-in-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-job/expected-completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-job (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.backup-job/bytes-transferred :portkey.aws.backup.-2018-11-15.backup-job/backup-job-id :portkey.aws.backup.-2018-11-15.backup-job/completion-date :portkey.aws.backup.-2018-11-15.backup-job/status-message :portkey.aws.backup.-2018-11-15.backup-job/backup-vault-arn :portkey.aws.backup.-2018-11-15.backup-job/created-by :portkey.aws.backup.-2018-11-15.backup-job/iam-role-arn :portkey.aws.backup.-2018-11-15.backup-job/start-by :portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15/resource-type :portkey.aws.backup.-2018-11-15.backup-job/creation-date :portkey.aws.backup.-2018-11-15.backup-job/resource-arn :portkey.aws.backup.-2018-11-15.backup-job/state :portkey.aws.backup.-2018-11-15.backup-job/percent-done :portkey.aws.backup.-2018-11-15.backup-job/recovery-point-arn :portkey.aws.backup.-2018-11-15.backup-job/backup-size-in-bytes :portkey.aws.backup.-2018-11-15.backup-job/expected-completion-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.put-backup-vault-notifications-input/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/put-backup-vault-notifications-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.put-backup-vault-notifications-input/sns-topic-arn :portkey.aws.backup.-2018-11-15/backup-vault-events] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-plan-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-backup-plan-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.delete-backup-plan-input/backup-plan-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/protected-resources-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/protected-resource))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/metadata (clojure.spec.alpha/map-of :portkey.aws.backup.-2018-11-15/metadata-key :portkey.aws.backup.-2018-11-15/metadata-value))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-selection-output/selection-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-selection-output/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-selection-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/create-backup-selection-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.create-backup-selection-output/selection-id :portkey.aws.backup.-2018-11-15.create-backup-selection-output/backup-plan-id :portkey.aws.backup.-2018-11-15.create-backup-selection-output/creation-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-selection-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21078__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9\-\_\.]{1,50}$" s__21078__auto__))))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plan-input/rules (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-rules-input))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plan-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-plan-name :portkey.aws.backup.-2018-11-15.backup-plan-input/rules] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/max-results (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/condition (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/condition-type :portkey.aws.backup.-2018-11-15/condition-key :portkey.aws.backup.-2018-11-15/condition-value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.stop-backup-job-input/backup-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/stop-backup-job-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.stop-backup-job-input/backup-job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-input/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-recovery-point-restore-metadata-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-input/recovery-point-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-vault-notifications-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-vault-notifications-output/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-vault-notifications-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.get-backup-vault-notifications-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.get-backup-vault-notifications-output/sns-topic-arn :portkey.aws.backup.-2018-11-15/backup-vault-events]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/resource-types (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/resource-type))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-plan-versions-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-plan-versions-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-plan-versions-output/next-token :portkey.aws.backup.-2018-11-15/backup-plan-versions-list]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-input/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-recovery-point-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.describe-recovery-point-input/recovery-point-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-vault-notifications-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15/backup-vault-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-restore-job-input/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-restore-job-input/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.start-restore-job-input/idempotency-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/start-restore-job-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.start-restore-job-input/recovery-point-arn :portkey.aws.backup.-2018-11-15/metadata :portkey.aws.backup.-2018-11-15.start-restore-job-input/iam-role-arn] :opt-un [:portkey.aws.backup.-2018-11-15.start-restore-job-input/idempotency-token :portkey.aws.backup.-2018-11-15/resource-type]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/code :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/message :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/type :portkey.aws.backup.-2018-11-15.missing-parameter-value-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-protected-resources-output/results (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/protected-resources-list))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-protected-resources-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-protected-resources-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-protected-resources-output/results :portkey.aws.backup.-2018-11-15.list-protected-resources-output/next-token]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-state (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-job-state))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-backup-vault-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-vault-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-created-before (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-created-after (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-resource-type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/resource-type))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-jobs-input (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-jobs-input/next-token :portkey.aws.backup.-2018-11-15/max-results :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-resource-arn :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-state :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-backup-vault-name :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-created-before :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-created-after :portkey.aws.backup.-2018-11-15.list-backup-jobs-input/by-resource-type]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.lifecycle/move-to-cold-storage-after-days (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.lifecycle/delete-after-days (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/lifecycle (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.lifecycle/move-to-cold-storage-after-days :portkey.aws.backup.-2018-11-15.lifecycle/delete-after-days]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-selections-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-selections-list-member))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/storage-class #{:deleted "COLD" "WARM" :warm :cold "DELETED"})

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/recovery-point-by-backup-vault-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/recovery-point-by-backup-vault))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/last-restore-time (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/is-encrypted (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/boolean))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/encryption-key-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/status (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-status))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/created-by (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-creator))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/backup-size-in-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-recovery-point-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.describe-recovery-point-output/last-restore-time :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/completion-date :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/is-encrypted :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/encryption-key-arn :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/status :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/created-by :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/iam-role-arn :portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15/resource-type :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/creation-date :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/resource-arn :portkey.aws.backup.-2018-11-15/lifecycle :portkey.aws.backup.-2018-11-15/storage-class :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/recovery-point-arn :portkey.aws.backup.-2018-11-15.describe-recovery-point-output/backup-size-in-bytes :portkey.aws.backup.-2018-11-15/calculated-lifecycle]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-output/recovery-points (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/recovery-point-by-resource-list))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-recovery-points-by-resource-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-output/next-token :portkey.aws.backup.-2018-11-15.list-recovery-points-by-resource-output/recovery-points]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selection/selection-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-selection-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selection/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-selection/resources (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/resource-arns))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-selection (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.backup-selection/selection-name :portkey.aws.backup.-2018-11-15.backup-selection/iam-role-arn] :opt-un [:portkey.aws.backup.-2018-11-15.backup-selection/resources :portkey.aws.backup.-2018-11-15/list-of-tags]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/rule-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-rule-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/target-backup-vault-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-vault-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/schedule-expression (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/cron-expression))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/start-window-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/window-minutes))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/completion-window-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/window-minutes))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/recovery-point-tags (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/tags))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule/rule-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-rule (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.backup-rule/rule-name :portkey.aws.backup.-2018-11-15.backup-rule/target-backup-vault-name] :opt-un [:portkey.aws.backup.-2018-11-15.backup-rule/schedule-expression :portkey.aws.backup.-2018-11-15.backup-rule/start-window-minutes :portkey.aws.backup.-2018-11-15.backup-rule/completion-window-minutes :portkey.aws.backup.-2018-11-15/lifecycle :portkey.aws.backup.-2018-11-15.backup-rule/recovery-point-tags :portkey.aws.backup.-2018-11-15.backup-rule/rule-id]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-selection-input/backup-plan-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.delete-backup-selection-input/selection-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/delete-backup-selection-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.delete-backup-selection-input/backup-plan-id :portkey.aws.backup.-2018-11-15.delete-backup-selection-input/selection-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/code (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/type (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/context (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/code :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/message :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/type :portkey.aws.backup.-2018-11-15.invalid-parameter-value-exception/context]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-output/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-output/restore-metadata (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/metadata))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-recovery-point-restore-metadata-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-output/recovery-point-arn :portkey.aws.backup.-2018-11-15.get-recovery-point-restore-metadata-output/restore-metadata]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-output/backup-jobs (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-jobs-list))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-backup-jobs-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-backup-jobs-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-backup-jobs-output/backup-jobs :portkey.aws.backup.-2018-11-15.list-backup-jobs-output/next-token]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/iam-policy (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/restore-jobs-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/restore-jobs-list-member))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-tags-input/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-tags-input/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-tags-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.list-tags-input/resource-arn] :opt-un [:portkey.aws.backup.-2018-11-15.list-tags-input/next-token :portkey.aws.backup.-2018-11-15/max-results]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/backup-vault-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/encryption-key-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/creator-request-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/number-of-recovery-points (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-backup-vault-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.describe-backup-vault-output/backup-vault-name :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/encryption-key-arn :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/creation-date :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/creator-request-id :portkey.aws.backup.-2018-11-15.describe-backup-vault-output/number-of-recovery-points]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.list-tags-output/next-token (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/list-tags-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.list-tags-output/next-token :portkey.aws.backup.-2018-11-15/tags]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/restore-job-status #{"COMPLETED" :pending :completed :aborted "PENDING" :running "FAILED" "ABORTED" :failed "RUNNING"})

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.describe-backup-job-input/backup-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/describe-backup-job-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.describe-backup-job-input/backup-job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/window-minutes clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-vault-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.create-backup-vault-output/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/create-backup-vault-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.create-backup-vault-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.create-backup-vault-output/creation-date]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-vault-access-policy-output/backup-vault-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.get-backup-vault-access-policy-output/policy (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-policy))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/get-backup-vault-access-policy-output (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15/backup-vault-name :portkey.aws.backup.-2018-11-15.get-backup-vault-access-policy-output/backup-vault-arn :portkey.aws.backup.-2018-11-15.get-backup-vault-access-policy-output/policy]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-jobs-list (clojure.spec.alpha/coll-of :portkey.aws.backup.-2018-11-15/backup-job))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.protected-resource/resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.protected-resource/last-backup-time (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/protected-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.protected-resource/resource-arn :portkey.aws.backup.-2018-11-15/resource-type :portkey.aws.backup.-2018-11-15.protected-resource/last-backup-time]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule-input/rule-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-rule-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule-input/target-backup-vault-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/backup-vault-name))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule-input/schedule-expression (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/cron-expression))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule-input/start-window-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/window-minutes))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule-input/completion-window-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/window-minutes))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-rule-input/recovery-point-tags (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/tags))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-rule-input (clojure.spec.alpha/keys :req-un [:portkey.aws.backup.-2018-11-15.backup-rule-input/rule-name :portkey.aws.backup.-2018-11-15.backup-rule-input/target-backup-vault-name] :opt-un [:portkey.aws.backup.-2018-11-15.backup-rule-input/schedule-expression :portkey.aws.backup.-2018-11-15.backup-rule-input/start-window-minutes :portkey.aws.backup.-2018-11-15.backup-rule-input/completion-window-minutes :portkey.aws.backup.-2018-11-15/lifecycle :portkey.aws.backup.-2018-11-15.backup-rule-input/recovery-point-tags]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.calculated-lifecycle/move-to-cold-storage-at (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.calculated-lifecycle/delete-at (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/calculated-lifecycle (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.calculated-lifecycle/move-to-cold-storage-at :portkey.aws.backup.-2018-11-15.calculated-lifecycle/delete-at]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plan-templates-list-member/backup-plan-template-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.backup-plan-templates-list-member/backup-plan-template-name (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/backup-plan-templates-list-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.backup-plan-templates-list-member/backup-plan-template-id :portkey.aws.backup.-2018-11-15.backup-plan-templates-list-member/backup-plan-template-name]))

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/completion-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/status-message (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/expected-completion-time-minutes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/status (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/restore-job-status))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/iam-role-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/iam-role-arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/created-resource-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/restore-job-id (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/creation-date (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/timestamp))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/percent-done (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/string))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/recovery-point-arn (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/arn))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/backup-size-in-bytes (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/long))
(clojure.spec.alpha/def :portkey.aws.backup.-2018-11-15/restore-jobs-list-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.backup.-2018-11-15.restore-jobs-list-member/completion-date :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/status-message :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/expected-completion-time-minutes :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/status :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/iam-role-arn :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/created-resource-arn :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/restore-job-id :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/creation-date :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/percent-done :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/recovery-point-arn :portkey.aws.backup.-2018-11-15.restore-jobs-list-member/backup-size-in-bytes]))

(clojure.core/defn tag-resource "Assigns a set of key-value pairs to a recovery point, backup plan, or backup\nvault identified by an Amazon Resource Name (ARN)." ([tag-resource-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-tag-resource-input tag-resource-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resourceArn}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/tag-resource-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "LimitExceededException" :portkey.aws.backup.-2018-11-15/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/tag-resource-input) :ret clojure.core/true?)

(clojure.core/defn create-backup-vault "Creates a logical container where backups are stored. A CreateBackupVault\nrequest includes a name, optionally one or more resource tags, an encryption\nkey, and a request ID.\n Sensitive data, such as passport numbers, should not be included the name of a\nbackup vault." ([create-backup-vault-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-backup-vault-input create-backup-vault-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/create-backup-vault-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/create-backup-vault-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBackupVault", :http.request.configuration/output-deser-fn response-create-backup-vault-output, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "LimitExceededException" :portkey.aws.backup.-2018-11-15/limit-exceeded-exception, "AlreadyExistsException" :portkey.aws.backup.-2018-11-15/already-exists-exception}})))))
(clojure.spec.alpha/fdef create-backup-vault :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/create-backup-vault-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/create-backup-vault-output))

(clojure.core/defn get-backup-plan-from-template "Returns the template specified by its templateId as a backup plan." ([get-backup-plan-from-template-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-backup-plan-from-template-input get-backup-plan-from-template-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-backup-plan-from-template-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/template/plans/{templateId}/toPlan", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-backup-plan-from-template-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBackupPlanFromTemplate", :http.request.configuration/output-deser-fn response-get-backup-plan-from-template-output, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef get-backup-plan-from-template :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-backup-plan-from-template-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-backup-plan-from-template-output))

(clojure.core/defn put-backup-vault-notifications "Turns on notifications on a backup vault for the specified topic and events." ([put-backup-vault-notifications-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-put-backup-vault-notifications-input put-backup-vault-notifications-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/notification-configuration", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/put-backup-vault-notifications-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutBackupVaultNotifications", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef put-backup-vault-notifications :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/put-backup-vault-notifications-input) :ret clojure.core/true?)

(clojure.core/defn get-supported-resource-types "Returns the AWS resource types supported by AWS Backup." ([] (get-supported-resource-types {})) ([_] (clojure.core/let [request-function-result__22119__auto__ {}] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-supported-resource-types-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/supported-resource-types", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec nil, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSupportedResourceTypes", :http.request.configuration/output-deser-fn response-get-supported-resource-types-output, :http.request.spec/error-spec {"ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-supported-resource-types :args clojure.core/empty? :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-supported-resource-types-output))

(clojure.core/defn get-recovery-point-restore-metadata "Returns two sets of metadata key-value pairs. The first set lists the metadata\nthat the recovery point was created with. The second set lists the metadata\nkey-value pairs that are required to restore the recovery point.\n These sets can be the same, or the restore metadata set can contain different\nvalues if the target service to be restored has changed since the recovery point\nwas created and now requires additional or different information in order to be\nrestored." ([get-recovery-point-restore-metadata-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-recovery-point-restore-metadata-input get-recovery-point-restore-metadata-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-recovery-point-restore-metadata-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}/restore-metadata", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-recovery-point-restore-metadata-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRecoveryPointRestoreMetadata", :http.request.configuration/output-deser-fn response-get-recovery-point-restore-metadata-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-recovery-point-restore-metadata :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-recovery-point-restore-metadata-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-recovery-point-restore-metadata-output))

(clojure.core/defn get-backup-selection "Returns selection metadata and a document in JSON format that specifies a list\nof resources that are associated with a backup plan." ([get-backup-selection-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-backup-selection-input get-backup-selection-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-backup-selection-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/selections/{selectionId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-backup-selection-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBackupSelection", :http.request.configuration/output-deser-fn response-get-backup-selection-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-backup-selection :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-backup-selection-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-backup-selection-output))

(clojure.core/defn update-backup-plan "Replaces the body of a saved backup plan identified by its backupPlanId with the\ninput document in JSON format. The new version is uniquely identified by a\nVersionId." ([update-backup-plan-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-update-backup-plan-input update-backup-plan-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/update-backup-plan-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/update-backup-plan-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateBackupPlan", :http.request.configuration/output-deser-fn response-update-backup-plan-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-backup-plan :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/update-backup-plan-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/update-backup-plan-output))

(clojure.core/defn get-backup-plan-from-json "Returns a valid JSON document specifying a backup plan or an error." ([get-backup-plan-from-json-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-backup-plan-from-json-input get-backup-plan-from-json-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-backup-plan-from-json-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/template/json/toPlan", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-backup-plan-from-json-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBackupPlanFromJSON", :http.request.configuration/output-deser-fn response-get-backup-plan-from-json-output, :http.request.spec/error-spec {"LimitExceededException" :portkey.aws.backup.-2018-11-15/limit-exceeded-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "InvalidRequestException" :portkey.aws.backup.-2018-11-15/invalid-request-exception}})))))
(clojure.spec.alpha/fdef get-backup-plan-from-json :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-backup-plan-from-json-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-backup-plan-from-json-output))

(clojure.core/defn delete-backup-vault "Deletes the backup vault identified by its name. A vault can be deleted only if\nit is empty." ([delete-backup-vault-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-backup-vault-input delete-backup-vault-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/delete-backup-vault-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBackupVault", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "InvalidRequestException" :portkey.aws.backup.-2018-11-15/invalid-request-exception}})))))
(clojure.spec.alpha/fdef delete-backup-vault :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/delete-backup-vault-input) :ret clojure.core/true?)

(clojure.core/defn list-backup-plan-templates "Returns metadata of your saved backup plan templates, including the template ID,\nname, and the creation and deletion dates." ([] (list-backup-plan-templates {})) ([list-backup-plan-templates-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-backup-plan-templates-input list-backup-plan-templates-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-backup-plan-templates-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/template/plans", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-backup-plan-templates-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBackupPlanTemplates", :http.request.configuration/output-deser-fn response-list-backup-plan-templates-output, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-backup-plan-templates :args (clojure.spec.alpha/? :portkey.aws.backup.-2018-11-15/list-backup-plan-templates-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-backup-plan-templates-output))

(clojure.core/defn delete-backup-plan "Deletes a backup plan. A backup plan can only be deleted after all associated\nselections of resources have been deleted. Deleting a backup plan deletes the\ncurrent version of a backup plan. Previous versions, if any, will still exist." ([delete-backup-plan-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-backup-plan-input delete-backup-plan-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/delete-backup-plan-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/delete-backup-plan-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBackupPlan", :http.request.configuration/output-deser-fn response-delete-backup-plan-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "InvalidRequestException" :portkey.aws.backup.-2018-11-15/invalid-request-exception}})))))
(clojure.spec.alpha/fdef delete-backup-plan :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/delete-backup-plan-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/delete-backup-plan-output))

(clojure.core/defn list-backup-plans "Returns metadata of your saved backup plans, including Amazon Resource Names\n(ARNs), plan IDs, creation and deletion dates, version IDs, plan names, and\ncreator request IDs." ([] (list-backup-plans {})) ([list-backup-plans-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-backup-plans-input list-backup-plans-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-backup-plans-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-backup-plans-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBackupPlans", :http.request.configuration/output-deser-fn response-list-backup-plans-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-backup-plans :args (clojure.spec.alpha/? :portkey.aws.backup.-2018-11-15/list-backup-plans-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-backup-plans-output))

(clojure.core/defn list-protected-resources "Returns an array of resources successfully backed up by AWS Backup, including\nthe time the resource was saved, an Amazon Resource Name (ARN) of the resource,\nand a resource type." ([] (list-protected-resources {})) ([list-protected-resources-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-protected-resources-input list-protected-resources-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-protected-resources-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/resources/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-protected-resources-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListProtectedResources", :http.request.configuration/output-deser-fn response-list-protected-resources-output, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-protected-resources :args (clojure.spec.alpha/? :portkey.aws.backup.-2018-11-15/list-protected-resources-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-protected-resources-output))

(clojure.core/defn list-restore-jobs "Returns a list of jobs that AWS Backup initiated to restore a saved resource,\nincluding metadata about the recovery process." ([] (list-restore-jobs {})) ([list-restore-jobs-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-restore-jobs-input list-restore-jobs-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-restore-jobs-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restore-jobs/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-restore-jobs-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListRestoreJobs", :http.request.configuration/output-deser-fn response-list-restore-jobs-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-restore-jobs :args (clojure.spec.alpha/? :portkey.aws.backup.-2018-11-15/list-restore-jobs-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-restore-jobs-output))

(clojure.core/defn list-tags "Returns a list of key-value pairs assigned to a target recovery point, backup\nplan, or backup vault." ([list-tags-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-tags-input list-tags-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-tags-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resourceArn}/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-tags-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTags", :http.request.configuration/output-deser-fn response-list-tags-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-tags :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/list-tags-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-tags-output))

(clojure.core/defn delete-recovery-point "Deletes the recovery point specified by a recovery point ID." ([delete-recovery-point-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-recovery-point-input delete-recovery-point-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/delete-recovery-point-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRecoveryPoint", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "InvalidRequestException" :portkey.aws.backup.-2018-11-15/invalid-request-exception}})))))
(clojure.spec.alpha/fdef delete-recovery-point :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/delete-recovery-point-input) :ret clojure.core/true?)

(clojure.core/defn create-backup-selection "Creates a JSON document that specifies a set of resources to assign to a backup\nplan. Resources can be included by specifying patterns for a ListOfTags and\nselected Resources.\n For example, consider the following patterns:\n * Resources: \"arn:aws:ec2:region:account-id:volume/volume-id\"\n * ConditionKey:\"department\"\n ConditionValue:\"finance\"\n ConditionType:\"StringEquals\"\n * ConditionKey:\"importance\"\n ConditionValue:\"critical\"\n ConditionType:\"StringEquals\"\n Using these patterns would back up all Amazon Elastic Block Store (Amazon EBS)\nvolumes that are tagged as \"department=finance\", \"importance=critical\", in\naddition to an EBS volume with the specified volume Id.\n Resources and conditions are additive in that all resources that match the\npattern are selected. This shouldn't be confused with a logical AND, where all\nconditions must match. The matching patterns are logically 'put together using\nthe OR operator. In other words, all patterns that match are selected for\nbackup." ([create-backup-selection-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-backup-selection-input create-backup-selection-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/create-backup-selection-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/selections/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/create-backup-selection-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBackupSelection", :http.request.configuration/output-deser-fn response-create-backup-selection-output, :http.request.spec/error-spec {"LimitExceededException" :portkey.aws.backup.-2018-11-15/limit-exceeded-exception, "AlreadyExistsException" :portkey.aws.backup.-2018-11-15/already-exists-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-backup-selection :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/create-backup-selection-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/create-backup-selection-output))

(clojure.core/defn update-recovery-point-lifecycle "Sets the transition lifecycle of a recovery point.\n The lifecycle defines when a protected resource is transitioned to cold storage\nand when it expires. AWS Backup transitions and expires backups automatically\naccording to the lifecycle that you define.\n Backups transitioned to cold storage must be stored in cold storage for a\nminimum of 90 days. Therefore, the “expire after days” setting must be 90 days\ngreater than the “transition to cold after days” setting. The “transition to\ncold after days” setting cannot be changed after a backup has been transitioned\nto cold." ([update-recovery-point-lifecycle-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-update-recovery-point-lifecycle-input update-recovery-point-lifecycle-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/update-recovery-point-lifecycle-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/update-recovery-point-lifecycle-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRecoveryPointLifecycle", :http.request.configuration/output-deser-fn response-update-recovery-point-lifecycle-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-recovery-point-lifecycle :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/update-recovery-point-lifecycle-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/update-recovery-point-lifecycle-output))

(clojure.core/defn describe-restore-job "Returns metadata associated with a restore job that is specified by a job ID." ([describe-restore-job-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-restore-job-input describe-restore-job-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/describe-restore-job-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restore-jobs/{restoreJobId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/describe-restore-job-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRestoreJob", :http.request.configuration/output-deser-fn response-describe-restore-job-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "DependencyFailureException" :portkey.aws.backup.-2018-11-15/dependency-failure-exception}})))))
(clojure.spec.alpha/fdef describe-restore-job :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/describe-restore-job-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/describe-restore-job-output))

(clojure.core/defn describe-recovery-point "Returns metadata associated with a recovery point, including ID, status,\nencryption, and lifecycle." ([describe-recovery-point-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-recovery-point-input describe-recovery-point-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/describe-recovery-point-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/describe-recovery-point-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRecoveryPoint", :http.request.configuration/output-deser-fn response-describe-recovery-point-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-recovery-point :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/describe-recovery-point-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/describe-recovery-point-output))

(clojure.core/defn start-restore-job "Recovers the saved resource identified by an Amazon Resource Name (ARN).\n If the resource ARN is included in the request, then the last complete backup\nof that resource is recovered. If the ARN of a recovery point is supplied, then\nthat recovery point is restored." ([start-restore-job-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-start-restore-job-input start-restore-job-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/start-restore-job-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/restore-jobs", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/start-restore-job-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartRestoreJob", :http.request.configuration/output-deser-fn response-start-restore-job-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef start-restore-job :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/start-restore-job-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/start-restore-job-output))

(clojure.core/defn describe-backup-job "Returns metadata associated with creating a backup of a resource." ([describe-backup-job-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-backup-job-input describe-backup-job-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/describe-backup-job-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-jobs/{backupJobId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/describe-backup-job-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeBackupJob", :http.request.configuration/output-deser-fn response-describe-backup-job-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "DependencyFailureException" :portkey.aws.backup.-2018-11-15/dependency-failure-exception}})))))
(clojure.spec.alpha/fdef describe-backup-job :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/describe-backup-job-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/describe-backup-job-output))

(clojure.core/defn put-backup-vault-access-policy "Sets a resource-based policy that is used to manage access permissions on the\ntarget backup vault. Requires a backup vault name and an access policy document\nin JSON format." ([put-backup-vault-access-policy-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-put-backup-vault-access-policy-input put-backup-vault-access-policy-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/access-policy", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/put-backup-vault-access-policy-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutBackupVaultAccessPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef put-backup-vault-access-policy :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/put-backup-vault-access-policy-input) :ret clojure.core/true?)

(clojure.core/defn describe-backup-vault "Returns metadata about a backup vault specified by its name." ([describe-backup-vault-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-backup-vault-input describe-backup-vault-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/describe-backup-vault-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/describe-backup-vault-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeBackupVault", :http.request.configuration/output-deser-fn response-describe-backup-vault-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-backup-vault :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/describe-backup-vault-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/describe-backup-vault-output))

(clojure.core/defn start-backup-job "Starts a job to create a one-time backup of the specified resource." ([start-backup-job-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-start-backup-job-input start-backup-job-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/start-backup-job-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-jobs", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/start-backup-job-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartBackupJob", :http.request.configuration/output-deser-fn response-start-backup-job-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "LimitExceededException" :portkey.aws.backup.-2018-11-15/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef start-backup-job :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/start-backup-job-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/start-backup-job-output))

(clojure.core/defn export-backup-plan-template "Returns the backup plan that is specified by the plan ID as a backup template." ([export-backup-plan-template-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-export-backup-plan-template-input export-backup-plan-template-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/export-backup-plan-template-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/toTemplate/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/export-backup-plan-template-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ExportBackupPlanTemplate", :http.request.configuration/output-deser-fn response-export-backup-plan-template-output, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef export-backup-plan-template :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/export-backup-plan-template-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/export-backup-plan-template-output))

(clojure.core/defn get-backup-vault-notifications "Returns event notifications for the specified backup vault." ([get-backup-vault-notifications-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-backup-vault-notifications-input get-backup-vault-notifications-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-backup-vault-notifications-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/notification-configuration", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-backup-vault-notifications-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBackupVaultNotifications", :http.request.configuration/output-deser-fn response-get-backup-vault-notifications-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-backup-vault-notifications :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-backup-vault-notifications-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-backup-vault-notifications-output))

(clojure.core/defn list-backup-jobs "Returns metadata about your backup jobs." ([] (list-backup-jobs {})) ([list-backup-jobs-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-backup-jobs-input list-backup-jobs-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-backup-jobs-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-jobs/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-backup-jobs-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBackupJobs", :http.request.configuration/output-deser-fn response-list-backup-jobs-output, :http.request.spec/error-spec {"InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-backup-jobs :args (clojure.spec.alpha/? :portkey.aws.backup.-2018-11-15/list-backup-jobs-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-backup-jobs-output))

(clojure.core/defn list-backup-selections "Returns an array containing metadata of the resources associated with the target\nbackup plan." ([list-backup-selections-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-backup-selections-input list-backup-selections-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-backup-selections-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/selections/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-backup-selections-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBackupSelections", :http.request.configuration/output-deser-fn response-list-backup-selections-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-backup-selections :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/list-backup-selections-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-backup-selections-output))

(clojure.core/defn get-backup-plan "Returns the body of a backup plan in JSON format, in addition to plan metadata." ([get-backup-plan-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-backup-plan-input get-backup-plan-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-backup-plan-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-backup-plan-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBackupPlan", :http.request.configuration/output-deser-fn response-get-backup-plan-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-backup-plan :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-backup-plan-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-backup-plan-output))

(clojure.core/defn list-recovery-points-by-resource "Returns detailed information about recovery points of the type specified by a\nresource Amazon Resource Name (ARN)." ([list-recovery-points-by-resource-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-recovery-points-by-resource-input list-recovery-points-by-resource-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-recovery-points-by-resource-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/resources/{resourceArn}/recovery-points/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-recovery-points-by-resource-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListRecoveryPointsByResource", :http.request.configuration/output-deser-fn response-list-recovery-points-by-resource-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-recovery-points-by-resource :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/list-recovery-points-by-resource-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-recovery-points-by-resource-output))

(clojure.core/defn delete-backup-vault-notifications "Deletes event notifications for the specified backup vault." ([delete-backup-vault-notifications-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-backup-vault-notifications-input delete-backup-vault-notifications-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/notification-configuration", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/delete-backup-vault-notifications-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBackupVaultNotifications", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-backup-vault-notifications :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/delete-backup-vault-notifications-input) :ret clojure.core/true?)

(clojure.core/defn list-recovery-points-by-backup-vault "Returns detailed information about the recovery points stored in a backup vault." ([list-recovery-points-by-backup-vault-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-recovery-points-by-backup-vault-input list-recovery-points-by-backup-vault-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-recovery-points-by-backup-vault-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/recovery-points/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-recovery-points-by-backup-vault-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListRecoveryPointsByBackupVault", :http.request.configuration/output-deser-fn response-list-recovery-points-by-backup-vault-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-recovery-points-by-backup-vault :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/list-recovery-points-by-backup-vault-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-recovery-points-by-backup-vault-output))

(clojure.core/defn get-backup-vault-access-policy "Returns the access policy document that is associated with the named backup\nvault." ([get-backup-vault-access-policy-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-backup-vault-access-policy-input get-backup-vault-access-policy-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/get-backup-vault-access-policy-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/access-policy", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/get-backup-vault-access-policy-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBackupVaultAccessPolicy", :http.request.configuration/output-deser-fn response-get-backup-vault-access-policy-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-backup-vault-access-policy :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/get-backup-vault-access-policy-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/get-backup-vault-access-policy-output))

(clojure.core/defn delete-backup-vault-access-policy "Deletes the policy document that manages permissions on a backup vault." ([delete-backup-vault-access-policy-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-backup-vault-access-policy-input delete-backup-vault-access-policy-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/{backupVaultName}/access-policy", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/delete-backup-vault-access-policy-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBackupVaultAccessPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-backup-vault-access-policy :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/delete-backup-vault-access-policy-input) :ret clojure.core/true?)

(clojure.core/defn delete-backup-selection "Deletes the resource selection associated with a backup plan that is specified\nby the SelectionId." ([delete-backup-selection-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-backup-selection-input delete-backup-selection-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/selections/{selectionId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/delete-backup-selection-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBackupSelection", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-backup-selection :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/delete-backup-selection-input) :ret clojure.core/true?)

(clojure.core/defn untag-resource "Removes a set of key-value pairs from a recovery point, backup plan, or backup\nvault identified by an Amazon Resource Name (ARN)" ([untag-resource-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-untag-resource-input untag-resource-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/untag/{resourceArn}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/untag-resource-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/untag-resource-input) :ret clojure.core/true?)

(clojure.core/defn list-backup-vaults "Returns a list of recovery point storage containers along with information about\nthem." ([] (list-backup-vaults {})) ([list-backup-vaults-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-backup-vaults-input list-backup-vaults-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-backup-vaults-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-vaults/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-backup-vaults-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBackupVaults", :http.request.configuration/output-deser-fn response-list-backup-vaults-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-backup-vaults :args (clojure.spec.alpha/? :portkey.aws.backup.-2018-11-15/list-backup-vaults-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-backup-vaults-output))

(clojure.core/defn create-backup-plan "Backup plans are documents that contain information that AWS Backup uses to\nschedule tasks that create recovery points of resources.\n If you call CreateBackupPlan with a plan that already exists, the existing\nbackupPlanId is returned." ([create-backup-plan-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-backup-plan-input create-backup-plan-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/create-backup-plan-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/create-backup-plan-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBackupPlan", :http.request.configuration/output-deser-fn response-create-backup-plan-output, :http.request.spec/error-spec {"LimitExceededException" :portkey.aws.backup.-2018-11-15/limit-exceeded-exception, "AlreadyExistsException" :portkey.aws.backup.-2018-11-15/already-exists-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-backup-plan :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/create-backup-plan-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/create-backup-plan-output))

(clojure.core/defn stop-backup-job "Attempts to cancel a job to create a one-time backup of a resource." ([stop-backup-job-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-stop-backup-job-input stop-backup-job-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup-jobs/{backupJobId}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/stop-backup-job-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopBackupJob", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "InvalidRequestException" :portkey.aws.backup.-2018-11-15/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef stop-backup-job :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/stop-backup-job-input) :ret clojure.core/true?)

(clojure.core/defn describe-protected-resource "Returns information about a saved resource, including the last time it was\nbacked-up, its Amazon Resource Name (ARN), and the AWS service type of the saved\nresource." ([describe-protected-resource-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-protected-resource-input describe-protected-resource-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/describe-protected-resource-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/resources/{resourceArn}", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/describe-protected-resource-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeProtectedResource", :http.request.configuration/output-deser-fn response-describe-protected-resource-output, :http.request.spec/error-spec {"MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception, "ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-protected-resource :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/describe-protected-resource-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/describe-protected-resource-output))

(clojure.core/defn list-backup-plan-versions "Returns version metadata of your backup plans, including Amazon Resource Names\n(ARNs), backup plan IDs, creation and deletion dates, plan names, and version\nIDs." ([list-backup-plan-versions-inputinput] (clojure.core/let [request-function-result__22119__auto__ (req-list-backup-plan-versions-input list-backup-plan-versions-inputinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.backup.-2018-11-15/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.backup.-2018-11-15/list-backup-plan-versions-output, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/backup/plans/{backupPlanId}/versions/", :http.request.configuration/version "2018-11-15", :http.request.configuration/service-id "Backup", :http.request.spec/input-spec :portkey.aws.backup.-2018-11-15/list-backup-plan-versions-input, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBackupPlanVersions", :http.request.configuration/output-deser-fn response-list-backup-plan-versions-output, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.backup.-2018-11-15/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.backup.-2018-11-15/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.backup.-2018-11-15/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.backup.-2018-11-15/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-backup-plan-versions :args (clojure.spec.alpha/tuple :portkey.aws.backup.-2018-11-15/list-backup-plan-versions-input) :ret (clojure.spec.alpha/and :portkey.aws.backup.-2018-11-15/list-backup-plan-versions-output))
