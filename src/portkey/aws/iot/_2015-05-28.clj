(ns portkey.aws.iot.-2015-05-28 (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope
    {:service "execute-api", :region "ap-northeast-1"},
    :ssl-common-name "iot.ap-northeast-1.amazonaws.com",
    :endpoint "https://iot.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "execute-api", :region "eu-west-1"},
    :ssl-common-name "iot.eu-west-1.amazonaws.com",
    :endpoint "https://iot.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "execute-api", :region "us-east-2"},
    :ssl-common-name "iot.us-east-2.amazonaws.com",
    :endpoint "https://iot.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope
    {:service "execute-api", :region "ap-southeast-2"},
    :ssl-common-name "iot.ap-southeast-2.amazonaws.com",
    :endpoint "https://iot.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "execute-api", :region "cn-north-1"},
    :ssl-common-name "iot.cn-north-1.amazonaws.com.cn",
    :endpoint "https://iot.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope
    {:service "execute-api", :region "ap-southeast-1"},
    :ssl-common-name "iot.ap-southeast-1.amazonaws.com",
    :endpoint "https://iot.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope
    {:service "execute-api", :region "ap-northeast-2"},
    :ssl-common-name "iot.ap-northeast-2.amazonaws.com",
    :endpoint "https://iot.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "execute-api", :region "eu-central-1"},
    :ssl-common-name "iot.eu-central-1.amazonaws.com",
    :endpoint "https://iot.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "execute-api", :region "eu-west-2"},
    :ssl-common-name "iot.eu-west-2.amazonaws.com",
    :endpoint "https://iot.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope
    {:service "execute-api", :region "us-gov-west-1"},
    :ssl-common-name "iot.us-gov-west-1.amazonaws.com",
    :endpoint "https://iot.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "execute-api", :region "us-west-2"},
    :ssl-common-name "iot.us-west-2.amazonaws.com",
    :endpoint "https://iot.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "execute-api", :region "us-east-1"},
    :ssl-common-name "iot.us-east-1.amazonaws.com",
    :endpoint "https://iot.us-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "execute-api", :region "ap-south-1"},
    :ssl-common-name "iot.ap-south-1.amazonaws.com",
    :endpoint "https://iot.ap-south-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-registry-max-results)

(clojure.core/declare ser-stream-id)

(clojure.core/declare ser-expected-version)

(clojure.core/declare ser-billing-group-arn)

(clojure.core/declare ser-auto-registration-status)

(clojure.core/declare ser-thing-indexing-mode)

(clojure.core/declare ser-billing-group-properties)

(clojure.core/declare ser-skyfall-max-results)

(clojure.core/declare ser-thing-group-description)

(clojure.core/declare ser-range-key-field)

(clojure.core/declare ser-thing-group-indexing-configuration)

(clojure.core/declare ser-security-profile-description)

(clojure.core/declare ser-in-progress-timeout-in-minutes)

(clojure.core/declare ser-thing-type-properties)

(clojure.core/declare ser-stream-name)

(clojure.core/declare ser-token-signature)

(clojure.core/declare ser-code-signing)

(clojure.core/declare ser-dynamo-d-bv-2-action)

(clojure.core/declare ser-audit-notification-target-configurations)

(clojure.core/declare ser-statistical-threshold)

(clojure.core/declare ser-override-dynamic-groups)

(clojure.core/declare ser-topic-rule-payload)

(clojure.core/declare ser-minimum-number-of-executed-things)

(clojure.core/declare ser-cidr)

(clojure.core/declare ser-platform)

(clojure.core/declare ser-delete-stream)

(clojure.core/declare ser-function-arn)

(clojure.core/declare ser-topic-pattern)

(clojure.core/declare ser-signature-algorithm)

(clojure.core/declare ser-query-version)

(clojure.core/declare ser-rule-name)

(clojure.core/declare ser-job-status)

(clojure.core/declare ser-code-signing-certificate-chain)

(clojure.core/declare ser-comment)

(clojure.core/declare ser-certificate-signing-request)

(clojure.core/declare ser-day-of-week)

(clojure.core/declare ser-page-size)

(clojure.core/declare ser-prefix)

(clojure.core/declare ser-message-id)

(clojure.core/declare ser-thing-type-description)

(clojure.core/declare ser-abort-criteria)

(clojure.core/declare ser-audit-task-type)

(clojure.core/declare ser-canned-access-control-list)

(clojure.core/declare ser-thing-group-id)

(clojure.core/declare ser-duration-seconds)

(clojure.core/declare ser-thing-type-name)

(clojure.core/declare ser-iot-events-action)

(clojure.core/declare ser-execution-number)

(clojure.core/declare ser-input-name)

(clojure.core/declare ser-additional-metrics-to-retain-list)

(clojure.core/declare ser-number-of-things)

(clojure.core/declare ser-key-value)

(clojure.core/declare ser-thing-group-arn)

(clojure.core/declare ser-attribute-name)

(clojure.core/declare ser-log-level)

(clojure.core/declare ser-target-audit-check-names)

(clojure.core/declare ser-policy-name)

(clojure.core/declare ser-action-list)

(clojure.core/declare ser-registration-config)

(clojure.core/declare ser-additional-parameter-map)

(clojure.core/declare ser-laser-max-results)

(clojure.core/declare ser-expires-in-sec)

(clojure.core/declare ser-thing-arn)

(clojure.core/declare ser-template-body)

(clojure.core/declare ser-behavior)

(clojure.core/declare ser-index-name)

(clojure.core/declare ser-endpoint-type)

(clojure.core/declare ser-certificate-name)

(clojure.core/declare ser-attribute-payload)

(clojure.core/declare ser-parameters)

(clojure.core/declare ser-inline-document)

(clojure.core/declare ser-state-value)

(clojure.core/declare ser-use-base-64)

(clojure.core/declare ser-abort-config)

(clojure.core/declare ser-certificate-path-on-device)

(clojure.core/declare ser-security-profile-target-arn)

(clojure.core/declare ser-day-of-month)

(clojure.core/declare ser-max-job-executions-per-min)

(clojure.core/declare ser-ca-certificate-status)

(clojure.core/declare ser-role-arn)

(clojure.core/declare ser-target-arn)

(clojure.core/declare ser-abort-criteria-list)

(clojure.core/declare ser-disable-all-logs)

(clojure.core/declare ser-registry-s-3-key-name)

(clojure.core/declare ser-partition-key)

(clojure.core/declare ser-flag)

(clojure.core/declare ser-marker)

(clojure.core/declare ser-tag-key)

(clojure.core/declare ser-ota-update-files)

(clojure.core/declare ser-start-signing-job-parameter)

(clojure.core/declare ser-destination)

(clojure.core/declare ser-comparison-operator)

(clojure.core/declare ser-task-id)

(clojure.core/declare ser-policy-names)

(clojure.core/declare ser-exponential-rollout-rate)

(clojure.core/declare ser-elasticsearch-type)

(clojure.core/declare ser-rate-increase-criteria)

(clojure.core/declare ser-set-as-active-flag)

(clojure.core/declare ser-force-delete-aws-job)

(clojure.core/declare ser-alert-targets)

(clojure.core/declare ser-aws-arn)

(clojure.core/declare ser-stream-files)

(clojure.core/declare ser-key-name)

(clojure.core/declare ser-log-target-type)

(clojure.core/declare ser-enabled)

(clojure.core/declare ser-query-string)

(clojure.core/declare ser-status)

(clojure.core/declare ser-behaviors)

(clojure.core/declare ser-allow-auto-registration)

(clojure.core/declare ser-event-type)

(clojure.core/declare ser-role-alias)

(clojure.core/declare ser-put-item-input)

(clojure.core/declare ser-log-target-name)

(clojure.core/declare ser-next-token)

(clojure.core/declare ser-behavior-metric)

(clojure.core/declare ser-ota-update-file)

(clojure.core/declare ser-range-key-value)

(clojure.core/declare ser-hash-key-value)

(clojure.core/declare ser-firehose-action)

(clojure.core/declare ser-consecutive-datapoints-to-alarm)

(clojure.core/declare ser-security-profile-name)

(clojure.core/declare ser-thing-group-properties)

(clojure.core/declare ser-cidrs)

(clojure.core/declare ser-topic)

(clojure.core/declare ser-alert-target-type)

(clojure.core/declare ser-job-document)

(clojure.core/declare ser-audit-check-name)

(clojure.core/declare ser-key)

(clojure.core/declare ser-recursive-without-default)

(clojure.core/declare ser-stream-description)

(clojure.core/declare ser-salesforce-token)

(clojure.core/declare ser-thing-group-indexing-mode)

(clojure.core/declare ser-target-selection)

(clojure.core/declare ser-remove-auto-registration)

(clojure.core/declare ser-attributes)

(clojure.core/declare ser-queue-url)

(clojure.core/declare ser-force-flag)

(clojure.core/declare ser-unsigned-long)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-signature)

(clojure.core/declare ser-searchable-attributes)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-message-format)

(clojure.core/declare ser-thing-indexing-configuration)

(clojure.core/declare ser-audit-frequency)

(clojure.core/declare ser-attribute-value)

(clojure.core/declare ser-ota-update-file-version)

(clojure.core/declare ser-dynamo-key-type)

(clojure.core/declare ser-public-key-map)

(clojure.core/declare ser-behavior-criteria)

(clojure.core/declare ser-signing-profile-parameter)

(clojure.core/declare ser-stream-file)

(clojure.core/declare ser-sns-action)

(clojure.core/declare ser-channel-name)

(clojure.core/declare ser-presigned-url-config)

(clojure.core/declare ser-undo-deprecate)

(clojure.core/declare ser-value)

(clojure.core/declare ser-credential-duration-seconds)

(clojure.core/declare ser-delete-alert-targets)

(clojure.core/declare ser-aws-job-executions-rollout-config)

(clojure.core/declare ser-description)

(clojure.core/declare ser-tag-value)

(clojure.core/declare ser-ota-update-description)

(clojure.core/declare ser-token-key-name)

(clojure.core/declare ser-policy-document)

(clojure.core/declare ser-port)

(clojure.core/declare ser-authorizer-status)

(clojure.core/declare ser-timeout-config)

(clojure.core/declare ser-aws-account-id)

(clojure.core/declare ser-message)

(clojure.core/declare ser-is-disabled)

(clojure.core/declare ser-resources)

(clojure.core/declare ser-attribute-key)

(clojure.core/declare ser-file-location)

(clojure.core/declare ser-log-target)

(clojure.core/declare ser-cloudwatch-metric-action)

(clojure.core/declare ser-audit-notification-target)

(clojure.core/declare ser-job-executions-rollout-config)

(clojure.core/declare ser-delete-behaviors)

(clojure.core/declare ser-attributes-map)

(clojure.core/declare ser-job-document-source)

(clojure.core/declare ser-remove-thing-type)

(clojure.core/declare ser-delivery-stream-name)

(clojure.core/declare ser-billing-group-description)

(clojure.core/declare ser-sqs-action)

(clojure.core/declare ser-s-3-version)

(clojure.core/declare ser-string)

(clojure.core/declare ser-cognito-identity-pool-id)

(clojure.core/declare ser-delete-additional-metrics-to-retain)

(clojure.core/declare ser-parameter)

(clojure.core/declare ser-details-value)

(clojure.core/declare ser-ports)

(clojure.core/declare ser-job-targets)

(clojure.core/declare ser-thing-connectivity-indexing-mode)

(clojure.core/declare ser-code-signing-signature)

(clojure.core/declare ser-alert-target-arn)

(clojure.core/declare ser-abort-threshold-percentage)

(clojure.core/declare ser-audit-notification-type)

(clojure.core/declare ser-report-type)

(clojure.core/declare ser-alarm-name)

(clojure.core/declare ser-hash-key-field)

(clojure.core/declare ser-targets)

(clojure.core/declare ser-thing-name)

(clojure.core/declare ser-republish-action)

(clojure.core/declare ser-resource-identifier)

(clojure.core/declare ser-s-3-key)

(clojure.core/declare ser-job-execution-status)

(clojure.core/declare ser-metric-value)

(clojure.core/declare ser-client-id)

(clojure.core/declare ser-audit-check-configurations)

(clojure.core/declare ser-delete-scheduled-audits)

(clojure.core/declare ser-elasticsearch-action)

(clojure.core/declare ser-s-3-location)

(clojure.core/declare ser-elasticsearch-index)

(clojure.core/declare ser-certificate-arn)

(clojure.core/declare ser-custom-code-signing)

(clojure.core/declare ser-set-as-active)

(clojure.core/declare ser-table-name)

(clojure.core/declare ser-s-3-bucket)

(clojure.core/declare ser-billing-group-name)

(clojure.core/declare ser-aws-iot-sql-version)

(clojure.core/declare ser-auth-infos)

(clojure.core/declare ser-stream)

(clojure.core/declare ser-sql)

(clojure.core/declare ser-details-key)

(clojure.core/declare ser-registry-s-3-bucket-name)

(clojure.core/declare ser-abort-action)

(clojure.core/declare ser-dynamo-db-action)

(clojure.core/declare ser-policy-version-id)

(clojure.core/declare ser-alert-target)

(clojure.core/declare ser-timestamp)

(clojure.core/declare ser-dynamo-operation)

(clojure.core/declare ser-resource-arn)

(clojure.core/declare ser-hash-algorithm)

(clojure.core/declare ser-certificate-status)

(clojure.core/declare ser-policy-version-identifier)

(clojure.core/declare ser-authorizer-name)

(clojure.core/declare ser-maximum-per-minute)

(clojure.core/declare ser-behavior-name)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-s-3-destination)

(clojure.core/declare ser-set-as-default)

(clojure.core/declare ser-resource)

(clojure.core/declare ser-reason-code)

(clojure.core/declare ser-job-execution-failure-type)

(clojure.core/declare ser-state-machine-name)

(clojure.core/declare ser-logging-options-payload)

(clojure.core/declare ser-elasticsearch-id)

(clojure.core/declare ser-file-id)

(clojure.core/declare ser-salesforce-action)

(clojure.core/declare ser-event-configurations)

(clojure.core/declare ser-salesforce-endpoint)

(clojure.core/declare ser-step-functions-action)

(clojure.core/declare ser-ascending-order)

(clojure.core/declare ser-auth-info)

(clojure.core/declare ser-target)

(clojure.core/declare ser-ge-max-results)

(clojure.core/declare ser-rollout-rate-per-minute)

(clojure.core/declare ser-optional-version)

(clojure.core/declare ser-action-type)

(clojure.core/declare ser-thing-group-name)

(clojure.core/declare ser-principal)

(clojure.core/declare ser-policy-target)

(clojure.core/declare ser-execution-name-prefix)

(clojure.core/declare ser-evaluation-statistic)

(clojure.core/declare ser-scheduled-audit-name)

(clojure.core/declare ser-cloudwatch-alarm-action)

(clojure.core/declare ser-signing-job-id)

(clojure.core/declare ser-lambda-action)

(clojure.core/declare ser-bucket-name)

(clojure.core/declare ser-certificate-id)

(clojure.core/declare ser-ota-update-status)

(clojure.core/declare ser-certificate-pem)

(clojure.core/declare ser-file-name)

(clojure.core/declare ser-ota-update-id)

(clojure.core/declare ser-action)

(clojure.core/declare ser-configuration)

(clojure.core/declare ser-token)

(clojure.core/declare ser-increment-factor)

(clojure.core/declare ser-job-description)

(clojure.core/declare ser-state-reason)

(clojure.core/declare ser-elasticsearch-endpoint)

(clojure.core/declare ser-signing-profile-name)

(clojure.core/declare ser-details-map)

(clojure.core/declare ser-consecutive-datapoints-to-clear)

(clojure.core/declare ser-force-delete)

(clojure.core/declare ser-recursive)

(clojure.core/declare ser-audit-check-configuration)

(clojure.core/declare ser-audit-task-status)

(clojure.core/declare ser-s-3-action)

(clojure.core/declare ser-iot-analytics-action)

(clojure.core/declare ser-kinesis-action)

(clojure.core/declare ser-query-max-results)

(clojure.core/declare ser-audit-task-id)

(clojure.core/declare ser-thing-group-list)

(clojure.core/declare ser-payload-field)

(clojure.core/declare ser-authorizer-function-arn)

(clojure.core/declare ser-firehose-separator)

(clojure.core/declare ser-job-id)

(clojure.core/defn- ser-registry-max-results [input] #:http.request.field{:value input, :shape "RegistryMaxResults"})

(clojure.core/defn- ser-stream-id [input] #:http.request.field{:value input, :shape "StreamId"})

(clojure.core/defn- ser-expected-version [input] #:http.request.field{:value input, :shape "ExpectedVersion"})

(clojure.core/defn- ser-billing-group-arn [input] #:http.request.field{:value input, :shape "BillingGroupArn"})

(clojure.core/defn- ser-auto-registration-status [input] #:http.request.field{:value (clojure.core/get {"ENABLE" "ENABLE", :enable "ENABLE", "DISABLE" "DISABLE", :disable "DISABLE"} input), :shape "AutoRegistrationStatus"})

(clojure.core/defn- ser-thing-indexing-mode [input] #:http.request.field{:value (clojure.core/get {"OFF" "OFF", :off "OFF", "REGISTRY" "REGISTRY", :registry "REGISTRY", "REGISTRY_AND_SHADOW" "REGISTRY_AND_SHADOW", :registry-and-shadow "REGISTRY_AND_SHADOW"} input), :shape "ThingIndexingMode"})

(clojure.core/defn- ser-billing-group-properties [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BillingGroupProperties", :type "structure"} (clojure.core/contains? input :billing-group-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-description (input :billing-group-description)) #:http.request.field{:name "billingGroupDescription", :shape "BillingGroupDescription"}))))

(clojure.core/defn- ser-skyfall-max-results [input] #:http.request.field{:value input, :shape "SkyfallMaxResults"})

(clojure.core/defn- ser-thing-group-description [input] #:http.request.field{:value input, :shape "ThingGroupDescription"})

(clojure.core/defn- ser-range-key-field [input] #:http.request.field{:value input, :shape "RangeKeyField"})

(clojure.core/defn- ser-thing-group-indexing-configuration [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-thing-group-indexing-mode (:thing-group-indexing-mode input)) #:http.request.field{:name "thingGroupIndexingMode", :shape "ThingGroupIndexingMode"})], :shape "ThingGroupIndexingConfiguration", :type "structure"}))

(clojure.core/defn- ser-security-profile-description [input] #:http.request.field{:value input, :shape "SecurityProfileDescription"})

(clojure.core/defn- ser-in-progress-timeout-in-minutes [input] #:http.request.field{:value input, :shape "InProgressTimeoutInMinutes"})

(clojure.core/defn- ser-thing-type-properties [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ThingTypeProperties", :type "structure"} (clojure.core/contains? input :thing-type-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-description (input :thing-type-description)) #:http.request.field{:name "thingTypeDescription", :shape "ThingTypeDescription"})) (clojure.core/contains? input :searchable-attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-searchable-attributes (input :searchable-attributes)) #:http.request.field{:name "searchableAttributes", :shape "SearchableAttributes"}))))

(clojure.core/defn- ser-stream-name [input] #:http.request.field{:value input, :shape "StreamName"})

(clojure.core/defn- ser-token-signature [input] #:http.request.field{:value input, :shape "TokenSignature"})

(clojure.core/defn- ser-code-signing [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CodeSigning", :type "structure"} (clojure.core/contains? input :aws-signer-job-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signing-job-id (input :aws-signer-job-id)) #:http.request.field{:name "awsSignerJobId", :shape "SigningJobId"})) (clojure.core/contains? input :start-signing-job-parameter) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-start-signing-job-parameter (input :start-signing-job-parameter)) #:http.request.field{:name "startSigningJobParameter", :shape "StartSigningJobParameter"})) (clojure.core/contains? input :custom-code-signing) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-custom-code-signing (input :custom-code-signing)) #:http.request.field{:name "customCodeSigning", :shape "CustomCodeSigning"}))))

(clojure.core/defn- ser-dynamo-d-bv-2-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-put-item-input (:put-item input)) #:http.request.field{:name "putItem", :shape "PutItemInput"})], :shape "DynamoDBv2Action", :type "structure"}))

(clojure.core/defn- ser-audit-notification-target-configurations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-audit-notification-type k) #:http.request.field{:map-info "key", :shape "AuditNotificationType"}) (clojure.core/into (ser-audit-notification-target v) #:http.request.field{:map-info "value", :shape "AuditNotificationTarget"})])) input), :shape "AuditNotificationTargetConfigurations", :type "map"})

(clojure.core/defn- ser-statistical-threshold [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StatisticalThreshold", :type "structure"} (clojure.core/contains? input :statistic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-evaluation-statistic (input :statistic)) #:http.request.field{:name "statistic", :shape "EvaluationStatistic"}))))

(clojure.core/defn- ser-override-dynamic-groups [input] #:http.request.field{:value input, :shape "OverrideDynamicGroups"})

(clojure.core/defn- ser-topic-rule-payload [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-sql (:sql input)) #:http.request.field{:name "sql", :shape "SQL"}) (clojure.core/into (ser-action-list (:actions input)) #:http.request.field{:name "actions", :shape "ActionList"})], :shape "TopicRulePayload", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-description (input :description)) #:http.request.field{:name "description", :shape "Description"})) (clojure.core/contains? input :rule-disabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-is-disabled (input :rule-disabled)) #:http.request.field{:name "ruleDisabled", :shape "IsDisabled"})) (clojure.core/contains? input :aws-iot-sql-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-iot-sql-version (input :aws-iot-sql-version)) #:http.request.field{:name "awsIotSqlVersion", :shape "AwsIotSqlVersion"})) (clojure.core/contains? input :error-action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :error-action)) #:http.request.field{:name "errorAction", :shape "Action"}))))

(clojure.core/defn- ser-minimum-number-of-executed-things [input] #:http.request.field{:value input, :shape "MinimumNumberOfExecutedThings"})

(clojure.core/defn- ser-cidr [input] #:http.request.field{:value input, :shape "Cidr"})

(clojure.core/defn- ser-platform [input] #:http.request.field{:value input, :shape "Platform"})

(clojure.core/defn- ser-delete-stream [input] #:http.request.field{:value input, :shape "DeleteStream"})

(clojure.core/defn- ser-function-arn [input] #:http.request.field{:value input, :shape "FunctionArn"})

(clojure.core/defn- ser-topic-pattern [input] #:http.request.field{:value input, :shape "TopicPattern"})

(clojure.core/defn- ser-signature-algorithm [input] #:http.request.field{:value input, :shape "SignatureAlgorithm"})

(clojure.core/defn- ser-query-version [input] #:http.request.field{:value input, :shape "QueryVersion"})

(clojure.core/defn- ser-rule-name [input] #:http.request.field{:value input, :shape "RuleName"})

(clojure.core/defn- ser-job-status [input] #:http.request.field{:value (clojure.core/get {"IN_PROGRESS" "IN_PROGRESS", :in-progress "IN_PROGRESS", "CANCELED" "CANCELED", :canceled "CANCELED", "COMPLETED" "COMPLETED", :completed "COMPLETED", "DELETION_IN_PROGRESS" "DELETION_IN_PROGRESS", :deletion-in-progress "DELETION_IN_PROGRESS"} input), :shape "JobStatus"})

(clojure.core/defn- ser-code-signing-certificate-chain [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CodeSigningCertificateChain", :type "structure"} (clojure.core/contains? input :certificate-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-name (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "CertificateName"})) (clojure.core/contains? input :inline-document) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inline-document (input :inline-document)) #:http.request.field{:name "inlineDocument", :shape "InlineDocument"}))))

(clojure.core/defn- ser-comment [input] #:http.request.field{:value input, :shape "Comment"})

(clojure.core/defn- ser-certificate-signing-request [input] #:http.request.field{:value input, :shape "CertificateSigningRequest"})

(clojure.core/defn- ser-day-of-week [input] #:http.request.field{:value (clojure.core/get {:wed "WED", "TUE" "TUE", "SAT" "SAT", "SUN" "SUN", :sat "SAT", "MON" "MON", :tue "TUE", :fri "FRI", :sun "SUN", "THU" "THU", "WED" "WED", "FRI" "FRI", :mon "MON", :thu "THU"} input), :shape "DayOfWeek"})

(clojure.core/defn- ser-page-size [input] #:http.request.field{:value input, :shape "PageSize"})

(clojure.core/defn- ser-prefix [input] #:http.request.field{:value input, :shape "Prefix"})

(clojure.core/defn- ser-message-id [input] #:http.request.field{:value input, :shape "MessageId"})

(clojure.core/defn- ser-thing-type-description [input] #:http.request.field{:value input, :shape "ThingTypeDescription"})

(clojure.core/defn- ser-abort-criteria [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-job-execution-failure-type (:failure-type input)) #:http.request.field{:name "failureType", :shape "JobExecutionFailureType"}) (clojure.core/into (ser-abort-action (:action input)) #:http.request.field{:name "action", :shape "AbortAction"}) (clojure.core/into (ser-abort-threshold-percentage (:threshold-percentage input)) #:http.request.field{:name "thresholdPercentage", :shape "AbortThresholdPercentage"}) (clojure.core/into (ser-minimum-number-of-executed-things (:min-number-of-executed-things input)) #:http.request.field{:name "minNumberOfExecutedThings", :shape "MinimumNumberOfExecutedThings"})], :shape "AbortCriteria", :type "structure"}))

(clojure.core/defn- ser-audit-task-type [input] #:http.request.field{:value (clojure.core/get {"ON_DEMAND_AUDIT_TASK" "ON_DEMAND_AUDIT_TASK", :on-demand-audit-task "ON_DEMAND_AUDIT_TASK", "SCHEDULED_AUDIT_TASK" "SCHEDULED_AUDIT_TASK", :scheduled-audit-task "SCHEDULED_AUDIT_TASK"} input), :shape "AuditTaskType"})

(clojure.core/defn- ser-canned-access-control-list [input] #:http.request.field{:value (clojure.core/get {"authenticated-read" "authenticated-read", :logdeliverywrite "log-delivery-write", :bucketownerfullcontrol "bucket-owner-full-control", "public-read-write" "public-read-write", :private "private", "bucket-owner-full-control" "bucket-owner-full-control", "private" "private", :bucketownerread "bucket-owner-read", :publicread "public-read", "aws-exec-read" "aws-exec-read", :publicreadwrite "public-read-write", :awsexecread "aws-exec-read", "bucket-owner-read" "bucket-owner-read", "public-read" "public-read", "log-delivery-write" "log-delivery-write", :authenticatedread "authenticated-read"} input), :shape "CannedAccessControlList"})

(clojure.core/defn- ser-thing-group-id [input] #:http.request.field{:value input, :shape "ThingGroupId"})

(clojure.core/defn- ser-duration-seconds [input] #:http.request.field{:value input, :shape "DurationSeconds"})

(clojure.core/defn- ser-thing-type-name [input] #:http.request.field{:value input, :shape "ThingTypeName"})

(clojure.core/defn- ser-iot-events-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-input-name (:input-name input)) #:http.request.field{:name "inputName", :shape "InputName"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "IotEventsAction", :type "structure"} (clojure.core/contains? input :message-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-id (input :message-id)) #:http.request.field{:name "messageId", :shape "MessageId"}))))

(clojure.core/defn- ser-execution-number [input] #:http.request.field{:value input, :shape "ExecutionNumber"})

(clojure.core/defn- ser-input-name [input] #:http.request.field{:value input, :shape "InputName"})

(clojure.core/defn- ser-additional-metrics-to-retain-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-behavior-metric coll) #:http.request.field{:shape "BehaviorMetric"}))) input), :shape "AdditionalMetricsToRetainList", :type "list"})

(clojure.core/defn- ser-number-of-things [input] #:http.request.field{:value input, :shape "NumberOfThings"})

(clojure.core/defn- ser-key-value [input] #:http.request.field{:value input, :shape "KeyValue"})

(clojure.core/defn- ser-thing-group-arn [input] #:http.request.field{:value input, :shape "ThingGroupArn"})

(clojure.core/defn- ser-attribute-name [input] #:http.request.field{:value input, :shape "AttributeName"})

(clojure.core/defn- ser-log-level [input] #:http.request.field{:value (clojure.core/get {"DISABLED" "DISABLED", :disabled "DISABLED", :warn "WARN", "WARN" "WARN", :debug "DEBUG", "ERROR" "ERROR", "DEBUG" "DEBUG", :info "INFO", :error "ERROR", "INFO" "INFO"} input), :shape "LogLevel"})

(clojure.core/defn- ser-target-audit-check-names [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-audit-check-name coll) #:http.request.field{:shape "AuditCheckName"}))) input), :shape "TargetAuditCheckNames", :type "list"})

(clojure.core/defn- ser-policy-name [input] #:http.request.field{:value input, :shape "PolicyName"})

(clojure.core/defn- ser-action-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-action coll) #:http.request.field{:shape "Action"}))) input), :shape "ActionList", :type "list", :max 10, :min 0})

(clojure.core/defn- ser-registration-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RegistrationConfig", :type "structure"} (clojure.core/contains? input :template-body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-template-body (input :template-body)) #:http.request.field{:name "templateBody", :shape "TemplateBody"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"}))))

(clojure.core/defn- ser-additional-parameter-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-key k) #:http.request.field{:map-info "key", :shape "AttributeKey"}) (clojure.core/into (ser-value v) #:http.request.field{:map-info "value", :shape "Value"})])) input), :shape "AdditionalParameterMap", :type "map"})

(clojure.core/defn- ser-laser-max-results [input] #:http.request.field{:value input, :shape "LaserMaxResults"})

(clojure.core/defn- ser-expires-in-sec [input] #:http.request.field{:value input, :shape "ExpiresInSec"})

(clojure.core/defn- ser-thing-arn [input] #:http.request.field{:value input, :shape "ThingArn"})

(clojure.core/defn- ser-template-body [input] #:http.request.field{:value input, :shape "TemplateBody"})

(clojure.core/defn- ser-behavior [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-behavior-name (:name input)) #:http.request.field{:name "name", :shape "BehaviorName"})], :shape "Behavior", :type "structure"} (clojure.core/contains? input :metric) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behavior-metric (input :metric)) #:http.request.field{:name "metric", :shape "BehaviorMetric"})) (clojure.core/contains? input :criteria) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behavior-criteria (input :criteria)) #:http.request.field{:name "criteria", :shape "BehaviorCriteria"}))))

(clojure.core/defn- ser-index-name [input] #:http.request.field{:value input, :shape "IndexName"})

(clojure.core/defn- ser-endpoint-type [input] #:http.request.field{:value input, :shape "EndpointType"})

(clojure.core/defn- ser-certificate-name [input] #:http.request.field{:value input, :shape "CertificateName"})

(clojure.core/defn- ser-attribute-payload [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttributePayload", :type "structure"} (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attributes (input :attributes)) #:http.request.field{:name "attributes", :shape "Attributes"})) (clojure.core/contains? input :merge) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-flag (input :merge)) #:http.request.field{:name "merge", :shape "Flag"}))))

(clojure.core/defn- ser-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-parameter k) #:http.request.field{:map-info "key", :shape "Parameter"}) (clojure.core/into (ser-value v) #:http.request.field{:map-info "value", :shape "Value"})])) input), :shape "Parameters", :type "map"})

(clojure.core/defn- ser-inline-document [input] #:http.request.field{:value input, :shape "InlineDocument"})

(clojure.core/defn- ser-state-value [input] #:http.request.field{:value input, :shape "StateValue"})

(clojure.core/defn- ser-use-base-64 [input] #:http.request.field{:value input, :shape "UseBase64"})

(clojure.core/defn- ser-abort-config [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-abort-criteria-list (:criteria-list input)) #:http.request.field{:name "criteriaList", :shape "AbortCriteriaList"})], :shape "AbortConfig", :type "structure"}))

(clojure.core/defn- ser-certificate-path-on-device [input] #:http.request.field{:value input, :shape "CertificatePathOnDevice"})

(clojure.core/defn- ser-security-profile-target-arn [input] #:http.request.field{:value input, :shape "SecurityProfileTargetArn"})

(clojure.core/defn- ser-day-of-month [input] #:http.request.field{:value input, :shape "DayOfMonth"})

(clojure.core/defn- ser-max-job-executions-per-min [input] #:http.request.field{:value input, :shape "MaxJobExecutionsPerMin"})

(clojure.core/defn- ser-ca-certificate-status [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE", "INACTIVE" "INACTIVE", :inactive "INACTIVE"} input), :shape "CACertificateStatus"})

(clojure.core/defn- ser-role-arn [input] #:http.request.field{:value input, :shape "RoleArn"})

(clojure.core/defn- ser-target-arn [input] #:http.request.field{:value input, :shape "TargetArn"})

(clojure.core/defn- ser-abort-criteria-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-abort-criteria coll) #:http.request.field{:shape "AbortCriteria"}))) input), :shape "AbortCriteriaList", :type "list", :min 1})

(clojure.core/defn- ser-disable-all-logs [input] #:http.request.field{:value input, :shape "DisableAllLogs"})

(clojure.core/defn- ser-registry-s-3-key-name [input] #:http.request.field{:value input, :shape "RegistryS3KeyName"})

(clojure.core/defn- ser-partition-key [input] #:http.request.field{:value input, :shape "PartitionKey"})

(clojure.core/defn- ser-flag [input] #:http.request.field{:value input, :shape "Flag"})

(clojure.core/defn- ser-marker [input] #:http.request.field{:value input, :shape "Marker"})

(clojure.core/defn- ser-tag-key [input] #:http.request.field{:value input, :shape "TagKey"})

(clojure.core/defn- ser-ota-update-files [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ota-update-file coll) #:http.request.field{:shape "OTAUpdateFile"}))) input), :shape "OTAUpdateFiles", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-start-signing-job-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StartSigningJobParameter", :type "structure"} (clojure.core/contains? input :signing-profile-parameter) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signing-profile-parameter (input :signing-profile-parameter)) #:http.request.field{:name "signingProfileParameter", :shape "SigningProfileParameter"})) (clojure.core/contains? input :signing-profile-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signing-profile-name (input :signing-profile-name)) #:http.request.field{:name "signingProfileName", :shape "SigningProfileName"})) (clojure.core/contains? input :destination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-destination (input :destination)) #:http.request.field{:name "destination", :shape "Destination"}))))

(clojure.core/defn- ser-destination [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Destination", :type "structure"} (clojure.core/contains? input :s-3-destination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-destination (input :s-3-destination)) #:http.request.field{:name "s3Destination", :shape "S3Destination"}))))

(clojure.core/defn- ser-comparison-operator [input] #:http.request.field{:value (clojure.core/get {"less-than-equals" "less-than-equals", :notinportset "not-in-port-set", :notincidrset "not-in-cidr-set", "greater-than" "greater-than", "not-in-port-set" "not-in-port-set", :lessthan "less-than", "greater-than-equals" "greater-than-equals", :lessthanequals "less-than-equals", :incidrset "in-cidr-set", "in-cidr-set" "in-cidr-set", "not-in-cidr-set" "not-in-cidr-set", :greaterthanequals "greater-than-equals", "in-port-set" "in-port-set", :inportset "in-port-set", :greaterthan "greater-than", "less-than" "less-than"} input), :shape "ComparisonOperator"})

(clojure.core/defn- ser-task-id [input] #:http.request.field{:value input, :shape "TaskId"})

(clojure.core/defn- ser-policy-names [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-policy-name coll) #:http.request.field{:shape "PolicyName"}))) input), :shape "PolicyNames", :type "list"})

(clojure.core/defn- ser-exponential-rollout-rate [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-rollout-rate-per-minute (:base-rate-per-minute input)) #:http.request.field{:name "baseRatePerMinute", :shape "RolloutRatePerMinute"}) (clojure.core/into (ser-increment-factor (:increment-factor input)) #:http.request.field{:name "incrementFactor", :shape "IncrementFactor"}) (clojure.core/into (ser-rate-increase-criteria (:rate-increase-criteria input)) #:http.request.field{:name "rateIncreaseCriteria", :shape "RateIncreaseCriteria"})], :shape "ExponentialRolloutRate", :type "structure"}))

(clojure.core/defn- ser-elasticsearch-type [input] #:http.request.field{:value input, :shape "ElasticsearchType"})

(clojure.core/defn- ser-rate-increase-criteria [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RateIncreaseCriteria", :type "structure"} (clojure.core/contains? input :number-of-notified-things) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-number-of-things (input :number-of-notified-things)) #:http.request.field{:name "numberOfNotifiedThings", :shape "NumberOfThings"})) (clojure.core/contains? input :number-of-succeeded-things) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-number-of-things (input :number-of-succeeded-things)) #:http.request.field{:name "numberOfSucceededThings", :shape "NumberOfThings"}))))

(clojure.core/defn- ser-set-as-active-flag [input] #:http.request.field{:value input, :shape "SetAsActiveFlag"})

(clojure.core/defn- ser-force-delete-aws-job [input] #:http.request.field{:value input, :shape "ForceDeleteAWSJob"})

(clojure.core/defn- ser-alert-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-alert-target-type k) #:http.request.field{:map-info "key", :shape "AlertTargetType"}) (clojure.core/into (ser-alert-target v) #:http.request.field{:map-info "value", :shape "AlertTarget"})])) input), :shape "AlertTargets", :type "map"})

(clojure.core/defn- ser-aws-arn [input] #:http.request.field{:value input, :shape "AwsArn"})

(clojure.core/defn- ser-stream-files [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-stream-file coll) #:http.request.field{:shape "StreamFile"}))) input), :shape "StreamFiles", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-key-name [input] #:http.request.field{:value input, :shape "KeyName"})

(clojure.core/defn- ser-log-target-type [input] #:http.request.field{:value (clojure.core/get {"DEFAULT" "DEFAULT", :default "DEFAULT", "THING_GROUP" "THING_GROUP", :thing-group "THING_GROUP"} input), :shape "LogTargetType"})

(clojure.core/defn- ser-enabled [input] #:http.request.field{:value input, :shape "Enabled"})

(clojure.core/defn- ser-query-string [input] #:http.request.field{:value input, :shape "QueryString"})

(clojure.core/defn- ser-status [input] #:http.request.field{:value (clojure.core/get {"Failed" "Failed", "Cancelled" "Cancelled", :in-progress "InProgress", "Cancelling" "Cancelling", :completed "Completed", :cancelled "Cancelled", "InProgress" "InProgress", "Completed" "Completed", :cancelling "Cancelling", :failed "Failed"} input), :shape "Status"})

(clojure.core/defn- ser-behaviors [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-behavior coll) #:http.request.field{:shape "Behavior"}))) input), :shape "Behaviors", :type "list", :max 100})

(clojure.core/defn- ser-allow-auto-registration [input] #:http.request.field{:value input, :shape "AllowAutoRegistration"})

(clojure.core/defn- ser-event-type [input] #:http.request.field{:value (clojure.core/get {:ca-certificate "CA_CERTIFICATE", :thing-group "THING_GROUP", "THING_TYPE" "THING_TYPE", "THING_GROUP_HIERARCHY" "THING_GROUP_HIERARCHY", "JOB_EXECUTION" "JOB_EXECUTION", "CA_CERTIFICATE" "CA_CERTIFICATE", :thing-group-membership "THING_GROUP_MEMBERSHIP", :job-execution "JOB_EXECUTION", "THING_TYPE_ASSOCIATION" "THING_TYPE_ASSOCIATION", "JOB" "JOB", :thing-group-hierarchy "THING_GROUP_HIERARCHY", :policy "POLICY", :certificate "CERTIFICATE", :thing "THING", :thing-type "THING_TYPE", "POLICY" "POLICY", "THING_GROUP" "THING_GROUP", "THING_GROUP_MEMBERSHIP" "THING_GROUP_MEMBERSHIP", "THING" "THING", :job "JOB", "CERTIFICATE" "CERTIFICATE", :thing-type-association "THING_TYPE_ASSOCIATION"} input), :shape "EventType"})

(clojure.core/defn- ser-role-alias [input] #:http.request.field{:value input, :shape "RoleAlias"})

(clojure.core/defn- ser-put-item-input [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-table-name (:table-name input)) #:http.request.field{:name "tableName", :shape "TableName"})], :shape "PutItemInput", :type "structure"}))

(clojure.core/defn- ser-log-target-name [input] #:http.request.field{:value input, :shape "LogTargetName"})

(clojure.core/defn- ser-next-token [input] #:http.request.field{:value input, :shape "NextToken"})

(clojure.core/defn- ser-behavior-metric [input] #:http.request.field{:value input, :shape "BehaviorMetric"})

(clojure.core/defn- ser-ota-update-file [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "OTAUpdateFile", :type "structure"} (clojure.core/contains? input :file-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-name (input :file-name)) #:http.request.field{:name "fileName", :shape "FileName"})) (clojure.core/contains? input :file-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ota-update-file-version (input :file-version)) #:http.request.field{:name "fileVersion", :shape "OTAUpdateFileVersion"})) (clojure.core/contains? input :file-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-location (input :file-location)) #:http.request.field{:name "fileLocation", :shape "FileLocation"})) (clojure.core/contains? input :code-signing) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-code-signing (input :code-signing)) #:http.request.field{:name "codeSigning", :shape "CodeSigning"})) (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attributes-map (input :attributes)) #:http.request.field{:name "attributes", :shape "AttributesMap"}))))

(clojure.core/defn- ser-range-key-value [input] #:http.request.field{:value input, :shape "RangeKeyValue"})

(clojure.core/defn- ser-hash-key-value [input] #:http.request.field{:value input, :shape "HashKeyValue"})

(clojure.core/defn- ser-firehose-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-delivery-stream-name (:delivery-stream-name input)) #:http.request.field{:name "deliveryStreamName", :shape "DeliveryStreamName"})], :shape "FirehoseAction", :type "structure"} (clojure.core/contains? input :separator) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-firehose-separator (input :separator)) #:http.request.field{:name "separator", :shape "FirehoseSeparator"}))))

(clojure.core/defn- ser-consecutive-datapoints-to-alarm [input] #:http.request.field{:value input, :shape "ConsecutiveDatapointsToAlarm"})

(clojure.core/defn- ser-security-profile-name [input] #:http.request.field{:value input, :shape "SecurityProfileName"})

(clojure.core/defn- ser-thing-group-properties [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ThingGroupProperties", :type "structure"} (clojure.core/contains? input :thing-group-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-description (input :thing-group-description)) #:http.request.field{:name "thingGroupDescription", :shape "ThingGroupDescription"})) (clojure.core/contains? input :attribute-payload) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-payload (input :attribute-payload)) #:http.request.field{:name "attributePayload", :shape "AttributePayload"}))))

(clojure.core/defn- ser-cidrs [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-cidr coll) #:http.request.field{:shape "Cidr"}))) input), :shape "Cidrs", :type "list"})

(clojure.core/defn- ser-topic [input] #:http.request.field{:value input, :shape "Topic"})

(clojure.core/defn- ser-alert-target-type [input] #:http.request.field{:value (clojure.core/get {"SNS" "SNS", :sns "SNS"} input), :shape "AlertTargetType"})

(clojure.core/defn- ser-job-document [input] #:http.request.field{:value input, :shape "JobDocument"})

(clojure.core/defn- ser-audit-check-name [input] #:http.request.field{:value input, :shape "AuditCheckName"})

(clojure.core/defn- ser-key [input] #:http.request.field{:value input, :shape "Key"})

(clojure.core/defn- ser-recursive-without-default [input] #:http.request.field{:value input, :shape "RecursiveWithoutDefault"})

(clojure.core/defn- ser-stream-description [input] #:http.request.field{:value input, :shape "StreamDescription"})

(clojure.core/defn- ser-salesforce-token [input] #:http.request.field{:value input, :shape "SalesforceToken"})

(clojure.core/defn- ser-thing-group-indexing-mode [input] #:http.request.field{:value (clojure.core/get {"OFF" "OFF", :off "OFF", "ON" "ON", :on "ON"} input), :shape "ThingGroupIndexingMode"})

(clojure.core/defn- ser-target-selection [input] #:http.request.field{:value (clojure.core/get {"CONTINUOUS" "CONTINUOUS", :continuous "CONTINUOUS", "SNAPSHOT" "SNAPSHOT", :snapshot "SNAPSHOT"} input), :shape "TargetSelection"})

(clojure.core/defn- ser-remove-auto-registration [input] #:http.request.field{:value input, :shape "RemoveAutoRegistration"})

(clojure.core/defn- ser-attributes [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "Attributes", :type "map"})

(clojure.core/defn- ser-queue-url [input] #:http.request.field{:value input, :shape "QueueUrl"})

(clojure.core/defn- ser-force-flag [input] #:http.request.field{:value input, :shape "ForceFlag"})

(clojure.core/defn- ser-unsigned-long [input] #:http.request.field{:value input, :shape "UnsignedLong"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-signature [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "Signature"})

(clojure.core/defn- ser-searchable-attributes [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-attribute-name coll) #:http.request.field{:shape "AttributeName"}))) input), :shape "SearchableAttributes", :type "list"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag-key coll) #:http.request.field{:shape "TagKey"}))) input), :shape "TagKeyList", :type "list"})

(clojure.core/defn- ser-message-format [input] #:http.request.field{:value (clojure.core/get {"RAW" "RAW", :raw "RAW", "JSON" "JSON", :json "JSON"} input), :shape "MessageFormat"})

(clojure.core/defn- ser-thing-indexing-configuration [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-thing-indexing-mode (:thing-indexing-mode input)) #:http.request.field{:name "thingIndexingMode", :shape "ThingIndexingMode"})], :shape "ThingIndexingConfiguration", :type "structure"} (clojure.core/contains? input :thing-connectivity-indexing-mode) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-connectivity-indexing-mode (input :thing-connectivity-indexing-mode)) #:http.request.field{:name "thingConnectivityIndexingMode", :shape "ThingConnectivityIndexingMode"}))))

(clojure.core/defn- ser-audit-frequency [input] #:http.request.field{:value (clojure.core/get {"DAILY" "DAILY", :daily "DAILY", "WEEKLY" "WEEKLY", :weekly "WEEKLY", "BIWEEKLY" "BIWEEKLY", :biweekly "BIWEEKLY", "MONTHLY" "MONTHLY", :monthly "MONTHLY"} input), :shape "AuditFrequency"})

(clojure.core/defn- ser-attribute-value [input] #:http.request.field{:value input, :shape "AttributeValue"})

(clojure.core/defn- ser-ota-update-file-version [input] #:http.request.field{:value input, :shape "OTAUpdateFileVersion"})

(clojure.core/defn- ser-dynamo-key-type [input] #:http.request.field{:value (clojure.core/get {"STRING" "STRING", :string "STRING", "NUMBER" "NUMBER", :number "NUMBER"} input), :shape "DynamoKeyType"})

(clojure.core/defn- ser-public-key-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-key-name k) #:http.request.field{:map-info "key", :shape "KeyName"}) (clojure.core/into (ser-key-value v) #:http.request.field{:map-info "value", :shape "KeyValue"})])) input), :shape "PublicKeyMap", :type "map"})

(clojure.core/defn- ser-behavior-criteria [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BehaviorCriteria", :type "structure"} (clojure.core/contains? input :comparison-operator) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comparison-operator (input :comparison-operator)) #:http.request.field{:name "comparisonOperator", :shape "ComparisonOperator"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-metric-value (input :value)) #:http.request.field{:name "value", :shape "MetricValue"})) (clojure.core/contains? input :duration-seconds) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-duration-seconds (input :duration-seconds)) #:http.request.field{:name "durationSeconds", :shape "DurationSeconds"})) (clojure.core/contains? input :consecutive-datapoints-to-alarm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-consecutive-datapoints-to-alarm (input :consecutive-datapoints-to-alarm)) #:http.request.field{:name "consecutiveDatapointsToAlarm", :shape "ConsecutiveDatapointsToAlarm"})) (clojure.core/contains? input :consecutive-datapoints-to-clear) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-consecutive-datapoints-to-clear (input :consecutive-datapoints-to-clear)) #:http.request.field{:name "consecutiveDatapointsToClear", :shape "ConsecutiveDatapointsToClear"})) (clojure.core/contains? input :statistical-threshold) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-statistical-threshold (input :statistical-threshold)) #:http.request.field{:name "statisticalThreshold", :shape "StatisticalThreshold"}))))

(clojure.core/defn- ser-signing-profile-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SigningProfileParameter", :type "structure"} (clojure.core/contains? input :certificate-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-arn (input :certificate-arn)) #:http.request.field{:name "certificateArn", :shape "CertificateArn"})) (clojure.core/contains? input :platform) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-platform (input :platform)) #:http.request.field{:name "platform", :shape "Platform"})) (clojure.core/contains? input :certificate-path-on-device) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-path-on-device (input :certificate-path-on-device)) #:http.request.field{:name "certificatePathOnDevice", :shape "CertificatePathOnDevice"}))))

(clojure.core/defn- ser-stream-file [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StreamFile", :type "structure"} (clojure.core/contains? input :file-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-id (input :file-id)) #:http.request.field{:name "fileId", :shape "FileId"})) (clojure.core/contains? input :s-3-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-location (input :s-3-location)) #:http.request.field{:name "s3Location", :shape "S3Location"}))))

(clojure.core/defn- ser-sns-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:target-arn input)) #:http.request.field{:name "targetArn", :shape "AwsArn"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "SnsAction", :type "structure"} (clojure.core/contains? input :message-format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-format (input :message-format)) #:http.request.field{:name "messageFormat", :shape "MessageFormat"}))))

(clojure.core/defn- ser-channel-name [input] #:http.request.field{:value input, :shape "ChannelName"})

(clojure.core/defn- ser-presigned-url-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PresignedUrlConfig", :type "structure"} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :expires-in-sec) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-expires-in-sec (input :expires-in-sec)) #:http.request.field{:name "expiresInSec", :shape "ExpiresInSec"}))))

(clojure.core/defn- ser-undo-deprecate [input] #:http.request.field{:value input, :shape "UndoDeprecate"})

(clojure.core/defn- ser-value [input] #:http.request.field{:value input, :shape "Value"})

(clojure.core/defn- ser-credential-duration-seconds [input] #:http.request.field{:value input, :shape "CredentialDurationSeconds"})

(clojure.core/defn- ser-delete-alert-targets [input] #:http.request.field{:value input, :shape "DeleteAlertTargets"})

(clojure.core/defn- ser-aws-job-executions-rollout-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AwsJobExecutionsRolloutConfig", :type "structure"} (clojure.core/contains? input :maximum-per-minute) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maximum-per-minute (input :maximum-per-minute)) #:http.request.field{:name "maximumPerMinute", :shape "MaximumPerMinute"}))))

(clojure.core/defn- ser-description [input] #:http.request.field{:value input, :shape "Description"})

(clojure.core/defn- ser-tag-value [input] #:http.request.field{:value input, :shape "TagValue"})

(clojure.core/defn- ser-ota-update-description [input] #:http.request.field{:value input, :shape "OTAUpdateDescription"})

(clojure.core/defn- ser-token-key-name [input] #:http.request.field{:value input, :shape "TokenKeyName"})

(clojure.core/defn- ser-policy-document [input] #:http.request.field{:value input, :shape "PolicyDocument"})

(clojure.core/defn- ser-port [input] #:http.request.field{:value input, :shape "Port"})

(clojure.core/defn- ser-authorizer-status [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE", "INACTIVE" "INACTIVE", :inactive "INACTIVE"} input), :shape "AuthorizerStatus"})

(clojure.core/defn- ser-timeout-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TimeoutConfig", :type "structure"} (clojure.core/contains? input :in-progress-timeout-in-minutes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-in-progress-timeout-in-minutes (input :in-progress-timeout-in-minutes)) #:http.request.field{:name "inProgressTimeoutInMinutes", :shape "InProgressTimeoutInMinutes"}))))

(clojure.core/defn- ser-aws-account-id [input] #:http.request.field{:value input, :shape "AwsAccountId"})

(clojure.core/defn- ser-message [input] #:http.request.field{:value input, :shape "Message"})

(clojure.core/defn- ser-is-disabled [input] #:http.request.field{:value input, :shape "IsDisabled"})

(clojure.core/defn- ser-resources [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-resource coll) #:http.request.field{:shape "Resource"}))) input), :shape "Resources", :type "list"})

(clojure.core/defn- ser-attribute-key [input] #:http.request.field{:value input, :shape "AttributeKey"})

(clojure.core/defn- ser-file-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "FileLocation", :type "structure"} (clojure.core/contains? input :stream) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream (input :stream)) #:http.request.field{:name "stream", :shape "Stream"})) (clojure.core/contains? input :s-3-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-location (input :s-3-location)) #:http.request.field{:name "s3Location", :shape "S3Location"}))))

(clojure.core/defn- ser-log-target [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-log-target-type (:target-type input)) #:http.request.field{:name "targetType", :shape "LogTargetType"})], :shape "LogTarget", :type "structure"} (clojure.core/contains? input :target-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-target-name (input :target-name)) #:http.request.field{:name "targetName", :shape "LogTargetName"}))))

(clojure.core/defn- ser-cloudwatch-metric-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-string (:metric-namespace input)) #:http.request.field{:name "metricNamespace", :shape "String"}) (clojure.core/into (ser-string (:metric-name input)) #:http.request.field{:name "metricName", :shape "String"}) (clojure.core/into (ser-string (:metric-value input)) #:http.request.field{:name "metricValue", :shape "String"}) (clojure.core/into (ser-string (:metric-unit input)) #:http.request.field{:name "metricUnit", :shape "String"})], :shape "CloudwatchMetricAction", :type "structure"} (clojure.core/contains? input :metric-timestamp) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :metric-timestamp)) #:http.request.field{:name "metricTimestamp", :shape "String"}))))

(clojure.core/defn- ser-audit-notification-target [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AuditNotificationTarget", :type "structure"} (clojure.core/contains? input :target-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-arn (input :target-arn)) #:http.request.field{:name "targetArn", :shape "TargetArn"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-enabled (input :enabled)) #:http.request.field{:name "enabled", :shape "Enabled"}))))

(clojure.core/defn- ser-job-executions-rollout-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "JobExecutionsRolloutConfig", :type "structure"} (clojure.core/contains? input :maximum-per-minute) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-job-executions-per-min (input :maximum-per-minute)) #:http.request.field{:name "maximumPerMinute", :shape "MaxJobExecutionsPerMin"})) (clojure.core/contains? input :exponential-rate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-exponential-rollout-rate (input :exponential-rate)) #:http.request.field{:name "exponentialRate", :shape "ExponentialRolloutRate"}))))

(clojure.core/defn- ser-delete-behaviors [input] #:http.request.field{:value input, :shape "DeleteBehaviors"})

(clojure.core/defn- ser-attributes-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-key k) #:http.request.field{:map-info "key", :shape "AttributeKey"}) (clojure.core/into (ser-value v) #:http.request.field{:map-info "value", :shape "Value"})])) input), :shape "AttributesMap", :type "map"})

(clojure.core/defn- ser-job-document-source [input] #:http.request.field{:value input, :shape "JobDocumentSource"})

(clojure.core/defn- ser-remove-thing-type [input] #:http.request.field{:value input, :shape "RemoveThingType"})

(clojure.core/defn- ser-delivery-stream-name [input] #:http.request.field{:value input, :shape "DeliveryStreamName"})

(clojure.core/defn- ser-billing-group-description [input] #:http.request.field{:value input, :shape "BillingGroupDescription"})

(clojure.core/defn- ser-sqs-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-queue-url (:queue-url input)) #:http.request.field{:name "queueUrl", :shape "QueueUrl"})], :shape "SqsAction", :type "structure"} (clojure.core/contains? input :use-base-64) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-use-base-64 (input :use-base-64)) #:http.request.field{:name "useBase64", :shape "UseBase64"}))))

(clojure.core/defn- ser-s-3-version [input] #:http.request.field{:value input, :shape "S3Version"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-cognito-identity-pool-id [input] #:http.request.field{:value input, :shape "CognitoIdentityPoolId"})

(clojure.core/defn- ser-delete-additional-metrics-to-retain [input] #:http.request.field{:value input, :shape "DeleteAdditionalMetricsToRetain"})

(clojure.core/defn- ser-parameter [input] #:http.request.field{:value input, :shape "Parameter"})

(clojure.core/defn- ser-details-value [input] #:http.request.field{:value input, :shape "DetailsValue"})

(clojure.core/defn- ser-ports [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-port coll) #:http.request.field{:shape "Port"}))) input), :shape "Ports", :type "list"})

(clojure.core/defn- ser-job-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-arn coll) #:http.request.field{:shape "TargetArn"}))) input), :shape "JobTargets", :type "list", :min 1})

(clojure.core/defn- ser-thing-connectivity-indexing-mode [input] #:http.request.field{:value (clojure.core/get {"OFF" "OFF", :off "OFF", "STATUS" "STATUS", :status "STATUS"} input), :shape "ThingConnectivityIndexingMode"})

(clojure.core/defn- ser-code-signing-signature [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CodeSigningSignature", :type "structure"} (clojure.core/contains? input :inline-document) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signature (input :inline-document)) #:http.request.field{:name "inlineDocument", :shape "Signature"}))))

(clojure.core/defn- ser-alert-target-arn [input] #:http.request.field{:value input, :shape "AlertTargetArn"})

(clojure.core/defn- ser-abort-threshold-percentage [input] #:http.request.field{:value input, :shape "AbortThresholdPercentage"})

(clojure.core/defn- ser-audit-notification-type [input] #:http.request.field{:value (clojure.core/get {"SNS" "SNS", :sns "SNS"} input), :shape "AuditNotificationType"})

(clojure.core/defn- ser-report-type [input] #:http.request.field{:value (clojure.core/get {"ERRORS" "ERRORS", :errors "ERRORS", "RESULTS" "RESULTS", :results "RESULTS"} input), :shape "ReportType"})

(clojure.core/defn- ser-alarm-name [input] #:http.request.field{:value input, :shape "AlarmName"})

(clojure.core/defn- ser-hash-key-field [input] #:http.request.field{:value input, :shape "HashKeyField"})

(clojure.core/defn- ser-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target coll) #:http.request.field{:shape "Target"}))) input), :shape "Targets", :type "list", :min 1})

(clojure.core/defn- ser-thing-name [input] #:http.request.field{:value input, :shape "ThingName"})

(clojure.core/defn- ser-republish-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-topic-pattern (:topic input)) #:http.request.field{:name "topic", :shape "TopicPattern"})], :shape "RepublishAction", :type "structure"}))

(clojure.core/defn- ser-resource-identifier [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ResourceIdentifier", :type "structure"} (clojure.core/contains? input :device-certificate-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-id (input :device-certificate-id)) #:http.request.field{:name "deviceCertificateId", :shape "CertificateId"})) (clojure.core/contains? input :ca-certificate-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-id (input :ca-certificate-id)) #:http.request.field{:name "caCertificateId", :shape "CertificateId"})) (clojure.core/contains? input :cognito-identity-pool-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cognito-identity-pool-id (input :cognito-identity-pool-id)) #:http.request.field{:name "cognitoIdentityPoolId", :shape "CognitoIdentityPoolId"})) (clojure.core/contains? input :client-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-id (input :client-id)) #:http.request.field{:name "clientId", :shape "ClientId"})) (clojure.core/contains? input :policy-version-identifier) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-version-identifier (input :policy-version-identifier)) #:http.request.field{:name "policyVersionIdentifier", :shape "PolicyVersionIdentifier"})) (clojure.core/contains? input :account) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-account-id (input :account)) #:http.request.field{:name "account", :shape "AwsAccountId"}))))

(clojure.core/defn- ser-s-3-key [input] #:http.request.field{:value input, :shape "S3Key"})

(clojure.core/defn- ser-job-execution-status [input] #:http.request.field{:value (clojure.core/get {"CANCELED" "CANCELED", :timed-out "TIMED_OUT", "IN_PROGRESS" "IN_PROGRESS", "TIMED_OUT" "TIMED_OUT", :in-progress "IN_PROGRESS", :rejected "REJECTED", "REMOVED" "REMOVED", :queued "QUEUED", :canceled "CANCELED", "SUCCEEDED" "SUCCEEDED", "REJECTED" "REJECTED", "QUEUED" "QUEUED", "FAILED" "FAILED", :removed "REMOVED", :failed "FAILED", :succeeded "SUCCEEDED"} input), :shape "JobExecutionStatus"})

(clojure.core/defn- ser-metric-value [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MetricValue", :type "structure"} (clojure.core/contains? input :count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-unsigned-long (input :count)) #:http.request.field{:name "count", :shape "UnsignedLong"})) (clojure.core/contains? input :cidrs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cidrs (input :cidrs)) #:http.request.field{:name "cidrs", :shape "Cidrs"})) (clojure.core/contains? input :ports) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ports (input :ports)) #:http.request.field{:name "ports", :shape "Ports"}))))

(clojure.core/defn- ser-client-id [input] #:http.request.field{:value input, :shape "ClientId"})

(clojure.core/defn- ser-audit-check-configurations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-audit-check-name k) #:http.request.field{:map-info "key", :shape "AuditCheckName"}) (clojure.core/into (ser-audit-check-configuration v) #:http.request.field{:map-info "value", :shape "AuditCheckConfiguration"})])) input), :shape "AuditCheckConfigurations", :type "map"})

(clojure.core/defn- ser-delete-scheduled-audits [input] #:http.request.field{:value input, :shape "DeleteScheduledAudits"})

(clojure.core/defn- ser-elasticsearch-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-elasticsearch-endpoint (:endpoint input)) #:http.request.field{:name "endpoint", :shape "ElasticsearchEndpoint"}) (clojure.core/into (ser-elasticsearch-index (:index input)) #:http.request.field{:name "index", :shape "ElasticsearchIndex"}) (clojure.core/into (ser-elasticsearch-type (:type input)) #:http.request.field{:name "type", :shape "ElasticsearchType"}) (clojure.core/into (ser-elasticsearch-id (:id input)) #:http.request.field{:name "id", :shape "ElasticsearchId"})], :shape "ElasticsearchAction", :type "structure"}))

(clojure.core/defn- ser-s-3-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3Location", :type "structure"} (clojure.core/contains? input :bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket (input :bucket)) #:http.request.field{:name "bucket", :shape "S3Bucket"})) (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key (input :key)) #:http.request.field{:name "key", :shape "S3Key"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-version (input :version)) #:http.request.field{:name "version", :shape "S3Version"}))))

(clojure.core/defn- ser-elasticsearch-index [input] #:http.request.field{:value input, :shape "ElasticsearchIndex"})

(clojure.core/defn- ser-certificate-arn [input] #:http.request.field{:value input, :shape "CertificateArn"})

(clojure.core/defn- ser-custom-code-signing [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CustomCodeSigning", :type "structure"} (clojure.core/contains? input :signature) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-code-signing-signature (input :signature)) #:http.request.field{:name "signature", :shape "CodeSigningSignature"})) (clojure.core/contains? input :certificate-chain) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-code-signing-certificate-chain (input :certificate-chain)) #:http.request.field{:name "certificateChain", :shape "CodeSigningCertificateChain"})) (clojure.core/contains? input :hash-algorithm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-hash-algorithm (input :hash-algorithm)) #:http.request.field{:name "hashAlgorithm", :shape "HashAlgorithm"})) (clojure.core/contains? input :signature-algorithm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signature-algorithm (input :signature-algorithm)) #:http.request.field{:name "signatureAlgorithm", :shape "SignatureAlgorithm"}))))

(clojure.core/defn- ser-set-as-active [input] #:http.request.field{:value input, :shape "SetAsActive"})

(clojure.core/defn- ser-table-name [input] #:http.request.field{:value input, :shape "TableName"})

(clojure.core/defn- ser-s-3-bucket [input] #:http.request.field{:value input, :shape "S3Bucket"})

(clojure.core/defn- ser-billing-group-name [input] #:http.request.field{:value input, :shape "BillingGroupName"})

(clojure.core/defn- ser-aws-iot-sql-version [input] #:http.request.field{:value input, :shape "AwsIotSqlVersion"})

(clojure.core/defn- ser-auth-infos [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-auth-info coll) #:http.request.field{:shape "AuthInfo"}))) input), :shape "AuthInfos", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-stream [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Stream", :type "structure"} (clojure.core/contains? input :stream-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId"})) (clojure.core/contains? input :file-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-id (input :file-id)) #:http.request.field{:name "fileId", :shape "FileId"}))))

(clojure.core/defn- ser-sql [input] #:http.request.field{:value input, :shape "SQL"})

(clojure.core/defn- ser-details-key [input] #:http.request.field{:value input, :shape "DetailsKey"})

(clojure.core/defn- ser-registry-s-3-bucket-name [input] #:http.request.field{:value input, :shape "RegistryS3BucketName"})

(clojure.core/defn- ser-abort-action [input] #:http.request.field{:value (clojure.core/get {"CANCEL" "CANCEL", :cancel "CANCEL"} input), :shape "AbortAction"})

(clojure.core/defn- ser-dynamo-db-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-table-name (:table-name input)) #:http.request.field{:name "tableName", :shape "TableName"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-hash-key-field (:hash-key-field input)) #:http.request.field{:name "hashKeyField", :shape "HashKeyField"}) (clojure.core/into (ser-hash-key-value (:hash-key-value input)) #:http.request.field{:name "hashKeyValue", :shape "HashKeyValue"})], :shape "DynamoDBAction", :type "structure"} (clojure.core/contains? input :range-key-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-range-key-value (input :range-key-value)) #:http.request.field{:name "rangeKeyValue", :shape "RangeKeyValue"})) (clojure.core/contains? input :range-key-field) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-range-key-field (input :range-key-field)) #:http.request.field{:name "rangeKeyField", :shape "RangeKeyField"})) (clojure.core/contains? input :hash-key-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-key-type (input :hash-key-type)) #:http.request.field{:name "hashKeyType", :shape "DynamoKeyType"})) (clojure.core/contains? input :operation) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-operation (input :operation)) #:http.request.field{:name "operation", :shape "DynamoOperation"})) (clojure.core/contains? input :payload-field) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-payload-field (input :payload-field)) #:http.request.field{:name "payloadField", :shape "PayloadField"})) (clojure.core/contains? input :range-key-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-key-type (input :range-key-type)) #:http.request.field{:name "rangeKeyType", :shape "DynamoKeyType"}))))

(clojure.core/defn- ser-policy-version-id [input] #:http.request.field{:value input, :shape "PolicyVersionId"})

(clojure.core/defn- ser-alert-target [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-alert-target-arn (:alert-target-arn input)) #:http.request.field{:name "alertTargetArn", :shape "AlertTargetArn"}) (clojure.core/into (ser-role-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "RoleArn"})], :shape "AlertTarget", :type "structure"}))

(clojure.core/defn- ser-timestamp [input] #:http.request.field{:value input, :shape "Timestamp"})

(clojure.core/defn- ser-dynamo-operation [input] #:http.request.field{:value input, :shape "DynamoOperation"})

(clojure.core/defn- ser-resource-arn [input] #:http.request.field{:value input, :shape "ResourceArn"})

(clojure.core/defn- ser-hash-algorithm [input] #:http.request.field{:value input, :shape "HashAlgorithm"})

(clojure.core/defn- ser-certificate-status [input] #:http.request.field{:value (clojure.core/get {:inactive "INACTIVE", "REGISTER_INACTIVE" "REGISTER_INACTIVE", "REVOKED" "REVOKED", :revoked "REVOKED", :pending-activation "PENDING_ACTIVATION", :register-inactive "REGISTER_INACTIVE", :pending-transfer "PENDING_TRANSFER", :active "ACTIVE", "INACTIVE" "INACTIVE", "PENDING_ACTIVATION" "PENDING_ACTIVATION", "ACTIVE" "ACTIVE", "PENDING_TRANSFER" "PENDING_TRANSFER"} input), :shape "CertificateStatus"})

(clojure.core/defn- ser-policy-version-identifier [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PolicyVersionIdentifier", :type "structure"} (clojure.core/contains? input :policy-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName"})) (clojure.core/contains? input :policy-version-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId"}))))

(clojure.core/defn- ser-authorizer-name [input] #:http.request.field{:value input, :shape "AuthorizerName"})

(clojure.core/defn- ser-maximum-per-minute [input] #:http.request.field{:value input, :shape "MaximumPerMinute"})

(clojure.core/defn- ser-behavior-name [input] #:http.request.field{:value input, :shape "BehaviorName"})

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key (input :key)) #:http.request.field{:name "Key", :shape "TagKey"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value (input :value)) #:http.request.field{:name "Value", :shape "TagValue"}))))

(clojure.core/defn- ser-s-3-destination [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3Destination", :type "structure"} (clojure.core/contains? input :bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket (input :bucket)) #:http.request.field{:name "bucket", :shape "S3Bucket"})) (clojure.core/contains? input :prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-prefix (input :prefix)) #:http.request.field{:name "prefix", :shape "Prefix"}))))

(clojure.core/defn- ser-set-as-default [input] #:http.request.field{:value input, :shape "SetAsDefault"})

(clojure.core/defn- ser-resource [input] #:http.request.field{:value input, :shape "Resource"})

(clojure.core/defn- ser-reason-code [input] #:http.request.field{:value input, :shape "ReasonCode"})

(clojure.core/defn- ser-job-execution-failure-type [input] #:http.request.field{:value (clojure.core/get {"FAILED" "FAILED", :failed "FAILED", "REJECTED" "REJECTED", :rejected "REJECTED", "TIMED_OUT" "TIMED_OUT", :timed-out "TIMED_OUT", "ALL" "ALL", :all "ALL"} input), :shape "JobExecutionFailureType"})

(clojure.core/defn- ser-state-machine-name [input] #:http.request.field{:value input, :shape "StateMachineName"})

(clojure.core/defn- ser-logging-options-payload [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "LoggingOptionsPayload", :type "structure"} (clojure.core/contains? input :log-level) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-level (input :log-level)) #:http.request.field{:name "logLevel", :shape "LogLevel"}))))

(clojure.core/defn- ser-elasticsearch-id [input] #:http.request.field{:value input, :shape "ElasticsearchId"})

(clojure.core/defn- ser-file-id [input] #:http.request.field{:value input, :shape "FileId"})

(clojure.core/defn- ser-salesforce-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-salesforce-token (:token input)) #:http.request.field{:name "token", :shape "SalesforceToken"}) (clojure.core/into (ser-salesforce-endpoint (:url input)) #:http.request.field{:name "url", :shape "SalesforceEndpoint"})], :shape "SalesforceAction", :type "structure"}))

(clojure.core/defn- ser-event-configurations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-event-type k) #:http.request.field{:map-info "key", :shape "EventType"}) (clojure.core/into (ser-configuration v) #:http.request.field{:map-info "value", :shape "Configuration"})])) input), :shape "EventConfigurations", :type "map"})

(clojure.core/defn- ser-salesforce-endpoint [input] #:http.request.field{:value input, :shape "SalesforceEndpoint"})

(clojure.core/defn- ser-step-functions-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-state-machine-name (:state-machine-name input)) #:http.request.field{:name "stateMachineName", :shape "StateMachineName"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "StepFunctionsAction", :type "structure"} (clojure.core/contains? input :execution-name-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-name-prefix (input :execution-name-prefix)) #:http.request.field{:name "executionNamePrefix", :shape "ExecutionNamePrefix"}))))

(clojure.core/defn- ser-ascending-order [input] #:http.request.field{:value input, :shape "AscendingOrder"})

(clojure.core/defn- ser-auth-info [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AuthInfo", :type "structure"} (clojure.core/contains? input :action-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action-type (input :action-type)) #:http.request.field{:name "actionType", :shape "ActionType"})) (clojure.core/contains? input :resources) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resources (input :resources)) #:http.request.field{:name "resources", :shape "Resources"}))))

(clojure.core/defn- ser-target [input] #:http.request.field{:value input, :shape "Target"})

(clojure.core/defn- ser-ge-max-results [input] #:http.request.field{:value input, :shape "GEMaxResults"})

(clojure.core/defn- ser-rollout-rate-per-minute [input] #:http.request.field{:value input, :shape "RolloutRatePerMinute"})

(clojure.core/defn- ser-optional-version [input] #:http.request.field{:value input, :shape "OptionalVersion"})

(clojure.core/defn- ser-action-type [input] #:http.request.field{:value (clojure.core/get {"PUBLISH" "PUBLISH", :publish "PUBLISH", "SUBSCRIBE" "SUBSCRIBE", :subscribe "SUBSCRIBE", "RECEIVE" "RECEIVE", :receive "RECEIVE", "CONNECT" "CONNECT", :connect "CONNECT"} input), :shape "ActionType"})

(clojure.core/defn- ser-thing-group-name [input] #:http.request.field{:value input, :shape "ThingGroupName"})

(clojure.core/defn- ser-principal [input] #:http.request.field{:value input, :shape "Principal"})

(clojure.core/defn- ser-policy-target [input] #:http.request.field{:value input, :shape "PolicyTarget"})

(clojure.core/defn- ser-execution-name-prefix [input] #:http.request.field{:value input, :shape "ExecutionNamePrefix"})

(clojure.core/defn- ser-evaluation-statistic [input] #:http.request.field{:value input, :shape "EvaluationStatistic"})

(clojure.core/defn- ser-scheduled-audit-name [input] #:http.request.field{:value input, :shape "ScheduledAuditName"})

(clojure.core/defn- ser-cloudwatch-alarm-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-alarm-name (:alarm-name input)) #:http.request.field{:name "alarmName", :shape "AlarmName"}) (clojure.core/into (ser-state-reason (:state-reason input)) #:http.request.field{:name "stateReason", :shape "StateReason"}) (clojure.core/into (ser-state-value (:state-value input)) #:http.request.field{:name "stateValue", :shape "StateValue"})], :shape "CloudwatchAlarmAction", :type "structure"}))

(clojure.core/defn- ser-signing-job-id [input] #:http.request.field{:value input, :shape "SigningJobId"})

(clojure.core/defn- ser-lambda-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-function-arn (:function-arn input)) #:http.request.field{:name "functionArn", :shape "FunctionArn"})], :shape "LambdaAction", :type "structure"}))

(clojure.core/defn- ser-bucket-name [input] #:http.request.field{:value input, :shape "BucketName"})

(clojure.core/defn- ser-certificate-id [input] #:http.request.field{:value input, :shape "CertificateId"})

(clojure.core/defn- ser-ota-update-status [input] #:http.request.field{:value (clojure.core/get {"CREATE_PENDING" "CREATE_PENDING", :create-pending "CREATE_PENDING", "CREATE_IN_PROGRESS" "CREATE_IN_PROGRESS", :create-in-progress "CREATE_IN_PROGRESS", "CREATE_COMPLETE" "CREATE_COMPLETE", :create-complete "CREATE_COMPLETE", "CREATE_FAILED" "CREATE_FAILED", :create-failed "CREATE_FAILED"} input), :shape "OTAUpdateStatus"})

(clojure.core/defn- ser-certificate-pem [input] #:http.request.field{:value input, :shape "CertificatePem"})

(clojure.core/defn- ser-file-name [input] #:http.request.field{:value input, :shape "FileName"})

(clojure.core/defn- ser-ota-update-id [input] #:http.request.field{:value input, :shape "OTAUpdateId"})

(clojure.core/defn- ser-action [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Action", :type "structure"} (clojure.core/contains? input :dynamo-db) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-db-action (input :dynamo-db)) #:http.request.field{:name "dynamoDB", :shape "DynamoDBAction"})) (clojure.core/contains? input :sns) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sns-action (input :sns)) #:http.request.field{:name "sns", :shape "SnsAction"})) (clojure.core/contains? input :cloudwatch-alarm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloudwatch-alarm-action (input :cloudwatch-alarm)) #:http.request.field{:name "cloudwatchAlarm", :shape "CloudwatchAlarmAction"})) (clojure.core/contains? input :iot-analytics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iot-analytics-action (input :iot-analytics)) #:http.request.field{:name "iotAnalytics", :shape "IotAnalyticsAction"})) (clojure.core/contains? input :republish) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-republish-action (input :republish)) #:http.request.field{:name "republish", :shape "RepublishAction"})) (clojure.core/contains? input :kinesis) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-kinesis-action (input :kinesis)) #:http.request.field{:name "kinesis", :shape "KinesisAction"})) (clojure.core/contains? input :s-3) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-action (input :s-3)) #:http.request.field{:name "s3", :shape "S3Action"})) (clojure.core/contains? input :salesforce) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-salesforce-action (input :salesforce)) #:http.request.field{:name "salesforce", :shape "SalesforceAction"})) (clojure.core/contains? input :sqs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sqs-action (input :sqs)) #:http.request.field{:name "sqs", :shape "SqsAction"})) (clojure.core/contains? input :elasticsearch) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-elasticsearch-action (input :elasticsearch)) #:http.request.field{:name "elasticsearch", :shape "ElasticsearchAction"})) (clojure.core/contains? input :cloudwatch-metric) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloudwatch-metric-action (input :cloudwatch-metric)) #:http.request.field{:name "cloudwatchMetric", :shape "CloudwatchMetricAction"})) (clojure.core/contains? input :firehose) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-firehose-action (input :firehose)) #:http.request.field{:name "firehose", :shape "FirehoseAction"})) (clojure.core/contains? input :dynamo-d-bv-2) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-d-bv-2-action (input :dynamo-d-bv-2)) #:http.request.field{:name "dynamoDBv2", :shape "DynamoDBv2Action"})) (clojure.core/contains? input :lambda) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-lambda-action (input :lambda)) #:http.request.field{:name "lambda", :shape "LambdaAction"})) (clojure.core/contains? input :step-functions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-step-functions-action (input :step-functions)) #:http.request.field{:name "stepFunctions", :shape "StepFunctionsAction"})) (clojure.core/contains? input :iot-events) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iot-events-action (input :iot-events)) #:http.request.field{:name "iotEvents", :shape "IotEventsAction"}))))

(clojure.core/defn- ser-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Configuration", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-enabled (input :enabled)) #:http.request.field{:name "Enabled", :shape "Enabled"}))))

(clojure.core/defn- ser-token [input] #:http.request.field{:value input, :shape "Token"})

(clojure.core/defn- ser-increment-factor [input] #:http.request.field{:value input, :shape "IncrementFactor"})

(clojure.core/defn- ser-job-description [input] #:http.request.field{:value input, :shape "JobDescription"})

(clojure.core/defn- ser-state-reason [input] #:http.request.field{:value input, :shape "StateReason"})

(clojure.core/defn- ser-elasticsearch-endpoint [input] #:http.request.field{:value input, :shape "ElasticsearchEndpoint"})

(clojure.core/defn- ser-signing-profile-name [input] #:http.request.field{:value input, :shape "SigningProfileName"})

(clojure.core/defn- ser-details-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-details-key k) #:http.request.field{:map-info "key", :shape "DetailsKey"}) (clojure.core/into (ser-details-value v) #:http.request.field{:map-info "value", :shape "DetailsValue"})])) input), :shape "DetailsMap", :type "map"})

(clojure.core/defn- ser-consecutive-datapoints-to-clear [input] #:http.request.field{:value input, :shape "ConsecutiveDatapointsToClear"})

(clojure.core/defn- ser-force-delete [input] #:http.request.field{:value input, :shape "ForceDelete"})

(clojure.core/defn- ser-recursive [input] #:http.request.field{:value input, :shape "Recursive"})

(clojure.core/defn- ser-audit-check-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AuditCheckConfiguration", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-enabled (input :enabled)) #:http.request.field{:name "enabled", :shape "Enabled"}))))

(clojure.core/defn- ser-audit-task-status [input] #:http.request.field{:value (clojure.core/get {"IN_PROGRESS" "IN_PROGRESS", :in-progress "IN_PROGRESS", "COMPLETED" "COMPLETED", :completed "COMPLETED", "FAILED" "FAILED", :failed "FAILED", "CANCELED" "CANCELED", :canceled "CANCELED"} input), :shape "AuditTaskStatus"})

(clojure.core/defn- ser-s-3-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-bucket-name (:bucket-name input)) #:http.request.field{:name "bucketName", :shape "BucketName"}) (clojure.core/into (ser-key (:key input)) #:http.request.field{:name "key", :shape "Key"})], :shape "S3Action", :type "structure"} (clojure.core/contains? input :canned-acl) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-canned-access-control-list (input :canned-acl)) #:http.request.field{:name "cannedAcl", :shape "CannedAccessControlList"}))))

(clojure.core/defn- ser-iot-analytics-action [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "IotAnalyticsAction", :type "structure"} (clojure.core/contains? input :channel-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-arn (input :channel-arn)) #:http.request.field{:name "channelArn", :shape "AwsArn"})) (clojure.core/contains? input :channel-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-channel-name (input :channel-name)) #:http.request.field{:name "channelName", :shape "ChannelName"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "AwsArn"}))))

(clojure.core/defn- ser-kinesis-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-stream-name (:stream-name input)) #:http.request.field{:name "streamName", :shape "StreamName"})], :shape "KinesisAction", :type "structure"} (clojure.core/contains? input :partition-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-partition-key (input :partition-key)) #:http.request.field{:name "partitionKey", :shape "PartitionKey"}))))

(clojure.core/defn- ser-query-max-results [input] #:http.request.field{:value input, :shape "QueryMaxResults"})

(clojure.core/defn- ser-audit-task-id [input] #:http.request.field{:value input, :shape "AuditTaskId"})

(clojure.core/defn- ser-thing-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-thing-group-name coll) #:http.request.field{:shape "ThingGroupName"}))) input), :shape "ThingGroupList", :type "list"})

(clojure.core/defn- ser-payload-field [input] #:http.request.field{:value input, :shape "PayloadField"})

(clojure.core/defn- ser-authorizer-function-arn [input] #:http.request.field{:value input, :shape "AuthorizerFunctionArn"})

(clojure.core/defn- ser-firehose-separator [input] #:http.request.field{:value input, :shape "FirehoseSeparator"})

(clojure.core/defn- ser-job-id [input] #:http.request.field{:value input, :shape "JobId"})

(clojure.core/defn- req-start-on-demand-audit-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-target-audit-check-names (input :target-check-names)) #:http.request.field{:name "targetCheckNames", :shape "TargetAuditCheckNames"})]}))

(clojure.core/defn- req-accept-certificate-transfer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"}))))

(clojure.core/defn- req-delete-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-update-dynamic-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})], :body [(clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"})) (clojure.core/contains? input :index-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName"})) (clojure.core/contains? input :query-string) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-string (input :query-string)) #:http.request.field{:name "queryString", :shape "QueryString"})) (clojure.core/contains? input :query-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-version (input :query-version)) #:http.request.field{:name "queryVersion", :shape "QueryVersion"}))))

(clojure.core/defn- req-list-violation-events-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-timestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "Timestamp", :location "querystring", :location-name "startTime"}) (clojure.core/into (ser-timestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "Timestamp", :location "querystring", :location-name "endTime"})]} (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "querystring", :location-name "thingName"})) (clojure.core/contains? input :security-profile-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "querystring", :location-name "securityProfileName"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-authorizers-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-status (input :status)) #:http.request.field{:name "status", :shape "AuthorizerStatus", :location "querystring", :location-name "status"}))))

(clojure.core/defn- req-delete-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-deprecate-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]} (clojure.core/contains? input :undo-deprecate) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-undo-deprecate (input :undo-deprecate)) #:http.request.field{:name "undoDeprecate", :shape "UndoDeprecate"}))))

(clojure.core/defn- req-detach-principal-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-iot-principal"})]}))

(clojure.core/defn- req-list-things-in-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-test-invoke-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})], :body [(clojure.core/into (ser-token (input :token)) #:http.request.field{:name "token", :shape "Token"}) (clojure.core/into (ser-token-signature (input :token-signature)) #:http.request.field{:name "tokenSignature", :shape "TokenSignature"})]}))

(clojure.core/defn- req-register-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-certificate-pem (input :certificate-pem)) #:http.request.field{:name "certificatePem", :shape "CertificatePem"})]} (clojure.core/contains? input :ca-certificate-pem) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-pem (input :ca-certificate-pem)) #:http.request.field{:name "caCertificatePem", :shape "CertificatePem"})) (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active-flag (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActiveFlag", :deprecated true, :location "querystring", :location-name "setAsActive"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-status (input :status)) #:http.request.field{:name "status", :shape "CertificateStatus"}))))

(clojure.core/defn- req-create-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName"})) (clojure.core/contains? input :attribute-payload) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-payload (input :attribute-payload)) #:http.request.field{:name "attributePayload", :shape "AttributePayload"})) (clojure.core/contains? input :billing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName"}))))

(clojure.core/defn- req-list-ota-updates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :ota-update-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ota-update-status (input :ota-update-status)) #:http.request.field{:name "otaUpdateStatus", :shape "OTAUpdateStatus", :location "querystring", :location-name "otaUpdateStatus"}))))

(clojure.core/defn- req-transfer-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})], :querystring [(clojure.core/into (ser-aws-account-id (input :target-aws-account)) #:http.request.field{:name "targetAwsAccount", :shape "AwsAccountId", :location "querystring", :location-name "targetAwsAccount"})]} (clojure.core/contains? input :transfer-message) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :transfer-message)) #:http.request.field{:name "transferMessage", :shape "Message"}))))

(clojure.core/defn- req-update-event-configurations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :event-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-configurations (input :event-configurations)) #:http.request.field{:name "eventConfigurations", :shape "EventConfigurations"}))))

(clojure.core/defn- req-update-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})], :querystring [(clojure.core/into (ser-certificate-status (input :new-status)) #:http.request.field{:name "newStatus", :shape "CertificateStatus", :location "querystring", :location-name "newStatus"})]}))

(clojure.core/defn- req-list-billing-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :name-prefix-filter) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :name-prefix-filter)) #:http.request.field{:name "namePrefixFilter", :shape "BillingGroupName", :location "querystring", :location-name "namePrefixFilter"}))))

(clojure.core/defn- req-get-v-2-logging-options-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-create-keys-and-certificate-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"}))))

(clojure.core/defn- req-update-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]} (clojure.core/contains? input :new-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ca-certificate-status (input :new-status)) #:http.request.field{:name "newStatus", :shape "CACertificateStatus", :location "querystring", :location-name "newStatus"})) (clojure.core/contains? input :new-auto-registration-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-auto-registration-status (input :new-auto-registration-status)) #:http.request.field{:name "newAutoRegistrationStatus", :shape "AutoRegistrationStatus", :location "querystring", :location-name "newAutoRegistrationStatus"})) (clojure.core/contains? input :registration-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registration-config (input :registration-config)) #:http.request.field{:name "registrationConfig", :shape "RegistrationConfig"})) (clojure.core/contains? input :remove-auto-registration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-remove-auto-registration (input :remove-auto-registration)) #:http.request.field{:name "removeAutoRegistration", :shape "RemoveAutoRegistration"}))))

(clojure.core/defn- req-search-index-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-query-string (input :query-string)) #:http.request.field{:name "queryString", :shape "QueryString"})]} (clojure.core/contains? input :index-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "QueryMaxResults"})) (clojure.core/contains? input :query-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-version (input :query-version)) #:http.request.field{:name "queryVersion", :shape "QueryVersion"}))))

(clojure.core/defn- req-describe-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]}))

(clojure.core/defn- req-list-topic-rules-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :topic) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-topic (input :topic)) #:http.request.field{:name "topic", :shape "Topic", :location "querystring", :location-name "topic"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ge-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "GEMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :rule-disabled) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-is-disabled (input :rule-disabled)) #:http.request.field{:name "ruleDisabled", :shape "IsDisabled", :location "querystring", :location-name "ruleDisabled"}))))

(clojure.core/defn- req-list-outgoing-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-list-principal-policies-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-iot-principal"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-set-default-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"}) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId", :location "uri", :location-name "policyVersionId"})]}))

(clojure.core/defn- req-describe-default-authorizer-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-enable-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-create-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})], :body [(clojure.core/into (ser-stream-files (input :files)) #:http.request.field{:name "files", :shape "StreamFiles"}) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-description (input :description)) #:http.request.field{:name "description", :shape "StreamDescription"}))))

(clojure.core/defn- req-reject-certificate-transfer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]} (clojure.core/contains? input :reject-reason) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :reject-reason)) #:http.request.field{:name "rejectReason", :shape "Message"}))))

(clojure.core/defn- req-list-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-describe-audit-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-audit-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "AuditTaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-describe-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]}))

(clojure.core/defn- req-list-jobs-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-status (input :status)) #:http.request.field{:name "status", :shape "JobStatus", :location "querystring", :location-name "status"})) (clojure.core/contains? input :target-selection) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-selection (input :target-selection)) #:http.request.field{:name "targetSelection", :shape "TargetSelection", :location "querystring", :location-name "targetSelection"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-laser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "LaserMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :thing-group-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "querystring", :location-name "thingGroupName"})) (clojure.core/contains? input :thing-group-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-id (input :thing-group-id)) #:http.request.field{:name "thingGroupId", :shape "ThingGroupId", :location "querystring", :location-name "thingGroupId"}))))

(clojure.core/defn- req-list-tags-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-resource-arn (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "ResourceArn", :location "querystring", :location-name "resourceArn"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-attach-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-target (input :target)) #:http.request.field{:name "target", :shape "PolicyTarget"})]}))

(clojure.core/defn- req-describe-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]}))

(clojure.core/defn- req-delete-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-create-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :parent-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :parent-group-name)) #:http.request.field{:name "parentGroupName", :shape "ThingGroupName"})) (clojure.core/contains? input :thing-group-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]}))

(clojure.core/defn- req-update-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})], :body [(clojure.core/into (ser-billing-group-properties (input :billing-group-properties)) #:http.request.field{:name "billingGroupProperties", :shape "BillingGroupProperties"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"}))))

(clojure.core/defn- req-describe-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]}))

(clojure.core/defn- req-set-v-2-logging-options-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "AwsArn"})) (clojure.core/contains? input :default-log-level) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-level (input :default-log-level)) #:http.request.field{:name "defaultLogLevel", :shape "LogLevel"})) (clojure.core/contains? input :disable-all-logs) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-disable-all-logs (input :disable-all-logs)) #:http.request.field{:name "disableAllLogs", :shape "DisableAllLogs"}))))

(clojure.core/defn- req-list-thing-types-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "querystring", :location-name "thingTypeName"}))))

(clojure.core/defn- req-delete-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-create-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})], :body [(clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]} (clojure.core/contains? input :credential-duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-credential-duration-seconds (input :credential-duration-seconds)) #:http.request.field{:name "credentialDurationSeconds", :shape "CredentialDurationSeconds"}))))

(clojure.core/defn- req-update-indexing-configuration-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-indexing-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-indexing-configuration (input :thing-indexing-configuration)) #:http.request.field{:name "thingIndexingConfiguration", :shape "ThingIndexingConfiguration"})) (clojure.core/contains? input :thing-group-indexing-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-indexing-configuration (input :thing-group-indexing-configuration)) #:http.request.field{:name "thingGroupIndexingConfiguration", :shape "ThingGroupIndexingConfiguration"}))))

(clojure.core/defn- req-update-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-description (input :description)) #:http.request.field{:name "description", :shape "StreamDescription"})) (clojure.core/contains? input :files) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-files (input :files)) #:http.request.field{:name "files", :shape "StreamFiles"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"}))))

(clojure.core/defn- req-detach-thing-principal-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-principal"})]}))

(clojure.core/defn- req-list-indices-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "QueryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-thing-groups-for-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-attach-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})], :querystring [(clojure.core/into (ser-security-profile-target-arn (input :security-profile-target-arn)) #:http.request.field{:name "securityProfileTargetArn", :shape "SecurityProfileTargetArn", :location "querystring", :location-name "securityProfileTargetArn"})]}))

(clojure.core/defn- req-cancel-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :reason-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reason-code (input :reason-code)) #:http.request.field{:name "reasonCode", :shape "ReasonCode"})) (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "comment", :shape "Comment"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"}))))

(clojure.core/defn- req-create-certificate-from-csr-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-certificate-signing-request (input :certificate-signing-request)) #:http.request.field{:name "certificateSigningRequest", :shape "CertificateSigningRequest"})]} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"}))))

(clojure.core/defn- req-create-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :security-profile-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-description (input :security-profile-description)) #:http.request.field{:name "securityProfileDescription", :shape "SecurityProfileDescription"})) (clojure.core/contains? input :behaviors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behaviors (input :behaviors)) #:http.request.field{:name "behaviors", :shape "Behaviors"})) (clojure.core/contains? input :alert-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-alert-targets (input :alert-targets)) #:http.request.field{:name "alertTargets", :shape "AlertTargets"})) (clojure.core/contains? input :additional-metrics-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-additional-metrics-to-retain-list (input :additional-metrics-to-retain)) #:http.request.field{:name "additionalMetricsToRetain", :shape "AdditionalMetricsToRetainList"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-list-active-violations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "querystring", :location-name "thingName"})) (clojure.core/contains? input :security-profile-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "querystring", :location-name "securityProfileName"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-cancel-job-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"}) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"})) (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-expected-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "ExpectedVersion"})) (clojure.core/contains? input :status-details) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-details-map (input :status-details)) #:http.request.field{:name "statusDetails", :shape "DetailsMap"}))))

(clojure.core/defn- req-list-thing-principals-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]}))

(clojure.core/defn- req-describe-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})]}))

(clojure.core/defn- req-delete-dynamic-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-delete-registration-code-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-delete-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]}))

(clojure.core/defn- req-describe-index-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName", :location "uri", :location-name "indexName"})]}))

(clojure.core/defn- req-get-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-create-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-document (input :policy-document)) #:http.request.field{:name "policyDocument", :shape "PolicyDocument"})]}))

(clojure.core/defn- req-attach-principal-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-iot-principal"})]}))

(clojure.core/defn- req-create-dynamic-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})], :body [(clojure.core/into (ser-query-string (input :query-string)) #:http.request.field{:name "queryString", :shape "QueryString"})]} (clojure.core/contains? input :thing-group-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})) (clojure.core/contains? input :index-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName"})) (clojure.core/contains? input :query-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-version (input :query-version)) #:http.request.field{:name "queryVersion", :shape "QueryVersion"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-list-scheduled-audits-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-delete-ota-update-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-ota-update-id (input :ota-update-id)) #:http.request.field{:name "otaUpdateId", :shape "OTAUpdateId", :location "uri", :location-name "otaUpdateId"})]} (clojure.core/contains? input :delete-stream) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-stream (input :delete-stream)) #:http.request.field{:name "deleteStream", :shape "DeleteStream", :location "querystring", :location-name "deleteStream"})) (clojure.core/contains? input :force-delete-aws-job) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-delete-aws-job (input :force-delete-aws-job)) #:http.request.field{:name "forceDeleteAWSJob", :shape "ForceDeleteAWSJob", :location "querystring", :location-name "forceDeleteAWSJob"}))))

(clojure.core/defn- req-list-thing-registration-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-status (input :status)) #:http.request.field{:name "status", :shape "Status", :location "querystring", :location-name "status"}))))

(clojure.core/defn- req-delete-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})]}))

(clojure.core/defn- req-list-security-profiles-for-target-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-security-profile-target-arn (input :security-profile-target-arn)) #:http.request.field{:name "securityProfileTargetArn", :shape "SecurityProfileTargetArn", :location "querystring", :location-name "securityProfileTargetArn"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive (input :recursive)) #:http.request.field{:name "recursive", :shape "Recursive", :location "querystring", :location-name "recursive"}))))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-arn (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "ResourceArn"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})]}))

(clojure.core/defn- req-register-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-template-body (input :template-body)) #:http.request.field{:name "templateBody", :shape "TemplateBody"})]} (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "parameters", :shape "Parameters"}))))

(clojure.core/defn- req-list-targets-for-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"}))))

(clojure.core/defn- req-list-streams-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-stop-thing-registration-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "TaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-list-audit-findings-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :task-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "AuditTaskId"})) (clojure.core/contains? input :check-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-check-name (input :check-name)) #:http.request.field{:name "checkName", :shape "AuditCheckName"})) (clojure.core/contains? input :resource-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-identifier (input :resource-identifier)) #:http.request.field{:name "resourceIdentifier", :shape "ResourceIdentifier"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "Timestamp"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "Timestamp"}))))

(clojure.core/defn- req-list-role-aliases-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-describe-job-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"}) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :execution-number) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-number (input :execution-number)) #:http.request.field{:name "executionNumber", :shape "ExecutionNumber", :location "querystring", :location-name "executionNumber"}))))

(clojure.core/defn- req-describe-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]}))

(clojure.core/defn- req-create-ota-update-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-ota-update-id (input :ota-update-id)) #:http.request.field{:name "otaUpdateId", :shape "OTAUpdateId", :location "uri", :location-name "otaUpdateId"})], :body [(clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "targets", :shape "Targets"}) (clojure.core/into (ser-ota-update-files (input :files)) #:http.request.field{:name "files", :shape "OTAUpdateFiles"}) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ota-update-description (input :description)) #:http.request.field{:name "description", :shape "OTAUpdateDescription"})) (clojure.core/contains? input :target-selection) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-selection (input :target-selection)) #:http.request.field{:name "targetSelection", :shape "TargetSelection"})) (clojure.core/contains? input :aws-job-executions-rollout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-job-executions-rollout-config (input :aws-job-executions-rollout-config)) #:http.request.field{:name "awsJobExecutionsRolloutConfig", :shape "AwsJobExecutionsRolloutConfig"})) (clojure.core/contains? input :additional-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-additional-parameter-map (input :additional-parameters)) #:http.request.field{:name "additionalParameters", :shape "AdditionalParameterMap"}))))

(clojure.core/defn- req-delete-v-2-logging-level-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-log-target-type (input :target-type)) #:http.request.field{:name "targetType", :shape "LogTargetType", :location "querystring", :location-name "targetType"}) (clojure.core/into (ser-log-target-name (input :target-name)) #:http.request.field{:name "targetName", :shape "LogTargetName", :location "querystring", :location-name "targetName"})]}))

(clojure.core/defn- req-list-ca-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-delete-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]} (clojure.core/contains? input :force-delete) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-delete (input :force-delete)) #:http.request.field{:name "forceDelete", :shape "ForceDelete", :location "querystring", :location-name "forceDelete"}))))

(clojure.core/defn- req-cancel-certificate-transfer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]}))

(clojure.core/defn- req-get-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]}))

(clojure.core/defn- req-create-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})], :body [(clojure.core/into (ser-job-targets (input :targets)) #:http.request.field{:name "targets", :shape "JobTargets"})]} (clojure.core/contains? input :target-selection) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-selection (input :target-selection)) #:http.request.field{:name "targetSelection", :shape "TargetSelection"})) (clojure.core/contains? input :timeout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-config (input :timeout-config)) #:http.request.field{:name "timeoutConfig", :shape "TimeoutConfig"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})) (clojure.core/contains? input :document) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-document (input :document)) #:http.request.field{:name "document", :shape "JobDocument"})) (clojure.core/contains? input :abort-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-abort-config (input :abort-config)) #:http.request.field{:name "abortConfig", :shape "AbortConfig"})) (clojure.core/contains? input :document-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-document-source (input :document-source)) #:http.request.field{:name "documentSource", :shape "JobDocumentSource"})) (clojure.core/contains? input :presigned-url-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-presigned-url-config (input :presigned-url-config)) #:http.request.field{:name "presignedUrlConfig", :shape "PresignedUrlConfig"})) (clojure.core/contains? input :job-executions-rollout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-executions-rollout-config (input :job-executions-rollout-config)) #:http.request.field{:name "jobExecutionsRolloutConfig", :shape "JobExecutionsRolloutConfig"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-description (input :description)) #:http.request.field{:name "description", :shape "JobDescription"}))))

(clojure.core/defn- req-get-logging-options-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-describe-event-configurations-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-describe-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})]}))

(clojure.core/defn- req-delete-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]}))

(clojure.core/defn- req-delete-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]}))

(clojure.core/defn- req-delete-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"}) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId", :location "uri", :location-name "policyVersionId"})]}))

(clojure.core/defn- req-list-attached-policies-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-target (input :target)) #:http.request.field{:name "target", :shape "PolicyTarget", :location "uri", :location-name "target"})]} (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive (input :recursive)) #:http.request.field{:name "recursive", :shape "Recursive", :location "querystring", :location-name "recursive"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"}))))

(clojure.core/defn- req-set-default-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName"})]}))

(clojure.core/defn- req-describe-account-audit-configuration-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-remove-thing-from-thing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName"})) (clojure.core/contains? input :thing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-arn (input :thing-group-arn)) #:http.request.field{:name "thingGroupArn", :shape "ThingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"}))))

(clojure.core/defn- req-list-thing-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :parent-group) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :parent-group)) #:http.request.field{:name "parentGroup", :shape "ThingGroupName", :location "querystring", :location-name "parentGroup"})) (clojure.core/contains? input :name-prefix-filter) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :name-prefix-filter)) #:http.request.field{:name "namePrefixFilter", :shape "ThingGroupName", :location "querystring", :location-name "namePrefixFilter"})) (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive-without-default (input :recursive)) #:http.request.field{:name "recursive", :shape "RecursiveWithoutDefault", :location "querystring", :location-name "recursive"}))))

(clojure.core/defn- req-remove-thing-from-billing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :billing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName"})) (clojure.core/contains? input :billing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-arn (input :billing-group-arn)) #:http.request.field{:name "billingGroupArn", :shape "BillingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"}))))

(clojure.core/defn- req-attach-thing-principal-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-principal"})]}))

(clojure.core/defn- req-delete-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]}))

(clojure.core/defn- req-list-policy-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]}))

(clojure.core/defn- req-get-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"}) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId", :location "uri", :location-name "policyVersionId"})]}))

(clojure.core/defn- req-list-principal-things-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-principal"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-endpoint-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :endpoint-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-type (input :endpoint-type)) #:http.request.field{:name "endpointType", :shape "EndpointType", :location "querystring", :location-name "endpointType"}))))

(clojure.core/defn- req-list-targets-for-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-certificates-by-ca-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :ca-certificate-id)) #:http.request.field{:name "caCertificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-update-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :delete-behaviors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-behaviors (input :delete-behaviors)) #:http.request.field{:name "deleteBehaviors", :shape "DeleteBehaviors"})) (clojure.core/contains? input :additional-metrics-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-additional-metrics-to-retain-list (input :additional-metrics-to-retain)) #:http.request.field{:name "additionalMetricsToRetain", :shape "AdditionalMetricsToRetainList"})) (clojure.core/contains? input :behaviors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behaviors (input :behaviors)) #:http.request.field{:name "behaviors", :shape "Behaviors"})) (clojure.core/contains? input :security-profile-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-description (input :security-profile-description)) #:http.request.field{:name "securityProfileDescription", :shape "SecurityProfileDescription"})) (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"})) (clojure.core/contains? input :delete-alert-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-alert-targets (input :delete-alert-targets)) #:http.request.field{:name "deleteAlertTargets", :shape "DeleteAlertTargets"})) (clojure.core/contains? input :delete-additional-metrics-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-additional-metrics-to-retain (input :delete-additional-metrics-to-retain)) #:http.request.field{:name "deleteAdditionalMetricsToRetain", :shape "DeleteAdditionalMetricsToRetain"})) (clojure.core/contains? input :alert-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-alert-targets (input :alert-targets)) #:http.request.field{:name "alertTargets", :shape "AlertTargets"}))))

(clojure.core/defn- req-delete-account-audit-configuration-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :delete-scheduled-audits) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-scheduled-audits (input :delete-scheduled-audits)) #:http.request.field{:name "deleteScheduledAudits", :shape "DeleteScheduledAudits", :location "querystring", :location-name "deleteScheduledAudits"}))))

(clojure.core/defn- req-get-ota-update-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-ota-update-id (input :ota-update-id)) #:http.request.field{:name "otaUpdateId", :shape "OTAUpdateId", :location "uri", :location-name "otaUpdateId"})]}))

(clojure.core/defn- req-clear-default-authorizer-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-register-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-certificate-pem (input :ca-certificate)) #:http.request.field{:name "caCertificate", :shape "CertificatePem"}) (clojure.core/into (ser-certificate-pem (input :verification-certificate)) #:http.request.field{:name "verificationCertificate", :shape "CertificatePem"})]} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"})) (clojure.core/contains? input :allow-auto-registration) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allow-auto-registration (input :allow-auto-registration)) #:http.request.field{:name "allowAutoRegistration", :shape "AllowAutoRegistration", :location "querystring", :location-name "allowAutoRegistration"})) (clojure.core/contains? input :registration-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registration-config (input :registration-config)) #:http.request.field{:name "registrationConfig", :shape "RegistrationConfig"}))))

(clojure.core/defn- req-list-policies-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-describe-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]}))

(clojure.core/defn- req-create-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})], :body [(clojure.core/into (ser-authorizer-function-arn (input :authorizer-function-arn)) #:http.request.field{:name "authorizerFunctionArn", :shape "AuthorizerFunctionArn"}) (clojure.core/into (ser-token-key-name (input :token-key-name)) #:http.request.field{:name "tokenKeyName", :shape "TokenKeyName"}) (clojure.core/into (ser-public-key-map (input :token-signing-public-keys)) #:http.request.field{:name "tokenSigningPublicKeys", :shape "PublicKeyMap"})]} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-status (input :status)) #:http.request.field{:name "status", :shape "AuthorizerStatus"}))))

(clojure.core/defn- req-set-v-2-logging-level-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-log-target (input :log-target)) #:http.request.field{:name "logTarget", :shape "LogTarget"}) (clojure.core/into (ser-log-level (input :log-level)) #:http.request.field{:name "logLevel", :shape "LogLevel"})]}))

(clojure.core/defn- req-get-job-document-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]}))

(clojure.core/defn- req-describe-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})]}))

(clojure.core/defn- req-disable-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-detach-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})], :querystring [(clojure.core/into (ser-security-profile-target-arn (input :security-profile-target-arn)) #:http.request.field{:name "securityProfileTargetArn", :shape "SecurityProfileTargetArn", :location "querystring", :location-name "securityProfileTargetArn"})]}))

(clojure.core/defn- req-list-job-executions-for-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-execution-status (input :status)) #:http.request.field{:name "status", :shape "JobExecutionStatus", :location "querystring", :location-name "status"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-laser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "LaserMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-update-thing-groups-for-thing-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-groups-to-add) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-list (input :thing-groups-to-add)) #:http.request.field{:name "thingGroupsToAdd", :shape "ThingGroupList"})) (clojure.core/contains? input :thing-groups-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-list (input :thing-groups-to-remove)) #:http.request.field{:name "thingGroupsToRemove", :shape "ThingGroupList"})) (clojure.core/contains? input :override-dynamic-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-override-dynamic-groups (input :override-dynamic-groups)) #:http.request.field{:name "overrideDynamicGroups", :shape "OverrideDynamicGroups"}))))

(clojure.core/defn- req-create-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-audit-frequency (input :frequency)) #:http.request.field{:name "frequency", :shape "AuditFrequency"}) (clojure.core/into (ser-target-audit-check-names (input :target-check-names)) #:http.request.field{:name "targetCheckNames", :shape "TargetAuditCheckNames"})], :uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]} (clojure.core/contains? input :day-of-month) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-month (input :day-of-month)) #:http.request.field{:name "dayOfMonth", :shape "DayOfMonth"})) (clojure.core/contains? input :day-of-week) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-week (input :day-of-week)) #:http.request.field{:name "dayOfWeek", :shape "DayOfWeek"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-update-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName"})) (clojure.core/contains? input :attribute-payload) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-payload (input :attribute-payload)) #:http.request.field{:name "attributePayload", :shape "AttributePayload"})) (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"})) (clojure.core/contains? input :remove-thing-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-remove-thing-type (input :remove-thing-type)) #:http.request.field{:name "removeThingType", :shape "RemoveThingType"}))))

(clojure.core/defn- req-describe-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]}))

(clojure.core/defn- req-test-authorization-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-auth-infos (input :auth-infos)) #:http.request.field{:name "authInfos", :shape "AuthInfos"})]} (clojure.core/contains? input :principal) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal"})) (clojure.core/contains? input :cognito-identity-pool-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cognito-identity-pool-id (input :cognito-identity-pool-id)) #:http.request.field{:name "cognitoIdentityPoolId", :shape "CognitoIdentityPoolId"})) (clojure.core/contains? input :client-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-id (input :client-id)) #:http.request.field{:name "clientId", :shape "ClientId", :location "querystring", :location-name "clientId"})) (clojure.core/contains? input :policy-names-to-add) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-names (input :policy-names-to-add)) #:http.request.field{:name "policyNamesToAdd", :shape "PolicyNames"})) (clojure.core/contains? input :policy-names-to-skip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-names (input :policy-names-to-skip)) #:http.request.field{:name "policyNamesToSkip", :shape "PolicyNames"}))))

(clojure.core/defn- req-list-policy-principals-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "header", :location-name "x-amzn-iot-policy"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-validate-security-profile-behaviors-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-behaviors (input :behaviors)) #:http.request.field{:name "behaviors", :shape "Behaviors"})]}))

(clojure.core/defn- req-detach-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-target (input :target)) #:http.request.field{:name "target", :shape "PolicyTarget"})]}))

(clojure.core/defn- req-add-thing-to-thing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName"})) (clojure.core/contains? input :thing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-arn (input :thing-group-arn)) #:http.request.field{:name "thingGroupArn", :shape "ThingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"})) (clojure.core/contains? input :override-dynamic-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-override-dynamic-groups (input :override-dynamic-groups)) #:http.request.field{:name "overrideDynamicGroups", :shape "OverrideDynamicGroups"}))))

(clojure.core/defn- req-update-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-description (input :description)) #:http.request.field{:name "description", :shape "JobDescription"})) (clojure.core/contains? input :presigned-url-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-presigned-url-config (input :presigned-url-config)) #:http.request.field{:name "presignedUrlConfig", :shape "PresignedUrlConfig"})) (clojure.core/contains? input :job-executions-rollout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-executions-rollout-config (input :job-executions-rollout-config)) #:http.request.field{:name "jobExecutionsRolloutConfig", :shape "JobExecutionsRolloutConfig"})) (clojure.core/contains? input :abort-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-abort-config (input :abort-config)) #:http.request.field{:name "abortConfig", :shape "AbortConfig"})) (clojure.core/contains? input :timeout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-config (input :timeout-config)) #:http.request.field{:name "timeoutConfig", :shape "TimeoutConfig"}))))

(clojure.core/defn- req-list-things-in-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive (input :recursive)) #:http.request.field{:name "recursive", :shape "Recursive", :location "querystring", :location-name "recursive"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-delete-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"}))))

(clojure.core/defn- req-cancel-audit-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-audit-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "AuditTaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-list-audit-tasks-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-timestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "Timestamp", :location "querystring", :location-name "startTime"}) (clojure.core/into (ser-timestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "Timestamp", :location "querystring", :location-name "endTime"})]} (clojure.core/contains? input :task-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-task-type (input :task-type)) #:http.request.field{:name "taskType", :shape "AuditTaskType", :location "querystring", :location-name "taskType"})) (clojure.core/contains? input :task-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-task-status (input :task-status)) #:http.request.field{:name "taskStatus", :shape "AuditTaskStatus", :location "querystring", :location-name "taskStatus"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]}))

(clojure.core/defn- req-update-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})], :body [(clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"}))))

(clojure.core/defn- req-add-thing-to-billing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :billing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName"})) (clojure.core/contains? input :billing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-arn (input :billing-group-arn)) #:http.request.field{:name "billingGroupArn", :shape "BillingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"}))))

(clojure.core/defn- req-start-thing-registration-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-template-body (input :template-body)) #:http.request.field{:name "templateBody", :shape "TemplateBody"}) (clojure.core/into (ser-registry-s-3-bucket-name (input :input-file-bucket)) #:http.request.field{:name "inputFileBucket", :shape "RegistryS3BucketName"}) (clojure.core/into (ser-registry-s-3-key-name (input :input-file-key)) #:http.request.field{:name "inputFileKey", :shape "RegistryS3KeyName"}) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]}))

(clojure.core/defn- req-list-security-profiles-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-set-logging-options-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-logging-options-payload (input :logging-options-payload)) #:http.request.field{:name "loggingOptionsPayload", :shape "LoggingOptionsPayload"})]}))

(clojure.core/defn- req-list-thing-registration-task-reports-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "TaskId", :location "uri", :location-name "taskId"})], :querystring [(clojure.core/into (ser-report-type (input :report-type)) #:http.request.field{:name "reportType", :shape "ReportType", :location "querystring", :location-name "reportType"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-v-2-logging-levels-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :target-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-target-type (input :target-type)) #:http.request.field{:name "targetType", :shape "LogTargetType", :location "querystring", :location-name "targetType"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-skyfall-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "SkyfallMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-create-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]} (clojure.core/contains? input :thing-type-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-properties (input :thing-type-properties)) #:http.request.field{:name "thingTypeProperties", :shape "ThingTypeProperties"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-create-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})], :body [(clojure.core/into (ser-topic-rule-payload (input :topic-rule-payload)) #:http.request.field{:name "topicRulePayload", :shape "TopicRulePayload"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :tags)) #:http.request.field{:name "tags", :shape "String", :location "header", :location-name "x-amz-tagging"}))))

(clojure.core/defn- req-delete-job-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"}) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"}) (clojure.core/into (ser-execution-number (input :execution-number)) #:http.request.field{:name "executionNumber", :shape "ExecutionNumber", :location "uri", :location-name "executionNumber"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"}))))

(clojure.core/defn- req-update-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})]} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :credential-duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-credential-duration-seconds (input :credential-duration-seconds)) #:http.request.field{:name "credentialDurationSeconds", :shape "CredentialDurationSeconds"}))))

(clojure.core/defn- req-delete-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})]}))

(clojure.core/defn- req-list-things-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :attribute-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-name (input :attribute-name)) #:http.request.field{:name "attributeName", :shape "AttributeName", :location "querystring", :location-name "attributeName"})) (clojure.core/contains? input :attribute-value) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :attribute-value)) #:http.request.field{:name "attributeValue", :shape "AttributeValue", :location "querystring", :location-name "attributeValue"})) (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "querystring", :location-name "thingTypeName"}))))

(clojure.core/defn- req-update-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})]} (clojure.core/contains? input :authorizer-function-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-function-arn (input :authorizer-function-arn)) #:http.request.field{:name "authorizerFunctionArn", :shape "AuthorizerFunctionArn"})) (clojure.core/contains? input :token-key-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-token-key-name (input :token-key-name)) #:http.request.field{:name "tokenKeyName", :shape "TokenKeyName"})) (clojure.core/contains? input :token-signing-public-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-public-key-map (input :token-signing-public-keys)) #:http.request.field{:name "tokenSigningPublicKeys", :shape "PublicKeyMap"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-status (input :status)) #:http.request.field{:name "status", :shape "AuthorizerStatus"}))))

(clojure.core/defn- req-describe-thing-registration-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "TaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-get-indexing-configuration-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-list-job-executions-for-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-execution-status (input :status)) #:http.request.field{:name "status", :shape "JobExecutionStatus", :location "querystring", :location-name "status"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-laser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "LaserMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-replace-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})], :body [(clojure.core/into (ser-topic-rule-payload (input :topic-rule-payload)) #:http.request.field{:name "topicRulePayload", :shape "TopicRulePayload"})]}))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-arn (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "ResourceArn"}) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "tagKeys", :shape "TagKeyList"})]}))

(clojure.core/defn- req-get-registration-code-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-update-account-audit-configuration-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :audit-notification-target-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-notification-target-configurations (input :audit-notification-target-configurations)) #:http.request.field{:name "auditNotificationTargetConfigurations", :shape "AuditNotificationTargetConfigurations"})) (clojure.core/contains? input :audit-check-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-check-configurations (input :audit-check-configurations)) #:http.request.field{:name "auditCheckConfigurations", :shape "AuditCheckConfigurations"}))))

(clojure.core/defn- req-create-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-document (input :policy-document)) #:http.request.field{:name "policyDocument", :shape "PolicyDocument"})]} (clojure.core/contains? input :set-as-default) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-default (input :set-as-default)) #:http.request.field{:name "setAsDefault", :shape "SetAsDefault", :location "querystring", :location-name "setAsDefault"}))))

(clojure.core/defn- req-delete-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})]}))

(clojure.core/defn- req-associate-targets-with-job-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-job-targets (input :targets)) #:http.request.field{:name "targets", :shape "JobTargets"})], :uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "comment", :shape "Comment"}))))

(clojure.core/defn- req-create-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]} (clojure.core/contains? input :billing-group-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-properties (input :billing-group-properties)) #:http.request.field{:name "billingGroupProperties", :shape "BillingGroupProperties"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-effective-policies-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :principal) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal"})) (clojure.core/contains? input :cognito-identity-pool-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cognito-identity-pool-id (input :cognito-identity-pool-id)) #:http.request.field{:name "cognitoIdentityPoolId", :shape "CognitoIdentityPoolId"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "querystring", :location-name "thingName"}))))

(clojure.core/defn- req-update-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]} (clojure.core/contains? input :frequency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-frequency (input :frequency)) #:http.request.field{:name "frequency", :shape "AuditFrequency"})) (clojure.core/contains? input :day-of-month) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-month (input :day-of-month)) #:http.request.field{:name "dayOfMonth", :shape "DayOfMonth"})) (clojure.core/contains? input :day-of-week) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-week (input :day-of-week)) #:http.request.field{:name "dayOfWeek", :shape "DayOfWeek"})) (clojure.core/contains? input :target-check-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-audit-check-names (input :target-check-names)) #:http.request.field{:name "targetCheckNames", :shape "TargetAuditCheckNames"}))))

(clojure.core/declare deser-audit-task-metadata-list)

(clojure.core/declare deser-audit-finding-severity)

(clojure.core/declare deser-stream-id)

(clojure.core/declare deser-billing-group-arn)

(clojure.core/declare deser-compliant-checks-count)

(clojure.core/declare deser-auto-registration-status)

(clojure.core/declare deser-security-profile-targets)

(clojure.core/declare deser-thing-indexing-mode)

(clojure.core/declare deser-canceled-checks-count)

(clojure.core/declare deser-billing-group-properties)

(clojure.core/declare deser-thing-group-description)

(clojure.core/declare deser-scheduled-audit-arn)

(clojure.core/declare deser-outgoing-certificates)

(clojure.core/declare deser-range-key-field)

(clojure.core/declare deser-thing-group-indexing-configuration)

(clojure.core/declare deser-security-profile-description)

(clojure.core/declare deser-thing-attribute-list)

(clojure.core/declare deser-thing-group-document-list)

(clojure.core/declare deser-ota-update-arn)

(clojure.core/declare deser-log-target-configurations)

(clojure.core/declare deser-in-progress-timeout-in-minutes)

(clojure.core/declare deser-thing-type-properties)

(clojure.core/declare deser-stream-name)

(clojure.core/declare deser-job-execution-summary-for-job)

(clojure.core/declare deser-code-signing)

(clojure.core/declare deser-dynamo-d-bv-2-action)

(clojure.core/declare deser-audit-notification-target-configurations)

(clojure.core/declare deser-statistical-threshold)

(clojure.core/declare deser-ota-update-summary)

(clojure.core/declare deser-minimum-number-of-executed-things)

(clojure.core/declare deser-cidr)

(clojure.core/declare deser-active-violations)

(clojure.core/declare deser-string-map)

(clojure.core/declare deser-platform)

(clojure.core/declare deser-stream-info)

(clojure.core/declare deser-private-key)

(clojure.core/declare deser-explicit-deny)

(clojure.core/declare deser-deprecation-date)

(clojure.core/declare deser-function-arn)

(clojure.core/declare deser-resource-logical-id)

(clojure.core/declare deser-topic-pattern)

(clojure.core/declare deser-removed-things)

(clojure.core/declare deser-signature-algorithm)

(clojure.core/declare deser-index-status)

(clojure.core/declare deser-query-version)

(clojure.core/declare deser-rule-name)

(clojure.core/declare deser-violation-event)

(clojure.core/declare deser-s-3-file-url-list)

(clojure.core/declare deser-non-compliant-resources-count)

(clojure.core/declare deser-job-status)

(clojure.core/declare deser-failed-things)

(clojure.core/declare deser-code-signing-certificate-chain)

(clojure.core/declare deser-comment)

(clojure.core/declare deser-missing-context-values)

(clojure.core/declare deser-day-of-week)

(clojure.core/declare deser-prefix)

(clojure.core/declare deser-message-id)

(clojure.core/declare deser-security-profile-target)

(clojure.core/declare deser-thing-type-description)

(clojure.core/declare deser-streams-summary)

(clojure.core/declare deser-thing-attribute)

(clojure.core/declare deser-abort-criteria)

(clojure.core/declare deser-validation-error)

(clojure.core/declare deser-index-names-list)

(clojure.core/declare deser-audit-task-type)

(clojure.core/declare deser-canned-access-control-list)

(clojure.core/declare deser-connectivity-timestamp)

(clojure.core/declare deser-thing-group-id)

(clojure.core/declare deser-duration-seconds)

(clojure.core/declare deser-thing-type-name)

(clojure.core/declare deser-violation-events)

(clojure.core/declare deser-iot-events-action)

(clojure.core/declare deser-execution-number)

(clojure.core/declare deser-input-name)

(clojure.core/declare deserresource-id)

(clojure.core/declare deser-additional-metrics-to-retain-list)

(clojure.core/declare deser-number-of-things)

(clojure.core/declare deser-non-compliant-resource)

(clojure.core/declare deser-key-value)

(clojure.core/declare deser-thing-group-arn)

(clojure.core/declare deser-attribute-name)

(clojure.core/declare deser-outgoing-certificate)

(clojure.core/declare deser-canceled-things)

(clojure.core/declare deser-last-modified-date)

(clojure.core/declare deser-log-level)

(clojure.core/declare deser-target-audit-check-names)

(clojure.core/declare deser-effective-policies)

(clojure.core/declare deser-policy-name)

(clojure.core/declare deser-ca-certificates)

(clojure.core/declare desererror-message)

(clojure.core/declare deser-action-list)

(clojure.core/declare deser-active-violation)

(clojure.core/declare deser-registration-config)

(clojure.core/declare deser-additional-parameter-map)

(clojure.core/declare deser-json-document)

(clojure.core/declare deser-expires-in-sec)

(clojure.core/declare deser-thing-arn)

(clojure.core/declare deser-template-body)

(clojure.core/declare deser-behavior)

(clojure.core/declare deser-index-name)

(clojure.core/declare deser-certificates)

(clojure.core/declare deser-thing-type-metadata)

(clojure.core/declare deser-certificate-name)

(clojure.core/declare deser-attribute-payload)

(clojure.core/declare deser-scheduled-audit-metadata-list)

(clojure.core/declare deser-inline-document)

(clojure.core/declare deser-state-value)

(clojure.core/declare deser-reason-for-non-compliance-code)

(clojure.core/declare deser-use-base-64)

(clojure.core/declare deser-abort-config)

(clojure.core/declare deser-certificate-path-on-device)

(clojure.core/declare deser-security-profile-target-arn)

(clojure.core/declare deser-day-of-month)

(clojure.core/declare deser-principal-arn)

(clojure.core/declare deser-max-job-executions-per-min)

(clojure.core/declare deser-ca-certificate-status)

(clojure.core/declare deser-role-arn)

(clojure.core/declare deser-target-arn)

(clojure.core/declare deser-security-profile-target-mappings)

(clojure.core/declare deser-abort-criteria-list)

(clojure.core/declare deser-disable-all-logs)

(clojure.core/declare deser-registry-s-3-key-name)

(clojure.core/declare deser-partition-key)

(clojure.core/declare deser-audit-check-details)

(clojure.core/declare deser-audit-details)

(clojure.core/declare deser-flag)

(clojure.core/declare deser-certificate-description)

(clojure.core/declare deser-principal-id)

(clojure.core/declare deser-marker)

(clojure.core/declare deser-index-schema)

(clojure.core/declare deser-tag-key)

(clojure.core/declare deser-ota-update-files)

(clojure.core/declare deser-thing-document-list)

(clojure.core/declare deser-start-signing-job-parameter)

(clojure.core/declare deser-destination)

(clojure.core/declare deser-task-id-list)

(clojure.core/declare deser-rule-arn)

(clojure.core/declare deser-count)

(clojure.core/declare deser-non-compliant-checks-count)

(clojure.core/declare deser-comparison-operator)

(clojure.core/declare deser-task-id)

(clojure.core/declare deser-thing-type-definition)

(clojure.core/declare deser-billing-group-id)

(clojure.core/declare deser-thing-name-list)

(clojure.core/declare deser-policy-targets)

(clojure.core/declare deser-forced)

(clojure.core/declare deser-resource-arns)

(clojure.core/declare deser-exponential-rollout-rate)

(clojure.core/declare deser-job-execution-summary)

(clojure.core/declare deser-elasticsearch-type)

(clojure.core/declare deser-waiting-for-data-collection-checks-count)

(clojure.core/declare deser-thing-group-name-list)

(clojure.core/declare deser-rate-increase-criteria)

(clojure.core/declare deser-thing-type-arn)

(clojure.core/declare deser-rejected-things)

(clojure.core/declare deser-alert-targets)

(clojure.core/declare deser-implicit-deny)

(clojure.core/declare deser-aws-arn)

(clojure.core/declare deser-stream-files)

(clojure.core/declare deser-key-name)

(clojure.core/declare deser-log-target-type)

(clojure.core/declare deser-enabled)

(clojure.core/declare deser-query-string)

(clojure.core/declare deser-status)

(clojure.core/declare deser-behaviors)

(clojure.core/declare deser-audit-findings)

(clojure.core/declare deser-auth-results)

(clojure.core/declare deser-policy-version)

(clojure.core/declare deser-event-type)

(clojure.core/declare deser-in-progress-checks-count)

(clojure.core/declare deser-role-alias)

(clojure.core/declare deser-log-target-configuration)

(clojure.core/declare deser-put-item-input)

(clojure.core/declare deser-succeeded-things)

(clojure.core/declare deser-log-target-name)

(clojure.core/declare deser-next-token)

(clojure.core/declare deser-behavior-metric)

(clojure.core/declare deser-ota-update-file)

(clojure.core/declare deser-range-key-value)

(clojure.core/declare deser-hash-key-value)

(clojure.core/declare deser-firehose-action)

(clojure.core/declare deser-role-alias-arn)

(clojure.core/declare deser-scheduled-audit-metadata)

(clojure.core/declare deser-consecutive-datapoints-to-alarm)

(clojure.core/declare deser-error-message)

(clojure.core/declare deser-total-checks-count)

(clojure.core/declare deser-security-profile-name)

(clojure.core/declare deser-timed-out-things)

(clojure.core/declare deser-thing-group-properties)

(clojure.core/declare deser-cidrs)

(clojure.core/declare deser-audit-task-metadata)

(clojure.core/declare deser-alert-target-type)

(clojure.core/declare deser-job-document)

(clojure.core/declare deser-audit-check-name)

(clojure.core/declare deser-key)

(clojure.core/declare deser-stream-description)

(clojure.core/declare deser-salesforce-token)

(clojure.core/declare deser-thing-group-metadata)

(clojure.core/declare deser-thing-group-indexing-mode)

(clojure.core/declare deser-target-selection)

(clojure.core/declare deser-attributes)

(clojure.core/declare deser-queue-url)

(clojure.core/declare deser-unsigned-long)

(clojure.core/declare deser-role-aliases)

(clojure.core/declare deser-authorizer-summary)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-signature)

(clojure.core/declare deser-ota-update-error-message)

(clojure.core/declare deser-check-compliant)

(clojure.core/declare deser-searchable-attributes)

(clojure.core/declare deser-job-summary-list)

(clojure.core/declare deser-audit-check-run-status)

(clojure.core/declare deser-message-format)

(clojure.core/declare deser-date-type)

(clojure.core/declare deser-thing-indexing-configuration)

(clojure.core/declare deser-role-alias-description)

(clojure.core/declare deser-audit-frequency)

(clojure.core/declare deser-attribute-value)

(clojure.core/declare deser-ota-update-file-version)

(clojure.core/declare deser-aws-iot-job-arn)

(clojure.core/declare deser-dynamo-key-type)

(clojure.core/declare deser-thing-id)

(clojure.core/declare deser-public-key-map)

(clojure.core/declare deser-behavior-criteria)

(clojure.core/declare deser-reason-for-non-compliance)

(clojure.core/declare deser-security-profile-identifiers)

(clojure.core/declare deser-error-code)

(clojure.core/declare deser-stream-arn)

(clojure.core/declare deser-signing-profile-parameter)

(clojure.core/declare deser-stream-file)

(clojure.core/declare deser-sns-action)

(clojure.core/declare deser-channel-name)

(clojure.core/declare deser-presigned-url-config)

(clojure.core/declare deser-related-resource)

(clojure.core/declare deser-queued-things)

(clojure.core/declare deser-value)

(clojure.core/declare deser-credential-duration-seconds)

(clojure.core/declare deser-audit-finding)

(clojure.core/declare deser-job-execution-summary-for-job-list)

(clojure.core/declare deser-aws-job-executions-rollout-config)

(clojure.core/declare deser-description)

(clojure.core/declare deser-tag-value)

(clojure.core/declare deser-ota-update-description)

(clojure.core/declare deser-token-key-name)

(clojure.core/declare deser-policy-document)

(clojure.core/declare deser-port)

(clojure.core/declare deser-billing-group-metadata)

(clojure.core/declare deser-authorizer-status)

(clojure.core/declare deser-group-name-and-arn)

(clojure.core/declare deser-timeout-config)

(clojure.core/declare deser-aws-account-id)

(clojure.core/declare deser-message)

(clojure.core/declare deser-is-disabled)

(clojure.core/declare deser-dynamic-group-status)

(clojure.core/declare deser-resources)

(clojure.core/declare deser-policy-documents)

(clojure.core/declare deser-auth-decision)

(clojure.core/declare deser-attribute-key)

(clojure.core/declare deser-billing-group-name-and-arn-list)

(clojure.core/declare deser-file-location)

(clojure.core/declare deser-log-target)

(clojure.core/declare deser-cloudwatch-metric-action)

(clojure.core/declare deser-audit-notification-target)

(clojure.core/declare deser-job-executions-rollout-config)

(clojure.core/declare deser-stream-summary)

(clojure.core/declare deser-error-info)

(clojure.core/declare deser-attributes-map)

(clojure.core/declare deser-job-document-source)

(clojure.core/declare deser-thing-group-document)

(clojure.core/declare deser-authorizer-description)

(clojure.core/declare deser-delivery-stream-name)

(clojure.core/declare deser-billing-group-description)

(clojure.core/declare deser-sqs-action)

(clojure.core/declare deser-s-3-version)

(clojure.core/declare deser-string)

(clojure.core/declare deser-cognito-identity-pool-id)

(clojure.core/declare deser-details-value)

(clojure.core/declare deser-ports)

(clojure.core/declare deser-allowed)

(clojure.core/declare deser-percentage)

(clojure.core/declare deser-job-targets)

(clojure.core/declare deser-missing-context-value)

(clojure.core/declare deser-thing-connectivity-indexing-mode)

(clojure.core/declare deser-denied)

(clojure.core/declare deser-policy-arn)

(clojure.core/declare deser-code-signing-signature)

(clojure.core/declare deser-alert-target-arn)

(clojure.core/declare deser-abort-threshold-percentage)

(clojure.core/declare deser-audit-notification-type)

(clojure.core/declare deser-s-3-file-url)

(clojure.core/declare deser-report-type)

(clojure.core/declare deser-thing-type-id)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-alarm-name)

(clojure.core/declare deser-job-execution-status-details)

(clojure.core/declare deser-hash-key-field)

(clojure.core/declare deser-targets)

(clojure.core/declare deser-thing-name)

(clojure.core/declare deser-republish-action)

(clojure.core/declare deser-resource-identifier)

(clojure.core/declare deser-s-3-key)

(clojure.core/declare deser-authorizer-arn)

(clojure.core/declare deser-stream-version)

(clojure.core/declare deser-job-execution-status)

(clojure.core/declare deser-metric-value)

(clojure.core/declare deser-job-process-details)

(clojure.core/declare deser-client-id)

(clojure.core/declare deser-audit-check-configurations)

(clojure.core/declare deser-elasticsearch-action)

(clojure.core/declare deser-s-3-location)

(clojure.core/declare deser-task-statistics)

(clojure.core/declare deser-elasticsearch-index)

(clojure.core/declare deser-policies)

(clojure.core/declare deser-certificate-arn)

(clojure.core/declare deser-custom-code-signing)

(clojure.core/declare deser-table-name)

(clojure.core/declare deser-s-3-bucket)

(clojure.core/declare deser-billing-group-name)

(clojure.core/declare deser-aws-iot-sql-version)

(clojure.core/declare deser-stream)

(clojure.core/declare deser-sql)

(clojure.core/declare deser-details-key)

(clojure.core/declare deser-registry-s-3-bucket-name)

(clojure.core/declare deser-creation-date)

(clojure.core/declare deser-abort-action)

(clojure.core/declare deser-dynamo-db-action)

(clojure.core/declare deser-violation-event-type)

(clojure.core/declare deser-total-resources-count)

(clojure.core/declare deser-topic-rule-list)

(clojure.core/declare deser-security-profile-arn)

(clojure.core/declare deser-policy-version-id)

(clojure.core/declare deser-alert-target)

(clojure.core/declare deser-timestamp)

(clojure.core/declare deser-dynamo-operation)

(clojure.core/declare deser-resource-arn)

(clojure.core/declare deser-authorizers)

(clojure.core/declare deser-processing-target-name-list)

(clojure.core/declare deser-hash-algorithm)

(clojure.core/declare deser-certificate-status)

(clojure.core/declare deser-policy-version-identifier)

(clojure.core/declare deser-security-profile-identifier)

(clojure.core/declare deser-thing-group-name-and-arn-list)

(clojure.core/declare deser-customer-version)

(clojure.core/declare deser-authorizer-name)

(clojure.core/declare deser-policy)

(clojure.core/declare deser-thing-connectivity)

(clojure.core/declare deser-key-pair)

(clojure.core/declare deser-maximum-per-minute)

(clojure.core/declare deser-behavior-name)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-s-3-destination)

(clojure.core/declare deser-resource)

(clojure.core/declare deser-version)

(clojure.core/declare deser-reason-code)

(clojure.core/declare deser-job-execution-failure-type)

(clojure.core/declare deser-state-machine-name)

(clojure.core/declare deser-elasticsearch-id)

(clojure.core/declare deser-file-id)

(clojure.core/declare deser-processing-target-name)

(clojure.core/declare deserresource-arn)

(clojure.core/declare deser-salesforce-action)

(clojure.core/declare deser-event-configurations)

(clojure.core/declare deser-version-number)

(clojure.core/declare deser-salesforce-endpoint)

(clojure.core/declare deser-step-functions-action)

(clojure.core/declare deser-job)

(clojure.core/declare deser-is-default-version)

(clojure.core/declare deser-auth-info)

(clojure.core/declare deser-target)

(clojure.core/declare deser-rollout-rate-per-minute)

(clojure.core/declare deser-code)

(clojure.core/declare deser-certificate-validity)

(clojure.core/declare deser-violation-id)

(clojure.core/declare deser-action-type)

(clojure.core/declare deser-job-execution-summary-for-thing-list)

(clojure.core/declare deser-thing-group-name)

(clojure.core/declare deser-policy-target)

(clojure.core/declare deser-ca-certificate-description)

(clojure.core/declare deser-execution-name-prefix)

(clojure.core/declare deser-transfer-data)

(clojure.core/declare deser-evaluation-statistic)

(clojure.core/declare deser-scheduled-audit-name)

(clojure.core/declare deser-policy-versions)

(clojure.core/declare deser-cloudwatch-alarm-action)

(clojure.core/declare deser-signing-job-id)

(clojure.core/declare deser-lambda-action)

(clojure.core/declare deser-bucket-name)

(clojure.core/declare deser-failed-checks-count)

(clojure.core/declare deser-certificate-id)

(clojure.core/declare deser-ota-updates-summary)

(clojure.core/declare deser-ota-update-status)

(clojure.core/declare deser-related-resources)

(clojure.core/declare deser-endpoint-address)

(clojure.core/declare deser-in-progress-things)

(clojure.core/declare deser-certificate-pem)

(clojure.core/declare deser-file-name)

(clojure.core/declare deser-job-summary)

(clojure.core/declare deser-thing-document)

(clojure.core/declare deser-ota-update-id)

(clojure.core/declare deser-action)

(clojure.core/declare deser-configuration)

(clojure.core/declare deser-thing-type-list)

(clojure.core/declare deser-created-at-date)

(clojure.core/declare deser-job-execution-summary-for-thing)

(clojure.core/declare deser-certificate)

(clojure.core/declare deser-increment-factor)

(clojure.core/declare deser-job-description)

(clojure.core/declare deser-state-reason)

(clojure.core/declare deser-aws-iot-job-id)

(clojure.core/declare deser-approximate-seconds-before-timed-out)

(clojure.core/declare deser-elasticsearch-endpoint)

(clojure.core/declare deser-ota-update-info)

(clojure.core/declare deser-signing-profile-name)

(clojure.core/declare deser-effective-policy)

(clojure.core/declare deser-details-map)

(clojure.core/declare deser-consecutive-datapoints-to-clear)

(clojure.core/declare deser-audit-check-configuration)

(clojure.core/declare deser-audit-task-status)

(clojure.core/declare deser-s-3-action)

(clojure.core/declare deser-job-execution)

(clojure.core/declare deser-iot-analytics-action)

(clojure.core/declare deser-security-profile-target-mapping)

(clojure.core/declare deser-generation-id)

(clojure.core/declare deser-kinesis-action)

(clojure.core/declare deser-ca-certificate)

(clojure.core/declare deser-public-key)

(clojure.core/declare deser-job-arn)

(clojure.core/declare deser-valid)

(clojure.core/declare deser-audit-task-id)

(clojure.core/declare deser-payload-field)

(clojure.core/declare deser-authorizer-function-arn)

(clojure.core/declare deser-topic-rule-list-item)

(clojure.core/declare deser-is-authenticated)

(clojure.core/declare deser-firehose-separator)

(clojure.core/declare deser-seconds)

(clojure.core/declare deser-auth-result)

(clojure.core/declare deser-principals)

(clojure.core/declare deser-validation-errors)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-topic-rule)

(clojure.core/declare deser-registration-code)

(clojure.core/declare deser-job-id)

(clojure.core/defn- deser-audit-task-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-audit-task-metadata coll))) input))

(clojure.core/defn- deser-audit-finding-severity [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low} input))

(clojure.core/defn- deser-stream-id [input] input)

(clojure.core/defn- deser-billing-group-arn [input] input)

(clojure.core/defn- deser-compliant-checks-count [input] input)

(clojure.core/defn- deser-auto-registration-status [input] (clojure.core/get {"ENABLE" :enable, "DISABLE" :disable} input))

(clojure.core/defn- deser-security-profile-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-profile-target coll))) input))

(clojure.core/defn- deser-thing-indexing-mode [input] (clojure.core/get {"OFF" :off, "REGISTRY" :registry, "REGISTRY_AND_SHADOW" :registry-and-shadow} input))

(clojure.core/defn- deser-canceled-checks-count [input] input)

(clojure.core/defn- deser-billing-group-properties [input] (clojure.core/cond-> {} (clojure.core/contains? input "billingGroupDescription") (clojure.core/assoc :billing-group-description (deser-billing-group-description (input "billingGroupDescription")))))

(clojure.core/defn- deser-thing-group-description [input] input)

(clojure.core/defn- deser-scheduled-audit-arn [input] input)

(clojure.core/defn- deser-outgoing-certificates [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-outgoing-certificate coll))) input))

(clojure.core/defn- deser-range-key-field [input] input)

(clojure.core/defn- deser-thing-group-indexing-configuration [input] (clojure.core/cond-> {:thing-group-indexing-mode (deser-thing-group-indexing-mode (input "thingGroupIndexingMode"))}))

(clojure.core/defn- deser-security-profile-description [input] input)

(clojure.core/defn- deser-thing-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-attribute coll))) input))

(clojure.core/defn- deser-thing-group-document-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-group-document coll))) input))

(clojure.core/defn- deser-ota-update-arn [input] input)

(clojure.core/defn- deser-log-target-configurations [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-log-target-configuration coll))) input))

(clojure.core/defn- deser-in-progress-timeout-in-minutes [input] input)

(clojure.core/defn- deser-thing-type-properties [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingTypeDescription") (clojure.core/assoc :thing-type-description (deser-thing-type-description (input "thingTypeDescription"))) (clojure.core/contains? input "searchableAttributes") (clojure.core/assoc :searchable-attributes (deser-searchable-attributes (input "searchableAttributes")))))

(clojure.core/defn- deser-stream-name [input] input)

(clojure.core/defn- deser-job-execution-summary-for-job [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (input "thingArn"))) (clojure.core/contains? input "jobExecutionSummary") (clojure.core/assoc :job-execution-summary (deser-job-execution-summary (input "jobExecutionSummary")))))

(clojure.core/defn- deser-code-signing [input] (clojure.core/cond-> {} (clojure.core/contains? input "awsSignerJobId") (clojure.core/assoc :aws-signer-job-id (deser-signing-job-id (input "awsSignerJobId"))) (clojure.core/contains? input "startSigningJobParameter") (clojure.core/assoc :start-signing-job-parameter (deser-start-signing-job-parameter (input "startSigningJobParameter"))) (clojure.core/contains? input "customCodeSigning") (clojure.core/assoc :custom-code-signing (deser-custom-code-signing (input "customCodeSigning")))))

(clojure.core/defn- deser-dynamo-d-bv-2-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :put-item (deser-put-item-input (input "putItem"))}))

(clojure.core/defn- deser-audit-notification-target-configurations [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-audit-notification-type k) (deser-audit-notification-target v)])) input))

(clojure.core/defn- deser-statistical-threshold [input] (clojure.core/cond-> {} (clojure.core/contains? input "statistic") (clojure.core/assoc :statistic (deser-evaluation-statistic (input "statistic")))))

(clojure.core/defn- deser-ota-update-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "otaUpdateId") (clojure.core/assoc :ota-update-id (deser-ota-update-id (input "otaUpdateId"))) (clojure.core/contains? input "otaUpdateArn") (clojure.core/assoc :ota-update-arn (deser-ota-update-arn (input "otaUpdateArn"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-minimum-number-of-executed-things [input] input)

(clojure.core/defn- deser-cidr [input] input)

(clojure.core/defn- deser-active-violations [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-active-violation coll))) input))

(clojure.core/defn- deser-string-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-platform [input] input)

(clojure.core/defn- deser-stream-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-stream-id (input "streamId"))) (clojure.core/contains? input "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (input "streamArn"))) (clojure.core/contains? input "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (input "streamVersion"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-stream-description (input "description"))) (clojure.core/contains? input "files") (clojure.core/assoc :files (deser-stream-files (input "files"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-date-type (input "createdAt"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn")))))

(clojure.core/defn- deser-private-key [input] input)

(clojure.core/defn- deser-explicit-deny [input] (clojure.core/cond-> {} (clojure.core/contains? input "policies") (clojure.core/assoc :policies (deser-policies (input "policies")))))

(clojure.core/defn- deser-deprecation-date [input] input)

(clojure.core/defn- deser-function-arn [input] input)

(clojure.core/defn- deser-resource-logical-id [input] input)

(clojure.core/defn- deser-topic-pattern [input] input)

(clojure.core/defn- deser-removed-things [input] input)

(clojure.core/defn- deser-signature-algorithm [input] input)

(clojure.core/defn- deser-index-status [input] (clojure.core/get {"ACTIVE" :active, "BUILDING" :building, "REBUILDING" :rebuilding} input))

(clojure.core/defn- deser-query-version [input] input)

(clojure.core/defn- deser-rule-name [input] input)

(clojure.core/defn- deser-violation-event [input] (clojure.core/cond-> {} (clojure.core/contains? input "violationId") (clojure.core/assoc :violation-id (deser-violation-id (input "violationId"))) (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (input "securityProfileName"))) (clojure.core/contains? input "behavior") (clojure.core/assoc :behavior (deser-behavior (input "behavior"))) (clojure.core/contains? input "metricValue") (clojure.core/assoc :metric-value (deser-metric-value (input "metricValue"))) (clojure.core/contains? input "violationEventType") (clojure.core/assoc :violation-event-type (deser-violation-event-type (input "violationEventType"))) (clojure.core/contains? input "violationEventTime") (clojure.core/assoc :violation-event-time (deser-timestamp (input "violationEventTime")))))

(clojure.core/defn- deser-s-3-file-url-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-s-3-file-url coll))) input))

(clojure.core/defn- deser-non-compliant-resources-count [input] input)

(clojure.core/defn- deser-job-status [input] (clojure.core/get {"IN_PROGRESS" :in-progress, "CANCELED" :canceled, "COMPLETED" :completed, "DELETION_IN_PROGRESS" :deletion-in-progress} input))

(clojure.core/defn- deser-failed-things [input] input)

(clojure.core/defn- deser-code-signing-certificate-chain [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateName") (clojure.core/assoc :certificate-name (deser-certificate-name (input "certificateName"))) (clojure.core/contains? input "inlineDocument") (clojure.core/assoc :inline-document (deser-inline-document (input "inlineDocument")))))

(clojure.core/defn- deser-comment [input] input)

(clojure.core/defn- deser-missing-context-values [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-missing-context-value coll))) input))

(clojure.core/defn- deser-day-of-week [input] (clojure.core/get {"SUN" :sun, "MON" :mon, "TUE" :tue, "WED" :wed, "THU" :thu, "FRI" :fri, "SAT" :sat} input))

(clojure.core/defn- deser-prefix [input] input)

(clojure.core/defn- deser-message-id [input] input)

(clojure.core/defn- deser-security-profile-target [input] (clojure.core/cond-> {:arn (deser-security-profile-target-arn (input "arn"))}))

(clojure.core/defn- deser-thing-type-description [input] input)

(clojure.core/defn- deser-streams-summary [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stream-summary coll))) input))

(clojure.core/defn- deser-thing-attribute [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (input "thingTypeName"))) (clojure.core/contains? input "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (input "thingArn"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-version (input "version")))))

(clojure.core/defn- deser-abort-criteria [input] (clojure.core/cond-> {:failure-type (deser-job-execution-failure-type (input "failureType")), :action (deser-abort-action (input "action")), :threshold-percentage (deser-abort-threshold-percentage (input "thresholdPercentage")), :min-number-of-executed-things (deser-minimum-number-of-executed-things (input "minNumberOfExecutedThings"))}))

(clojure.core/defn- deser-validation-error [input] (clojure.core/cond-> {} (clojure.core/contains? input "errorMessage") (clojure.core/assoc :error-message (deser-error-message (input "errorMessage")))))

(clojure.core/defn- deser-index-names-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-index-name coll))) input))

(clojure.core/defn- deser-audit-task-type [input] (clojure.core/get {"ON_DEMAND_AUDIT_TASK" :on-demand-audit-task, "SCHEDULED_AUDIT_TASK" :scheduled-audit-task} input))

(clojure.core/defn- deser-canned-access-control-list [input] (clojure.core/get {"private" :private, "public-read" :publicread, "public-read-write" :publicreadwrite, "aws-exec-read" :awsexecread, "authenticated-read" :authenticatedread, "bucket-owner-read" :bucketownerread, "bucket-owner-full-control" :bucketownerfullcontrol, "log-delivery-write" :logdeliverywrite} input))

(clojure.core/defn- deser-connectivity-timestamp [input] input)

(clojure.core/defn- deser-thing-group-id [input] input)

(clojure.core/defn- deser-duration-seconds [input] input)

(clojure.core/defn- deser-thing-type-name [input] input)

(clojure.core/defn- deser-violation-events [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-violation-event coll))) input))

(clojure.core/defn- deser-iot-events-action [input] (clojure.core/cond-> {:input-name (deser-input-name (input "inputName")), :role-arn (deser-aws-arn (input "roleArn"))} (clojure.core/contains? input "messageId") (clojure.core/assoc :message-id (deser-message-id (input "messageId")))))

(clojure.core/defn- deser-execution-number [input] input)

(clojure.core/defn- deser-input-name [input] input)

(clojure.core/defn- deserresource-id [input] input)

(clojure.core/defn- deser-additional-metrics-to-retain-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-behavior-metric coll))) input))

(clojure.core/defn- deser-number-of-things [input] input)

(clojure.core/defn- deser-non-compliant-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "resourceIdentifier") (clojure.core/assoc :resource-identifier (deser-resource-identifier (input "resourceIdentifier"))) (clojure.core/contains? input "additionalInfo") (clojure.core/assoc :additional-info (deser-string-map (input "additionalInfo")))))

(clojure.core/defn- deser-key-value [input] input)

(clojure.core/defn- deser-thing-group-arn [input] input)

(clojure.core/defn- deser-attribute-name [input] input)

(clojure.core/defn- deser-outgoing-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId"))) (clojure.core/contains? input "transferredTo") (clojure.core/assoc :transferred-to (deser-aws-account-id (input "transferredTo"))) (clojure.core/contains? input "transferDate") (clojure.core/assoc :transfer-date (deser-date-type (input "transferDate"))) (clojure.core/contains? input "transferMessage") (clojure.core/assoc :transfer-message (deser-message (input "transferMessage"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-canceled-things [input] input)

(clojure.core/defn- deser-last-modified-date [input] input)

(clojure.core/defn- deser-log-level [input] (clojure.core/get {"DEBUG" :debug, "INFO" :info, "ERROR" :error, "WARN" :warn, "DISABLED" :disabled} input))

(clojure.core/defn- deser-target-audit-check-names [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-audit-check-name coll))) input))

(clojure.core/defn- deser-effective-policies [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-effective-policy coll))) input))

(clojure.core/defn- deser-policy-name [input] input)

(clojure.core/defn- deser-ca-certificates [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ca-certificate coll))) input))

(clojure.core/defn- desererror-message [input] input)

(clojure.core/defn- deser-action-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-action coll))) input))

(clojure.core/defn- deser-active-violation [input] (clojure.core/cond-> {} (clojure.core/contains? input "violationId") (clojure.core/assoc :violation-id (deser-violation-id (input "violationId"))) (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (input "securityProfileName"))) (clojure.core/contains? input "behavior") (clojure.core/assoc :behavior (deser-behavior (input "behavior"))) (clojure.core/contains? input "lastViolationValue") (clojure.core/assoc :last-violation-value (deser-metric-value (input "lastViolationValue"))) (clojure.core/contains? input "lastViolationTime") (clojure.core/assoc :last-violation-time (deser-timestamp (input "lastViolationTime"))) (clojure.core/contains? input "violationStartTime") (clojure.core/assoc :violation-start-time (deser-timestamp (input "violationStartTime")))))

(clojure.core/defn- deser-registration-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "templateBody") (clojure.core/assoc :template-body (deser-template-body (input "templateBody"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn")))))

(clojure.core/defn- deser-additional-parameter-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-key k) (deser-value v)])) input))

(clojure.core/defn- deser-json-document [input] input)

(clojure.core/defn- deser-expires-in-sec [input] input)

(clojure.core/defn- deser-thing-arn [input] input)

(clojure.core/defn- deser-template-body [input] input)

(clojure.core/defn- deser-behavior [input] (clojure.core/cond-> {:name (deser-behavior-name (input "name"))} (clojure.core/contains? input "metric") (clojure.core/assoc :metric (deser-behavior-metric (input "metric"))) (clojure.core/contains? input "criteria") (clojure.core/assoc :criteria (deser-behavior-criteria (input "criteria")))))

(clojure.core/defn- deser-index-name [input] input)

(clojure.core/defn- deser-certificates [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-certificate coll))) input))

(clojure.core/defn- deser-thing-type-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "deprecated") (clojure.core/assoc :deprecated (deser-boolean (input "deprecated"))) (clojure.core/contains? input "deprecationDate") (clojure.core/assoc :deprecation-date (deser-deprecation-date (input "deprecationDate"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (input "creationDate")))))

(clojure.core/defn- deser-certificate-name [input] input)

(clojure.core/defn- deser-attribute-payload [input] (clojure.core/cond-> {} (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "merge") (clojure.core/assoc :merge (deser-flag (input "merge")))))

(clojure.core/defn- deser-scheduled-audit-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-audit-metadata coll))) input))

(clojure.core/defn- deser-inline-document [input] input)

(clojure.core/defn- deser-state-value [input] input)

(clojure.core/defn- deser-reason-for-non-compliance-code [input] input)

(clojure.core/defn- deser-use-base-64 [input] input)

(clojure.core/defn- deser-abort-config [input] (clojure.core/cond-> {:criteria-list (deser-abort-criteria-list (input "criteriaList"))}))

(clojure.core/defn- deser-certificate-path-on-device [input] input)

(clojure.core/defn- deser-security-profile-target-arn [input] input)

(clojure.core/defn- deser-day-of-month [input] input)

(clojure.core/defn- deser-principal-arn [input] input)

(clojure.core/defn- deser-max-job-executions-per-min [input] input)

(clojure.core/defn- deser-ca-certificate-status [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive} input))

(clojure.core/defn- deser-role-arn [input] input)

(clojure.core/defn- deser-target-arn [input] input)

(clojure.core/defn- deser-security-profile-target-mappings [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-profile-target-mapping coll))) input))

(clojure.core/defn- deser-abort-criteria-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-abort-criteria coll))) input))

(clojure.core/defn- deser-disable-all-logs [input] input)

(clojure.core/defn- deser-registry-s-3-key-name [input] input)

(clojure.core/defn- deser-partition-key [input] input)

(clojure.core/defn- deser-audit-check-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "checkRunStatus") (clojure.core/assoc :check-run-status (deser-audit-check-run-status (input "checkRunStatus"))) (clojure.core/contains? input "checkCompliant") (clojure.core/assoc :check-compliant (deser-check-compliant (input "checkCompliant"))) (clojure.core/contains? input "totalResourcesCount") (clojure.core/assoc :total-resources-count (deser-total-resources-count (input "totalResourcesCount"))) (clojure.core/contains? input "nonCompliantResourcesCount") (clojure.core/assoc :non-compliant-resources-count (deser-non-compliant-resources-count (input "nonCompliantResourcesCount"))) (clojure.core/contains? input "errorCode") (clojure.core/assoc :error-code (deser-error-code (input "errorCode"))) (clojure.core/contains? input "message") (clojure.core/assoc :message (deser-error-message (input "message")))))

(clojure.core/defn- deser-audit-details [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-audit-check-name k) (deser-audit-check-details v)])) input))

(clojure.core/defn- deser-flag [input] input)

(clojure.core/defn- deser-certificate-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "customerVersion") (clojure.core/assoc :customer-version (deser-customer-version (input "customerVersion"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (input "certificatePem"))) (clojure.core/contains? input "caCertificateId") (clojure.core/assoc :ca-certificate-id (deser-certificate-id (input "caCertificateId"))) (clojure.core/contains? input "validity") (clojure.core/assoc :validity (deser-certificate-validity (input "validity"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate"))) (clojure.core/contains? input "ownedBy") (clojure.core/assoc :owned-by (deser-aws-account-id (input "ownedBy"))) (clojure.core/contains? input "transferData") (clojure.core/assoc :transfer-data (deser-transfer-data (input "transferData"))) (clojure.core/contains? input "generationId") (clojure.core/assoc :generation-id (deser-generation-id (input "generationId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-certificate-status (input "status"))) (clojure.core/contains? input "previousOwnedBy") (clojure.core/assoc :previous-owned-by (deser-aws-account-id (input "previousOwnedBy"))) (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId")))))

(clojure.core/defn- deser-principal-id [input] input)

(clojure.core/defn- deser-marker [input] input)

(clojure.core/defn- deser-index-schema [input] input)

(clojure.core/defn- deser-tag-key [input] input)

(clojure.core/defn- deser-ota-update-files [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ota-update-file coll))) input))

(clojure.core/defn- deser-thing-document-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-document coll))) input))

(clojure.core/defn- deser-start-signing-job-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "signingProfileParameter") (clojure.core/assoc :signing-profile-parameter (deser-signing-profile-parameter (input "signingProfileParameter"))) (clojure.core/contains? input "signingProfileName") (clojure.core/assoc :signing-profile-name (deser-signing-profile-name (input "signingProfileName"))) (clojure.core/contains? input "destination") (clojure.core/assoc :destination (deser-destination (input "destination")))))

(clojure.core/defn- deser-destination [input] (clojure.core/cond-> {} (clojure.core/contains? input "s3Destination") (clojure.core/assoc :s-3-destination (deser-s-3-destination (input "s3Destination")))))

(clojure.core/defn- deser-task-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-task-id coll))) input))

(clojure.core/defn- deser-rule-arn [input] input)

(clojure.core/defn- deser-count [input] input)

(clojure.core/defn- deser-non-compliant-checks-count [input] input)

(clojure.core/defn- deser-comparison-operator [input] (clojure.core/get {"less-than" :lessthan, "less-than-equals" :lessthanequals, "greater-than" :greaterthan, "greater-than-equals" :greaterthanequals, "in-cidr-set" :incidrset, "not-in-cidr-set" :notincidrset, "in-port-set" :inportset, "not-in-port-set" :notinportset} input))

(clojure.core/defn- deser-task-id [input] input)

(clojure.core/defn- deser-thing-type-definition [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (input "thingTypeName"))) (clojure.core/contains? input "thingTypeArn") (clojure.core/assoc :thing-type-arn (deser-thing-type-arn (input "thingTypeArn"))) (clojure.core/contains? input "thingTypeProperties") (clojure.core/assoc :thing-type-properties (deser-thing-type-properties (input "thingTypeProperties"))) (clojure.core/contains? input "thingTypeMetadata") (clojure.core/assoc :thing-type-metadata (deser-thing-type-metadata (input "thingTypeMetadata")))))

(clojure.core/defn- deser-billing-group-id [input] input)

(clojure.core/defn- deser-thing-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-name coll))) input))

(clojure.core/defn- deser-policy-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy-target coll))) input))

(clojure.core/defn- deser-forced [input] input)

(clojure.core/defn- deser-resource-arns [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-resource-logical-id k) (deser-resource-arn v)])) input))

(clojure.core/defn- deser-exponential-rollout-rate [input] (clojure.core/cond-> {:base-rate-per-minute (deser-rollout-rate-per-minute (input "baseRatePerMinute")), :increment-factor (deser-increment-factor (input "incrementFactor")), :rate-increase-criteria (deser-rate-increase-criteria (input "rateIncreaseCriteria"))}))

(clojure.core/defn- deser-job-execution-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-execution-status (input "status"))) (clojure.core/contains? input "queuedAt") (clojure.core/assoc :queued-at (deser-date-type (input "queuedAt"))) (clojure.core/contains? input "startedAt") (clojure.core/assoc :started-at (deser-date-type (input "startedAt"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "executionNumber") (clojure.core/assoc :execution-number (deser-execution-number (input "executionNumber")))))

(clojure.core/defn- deser-elasticsearch-type [input] input)

(clojure.core/defn- deser-waiting-for-data-collection-checks-count [input] input)

(clojure.core/defn- deser-thing-group-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-group-name coll))) input))

(clojure.core/defn- deser-rate-increase-criteria [input] (clojure.core/cond-> {} (clojure.core/contains? input "numberOfNotifiedThings") (clojure.core/assoc :number-of-notified-things (deser-number-of-things (input "numberOfNotifiedThings"))) (clojure.core/contains? input "numberOfSucceededThings") (clojure.core/assoc :number-of-succeeded-things (deser-number-of-things (input "numberOfSucceededThings")))))

(clojure.core/defn- deser-thing-type-arn [input] input)

(clojure.core/defn- deser-rejected-things [input] input)

(clojure.core/defn- deser-alert-targets [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-alert-target-type k) (deser-alert-target v)])) input))

(clojure.core/defn- deser-implicit-deny [input] (clojure.core/cond-> {} (clojure.core/contains? input "policies") (clojure.core/assoc :policies (deser-policies (input "policies")))))

(clojure.core/defn- deser-aws-arn [input] input)

(clojure.core/defn- deser-stream-files [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stream-file coll))) input))

(clojure.core/defn- deser-key-name [input] input)

(clojure.core/defn- deser-log-target-type [input] (clojure.core/get {"DEFAULT" :default, "THING_GROUP" :thing-group} input))

(clojure.core/defn- deser-enabled [input] input)

(clojure.core/defn- deser-query-string [input] input)

(clojure.core/defn- deser-status [input] (clojure.core/get {"InProgress" :in-progress, "Completed" :completed, "Failed" :failed, "Cancelled" :cancelled, "Cancelling" :cancelling} input))

(clojure.core/defn- deser-behaviors [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-behavior coll))) input))

(clojure.core/defn- deser-audit-findings [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-audit-finding coll))) input))

(clojure.core/defn- deser-auth-results [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-auth-result coll))) input))

(clojure.core/defn- deser-policy-version [input] (clojure.core/cond-> {} (clojure.core/contains? input "versionId") (clojure.core/assoc :version-id (deser-policy-version-id (input "versionId"))) (clojure.core/contains? input "isDefaultVersion") (clojure.core/assoc :is-default-version (deser-is-default-version (input "isDefaultVersion"))) (clojure.core/contains? input "createDate") (clojure.core/assoc :create-date (deser-date-type (input "createDate")))))

(clojure.core/defn- deser-event-type [input] (clojure.core/get {"THING_TYPE" :thing-type, "THING_GROUP_HIERARCHY" :thing-group-hierarchy, "JOB_EXECUTION" :job-execution, "CA_CERTIFICATE" :ca-certificate, "THING_TYPE_ASSOCIATION" :thing-type-association, "JOB" :job, "POLICY" :policy, "THING_GROUP" :thing-group, "THING_GROUP_MEMBERSHIP" :thing-group-membership, "THING" :thing, "CERTIFICATE" :certificate} input))

(clojure.core/defn- deser-in-progress-checks-count [input] input)

(clojure.core/defn- deser-role-alias [input] input)

(clojure.core/defn- deser-log-target-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "logTarget") (clojure.core/assoc :log-target (deser-log-target (input "logTarget"))) (clojure.core/contains? input "logLevel") (clojure.core/assoc :log-level (deser-log-level (input "logLevel")))))

(clojure.core/defn- deser-put-item-input [input] (clojure.core/cond-> {:table-name (deser-table-name (input "tableName"))}))

(clojure.core/defn- deser-succeeded-things [input] input)

(clojure.core/defn- deser-log-target-name [input] input)

(clojure.core/defn- deser-next-token [input] input)

(clojure.core/defn- deser-behavior-metric [input] input)

(clojure.core/defn- deser-ota-update-file [input] (clojure.core/cond-> {} (clojure.core/contains? input "fileName") (clojure.core/assoc :file-name (deser-file-name (input "fileName"))) (clojure.core/contains? input "fileVersion") (clojure.core/assoc :file-version (deser-ota-update-file-version (input "fileVersion"))) (clojure.core/contains? input "fileLocation") (clojure.core/assoc :file-location (deser-file-location (input "fileLocation"))) (clojure.core/contains? input "codeSigning") (clojure.core/assoc :code-signing (deser-code-signing (input "codeSigning"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes-map (input "attributes")))))

(clojure.core/defn- deser-range-key-value [input] input)

(clojure.core/defn- deser-hash-key-value [input] input)

(clojure.core/defn- deser-firehose-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :delivery-stream-name (deser-delivery-stream-name (input "deliveryStreamName"))} (clojure.core/contains? input "separator") (clojure.core/assoc :separator (deser-firehose-separator (input "separator")))))

(clojure.core/defn- deser-role-alias-arn [input] input)

(clojure.core/defn- deser-scheduled-audit-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "scheduledAuditName") (clojure.core/assoc :scheduled-audit-name (deser-scheduled-audit-name (input "scheduledAuditName"))) (clojure.core/contains? input "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (input "scheduledAuditArn"))) (clojure.core/contains? input "frequency") (clojure.core/assoc :frequency (deser-audit-frequency (input "frequency"))) (clojure.core/contains? input "dayOfMonth") (clojure.core/assoc :day-of-month (deser-day-of-month (input "dayOfMonth"))) (clojure.core/contains? input "dayOfWeek") (clojure.core/assoc :day-of-week (deser-day-of-week (input "dayOfWeek")))))

(clojure.core/defn- deser-consecutive-datapoints-to-alarm [input] input)

(clojure.core/defn- deser-error-message [input] input)

(clojure.core/defn- deser-total-checks-count [input] input)

(clojure.core/defn- deser-security-profile-name [input] input)

(clojure.core/defn- deser-timed-out-things [input] input)

(clojure.core/defn- deser-thing-group-properties [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingGroupDescription") (clojure.core/assoc :thing-group-description (deser-thing-group-description (input "thingGroupDescription"))) (clojure.core/contains? input "attributePayload") (clojure.core/assoc :attribute-payload (deser-attribute-payload (input "attributePayload")))))

(clojure.core/defn- deser-cidrs [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cidr coll))) input))

(clojure.core/defn- deser-audit-task-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "taskId") (clojure.core/assoc :task-id (deser-audit-task-id (input "taskId"))) (clojure.core/contains? input "taskStatus") (clojure.core/assoc :task-status (deser-audit-task-status (input "taskStatus"))) (clojure.core/contains? input "taskType") (clojure.core/assoc :task-type (deser-audit-task-type (input "taskType")))))

(clojure.core/defn- deser-alert-target-type [input] (clojure.core/get {"SNS" :sns} input))

(clojure.core/defn- deser-job-document [input] input)

(clojure.core/defn- deser-audit-check-name [input] input)

(clojure.core/defn- deser-key [input] input)

(clojure.core/defn- deser-stream-description [input] input)

(clojure.core/defn- deser-salesforce-token [input] input)

(clojure.core/defn- deser-thing-group-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "parentGroupName") (clojure.core/assoc :parent-group-name (deser-thing-group-name (input "parentGroupName"))) (clojure.core/contains? input "rootToParentThingGroups") (clojure.core/assoc :root-to-parent-thing-groups (deser-thing-group-name-and-arn-list (input "rootToParentThingGroups"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (input "creationDate")))))

(clojure.core/defn- deser-thing-group-indexing-mode [input] (clojure.core/get {"OFF" :off, "ON" :on} input))

(clojure.core/defn- deser-target-selection [input] (clojure.core/get {"CONTINUOUS" :continuous, "SNAPSHOT" :snapshot} input))

(clojure.core/defn- deser-attributes [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-name k) (deser-attribute-value v)])) input))

(clojure.core/defn- deser-queue-url [input] input)

(clojure.core/defn- deser-unsigned-long [input] input)

(clojure.core/defn- deser-role-aliases [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-role-alias coll))) input))

(clojure.core/defn- deser-authorizer-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (input "authorizerName"))) (clojure.core/contains? input "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (input "authorizerArn")))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-signature [input] (portkey.aws/base64-decode input))

(clojure.core/defn- deser-ota-update-error-message [input] input)

(clojure.core/defn- deser-check-compliant [input] input)

(clojure.core/defn- deser-searchable-attributes [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attribute-name coll))) input))

(clojure.core/defn- deser-job-summary-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-job-summary coll))) input))

(clojure.core/defn- deser-audit-check-run-status [input] (clojure.core/get {"IN_PROGRESS" :in-progress, "WAITING_FOR_DATA_COLLECTION" :waiting-for-data-collection, "CANCELED" :canceled, "COMPLETED_COMPLIANT" :completed-compliant, "COMPLETED_NON_COMPLIANT" :completed-non-compliant, "FAILED" :failed} input))

(clojure.core/defn- deser-message-format [input] (clojure.core/get {"RAW" :raw, "JSON" :json} input))

(clojure.core/defn- deser-date-type [input] input)

(clojure.core/defn- deser-thing-indexing-configuration [input] (clojure.core/cond-> {:thing-indexing-mode (deser-thing-indexing-mode (input "thingIndexingMode"))} (clojure.core/contains? input "thingConnectivityIndexingMode") (clojure.core/assoc :thing-connectivity-indexing-mode (deser-thing-connectivity-indexing-mode (input "thingConnectivityIndexingMode")))))

(clojure.core/defn- deser-role-alias-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "roleAlias") (clojure.core/assoc :role-alias (deser-role-alias (input "roleAlias"))) (clojure.core/contains? input "roleAliasArn") (clojure.core/assoc :role-alias-arn (deser-role-alias-arn (input "roleAliasArn"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn"))) (clojure.core/contains? input "owner") (clojure.core/assoc :owner (deser-aws-account-id (input "owner"))) (clojure.core/contains? input "credentialDurationSeconds") (clojure.core/assoc :credential-duration-seconds (deser-credential-duration-seconds (input "credentialDurationSeconds"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate")))))

(clojure.core/defn- deser-audit-frequency [input] (clojure.core/get {"DAILY" :daily, "WEEKLY" :weekly, "BIWEEKLY" :biweekly, "MONTHLY" :monthly} input))

(clojure.core/defn- deser-attribute-value [input] input)

(clojure.core/defn- deser-ota-update-file-version [input] input)

(clojure.core/defn- deser-aws-iot-job-arn [input] input)

(clojure.core/defn- deser-dynamo-key-type [input] (clojure.core/get {"STRING" :string, "NUMBER" :number} input))

(clojure.core/defn- deser-thing-id [input] input)

(clojure.core/defn- deser-public-key-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-key-name k) (deser-key-value v)])) input))

(clojure.core/defn- deser-behavior-criteria [input] (clojure.core/cond-> {} (clojure.core/contains? input "comparisonOperator") (clojure.core/assoc :comparison-operator (deser-comparison-operator (input "comparisonOperator"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-metric-value (input "value"))) (clojure.core/contains? input "durationSeconds") (clojure.core/assoc :duration-seconds (deser-duration-seconds (input "durationSeconds"))) (clojure.core/contains? input "consecutiveDatapointsToAlarm") (clojure.core/assoc :consecutive-datapoints-to-alarm (deser-consecutive-datapoints-to-alarm (input "consecutiveDatapointsToAlarm"))) (clojure.core/contains? input "consecutiveDatapointsToClear") (clojure.core/assoc :consecutive-datapoints-to-clear (deser-consecutive-datapoints-to-clear (input "consecutiveDatapointsToClear"))) (clojure.core/contains? input "statisticalThreshold") (clojure.core/assoc :statistical-threshold (deser-statistical-threshold (input "statisticalThreshold")))))

(clojure.core/defn- deser-reason-for-non-compliance [input] input)

(clojure.core/defn- deser-security-profile-identifiers [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-profile-identifier coll))) input))

(clojure.core/defn- deser-error-code [input] input)

(clojure.core/defn- deser-stream-arn [input] input)

(clojure.core/defn- deser-signing-profile-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "platform") (clojure.core/assoc :platform (deser-platform (input "platform"))) (clojure.core/contains? input "certificatePathOnDevice") (clojure.core/assoc :certificate-path-on-device (deser-certificate-path-on-device (input "certificatePathOnDevice")))))

(clojure.core/defn- deser-stream-file [input] (clojure.core/cond-> {} (clojure.core/contains? input "fileId") (clojure.core/assoc :file-id (deser-file-id (input "fileId"))) (clojure.core/contains? input "s3Location") (clojure.core/assoc :s-3-location (deser-s-3-location (input "s3Location")))))

(clojure.core/defn- deser-sns-action [input] (clojure.core/cond-> {:target-arn (deser-aws-arn (input "targetArn")), :role-arn (deser-aws-arn (input "roleArn"))} (clojure.core/contains? input "messageFormat") (clojure.core/assoc :message-format (deser-message-format (input "messageFormat")))))

(clojure.core/defn- deser-channel-name [input] input)

(clojure.core/defn- deser-presigned-url-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn"))) (clojure.core/contains? input "expiresInSec") (clojure.core/assoc :expires-in-sec (deser-expires-in-sec (input "expiresInSec")))))

(clojure.core/defn- deser-related-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "resourceIdentifier") (clojure.core/assoc :resource-identifier (deser-resource-identifier (input "resourceIdentifier"))) (clojure.core/contains? input "additionalInfo") (clojure.core/assoc :additional-info (deser-string-map (input "additionalInfo")))))

(clojure.core/defn- deser-queued-things [input] input)

(clojure.core/defn- deser-value [input] input)

(clojure.core/defn- deser-credential-duration-seconds [input] input)

(clojure.core/defn- deser-audit-finding [input] (clojure.core/cond-> {} (clojure.core/contains? input "taskStartTime") (clojure.core/assoc :task-start-time (deser-timestamp (input "taskStartTime"))) (clojure.core/contains? input "checkName") (clojure.core/assoc :check-name (deser-audit-check-name (input "checkName"))) (clojure.core/contains? input "relatedResources") (clojure.core/assoc :related-resources (deser-related-resources (input "relatedResources"))) (clojure.core/contains? input "findingTime") (clojure.core/assoc :finding-time (deser-timestamp (input "findingTime"))) (clojure.core/contains? input "reasonForNonComplianceCode") (clojure.core/assoc :reason-for-non-compliance-code (deser-reason-for-non-compliance-code (input "reasonForNonComplianceCode"))) (clojure.core/contains? input "taskId") (clojure.core/assoc :task-id (deser-audit-task-id (input "taskId"))) (clojure.core/contains? input "severity") (clojure.core/assoc :severity (deser-audit-finding-severity (input "severity"))) (clojure.core/contains? input "nonCompliantResource") (clojure.core/assoc :non-compliant-resource (deser-non-compliant-resource (input "nonCompliantResource"))) (clojure.core/contains? input "reasonForNonCompliance") (clojure.core/assoc :reason-for-non-compliance (deser-reason-for-non-compliance (input "reasonForNonCompliance")))))

(clojure.core/defn- deser-job-execution-summary-for-job-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-job-execution-summary-for-job coll))) input))

(clojure.core/defn- deser-aws-job-executions-rollout-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "maximumPerMinute") (clojure.core/assoc :maximum-per-minute (deser-maximum-per-minute (input "maximumPerMinute")))))

(clojure.core/defn- deser-description [input] input)

(clojure.core/defn- deser-tag-value [input] input)

(clojure.core/defn- deser-ota-update-description [input] input)

(clojure.core/defn- deser-token-key-name [input] input)

(clojure.core/defn- deser-policy-document [input] input)

(clojure.core/defn- deser-port [input] input)

(clojure.core/defn- deser-billing-group-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (input "creationDate")))))

(clojure.core/defn- deser-authorizer-status [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive} input))

(clojure.core/defn- deser-group-name-and-arn [input] (clojure.core/cond-> {} (clojure.core/contains? input "groupName") (clojure.core/assoc :group-name (deser-thing-group-name (input "groupName"))) (clojure.core/contains? input "groupArn") (clojure.core/assoc :group-arn (deser-thing-group-arn (input "groupArn")))))

(clojure.core/defn- deser-timeout-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "inProgressTimeoutInMinutes") (clojure.core/assoc :in-progress-timeout-in-minutes (deser-in-progress-timeout-in-minutes (input "inProgressTimeoutInMinutes")))))

(clojure.core/defn- deser-aws-account-id [input] input)

(clojure.core/defn- deser-message [input] input)

(clojure.core/defn- deser-is-disabled [input] input)

(clojure.core/defn- deser-dynamic-group-status [input] (clojure.core/get {"ACTIVE" :active, "BUILDING" :building, "REBUILDING" :rebuilding} input))

(clojure.core/defn- deser-resources [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource coll))) input))

(clojure.core/defn- deser-policy-documents [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy-document coll))) input))

(clojure.core/defn- deser-auth-decision [input] (clojure.core/get {"ALLOWED" :allowed, "EXPLICIT_DENY" :explicit-deny, "IMPLICIT_DENY" :implicit-deny} input))

(clojure.core/defn- deser-attribute-key [input] input)

(clojure.core/defn- deser-billing-group-name-and-arn-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-name-and-arn coll))) input))

(clojure.core/defn- deser-file-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "stream") (clojure.core/assoc :stream (deser-stream (input "stream"))) (clojure.core/contains? input "s3Location") (clojure.core/assoc :s-3-location (deser-s-3-location (input "s3Location")))))

(clojure.core/defn- deser-log-target [input] (clojure.core/cond-> {:target-type (deser-log-target-type (input "targetType"))} (clojure.core/contains? input "targetName") (clojure.core/assoc :target-name (deser-log-target-name (input "targetName")))))

(clojure.core/defn- deser-cloudwatch-metric-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :metric-namespace (deser-string (input "metricNamespace")), :metric-name (deser-string (input "metricName")), :metric-value (deser-string (input "metricValue")), :metric-unit (deser-string (input "metricUnit"))} (clojure.core/contains? input "metricTimestamp") (clojure.core/assoc :metric-timestamp (deser-string (input "metricTimestamp")))))

(clojure.core/defn- deser-audit-notification-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "targetArn") (clojure.core/assoc :target-arn (deser-target-arn (input "targetArn"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn"))) (clojure.core/contains? input "enabled") (clojure.core/assoc :enabled (deser-enabled (input "enabled")))))

(clojure.core/defn- deser-job-executions-rollout-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "maximumPerMinute") (clojure.core/assoc :maximum-per-minute (deser-max-job-executions-per-min (input "maximumPerMinute"))) (clojure.core/contains? input "exponentialRate") (clojure.core/assoc :exponential-rate (deser-exponential-rollout-rate (input "exponentialRate")))))

(clojure.core/defn- deser-stream-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-stream-id (input "streamId"))) (clojure.core/contains? input "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (input "streamArn"))) (clojure.core/contains? input "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (input "streamVersion"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-stream-description (input "description")))))

(clojure.core/defn- deser-error-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "code") (clojure.core/assoc :code (deser-code (input "code"))) (clojure.core/contains? input "message") (clojure.core/assoc :message (deser-ota-update-error-message (input "message")))))

(clojure.core/defn- deser-attributes-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-key k) (deser-value v)])) input))

(clojure.core/defn- deser-job-document-source [input] input)

(clojure.core/defn- deser-thing-group-document [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (input "thingGroupName"))) (clojure.core/contains? input "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (input "thingGroupId"))) (clojure.core/contains? input "thingGroupDescription") (clojure.core/assoc :thing-group-description (deser-thing-group-description (input "thingGroupDescription"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "parentGroupNames") (clojure.core/assoc :parent-group-names (deser-thing-group-name-list (input "parentGroupNames")))))

(clojure.core/defn- deser-authorizer-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (input "authorizerName"))) (clojure.core/contains? input "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (input "authorizerArn"))) (clojure.core/contains? input "authorizerFunctionArn") (clojure.core/assoc :authorizer-function-arn (deser-authorizer-function-arn (input "authorizerFunctionArn"))) (clojure.core/contains? input "tokenKeyName") (clojure.core/assoc :token-key-name (deser-token-key-name (input "tokenKeyName"))) (clojure.core/contains? input "tokenSigningPublicKeys") (clojure.core/assoc :token-signing-public-keys (deser-public-key-map (input "tokenSigningPublicKeys"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-authorizer-status (input "status"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate")))))

(clojure.core/defn- deser-delivery-stream-name [input] input)

(clojure.core/defn- deser-billing-group-description [input] input)

(clojure.core/defn- deser-sqs-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :queue-url (deser-queue-url (input "queueUrl"))} (clojure.core/contains? input "useBase64") (clojure.core/assoc :use-base-64 (deser-use-base-64 (input "useBase64")))))

(clojure.core/defn- deser-s-3-version [input] input)

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-cognito-identity-pool-id [input] input)

(clojure.core/defn- deser-details-value [input] input)

(clojure.core/defn- deser-ports [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-port coll))) input))

(clojure.core/defn- deser-allowed [input] (clojure.core/cond-> {} (clojure.core/contains? input "policies") (clojure.core/assoc :policies (deser-policies (input "policies")))))

(clojure.core/defn- deser-percentage [input] input)

(clojure.core/defn- deser-job-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-arn coll))) input))

(clojure.core/defn- deser-missing-context-value [input] input)

(clojure.core/defn- deser-thing-connectivity-indexing-mode [input] (clojure.core/get {"OFF" :off, "STATUS" :status} input))

(clojure.core/defn- deser-denied [input] (clojure.core/cond-> {} (clojure.core/contains? input "implicitDeny") (clojure.core/assoc :implicit-deny (deser-implicit-deny (input "implicitDeny"))) (clojure.core/contains? input "explicitDeny") (clojure.core/assoc :explicit-deny (deser-explicit-deny (input "explicitDeny")))))

(clojure.core/defn- deser-policy-arn [input] input)

(clojure.core/defn- deser-code-signing-signature [input] (clojure.core/cond-> {} (clojure.core/contains? input "inlineDocument") (clojure.core/assoc :inline-document (deser-signature (input "inlineDocument")))))

(clojure.core/defn- deser-alert-target-arn [input] input)

(clojure.core/defn- deser-abort-threshold-percentage [input] input)

(clojure.core/defn- deser-audit-notification-type [input] (clojure.core/get {"SNS" :sns} input))

(clojure.core/defn- deser-s-3-file-url [input] input)

(clojure.core/defn- deser-report-type [input] (clojure.core/get {"ERRORS" :errors, "RESULTS" :results} input))

(clojure.core/defn- deser-thing-type-id [input] input)

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"DEVICE_CERTIFICATE" :device-certificate, "CA_CERTIFICATE" :ca-certificate, "IOT_POLICY" :iot-policy, "COGNITO_IDENTITY_POOL" :cognito-identity-pool, "CLIENT_ID" :client-id, "ACCOUNT_SETTINGS" :account-settings} input))

(clojure.core/defn- deser-alarm-name [input] input)

(clojure.core/defn- deser-job-execution-status-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "detailsMap") (clojure.core/assoc :details-map (deser-details-map (input "detailsMap")))))

(clojure.core/defn- deser-hash-key-field [input] input)

(clojure.core/defn- deser-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target coll))) input))

(clojure.core/defn- deser-thing-name [input] input)

(clojure.core/defn- deser-republish-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :topic (deser-topic-pattern (input "topic"))}))

(clojure.core/defn- deser-resource-identifier [input] (clojure.core/cond-> {} (clojure.core/contains? input "deviceCertificateId") (clojure.core/assoc :device-certificate-id (deser-certificate-id (input "deviceCertificateId"))) (clojure.core/contains? input "caCertificateId") (clojure.core/assoc :ca-certificate-id (deser-certificate-id (input "caCertificateId"))) (clojure.core/contains? input "cognitoIdentityPoolId") (clojure.core/assoc :cognito-identity-pool-id (deser-cognito-identity-pool-id (input "cognitoIdentityPoolId"))) (clojure.core/contains? input "clientId") (clojure.core/assoc :client-id (deser-client-id (input "clientId"))) (clojure.core/contains? input "policyVersionIdentifier") (clojure.core/assoc :policy-version-identifier (deser-policy-version-identifier (input "policyVersionIdentifier"))) (clojure.core/contains? input "account") (clojure.core/assoc :account (deser-aws-account-id (input "account")))))

(clojure.core/defn- deser-s-3-key [input] input)

(clojure.core/defn- deser-authorizer-arn [input] input)

(clojure.core/defn- deser-stream-version [input] input)

(clojure.core/defn- deser-job-execution-status [input] (clojure.core/get {"QUEUED" :queued, "IN_PROGRESS" :in-progress, "SUCCEEDED" :succeeded, "FAILED" :failed, "TIMED_OUT" :timed-out, "REJECTED" :rejected, "REMOVED" :removed, "CANCELED" :canceled} input))

(clojure.core/defn- deser-metric-value [input] (clojure.core/cond-> {} (clojure.core/contains? input "count") (clojure.core/assoc :count (deser-unsigned-long (input "count"))) (clojure.core/contains? input "cidrs") (clojure.core/assoc :cidrs (deser-cidrs (input "cidrs"))) (clojure.core/contains? input "ports") (clojure.core/assoc :ports (deser-ports (input "ports")))))

(clojure.core/defn- deser-job-process-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "numberOfTimedOutThings") (clojure.core/assoc :number-of-timed-out-things (deser-timed-out-things (input "numberOfTimedOutThings"))) (clojure.core/contains? input "numberOfCanceledThings") (clojure.core/assoc :number-of-canceled-things (deser-canceled-things (input "numberOfCanceledThings"))) (clojure.core/contains? input "numberOfQueuedThings") (clojure.core/assoc :number-of-queued-things (deser-queued-things (input "numberOfQueuedThings"))) (clojure.core/contains? input "numberOfInProgressThings") (clojure.core/assoc :number-of-in-progress-things (deser-in-progress-things (input "numberOfInProgressThings"))) (clojure.core/contains? input "numberOfRemovedThings") (clojure.core/assoc :number-of-removed-things (deser-removed-things (input "numberOfRemovedThings"))) (clojure.core/contains? input "numberOfFailedThings") (clojure.core/assoc :number-of-failed-things (deser-failed-things (input "numberOfFailedThings"))) (clojure.core/contains? input "numberOfSucceededThings") (clojure.core/assoc :number-of-succeeded-things (deser-succeeded-things (input "numberOfSucceededThings"))) (clojure.core/contains? input "numberOfRejectedThings") (clojure.core/assoc :number-of-rejected-things (deser-rejected-things (input "numberOfRejectedThings"))) (clojure.core/contains? input "processingTargets") (clojure.core/assoc :processing-targets (deser-processing-target-name-list (input "processingTargets")))))

(clojure.core/defn- deser-client-id [input] input)

(clojure.core/defn- deser-audit-check-configurations [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-audit-check-name k) (deser-audit-check-configuration v)])) input))

(clojure.core/defn- deser-elasticsearch-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :endpoint (deser-elasticsearch-endpoint (input "endpoint")), :index (deser-elasticsearch-index (input "index")), :type (deser-elasticsearch-type (input "type")), :id (deser-elasticsearch-id (input "id"))}))

(clojure.core/defn- deser-s-3-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "bucket") (clojure.core/assoc :bucket (deser-s-3-bucket (input "bucket"))) (clojure.core/contains? input "key") (clojure.core/assoc :key (deser-s-3-key (input "key"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-s-3-version (input "version")))))

(clojure.core/defn- deser-task-statistics [input] (clojure.core/cond-> {} (clojure.core/contains? input "totalChecks") (clojure.core/assoc :total-checks (deser-total-checks-count (input "totalChecks"))) (clojure.core/contains? input "inProgressChecks") (clojure.core/assoc :in-progress-checks (deser-in-progress-checks-count (input "inProgressChecks"))) (clojure.core/contains? input "waitingForDataCollectionChecks") (clojure.core/assoc :waiting-for-data-collection-checks (deser-waiting-for-data-collection-checks-count (input "waitingForDataCollectionChecks"))) (clojure.core/contains? input "compliantChecks") (clojure.core/assoc :compliant-checks (deser-compliant-checks-count (input "compliantChecks"))) (clojure.core/contains? input "nonCompliantChecks") (clojure.core/assoc :non-compliant-checks (deser-non-compliant-checks-count (input "nonCompliantChecks"))) (clojure.core/contains? input "failedChecks") (clojure.core/assoc :failed-checks (deser-failed-checks-count (input "failedChecks"))) (clojure.core/contains? input "canceledChecks") (clojure.core/assoc :canceled-checks (deser-canceled-checks-count (input "canceledChecks")))))

(clojure.core/defn- deser-elasticsearch-index [input] input)

(clojure.core/defn- deser-policies [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy coll))) input))

(clojure.core/defn- deser-certificate-arn [input] input)

(clojure.core/defn- deser-custom-code-signing [input] (clojure.core/cond-> {} (clojure.core/contains? input "signature") (clojure.core/assoc :signature (deser-code-signing-signature (input "signature"))) (clojure.core/contains? input "certificateChain") (clojure.core/assoc :certificate-chain (deser-code-signing-certificate-chain (input "certificateChain"))) (clojure.core/contains? input "hashAlgorithm") (clojure.core/assoc :hash-algorithm (deser-hash-algorithm (input "hashAlgorithm"))) (clojure.core/contains? input "signatureAlgorithm") (clojure.core/assoc :signature-algorithm (deser-signature-algorithm (input "signatureAlgorithm")))))

(clojure.core/defn- deser-table-name [input] input)

(clojure.core/defn- deser-s-3-bucket [input] input)

(clojure.core/defn- deser-billing-group-name [input] input)

(clojure.core/defn- deser-aws-iot-sql-version [input] input)

(clojure.core/defn- deser-stream [input] (clojure.core/cond-> {} (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-stream-id (input "streamId"))) (clojure.core/contains? input "fileId") (clojure.core/assoc :file-id (deser-file-id (input "fileId")))))

(clojure.core/defn- deser-sql [input] input)

(clojure.core/defn- deser-details-key [input] input)

(clojure.core/defn- deser-registry-s-3-bucket-name [input] input)

(clojure.core/defn- deser-creation-date [input] input)

(clojure.core/defn- deser-abort-action [input] (clojure.core/get {"CANCEL" :cancel} input))

(clojure.core/defn- deser-dynamo-db-action [input] (clojure.core/cond-> {:table-name (deser-table-name (input "tableName")), :role-arn (deser-aws-arn (input "roleArn")), :hash-key-field (deser-hash-key-field (input "hashKeyField")), :hash-key-value (deser-hash-key-value (input "hashKeyValue"))} (clojure.core/contains? input "rangeKeyValue") (clojure.core/assoc :range-key-value (deser-range-key-value (input "rangeKeyValue"))) (clojure.core/contains? input "rangeKeyField") (clojure.core/assoc :range-key-field (deser-range-key-field (input "rangeKeyField"))) (clojure.core/contains? input "hashKeyType") (clojure.core/assoc :hash-key-type (deser-dynamo-key-type (input "hashKeyType"))) (clojure.core/contains? input "operation") (clojure.core/assoc :operation (deser-dynamo-operation (input "operation"))) (clojure.core/contains? input "payloadField") (clojure.core/assoc :payload-field (deser-payload-field (input "payloadField"))) (clojure.core/contains? input "rangeKeyType") (clojure.core/assoc :range-key-type (deser-dynamo-key-type (input "rangeKeyType")))))

(clojure.core/defn- deser-violation-event-type [input] (clojure.core/get {"in-alarm" :inalarm, "alarm-cleared" :alarmcleared, "alarm-invalidated" :alarminvalidated} input))

(clojure.core/defn- deser-total-resources-count [input] input)

(clojure.core/defn- deser-topic-rule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-topic-rule-list-item coll))) input))

(clojure.core/defn- deser-security-profile-arn [input] input)

(clojure.core/defn- deser-policy-version-id [input] input)

(clojure.core/defn- deser-alert-target [input] (clojure.core/cond-> {:alert-target-arn (deser-alert-target-arn (input "alertTargetArn")), :role-arn (deser-role-arn (input "roleArn"))}))

(clojure.core/defn- deser-timestamp [input] input)

(clojure.core/defn- deser-dynamo-operation [input] input)

(clojure.core/defn- deser-resource-arn [input] input)

(clojure.core/defn- deser-authorizers [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-authorizer-summary coll))) input))

(clojure.core/defn- deser-processing-target-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-processing-target-name coll))) input))

(clojure.core/defn- deser-hash-algorithm [input] input)

(clojure.core/defn- deser-certificate-status [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive, "REVOKED" :revoked, "PENDING_TRANSFER" :pending-transfer, "REGISTER_INACTIVE" :register-inactive, "PENDING_ACTIVATION" :pending-activation} input))

(clojure.core/defn- deser-policy-version-identifier [input] (clojure.core/cond-> {} (clojure.core/contains? input "policyName") (clojure.core/assoc :policy-name (deser-policy-name (input "policyName"))) (clojure.core/contains? input "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (input "policyVersionId")))))

(clojure.core/defn- deser-security-profile-identifier [input] (clojure.core/cond-> {:name (deser-security-profile-name (input "name")), :arn (deser-security-profile-arn (input "arn"))}))

(clojure.core/defn- deser-thing-group-name-and-arn-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-name-and-arn coll))) input))

(clojure.core/defn- deser-customer-version [input] input)

(clojure.core/defn- deser-authorizer-name [input] input)

(clojure.core/defn- deser-policy [input] (clojure.core/cond-> {} (clojure.core/contains? input "policyName") (clojure.core/assoc :policy-name (deser-policy-name (input "policyName"))) (clojure.core/contains? input "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (input "policyArn")))))

(clojure.core/defn- deser-thing-connectivity [input] (clojure.core/cond-> {} (clojure.core/contains? input "connected") (clojure.core/assoc :connected (deser-boolean (input "connected"))) (clojure.core/contains? input "timestamp") (clojure.core/assoc :timestamp (deser-connectivity-timestamp (input "timestamp")))))

(clojure.core/defn- deser-key-pair [input] (clojure.core/cond-> {} (clojure.core/contains? input "PublicKey") (clojure.core/assoc :public-key (deser-public-key (input "PublicKey"))) (clojure.core/contains? input "PrivateKey") (clojure.core/assoc :private-key (deser-private-key (input "PrivateKey")))))

(clojure.core/defn- deser-maximum-per-minute [input] input)

(clojure.core/defn- deser-behavior-name [input] input)

(clojure.core/defn- deser-tag [input] (clojure.core/cond-> {} (clojure.core/contains? input "Key") (clojure.core/assoc :key (deser-tag-key (input "Key"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-tag-value (input "Value")))))

(clojure.core/defn- deser-s-3-destination [input] (clojure.core/cond-> {} (clojure.core/contains? input "bucket") (clojure.core/assoc :bucket (deser-s-3-bucket (input "bucket"))) (clojure.core/contains? input "prefix") (clojure.core/assoc :prefix (deser-prefix (input "prefix")))))

(clojure.core/defn- deser-resource [input] input)

(clojure.core/defn- deser-version [input] input)

(clojure.core/defn- deser-reason-code [input] input)

(clojure.core/defn- deser-job-execution-failure-type [input] (clojure.core/get {"FAILED" :failed, "REJECTED" :rejected, "TIMED_OUT" :timed-out, "ALL" :all} input))

(clojure.core/defn- deser-state-machine-name [input] input)

(clojure.core/defn- deser-elasticsearch-id [input] input)

(clojure.core/defn- deser-file-id [input] input)

(clojure.core/defn- deser-processing-target-name [input] input)

(clojure.core/defn- deserresource-arn [input] input)

(clojure.core/defn- deser-salesforce-action [input] (clojure.core/cond-> {:token (deser-salesforce-token (input "token")), :url (deser-salesforce-endpoint (input "url"))}))

(clojure.core/defn- deser-event-configurations [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-event-type k) (deser-configuration v)])) input))

(clojure.core/defn- deser-version-number [input] input)

(clojure.core/defn- deser-salesforce-endpoint [input] input)

(clojure.core/defn- deser-step-functions-action [input] (clojure.core/cond-> {:state-machine-name (deser-state-machine-name (input "stateMachineName")), :role-arn (deser-aws-arn (input "roleArn"))} (clojure.core/contains? input "executionNamePrefix") (clojure.core/assoc :execution-name-prefix (deser-execution-name-prefix (input "executionNamePrefix")))))

(clojure.core/defn- deser-job [input] (clojure.core/cond-> {} (clojure.core/contains? input "targetSelection") (clojure.core/assoc :target-selection (deser-target-selection (input "targetSelection"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-date-type (input "createdAt"))) (clojure.core/contains? input "timeoutConfig") (clojure.core/assoc :timeout-config (deser-timeout-config (input "timeoutConfig"))) (clojure.core/contains? input "completedAt") (clojure.core/assoc :completed-at (deser-date-type (input "completedAt"))) (clojure.core/contains? input "abortConfig") (clojure.core/assoc :abort-config (deser-abort-config (input "abortConfig"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-status (input "status"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "targets") (clojure.core/assoc :targets (deser-job-targets (input "targets"))) (clojure.core/contains? input "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (input "jobArn"))) (clojure.core/contains? input "presignedUrlConfig") (clojure.core/assoc :presigned-url-config (deser-presigned-url-config (input "presignedUrlConfig"))) (clojure.core/contains? input "reasonCode") (clojure.core/assoc :reason-code (deser-reason-code (input "reasonCode"))) (clojure.core/contains? input "jobProcessDetails") (clojure.core/assoc :job-process-details (deser-job-process-details (input "jobProcessDetails"))) (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "comment") (clojure.core/assoc :comment (deser-comment (input "comment"))) (clojure.core/contains? input "jobExecutionsRolloutConfig") (clojure.core/assoc :job-executions-rollout-config (deser-job-executions-rollout-config (input "jobExecutionsRolloutConfig"))) (clojure.core/contains? input "forceCanceled") (clojure.core/assoc :force-canceled (deser-forced (input "forceCanceled"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-job-description (input "description")))))

(clojure.core/defn- deser-is-default-version [input] input)

(clojure.core/defn- deser-auth-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "actionType") (clojure.core/assoc :action-type (deser-action-type (input "actionType"))) (clojure.core/contains? input "resources") (clojure.core/assoc :resources (deser-resources (input "resources")))))

(clojure.core/defn- deser-target [input] input)

(clojure.core/defn- deser-rollout-rate-per-minute [input] input)

(clojure.core/defn- deser-code [input] input)

(clojure.core/defn- deser-certificate-validity [input] (clojure.core/cond-> {} (clojure.core/contains? input "notBefore") (clojure.core/assoc :not-before (deser-date-type (input "notBefore"))) (clojure.core/contains? input "notAfter") (clojure.core/assoc :not-after (deser-date-type (input "notAfter")))))

(clojure.core/defn- deser-violation-id [input] input)

(clojure.core/defn- deser-action-type [input] (clojure.core/get {"PUBLISH" :publish, "SUBSCRIBE" :subscribe, "RECEIVE" :receive, "CONNECT" :connect} input))

(clojure.core/defn- deser-job-execution-summary-for-thing-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-job-execution-summary-for-thing coll))) input))

(clojure.core/defn- deser-thing-group-name [input] input)

(clojure.core/defn- deser-policy-target [input] input)

(clojure.core/defn- deser-ca-certificate-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "customerVersion") (clojure.core/assoc :customer-version (deser-customer-version (input "customerVersion"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (input "certificatePem"))) (clojure.core/contains? input "validity") (clojure.core/assoc :validity (deser-certificate-validity (input "validity"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate"))) (clojure.core/contains? input "ownedBy") (clojure.core/assoc :owned-by (deser-aws-account-id (input "ownedBy"))) (clojure.core/contains? input "autoRegistrationStatus") (clojure.core/assoc :auto-registration-status (deser-auto-registration-status (input "autoRegistrationStatus"))) (clojure.core/contains? input "generationId") (clojure.core/assoc :generation-id (deser-generation-id (input "generationId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-ca-certificate-status (input "status"))) (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId")))))

(clojure.core/defn- deser-execution-name-prefix [input] input)

(clojure.core/defn- deser-transfer-data [input] (clojure.core/cond-> {} (clojure.core/contains? input "transferMessage") (clojure.core/assoc :transfer-message (deser-message (input "transferMessage"))) (clojure.core/contains? input "rejectReason") (clojure.core/assoc :reject-reason (deser-message (input "rejectReason"))) (clojure.core/contains? input "transferDate") (clojure.core/assoc :transfer-date (deser-date-type (input "transferDate"))) (clojure.core/contains? input "acceptDate") (clojure.core/assoc :accept-date (deser-date-type (input "acceptDate"))) (clojure.core/contains? input "rejectDate") (clojure.core/assoc :reject-date (deser-date-type (input "rejectDate")))))

(clojure.core/defn- deser-evaluation-statistic [input] input)

(clojure.core/defn- deser-scheduled-audit-name [input] input)

(clojure.core/defn- deser-policy-versions [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy-version coll))) input))

(clojure.core/defn- deser-cloudwatch-alarm-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :alarm-name (deser-alarm-name (input "alarmName")), :state-reason (deser-state-reason (input "stateReason")), :state-value (deser-state-value (input "stateValue"))}))

(clojure.core/defn- deser-signing-job-id [input] input)

(clojure.core/defn- deser-lambda-action [input] (clojure.core/cond-> {:function-arn (deser-function-arn (input "functionArn"))}))

(clojure.core/defn- deser-bucket-name [input] input)

(clojure.core/defn- deser-failed-checks-count [input] input)

(clojure.core/defn- deser-certificate-id [input] input)

(clojure.core/defn- deser-ota-updates-summary [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ota-update-summary coll))) input))

(clojure.core/defn- deser-ota-update-status [input] (clojure.core/get {"CREATE_PENDING" :create-pending, "CREATE_IN_PROGRESS" :create-in-progress, "CREATE_COMPLETE" :create-complete, "CREATE_FAILED" :create-failed} input))

(clojure.core/defn- deser-related-resources [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-related-resource coll))) input))

(clojure.core/defn- deser-endpoint-address [input] input)

(clojure.core/defn- deser-in-progress-things [input] input)

(clojure.core/defn- deser-certificate-pem [input] input)

(clojure.core/defn- deser-file-name [input] input)

(clojure.core/defn- deser-job-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (input "jobArn"))) (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (input "thingGroupId"))) (clojure.core/contains? input "targetSelection") (clojure.core/assoc :target-selection (deser-target-selection (input "targetSelection"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-status (input "status"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-date-type (input "createdAt"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "completedAt") (clojure.core/assoc :completed-at (deser-date-type (input "completedAt")))))

(clojure.core/defn- deser-thing-document [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "thingId") (clojure.core/assoc :thing-id (deser-thing-id (input "thingId"))) (clojure.core/contains? input "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (input "thingTypeName"))) (clojure.core/contains? input "thingGroupNames") (clojure.core/assoc :thing-group-names (deser-thing-group-name-list (input "thingGroupNames"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "shadow") (clojure.core/assoc :shadow (deser-json-document (input "shadow"))) (clojure.core/contains? input "connectivity") (clojure.core/assoc :connectivity (deser-thing-connectivity (input "connectivity")))))

(clojure.core/defn- deser-ota-update-id [input] input)

(clojure.core/defn- deser-action [input] (clojure.core/cond-> {} (clojure.core/contains? input "dynamoDB") (clojure.core/assoc :dynamo-db (deser-dynamo-db-action (input "dynamoDB"))) (clojure.core/contains? input "sns") (clojure.core/assoc :sns (deser-sns-action (input "sns"))) (clojure.core/contains? input "cloudwatchAlarm") (clojure.core/assoc :cloudwatch-alarm (deser-cloudwatch-alarm-action (input "cloudwatchAlarm"))) (clojure.core/contains? input "iotAnalytics") (clojure.core/assoc :iot-analytics (deser-iot-analytics-action (input "iotAnalytics"))) (clojure.core/contains? input "republish") (clojure.core/assoc :republish (deser-republish-action (input "republish"))) (clojure.core/contains? input "kinesis") (clojure.core/assoc :kinesis (deser-kinesis-action (input "kinesis"))) (clojure.core/contains? input "s3") (clojure.core/assoc :s-3 (deser-s-3-action (input "s3"))) (clojure.core/contains? input "salesforce") (clojure.core/assoc :salesforce (deser-salesforce-action (input "salesforce"))) (clojure.core/contains? input "sqs") (clojure.core/assoc :sqs (deser-sqs-action (input "sqs"))) (clojure.core/contains? input "elasticsearch") (clojure.core/assoc :elasticsearch (deser-elasticsearch-action (input "elasticsearch"))) (clojure.core/contains? input "cloudwatchMetric") (clojure.core/assoc :cloudwatch-metric (deser-cloudwatch-metric-action (input "cloudwatchMetric"))) (clojure.core/contains? input "firehose") (clojure.core/assoc :firehose (deser-firehose-action (input "firehose"))) (clojure.core/contains? input "dynamoDBv2") (clojure.core/assoc :dynamo-d-bv-2 (deser-dynamo-d-bv-2-action (input "dynamoDBv2"))) (clojure.core/contains? input "lambda") (clojure.core/assoc :lambda (deser-lambda-action (input "lambda"))) (clojure.core/contains? input "stepFunctions") (clojure.core/assoc :step-functions (deser-step-functions-action (input "stepFunctions"))) (clojure.core/contains? input "iotEvents") (clojure.core/assoc :iot-events (deser-iot-events-action (input "iotEvents")))))

(clojure.core/defn- deser-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-enabled (input "Enabled")))))

(clojure.core/defn- deser-thing-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-type-definition coll))) input))

(clojure.core/defn- deser-created-at-date [input] input)

(clojure.core/defn- deser-job-execution-summary-for-thing [input] (clojure.core/cond-> {} (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "jobExecutionSummary") (clojure.core/assoc :job-execution-summary (deser-job-execution-summary (input "jobExecutionSummary")))))

(clojure.core/defn- deser-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-certificate-status (input "status"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-increment-factor [input] input)

(clojure.core/defn- deser-job-description [input] input)

(clojure.core/defn- deser-state-reason [input] input)

(clojure.core/defn- deser-aws-iot-job-id [input] input)

(clojure.core/defn- deser-approximate-seconds-before-timed-out [input] input)

(clojure.core/defn- deser-elasticsearch-endpoint [input] input)

(clojure.core/defn- deser-ota-update-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "awsJobExecutionsRolloutConfig") (clojure.core/assoc :aws-job-executions-rollout-config (deser-aws-job-executions-rollout-config (input "awsJobExecutionsRolloutConfig"))) (clojure.core/contains? input "targetSelection") (clojure.core/assoc :target-selection (deser-target-selection (input "targetSelection"))) (clojure.core/contains? input "otaUpdateId") (clojure.core/assoc :ota-update-id (deser-ota-update-id (input "otaUpdateId"))) (clojure.core/contains? input "otaUpdateStatus") (clojure.core/assoc :ota-update-status (deser-ota-update-status (input "otaUpdateStatus"))) (clojure.core/contains? input "otaUpdateFiles") (clojure.core/assoc :ota-update-files (deser-ota-update-files (input "otaUpdateFiles"))) (clojure.core/contains? input "errorInfo") (clojure.core/assoc :error-info (deser-error-info (input "errorInfo"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate"))) (clojure.core/contains? input "otaUpdateArn") (clojure.core/assoc :ota-update-arn (deser-ota-update-arn (input "otaUpdateArn"))) (clojure.core/contains? input "targets") (clojure.core/assoc :targets (deser-targets (input "targets"))) (clojure.core/contains? input "awsIotJobArn") (clojure.core/assoc :aws-iot-job-arn (deser-aws-iot-job-arn (input "awsIotJobArn"))) (clojure.core/contains? input "awsIotJobId") (clojure.core/assoc :aws-iot-job-id (deser-aws-iot-job-id (input "awsIotJobId"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-ota-update-description (input "description"))) (clojure.core/contains? input "additionalParameters") (clojure.core/assoc :additional-parameters (deser-additional-parameter-map (input "additionalParameters")))))

(clojure.core/defn- deser-signing-profile-name [input] input)

(clojure.core/defn- deser-effective-policy [input] (clojure.core/cond-> {} (clojure.core/contains? input "policyName") (clojure.core/assoc :policy-name (deser-policy-name (input "policyName"))) (clojure.core/contains? input "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (input "policyArn"))) (clojure.core/contains? input "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (input "policyDocument")))))

(clojure.core/defn- deser-details-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-details-key k) (deser-details-value v)])) input))

(clojure.core/defn- deser-consecutive-datapoints-to-clear [input] input)

(clojure.core/defn- deser-audit-check-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "enabled") (clojure.core/assoc :enabled (deser-enabled (input "enabled")))))

(clojure.core/defn- deser-audit-task-status [input] (clojure.core/get {"IN_PROGRESS" :in-progress, "COMPLETED" :completed, "FAILED" :failed, "CANCELED" :canceled} input))

(clojure.core/defn- deser-s-3-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :bucket-name (deser-bucket-name (input "bucketName")), :key (deser-key (input "key"))} (clojure.core/contains? input "cannedAcl") (clojure.core/assoc :canned-acl (deser-canned-access-control-list (input "cannedAcl")))))

(clojure.core/defn- deser-job-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "queuedAt") (clojure.core/assoc :queued-at (deser-date-type (input "queuedAt"))) (clojure.core/contains? input "startedAt") (clojure.core/assoc :started-at (deser-date-type (input "startedAt"))) (clojure.core/contains? input "approximateSecondsBeforeTimedOut") (clojure.core/assoc :approximate-seconds-before-timed-out (deser-approximate-seconds-before-timed-out (input "approximateSecondsBeforeTimedOut"))) (clojure.core/contains? input "statusDetails") (clojure.core/assoc :status-details (deser-job-execution-status-details (input "statusDetails"))) (clojure.core/contains? input "executionNumber") (clojure.core/assoc :execution-number (deser-execution-number (input "executionNumber"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-execution-status (input "status"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (input "thingArn"))) (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "versionNumber") (clojure.core/assoc :version-number (deser-version-number (input "versionNumber"))) (clojure.core/contains? input "forceCanceled") (clojure.core/assoc :force-canceled (deser-forced (input "forceCanceled")))))

(clojure.core/defn- deser-iot-analytics-action [input] (clojure.core/cond-> {} (clojure.core/contains? input "channelArn") (clojure.core/assoc :channel-arn (deser-aws-arn (input "channelArn"))) (clojure.core/contains? input "channelName") (clojure.core/assoc :channel-name (deser-channel-name (input "channelName"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-aws-arn (input "roleArn")))))

(clojure.core/defn- deser-security-profile-target-mapping [input] (clojure.core/cond-> {} (clojure.core/contains? input "securityProfileIdentifier") (clojure.core/assoc :security-profile-identifier (deser-security-profile-identifier (input "securityProfileIdentifier"))) (clojure.core/contains? input "target") (clojure.core/assoc :target (deser-security-profile-target (input "target")))))

(clojure.core/defn- deser-generation-id [input] input)

(clojure.core/defn- deser-kinesis-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :stream-name (deser-stream-name (input "streamName"))} (clojure.core/contains? input "partitionKey") (clojure.core/assoc :partition-key (deser-partition-key (input "partitionKey")))))

(clojure.core/defn- deser-ca-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-ca-certificate-status (input "status"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-public-key [input] input)

(clojure.core/defn- deser-job-arn [input] input)

(clojure.core/defn- deser-valid [input] input)

(clojure.core/defn- deser-audit-task-id [input] input)

(clojure.core/defn- deser-payload-field [input] input)

(clojure.core/defn- deser-authorizer-function-arn [input] input)

(clojure.core/defn- deser-topic-rule-list-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "ruleArn") (clojure.core/assoc :rule-arn (deser-rule-arn (input "ruleArn"))) (clojure.core/contains? input "ruleName") (clojure.core/assoc :rule-name (deser-rule-name (input "ruleName"))) (clojure.core/contains? input "topicPattern") (clojure.core/assoc :topic-pattern (deser-topic-pattern (input "topicPattern"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-created-at-date (input "createdAt"))) (clojure.core/contains? input "ruleDisabled") (clojure.core/assoc :rule-disabled (deser-is-disabled (input "ruleDisabled")))))

(clojure.core/defn- deser-is-authenticated [input] input)

(clojure.core/defn- deser-firehose-separator [input] input)

(clojure.core/defn- deser-seconds [input] input)

(clojure.core/defn- deser-auth-result [input] (clojure.core/cond-> {} (clojure.core/contains? input "authInfo") (clojure.core/assoc :auth-info (deser-auth-info (input "authInfo"))) (clojure.core/contains? input "allowed") (clojure.core/assoc :allowed (deser-allowed (input "allowed"))) (clojure.core/contains? input "denied") (clojure.core/assoc :denied (deser-denied (input "denied"))) (clojure.core/contains? input "authDecision") (clojure.core/assoc :auth-decision (deser-auth-decision (input "authDecision"))) (clojure.core/contains? input "missingContextValues") (clojure.core/assoc :missing-context-values (deser-missing-context-values (input "missingContextValues")))))

(clojure.core/defn- deser-principals [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-principal-arn coll))) input))

(clojure.core/defn- deser-validation-errors [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-validation-error coll))) input))

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- deser-topic-rule [input] (clojure.core/cond-> {} (clojure.core/contains? input "ruleName") (clojure.core/assoc :rule-name (deser-rule-name (input "ruleName"))) (clojure.core/contains? input "sql") (clojure.core/assoc :sql (deser-sql (input "sql"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-description (input "description"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-created-at-date (input "createdAt"))) (clojure.core/contains? input "actions") (clojure.core/assoc :actions (deser-action-list (input "actions"))) (clojure.core/contains? input "ruleDisabled") (clojure.core/assoc :rule-disabled (deser-is-disabled (input "ruleDisabled"))) (clojure.core/contains? input "awsIotSqlVersion") (clojure.core/assoc :aws-iot-sql-version (deser-aws-iot-sql-version (input "awsIotSqlVersion"))) (clojure.core/contains? input "errorAction") (clojure.core/assoc :error-action (deser-action (input "errorAction")))))

(clojure.core/defn- deser-registration-code [input] input)

(clojure.core/defn- deser-job-id [input] input)

(clojure.core/defn- response-delete-stream-response ([input] (response-delete-stream-response nil input)) ([resultWrapper233584 input] (clojure.core/let [rawinput233583 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233585 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-effective-policies-response ([input] (response-get-effective-policies-response nil input)) ([resultWrapper233587 input] (clojure.core/let [rawinput233586 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233588 {"effectivePolicies" (rawinput233586 "effectivePolicies")}] (clojure.core/cond-> {} (letvar233588 "effectivePolicies") (clojure.core/assoc :effective-policies (deser-effective-policies (clojure.core/get-in letvar233588 ["effectivePolicies"])))))))

(clojure.core/defn- response-list-policy-versions-response ([input] (response-list-policy-versions-response nil input)) ([resultWrapper233590 input] (clojure.core/let [rawinput233589 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233591 {"policyVersions" (rawinput233589 "policyVersions")}] (clojure.core/cond-> {} (letvar233591 "policyVersions") (clojure.core/assoc :policy-versions (deser-policy-versions (clojure.core/get-in letvar233591 ["policyVersions"])))))))

(clojure.core/defn- response-delete-scheduled-audit-response ([input] (response-delete-scheduled-audit-response nil input)) ([resultWrapper233593 input] (clojure.core/let [rawinput233592 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233594 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-event-configurations-response ([input] (response-describe-event-configurations-response nil input)) ([resultWrapper233596 input] (clojure.core/let [rawinput233595 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233597 {"eventConfigurations" (rawinput233595 "eventConfigurations"), "creationDate" (rawinput233595 "creationDate"), "lastModifiedDate" (rawinput233595 "lastModifiedDate")}] (clojure.core/cond-> {} (letvar233597 "eventConfigurations") (clojure.core/assoc :event-configurations (deser-event-configurations (clojure.core/get-in letvar233597 ["eventConfigurations"]))) (letvar233597 "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (clojure.core/get-in letvar233597 ["creationDate"]))) (letvar233597 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-last-modified-date (clojure.core/get-in letvar233597 ["lastModifiedDate"])))))))

(clojure.core/defn- response-unauthorized-exception ([input] (response-unauthorized-exception nil input)) ([resultWrapper233599 input] (clojure.core/let [rawinput233598 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233600 {"message" (rawinput233598 "message")}] (clojure.core/cond-> {} (letvar233600 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233600 ["message"])))))))

(clojure.core/defn- response-update-security-profile-response ([input] (response-update-security-profile-response nil input)) ([resultWrapper233602 input] (clojure.core/let [rawinput233601 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233603 {"creationDate" (rawinput233601 "creationDate"), "securityProfileArn" (rawinput233601 "securityProfileArn"), "additionalMetricsToRetain" (rawinput233601 "additionalMetricsToRetain"), "behaviors" (rawinput233601 "behaviors"), "lastModifiedDate" (rawinput233601 "lastModifiedDate"), "securityProfileDescription" (rawinput233601 "securityProfileDescription"), "version" (rawinput233601 "version"), "securityProfileName" (rawinput233601 "securityProfileName"), "alertTargets" (rawinput233601 "alertTargets")}] (clojure.core/cond-> {} (letvar233603 "creationDate") (clojure.core/assoc :creation-date (deser-timestamp (clojure.core/get-in letvar233603 ["creationDate"]))) (letvar233603 "securityProfileArn") (clojure.core/assoc :security-profile-arn (deser-security-profile-arn (clojure.core/get-in letvar233603 ["securityProfileArn"]))) (letvar233603 "additionalMetricsToRetain") (clojure.core/assoc :additional-metrics-to-retain (deser-additional-metrics-to-retain-list (clojure.core/get-in letvar233603 ["additionalMetricsToRetain"]))) (letvar233603 "behaviors") (clojure.core/assoc :behaviors (deser-behaviors (clojure.core/get-in letvar233603 ["behaviors"]))) (letvar233603 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-timestamp (clojure.core/get-in letvar233603 ["lastModifiedDate"]))) (letvar233603 "securityProfileDescription") (clojure.core/assoc :security-profile-description (deser-security-profile-description (clojure.core/get-in letvar233603 ["securityProfileDescription"]))) (letvar233603 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar233603 ["version"]))) (letvar233603 "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (clojure.core/get-in letvar233603 ["securityProfileName"]))) (letvar233603 "alertTargets") (clojure.core/assoc :alert-targets (deser-alert-targets (clojure.core/get-in letvar233603 ["alertTargets"])))))))

(clojure.core/defn- response-list-targets-for-policy-response ([input] (response-list-targets-for-policy-response nil input)) ([resultWrapper233605 input] (clojure.core/let [rawinput233604 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233606 {"targets" (rawinput233604 "targets"), "nextMarker" (rawinput233604 "nextMarker")}] (clojure.core/cond-> {} (letvar233606 "targets") (clojure.core/assoc :targets (deser-policy-targets (clojure.core/get-in letvar233606 ["targets"]))) (letvar233606 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233606 ["nextMarker"])))))))

(clojure.core/defn- response-detach-thing-principal-response ([input] (response-detach-thing-principal-response nil input)) ([resultWrapper233608 input] (clojure.core/let [rawinput233607 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233609 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-thing-registration-task-response ([input] (response-start-thing-registration-task-response nil input)) ([resultWrapper233611 input] (clojure.core/let [rawinput233610 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233612 {"taskId" (rawinput233610 "taskId")}] (clojure.core/cond-> {} (letvar233612 "taskId") (clojure.core/assoc :task-id (deser-task-id (clojure.core/get-in letvar233612 ["taskId"])))))))

(clojure.core/defn- response-list-thing-groups-response ([input] (response-list-thing-groups-response nil input)) ([resultWrapper233614 input] (clojure.core/let [rawinput233613 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233615 {"thingGroups" (rawinput233613 "thingGroups"), "nextToken" (rawinput233613 "nextToken")}] (clojure.core/cond-> {} (letvar233615 "thingGroups") (clojure.core/assoc :thing-groups (deser-thing-group-name-and-arn-list (clojure.core/get-in letvar233615 ["thingGroups"]))) (letvar233615 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233615 ["nextToken"])))))))

(clojure.core/defn- response-delete-registration-code-response ([input] (response-delete-registration-code-response nil input)) ([resultWrapper233617 input] (clojure.core/let [rawinput233616 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233618 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-security-profiles-for-target-response ([input] (response-list-security-profiles-for-target-response nil input)) ([resultWrapper233620 input] (clojure.core/let [rawinput233619 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233621 {"securityProfileTargetMappings" (rawinput233619 "securityProfileTargetMappings"), "nextToken" (rawinput233619 "nextToken")}] (clojure.core/cond-> {} (letvar233621 "securityProfileTargetMappings") (clojure.core/assoc :security-profile-target-mappings (deser-security-profile-target-mappings (clojure.core/get-in letvar233621 ["securityProfileTargetMappings"]))) (letvar233621 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233621 ["nextToken"])))))))

(clojure.core/defn- response-list-principal-things-response ([input] (response-list-principal-things-response nil input)) ([resultWrapper233623 input] (clojure.core/let [rawinput233622 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233624 {"things" (rawinput233622 "things"), "nextToken" (rawinput233622 "nextToken")}] (clojure.core/cond-> {} (letvar233624 "things") (clojure.core/assoc :things (deser-thing-name-list (clojure.core/get-in letvar233624 ["things"]))) (letvar233624 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233624 ["nextToken"])))))))

(clojure.core/defn- response-create-billing-group-response ([input] (response-create-billing-group-response nil input)) ([resultWrapper233626 input] (clojure.core/let [rawinput233625 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233627 {"billingGroupName" (rawinput233625 "billingGroupName"), "billingGroupArn" (rawinput233625 "billingGroupArn"), "billingGroupId" (rawinput233625 "billingGroupId")}] (clojure.core/cond-> {} (letvar233627 "billingGroupName") (clojure.core/assoc :billing-group-name (deser-billing-group-name (clojure.core/get-in letvar233627 ["billingGroupName"]))) (letvar233627 "billingGroupArn") (clojure.core/assoc :billing-group-arn (deser-billing-group-arn (clojure.core/get-in letvar233627 ["billingGroupArn"]))) (letvar233627 "billingGroupId") (clojure.core/assoc :billing-group-id (deser-billing-group-id (clojure.core/get-in letvar233627 ["billingGroupId"])))))))

(clojure.core/defn- response-create-ota-update-response ([input] (response-create-ota-update-response nil input)) ([resultWrapper233629 input] (clojure.core/let [rawinput233628 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233630 {"otaUpdateId" (rawinput233628 "otaUpdateId"), "awsIotJobId" (rawinput233628 "awsIotJobId"), "otaUpdateArn" (rawinput233628 "otaUpdateArn"), "awsIotJobArn" (rawinput233628 "awsIotJobArn"), "otaUpdateStatus" (rawinput233628 "otaUpdateStatus")}] (clojure.core/cond-> {} (letvar233630 "otaUpdateId") (clojure.core/assoc :ota-update-id (deser-ota-update-id (clojure.core/get-in letvar233630 ["otaUpdateId"]))) (letvar233630 "awsIotJobId") (clojure.core/assoc :aws-iot-job-id (deser-aws-iot-job-id (clojure.core/get-in letvar233630 ["awsIotJobId"]))) (letvar233630 "otaUpdateArn") (clojure.core/assoc :ota-update-arn (deser-ota-update-arn (clojure.core/get-in letvar233630 ["otaUpdateArn"]))) (letvar233630 "awsIotJobArn") (clojure.core/assoc :aws-iot-job-arn (deser-aws-iot-job-arn (clojure.core/get-in letvar233630 ["awsIotJobArn"]))) (letvar233630 "otaUpdateStatus") (clojure.core/assoc :ota-update-status (deser-ota-update-status (clojure.core/get-in letvar233630 ["otaUpdateStatus"])))))))

(clojure.core/defn- response-cancel-job-response ([input] (response-cancel-job-response nil input)) ([resultWrapper233632 input] (clojure.core/let [rawinput233631 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233633 {"jobArn" (rawinput233631 "jobArn"), "jobId" (rawinput233631 "jobId"), "description" (rawinput233631 "description")}] (clojure.core/cond-> {} (letvar233633 "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (clojure.core/get-in letvar233633 ["jobArn"]))) (letvar233633 "jobId") (clojure.core/assoc :job-id (deser-job-id (clojure.core/get-in letvar233633 ["jobId"]))) (letvar233633 "description") (clojure.core/assoc :description (deser-job-description (clojure.core/get-in letvar233633 ["description"])))))))

(clojure.core/defn- response-list-scheduled-audits-response ([input] (response-list-scheduled-audits-response nil input)) ([resultWrapper233635 input] (clojure.core/let [rawinput233634 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233636 {"scheduledAudits" (rawinput233634 "scheduledAudits"), "nextToken" (rawinput233634 "nextToken")}] (clojure.core/cond-> {} (letvar233636 "scheduledAudits") (clojure.core/assoc :scheduled-audits (deser-scheduled-audit-metadata-list (clojure.core/get-in letvar233636 ["scheduledAudits"]))) (letvar233636 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233636 ["nextToken"])))))))

(clojure.core/defn- response-list-targets-for-security-profile-response ([input] (response-list-targets-for-security-profile-response nil input)) ([resultWrapper233638 input] (clojure.core/let [rawinput233637 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233639 {"securityProfileTargets" (rawinput233637 "securityProfileTargets"), "nextToken" (rawinput233637 "nextToken")}] (clojure.core/cond-> {} (letvar233639 "securityProfileTargets") (clojure.core/assoc :security-profile-targets (deser-security-profile-targets (clojure.core/get-in letvar233639 ["securityProfileTargets"]))) (letvar233639 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233639 ["nextToken"])))))))

(clojure.core/defn- response-create-role-alias-response ([input] (response-create-role-alias-response nil input)) ([resultWrapper233641 input] (clojure.core/let [rawinput233640 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233642 {"roleAlias" (rawinput233640 "roleAlias"), "roleAliasArn" (rawinput233640 "roleAliasArn")}] (clojure.core/cond-> {} (letvar233642 "roleAlias") (clojure.core/assoc :role-alias (deser-role-alias (clojure.core/get-in letvar233642 ["roleAlias"]))) (letvar233642 "roleAliasArn") (clojure.core/assoc :role-alias-arn (deser-role-alias-arn (clojure.core/get-in letvar233642 ["roleAliasArn"])))))))

(clojure.core/defn- response-describe-thing-response ([input] (response-describe-thing-response nil input)) ([resultWrapper233644 input] (clojure.core/let [rawinput233643 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233645 {"defaultClientId" (rawinput233643 "defaultClientId"), "thingName" (rawinput233643 "thingName"), "thingId" (rawinput233643 "thingId"), "thingArn" (rawinput233643 "thingArn"), "thingTypeName" (rawinput233643 "thingTypeName"), "attributes" (rawinput233643 "attributes"), "version" (rawinput233643 "version"), "billingGroupName" (rawinput233643 "billingGroupName")}] (clojure.core/cond-> {} (letvar233645 "defaultClientId") (clojure.core/assoc :default-client-id (deser-client-id (clojure.core/get-in letvar233645 ["defaultClientId"]))) (letvar233645 "thingName") (clojure.core/assoc :thing-name (deser-thing-name (clojure.core/get-in letvar233645 ["thingName"]))) (letvar233645 "thingId") (clojure.core/assoc :thing-id (deser-thing-id (clojure.core/get-in letvar233645 ["thingId"]))) (letvar233645 "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (clojure.core/get-in letvar233645 ["thingArn"]))) (letvar233645 "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (clojure.core/get-in letvar233645 ["thingTypeName"]))) (letvar233645 "attributes") (clojure.core/assoc :attributes (deser-attributes (clojure.core/get-in letvar233645 ["attributes"]))) (letvar233645 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar233645 ["version"]))) (letvar233645 "billingGroupName") (clojure.core/assoc :billing-group-name (deser-billing-group-name (clojure.core/get-in letvar233645 ["billingGroupName"])))))))

(clojure.core/defn- response-certificate-state-exception ([input] (response-certificate-state-exception nil input)) ([resultWrapper233647 input] (clojure.core/let [rawinput233646 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233648 {"message" (rawinput233646 "message")}] (clojure.core/cond-> {} (letvar233648 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233648 ["message"])))))))

(clojure.core/defn- response-test-invoke-authorizer-response ([input] (response-test-invoke-authorizer-response nil input)) ([resultWrapper233650 input] (clojure.core/let [rawinput233649 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233651 {"isAuthenticated" (rawinput233649 "isAuthenticated"), "principalId" (rawinput233649 "principalId"), "policyDocuments" (rawinput233649 "policyDocuments"), "refreshAfterInSeconds" (rawinput233649 "refreshAfterInSeconds"), "disconnectAfterInSeconds" (rawinput233649 "disconnectAfterInSeconds")}] (clojure.core/cond-> {} (letvar233651 "isAuthenticated") (clojure.core/assoc :is-authenticated (deser-is-authenticated (clojure.core/get-in letvar233651 ["isAuthenticated"]))) (letvar233651 "principalId") (clojure.core/assoc :principal-id (deser-principal-id (clojure.core/get-in letvar233651 ["principalId"]))) (letvar233651 "policyDocuments") (clojure.core/assoc :policy-documents (deser-policy-documents (clojure.core/get-in letvar233651 ["policyDocuments"]))) (letvar233651 "refreshAfterInSeconds") (clojure.core/assoc :refresh-after-in-seconds (deser-seconds (clojure.core/get-in letvar233651 ["refreshAfterInSeconds"]))) (letvar233651 "disconnectAfterInSeconds") (clojure.core/assoc :disconnect-after-in-seconds (deser-seconds (clojure.core/get-in letvar233651 ["disconnectAfterInSeconds"])))))))

(clojure.core/defn- response-invalid-request-exception ([input] (response-invalid-request-exception nil input)) ([resultWrapper233653 input] (clojure.core/let [rawinput233652 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233654 {"message" (rawinput233652 "message")}] (clojure.core/cond-> {} (letvar233654 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233654 ["message"])))))))

(clojure.core/defn- response-cancel-audit-task-response ([input] (response-cancel-audit-task-response nil input)) ([resultWrapper233656 input] (clojure.core/let [rawinput233655 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233657 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-tags-for-resource-response ([input] (response-list-tags-for-resource-response nil input)) ([resultWrapper233659 input] (clojure.core/let [rawinput233658 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233660 {"tags" (rawinput233658 "tags"), "nextToken" (rawinput233658 "nextToken")}] (clojure.core/cond-> {} (letvar233660 "tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar233660 ["tags"]))) (letvar233660 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233660 ["nextToken"])))))))

(clojure.core/defn- response-certificate-validation-exception ([input] (response-certificate-validation-exception nil input)) ([resultWrapper233662 input] (clojure.core/let [rawinput233661 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233663 {"message" (rawinput233661 "message")}] (clojure.core/cond-> {} (letvar233663 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233663 ["message"])))))))

(clojure.core/defn- response-update-thing-group-response ([input] (response-update-thing-group-response nil input)) ([resultWrapper233665 input] (clojure.core/let [rawinput233664 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233666 {"version" (rawinput233664 "version")}] (clojure.core/cond-> {} (letvar233666 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar233666 ["version"])))))))

(clojure.core/defn- response-get-logging-options-response ([input] (response-get-logging-options-response nil input)) ([resultWrapper233668 input] (clojure.core/let [rawinput233667 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233669 {"roleArn" (rawinput233667 "roleArn"), "logLevel" (rawinput233667 "logLevel")}] (clojure.core/cond-> {} (letvar233669 "roleArn") (clojure.core/assoc :role-arn (deser-aws-arn (clojure.core/get-in letvar233669 ["roleArn"]))) (letvar233669 "logLevel") (clojure.core/assoc :log-level (deser-log-level (clojure.core/get-in letvar233669 ["logLevel"])))))))

(clojure.core/defn- response-get-v-2-logging-options-response ([input] (response-get-v-2-logging-options-response nil input)) ([resultWrapper233671 input] (clojure.core/let [rawinput233670 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233672 {"roleArn" (rawinput233670 "roleArn"), "defaultLogLevel" (rawinput233670 "defaultLogLevel"), "disableAllLogs" (rawinput233670 "disableAllLogs")}] (clojure.core/cond-> {} (letvar233672 "roleArn") (clojure.core/assoc :role-arn (deser-aws-arn (clojure.core/get-in letvar233672 ["roleArn"]))) (letvar233672 "defaultLogLevel") (clojure.core/assoc :default-log-level (deser-log-level (clojure.core/get-in letvar233672 ["defaultLogLevel"]))) (letvar233672 "disableAllLogs") (clojure.core/assoc :disable-all-logs (deser-disable-all-logs (clojure.core/get-in letvar233672 ["disableAllLogs"])))))))

(clojure.core/defn- response-list-thing-groups-for-thing-response ([input] (response-list-thing-groups-for-thing-response nil input)) ([resultWrapper233674 input] (clojure.core/let [rawinput233673 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233675 {"thingGroups" (rawinput233673 "thingGroups"), "nextToken" (rawinput233673 "nextToken")}] (clojure.core/cond-> {} (letvar233675 "thingGroups") (clojure.core/assoc :thing-groups (deser-thing-group-name-and-arn-list (clojure.core/get-in letvar233675 ["thingGroups"]))) (letvar233675 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233675 ["nextToken"])))))))

(clojure.core/defn- response-describe-account-audit-configuration-response ([input] (response-describe-account-audit-configuration-response nil input)) ([resultWrapper233677 input] (clojure.core/let [rawinput233676 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233678 {"roleArn" (rawinput233676 "roleArn"), "auditNotificationTargetConfigurations" (rawinput233676 "auditNotificationTargetConfigurations"), "auditCheckConfigurations" (rawinput233676 "auditCheckConfigurations")}] (clojure.core/cond-> {} (letvar233678 "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (clojure.core/get-in letvar233678 ["roleArn"]))) (letvar233678 "auditNotificationTargetConfigurations") (clojure.core/assoc :audit-notification-target-configurations (deser-audit-notification-target-configurations (clojure.core/get-in letvar233678 ["auditNotificationTargetConfigurations"]))) (letvar233678 "auditCheckConfigurations") (clojure.core/assoc :audit-check-configurations (deser-audit-check-configurations (clojure.core/get-in letvar233678 ["auditCheckConfigurations"])))))))

(clojure.core/defn- response-describe-index-response ([input] (response-describe-index-response nil input)) ([resultWrapper233680 input] (clojure.core/let [rawinput233679 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233681 {"indexName" (rawinput233679 "indexName"), "indexStatus" (rawinput233679 "indexStatus"), "schema" (rawinput233679 "schema")}] (clojure.core/cond-> {} (letvar233681 "indexName") (clojure.core/assoc :index-name (deser-index-name (clojure.core/get-in letvar233681 ["indexName"]))) (letvar233681 "indexStatus") (clojure.core/assoc :index-status (deser-index-status (clojure.core/get-in letvar233681 ["indexStatus"]))) (letvar233681 "schema") (clojure.core/assoc :schema (deser-index-schema (clojure.core/get-in letvar233681 ["schema"])))))))

(clojure.core/defn- response-list-certificates-response ([input] (response-list-certificates-response nil input)) ([resultWrapper233683 input] (clojure.core/let [rawinput233682 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233684 {"certificates" (rawinput233682 "certificates"), "nextMarker" (rawinput233682 "nextMarker")}] (clojure.core/cond-> {} (letvar233684 "certificates") (clojure.core/assoc :certificates (deser-certificates (clojure.core/get-in letvar233684 ["certificates"]))) (letvar233684 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233684 ["nextMarker"])))))))

(clojure.core/defn- response-list-things-in-billing-group-response ([input] (response-list-things-in-billing-group-response nil input)) ([resultWrapper233686 input] (clojure.core/let [rawinput233685 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233687 {"things" (rawinput233685 "things"), "nextToken" (rawinput233685 "nextToken")}] (clojure.core/cond-> {} (letvar233687 "things") (clojure.core/assoc :things (deser-thing-name-list (clojure.core/get-in letvar233687 ["things"]))) (letvar233687 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233687 ["nextToken"])))))))

(clojure.core/defn- response-describe-audit-task-response ([input] (response-describe-audit-task-response nil input)) ([resultWrapper233689 input] (clojure.core/let [rawinput233688 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233690 {"taskStatus" (rawinput233688 "taskStatus"), "taskType" (rawinput233688 "taskType"), "taskStartTime" (rawinput233688 "taskStartTime"), "taskStatistics" (rawinput233688 "taskStatistics"), "scheduledAuditName" (rawinput233688 "scheduledAuditName"), "auditDetails" (rawinput233688 "auditDetails")}] (clojure.core/cond-> {} (letvar233690 "taskStatus") (clojure.core/assoc :task-status (deser-audit-task-status (clojure.core/get-in letvar233690 ["taskStatus"]))) (letvar233690 "taskType") (clojure.core/assoc :task-type (deser-audit-task-type (clojure.core/get-in letvar233690 ["taskType"]))) (letvar233690 "taskStartTime") (clojure.core/assoc :task-start-time (deser-timestamp (clojure.core/get-in letvar233690 ["taskStartTime"]))) (letvar233690 "taskStatistics") (clojure.core/assoc :task-statistics (deser-task-statistics (clojure.core/get-in letvar233690 ["taskStatistics"]))) (letvar233690 "scheduledAuditName") (clojure.core/assoc :scheduled-audit-name (deser-scheduled-audit-name (clojure.core/get-in letvar233690 ["scheduledAuditName"]))) (letvar233690 "auditDetails") (clojure.core/assoc :audit-details (deser-audit-details (clojure.core/get-in letvar233690 ["auditDetails"])))))))

(clojure.core/defn- response-get-topic-rule-response ([input] (response-get-topic-rule-response nil input)) ([resultWrapper233692 input] (clojure.core/let [rawinput233691 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233693 {"ruleArn" (rawinput233691 "ruleArn"), "rule" (rawinput233691 "rule")}] (clojure.core/cond-> {} (letvar233693 "ruleArn") (clojure.core/assoc :rule-arn (deser-rule-arn (clojure.core/get-in letvar233693 ["ruleArn"]))) (letvar233693 "rule") (clojure.core/assoc :rule (deser-topic-rule (clojure.core/get-in letvar233693 ["rule"])))))))

(clojure.core/defn- response-list-things-in-thing-group-response ([input] (response-list-things-in-thing-group-response nil input)) ([resultWrapper233695 input] (clojure.core/let [rawinput233694 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233696 {"things" (rawinput233694 "things"), "nextToken" (rawinput233694 "nextToken")}] (clojure.core/cond-> {} (letvar233696 "things") (clojure.core/assoc :things (deser-thing-name-list (clojure.core/get-in letvar233696 ["things"]))) (letvar233696 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233696 ["nextToken"])))))))

(clojure.core/defn- response-describe-ca-certificate-response ([input] (response-describe-ca-certificate-response nil input)) ([resultWrapper233698 input] (clojure.core/let [rawinput233697 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233699 {"certificateDescription" (rawinput233697 "certificateDescription"), "registrationConfig" (rawinput233697 "registrationConfig")}] (clojure.core/cond-> {} (letvar233699 "certificateDescription") (clojure.core/assoc :certificate-description (deser-ca-certificate-description (clojure.core/get-in letvar233699 ["certificateDescription"]))) (letvar233699 "registrationConfig") (clojure.core/assoc :registration-config (deser-registration-config (clojure.core/get-in letvar233699 ["registrationConfig"])))))))

(clojure.core/defn- response-list-streams-response ([input] (response-list-streams-response nil input)) ([resultWrapper233701 input] (clojure.core/let [rawinput233700 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233702 {"streams" (rawinput233700 "streams"), "nextToken" (rawinput233700 "nextToken")}] (clojure.core/cond-> {} (letvar233702 "streams") (clojure.core/assoc :streams (deser-streams-summary (clojure.core/get-in letvar233702 ["streams"]))) (letvar233702 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233702 ["nextToken"])))))))

(clojure.core/defn- response-create-job-response ([input] (response-create-job-response nil input)) ([resultWrapper233704 input] (clojure.core/let [rawinput233703 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233705 {"jobArn" (rawinput233703 "jobArn"), "jobId" (rawinput233703 "jobId"), "description" (rawinput233703 "description")}] (clojure.core/cond-> {} (letvar233705 "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (clojure.core/get-in letvar233705 ["jobArn"]))) (letvar233705 "jobId") (clojure.core/assoc :job-id (deser-job-id (clojure.core/get-in letvar233705 ["jobId"]))) (letvar233705 "description") (clojure.core/assoc :description (deser-job-description (clojure.core/get-in letvar233705 ["description"])))))))

(clojure.core/defn- response-update-role-alias-response ([input] (response-update-role-alias-response nil input)) ([resultWrapper233707 input] (clojure.core/let [rawinput233706 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233708 {"roleAlias" (rawinput233706 "roleAlias"), "roleAliasArn" (rawinput233706 "roleAliasArn")}] (clojure.core/cond-> {} (letvar233708 "roleAlias") (clojure.core/assoc :role-alias (deser-role-alias (clojure.core/get-in letvar233708 ["roleAlias"]))) (letvar233708 "roleAliasArn") (clojure.core/assoc :role-alias-arn (deser-role-alias-arn (clojure.core/get-in letvar233708 ["roleAliasArn"])))))))

(clojure.core/defn- response-list-indices-response ([input] (response-list-indices-response nil input)) ([resultWrapper233710 input] (clojure.core/let [rawinput233709 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233711 {"indexNames" (rawinput233709 "indexNames"), "nextToken" (rawinput233709 "nextToken")}] (clojure.core/cond-> {} (letvar233711 "indexNames") (clojure.core/assoc :index-names (deser-index-names-list (clojure.core/get-in letvar233711 ["indexNames"]))) (letvar233711 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233711 ["nextToken"])))))))

(clojure.core/defn- response-invalid-query-exception ([input] (response-invalid-query-exception nil input)) ([resultWrapper233713 input] (clojure.core/let [rawinput233712 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233714 {"message" (rawinput233712 "message")}] (clojure.core/cond-> {} (letvar233714 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233714 ["message"])))))))

(clojure.core/defn- response-list-violation-events-response ([input] (response-list-violation-events-response nil input)) ([resultWrapper233716 input] (clojure.core/let [rawinput233715 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233717 {"violationEvents" (rawinput233715 "violationEvents"), "nextToken" (rawinput233715 "nextToken")}] (clojure.core/cond-> {} (letvar233717 "violationEvents") (clojure.core/assoc :violation-events (deser-violation-events (clojure.core/get-in letvar233717 ["violationEvents"]))) (letvar233717 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233717 ["nextToken"])))))))

(clojure.core/defn- response-describe-thing-registration-task-response ([input] (response-describe-thing-registration-task-response nil input)) ([resultWrapper233719 input] (clojure.core/let [rawinput233718 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233720 {"message" (rawinput233718 "message"), "creationDate" (rawinput233718 "creationDate"), "templateBody" (rawinput233718 "templateBody"), "inputFileBucket" (rawinput233718 "inputFileBucket"), "roleArn" (rawinput233718 "roleArn"), "lastModifiedDate" (rawinput233718 "lastModifiedDate"), "status" (rawinput233718 "status"), "successCount" (rawinput233718 "successCount"), "failureCount" (rawinput233718 "failureCount"), "percentageProgress" (rawinput233718 "percentageProgress"), "inputFileKey" (rawinput233718 "inputFileKey"), "taskId" (rawinput233718 "taskId")}] (clojure.core/cond-> {} (letvar233720 "message") (clojure.core/assoc :message (deser-error-message (clojure.core/get-in letvar233720 ["message"]))) (letvar233720 "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (clojure.core/get-in letvar233720 ["creationDate"]))) (letvar233720 "templateBody") (clojure.core/assoc :template-body (deser-template-body (clojure.core/get-in letvar233720 ["templateBody"]))) (letvar233720 "inputFileBucket") (clojure.core/assoc :input-file-bucket (deser-registry-s-3-bucket-name (clojure.core/get-in letvar233720 ["inputFileBucket"]))) (letvar233720 "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (clojure.core/get-in letvar233720 ["roleArn"]))) (letvar233720 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-last-modified-date (clojure.core/get-in letvar233720 ["lastModifiedDate"]))) (letvar233720 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar233720 ["status"]))) (letvar233720 "successCount") (clojure.core/assoc :success-count (deser-count (clojure.core/get-in letvar233720 ["successCount"]))) (letvar233720 "failureCount") (clojure.core/assoc :failure-count (deser-count (clojure.core/get-in letvar233720 ["failureCount"]))) (letvar233720 "percentageProgress") (clojure.core/assoc :percentage-progress (deser-percentage (clojure.core/get-in letvar233720 ["percentageProgress"]))) (letvar233720 "inputFileKey") (clojure.core/assoc :input-file-key (deser-registry-s-3-key-name (clojure.core/get-in letvar233720 ["inputFileKey"]))) (letvar233720 "taskId") (clojure.core/assoc :task-id (deser-task-id (clojure.core/get-in letvar233720 ["taskId"])))))))

(clojure.core/defn- response-create-stream-response ([input] (response-create-stream-response nil input)) ([resultWrapper233722 input] (clojure.core/let [rawinput233721 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233723 {"streamId" (rawinput233721 "streamId"), "streamArn" (rawinput233721 "streamArn"), "description" (rawinput233721 "description"), "streamVersion" (rawinput233721 "streamVersion")}] (clojure.core/cond-> {} (letvar233723 "streamId") (clojure.core/assoc :stream-id (deser-stream-id (clojure.core/get-in letvar233723 ["streamId"]))) (letvar233723 "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (clojure.core/get-in letvar233723 ["streamArn"]))) (letvar233723 "description") (clojure.core/assoc :description (deser-stream-description (clojure.core/get-in letvar233723 ["description"]))) (letvar233723 "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (clojure.core/get-in letvar233723 ["streamVersion"])))))))

(clojure.core/defn- response-update-event-configurations-response ([input] (response-update-event-configurations-response nil input)) ([resultWrapper233725 input] (clojure.core/let [rawinput233724 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233726 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-principal-policies-response ([input] (response-list-principal-policies-response nil input)) ([resultWrapper233728 input] (clojure.core/let [rawinput233727 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233729 {"policies" (rawinput233727 "policies"), "nextMarker" (rawinput233727 "nextMarker")}] (clojure.core/cond-> {} (letvar233729 "policies") (clojure.core/assoc :policies (deser-policies (clojure.core/get-in letvar233729 ["policies"]))) (letvar233729 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233729 ["nextMarker"])))))))

(clojure.core/defn- response-update-stream-response ([input] (response-update-stream-response nil input)) ([resultWrapper233731 input] (clojure.core/let [rawinput233730 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233732 {"streamId" (rawinput233730 "streamId"), "streamArn" (rawinput233730 "streamArn"), "description" (rawinput233730 "description"), "streamVersion" (rawinput233730 "streamVersion")}] (clojure.core/cond-> {} (letvar233732 "streamId") (clojure.core/assoc :stream-id (deser-stream-id (clojure.core/get-in letvar233732 ["streamId"]))) (letvar233732 "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (clojure.core/get-in letvar233732 ["streamArn"]))) (letvar233732 "description") (clojure.core/assoc :description (deser-stream-description (clojure.core/get-in letvar233732 ["description"]))) (letvar233732 "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (clojure.core/get-in letvar233732 ["streamVersion"])))))))

(clojure.core/defn- response-delete-conflict-exception ([input] (response-delete-conflict-exception nil input)) ([resultWrapper233734 input] (clojure.core/let [rawinput233733 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233735 {"message" (rawinput233733 "message")}] (clojure.core/cond-> {} (letvar233735 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233735 ["message"])))))))

(clojure.core/defn- response-list-thing-registration-tasks-response ([input] (response-list-thing-registration-tasks-response nil input)) ([resultWrapper233737 input] (clojure.core/let [rawinput233736 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233738 {"taskIds" (rawinput233736 "taskIds"), "nextToken" (rawinput233736 "nextToken")}] (clojure.core/cond-> {} (letvar233738 "taskIds") (clojure.core/assoc :task-ids (deser-task-id-list (clojure.core/get-in letvar233738 ["taskIds"]))) (letvar233738 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233738 ["nextToken"])))))))

(clojure.core/defn- response-transfer-certificate-response ([input] (response-transfer-certificate-response nil input)) ([resultWrapper233740 input] (clojure.core/let [rawinput233739 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233741 {"transferredCertificateArn" (rawinput233739 "transferredCertificateArn")}] (clojure.core/cond-> {} (letvar233741 "transferredCertificateArn") (clojure.core/assoc :transferred-certificate-arn (deser-certificate-arn (clojure.core/get-in letvar233741 ["transferredCertificateArn"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper233743 input] (clojure.core/let [rawinput233742 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233744 {"message" (rawinput233742 "message")}] (clojure.core/cond-> {} (letvar233744 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233744 ["message"])))))))

(clojure.core/defn- response-deprecate-thing-type-response ([input] (response-deprecate-thing-type-response nil input)) ([resultWrapper233746 input] (clojure.core/let [rawinput233745 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233747 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-topic-rules-response ([input] (response-list-topic-rules-response nil input)) ([resultWrapper233749 input] (clojure.core/let [rawinput233748 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233750 {"rules" (rawinput233748 "rules"), "nextToken" (rawinput233748 "nextToken")}] (clojure.core/cond-> {} (letvar233750 "rules") (clojure.core/assoc :rules (deser-topic-rule-list (clojure.core/get-in letvar233750 ["rules"]))) (letvar233750 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233750 ["nextToken"])))))))

(clojure.core/defn- response-describe-thing-type-response ([input] (response-describe-thing-type-response nil input)) ([resultWrapper233752 input] (clojure.core/let [rawinput233751 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233753 {"thingTypeName" (rawinput233751 "thingTypeName"), "thingTypeId" (rawinput233751 "thingTypeId"), "thingTypeArn" (rawinput233751 "thingTypeArn"), "thingTypeProperties" (rawinput233751 "thingTypeProperties"), "thingTypeMetadata" (rawinput233751 "thingTypeMetadata")}] (clojure.core/cond-> {} (letvar233753 "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (clojure.core/get-in letvar233753 ["thingTypeName"]))) (letvar233753 "thingTypeId") (clojure.core/assoc :thing-type-id (deser-thing-type-id (clojure.core/get-in letvar233753 ["thingTypeId"]))) (letvar233753 "thingTypeArn") (clojure.core/assoc :thing-type-arn (deser-thing-type-arn (clojure.core/get-in letvar233753 ["thingTypeArn"]))) (letvar233753 "thingTypeProperties") (clojure.core/assoc :thing-type-properties (deser-thing-type-properties (clojure.core/get-in letvar233753 ["thingTypeProperties"]))) (letvar233753 "thingTypeMetadata") (clojure.core/assoc :thing-type-metadata (deser-thing-type-metadata (clojure.core/get-in letvar233753 ["thingTypeMetadata"])))))))

(clojure.core/defn- response-resource-already-exists-exception ([input] (response-resource-already-exists-exception nil input)) ([resultWrapper233755 input] (clojure.core/let [rawinput233754 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233756 {"message" (rawinput233754 "message"), "resourceId" (rawinput233754 "resourceId"), "resourceArn" (rawinput233754 "resourceArn")}] (clojure.core/cond-> {} (letvar233756 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233756 ["message"]))) (letvar233756 "resourceId") (clojure.core/assoc :resource-id (deserresource-id (clojure.core/get-in letvar233756 ["resourceId"]))) (letvar233756 "resourceArn") (clojure.core/assoc :resource-arn (deserresource-arn (clojure.core/get-in letvar233756 ["resourceArn"])))))))

(clojure.core/defn- response-list-certificates-by-ca-response ([input] (response-list-certificates-by-ca-response nil input)) ([resultWrapper233758 input] (clojure.core/let [rawinput233757 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233759 {"certificates" (rawinput233757 "certificates"), "nextMarker" (rawinput233757 "nextMarker")}] (clojure.core/cond-> {} (letvar233759 "certificates") (clojure.core/assoc :certificates (deser-certificates (clojure.core/get-in letvar233759 ["certificates"]))) (letvar233759 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233759 ["nextMarker"])))))))

(clojure.core/defn- response-list-ca-certificates-response ([input] (response-list-ca-certificates-response nil input)) ([resultWrapper233761 input] (clojure.core/let [rawinput233760 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233762 {"certificates" (rawinput233760 "certificates"), "nextMarker" (rawinput233760 "nextMarker")}] (clojure.core/cond-> {} (letvar233762 "certificates") (clojure.core/assoc :certificates (deser-ca-certificates (clojure.core/get-in letvar233762 ["certificates"]))) (letvar233762 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233762 ["nextMarker"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper233764 input] (clojure.core/let [rawinput233763 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233765 {"message" (rawinput233763 "message")}] (clojure.core/cond-> {} (letvar233765 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233765 ["message"])))))))

(clojure.core/defn- response-create-keys-and-certificate-response ([input] (response-create-keys-and-certificate-response nil input)) ([resultWrapper233767 input] (clojure.core/let [rawinput233766 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233768 {"certificateArn" (rawinput233766 "certificateArn"), "certificateId" (rawinput233766 "certificateId"), "certificatePem" (rawinput233766 "certificatePem"), "keyPair" (rawinput233766 "keyPair")}] (clojure.core/cond-> {} (letvar233768 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar233768 ["certificateArn"]))) (letvar233768 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar233768 ["certificateId"]))) (letvar233768 "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (clojure.core/get-in letvar233768 ["certificatePem"]))) (letvar233768 "keyPair") (clojure.core/assoc :key-pair (deser-key-pair (clojure.core/get-in letvar233768 ["keyPair"])))))))

(clojure.core/defn- response-list-active-violations-response ([input] (response-list-active-violations-response nil input)) ([resultWrapper233770 input] (clojure.core/let [rawinput233769 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233771 {"activeViolations" (rawinput233769 "activeViolations"), "nextToken" (rawinput233769 "nextToken")}] (clojure.core/cond-> {} (letvar233771 "activeViolations") (clojure.core/assoc :active-violations (deser-active-violations (clojure.core/get-in letvar233771 ["activeViolations"]))) (letvar233771 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233771 ["nextToken"])))))))

(clojure.core/defn- response-update-thing-groups-for-thing-response ([input] (response-update-thing-groups-for-thing-response nil input)) ([resultWrapper233773 input] (clojure.core/let [rawinput233772 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233774 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-search-index-response ([input] (response-search-index-response nil input)) ([resultWrapper233776 input] (clojure.core/let [rawinput233775 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233777 {"nextToken" (rawinput233775 "nextToken"), "things" (rawinput233775 "things"), "thingGroups" (rawinput233775 "thingGroups")}] (clojure.core/cond-> {} (letvar233777 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233777 ["nextToken"]))) (letvar233777 "things") (clojure.core/assoc :things (deser-thing-document-list (clojure.core/get-in letvar233777 ["things"]))) (letvar233777 "thingGroups") (clojure.core/assoc :thing-groups (deser-thing-group-document-list (clojure.core/get-in letvar233777 ["thingGroups"])))))))

(clojure.core/defn- response-tag-resource-response ([input] (response-tag-resource-response nil input)) ([resultWrapper233779 input] (clojure.core/let [rawinput233778 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233780 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-default-authorizer-response ([input] (response-describe-default-authorizer-response nil input)) ([resultWrapper233782 input] (clojure.core/let [rawinput233781 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233783 {"authorizerDescription" (rawinput233781 "authorizerDescription")}] (clojure.core/cond-> {} (letvar233783 "authorizerDescription") (clojure.core/assoc :authorizer-description (deser-authorizer-description (clojure.core/get-in letvar233783 ["authorizerDescription"])))))))

(clojure.core/defn- response-list-role-aliases-response ([input] (response-list-role-aliases-response nil input)) ([resultWrapper233785 input] (clojure.core/let [rawinput233784 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233786 {"roleAliases" (rawinput233784 "roleAliases"), "nextMarker" (rawinput233784 "nextMarker")}] (clojure.core/cond-> {} (letvar233786 "roleAliases") (clojure.core/assoc :role-aliases (deser-role-aliases (clojure.core/get-in letvar233786 ["roleAliases"]))) (letvar233786 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233786 ["nextMarker"])))))))

(clojure.core/defn- response-list-attached-policies-response ([input] (response-list-attached-policies-response nil input)) ([resultWrapper233788 input] (clojure.core/let [rawinput233787 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233789 {"policies" (rawinput233787 "policies"), "nextMarker" (rawinput233787 "nextMarker")}] (clojure.core/cond-> {} (letvar233789 "policies") (clojure.core/assoc :policies (deser-policies (clojure.core/get-in letvar233789 ["policies"]))) (letvar233789 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233789 ["nextMarker"])))))))

(clojure.core/defn- response-update-scheduled-audit-response ([input] (response-update-scheduled-audit-response nil input)) ([resultWrapper233791 input] (clojure.core/let [rawinput233790 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233792 {"scheduledAuditArn" (rawinput233790 "scheduledAuditArn")}] (clojure.core/cond-> {} (letvar233792 "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (clojure.core/get-in letvar233792 ["scheduledAuditArn"])))))))

(clojure.core/defn- response-list-thing-registration-task-reports-response ([input] (response-list-thing-registration-task-reports-response nil input)) ([resultWrapper233794 input] (clojure.core/let [rawinput233793 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233795 {"resourceLinks" (rawinput233793 "resourceLinks"), "reportType" (rawinput233793 "reportType"), "nextToken" (rawinput233793 "nextToken")}] (clojure.core/cond-> {} (letvar233795 "resourceLinks") (clojure.core/assoc :resource-links (deser-s-3-file-url-list (clojure.core/get-in letvar233795 ["resourceLinks"]))) (letvar233795 "reportType") (clojure.core/assoc :report-type (deser-report-type (clojure.core/get-in letvar233795 ["reportType"]))) (letvar233795 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233795 ["nextToken"])))))))

(clojure.core/defn- response-detach-security-profile-response ([input] (response-detach-security-profile-response nil input)) ([resultWrapper233797 input] (clojure.core/let [rawinput233796 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233798 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-certificate-from-csr-response ([input] (response-create-certificate-from-csr-response nil input)) ([resultWrapper233800 input] (clojure.core/let [rawinput233799 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233801 {"certificateArn" (rawinput233799 "certificateArn"), "certificateId" (rawinput233799 "certificateId"), "certificatePem" (rawinput233799 "certificatePem")}] (clojure.core/cond-> {} (letvar233801 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar233801 ["certificateArn"]))) (letvar233801 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar233801 ["certificateId"]))) (letvar233801 "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (clojure.core/get-in letvar233801 ["certificatePem"])))))))

(clojure.core/defn- response-list-security-profiles-response ([input] (response-list-security-profiles-response nil input)) ([resultWrapper233803 input] (clojure.core/let [rawinput233802 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233804 {"securityProfileIdentifiers" (rawinput233802 "securityProfileIdentifiers"), "nextToken" (rawinput233802 "nextToken")}] (clojure.core/cond-> {} (letvar233804 "securityProfileIdentifiers") (clojure.core/assoc :security-profile-identifiers (deser-security-profile-identifiers (clojure.core/get-in letvar233804 ["securityProfileIdentifiers"]))) (letvar233804 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233804 ["nextToken"])))))))

(clojure.core/defn- response-internal-failure-exception ([input] (response-internal-failure-exception nil input)) ([resultWrapper233806 input] (clojure.core/let [rawinput233805 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233807 {"message" (rawinput233805 "message")}] (clojure.core/cond-> {} (letvar233807 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233807 ["message"])))))))

(clojure.core/defn- response-get-policy-version-response ([input] (response-get-policy-version-response nil input)) ([resultWrapper233809 input] (clojure.core/let [rawinput233808 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233810 {"policyArn" (rawinput233808 "policyArn"), "policyName" (rawinput233808 "policyName"), "policyDocument" (rawinput233808 "policyDocument"), "policyVersionId" (rawinput233808 "policyVersionId"), "isDefaultVersion" (rawinput233808 "isDefaultVersion"), "creationDate" (rawinput233808 "creationDate"), "lastModifiedDate" (rawinput233808 "lastModifiedDate"), "generationId" (rawinput233808 "generationId")}] (clojure.core/cond-> {} (letvar233810 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar233810 ["policyArn"]))) (letvar233810 "policyName") (clojure.core/assoc :policy-name (deser-policy-name (clojure.core/get-in letvar233810 ["policyName"]))) (letvar233810 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar233810 ["policyDocument"]))) (letvar233810 "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (clojure.core/get-in letvar233810 ["policyVersionId"]))) (letvar233810 "isDefaultVersion") (clojure.core/assoc :is-default-version (deser-is-default-version (clojure.core/get-in letvar233810 ["isDefaultVersion"]))) (letvar233810 "creationDate") (clojure.core/assoc :creation-date (deser-date-type (clojure.core/get-in letvar233810 ["creationDate"]))) (letvar233810 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (clojure.core/get-in letvar233810 ["lastModifiedDate"]))) (letvar233810 "generationId") (clojure.core/assoc :generation-id (deser-generation-id (clojure.core/get-in letvar233810 ["generationId"])))))))

(clojure.core/defn- response-versions-limit-exceeded-exception ([input] (response-versions-limit-exceeded-exception nil input)) ([resultWrapper233812 input] (clojure.core/let [rawinput233811 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233813 {"message" (rawinput233811 "message")}] (clojure.core/cond-> {} (letvar233813 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233813 ["message"])))))))

(clojure.core/defn- response-delete-billing-group-response ([input] (response-delete-billing-group-response nil input)) ([resultWrapper233815 input] (clojure.core/let [rawinput233814 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233816 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-remove-thing-from-thing-group-response ([input] (response-remove-thing-from-thing-group-response nil input)) ([resultWrapper233818 input] (clojure.core/let [rawinput233817 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233819 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-registration-code-response ([input] (response-get-registration-code-response nil input)) ([resultWrapper233821 input] (clojure.core/let [rawinput233820 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233822 {"registrationCode" (rawinput233820 "registrationCode")}] (clojure.core/cond-> {} (letvar233822 "registrationCode") (clojure.core/assoc :registration-code (deser-registration-code (clojure.core/get-in letvar233822 ["registrationCode"])))))))

(clojure.core/defn- response-resource-not-found-exception ([input] (response-resource-not-found-exception nil input)) ([resultWrapper233824 input] (clojure.core/let [rawinput233823 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233825 {"message" (rawinput233823 "message")}] (clojure.core/cond-> {} (letvar233825 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233825 ["message"])))))))

(clojure.core/defn- response-list-audit-tasks-response ([input] (response-list-audit-tasks-response nil input)) ([resultWrapper233827 input] (clojure.core/let [rawinput233826 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233828 {"tasks" (rawinput233826 "tasks"), "nextToken" (rawinput233826 "nextToken")}] (clojure.core/cond-> {} (letvar233828 "tasks") (clojure.core/assoc :tasks (deser-audit-task-metadata-list (clojure.core/get-in letvar233828 ["tasks"]))) (letvar233828 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233828 ["nextToken"])))))))

(clojure.core/defn- response-describe-thing-group-response ([input] (response-describe-thing-group-response nil input)) ([resultWrapper233830 input] (clojure.core/let [rawinput233829 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233831 {"indexName" (rawinput233829 "indexName"), "status" (rawinput233829 "status"), "thingGroupId" (rawinput233829 "thingGroupId"), "queryVersion" (rawinput233829 "queryVersion"), "thingGroupName" (rawinput233829 "thingGroupName"), "thingGroupProperties" (rawinput233829 "thingGroupProperties"), "version" (rawinput233829 "version"), "thingGroupArn" (rawinput233829 "thingGroupArn"), "queryString" (rawinput233829 "queryString"), "thingGroupMetadata" (rawinput233829 "thingGroupMetadata")}] (clojure.core/cond-> {} (letvar233831 "indexName") (clojure.core/assoc :index-name (deser-index-name (clojure.core/get-in letvar233831 ["indexName"]))) (letvar233831 "status") (clojure.core/assoc :status (deser-dynamic-group-status (clojure.core/get-in letvar233831 ["status"]))) (letvar233831 "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (clojure.core/get-in letvar233831 ["thingGroupId"]))) (letvar233831 "queryVersion") (clojure.core/assoc :query-version (deser-query-version (clojure.core/get-in letvar233831 ["queryVersion"]))) (letvar233831 "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (clojure.core/get-in letvar233831 ["thingGroupName"]))) (letvar233831 "thingGroupProperties") (clojure.core/assoc :thing-group-properties (deser-thing-group-properties (clojure.core/get-in letvar233831 ["thingGroupProperties"]))) (letvar233831 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar233831 ["version"]))) (letvar233831 "thingGroupArn") (clojure.core/assoc :thing-group-arn (deser-thing-group-arn (clojure.core/get-in letvar233831 ["thingGroupArn"]))) (letvar233831 "queryString") (clojure.core/assoc :query-string (deser-query-string (clojure.core/get-in letvar233831 ["queryString"]))) (letvar233831 "thingGroupMetadata") (clojure.core/assoc :thing-group-metadata (deser-thing-group-metadata (clojure.core/get-in letvar233831 ["thingGroupMetadata"])))))))

(clojure.core/defn- response-not-configured-exception ([input] (response-not-configured-exception nil input)) ([resultWrapper233833 input] (clojure.core/let [rawinput233832 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233834 {"message" (rawinput233832 "message")}] (clojure.core/cond-> {} (letvar233834 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233834 ["message"])))))))

(clojure.core/defn- response-delete-thing-type-response ([input] (response-delete-thing-type-response nil input)) ([resultWrapper233836 input] (clojure.core/let [rawinput233835 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233837 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-ca-certificate-response ([input] (response-delete-ca-certificate-response nil input)) ([resultWrapper233839 input] (clojure.core/let [rawinput233838 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233840 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-response-exception ([input] (response-invalid-response-exception nil input)) ([resultWrapper233842 input] (clojure.core/let [rawinput233841 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233843 {"message" (rawinput233841 "message")}] (clojure.core/cond-> {} (letvar233843 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233843 ["message"])))))))

(clojure.core/defn- response-index-not-ready-exception ([input] (response-index-not-ready-exception nil input)) ([resultWrapper233845 input] (clojure.core/let [rawinput233844 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233846 {"message" (rawinput233844 "message")}] (clojure.core/cond-> {} (letvar233846 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233846 ["message"])))))))

(clojure.core/defn- response-delete-dynamic-thing-group-response ([input] (response-delete-dynamic-thing-group-response nil input)) ([resultWrapper233848 input] (clojure.core/let [rawinput233847 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233849 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-associate-targets-with-job-response ([input] (response-associate-targets-with-job-response nil input)) ([resultWrapper233851 input] (clojure.core/let [rawinput233850 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233852 {"jobArn" (rawinput233850 "jobArn"), "jobId" (rawinput233850 "jobId"), "description" (rawinput233850 "description")}] (clojure.core/cond-> {} (letvar233852 "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (clojure.core/get-in letvar233852 ["jobArn"]))) (letvar233852 "jobId") (clojure.core/assoc :job-id (deser-job-id (clojure.core/get-in letvar233852 ["jobId"]))) (letvar233852 "description") (clojure.core/assoc :description (deser-job-description (clojure.core/get-in letvar233852 ["description"])))))))

(clojure.core/defn- response-describe-job-execution-response ([input] (response-describe-job-execution-response nil input)) ([resultWrapper233854 input] (clojure.core/let [rawinput233853 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233855 {"execution" (rawinput233853 "execution")}] (clojure.core/cond-> {} (letvar233855 "execution") (clojure.core/assoc :execution (deser-job-execution (clojure.core/get-in letvar233855 ["execution"])))))))

(clojure.core/defn- response-remove-thing-from-billing-group-response ([input] (response-remove-thing-from-billing-group-response nil input)) ([resultWrapper233857 input] (clojure.core/let [rawinput233856 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233858 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-on-demand-audit-task-response ([input] (response-start-on-demand-audit-task-response nil input)) ([resultWrapper233860 input] (clojure.core/let [rawinput233859 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233861 {"taskId" (rawinput233859 "taskId")}] (clojure.core/cond-> {} (letvar233861 "taskId") (clojure.core/assoc :task-id (deser-audit-task-id (clojure.core/get-in letvar233861 ["taskId"])))))))

(clojure.core/defn- response-sql-parse-exception ([input] (response-sql-parse-exception nil input)) ([resultWrapper233863 input] (clojure.core/let [rawinput233862 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233864 {"message" (rawinput233862 "message")}] (clojure.core/cond-> {} (letvar233864 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233864 ["message"])))))))

(clojure.core/defn- response-update-authorizer-response ([input] (response-update-authorizer-response nil input)) ([resultWrapper233866 input] (clojure.core/let [rawinput233865 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233867 {"authorizerName" (rawinput233865 "authorizerName"), "authorizerArn" (rawinput233865 "authorizerArn")}] (clojure.core/cond-> {} (letvar233867 "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (clojure.core/get-in letvar233867 ["authorizerName"]))) (letvar233867 "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (clojure.core/get-in letvar233867 ["authorizerArn"])))))))

(clojure.core/defn- response-describe-scheduled-audit-response ([input] (response-describe-scheduled-audit-response nil input)) ([resultWrapper233869 input] (clojure.core/let [rawinput233868 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233870 {"frequency" (rawinput233868 "frequency"), "dayOfMonth" (rawinput233868 "dayOfMonth"), "dayOfWeek" (rawinput233868 "dayOfWeek"), "targetCheckNames" (rawinput233868 "targetCheckNames"), "scheduledAuditName" (rawinput233868 "scheduledAuditName"), "scheduledAuditArn" (rawinput233868 "scheduledAuditArn")}] (clojure.core/cond-> {} (letvar233870 "frequency") (clojure.core/assoc :frequency (deser-audit-frequency (clojure.core/get-in letvar233870 ["frequency"]))) (letvar233870 "dayOfMonth") (clojure.core/assoc :day-of-month (deser-day-of-month (clojure.core/get-in letvar233870 ["dayOfMonth"]))) (letvar233870 "dayOfWeek") (clojure.core/assoc :day-of-week (deser-day-of-week (clojure.core/get-in letvar233870 ["dayOfWeek"]))) (letvar233870 "targetCheckNames") (clojure.core/assoc :target-check-names (deser-target-audit-check-names (clojure.core/get-in letvar233870 ["targetCheckNames"]))) (letvar233870 "scheduledAuditName") (clojure.core/assoc :scheduled-audit-name (deser-scheduled-audit-name (clojure.core/get-in letvar233870 ["scheduledAuditName"]))) (letvar233870 "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (clojure.core/get-in letvar233870 ["scheduledAuditArn"])))))))

(clojure.core/defn- response-get-indexing-configuration-response ([input] (response-get-indexing-configuration-response nil input)) ([resultWrapper233872 input] (clojure.core/let [rawinput233871 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233873 {"thingIndexingConfiguration" (rawinput233871 "thingIndexingConfiguration"), "thingGroupIndexingConfiguration" (rawinput233871 "thingGroupIndexingConfiguration")}] (clojure.core/cond-> {} (letvar233873 "thingIndexingConfiguration") (clojure.core/assoc :thing-indexing-configuration (deser-thing-indexing-configuration (clojure.core/get-in letvar233873 ["thingIndexingConfiguration"]))) (letvar233873 "thingGroupIndexingConfiguration") (clojure.core/assoc :thing-group-indexing-configuration (deser-thing-group-indexing-configuration (clojure.core/get-in letvar233873 ["thingGroupIndexingConfiguration"])))))))

(clojure.core/defn- response-list-authorizers-response ([input] (response-list-authorizers-response nil input)) ([resultWrapper233875 input] (clojure.core/let [rawinput233874 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233876 {"authorizers" (rawinput233874 "authorizers"), "nextMarker" (rawinput233874 "nextMarker")}] (clojure.core/cond-> {} (letvar233876 "authorizers") (clojure.core/assoc :authorizers (deser-authorizers (clojure.core/get-in letvar233876 ["authorizers"]))) (letvar233876 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233876 ["nextMarker"])))))))

(clojure.core/defn- response-internal-exception ([input] (response-internal-exception nil input)) ([resultWrapper233878 input] (clojure.core/let [rawinput233877 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233879 {"message" (rawinput233877 "message")}] (clojure.core/cond-> {} (letvar233879 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233879 ["message"])))))))

(clojure.core/defn- response-get-policy-response ([input] (response-get-policy-response nil input)) ([resultWrapper233881 input] (clojure.core/let [rawinput233880 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233882 {"policyName" (rawinput233880 "policyName"), "policyArn" (rawinput233880 "policyArn"), "policyDocument" (rawinput233880 "policyDocument"), "defaultVersionId" (rawinput233880 "defaultVersionId"), "creationDate" (rawinput233880 "creationDate"), "lastModifiedDate" (rawinput233880 "lastModifiedDate"), "generationId" (rawinput233880 "generationId")}] (clojure.core/cond-> {} (letvar233882 "policyName") (clojure.core/assoc :policy-name (deser-policy-name (clojure.core/get-in letvar233882 ["policyName"]))) (letvar233882 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar233882 ["policyArn"]))) (letvar233882 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar233882 ["policyDocument"]))) (letvar233882 "defaultVersionId") (clojure.core/assoc :default-version-id (deser-policy-version-id (clojure.core/get-in letvar233882 ["defaultVersionId"]))) (letvar233882 "creationDate") (clojure.core/assoc :creation-date (deser-date-type (clojure.core/get-in letvar233882 ["creationDate"]))) (letvar233882 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (clojure.core/get-in letvar233882 ["lastModifiedDate"]))) (letvar233882 "generationId") (clojure.core/assoc :generation-id (deser-generation-id (clojure.core/get-in letvar233882 ["generationId"])))))))

(clojure.core/defn- response-version-conflict-exception ([input] (response-version-conflict-exception nil input)) ([resultWrapper233884 input] (clojure.core/let [rawinput233883 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233885 {"message" (rawinput233883 "message")}] (clojure.core/cond-> {} (letvar233885 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233885 ["message"])))))))

(clojure.core/defn- response-create-policy-response ([input] (response-create-policy-response nil input)) ([resultWrapper233887 input] (clojure.core/let [rawinput233886 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233888 {"policyName" (rawinput233886 "policyName"), "policyArn" (rawinput233886 "policyArn"), "policyDocument" (rawinput233886 "policyDocument"), "policyVersionId" (rawinput233886 "policyVersionId")}] (clojure.core/cond-> {} (letvar233888 "policyName") (clojure.core/assoc :policy-name (deser-policy-name (clojure.core/get-in letvar233888 ["policyName"]))) (letvar233888 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar233888 ["policyArn"]))) (letvar233888 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar233888 ["policyDocument"]))) (letvar233888 "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (clojure.core/get-in letvar233888 ["policyVersionId"])))))))

(clojure.core/defn- response-list-audit-findings-response ([input] (response-list-audit-findings-response nil input)) ([resultWrapper233890 input] (clojure.core/let [rawinput233889 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233891 {"findings" (rawinput233889 "findings"), "nextToken" (rawinput233889 "nextToken")}] (clojure.core/cond-> {} (letvar233891 "findings") (clojure.core/assoc :findings (deser-audit-findings (clojure.core/get-in letvar233891 ["findings"]))) (letvar233891 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233891 ["nextToken"])))))))

(clojure.core/defn- response-resource-registration-failure-exception ([input] (response-resource-registration-failure-exception nil input)) ([resultWrapper233893 input] (clojure.core/let [rawinput233892 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233894 {"message" (rawinput233892 "message")}] (clojure.core/cond-> {} (letvar233894 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233894 ["message"])))))))

(clojure.core/defn- response-add-thing-to-billing-group-response ([input] (response-add-thing-to-billing-group-response nil input)) ([resultWrapper233896 input] (clojure.core/let [rawinput233895 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233897 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-thing-response ([input] (response-update-thing-response nil input)) ([resultWrapper233899 input] (clojure.core/let [rawinput233898 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233900 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-security-profile-response ([input] (response-delete-security-profile-response nil input)) ([resultWrapper233902 input] (clojure.core/let [rawinput233901 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233903 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-state-transition-exception ([input] (response-invalid-state-transition-exception nil input)) ([resultWrapper233905 input] (clojure.core/let [rawinput233904 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233906 {"message" (rawinput233904 "message")}] (clojure.core/cond-> {} (letvar233906 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233906 ["message"])))))))

(clojure.core/defn- response-describe-certificate-response ([input] (response-describe-certificate-response nil input)) ([resultWrapper233908 input] (clojure.core/let [rawinput233907 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233909 {"certificateDescription" (rawinput233907 "certificateDescription")}] (clojure.core/cond-> {} (letvar233909 "certificateDescription") (clojure.core/assoc :certificate-description (deser-certificate-description (clojure.core/get-in letvar233909 ["certificateDescription"])))))))

(clojure.core/defn- response-conflicting-resource-update-exception ([input] (response-conflicting-resource-update-exception nil input)) ([resultWrapper233911 input] (clojure.core/let [rawinput233910 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233912 {"message" (rawinput233910 "message")}] (clojure.core/cond-> {} (letvar233912 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233912 ["message"])))))))

(clojure.core/defn- response-describe-role-alias-response ([input] (response-describe-role-alias-response nil input)) ([resultWrapper233914 input] (clojure.core/let [rawinput233913 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233915 {"roleAliasDescription" (rawinput233913 "roleAliasDescription")}] (clojure.core/cond-> {} (letvar233915 "roleAliasDescription") (clojure.core/assoc :role-alias-description (deser-role-alias-description (clojure.core/get-in letvar233915 ["roleAliasDescription"])))))))

(clojure.core/defn- response-get-job-document-response ([input] (response-get-job-document-response nil input)) ([resultWrapper233917 input] (clojure.core/let [rawinput233916 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233918 {"document" (rawinput233916 "document")}] (clojure.core/cond-> {} (letvar233918 "document") (clojure.core/assoc :document (deser-job-document (clojure.core/get-in letvar233918 ["document"])))))))

(clojure.core/defn- response-describe-job-response ([input] (response-describe-job-response nil input)) ([resultWrapper233920 input] (clojure.core/let [rawinput233919 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233921 {"documentSource" (rawinput233919 "documentSource"), "job" (rawinput233919 "job")}] (clojure.core/cond-> {} (letvar233921 "documentSource") (clojure.core/assoc :document-source (deser-job-document-source (clojure.core/get-in letvar233921 ["documentSource"]))) (letvar233921 "job") (clojure.core/assoc :job (deser-job (clojure.core/get-in letvar233921 ["job"])))))))

(clojure.core/defn- response-list-v-2-logging-levels-response ([input] (response-list-v-2-logging-levels-response nil input)) ([resultWrapper233923 input] (clojure.core/let [rawinput233922 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233924 {"logTargetConfigurations" (rawinput233922 "logTargetConfigurations"), "nextToken" (rawinput233922 "nextToken")}] (clojure.core/cond-> {} (letvar233924 "logTargetConfigurations") (clojure.core/assoc :log-target-configurations (deser-log-target-configurations (clojure.core/get-in letvar233924 ["logTargetConfigurations"]))) (letvar233924 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233924 ["nextToken"])))))))

(clojure.core/defn- response-register-certificate-response ([input] (response-register-certificate-response nil input)) ([resultWrapper233926 input] (clojure.core/let [rawinput233925 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233927 {"certificateArn" (rawinput233925 "certificateArn"), "certificateId" (rawinput233925 "certificateId")}] (clojure.core/cond-> {} (letvar233927 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar233927 ["certificateArn"]))) (letvar233927 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar233927 ["certificateId"])))))))

(clojure.core/defn- response-transfer-already-completed-exception ([input] (response-transfer-already-completed-exception nil input)) ([resultWrapper233929 input] (clojure.core/let [rawinput233928 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233930 {"message" (rawinput233928 "message")}] (clojure.core/cond-> {} (letvar233930 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233930 ["message"])))))))

(clojure.core/defn- response-list-thing-principals-response ([input] (response-list-thing-principals-response nil input)) ([resultWrapper233932 input] (clojure.core/let [rawinput233931 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233933 {"principals" (rawinput233931 "principals")}] (clojure.core/cond-> {} (letvar233933 "principals") (clojure.core/assoc :principals (deser-principals (clojure.core/get-in letvar233933 ["principals"])))))))

(clojure.core/defn- response-create-thing-group-response ([input] (response-create-thing-group-response nil input)) ([resultWrapper233935 input] (clojure.core/let [rawinput233934 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233936 {"thingGroupName" (rawinput233934 "thingGroupName"), "thingGroupArn" (rawinput233934 "thingGroupArn"), "thingGroupId" (rawinput233934 "thingGroupId")}] (clojure.core/cond-> {} (letvar233936 "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (clojure.core/get-in letvar233936 ["thingGroupName"]))) (letvar233936 "thingGroupArn") (clojure.core/assoc :thing-group-arn (deser-thing-group-arn (clojure.core/get-in letvar233936 ["thingGroupArn"]))) (letvar233936 "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (clojure.core/get-in letvar233936 ["thingGroupId"])))))))

(clojure.core/defn- response-stop-thing-registration-task-response ([input] (response-stop-thing-registration-task-response nil input)) ([resultWrapper233938 input] (clojure.core/let [rawinput233937 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233939 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-billing-group-response ([input] (response-update-billing-group-response nil input)) ([resultWrapper233941 input] (clojure.core/let [rawinput233940 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233942 {"version" (rawinput233940 "version")}] (clojure.core/cond-> {} (letvar233942 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar233942 ["version"])))))))

(clojure.core/defn- response-validate-security-profile-behaviors-response ([input] (response-validate-security-profile-behaviors-response nil input)) ([resultWrapper233944 input] (clojure.core/let [rawinput233943 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233945 {"valid" (rawinput233943 "valid"), "validationErrors" (rawinput233943 "validationErrors")}] (clojure.core/cond-> {} (letvar233945 "valid") (clojure.core/assoc :valid (deser-valid (clojure.core/get-in letvar233945 ["valid"]))) (letvar233945 "validationErrors") (clojure.core/assoc :validation-errors (deser-validation-errors (clojure.core/get-in letvar233945 ["validationErrors"])))))))

(clojure.core/defn- response-delete-thing-response ([input] (response-delete-thing-response nil input)) ([resultWrapper233947 input] (clojure.core/let [rawinput233946 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233948 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-policy-principals-response ([input] (response-list-policy-principals-response nil input)) ([resultWrapper233950 input] (clojure.core/let [rawinput233949 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233951 {"principals" (rawinput233949 "principals"), "nextMarker" (rawinput233949 "nextMarker")}] (clojure.core/cond-> {} (letvar233951 "principals") (clojure.core/assoc :principals (deser-principals (clojure.core/get-in letvar233951 ["principals"]))) (letvar233951 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar233951 ["nextMarker"])))))))

(clojure.core/defn- response-list-thing-types-response ([input] (response-list-thing-types-response nil input)) ([resultWrapper233953 input] (clojure.core/let [rawinput233952 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233954 {"thingTypes" (rawinput233952 "thingTypes"), "nextToken" (rawinput233952 "nextToken")}] (clojure.core/cond-> {} (letvar233954 "thingTypes") (clojure.core/assoc :thing-types (deser-thing-type-list (clojure.core/get-in letvar233954 ["thingTypes"]))) (letvar233954 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233954 ["nextToken"])))))))

(clojure.core/defn- response-list-job-executions-for-thing-response ([input] (response-list-job-executions-for-thing-response nil input)) ([resultWrapper233956 input] (clojure.core/let [rawinput233955 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233957 {"executionSummaries" (rawinput233955 "executionSummaries"), "nextToken" (rawinput233955 "nextToken")}] (clojure.core/cond-> {} (letvar233957 "executionSummaries") (clojure.core/assoc :execution-summaries (deser-job-execution-summary-for-thing-list (clojure.core/get-in letvar233957 ["executionSummaries"]))) (letvar233957 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233957 ["nextToken"])))))))

(clojure.core/defn- response-create-thing-response ([input] (response-create-thing-response nil input)) ([resultWrapper233959 input] (clojure.core/let [rawinput233958 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233960 {"thingName" (rawinput233958 "thingName"), "thingArn" (rawinput233958 "thingArn"), "thingId" (rawinput233958 "thingId")}] (clojure.core/cond-> {} (letvar233960 "thingName") (clojure.core/assoc :thing-name (deser-thing-name (clojure.core/get-in letvar233960 ["thingName"]))) (letvar233960 "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (clojure.core/get-in letvar233960 ["thingArn"]))) (letvar233960 "thingId") (clojure.core/assoc :thing-id (deser-thing-id (clojure.core/get-in letvar233960 ["thingId"])))))))

(clojure.core/defn- response-clear-default-authorizer-response ([input] (response-clear-default-authorizer-response nil input)) ([resultWrapper233962 input] (clojure.core/let [rawinput233961 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233963 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-dynamic-thing-group-response ([input] (response-create-dynamic-thing-group-response nil input)) ([resultWrapper233965 input] (clojure.core/let [rawinput233964 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233966 {"thingGroupName" (rawinput233964 "thingGroupName"), "thingGroupArn" (rawinput233964 "thingGroupArn"), "thingGroupId" (rawinput233964 "thingGroupId"), "indexName" (rawinput233964 "indexName"), "queryString" (rawinput233964 "queryString"), "queryVersion" (rawinput233964 "queryVersion")}] (clojure.core/cond-> {} (letvar233966 "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (clojure.core/get-in letvar233966 ["thingGroupName"]))) (letvar233966 "thingGroupArn") (clojure.core/assoc :thing-group-arn (deser-thing-group-arn (clojure.core/get-in letvar233966 ["thingGroupArn"]))) (letvar233966 "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (clojure.core/get-in letvar233966 ["thingGroupId"]))) (letvar233966 "indexName") (clojure.core/assoc :index-name (deser-index-name (clojure.core/get-in letvar233966 ["indexName"]))) (letvar233966 "queryString") (clojure.core/assoc :query-string (deser-query-string (clojure.core/get-in letvar233966 ["queryString"]))) (letvar233966 "queryVersion") (clojure.core/assoc :query-version (deser-query-version (clojure.core/get-in letvar233966 ["queryVersion"])))))))

(clojure.core/defn- response-describe-authorizer-response ([input] (response-describe-authorizer-response nil input)) ([resultWrapper233968 input] (clojure.core/let [rawinput233967 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233969 {"authorizerDescription" (rawinput233967 "authorizerDescription")}] (clojure.core/cond-> {} (letvar233969 "authorizerDescription") (clojure.core/assoc :authorizer-description (deser-authorizer-description (clojure.core/get-in letvar233969 ["authorizerDescription"])))))))

(clojure.core/defn- response-create-authorizer-response ([input] (response-create-authorizer-response nil input)) ([resultWrapper233971 input] (clojure.core/let [rawinput233970 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233972 {"authorizerName" (rawinput233970 "authorizerName"), "authorizerArn" (rawinput233970 "authorizerArn")}] (clojure.core/cond-> {} (letvar233972 "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (clojure.core/get-in letvar233972 ["authorizerName"]))) (letvar233972 "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (clojure.core/get-in letvar233972 ["authorizerArn"])))))))

(clojure.core/defn- response-delete-authorizer-response ([input] (response-delete-authorizer-response nil input)) ([resultWrapper233974 input] (clojure.core/let [rawinput233973 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233975 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-job-executions-for-job-response ([input] (response-list-job-executions-for-job-response nil input)) ([resultWrapper233977 input] (clojure.core/let [rawinput233976 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233978 {"executionSummaries" (rawinput233976 "executionSummaries"), "nextToken" (rawinput233976 "nextToken")}] (clojure.core/cond-> {} (letvar233978 "executionSummaries") (clojure.core/assoc :execution-summaries (deser-job-execution-summary-for-job-list (clojure.core/get-in letvar233978 ["executionSummaries"]))) (letvar233978 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar233978 ["nextToken"])))))))

(clojure.core/defn- response-malformed-policy-exception ([input] (response-malformed-policy-exception nil input)) ([resultWrapper233980 input] (clojure.core/let [rawinput233979 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233981 {"message" (rawinput233979 "message")}] (clojure.core/cond-> {} (letvar233981 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233981 ["message"])))))))

(clojure.core/defn- response-get-ota-update-response ([input] (response-get-ota-update-response nil input)) ([resultWrapper233983 input] (clojure.core/let [rawinput233982 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233984 {"otaUpdateInfo" (rawinput233982 "otaUpdateInfo")}] (clojure.core/cond-> {} (letvar233984 "otaUpdateInfo") (clojure.core/assoc :ota-update-info (deser-ota-update-info (clojure.core/get-in letvar233984 ["otaUpdateInfo"])))))))

(clojure.core/defn- response-register-ca-certificate-response ([input] (response-register-ca-certificate-response nil input)) ([resultWrapper233986 input] (clojure.core/let [rawinput233985 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233987 {"certificateArn" (rawinput233985 "certificateArn"), "certificateId" (rawinput233985 "certificateId")}] (clojure.core/cond-> {} (letvar233987 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar233987 ["certificateArn"]))) (letvar233987 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar233987 ["certificateId"])))))))

(clojure.core/defn- response-add-thing-to-thing-group-response ([input] (response-add-thing-to-thing-group-response nil input)) ([resultWrapper233989 input] (clojure.core/let [rawinput233988 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233990 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-scheduled-audit-response ([input] (response-create-scheduled-audit-response nil input)) ([resultWrapper233992 input] (clojure.core/let [rawinput233991 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233993 {"scheduledAuditArn" (rawinput233991 "scheduledAuditArn")}] (clojure.core/cond-> {} (letvar233993 "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (clojure.core/get-in letvar233993 ["scheduledAuditArn"])))))))

(clojure.core/defn- response-describe-billing-group-response ([input] (response-describe-billing-group-response nil input)) ([resultWrapper233995 input] (clojure.core/let [rawinput233994 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233996 {"billingGroupName" (rawinput233994 "billingGroupName"), "billingGroupId" (rawinput233994 "billingGroupId"), "billingGroupArn" (rawinput233994 "billingGroupArn"), "version" (rawinput233994 "version"), "billingGroupProperties" (rawinput233994 "billingGroupProperties"), "billingGroupMetadata" (rawinput233994 "billingGroupMetadata")}] (clojure.core/cond-> {} (letvar233996 "billingGroupName") (clojure.core/assoc :billing-group-name (deser-billing-group-name (clojure.core/get-in letvar233996 ["billingGroupName"]))) (letvar233996 "billingGroupId") (clojure.core/assoc :billing-group-id (deser-billing-group-id (clojure.core/get-in letvar233996 ["billingGroupId"]))) (letvar233996 "billingGroupArn") (clojure.core/assoc :billing-group-arn (deser-billing-group-arn (clojure.core/get-in letvar233996 ["billingGroupArn"]))) (letvar233996 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar233996 ["version"]))) (letvar233996 "billingGroupProperties") (clojure.core/assoc :billing-group-properties (deser-billing-group-properties (clojure.core/get-in letvar233996 ["billingGroupProperties"]))) (letvar233996 "billingGroupMetadata") (clojure.core/assoc :billing-group-metadata (deser-billing-group-metadata (clojure.core/get-in letvar233996 ["billingGroupMetadata"])))))))

(clojure.core/defn- response-throttling-exception ([input] (response-throttling-exception nil input)) ([resultWrapper233998 input] (clojure.core/let [rawinput233997 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar233999 {"message" (rawinput233997 "message")}] (clojure.core/cond-> {} (letvar233999 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar233999 ["message"])))))))

(clojure.core/defn- response-describe-security-profile-response ([input] (response-describe-security-profile-response nil input)) ([resultWrapper234001 input] (clojure.core/let [rawinput234000 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234002 {"creationDate" (rawinput234000 "creationDate"), "securityProfileArn" (rawinput234000 "securityProfileArn"), "additionalMetricsToRetain" (rawinput234000 "additionalMetricsToRetain"), "behaviors" (rawinput234000 "behaviors"), "lastModifiedDate" (rawinput234000 "lastModifiedDate"), "securityProfileDescription" (rawinput234000 "securityProfileDescription"), "version" (rawinput234000 "version"), "securityProfileName" (rawinput234000 "securityProfileName"), "alertTargets" (rawinput234000 "alertTargets")}] (clojure.core/cond-> {} (letvar234002 "creationDate") (clojure.core/assoc :creation-date (deser-timestamp (clojure.core/get-in letvar234002 ["creationDate"]))) (letvar234002 "securityProfileArn") (clojure.core/assoc :security-profile-arn (deser-security-profile-arn (clojure.core/get-in letvar234002 ["securityProfileArn"]))) (letvar234002 "additionalMetricsToRetain") (clojure.core/assoc :additional-metrics-to-retain (deser-additional-metrics-to-retain-list (clojure.core/get-in letvar234002 ["additionalMetricsToRetain"]))) (letvar234002 "behaviors") (clojure.core/assoc :behaviors (deser-behaviors (clojure.core/get-in letvar234002 ["behaviors"]))) (letvar234002 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-timestamp (clojure.core/get-in letvar234002 ["lastModifiedDate"]))) (letvar234002 "securityProfileDescription") (clojure.core/assoc :security-profile-description (deser-security-profile-description (clojure.core/get-in letvar234002 ["securityProfileDescription"]))) (letvar234002 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar234002 ["version"]))) (letvar234002 "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (clojure.core/get-in letvar234002 ["securityProfileName"]))) (letvar234002 "alertTargets") (clojure.core/assoc :alert-targets (deser-alert-targets (clojure.core/get-in letvar234002 ["alertTargets"])))))))

(clojure.core/defn- response-list-policies-response ([input] (response-list-policies-response nil input)) ([resultWrapper234004 input] (clojure.core/let [rawinput234003 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234005 {"policies" (rawinput234003 "policies"), "nextMarker" (rawinput234003 "nextMarker")}] (clojure.core/cond-> {} (letvar234005 "policies") (clojure.core/assoc :policies (deser-policies (clojure.core/get-in letvar234005 ["policies"]))) (letvar234005 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar234005 ["nextMarker"])))))))

(clojure.core/defn- response-transfer-conflict-exception ([input] (response-transfer-conflict-exception nil input)) ([resultWrapper234007 input] (clojure.core/let [rawinput234006 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234008 {"message" (rawinput234006 "message")}] (clojure.core/cond-> {} (letvar234008 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar234008 ["message"])))))))

(clojure.core/defn- response-attach-security-profile-response ([input] (response-attach-security-profile-response nil input)) ([resultWrapper234010 input] (clojure.core/let [rawinput234009 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234011 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-registration-code-validation-exception ([input] (response-registration-code-validation-exception nil input)) ([resultWrapper234013 input] (clojure.core/let [rawinput234012 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234014 {"message" (rawinput234012 "message")}] (clojure.core/cond-> {} (letvar234014 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar234014 ["message"])))))))

(clojure.core/defn- response-test-authorization-response ([input] (response-test-authorization-response nil input)) ([resultWrapper234016 input] (clojure.core/let [rawinput234015 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234017 {"authResults" (rawinput234015 "authResults")}] (clojure.core/cond-> {} (letvar234017 "authResults") (clojure.core/assoc :auth-results (deser-auth-results (clojure.core/get-in letvar234017 ["authResults"])))))))

(clojure.core/defn- response-list-jobs-response ([input] (response-list-jobs-response nil input)) ([resultWrapper234019 input] (clojure.core/let [rawinput234018 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234020 {"jobs" (rawinput234018 "jobs"), "nextToken" (rawinput234018 "nextToken")}] (clojure.core/cond-> {} (letvar234020 "jobs") (clojure.core/assoc :jobs (deser-job-summary-list (clojure.core/get-in letvar234020 ["jobs"]))) (letvar234020 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar234020 ["nextToken"])))))))

(clojure.core/defn- response-attach-thing-principal-response ([input] (response-attach-thing-principal-response nil input)) ([resultWrapper234022 input] (clojure.core/let [rawinput234021 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234023 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-dynamic-thing-group-response ([input] (response-update-dynamic-thing-group-response nil input)) ([resultWrapper234025 input] (clojure.core/let [rawinput234024 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234026 {"version" (rawinput234024 "version")}] (clojure.core/cond-> {} (letvar234026 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar234026 ["version"])))))))

(clojure.core/defn- response-untag-resource-response ([input] (response-untag-resource-response nil input)) ([resultWrapper234028 input] (clojure.core/let [rawinput234027 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234029 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-stream-response ([input] (response-describe-stream-response nil input)) ([resultWrapper234031 input] (clojure.core/let [rawinput234030 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234032 {"streamInfo" (rawinput234030 "streamInfo")}] (clojure.core/cond-> {} (letvar234032 "streamInfo") (clojure.core/assoc :stream-info (deser-stream-info (clojure.core/get-in letvar234032 ["streamInfo"])))))))

(clojure.core/defn- response-create-policy-version-response ([input] (response-create-policy-version-response nil input)) ([resultWrapper234034 input] (clojure.core/let [rawinput234033 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234035 {"policyArn" (rawinput234033 "policyArn"), "policyDocument" (rawinput234033 "policyDocument"), "policyVersionId" (rawinput234033 "policyVersionId"), "isDefaultVersion" (rawinput234033 "isDefaultVersion")}] (clojure.core/cond-> {} (letvar234035 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar234035 ["policyArn"]))) (letvar234035 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar234035 ["policyDocument"]))) (letvar234035 "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (clojure.core/get-in letvar234035 ["policyVersionId"]))) (letvar234035 "isDefaultVersion") (clojure.core/assoc :is-default-version (deser-is-default-version (clojure.core/get-in letvar234035 ["isDefaultVersion"])))))))

(clojure.core/defn- response-create-security-profile-response ([input] (response-create-security-profile-response nil input)) ([resultWrapper234037 input] (clojure.core/let [rawinput234036 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234038 {"securityProfileName" (rawinput234036 "securityProfileName"), "securityProfileArn" (rawinput234036 "securityProfileArn")}] (clojure.core/cond-> {} (letvar234038 "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (clojure.core/get-in letvar234038 ["securityProfileName"]))) (letvar234038 "securityProfileArn") (clojure.core/assoc :security-profile-arn (deser-security-profile-arn (clojure.core/get-in letvar234038 ["securityProfileArn"])))))))

(clojure.core/defn- response-describe-endpoint-response ([input] (response-describe-endpoint-response nil input)) ([resultWrapper234040 input] (clojure.core/let [rawinput234039 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234041 {"endpointAddress" (rawinput234039 "endpointAddress")}] (clojure.core/cond-> {} (letvar234041 "endpointAddress") (clojure.core/assoc :endpoint-address (deser-endpoint-address (clojure.core/get-in letvar234041 ["endpointAddress"])))))))

(clojure.core/defn- response-delete-thing-group-response ([input] (response-delete-thing-group-response nil input)) ([resultWrapper234043 input] (clojure.core/let [rawinput234042 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234044 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-account-audit-configuration-response ([input] (response-delete-account-audit-configuration-response nil input)) ([resultWrapper234046 input] (clojure.core/let [rawinput234045 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234047 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-set-default-authorizer-response ([input] (response-set-default-authorizer-response nil input)) ([resultWrapper234049 input] (clojure.core/let [rawinput234048 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234050 {"authorizerName" (rawinput234048 "authorizerName"), "authorizerArn" (rawinput234048 "authorizerArn")}] (clojure.core/cond-> {} (letvar234050 "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (clojure.core/get-in letvar234050 ["authorizerName"]))) (letvar234050 "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (clojure.core/get-in letvar234050 ["authorizerArn"])))))))

(clojure.core/defn- response-list-billing-groups-response ([input] (response-list-billing-groups-response nil input)) ([resultWrapper234052 input] (clojure.core/let [rawinput234051 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234053 {"billingGroups" (rawinput234051 "billingGroups"), "nextToken" (rawinput234051 "nextToken")}] (clojure.core/cond-> {} (letvar234053 "billingGroups") (clojure.core/assoc :billing-groups (deser-billing-group-name-and-arn-list (clojure.core/get-in letvar234053 ["billingGroups"]))) (letvar234053 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar234053 ["nextToken"])))))))

(clojure.core/defn- response-update-indexing-configuration-response ([input] (response-update-indexing-configuration-response nil input)) ([resultWrapper234055 input] (clojure.core/let [rawinput234054 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234056 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-things-response ([input] (response-list-things-response nil input)) ([resultWrapper234058 input] (clojure.core/let [rawinput234057 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234059 {"things" (rawinput234057 "things"), "nextToken" (rawinput234057 "nextToken")}] (clojure.core/cond-> {} (letvar234059 "things") (clojure.core/assoc :things (deser-thing-attribute-list (clojure.core/get-in letvar234059 ["things"]))) (letvar234059 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar234059 ["nextToken"])))))))

(clojure.core/defn- response-create-thing-type-response ([input] (response-create-thing-type-response nil input)) ([resultWrapper234061 input] (clojure.core/let [rawinput234060 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234062 {"thingTypeName" (rawinput234060 "thingTypeName"), "thingTypeArn" (rawinput234060 "thingTypeArn"), "thingTypeId" (rawinput234060 "thingTypeId")}] (clojure.core/cond-> {} (letvar234062 "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (clojure.core/get-in letvar234062 ["thingTypeName"]))) (letvar234062 "thingTypeArn") (clojure.core/assoc :thing-type-arn (deser-thing-type-arn (clojure.core/get-in letvar234062 ["thingTypeArn"]))) (letvar234062 "thingTypeId") (clojure.core/assoc :thing-type-id (deser-thing-type-id (clojure.core/get-in letvar234062 ["thingTypeId"])))))))

(clojure.core/defn- response-certificate-conflict-exception ([input] (response-certificate-conflict-exception nil input)) ([resultWrapper234064 input] (clojure.core/let [rawinput234063 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234065 {"message" (rawinput234063 "message")}] (clojure.core/cond-> {} (letvar234065 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar234065 ["message"])))))))

(clojure.core/defn- response-list-outgoing-certificates-response ([input] (response-list-outgoing-certificates-response nil input)) ([resultWrapper234067 input] (clojure.core/let [rawinput234066 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234068 {"outgoingCertificates" (rawinput234066 "outgoingCertificates"), "nextMarker" (rawinput234066 "nextMarker")}] (clojure.core/cond-> {} (letvar234068 "outgoingCertificates") (clojure.core/assoc :outgoing-certificates (deser-outgoing-certificates (clojure.core/get-in letvar234068 ["outgoingCertificates"]))) (letvar234068 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar234068 ["nextMarker"])))))))

(clojure.core/defn- response-delete-role-alias-response ([input] (response-delete-role-alias-response nil input)) ([resultWrapper234070 input] (clojure.core/let [rawinput234069 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234071 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-ota-update-response ([input] (response-delete-ota-update-response nil input)) ([resultWrapper234073 input] (clojure.core/let [rawinput234072 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234074 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-register-thing-response ([input] (response-register-thing-response nil input)) ([resultWrapper234076 input] (clojure.core/let [rawinput234075 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234077 {"certificatePem" (rawinput234075 "certificatePem"), "resourceArns" (rawinput234075 "resourceArns")}] (clojure.core/cond-> {} (letvar234077 "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (clojure.core/get-in letvar234077 ["certificatePem"]))) (letvar234077 "resourceArns") (clojure.core/assoc :resource-arns (deser-resource-arns (clojure.core/get-in letvar234077 ["resourceArns"])))))))

(clojure.core/defn- response-update-account-audit-configuration-response ([input] (response-update-account-audit-configuration-response nil input)) ([resultWrapper234079 input] (clojure.core/let [rawinput234078 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234080 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-ota-updates-response ([input] (response-list-ota-updates-response nil input)) ([resultWrapper234082 input] (clojure.core/let [rawinput234081 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar234083 {"otaUpdates" (rawinput234081 "otaUpdates"), "nextToken" (rawinput234081 "nextToken")}] (clojure.core/cond-> {} (letvar234083 "otaUpdates") (clojure.core/assoc :ota-updates (deser-ota-updates-summary (clojure.core/get-in letvar234083 ["otaUpdates"]))) (letvar234083 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar234083 ["nextToken"])))))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-on-demand-audit-task-request/target-check-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/start-on-demand-audit-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.start-on-demand-audit-task-request/target-check-names] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-task-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/audit-task-metadata))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.accept-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.accept-certificate-transfer-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/accept-certificate-transfer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.accept-certificate-transfer-request/certificate-id] :opt-un [:portkey.aws.iot.-2015-05-28.accept-certificate-transfer-request/set-as-active]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-billing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-billing-group-request/billing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.delete-billing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/query-string (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/query-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-dynamic-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/thing-group-name :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/thing-group-properties] :opt-un [:portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/expected-version :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/index-name :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/query-string :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-request/query-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-finding-severity #{"CRITICAL" :medium "LOW" :high :critical "HIGH" :low "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/registry-max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-effective-policies-response/effective-policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/effective-policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-effective-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-effective-policies-response/effective-policies]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-versions-response/policy-versions (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-versions))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-policy-versions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-policy-versions-response/policy-versions]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-request/start-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-request/end-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-violation-events-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-violation-events-request/start-time :portkey.aws.iot.-2015-05-28.list-violation-events-request/end-time] :opt-un [:portkey.aws.iot.-2015-05-28.list-violation-events-request/thing-name :portkey.aws.iot.-2015-05-28.list-violation-events-request/security-profile-name :portkey.aws.iot.-2015-05-28.list-violation-events-request/next-token :portkey.aws.iot.-2015-05-28.list-violation-events-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/expected-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/compliant-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/auto-registration-status #{:disable "DISABLE" :enable "ENABLE"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-targets (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/security-profile-target))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-indexing-mode #{"REGISTRY_AND_SHADOW" :registry "REGISTRY" :registry-and-shadow :off "OFF"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/canceled-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.billing-group-properties/billing-group-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.billing-group-properties/billing-group-description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-event-configurations-response/event-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/event-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-event-configurations-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-event-configurations-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/last-modified-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-event-configurations-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-event-configurations-response/event-configurations :portkey.aws.iot.-2015-05-28.describe-event-configurations-response/creation-date :portkey.aws.iot.-2015-05-28.describe-event-configurations-response/last-modified-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/skyfall-max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-authorizers-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-authorizers-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-authorizers-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-authorizers-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-authorizers-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-authorizers-request/page-size :portkey.aws.iot.-2015-05-28.list-authorizers-request/marker :portkey.aws.iot.-2015-05-28.list-authorizers-request/ascending-order :portkey.aws.iot.-2015-05-28.list-authorizers-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-security-profile-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.-2015-05-28.delete-security-profile-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/scheduled-audit-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.deprecate-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.deprecate-thing-type-request/undo-deprecate (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/undo-deprecate))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/deprecate-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.deprecate-thing-type-request/thing-type-name] :opt-un [:portkey.aws.iot.-2015-05-28.deprecate-thing-type-request/undo-deprecate]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.unauthorized-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/unauthorized-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.unauthorized-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/outgoing-certificates (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/outgoing-certificate))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-principal-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-principal-policy-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/detach-principal-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.detach-principal-policy-request/policy-name :portkey.aws.iot.-2015-05-28.detach-principal-policy-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/security-profile-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/behaviors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-response/alert-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-security-profile-response/creation-date :portkey.aws.iot.-2015-05-28.update-security-profile-response/security-profile-arn :portkey.aws.iot.-2015-05-28.update-security-profile-response/additional-metrics-to-retain :portkey.aws.iot.-2015-05-28.update-security-profile-response/behaviors :portkey.aws.iot.-2015-05-28.update-security-profile-response/last-modified-date :portkey.aws.iot.-2015-05-28.update-security-profile-response/security-profile-description :portkey.aws.iot.-2015-05-28.update-security-profile-response/version :portkey.aws.iot.-2015-05-28.update-security-profile-response/security-profile-name :portkey.aws.iot.-2015-05-28.update-security-profile-response/alert-targets]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/range-key-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-things-in-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-things-in-billing-group-request/billing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-things-in-billing-group-request/next-token :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-indexing-configuration/thing-group-indexing-mode (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-indexing-mode))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-indexing-configuration (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.thing-group-indexing-configuration/thing-group-indexing-mode] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 1000)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-policy-response/targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-policy-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-targets-for-policy-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-targets-for-policy-response/targets :portkey.aws.iot.-2015-05-28.list-targets-for-policy-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-attribute))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-request/token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-request/token-signature (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/token-signature))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/test-invoke-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.test-invoke-authorizer-request/authorizer-name :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-request/token :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-request/token-signature] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-document-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-group-document))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/log-target-configurations (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/log-target-configuration))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/in-progress-timeout-in-minutes clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-properties/thing-type-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-properties/searchable-attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/searchable-attributes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-type-properties/thing-type-description :portkey.aws.iot.-2015-05-28.thing-type-properties/searchable-attributes]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-certificate-request/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-certificate-request/ca-certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-as-active-flag))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-certificate-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/register-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.register-certificate-request/certificate-pem] :opt-un [:portkey.aws.iot.-2015-05-28.register-certificate-request/ca-certificate-pem :portkey.aws.iot.-2015-05-28.register-certificate-request/set-as-active :portkey.aws.iot.-2015-05-28.register-certificate-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/detach-thing-principal-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-request/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-thing-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.create-thing-request/thing-type-name :portkey.aws.iot.-2015-05-28.create-thing-request/attribute-payload :portkey.aws.iot.-2015-05-28.create-thing-request/billing-group-name]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/token-signature (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2560)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[A-Za-z0-9+/]+={0,2}" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-thing-registration-task-response/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/start-thing-registration-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.start-thing-registration-task-response/task-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary-for-job/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary-for-job/job-execution-summary (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-summary))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-summary-for-job (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-execution-summary-for-job/thing-arn :portkey.aws.iot.-2015-05-28.job-execution-summary-for-job/job-execution-summary]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.code-signing/aws-signer-job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/signing-job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.code-signing/start-signing-job-parameter (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/start-signing-job-parameter))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.code-signing/custom-code-signing (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/custom-code-signing))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/code-signing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.code-signing/aws-signer-job-id :portkey.aws.iot.-2015-05-28.code-signing/start-signing-job-parameter :portkey.aws.iot.-2015-05-28.code-signing/custom-code-signing]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-d-bv-2-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-d-bv-2-action/put-item (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/put-item-input))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/dynamo-d-bv-2-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.dynamo-d-bv-2-action/role-arn :portkey.aws.iot.-2015-05-28.dynamo-d-bv-2-action/put-item] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-notification-target-configurations (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/audit-notification-type :portkey.aws.iot.-2015-05-28/audit-notification-target))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-response/thing-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-groups-response/thing-groups :portkey.aws.iot.-2015-05-28.list-thing-groups-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.statistical-threshold/statistic (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/evaluation-statistic))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/statistical-threshold (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.statistical-threshold/statistic]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-registration-code-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-response/security-profile-target-mappings (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-target-mappings))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-security-profiles-for-target-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-response/security-profile-target-mappings :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/override-dynamic-groups clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-payload/sql (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/sql))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-payload/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-payload/actions (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/action-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-payload/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-payload/aws-iot-sql-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-iot-sql-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-payload/error-action (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/topic-rule-payload (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.topic-rule-payload/sql :portkey.aws.iot.-2015-05-28.topic-rule-payload/actions] :opt-un [:portkey.aws.iot.-2015-05-28.topic-rule-payload/description :portkey.aws.iot.-2015-05-28.topic-rule-payload/rule-disabled :portkey.aws.iot.-2015-05-28.topic-rule-payload/aws-iot-sql-version :portkey.aws.iot.-2015-05-28.topic-rule-payload/error-action]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-things-response/things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-things-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-principal-things-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-principal-things-response/things :portkey.aws.iot.-2015-05-28.list-principal-things-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-summary/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-summary/ota-update-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-summary/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.ota-update-summary/ota-update-id :portkey.aws.iot.-2015-05-28.ota-update-summary/ota-update-arn :portkey.aws.iot.-2015-05-28.ota-update-summary/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/minimum-number-of-executed-things (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cidr (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 2 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 43)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-fA-F0-9:\.\/]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/active-violations (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/active-violation))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-billing-group-response/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-billing-group-response/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-billing-group-response/billing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-billing-group-response/billing-group-name :portkey.aws.iot.-2015-05-28.create-billing-group-response/billing-group-arn :portkey.aws.iot.-2015-05-28.create-billing-group-response/billing-group-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/string-map (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/string :portkey.aws.iot.-2015-05-28/string))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/platform (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/stream-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/stream-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/files (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-files))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/created-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-info/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.stream-info/stream-id :portkey.aws.iot.-2015-05-28.stream-info/stream-arn :portkey.aws.iot.-2015-05-28.stream-info/stream-version :portkey.aws.iot.-2015-05-28.stream-info/description :portkey.aws.iot.-2015-05-28.stream-info/files :portkey.aws.iot.-2015-05-28.stream-info/created-at :portkey.aws.iot.-2015-05-28.stream-info/last-updated-at :portkey.aws.iot.-2015-05-28.stream-info/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/private-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-response/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-response/aws-iot-job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-iot-job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-response/ota-update-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-response/aws-iot-job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-iot-job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-response/ota-update-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-ota-update-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-ota-update-response/ota-update-id :portkey.aws.iot.-2015-05-28.create-ota-update-response/aws-iot-job-id :portkey.aws.iot.-2015-05-28.create-ota-update-response/ota-update-arn :portkey.aws.iot.-2015-05-28.create-ota-update-response/aws-iot-job-arn :portkey.aws.iot.-2015-05-28.create-ota-update-response/ota-update-status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ota-updates-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ota-updates-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ota-updates-request/ota-update-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-ota-updates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-ota-updates-request/max-results :portkey.aws.iot.-2015-05-28.list-ota-updates-request/next-token :portkey.aws.iot.-2015-05-28.list-ota-updates-request/ota-update-status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-response/job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-response/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-response/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cancel-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.cancel-job-response/job-arn :portkey.aws.iot.-2015-05-28.cancel-job-response/job-id :portkey.aws.iot.-2015-05-28.cancel-job-response/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-scheduled-audits-response/scheduled-audits (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-metadata-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-scheduled-audits-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-scheduled-audits-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-scheduled-audits-response/scheduled-audits :portkey.aws.iot.-2015-05-28.list-scheduled-audits-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-certificate-request/target-aws-account (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-certificate-request/transfer-message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/transfer-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.transfer-certificate-request/certificate-id :portkey.aws.iot.-2015-05-28.transfer-certificate-request/target-aws-account] :opt-un [:portkey.aws.iot.-2015-05-28.transfer-certificate-request/transfer-message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-event-configurations-request/event-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/event-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-event-configurations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-event-configurations-request/event-configurations]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.explicit-deny/policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/explicit-deny (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.explicit-deny/policies]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-response/security-profile-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-targets-for-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-response/security-profile-targets :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/deprecation-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-stream clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-certificate-request/new-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-certificate-request/certificate-id :portkey.aws.iot.-2015-05-28.update-certificate-request/new-status] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/function-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-billing-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-billing-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-billing-groups-request/name-prefix-filter (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-billing-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-billing-groups-request/next-token :portkey.aws.iot.-2015-05-28.list-billing-groups-request/max-results :portkey.aws.iot.-2015-05-28.list-billing-groups-request/name-prefix-filter]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-logical-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/topic-pattern (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-role-alias-response/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-role-alias-response/role-alias-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-role-alias-response/role-alias :portkey.aws.iot.-2015-05-28.create-role-alias-response/role-alias-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/removed-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-v-2-logging-options-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/signature-algorithm (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/index-status #{:building "REBUILDING" :active "BUILDING" "ACTIVE" :rebuilding})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/query-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/rule-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_]+$" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/violation-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/violation-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/behavior (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behavior))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/metric-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/violation-event-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/violation-event-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.violation-event/violation-event-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/violation-event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.violation-event/violation-id :portkey.aws.iot.-2015-05-28.violation-event/thing-name :portkey.aws.iot.-2015-05-28.violation-event/security-profile-name :portkey.aws.iot.-2015-05-28.violation-event/behavior :portkey.aws.iot.-2015-05-28.violation-event/metric-value :portkey.aws.iot.-2015-05-28.violation-event/violation-event-type :portkey.aws.iot.-2015-05-28.violation-event/violation-event-time]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-file-url-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/s-3-file-url))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/default-client-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-response/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-thing-response/default-client-id :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-name :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-id :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-arn :portkey.aws.iot.-2015-05-28.describe-thing-response/thing-type-name :portkey.aws.iot.-2015-05-28.describe-thing-response/attributes :portkey.aws.iot.-2015-05-28.describe-thing-response/version :portkey.aws.iot.-2015-05-28.describe-thing-response/billing-group-name]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/non-compliant-resources-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-status #{"COMPLETED" "CANCELED" "IN_PROGRESS" :in-progress :completed :deletion-in-progress :canceled "DELETION_IN_PROGRESS"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/failed-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.code-signing-certificate-chain/certificate-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.code-signing-certificate-chain/inline-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/inline-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/code-signing-certificate-chain (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.code-signing-certificate-chain/certificate-name :portkey.aws.iot.-2015-05-28.code-signing-certificate-chain/inline-document]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-keys-and-certificate-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-keys-and-certificate-request/set-as-active]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/new-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ca-certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/new-auto-registration-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/auto-registration-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/registration-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registration-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/remove-auto-registration (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/remove-auto-registration))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-ca-certificate-request/certificate-id] :opt-un [:portkey.aws.iot.-2015-05-28.update-ca-certificate-request/new-status :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/new-auto-registration-status :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/registration-config :portkey.aws.iot.-2015-05-28.update-ca-certificate-request/remove-auto-registration]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-request/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-request/query-string (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-request/query-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/search-index-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.search-index-request/query-string] :opt-un [:portkey.aws.iot.-2015-05-28.search-index-request/index-name :portkey.aws.iot.-2015-05-28.search-index-request/next-token :portkey.aws.iot.-2015-05-28.search-index-request/max-results :portkey.aws.iot.-2015-05-28.search-index-request/query-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/comment (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-state-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-state-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.certificate-state-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-signing-request (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/missing-context-values (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/missing-context-value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/day-of-week #{:wed "TUE" "SAT" "SUN" :sat "MON" :tue :fri :sun "THU" "WED" "FRI" :mon :thu})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/is-authenticated (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-authenticated))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/principal-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/policy-documents (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-documents))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/refresh-after-in-seconds (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/seconds))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/disconnect-after-in-seconds (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/seconds))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/test-invoke-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/is-authenticated :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/principal-id :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/policy-documents :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/refresh-after-in-seconds :portkey.aws.iot.-2015-05-28.test-invoke-authorizer-response/disconnect-after-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/page-size (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.invalid-request-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/invalid-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.invalid-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cancel-audit-task-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-tags-for-resource-response/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-tags-for-resource-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-tags-for-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-tags-for-resource-response/tags :portkey.aws.iot.-2015-05-28.list-tags-for-resource-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/prefix (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/message-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.security-profile-target/arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-target (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.security-profile-target/arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-validation-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-validation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.certificate-validation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/streams-summary (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/stream-summary))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-attribute/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-attribute/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-attribute/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-attribute/attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-attribute/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-attribute/thing-name :portkey.aws.iot.-2015-05-28.thing-attribute/thing-type-name :portkey.aws.iot.-2015-05-28.thing-attribute/thing-arn :portkey.aws.iot.-2015-05-28.thing-attribute/attributes :portkey.aws.iot.-2015-05-28.thing-attribute/version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.abort-criteria/failure-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-failure-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.abort-criteria/action (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/abort-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.abort-criteria/threshold-percentage (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/abort-threshold-percentage))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.abort-criteria/min-number-of-executed-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/minimum-number-of-executed-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/abort-criteria (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.abort-criteria/failure-type :portkey.aws.iot.-2015-05-28.abort-criteria/action :portkey.aws.iot.-2015-05-28.abort-criteria/threshold-percentage :portkey.aws.iot.-2015-05-28.abort-criteria/min-number-of-executed-things] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.validation-error/error-message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/validation-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.validation-error/error-message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/index-names-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/index-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-thing-group-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-security-profile-request/security-profile-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-topic-rules-request/topic (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-topic-rules-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ge-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-topic-rules-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-topic-rules-request/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-topic-rules-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-topic-rules-request/topic :portkey.aws.iot.-2015-05-28.list-topic-rules-request/max-results :portkey.aws.iot.-2015-05-28.list-topic-rules-request/next-token :portkey.aws.iot.-2015-05-28.list-topic-rules-request/rule-disabled]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-task-type #{"SCHEDULED_AUDIT_TASK" :scheduled-audit-task "ON_DEMAND_AUDIT_TASK" :on-demand-audit-task})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/canned-access-control-list #{"authenticated-read" :logdeliverywrite :bucketownerfullcontrol "public-read-write" :private "bucket-owner-full-control" "private" :bucketownerread :publicread "aws-exec-read" :publicreadwrite :awsexecread "bucket-owner-read" "public-read" "log-delivery-write" :authenticatedread})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/connectivity-timestamp clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/duration-seconds clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-outgoing-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-outgoing-certificates-request/page-size :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-request/marker :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/violation-events (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/violation-event))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.iot-events-action/input-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/input-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.iot-events-action/message-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.iot-events-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/iot-events-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.iot-events-action/input-name :portkey.aws.iot.-2015-05-28.iot-events-action/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.iot-events-action/message-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/execution-number clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-policies-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-policies-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-principal-policies-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-principal-policies-request/principal] :opt-un [:portkey.aws.iot.-2015-05-28.list-principal-policies-request/marker :portkey.aws.iot.-2015-05-28.list-principal-policies-request/page-size :portkey.aws.iot.-2015-05-28.list-principal-policies-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/input-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/additional-metrics-to-retain-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/behavior-metric))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/number-of-things (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.non-compliant-resource/resource-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.non-compliant-resource/resource-identifier (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.non-compliant-resource/additional-info (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/non-compliant-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.non-compliant-resource/resource-type :portkey.aws.iot.-2015-05-28.non-compliant-resource/resource-identifier :portkey.aws.iot.-2015-05-28.non-compliant-resource/additional-info]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/key-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 5120))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-logging-options-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-logging-options-response/log-level (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-logging-options-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-logging-options-response/role-arn :portkey.aws.iot.-2015-05-28.get-logging-options-response/log-level]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-v-2-logging-options-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-v-2-logging-options-response/default-log-level (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-v-2-logging-options-response/disable-all-logs (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/disable-all-logs))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-v-2-logging-options-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-v-2-logging-options-response/role-arn :portkey.aws.iot.-2015-05-28.get-v-2-logging-options-response/default-log-level :portkey.aws.iot.-2015-05-28.get-v-2-logging-options-response/disable-all-logs]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-response/thing-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-groups-for-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-response/thing-groups :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attribute-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.,@/:#-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.outgoing-certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.outgoing-certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.outgoing-certificate/transferred-to (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.outgoing-certificate/transfer-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.outgoing-certificate/transfer-message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.outgoing-certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/outgoing-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.outgoing-certificate/certificate-arn :portkey.aws.iot.-2015-05-28.outgoing-certificate/certificate-id :portkey.aws.iot.-2015-05-28.outgoing-certificate/transferred-to :portkey.aws.iot.-2015-05-28.outgoing-certificate/transfer-date :portkey.aws.iot.-2015-05-28.outgoing-certificate/transfer-message :portkey.aws.iot.-2015-05-28.outgoing-certificate/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-account-audit-configuration-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-account-audit-configuration-response/audit-notification-target-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-notification-target-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-account-audit-configuration-response/audit-check-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-check-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-account-audit-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-account-audit-configuration-response/role-arn :portkey.aws.iot.-2015-05-28.describe-account-audit-configuration-response/audit-notification-target-configurations :portkey.aws.iot.-2015-05-28.describe-account-audit-configuration-response/audit-check-configurations]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-index-response/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-index-response/index-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-index-response/schema (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-schema))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-index-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-index-response/index-name :portkey.aws.iot.-2015-05-28.describe-index-response/index-status :portkey.aws.iot.-2015-05-28.describe-index-response/schema]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/canceled-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/last-modified-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-response/certificates (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificates))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-certificates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-certificates-response/certificates :portkey.aws.iot.-2015-05-28.list-certificates-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-default-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-default-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-default-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.set-default-policy-version-request/policy-name :portkey.aws.iot.-2015-05-28.set-default-policy-version-request/policy-version-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-default-authorizer-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-response/things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-things-in-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-things-in-billing-group-response/things :portkey.aws.iot.-2015-05-28.list-things-in-billing-group-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.enable-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/enable-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.enable-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/log-level #{"DISABLED" :disabled :warn "WARN" :debug "ERROR" "DEBUG" :info :error "INFO"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-start-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-statistics (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-statistics))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-response/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-response/audit-details (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-details))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-audit-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-status :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-type :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-start-time :portkey.aws.iot.-2015-05-28.describe-audit-task-response/task-statistics :portkey.aws.iot.-2015-05-28.describe-audit-task-response/scheduled-audit-name :portkey.aws.iot.-2015-05-28.describe-audit-task-response/audit-details]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/target-audit-check-names (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/audit-check-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/effective-policies (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/effective-policy))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-request/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-request/files (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-files))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-stream-request/stream-id :portkey.aws.iot.-2015-05-28.create-stream-request/files :portkey.aws.iot.-2015-05-28.create-stream-request/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.create-stream-request/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\w+=,.@-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ca-certificates (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/ca-certificate))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/action-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/action :min-count 0 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/violation-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/violation-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/behavior (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behavior))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/last-violation-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/last-violation-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.active-violation/violation-start-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/active-violation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.active-violation/violation-id :portkey.aws.iot.-2015-05-28.active-violation/thing-name :portkey.aws.iot.-2015-05-28.active-violation/security-profile-name :portkey.aws.iot.-2015-05-28.active-violation/behavior :portkey.aws.iot.-2015-05-28.active-violation/last-violation-value :portkey.aws.iot.-2015-05-28.active-violation/last-violation-time :portkey.aws.iot.-2015-05-28.active-violation/violation-start-time]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.reject-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.reject-certificate-transfer-request/reject-reason (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/reject-certificate-transfer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.reject-certificate-transfer-request/certificate-id] :opt-un [:portkey.aws.iot.-2015-05-28.reject-certificate-transfer-request/reject-reason]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.registration-config/template-body (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.registration-config/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/registration-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.registration-config/template-body :portkey.aws.iot.-2015-05-28.registration-config/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-certificates-request/page-size :portkey.aws.iot.-2015-05-28.list-certificates-request/marker :portkey.aws.iot.-2015-05-28.list-certificates-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/additional-parameter-map (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/attribute-key :portkey.aws.iot.-2015-05-28/value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/json-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/laser-max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/expires-in-sec clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-audit-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-audit-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-audit-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-thing-request/thing-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/template-body (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior/name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behavior-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior/metric (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behavior-metric))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior/criteria (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behavior-criteria))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/behavior (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.behavior/name] :opt-un [:portkey.aws.iot.-2015-05-28.behavior/metric :portkey.aws.iot.-2015-05-28.behavior/criteria]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-request/target-selection (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/laser-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-request/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-jobs-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-jobs-request/status :portkey.aws.iot.-2015-05-28.list-jobs-request/target-selection :portkey.aws.iot.-2015-05-28.list-jobs-request/max-results :portkey.aws.iot.-2015-05-28.list-jobs-request/next-token :portkey.aws.iot.-2015-05-28.list-jobs-request/thing-group-name :portkey.aws.iot.-2015-05-28.list-jobs-request/thing-group-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/index-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-topic-rule-response/rule-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-topic-rule-response/rule (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic-rule))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-topic-rule-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-topic-rule-response/rule-arn :portkey.aws.iot.-2015-05-28.get-topic-rule-response/rule]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-tags-for-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-tags-for-resource-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-tags-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-tags-for-resource-request/resource-arn] :opt-un [:portkey.aws.iot.-2015-05-28.list-tags-for-resource-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificates (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/certificate))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/endpoint-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-policy-request/target (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-target))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attach-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.attach-policy-request/policy-name :portkey.aws.iot.-2015-05-28.attach-policy-request/target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-metadata/deprecated (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/boolean))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-metadata/deprecation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/deprecation-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-type-metadata/deprecated :portkey.aws.iot.-2015-05-28.thing-type-metadata/deprecation-date :portkey.aws.iot.-2015-05-28.thing-type-metadata/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-job-request/job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.delete-thing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-request/parent-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.create-thing-group-request/parent-group-name :portkey.aws.iot.-2015-05-28.create-thing-group-request/thing-group-properties :portkey.aws.iot.-2015-05-28.create-thing-group-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attribute-payload/attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attribute-payload/merge (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/flag))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attribute-payload (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.attribute-payload/attributes :portkey.aws.iot.-2015-05-28.attribute-payload/merge]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-thing-type-request/thing-type-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/parameters (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/parameter :portkey.aws.iot.-2015-05-28/value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-response/things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-things-in-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-things-in-thing-group-response/things :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/scheduled-audit-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/scheduled-audit-metadata))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/inline-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-ca-certificate-response/certificate-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ca-certificate-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-ca-certificate-response/registration-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registration-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-ca-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-ca-certificate-response/certificate-description :portkey.aws.iot.-2015-05-28.describe-ca-certificate-response/registration-config]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/state-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-billing-group-request/billing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-billing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-billing-group-request/billing-group-name :portkey.aws.iot.-2015-05-28.update-billing-group-request/billing-group-properties] :opt-un [:portkey.aws.iot.-2015-05-28.update-billing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/reason-for-non-compliance-code (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/use-base-64 clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-streams-response/streams (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/streams-summary))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-streams-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-streams-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-streams-response/streams :portkey.aws.iot.-2015-05-28.list-streams-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-response/job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-response/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-response/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-job-response/job-arn :portkey.aws.iot.-2015-05-28.create-job-response/job-id :portkey.aws.iot.-2015-05-28.create-job-response/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.abort-config/criteria-list (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/abort-criteria-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/abort-config (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.abort-config/criteria-list] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-path-on-device (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-target-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/day-of-month (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"^([1-9]|[12][0-9]|3[01])$|^LAST$" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-certificate-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/principal-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-role-alias-response/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-role-alias-response/role-alias-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-role-alias-response/role-alias :portkey.aws.iot.-2015-05-28.update-role-alias-response/role-alias-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-indices-response/index-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-names-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-indices-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-indices-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-indices-response/index-names :portkey.aws.iot.-2015-05-28.list-indices-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-v-2-logging-options-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-v-2-logging-options-request/default-log-level (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-v-2-logging-options-request/disable-all-logs (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/disable-all-logs))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-v-2-logging-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.set-v-2-logging-options-request/role-arn :portkey.aws.iot.-2015-05-28.set-v-2-logging-options-request/default-log-level :portkey.aws.iot.-2015-05-28.set-v-2-logging-options-request/disable-all-logs]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-types-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-types-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-types-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-types-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-types-request/next-token :portkey.aws.iot.-2015-05-28.list-thing-types-request/max-results :portkey.aws.iot.-2015-05-28.list-thing-types-request/thing-type-name]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/max-job-executions-per-min (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ca-certificate-status #{:inactive :active "INACTIVE" "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/role-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 20 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.invalid-query-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/invalid-query-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.invalid-query-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/target-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-response/violation-events (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/violation-events))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-violation-events-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-violation-events-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-violation-events-response/violation-events :portkey.aws.iot.-2015-05-28.list-violation-events-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/template-body (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/input-file-bucket (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/last-modified-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/success-count (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/failure-count (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/percentage-progress (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/percentage))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/input-file-key (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-s-3-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-registration-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/message :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/creation-date :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/template-body :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/input-file-bucket :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/role-arn :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/last-modified-date :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/status :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/success-count :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/failure-count :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/percentage-progress :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/input-file-key :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-response/task-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-target-mappings (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/security-profile-target-mapping))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/abort-criteria-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/abort-criteria :min-count 1))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/disable-all-logs clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/registry-s-3-key-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 1024)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9!_.*'()-\/]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/partition-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-response/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-response/stream-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-response/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-stream-response/stream-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-stream-response/stream-id :portkey.aws.iot.-2015-05-28.create-stream-response/stream-arn :portkey.aws.iot.-2015-05-28.create-stream-response/description :portkey.aws.iot.-2015-05-28.create-stream-response/stream-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-thing-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-thing-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.delete-thing-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-role-alias-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-role-alias-request/credential-duration-seconds (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/credential-duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-role-alias-request/role-alias :portkey.aws.iot.-2015-05-28.create-role-alias-request/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.create-role-alias-request/credential-duration-seconds]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-event-configurations-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-principal-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-principal-policies-response/policies :portkey.aws.iot.-2015-05-28.list-principal-policies-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-indexing-configuration-request/thing-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-indexing-configuration-request/thing-group-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-indexing-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-indexing-configuration-request/thing-indexing-configuration :portkey.aws.iot.-2015-05-28.update-indexing-configuration-request/thing-group-indexing-configuration]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-details/check-run-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-check-run-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-details/check-compliant (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/check-compliant))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-details/total-resources-count (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/total-resources-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-details/non-compliant-resources-count (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/non-compliant-resources-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-details/error-code (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-code))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-details/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-check-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.audit-check-details/check-run-status :portkey.aws.iot.-2015-05-28.audit-check-details/check-compliant :portkey.aws.iot.-2015-05-28.audit-check-details/total-resources-count :portkey.aws.iot.-2015-05-28.audit-check-details/non-compliant-resources-count :portkey.aws.iot.-2015-05-28.audit-check-details/error-code :portkey.aws.iot.-2015-05-28.audit-check-details/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-details (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/audit-check-name :portkey.aws.iot.-2015-05-28/audit-check-details))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/customer-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/customer-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/validity (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-validity))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/owned-by (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/transfer-data (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/transfer-data))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/generation-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/previous-owned-by (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-description/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.certificate-description/customer-version :portkey.aws.iot.-2015-05-28.certificate-description/creation-date :portkey.aws.iot.-2015-05-28.certificate-description/certificate-pem :portkey.aws.iot.-2015-05-28.certificate-description/ca-certificate-id :portkey.aws.iot.-2015-05-28.certificate-description/validity :portkey.aws.iot.-2015-05-28.certificate-description/last-modified-date :portkey.aws.iot.-2015-05-28.certificate-description/owned-by :portkey.aws.iot.-2015-05-28.certificate-description/transfer-data :portkey.aws.iot.-2015-05-28.certificate-description/generation-id :portkey.aws.iot.-2015-05-28.certificate-description/status :portkey.aws.iot.-2015-05-28.certificate-description/previous-owned-by :portkey.aws.iot.-2015-05-28.certificate-description/certificate-arn :portkey.aws.iot.-2015-05-28.certificate-description/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-response/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-response/stream-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-response/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-response/stream-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-stream-response/stream-id :portkey.aws.iot.-2015-05-28.update-stream-response/stream-arn :portkey.aws.iot.-2015-05-28.update-stream-response/description :portkey.aws.iot.-2015-05-28.update-stream-response/stream-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/principal-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.delete-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/marker (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[A-Za-z0-9+/]+={0,2}" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-request/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-request/files (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-files))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-stream-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-stream-request/stream-id] :opt-un [:portkey.aws.iot.-2015-05-28.update-stream-request/description :portkey.aws.iot.-2015-05-28.update-stream-request/files :portkey.aws.iot.-2015-05-28.update-stream-request/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/index-schema (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-response/task-ids (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-id-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-registration-tasks-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-response/task-ids :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-files (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/ota-update-file :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-document-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-document))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-signing-job-parameter/signing-profile-parameter (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/signing-profile-parameter))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-signing-job-parameter/signing-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/signing-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-signing-job-parameter/destination (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/destination))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/start-signing-job-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.start-signing-job-parameter/signing-profile-parameter :portkey.aws.iot.-2015-05-28.start-signing-job-parameter/signing-profile-name :portkey.aws.iot.-2015-05-28.start-signing-job-parameter/destination]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.destination/s-3-destination (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-destination))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/destination (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.destination/s-3-destination]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/task-id-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/task-id))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-thing-principal-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-thing-principal-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/detach-thing-principal-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.detach-thing-principal-request/thing-name :portkey.aws.iot.-2015-05-28.detach-thing-principal-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/rule-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-certificate-response/transferred-certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/transfer-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.transfer-certificate-response/transferred-certificate-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-indices-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-indices-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-indices-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-indices-request/next-token :portkey.aws.iot.-2015-05-28.list-indices-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-groups-for-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-request/next-token :portkey.aws.iot.-2015-05-28.list-thing-groups-for-thing-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/non-compliant-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/comparison-operator #{"less-than-equals" :notinportset :notincidrset "greater-than" "not-in-port-set" :lessthan "greater-than-equals" :lessthanequals :incidrset "in-cidr-set" "not-in-cidr-set" :greaterthanequals "in-port-set" :inportset :greaterthan "less-than"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 40))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-metadata (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-metadata))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-definition (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-name :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-arn :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-properties :portkey.aws.iot.-2015-05-28.thing-type-definition/thing-type-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-security-profile-request/security-profile-target-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attach-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.attach-security-profile-request/security-profile-name :portkey.aws.iot.-2015-05-28.attach-security-profile-request/security-profile-target-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/deprecate-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-names (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/policy-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-topic-rules-response/rules (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic-rule-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-topic-rules-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-topic-rules-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-topic-rules-response/rules :portkey.aws.iot.-2015-05-28.list-topic-rules-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-request/reason-code (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/reason-code))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-request/comment (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/comment))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-request/force (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cancel-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.cancel-job-request/job-id] :opt-un [:portkey.aws.iot.-2015-05-28.cancel-job-request/reason-code :portkey.aws.iot.-2015-05-28.cancel-job-request/comment :portkey.aws.iot.-2015-05-28.cancel-job-request/force]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-request/certificate-signing-request (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-signing-request))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-certificate-from-csr-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-certificate-from-csr-request/certificate-signing-request] :opt-un [:portkey.aws.iot.-2015-05-28.create-certificate-from-csr-request/set-as-active]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-request/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-request/behaviors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-request/alert-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-request/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.-2015-05-28.create-security-profile-request/security-profile-description :portkey.aws.iot.-2015-05-28.create-security-profile-request/behaviors :portkey.aws.iot.-2015-05-28.create-security-profile-request/alert-targets :portkey.aws.iot.-2015-05-28.create-security-profile-request/additional-metrics-to-retain :portkey.aws.iot.-2015-05-28.create-security-profile-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-targets (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/policy-target))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/forced clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-arns (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/resource-logical-id :portkey.aws.iot.-2015-05-28/resource-arn))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-metadata (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-metadata))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-name :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-id :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-arn :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-properties :portkey.aws.iot.-2015-05-28.describe-thing-type-response/thing-type-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.exponential-rollout-rate/base-rate-per-minute (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rollout-rate-per-minute))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.exponential-rollout-rate/increment-factor (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/increment-factor))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.exponential-rollout-rate/rate-increase-criteria (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rate-increase-criteria))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/exponential-rollout-rate (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.exponential-rollout-rate/base-rate-per-minute :portkey.aws.iot.-2015-05-28.exponential-rollout-rate/increment-factor :portkey.aws.iot.-2015-05-28.exponential-rollout-rate/rate-increase-criteria] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary/queued-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary/started-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary/execution-number (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-execution-summary/status :portkey.aws.iot.-2015-05-28.job-execution-summary/queued-at :portkey.aws.iot.-2015-05-28.job-execution-summary/started-at :portkey.aws.iot.-2015-05-28.job-execution-summary/last-updated-at :portkey.aws.iot.-2015-05-28.job-execution-summary/execution-number]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/elasticsearch-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/waiting-for-data-collection-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-group-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.rate-increase-criteria/number-of-notified-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/number-of-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.rate-increase-criteria/number-of-succeeded-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/number-of-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/rate-increase-criteria (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.rate-increase-criteria/number-of-notified-things :portkey.aws.iot.-2015-05-28.rate-increase-criteria/number-of-succeeded-things]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-as-active-flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.resource-already-exists-exception/message :portkey.aws.iot.-2015-05-28/resource-id :portkey.aws.iot.-2015-05-28/resource-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/rejected-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/force-delete-aws-job clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-response/certificates (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificates))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-certificates-by-ca-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-certificates-by-ca-response/certificates :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/alert-targets (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/alert-target-type :portkey.aws.iot.-2015-05-28/alert-target))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-active-violations-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-active-violations-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-active-violations-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-active-violations-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-active-violations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-active-violations-request/thing-name :portkey.aws.iot.-2015-05-28.list-active-violations-request/security-profile-name :portkey.aws.iot.-2015-05-28.list-active-violations-request/next-token :portkey.aws.iot.-2015-05-28.list-active-violations-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/force (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/expected-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/status-details (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/details-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cancel-job-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.cancel-job-execution-request/job-id :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.cancel-job-execution-request/force :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/expected-version :portkey.aws.iot.-2015-05-28.cancel-job-execution-request/status-details]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.implicit-deny/policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/implicit-deny (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.implicit-deny/policies]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-principals-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-principals-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-thing-principals-request/thing-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ca-certificates-response/certificates (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ca-certificates))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ca-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-ca-certificates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-ca-certificates-response/certificates :portkey.aws.iot.-2015-05-28.list-ca-certificates-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-authorizer-request/authorizer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/service-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/key-pair (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/key-pair))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-keys-and-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/certificate-arn :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/certificate-id :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/certificate-pem :portkey.aws.iot.-2015-05-28.create-keys-and-certificate-response/key-pair]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-dynamic-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-dynamic-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-dynamic-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-dynamic-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.delete-dynamic-thing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/aws-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-files (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/stream-file :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-registration-code-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-active-violations-response/active-violations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/active-violations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-active-violations-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-active-violations-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-active-violations-response/active-violations :portkey.aws.iot.-2015-05-28.list-active-violations-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/key-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/log-target-type #{:thing-group :default "THING_GROUP" "DEFAULT"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/enabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/query-string (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/status #{"Failed" "Cancelled" :in-progress "Cancelling" :completed :cancelled "InProgress" "Completed" :cancelling :failed})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/behaviors (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/behavior :max-count 100))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/allow-auto-registration clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-findings (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/audit-finding))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/auth-results (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/auth-result))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy-version/version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy-version/is-default-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy-version/create-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.policy-version/version-id :portkey.aws.iot.-2015-05-28.policy-version/is-default-version :portkey.aws.iot.-2015-05-28.policy-version/create-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/event-type #{:ca-certificate :thing-group "THING_TYPE" "THING_GROUP_HIERARCHY" "JOB_EXECUTION" "CA_CERTIFICATE" :thing-group-membership :job-execution "THING_TYPE_ASSOCIATION" "JOB" :thing-group-hierarchy :policy :certificate :thing :thing-type "POLICY" "THING_GROUP" "THING_GROUP_MEMBERSHIP" "THING" :job "CERTIFICATE" :thing-type-association})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/in-progress-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-thing-groups-for-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/role-alias (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\w=,@-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.log-target-configuration/log-target (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.log-target-configuration/log-level (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/log-target-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.log-target-configuration/log-target :portkey.aws.iot.-2015-05-28.log-target-configuration/log-level]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.put-item-input/table-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/table-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/put-item-input (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.put-item-input/table-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-response/things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-document-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.search-index-response/thing-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-document-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/search-index-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.search-index-response/next-token :portkey.aws.iot.-2015-05-28.search-index-response/things :portkey.aws.iot.-2015-05-28.search-index-response/thing-groups]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/succeeded-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/log-target-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/next-token (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/behavior-metric (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-ca-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-ca-certificate-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-file/file-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/file-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-file/file-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-file-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-file/file-location (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/file-location))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-file/code-signing (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/code-signing))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-file/attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attributes-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-file (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.ota-update-file/file-name :portkey.aws.iot.-2015-05-28.ota-update-file/file-version :portkey.aws.iot.-2015-05-28.ota-update-file/file-location :portkey.aws.iot.-2015-05-28.ota-update-file/code-signing :portkey.aws.iot.-2015-05-28.ota-update-file/attributes]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/range-key-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/hash-key-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.firehose-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.firehose-action/delivery-stream-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delivery-stream-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.firehose-action/separator (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/firehose-separator))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/firehose-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.firehose-action/role-arn :portkey.aws.iot.-2015-05-28.firehose-action/delivery-stream-name] :opt-un [:portkey.aws.iot.-2015-05-28.firehose-action/separator]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/role-alias-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/frequency (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/day-of-month (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/day-of-week (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/scheduled-audit-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/scheduled-audit-name :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/scheduled-audit-arn :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/frequency :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/day-of-month :portkey.aws.iot.-2015-05-28.scheduled-audit-metadata/day-of-week]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/consecutive-datapoints-to-alarm (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-default-authorizer-response/authorizer-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-default-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-default-authorizer-response/authorizer-description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/error-message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/total-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/timed-out-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-properties/thing-group-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-properties/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-group-properties/thing-group-description :portkey.aws.iot.-2015-05-28.thing-group-properties/attribute-payload]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cidrs (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/cidr))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-task-metadata/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-task-metadata/task-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-task-metadata/task-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-task-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.audit-task-metadata/task-id :portkey.aws.iot.-2015-05-28.audit-task-metadata/task-status :portkey.aws.iot.-2015-05-28.audit-task-metadata/task-type]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-role-aliases-response/role-aliases (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-aliases))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-role-aliases-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-role-aliases-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-role-aliases-response/role-aliases :portkey.aws.iot.-2015-05-28.list-role-aliases-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/topic (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-index-request/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-index-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-index-request/index-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/alert-target-type #{:sns "SNS"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-document (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 32768))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-check-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.get-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-request/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-policy-request/policy-name :portkey.aws.iot.-2015-05-28.create-policy-request/policy-document] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-principal-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-principal-policy-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attach-principal-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.attach-principal-policy-request/policy-name :portkey.aws.iot.-2015-05-28.attach-principal-policy-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/recursive-without-default clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/salesforce-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 40 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-attached-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-attached-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-attached-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-attached-policies-response/policies :portkey.aws.iot.-2015-05-28.list-attached-policies-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/query-string (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/query-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-dynamic-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/thing-group-name :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/query-string] :opt-un [:portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/thing-group-properties :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/index-name :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/query-version :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-scheduled-audit-response/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-scheduled-audit-response/scheduled-audit-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-scheduled-audits-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-scheduled-audits-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-scheduled-audits-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-scheduled-audits-request/next-token :portkey.aws.iot.-2015-05-28.list-scheduled-audits-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-response/resource-links (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-file-url-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-response/report-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/report-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-registration-task-reports-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-response/resource-links :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-response/report-type :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-metadata/parent-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-metadata/root-to-parent-thing-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-group-metadata/parent-group-name :portkey.aws.iot.-2015-05-28.thing-group-metadata/root-to-parent-thing-groups :portkey.aws.iot.-2015-05-28.thing-group-metadata/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-indexing-mode #{"ON" :off :on "OFF"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/target-selection #{"SNAPSHOT" :continuous "CONTINUOUS" :snapshot})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/detach-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-ota-update-request/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-ota-update-request/delete-stream (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-stream))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-ota-update-request/force-delete-aws-job (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/force-delete-aws-job))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-ota-update-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-ota-update-request/ota-update-id] :opt-un [:portkey.aws.iot.-2015-05-28.delete-ota-update-request/delete-stream :portkey.aws.iot.-2015-05-28.delete-ota-update-request/force-delete-aws-job]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/remove-auto-registration clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attributes (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/attribute-name :portkey.aws.iot.-2015-05-28/attribute-value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-registration-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-request/next-token :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-request/max-results :portkey.aws.iot.-2015-05-28.list-thing-registration-tasks-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-certificate-from-csr-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-certificate-from-csr-response/certificate-arn :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-response/certificate-id :portkey.aws.iot.-2015-05-28.create-certificate-from-csr-response/certificate-pem]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-response/security-profile-identifiers (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-identifiers))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-security-profiles-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-security-profiles-response/security-profile-identifiers :portkey.aws.iot.-2015-05-28.list-security-profiles-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-stream-request/stream-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/recursive (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/recursive))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/security-profile-target-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-security-profiles-for-target-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/security-profile-target-arn] :opt-un [:portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/next-token :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/max-results :portkey.aws.iot.-2015-05-28.list-security-profiles-for-target-request/recursive]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/queue-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/force-flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.tag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.tag-resource-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.tag-resource-request/resource-arn :portkey.aws.iot.-2015-05-28.tag-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/unsigned-long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.internal-failure-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/internal-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.internal-failure-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-thing-request/template-body (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-thing-request/parameters (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/parameters))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/register-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.register-thing-request/template-body] :opt-un [:portkey.aws.iot.-2015-05-28.register-thing-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/role-aliases (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/role-alias))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-policy-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-policy-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-targets-for-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-targets-for-policy-request/policy-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-targets-for-policy-request/marker :portkey.aws.iot.-2015-05-28.list-targets-for-policy-request/page-size]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/is-default-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-response/generation-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-policy-version-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-arn :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-name :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-document :portkey.aws.iot.-2015-05-28.get-policy-version-response/policy-version-id :portkey.aws.iot.-2015-05-28.get-policy-version-response/is-default-version :portkey.aws.iot.-2015-05-28.get-policy-version-response/creation-date :portkey.aws.iot.-2015-05-28.get-policy-version-response/last-modified-date :portkey.aws.iot.-2015-05-28.get-policy-version-response/generation-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-streams-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-streams-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-streams-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-streams-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-streams-request/max-results :portkey.aws.iot.-2015-05-28.list-streams-request/next-token :portkey.aws.iot.-2015-05-28.list-streams-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stop-thing-registration-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stop-thing-registration-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.stop-thing-registration-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-summary/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-summary/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizer-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.authorizer-summary/authorizer-name :portkey.aws.iot.-2015-05-28.authorizer-summary/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/tag))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/signature clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.versions-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/versions-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.versions-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/check-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-check-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/resource-identifier (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/start-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-request/end-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-audit-findings-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-audit-findings-request/task-id :portkey.aws.iot.-2015-05-28.list-audit-findings-request/check-name :portkey.aws.iot.-2015-05-28.list-audit-findings-request/resource-identifier :portkey.aws.iot.-2015-05-28.list-audit-findings-request/max-results :portkey.aws.iot.-2015-05-28.list-audit-findings-request/next-token :portkey.aws.iot.-2015-05-28.list-audit-findings-request/start-time :portkey.aws.iot.-2015-05-28.list-audit-findings-request/end-time]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-role-aliases-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-role-aliases-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-role-aliases-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-role-aliases-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-role-aliases-request/page-size :portkey.aws.iot.-2015-05-28.list-role-aliases-request/marker :portkey.aws.iot.-2015-05-28.list-role-aliases-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-execution-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-execution-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-execution-request/execution-number (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-job-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-job-execution-request/job-id :portkey.aws.iot.-2015-05-28.describe-job-execution-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.describe-job-execution-request/execution-number]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-thing-group-request/thing-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/check-compliant clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/searchable-attributes (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/attribute-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/tag-key))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-summary-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/job-summary))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-check-run-status #{"CANCELED" "IN_PROGRESS" :in-progress "COMPLETED_NON_COMPLIANT" :waiting-for-data-collection :completed-non-compliant "COMPLETED_COMPLIANT" :canceled "WAITING_FOR_DATA_COLLECTION" "FAILED" :failed :completed-compliant})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/message-format #{:raw "JSON" "RAW" :json})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/date-type clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-indexing-configuration/thing-indexing-mode (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-indexing-mode))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-indexing-configuration/thing-connectivity-indexing-mode (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-connectivity-indexing-mode))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-indexing-configuration (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.thing-indexing-configuration/thing-indexing-mode] :opt-un [:portkey.aws.iot.-2015-05-28.thing-indexing-configuration/thing-connectivity-indexing-mode]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/role-alias-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/owner (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/credential-duration-seconds (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/credential-duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.role-alias-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/role-alias-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.role-alias-description/role-alias :portkey.aws.iot.-2015-05-28.role-alias-description/role-alias-arn :portkey.aws.iot.-2015-05-28.role-alias-description/role-arn :portkey.aws.iot.-2015-05-28.role-alias-description/owner :portkey.aws.iot.-2015-05-28.role-alias-description/credential-duration-seconds :portkey.aws.iot.-2015-05-28.role-alias-description/creation-date :portkey.aws.iot.-2015-05-28.role-alias-description/last-modified-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-frequency #{:daily :biweekly :monthly "MONTHLY" "WEEKLY" "DAILY" "BIWEEKLY" :weekly})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/target-selection (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/aws-job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/files (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-files))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-ota-update-request/additional-parameters (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/additional-parameter-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-ota-update-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-ota-update-request/ota-update-id :portkey.aws.iot.-2015-05-28.create-ota-update-request/targets :portkey.aws.iot.-2015-05-28.create-ota-update-request/files :portkey.aws.iot.-2015-05-28.create-ota-update-request/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.create-ota-update-request/description :portkey.aws.iot.-2015-05-28.create-ota-update-request/target-selection :portkey.aws.iot.-2015-05-28.create-ota-update-request/aws-job-executions-rollout-config :portkey.aws.iot.-2015-05-28.create-ota-update-request/additional-parameters]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-v-2-logging-level-request/target-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-v-2-logging-level-request/target-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-v-2-logging-level-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-v-2-logging-level-request/target-type :portkey.aws.iot.-2015-05-28.delete-v-2-logging-level-request/target-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attribute-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 800)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.,@/:#-]*" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ca-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ca-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ca-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-ca-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-ca-certificates-request/page-size :portkey.aws.iot.-2015-05-28.list-ca-certificates-request/marker :portkey.aws.iot.-2015-05-28.list-ca-certificates-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/remove-thing-from-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-file-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/aws-iot-job-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/dynamo-key-type #{:number "NUMBER" :string "STRING"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/public-key-map (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/key-name :portkey.aws.iot.-2015-05-28/key-value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-certificate-request/force-delete (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/force-delete))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-certificate-request/certificate-id] :opt-un [:portkey.aws.iot.-2015-05-28.delete-certificate-request/force-delete]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cancel-certificate-transfer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.cancel-certificate-transfer-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior-criteria/comparison-operator (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/comparison-operator))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior-criteria/value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior-criteria/duration-seconds (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior-criteria/consecutive-datapoints-to-alarm (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/consecutive-datapoints-to-alarm))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior-criteria/consecutive-datapoints-to-clear (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/consecutive-datapoints-to-clear))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.behavior-criteria/statistical-threshold (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/statistical-threshold))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/behavior-criteria (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.behavior-criteria/comparison-operator :portkey.aws.iot.-2015-05-28.behavior-criteria/value :portkey.aws.iot.-2015-05-28.behavior-criteria/duration-seconds :portkey.aws.iot.-2015-05-28.behavior-criteria/consecutive-datapoints-to-alarm :portkey.aws.iot.-2015-05-28.behavior-criteria/consecutive-datapoints-to-clear :portkey.aws.iot.-2015-05-28.behavior-criteria/statistical-threshold]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.get-policy-request/policy-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/reason-for-non-compliance (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/target-selection (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/timeout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timeout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/abort-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/abort-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/document-source (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-document-source))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/presigned-url-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/presigned-url-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-job-request/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-job-request/job-id :portkey.aws.iot.-2015-05-28.create-job-request/targets] :opt-un [:portkey.aws.iot.-2015-05-28.create-job-request/target-selection :portkey.aws.iot.-2015-05-28.create-job-request/timeout-config :portkey.aws.iot.-2015-05-28.create-job-request/tags :portkey.aws.iot.-2015-05-28.create-job-request/document :portkey.aws.iot.-2015-05-28.create-job-request/abort-config :portkey.aws.iot.-2015-05-28.create-job-request/document-source :portkey.aws.iot.-2015-05-28.create-job-request/presigned-url-config :portkey.aws.iot.-2015-05-28.create-job-request/job-executions-rollout-config :portkey.aws.iot.-2015-05-28.create-job-request/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-identifiers (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/security-profile-identifier))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/error-code (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-registration-code-response/registration-code (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registration-code))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-registration-code-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-registration-code-response/registration-code]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-logging-options-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.resource-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-response/tasks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-metadata-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-audit-tasks-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-audit-tasks-response/tasks :portkey.aws.iot.-2015-05-28.list-audit-tasks-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.signing-profile-parameter/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.signing-profile-parameter/platform (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/platform))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.signing-profile-parameter/certificate-path-on-device (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-path-on-device))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/signing-profile-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.signing-profile-parameter/certificate-arn :portkey.aws.iot.-2015-05-28.signing-profile-parameter/platform :portkey.aws.iot.-2015-05-28.signing-profile-parameter/certificate-path-on-device]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-file/file-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/file-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-file/s-3-location (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-location))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-file (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.stream-file/file-id :portkey.aws.iot.-2015-05-28.stream-file/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sns-action/target-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sns-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sns-action/message-format (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message-format))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/sns-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.sns-action/target-arn :portkey.aws.iot.-2015-05-28.sns-action/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.sns-action/message-format]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/dynamic-group-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/query-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/query-string (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-metadata (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-metadata))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-thing-group-response/index-name :portkey.aws.iot.-2015-05-28.describe-thing-group-response/status :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-id :portkey.aws.iot.-2015-05-28.describe-thing-group-response/query-version :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-name :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-properties :portkey.aws.iot.-2015-05-28.describe-thing-group-response/version :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-arn :portkey.aws.iot.-2015-05-28.describe-thing-group-response/query-string :portkey.aws.iot.-2015-05-28.describe-thing-group-response/thing-group-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/channel-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.not-configured-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/not-configured-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.not-configured-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.presigned-url-config/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.presigned-url-config/expires-in-sec (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/expires-in-sec))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/presigned-url-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.presigned-url-config/role-arn :portkey.aws.iot.-2015-05-28.presigned-url-config/expires-in-sec]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.related-resource/resource-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.related-resource/resource-identifier (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.related-resource/additional-info (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/related-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.related-resource/resource-type :portkey.aws.iot.-2015-05-28.related-resource/resource-identifier :portkey.aws.iot.-2015-05-28.related-resource/additional-info]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/undo-deprecate clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-event-configurations-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-ca-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/queued-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-role-alias-request/role-alias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.invalid-response-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/invalid-response-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.invalid-response-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-thing-type-request/thing-type-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/credential-duration-seconds (clojure.spec.alpha/int-in 900 3600))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/task-start-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/check-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-check-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/related-resources (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/related-resources))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/finding-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/reason-for-non-compliance-code (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/reason-for-non-compliance-code))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/severity (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-finding-severity))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/non-compliant-resource (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/non-compliant-resource))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-finding/reason-for-non-compliance (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/reason-for-non-compliance))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-finding (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.audit-finding/task-start-time :portkey.aws.iot.-2015-05-28.audit-finding/check-name :portkey.aws.iot.-2015-05-28.audit-finding/related-resources :portkey.aws.iot.-2015-05-28.audit-finding/finding-time :portkey.aws.iot.-2015-05-28.audit-finding/reason-for-non-compliance-code :portkey.aws.iot.-2015-05-28.audit-finding/task-id :portkey.aws.iot.-2015-05-28.audit-finding/severity :portkey.aws.iot.-2015-05-28.audit-finding/non-compliant-resource :portkey.aws.iot.-2015-05-28.audit-finding/reason-for-non-compliance]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-alert-targets clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.index-not-ready-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/index-not-ready-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.index-not-ready-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-summary-for-job-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/job-execution-summary-for-job))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.aws-job-executions-rollout-config/maximum-per-minute (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/maximum-per-minute))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/aws-job-executions-rollout-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.aws-job-executions-rollout-config/maximum-per-minute]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-policy-request/policy-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/description (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-dynamic-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.associate-targets-with-job-response/job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.associate-targets-with-job-response/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.associate-targets-with-job-response/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/associate-targets-with-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.associate-targets-with-job-response/job-arn :portkey.aws.iot.-2015-05-28.associate-targets-with-job-response/job-id :portkey.aws.iot.-2015-05-28.associate-targets-with-job-response/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-execution-response/execution (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-job-execution-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-job-execution-response/execution]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/token-key-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/remove-thing-from-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-policy-version-request/policy-name :portkey.aws.iot.-2015-05-28.delete-policy-version-request/policy-version-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/port (clojure.spec.alpha/int-in 0 65535))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-attached-policies-request/target (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-target))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-attached-policies-request/recursive (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/recursive))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-attached-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-attached-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-attached-policies-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-attached-policies-request/target] :opt-un [:portkey.aws.iot.-2015-05-28.list-attached-policies-request/recursive :portkey.aws.iot.-2015-05-28.list-attached-policies-request/marker :portkey.aws.iot.-2015-05-28.list-attached-policies-request/page-size]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.billing-group-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.billing-group-metadata/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizer-status #{:inactive :active "INACTIVE" "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.group-name-and-arn/group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.group-name-and-arn/group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/group-name-and-arn (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.group-name-and-arn/group-name :portkey.aws.iot.-2015-05-28.group-name-and-arn/group-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.timeout-config/in-progress-timeout-in-minutes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/in-progress-timeout-in-minutes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/timeout-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.timeout-config/in-progress-timeout-in-minutes]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-on-demand-audit-task-response/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/start-on-demand-audit-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.start-on-demand-audit-task-response/task-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/aws-account-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 12 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 12)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[0-9]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/is-disabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/dynamic-group-status #{:building "REBUILDING" :active "BUILDING" "ACTIVE" :rebuilding})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sql-parse-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/sql-parse-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.sql-parse-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-response/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-response/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-authorizer-response/authorizer-name :portkey.aws.iot.-2015-05-28.update-authorizer-response/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resources (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/resource))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/frequency (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/day-of-month (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/day-of-week (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/target-check-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/frequency :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/day-of-month :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/day-of-week :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/target-check-names :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/scheduled-audit-name :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-response/scheduled-audit-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-documents (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/policy-document))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-indexing-configuration-response/thing-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-indexing-configuration-response/thing-group-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-indexing-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-indexing-configuration-response/thing-indexing-configuration :portkey.aws.iot.-2015-05-28.get-indexing-configuration-response/thing-group-indexing-configuration]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/auth-decision #{"IMPLICIT_DENY" :explicit-deny "ALLOWED" :implicit-deny "EXPLICIT_DENY" :allowed})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attribute-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-authorizers-response/authorizers (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizers))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-authorizers-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-authorizers-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-authorizers-response/authorizers :portkey.aws.iot.-2015-05-28.list-authorizers-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-name-and-arn-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/group-name-and-arn))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.internal-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/internal-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.internal-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.file-location/stream (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.file-location/s-3-location (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-location))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/file-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.file-location/stream :portkey.aws.iot.-2015-05-28.file-location/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.log-target/target-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.log-target/target-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/log-target (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.log-target/target-type] :opt-un [:portkey.aws.iot.-2015-05-28.log-target/target-name]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/default-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-response/generation-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-policy-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-policy-response/policy-name :portkey.aws.iot.-2015-05-28.get-policy-response/policy-arn :portkey.aws.iot.-2015-05-28.get-policy-response/policy-document :portkey.aws.iot.-2015-05-28.get-policy-response/default-version-id :portkey.aws.iot.-2015-05-28.get-policy-response/creation-date :portkey.aws.iot.-2015-05-28.get-policy-response/last-modified-date :portkey.aws.iot.-2015-05-28.get-policy-response/generation-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-namespace (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-unit (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-timestamp (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cloudwatch-metric-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/role-arn :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-namespace :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-name :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-value :portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-unit] :opt-un [:portkey.aws.iot.-2015-05-28.cloudwatch-metric-action/metric-timestamp]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-default-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-default-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.set-default-authorizer-request/authorizer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.version-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/version-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.version-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-notification-target/target-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-notification-target/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-notification-target/enabled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/enabled))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-notification-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.audit-notification-target/target-arn :portkey.aws.iot.-2015-05-28.audit-notification-target/role-arn :portkey.aws.iot.-2015-05-28.audit-notification-target/enabled]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-executions-rollout-config/maximum-per-minute (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-job-executions-per-min))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-executions-rollout-config/exponential-rate (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/exponential-rollout-rate))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-executions-rollout-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-executions-rollout-config/maximum-per-minute :portkey.aws.iot.-2015-05-28.job-executions-rollout-config/exponential-rate]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-summary/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-summary/stream-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-summary/stream-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream-summary/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.stream-summary/stream-id :portkey.aws.iot.-2015-05-28.stream-summary/stream-arn :portkey.aws.iot.-2015-05-28.stream-summary/stream-version :portkey.aws.iot.-2015-05-28.stream-summary/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-policy-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-policy-response/policy-name :portkey.aws.iot.-2015-05-28.create-policy-response/policy-arn :portkey.aws.iot.-2015-05-28.create-policy-response/policy-document :portkey.aws.iot.-2015-05-28.create-policy-response/policy-version-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-account-audit-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-behaviors clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/remove-thing-from-thing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-group-name :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-group-arn :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-name :portkey.aws.iot.-2015-05-28.remove-thing-from-thing-group-request/thing-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.error-info/code (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/code))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.error-info/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/error-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.error-info/code :portkey.aws.iot.-2015-05-28.error-info/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attributes-map (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/attribute-key :portkey.aws.iot.-2015-05-28/value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-document-source (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 1350))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-request/parent-group (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-request/name-prefix-filter (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-groups-request/recursive (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/recursive-without-default))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-groups-request/next-token :portkey.aws.iot.-2015-05-28.list-thing-groups-request/max-results :portkey.aws.iot.-2015-05-28.list-thing-groups-request/parent-group :portkey.aws.iot.-2015-05-28.list-thing-groups-request/name-prefix-filter :portkey.aws.iot.-2015-05-28.list-thing-groups-request/recursive]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/remove-thing-type clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-document/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-document/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-document/thing-group-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-document/attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-group-document/parent-group-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-document (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-group-document/thing-group-name :portkey.aws.iot.-2015-05-28.thing-group-document/thing-group-id :portkey.aws.iot.-2015-05-28.thing-group-document/thing-group-description :portkey.aws.iot.-2015-05-28.thing-group-document/attributes :portkey.aws.iot.-2015-05-28.thing-group-document/parent-group-names]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/remove-thing-from-billing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/billing-group-name :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/billing-group-arn :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/thing-name :portkey.aws.iot.-2015-05-28.remove-thing-from-billing-group-request/thing-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/authorizer-function-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/token-key-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/token-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/token-signing-public-keys (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/public-key-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.authorizer-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizer-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.authorizer-description/authorizer-name :portkey.aws.iot.-2015-05-28.authorizer-description/authorizer-arn :portkey.aws.iot.-2015-05-28.authorizer-description/authorizer-function-arn :portkey.aws.iot.-2015-05-28.authorizer-description/token-key-name :portkey.aws.iot.-2015-05-28.authorizer-description/token-signing-public-keys :portkey.aws.iot.-2015-05-28.authorizer-description/status :portkey.aws.iot.-2015-05-28.authorizer-description/creation-date :portkey.aws.iot.-2015-05-28.authorizer-description/last-modified-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delivery-stream-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-response/findings (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-findings))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-findings-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-audit-findings-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-audit-findings-response/findings :portkey.aws.iot.-2015-05-28.list-audit-findings-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-thing-principal-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.attach-thing-principal-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attach-thing-principal-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.attach-thing-principal-request/thing-name :portkey.aws.iot.-2015-05-28.attach-thing-principal-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-registration-failure-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-registration-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.resource-registration-failure-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sqs-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sqs-action/queue-url (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/queue-url))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.sqs-action/use-base-64 (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/use-base-64))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/sqs-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.sqs-action/role-arn :portkey.aws.iot.-2015-05-28.sqs-action/queue-url] :opt-un [:portkey.aws.iot.-2015-05-28.sqs-action/use-base-64]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/add-thing-to-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-scheduled-audit-request/scheduled-audit-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-versions-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-policy-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-policy-versions-request/policy-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cognito-identity-pool-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-additional-metrics-to-retain clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/parameter (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/details-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 1024)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[^\p{C}]*+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ports (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/port))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.get-policy-version-request/policy-name :portkey.aws.iot.-2015-05-28.get-policy-version-request/policy-version-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.allowed/policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/allowed (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.allowed/policies]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/percentage (clojure.spec.alpha/int-in 0 100))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-targets (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/target-arn :min-count 1))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/missing-context-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-connectivity-indexing-mode #{"STATUS" :status :off "OFF"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.denied/implicit-deny (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/implicit-deny))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.denied/explicit-deny (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/explicit-deny))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/denied (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.denied/implicit-deny :portkey.aws.iot.-2015-05-28.denied/explicit-deny]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.code-signing-signature/inline-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/signature))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/code-signing-signature (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.code-signing-signature/inline-document]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-things-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-things-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-principal-things-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-principal-things-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-principal-things-request/principal] :opt-un [:portkey.aws.iot.-2015-05-28.list-principal-things-request/next-token :portkey.aws.iot.-2015-05-28.list-principal-things-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.invalid-state-transition-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/invalid-state-transition-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.invalid-state-transition-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-certificate-response/certificate-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-certificate-response/certificate-description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.conflicting-resource-update-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.conflicting-resource-update-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/alert-target-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-endpoint-request/endpoint-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/endpoint-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-endpoint-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-endpoint-request/endpoint-type]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-targets-for-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-request/next-token :portkey.aws.iot.-2015-05-28.list-targets-for-security-profile-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-certificates-by-ca-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/ca-certificate-id] :opt-un [:portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/page-size :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/marker :portkey.aws.iot.-2015-05-28.list-certificates-by-ca-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/abort-threshold-percentage clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-notification-type #{:sns "SNS"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-file-url (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 65535))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/report-type #{:errors "RESULTS" "ERRORS" :results})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-role-alias-response/role-alias-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-role-alias-response/role-alias-description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/delete-behaviors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/behaviors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/delete-alert-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/delete-additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-additional-metrics-to-retain))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-security-profile-request/alert-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.-2015-05-28.update-security-profile-request/delete-behaviors :portkey.aws.iot.-2015-05-28.update-security-profile-request/additional-metrics-to-retain :portkey.aws.iot.-2015-05-28.update-security-profile-request/behaviors :portkey.aws.iot.-2015-05-28.update-security-profile-request/security-profile-description :portkey.aws.iot.-2015-05-28.update-security-profile-request/expected-version :portkey.aws.iot.-2015-05-28.update-security-profile-request/delete-alert-targets :portkey.aws.iot.-2015-05-28.update-security-profile-request/delete-additional-metrics-to-retain :portkey.aws.iot.-2015-05-28.update-security-profile-request/alert-targets]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-job-document-response/document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-job-document-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-job-document-response/document]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-type #{:ca-certificate "ACCOUNT_SETTINGS" "CLIENT_ID" :client-id :account-settings "CA_CERTIFICATE" :device-certificate "IOT_POLICY" "COGNITO_IDENTITY_POOL" "DEVICE_CERTIFICATE" :iot-policy :cognito-identity-pool})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/alarm-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-status-details/details-map (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/details-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-status-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-execution-status-details/details-map]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/hash-key-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/targets (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/target :min-count 1))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-account-audit-configuration-request/delete-scheduled-audits (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-scheduled-audits))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-account-audit-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.delete-account-audit-configuration-request/delete-scheduled-audits]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.republish-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.republish-action/topic (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic-pattern))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/republish-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.republish-action/role-arn :portkey.aws.iot.-2015-05-28.republish-action/topic] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-response/document-source (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-document-source))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-job-response/job (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-job-response/document-source :portkey.aws.iot.-2015-05-28.describe-job-response/job]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-identifier/device-certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-identifier/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-identifier/cognito-identity-pool-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cognito-identity-pool-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-identifier/client-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-identifier/policy-version-identifier (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.resource-identifier/account (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.resource-identifier/device-certificate-id :portkey.aws.iot.-2015-05-28.resource-identifier/ca-certificate-id :portkey.aws.iot.-2015-05-28.resource-identifier/cognito-identity-pool-id :portkey.aws.iot.-2015-05-28.resource-identifier/client-id :portkey.aws.iot.-2015-05-28.resource-identifier/policy-version-identifier :portkey.aws.iot.-2015-05-28.resource-identifier/account]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-response/log-target-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-v-2-logging-levels-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-response/log-target-configurations :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizer-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-ota-update-request/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-ota-update-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.get-ota-update-request/ota-update-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/clear-default-authorizer-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/ca-certificate (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/verification-certificate (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/allow-auto-registration (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/allow-auto-registration))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/registration-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registration-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/register-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.register-ca-certificate-request/ca-certificate :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/verification-certificate] :opt-un [:portkey.aws.iot.-2015-05-28.register-ca-certificate-request/set-as-active :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/allow-auto-registration :portkey.aws.iot.-2015-05-28.register-ca-certificate-request/registration-config]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policies-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-policies-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-policies-request/marker :portkey.aws.iot.-2015-05-28.list-policies-request/page-size :portkey.aws.iot.-2015-05-28.list-policies-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream-version (clojure.spec.alpha/int-in 0 65535))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-scheduled-audit-request/scheduled-audit-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-status #{"CANCELED" :timed-out "IN_PROGRESS" "TIMED_OUT" :in-progress :rejected "REMOVED" :queued :canceled "SUCCEEDED" "REJECTED" "QUEUED" "FAILED" :removed :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/register-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.register-certificate-response/certificate-arn :portkey.aws.iot.-2015-05-28.register-certificate-response/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.metric-value/count (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/unsigned-long))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.metric-value/cidrs (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cidrs))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.metric-value/ports (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ports))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/metric-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.metric-value/count :portkey.aws.iot.-2015-05-28.metric-value/cidrs :portkey.aws.iot.-2015-05-28.metric-value/ports]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-timed-out-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timed-out-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-canceled-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/canceled-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-queued-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/queued-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-in-progress-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/in-progress-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-removed-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/removed-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-failed-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/failed-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-succeeded-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/succeeded-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/number-of-rejected-things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rejected-things))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-process-details/processing-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/processing-target-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-process-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-process-details/number-of-timed-out-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-canceled-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-queued-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-in-progress-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-removed-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-failed-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-succeeded-things :portkey.aws.iot.-2015-05-28.job-process-details/number-of-rejected-things :portkey.aws.iot.-2015-05-28.job-process-details/processing-targets]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/client-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-already-completed-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/transfer-already-completed-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.transfer-already-completed-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-request/authorizer-function-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-request/token-key-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/token-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-request/token-signing-public-keys (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/public-key-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-authorizer-request/authorizer-name :portkey.aws.iot.-2015-05-28.create-authorizer-request/authorizer-function-arn :portkey.aws.iot.-2015-05-28.create-authorizer-request/token-key-name :portkey.aws.iot.-2015-05-28.create-authorizer-request/token-signing-public-keys] :opt-un [:portkey.aws.iot.-2015-05-28.create-authorizer-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-check-configurations (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/audit-check-name :portkey.aws.iot.-2015-05-28/audit-check-configuration))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-principals-response/principals (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principals))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-principals-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-principals-response/principals]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-scheduled-audits clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.elasticsearch-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.elasticsearch-action/endpoint (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/elasticsearch-endpoint))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.elasticsearch-action/index (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/elasticsearch-index))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.elasticsearch-action/type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/elasticsearch-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.elasticsearch-action/id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/elasticsearch-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/elasticsearch-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.elasticsearch-action/role-arn :portkey.aws.iot.-2015-05-28.elasticsearch-action/endpoint :portkey.aws.iot.-2015-05-28.elasticsearch-action/index :portkey.aws.iot.-2015-05-28.elasticsearch-action/type :portkey.aws.iot.-2015-05-28.elasticsearch-action/id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-location/bucket (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-bucket))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-location/key (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-key))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-location/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.s-3-location/bucket :portkey.aws.iot.-2015-05-28.s-3-location/key :portkey.aws.iot.-2015-05-28.s-3-location/version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-v-2-logging-level-request/log-target (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-v-2-logging-level-request/log-level (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-v-2-logging-level-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.set-v-2-logging-level-request/log-target :portkey.aws.iot.-2015-05-28.set-v-2-logging-level-request/log-level] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/total-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/total-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/in-progress-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/in-progress-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/waiting-for-data-collection-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/waiting-for-data-collection-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/compliant-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/compliant-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/non-compliant-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/non-compliant-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/failed-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/failed-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.task-statistics/canceled-checks (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/canceled-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/task-statistics (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.task-statistics/total-checks :portkey.aws.iot.-2015-05-28.task-statistics/in-progress-checks :portkey.aws.iot.-2015-05-28.task-statistics/waiting-for-data-collection-checks :portkey.aws.iot.-2015-05-28.task-statistics/compliant-checks :portkey.aws.iot.-2015-05-28.task-statistics/non-compliant-checks :portkey.aws.iot.-2015-05-28.task-statistics/failed-checks :portkey.aws.iot.-2015-05-28.task-statistics/canceled-checks]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/elasticsearch-index (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-job-document-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-job-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.get-job-document-request/job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policies (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/policy))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-response/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-response/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-group-response/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-thing-group-response/thing-group-name :portkey.aws.iot.-2015-05-28.create-thing-group-response/thing-group-arn :portkey.aws.iot.-2015-05-28.create-thing-group-response/thing-group-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.custom-code-signing/signature (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/code-signing-signature))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.custom-code-signing/certificate-chain (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/code-signing-certificate-chain))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.custom-code-signing/hash-algorithm (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/hash-algorithm))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.custom-code-signing/signature-algorithm (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/signature-algorithm))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/custom-code-signing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.custom-code-signing/signature :portkey.aws.iot.-2015-05-28.custom-code-signing/certificate-chain :portkey.aws.iot.-2015-05-28.custom-code-signing/hash-algorithm :portkey.aws.iot.-2015-05-28.custom-code-signing/signature-algorithm]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-as-active clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/table-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stop-thing-registration-task-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-bucket (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/billing-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-stream-request/stream-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/aws-iot-sql-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-billing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-billing-group-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.disable-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/disable-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.disable-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/auth-infos (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/auth-info :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-security-profile-request/security-profile-target-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/detach-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.detach-security-profile-request/security-profile-name :portkey.aws.iot.-2015-05-28.detach-security-profile-request/security-profile-target-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream/stream-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.stream/file-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/file-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/stream (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.stream/stream-id :portkey.aws.iot.-2015-05-28.stream/file-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/sql (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.validate-security-profile-behaviors-response/valid (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/valid))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.validate-security-profile-behaviors-response/validation-errors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/validation-errors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/validate-security-profile-behaviors-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.validate-security-profile-behaviors-response/valid :portkey.aws.iot.-2015-05-28.validate-security-profile-behaviors-response/validation-errors]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/details-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/registry-s-3-bucket-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 3 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 256)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9._-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/laser-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-job-executions-for-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/job-id] :opt-un [:portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/status :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/max-results :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/creation-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/abort-action #{"CANCEL" :cancel})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/range-key-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/range-key-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/table-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/table-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/hash-key-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/hash-key-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/range-key-field (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/range-key-field))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/hash-key-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/dynamo-key-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/operation (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/dynamo-operation))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/payload-field (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/payload-field))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/hash-key-field (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/hash-key-field))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.dynamo-db-action/range-key-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/dynamo-key-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/dynamo-db-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.dynamo-db-action/table-name :portkey.aws.iot.-2015-05-28.dynamo-db-action/role-arn :portkey.aws.iot.-2015-05-28.dynamo-db-action/hash-key-field :portkey.aws.iot.-2015-05-28.dynamo-db-action/hash-key-value] :opt-un [:portkey.aws.iot.-2015-05-28.dynamo-db-action/range-key-value :portkey.aws.iot.-2015-05-28.dynamo-db-action/range-key-field :portkey.aws.iot.-2015-05-28.dynamo-db-action/hash-key-type :portkey.aws.iot.-2015-05-28.dynamo-db-action/operation :portkey.aws.iot.-2015-05-28.dynamo-db-action/payload-field :portkey.aws.iot.-2015-05-28.dynamo-db-action/range-key-type]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/thing-groups-to-add (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/thing-groups-to-remove (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/override-dynamic-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/override-dynamic-groups))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-thing-groups-for-thing-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/thing-name :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/thing-groups-to-add :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/thing-groups-to-remove :portkey.aws.iot.-2015-05-28.update-thing-groups-for-thing-request/override-dynamic-groups]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/violation-event-type #{:inalarm "alarm-invalidated" :alarmcleared "in-alarm" "alarm-cleared" :alarminvalidated})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/total-resources-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-principals-response/principals (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principals))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-principals-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-policy-principals-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-policy-principals-response/principals :portkey.aws.iot.-2015-05-28.list-policy-principals-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/frequency (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/day-of-month (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/day-of-week (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/target-check-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/frequency :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/target-check-names :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/scheduled-audit-name] :opt-un [:portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/day-of-month :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/day-of-week :portkey.aws.iot.-2015-05-28.create-scheduled-audit-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/topic-rule-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/topic-rule-list-item))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-request/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-request/remove-thing-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/remove-thing-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-thing-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.update-thing-request/thing-type-name :portkey.aws.iot.-2015-05-28.update-thing-request/attribute-payload :portkey.aws.iot.-2015-05-28.update-thing-request/expected-version :portkey.aws.iot.-2015-05-28.update-thing-request/remove-thing-type]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-version-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[0-9]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.alert-target/alert-target-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/alert-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.alert-target/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/alert-target (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.alert-target/alert-target-arn :portkey.aws.iot.-2015-05-28.alert-target/role-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-types-response/thing-types (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-types-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-types-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-types-response/thing-types :portkey.aws.iot.-2015-05-28.list-thing-types-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-ca-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-ca-certificate-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/dynamo-operation (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizers (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/authorizer-summary))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/processing-target-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/processing-target-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-response/execution-summaries (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-summary-for-thing-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-job-executions-for-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-response/execution-summaries :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-response/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-response/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-response/thing-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-thing-response/thing-name :portkey.aws.iot.-2015-05-28.create-thing-response/thing-arn :portkey.aws.iot.-2015-05-28.create-thing-response/thing-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-request/cognito-identity-pool-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cognito-identity-pool-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-request/auth-infos (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/auth-infos))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-request/client-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-request/policy-names-to-add (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-names))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-request/policy-names-to-skip (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-names))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/test-authorization-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.test-authorization-request/auth-infos] :opt-un [:portkey.aws.iot.-2015-05-28.test-authorization-request/principal :portkey.aws.iot.-2015-05-28.test-authorization-request/cognito-identity-pool-id :portkey.aws.iot.-2015-05-28.test-authorization-request/client-id :portkey.aws.iot.-2015-05-28.test-authorization-request/policy-names-to-add :portkey.aws.iot.-2015-05-28.test-authorization-request/policy-names-to-skip]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/clear-default-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/hash-algorithm (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/index-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/query-string (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/query-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-dynamic-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/thing-group-name :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/thing-group-arn :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/thing-group-id :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/index-name :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/query-string :portkey.aws.iot.-2015-05-28.create-dynamic-thing-group-response/query-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-principals-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-principals-request/marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-principals-request/page-size (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policy-principals-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-policy-principals-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-policy-principals-request/policy-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-policy-principals-request/marker :portkey.aws.iot.-2015-05-28.list-policy-principals-request/page-size :portkey.aws.iot.-2015-05-28.list-policy-principals-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-status #{:inactive "REGISTER_INACTIVE" "REVOKED" :revoked :pending-activation :register-inactive :pending-transfer :active "INACTIVE" "PENDING_ACTIVATION" "ACTIVE" "PENDING_TRANSFER"})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy-version-identifier/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy-version-identifier/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-version-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.policy-version-identifier/policy-name :portkey.aws.iot.-2015-05-28.policy-version-identifier/policy-version-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.security-profile-identifier/name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.security-profile-identifier/arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-identifier (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.security-profile-identifier/name :portkey.aws.iot.-2015-05-28.security-profile-identifier/arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-authorizer-response/authorizer-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-authorizer-response/authorizer-description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-name-and-arn-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/group-name-and-arn))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-response/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-authorizer-response/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-authorizer-response/authorizer-name :portkey.aws.iot.-2015-05-28.create-authorizer-response/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.validate-security-profile-behaviors-request/behaviors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/validate-security-profile-behaviors-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.validate-security-profile-behaviors-request/behaviors] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/customer-version (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizer-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\w=,@-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.policy/policy-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.policy/policy-name :portkey.aws.iot.-2015-05-28.policy/policy-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-connectivity/connected (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/boolean))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-connectivity/timestamp (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/connectivity-timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-connectivity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-connectivity/connected :portkey.aws.iot.-2015-05-28.thing-connectivity/timestamp]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/key-pair (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28/public-key :portkey.aws.iot.-2015-05-28/private-key]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/maximum-per-minute (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/behavior-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.detach-policy-request/target (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-target))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/detach-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.detach-policy-request/policy-name :portkey.aws.iot.-2015-05-28.detach-policy-request/target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.tag/key (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-key))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.tag/value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.tag/key :portkey.aws.iot.-2015-05-28.tag/value]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-destination/bucket (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-bucket))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-destination/prefix (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/prefix))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-destination (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.s-3-destination/bucket :portkey.aws.iot.-2015-05-28.s-3-destination/prefix]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-response/execution-summaries (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-summary-for-job-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-job-executions-for-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-job-executions-for-job-response/execution-summaries :portkey.aws.iot.-2015-05-28.list-job-executions-for-job-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.malformed-policy-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/malformed-policy-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.malformed-policy-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-as-default clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-ota-update-response/ota-update-info (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-info))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-ota-update-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-ota-update-response/ota-update-info]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/reason-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\p{Upper}\p{Digit}_]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-ca-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/register-ca-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.register-ca-certificate-response/certificate-arn :portkey.aws.iot.-2015-05-28.register-ca-certificate-response/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-failure-type #{:timed-out "TIMED_OUT" :rejected :all "REJECTED" "FAILED" "ALL" :failed})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/add-thing-to-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/state-machine-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/override-dynamic-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/override-dynamic-groups))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/add-thing-to-thing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-group-name :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-group-arn :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-name :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/thing-arn :portkey.aws.iot.-2015-05-28.add-thing-to-thing-group-request/override-dynamic-groups]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-scheduled-audit-response/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-scheduled-audit-response/scheduled-audit-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-job-request/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-job-request/presigned-url-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/presigned-url-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-job-request/job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-job-request/abort-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/abort-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-job-request/timeout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timeout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-job-request/job-id] :opt-un [:portkey.aws.iot.-2015-05-28.update-job-request/description :portkey.aws.iot.-2015-05-28.update-job-request/presigned-url-config :portkey.aws.iot.-2015-05-28.update-job-request/job-executions-rollout-config :portkey.aws.iot.-2015-05-28.update-job-request/abort-config :portkey.aws.iot.-2015-05-28.update-job-request/timeout-config]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.logging-options-payload/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.logging-options-payload/log-level (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/logging-options-payload (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.logging-options-payload/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.logging-options-payload/log-level]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-metadata (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-metadata))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-name :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-id :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-arn :portkey.aws.iot.-2015-05-28.describe-billing-group-response/version :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-properties :portkey.aws.iot.-2015-05-28.describe-billing-group-response/billing-group-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/elasticsearch-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.throttling-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/throttling-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.throttling-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/file-id (clojure.spec.alpha/int-in 0 255))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/processing-target-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/security-profile-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/behaviors (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-security-profile-response/alert-targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-security-profile-response/creation-date :portkey.aws.iot.-2015-05-28.describe-security-profile-response/security-profile-arn :portkey.aws.iot.-2015-05-28.describe-security-profile-response/additional-metrics-to-retain :portkey.aws.iot.-2015-05-28.describe-security-profile-response/behaviors :portkey.aws.iot.-2015-05-28.describe-security-profile-response/last-modified-date :portkey.aws.iot.-2015-05-28.describe-security-profile-response/security-profile-description :portkey.aws.iot.-2015-05-28.describe-security-profile-response/version :portkey.aws.iot.-2015-05-28.describe-security-profile-response/security-profile-name :portkey.aws.iot.-2015-05-28.describe-security-profile-response/alert-targets]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/recursive (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/recursive))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-things-in-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/recursive :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/next-token :portkey.aws.iot.-2015-05-28.list-things-in-thing-group-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/resource-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.salesforce-action/token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/salesforce-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.salesforce-action/url (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/salesforce-endpoint))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/salesforce-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.salesforce-action/token :portkey.aws.iot.-2015-05-28.salesforce-action/url] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-job-request/force (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-job-request/job-id] :opt-un [:portkey.aws.iot.-2015-05-28.delete-job-request/force]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/event-configurations (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/event-type :portkey.aws.iot.-2015-05-28/configuration))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/version-number clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/salesforce-endpoint (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2000)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"https://ingestion-[a-zA-Z0-9]{1,12}\.[a-zA-Z0-9]+\.((sfdc-matrix\.net)|(sfdcnow\.com))/streams/\w{1,20}/\w{1,20}/event" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cancel-audit-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cancel-audit-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.cancel-audit-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.step-functions-action/execution-name-prefix (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/execution-name-prefix))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.step-functions-action/state-machine-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/state-machine-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.step-functions-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/step-functions-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.step-functions-action/state-machine-name :portkey.aws.iot.-2015-05-28.step-functions-action/role-arn] :opt-un [:portkey.aws.iot.-2015-05-28.step-functions-action/execution-name-prefix]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policies))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-policies-response/policies :portkey.aws.iot.-2015-05-28.list-policies-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ascending-order clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/target-selection (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/created-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/timeout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timeout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/completed-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/abort-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/abort-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/presigned-url-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/presigned-url-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/reason-code (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/reason-code))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/job-process-details (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-process-details))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/comment (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/comment))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/force-canceled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/forced))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job/target-selection :portkey.aws.iot.-2015-05-28.job/created-at :portkey.aws.iot.-2015-05-28.job/timeout-config :portkey.aws.iot.-2015-05-28.job/completed-at :portkey.aws.iot.-2015-05-28.job/abort-config :portkey.aws.iot.-2015-05-28.job/status :portkey.aws.iot.-2015-05-28.job/last-updated-at :portkey.aws.iot.-2015-05-28.job/targets :portkey.aws.iot.-2015-05-28.job/job-arn :portkey.aws.iot.-2015-05-28.job/presigned-url-config :portkey.aws.iot.-2015-05-28.job/reason-code :portkey.aws.iot.-2015-05-28.job/job-process-details :portkey.aws.iot.-2015-05-28.job/job-id :portkey.aws.iot.-2015-05-28.job/comment :portkey.aws.iot.-2015-05-28.job/job-executions-rollout-config :portkey.aws.iot.-2015-05-28.job/force-canceled :portkey.aws.iot.-2015-05-28.job/description]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/is-default-version clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-info/action-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/action-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-info/resources (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resources))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/auth-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.auth-info/action-type :portkey.aws.iot.-2015-05-28.auth-info/resources]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/target (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/transfer-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.transfer-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ge-max-results (clojure.spec.alpha/int-in 1 10000))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/rollout-rate-per-minute (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attach-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/code (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-validity/not-before (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-validity/not-after (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-validity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.certificate-validity/not-before :portkey.aws.iot.-2015-05-28.certificate-validity/not-after]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/violation-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/optional-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/start-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/end-time (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/task-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/task-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-task-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-audit-tasks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-audit-tasks-request/start-time :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/end-time] :opt-un [:portkey.aws.iot.-2015-05-28.list-audit-tasks-request/task-type :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/task-status :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/next-token :portkey.aws.iot.-2015-05-28.list-audit-tasks-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/action-type #{"SUBSCRIBE" "PUBLISH" :connect :receive "CONNECT" "RECEIVE" :subscribe :publish})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-summary-for-thing-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/job-execution-summary-for-thing))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-billing-group-request/billing-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/principal (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-target (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/customer-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/customer-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/validity (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-validity))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/owned-by (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/auto-registration-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/auto-registration-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/generation-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ca-certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate-description/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ca-certificate-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.ca-certificate-description/customer-version :portkey.aws.iot.-2015-05-28.ca-certificate-description/creation-date :portkey.aws.iot.-2015-05-28.ca-certificate-description/certificate-pem :portkey.aws.iot.-2015-05-28.ca-certificate-description/validity :portkey.aws.iot.-2015-05-28.ca-certificate-description/last-modified-date :portkey.aws.iot.-2015-05-28.ca-certificate-description/owned-by :portkey.aws.iot.-2015-05-28.ca-certificate-description/auto-registration-status :portkey.aws.iot.-2015-05-28.ca-certificate-description/generation-id :portkey.aws.iot.-2015-05-28.ca-certificate-description/status :portkey.aws.iot.-2015-05-28.ca-certificate-description/certificate-arn :portkey.aws.iot.-2015-05-28.ca-certificate-description/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/execution-name-prefix (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-thing-group-request/thing-group-name :portkey.aws.iot.-2015-05-28.update-thing-group-request/thing-group-properties] :opt-un [:portkey.aws.iot.-2015-05-28.update-thing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/add-thing-to-billing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/billing-group-name :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/billing-group-arn :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/thing-name :portkey.aws.iot.-2015-05-28.add-thing-to-billing-group-request/thing-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-data/transfer-message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-data/reject-reason (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-data/transfer-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-data/accept-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.transfer-data/reject-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/transfer-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.transfer-data/transfer-message :portkey.aws.iot.-2015-05-28.transfer-data/reject-reason :portkey.aws.iot.-2015-05-28.transfer-data/transfer-date :portkey.aws.iot.-2015-05-28.transfer-data/accept-date :portkey.aws.iot.-2015-05-28.transfer-data/reject-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/evaluation-statistic (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"(p0|p0\.1|p0\.01|p1|p10|p50|p90|p99|p99\.9|p99\.99|p100)" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/scheduled-audit-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/template-body (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/input-file-bucket (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/input-file-key (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-s-3-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/start-thing-registration-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/template-body :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/input-file-bucket :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/input-file-key :portkey.aws.iot.-2015-05-28.start-thing-registration-task-request/role-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.registration-code-validation-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/registration-code-validation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.registration-code-validation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/policy-versions (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/policy-version))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-security-profiles-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-security-profiles-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-security-profiles-request/next-token :portkey.aws.iot.-2015-05-28.list-security-profiles-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/alarm-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/alarm-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/state-reason (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/state-reason))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/state-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/state-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/cloudwatch-alarm-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/role-arn :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/alarm-name :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/state-reason :portkey.aws.iot.-2015-05-28.cloudwatch-alarm-action/state-value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/signing-job-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.test-authorization-response/auth-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/auth-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/test-authorization-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.test-authorization-response/auth-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.lambda-action/function-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/lambda-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.lambda-action/function-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-response/jobs (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-summary-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-jobs-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-jobs-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-jobs-response/jobs :portkey.aws.iot.-2015-05-28.list-jobs-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-logging-options-request/logging-options-payload (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/logging-options-payload))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-logging-options-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.set-logging-options-request/logging-options-payload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/report-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/report-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-thing-registration-task-reports-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/task-id :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/report-type] :opt-un [:portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/next-token :portkey.aws.iot.-2015-05-28.list-thing-registration-task-reports-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/bucket-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/failed-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 64 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 64)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"(0x)?[a-fA-F0-9]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-updates-summary (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/ota-update-summary))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-status #{"CREATE_PENDING" :create-complete "CREATE_FAILED" "CREATE_IN_PROGRESS" :create-failed :create-in-progress "CREATE_COMPLETE" :create-pending})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/attach-thing-principal-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-request/target-type (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/log-target-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/skyfall-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-v-2-logging-levels-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-request/target-type :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-request/next-token :portkey.aws.iot.-2015-05-28.list-v-2-logging-levels-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/related-resources (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/related-resource))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/endpoint-address (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/in-progress-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-pem (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 65536))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/file-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/target-selection (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/created-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-summary/completed-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-summary/job-arn :portkey.aws.iot.-2015-05-28.job-summary/job-id :portkey.aws.iot.-2015-05-28.job-summary/thing-group-id :portkey.aws.iot.-2015-05-28.job-summary/target-selection :portkey.aws.iot.-2015-05-28.job-summary/status :portkey.aws.iot.-2015-05-28.job-summary/created-at :portkey.aws.iot.-2015-05-28.job-summary/last-updated-at :portkey.aws.iot.-2015-05-28.job-summary/completed-at]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/thing-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/thing-group-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-group-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/attributes (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/shadow (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/json-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.thing-document/connectivity (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-connectivity))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-document (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.thing-document/thing-name :portkey.aws.iot.-2015-05-28.thing-document/thing-id :portkey.aws.iot.-2015-05-28.thing-document/thing-type-name :portkey.aws.iot.-2015-05-28.thing-document/thing-group-names :portkey.aws.iot.-2015-05-28.thing-document/attributes :portkey.aws.iot.-2015-05-28.thing-document/shadow :portkey.aws.iot.-2015-05-28.thing-document/connectivity]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 128)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-type-request/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-type-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-thing-type-request/thing-type-name] :opt-un [:portkey.aws.iot.-2015-05-28.create-thing-type-request/thing-type-properties :portkey.aws.iot.-2015-05-28.create-thing-type-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/dynamo-db (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/dynamo-db-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/sns (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/sns-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/cloudwatch-alarm (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cloudwatch-alarm-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/iot-analytics (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/iot-analytics-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/republish (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/republish-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/kinesis (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/kinesis-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/s-3 (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/s-3-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/salesforce (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/salesforce-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/sqs (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/sqs-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/elasticsearch (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/elasticsearch-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/cloudwatch-metric (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cloudwatch-metric-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/firehose (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/firehose-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/dynamo-d-bv-2 (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/dynamo-d-bv-2-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/lambda (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/lambda-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/step-functions (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/step-functions-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.action/iot-events (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/iot-events-action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/action (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.action/dynamo-db :portkey.aws.iot.-2015-05-28.action/sns :portkey.aws.iot.-2015-05-28.action/cloudwatch-alarm :portkey.aws.iot.-2015-05-28.action/iot-analytics :portkey.aws.iot.-2015-05-28.action/republish :portkey.aws.iot.-2015-05-28.action/kinesis :portkey.aws.iot.-2015-05-28.action/s-3 :portkey.aws.iot.-2015-05-28.action/salesforce :portkey.aws.iot.-2015-05-28.action/sqs :portkey.aws.iot.-2015-05-28.action/elasticsearch :portkey.aws.iot.-2015-05-28.action/cloudwatch-metric :portkey.aws.iot.-2015-05-28.action/firehose :portkey.aws.iot.-2015-05-28.action/dynamo-d-bv-2 :portkey.aws.iot.-2015-05-28.action/lambda :portkey.aws.iot.-2015-05-28.action/step-functions :portkey.aws.iot.-2015-05-28.action/iot-events]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28/enabled]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-type-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-type-definition))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-topic-rule-request/topic-rule-payload (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic-rule-payload))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-topic-rule-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/string))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-topic-rule-request/rule-name :portkey.aws.iot.-2015-05-28.create-topic-rule-request/topic-rule-payload] :opt-un [:portkey.aws.iot.-2015-05-28.create-topic-rule-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-dynamic-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-dynamic-thing-group-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/created-at-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary-for-thing/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution-summary-for-thing/job-execution-summary (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-summary))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution-summary-for-thing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-execution-summary-for-thing/job-id :portkey.aws.iot.-2015-05-28.job-execution-summary-for-thing/job-execution-summary]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 6144))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.certificate/certificate-arn :portkey.aws.iot.-2015-05-28.certificate/certificate-id :portkey.aws.iot.-2015-05-28.certificate/status :portkey.aws.iot.-2015-05-28.certificate/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/increment-factor clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/untag-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-job-execution-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-job-execution-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-job-execution-request/execution-number (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-job-execution-request/force (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-job-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-job-execution-request/job-id :portkey.aws.iot.-2015-05-28.delete-job-execution-request/thing-name :portkey.aws.iot.-2015-05-28.delete-job-execution-request/execution-number] :opt-un [:portkey.aws.iot.-2015-05-28.delete-job-execution-request/force]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-stream-response/stream-info (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-info))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-stream-response/stream-info]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-role-alias-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-role-alias-request/credential-duration-seconds (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/credential-duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-role-alias-request/role-alias] :opt-un [:portkey.aws.iot.-2015-05-28.update-role-alias-request/role-arn :portkey.aws.iot.-2015-05-28.update-role-alias-request/credential-duration-seconds]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 2028)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-response/is-default-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-policy-version-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-policy-version-response/policy-arn :portkey.aws.iot.-2015-05-28.create-policy-version-response/policy-document :portkey.aws.iot.-2015-05-28.create-policy-version-response/policy-version-id :portkey.aws.iot.-2015-05-28.create-policy-version-response/is-default-version]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-authorizer-request/authorizer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/state-reason (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/aws-iot-job-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-response/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-security-profile-response/security-profile-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-security-profile-response/security-profile-name :portkey.aws.iot.-2015-05-28.create-security-profile-response/security-profile-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/approximate-seconds-before-timed-out clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/elasticsearch-endpoint (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"https?://.*" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/aws-job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/target-selection (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-files (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-files))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/error-info (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-info))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/aws-iot-job-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-iot-job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/aws-iot-job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-iot-job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-update-description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ota-update-info/additional-parameters (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/additional-parameter-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ota-update-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.ota-update-info/creation-date :portkey.aws.iot.-2015-05-28.ota-update-info/aws-job-executions-rollout-config :portkey.aws.iot.-2015-05-28.ota-update-info/target-selection :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-id :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-status :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-files :portkey.aws.iot.-2015-05-28.ota-update-info/error-info :portkey.aws.iot.-2015-05-28.ota-update-info/last-modified-date :portkey.aws.iot.-2015-05-28.ota-update-info/ota-update-arn :portkey.aws.iot.-2015-05-28.ota-update-info/targets :portkey.aws.iot.-2015-05-28.ota-update-info/aws-iot-job-arn :portkey.aws.iot.-2015-05-28.ota-update-info/aws-iot-job-id :portkey.aws.iot.-2015-05-28.ota-update-info/description :portkey.aws.iot.-2015-05-28.ota-update-info/additional-parameters]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/signing-profile-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.effective-policy/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.effective-policy/policy-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.effective-policy/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/effective-policy (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.effective-policy/policy-name :portkey.aws.iot.-2015-05-28.effective-policy/policy-arn :portkey.aws.iot.-2015-05-28.effective-policy/policy-document]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-request/attribute-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attribute-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-request/attribute-value (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attribute-value))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-things-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-things-request/next-token :portkey.aws.iot.-2015-05-28.list-things-request/max-results :portkey.aws.iot.-2015-05-28.list-things-request/attribute-name :portkey.aws.iot.-2015-05-28.list-things-request/attribute-value :portkey.aws.iot.-2015-05-28.list-things-request/thing-type-name]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/details-map (clojure.spec.alpha/map-of :portkey.aws.iot.-2015-05-28/details-key :portkey.aws.iot.-2015-05-28/details-value))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-endpoint-response/endpoint-address (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/endpoint-address))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-endpoint-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.describe-endpoint-response/endpoint-address]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-request/authorizer-function-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-request/token-key-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/token-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-request/token-signing-public-keys (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/public-key-map))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-authorizer-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-authorizer-request/authorizer-name] :opt-un [:portkey.aws.iot.-2015-05-28.update-authorizer-request/authorizer-function-arn :portkey.aws.iot.-2015-05-28.update-authorizer-request/token-key-name :portkey.aws.iot.-2015-05-28.update-authorizer-request/token-signing-public-keys :portkey.aws.iot.-2015-05-28.update-authorizer-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.describe-thing-registration-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/task-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/describe-thing-registration-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.describe-thing-registration-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/consecutive-datapoints-to-clear (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/force-delete clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-indexing-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/recursive clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.audit-check-configuration/enabled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/enabled))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-check-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.audit-check-configuration/enabled]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-task-status #{"COMPLETED" "CANCELED" "IN_PROGRESS" :in-progress :completed :canceled "FAILED" :failed})

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/max-results (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/laser-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-job-executions-for-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/thing-name] :opt-un [:portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/status :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/max-results :portkey.aws.iot.-2015-05-28.list-job-executions-for-thing-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.replace-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.replace-topic-rule-request/topic-rule-payload (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic-rule-payload))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/replace-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.replace-topic-rule-request/rule-name :portkey.aws.iot.-2015-05-28.replace-topic-rule-request/topic-rule-payload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-action/bucket-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-action/key (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/key))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.s-3-action/canned-acl (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/canned-access-control-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/s-3-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.s-3-action/role-arn :portkey.aws.iot.-2015-05-28.s-3-action/bucket-name :portkey.aws.iot.-2015-05-28.s-3-action/key] :opt-un [:portkey.aws.iot.-2015-05-28.s-3-action/canned-acl]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/queued-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/started-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/approximate-seconds-before-timed-out (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/approximate-seconds-before-timed-out))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/status-details (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/execution-number (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/thing-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/version-number (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/version-number))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.job-execution/force-canceled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/forced))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.job-execution/queued-at :portkey.aws.iot.-2015-05-28.job-execution/started-at :portkey.aws.iot.-2015-05-28.job-execution/approximate-seconds-before-timed-out :portkey.aws.iot.-2015-05-28.job-execution/status-details :portkey.aws.iot.-2015-05-28.job-execution/execution-number :portkey.aws.iot.-2015-05-28.job-execution/status :portkey.aws.iot.-2015-05-28.job-execution/last-updated-at :portkey.aws.iot.-2015-05-28.job-execution/thing-arn :portkey.aws.iot.-2015-05-28.job-execution/job-id :portkey.aws.iot.-2015-05-28.job-execution/version-number :portkey.aws.iot.-2015-05-28.job-execution/force-canceled]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.iot-analytics-action/channel-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.iot-analytics-action/channel-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/channel-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.iot-analytics-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/iot-analytics-action (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.iot-analytics-action/channel-arn :portkey.aws.iot.-2015-05-28.iot-analytics-action/channel-name :portkey.aws.iot.-2015-05-28.iot-analytics-action/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.untag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.untag-resource-request/resource-arn :portkey.aws.iot.-2015-05-28.untag-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.security-profile-target-mapping/security-profile-identifier (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.security-profile-target-mapping/target (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/security-profile-target))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/security-profile-target-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.security-profile-target-mapping/security-profile-identifier :portkey.aws.iot.-2015-05-28.security-profile-target-mapping/target]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-account-audit-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-default-authorizer-response/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.set-default-authorizer-response/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/set-default-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.set-default-authorizer-response/authorizer-name :portkey.aws.iot.-2015-05-28.set-default-authorizer-response/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-registration-code-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-account-audit-configuration-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-account-audit-configuration-request/audit-notification-target-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-notification-target-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-account-audit-configuration-request/audit-check-configurations (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-check-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-account-audit-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.update-account-audit-configuration-request/role-arn :portkey.aws.iot.-2015-05-28.update-account-audit-configuration-request/audit-notification-target-configurations :portkey.aws.iot.-2015-05-28.update-account-audit-configuration-request/audit-check-configurations]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/generation-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-billing-groups-response/billing-groups (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-billing-groups-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-billing-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-billing-groups-response/billing-groups :portkey.aws.iot.-2015-05-28.list-billing-groups-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.kinesis-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.kinesis-action/stream-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stream-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.kinesis-action/partition-key (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/partition-key))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/kinesis-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.kinesis-action/role-arn :portkey.aws.iot.-2015-05-28.kinesis-action/stream-name] :opt-un [:portkey.aws.iot.-2015-05-28.kinesis-action/partition-key]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate/status (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ca-certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.ca-certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/ca-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.ca-certificate/certificate-arn :portkey.aws.iot.-2015-05-28.ca-certificate/certificate-id :portkey.aws.iot.-2015-05-28.ca-certificate/status :portkey.aws.iot.-2015-05-28.ca-certificate/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/query-max-results (clojure.spec.alpha/int-in 1 500))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-indexing-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/public-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/valid clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-response/things (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-attribute-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-things-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-things-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-things-response/things :portkey.aws.iot.-2015-05-28.list-things-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-request/policy-document (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-policy-version-request/set-as-default (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-as-default))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-policy-version-request/policy-name :portkey.aws.iot.-2015-05-28.create-policy-version-request/policy-document] :opt-un [:portkey.aws.iot.-2015-05-28.create-policy-version-request/set-as-default]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-type-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-type-response/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-thing-type-response/thing-type-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-type-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.create-thing-type-response/thing-type-name :portkey.aws.iot.-2015-05-28.create-thing-type-response/thing-type-arn :portkey.aws.iot.-2015-05-28.create-thing-type-response/thing-type-id]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.certificate-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/certificate-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.certificate-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-response/outgoing-certificates (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/outgoing-certificates))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/marker))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-outgoing-certificates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-outgoing-certificates-response/outgoing-certificates :portkey.aws.iot.-2015-05-28.list-outgoing-certificates-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/audit-task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 40)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/thing-group-list (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/thing-group-name))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/payload-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/authorizer-function-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-list-item/rule-arn (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-arn))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-list-item/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-list-item/topic-pattern (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/topic-pattern))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-list-item/created-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/created-at-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule-list-item/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/topic-rule-list-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.topic-rule-list-item/rule-arn :portkey.aws.iot.-2015-05-28.topic-rule-list-item/rule-name :portkey.aws.iot.-2015-05-28.topic-rule-list-item/topic-pattern :portkey.aws.iot.-2015-05-28.topic-rule-list-item/created-at :portkey.aws.iot.-2015-05-28.topic-rule-list-item/rule-disabled]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/is-authenticated clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/firehose-separator (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"([\n\t])|(\r\n)|(,)" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.delete-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.delete-role-alias-request/role-alias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/seconds clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/delete-ota-update-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-result/auth-info (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/auth-info))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-result/allowed (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/allowed))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-result/denied (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/denied))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-result/auth-decision (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/auth-decision))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.auth-result/missing-context-values (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/missing-context-values))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/auth-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.auth-result/auth-info :portkey.aws.iot.-2015-05-28.auth-result/allowed :portkey.aws.iot.-2015-05-28.auth-result/denied :portkey.aws.iot.-2015-05-28.auth-result/auth-decision :portkey.aws.iot.-2015-05-28.auth-result/missing-context-values]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.associate-targets-with-job-request/targets (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-targets))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.associate-targets-with-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.associate-targets-with-job-request/comment (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/comment))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/associate-targets-with-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.associate-targets-with-job-request/targets :portkey.aws.iot.-2015-05-28.associate-targets-with-job-request/job-id] :opt-un [:portkey.aws.iot.-2015-05-28.associate-targets-with-job-request/comment]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-billing-group-request/billing-group-properties (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/billing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.create-billing-group-request/tags (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/create-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.create-billing-group-request/billing-group-name] :opt-un [:portkey.aws.iot.-2015-05-28.create-billing-group-request/billing-group-properties :portkey.aws.iot.-2015-05-28.create-billing-group-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-thing-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.register-thing-response/resource-arns (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/resource-arns))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/register-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.register-thing-response/certificate-pem :portkey.aws.iot.-2015-05-28.register-thing-response/resource-arns]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-effective-policies-request/principal (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/principal))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-effective-policies-request/cognito-identity-pool-id (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cognito-identity-pool-id))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.get-effective-policies-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/get-effective-policies-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.get-effective-policies-request/principal :portkey.aws.iot.-2015-05-28.get-effective-policies-request/cognito-identity-pool-id :portkey.aws.iot.-2015-05-28.get-effective-policies-request/thing-name]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-account-audit-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ota-updates-response/ota-updates (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/ota-updates-summary))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.list-ota-updates-response/next-token (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/list-ota-updates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.list-ota-updates-response/ota-updates :portkey.aws.iot.-2015-05-28.list-ota-updates-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/principals (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/principal-arn))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/validation-errors (clojure.spec.alpha/coll-of :portkey.aws.iot.-2015-05-28/validation-error))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/rule-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/sql (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/sql))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/description (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/description))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/created-at (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/created-at-date))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/actions (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/action-list))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/aws-iot-sql-version (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/aws-iot-sql-version))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.topic-rule/error-action (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/action))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/topic-rule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.-2015-05-28.topic-rule/rule-name :portkey.aws.iot.-2015-05-28.topic-rule/sql :portkey.aws.iot.-2015-05-28.topic-rule/description :portkey.aws.iot.-2015-05-28.topic-rule/created-at :portkey.aws.iot.-2015-05-28.topic-rule/actions :portkey.aws.iot.-2015-05-28.topic-rule/rule-disabled :portkey.aws.iot.-2015-05-28.topic-rule/aws-iot-sql-version :portkey.aws.iot.-2015-05-28.topic-rule/error-action]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/registration-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 64 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 64)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"(0x)?[a-fA-F0-9]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/frequency (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/day-of-month (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/day-of-week (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/target-check-names (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/update-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/scheduled-audit-name] :opt-un [:portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/frequency :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/day-of-month :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/day-of-week :portkey.aws.iot.-2015-05-28.update-scheduled-audit-request/target-check-names]))

(clojure.spec.alpha/def :portkey.aws.iot.-2015-05-28/job-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 64)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__21112__auto__))))

(clojure.core/defn describe-audit-task "Gets information about a Device Defender audit." ([describe-audit-task-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-audit-task-request describe-audit-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-audit-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks/{taskId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-audit-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAuditTask", :http.request.configuration/output-deser-fn response-describe-audit-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-audit-task :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-audit-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-audit-task-response))

(clojure.core/defn tag-resource "Adds to or modifies the tags of the given resource. Tags are metadata which can\nbe used to manage a resource." ([tag-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/tag-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/tag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn response-tag-resource-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/tag-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/tag-resource-response))

(clojure.core/defn update-role-alias "Updates a role alias." ([update-role-alias-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-role-alias-request update-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRoleAlias", :http.request.configuration/output-deser-fn response-update-role-alias-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-role-alias-response))

(clojure.core/defn delete-billing-group "Deletes the billing group." ([delete-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-billing-group-request delete-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBillingGroup", :http.request.configuration/output-deser-fn response-delete-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-billing-group-response))

(clojure.core/defn get-ota-update "Gets an OTA update." ([get-ota-update-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-ota-update-request get-ota-update-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-ota-update-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates/{otaUpdateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-ota-update-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetOTAUpdate", :http.request.configuration/output-deser-fn response-get-ota-update-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef get-ota-update :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/get-ota-update-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-ota-update-response))

(clojure.core/defn list-indices "Lists the search indices." ([] (list-indices {})) ([list-indices-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-indices-request list-indices-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-indices-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indices", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-indices-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListIndices", :http.request.configuration/output-deser-fn response-list-indices-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-indices :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-indices-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-indices-response))

(clojure.core/defn list-policy-versions "Lists the versions of the specified policy and identifies the default version." ([list-policy-versions-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-policy-versions-request list-policy-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-policy-versions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-policy-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPolicyVersions", :http.request.configuration/output-deser-fn response-list-policy-versions-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-policy-versions :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-policy-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-policy-versions-response))

(clojure.core/defn delete-policy-version "Deletes the specified version of the specified policy. You cannot delete the\ndefault version of a policy using this API. To delete the default version of a\npolicy, use DeletePolicy. To find out which version of a policy is marked as the\ndefault version, use ListPolicyVersions." ([delete-policy-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-policy-version-request delete-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version/{policyVersionId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePolicyVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot.-2015-05-28/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-policy-version-request) :ret clojure.core/true?)

(clojure.core/defn create-role-alias "Creates a role alias." ([create-role-alias-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-role-alias-request create-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRoleAlias", :http.request.configuration/output-deser-fn response-create-role-alias-response, :http.request.spec/error-spec {"ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-role-alias-response))

(clojure.core/defn update-authorizer "Updates an authorizer." ([update-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-authorizer-request update-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAuthorizer", :http.request.configuration/output-deser-fn response-update-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-authorizer-response))

(clojure.core/defn attach-principal-policy "Attaches the specified policy to the specified principal (certificate or other\ncredential).\n Note: This API is deprecated. Please use AttachPolicy instead." ([attach-principal-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-attach-principal-policy-request attach-principal-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principal-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/attach-principal-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachPrincipalPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef attach-principal-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/attach-principal-policy-request) :ret clojure.core/true?)

(clojure.core/defn list-authorizers "Lists the authorizers registered in your account." ([] (list-authorizers {})) ([list-authorizers-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-authorizers-request list-authorizers-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-authorizers-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizers/", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-authorizers-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAuthorizers", :http.request.configuration/output-deser-fn response-list-authorizers-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-authorizers :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-authorizers-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-authorizers-response))

(clojure.core/defn detach-policy "Detaches a policy from the specified target." ([detach-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-detach-policy-request detach-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/target-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/detach-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef detach-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/detach-policy-request) :ret clojure.core/true?)

(clojure.core/defn search-index "The query search index." ([search-index-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-search-index-request search-index-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/search-index-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indices/search", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/search-index-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SearchIndex", :http.request.configuration/output-deser-fn response-search-index-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidQueryException" :portkey.aws.iot.-2015-05-28/invalid-query-exception, "IndexNotReadyException" :portkey.aws.iot.-2015-05-28/index-not-ready-exception}})))))
(clojure.spec.alpha/fdef search-index :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/search-index-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/search-index-response))

(clojure.core/defn delete-job-execution "Deletes a job execution." ([delete-job-execution-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-job-execution-request delete-job-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-job-execution-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteJobExecution", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InvalidStateTransitionException" :portkey.aws.iot.-2015-05-28/invalid-state-transition-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-job-execution :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-job-execution-request) :ret clojure.core/true?)

(clojure.core/defn list-certificates-by-ca "List the device certificates signed by the specified CA certificate." ([list-certificates-by-ca-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-certificates-by-ca-request list-certificates-by-ca-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-certificates-by-ca-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates-by-ca/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-certificates-by-ca-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCertificatesByCA", :http.request.configuration/output-deser-fn response-list-certificates-by-ca-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-certificates-by-ca :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-certificates-by-ca-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-certificates-by-ca-response))

(clojure.core/defn delete-stream "Deletes a stream." ([delete-stream-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-stream-request delete-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteStream", :http.request.configuration/output-deser-fn response-delete-stream-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "DeleteConflictException" :portkey.aws.iot.-2015-05-28/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-stream-response))

(clojure.core/defn get-policy-version "Gets information about the specified policy version." ([get-policy-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-policy-version-request get-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-policy-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version/{policyVersionId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPolicyVersion", :http.request.configuration/output-deser-fn response-get-policy-version-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef get-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/get-policy-version-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-policy-version-response))

(clojure.core/defn cancel-certificate-transfer "Cancels a pending transfer for the specified certificate.\n Note Only the transfer source account can use this operation to cancel a\ntransfer. (Transfer destinations can use RejectCertificateTransfer instead.)\nAfter transfer, AWS IoT returns the certificate to the source account in the\nINACTIVE state. After the destination account has accepted the transfer, the\ntransfer cannot be cancelled.\n After a certificate transfer is cancelled, the status of the certificate\nchanges from PENDING_TRANSFER to INACTIVE." ([cancel-certificate-transfer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-cancel-certificate-transfer-request cancel-certificate-transfer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cancel-certificate-transfer/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/cancel-certificate-transfer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelCertificateTransfer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot.-2015-05-28/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef cancel-certificate-transfer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/cancel-certificate-transfer-request) :ret clojure.core/true?)

(clojure.core/defn get-job-document "Gets a job document." ([get-job-document-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-job-document-request get-job-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-job-document-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/job-document", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-job-document-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetJobDocument", :http.request.configuration/output-deser-fn response-get-job-document-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-job-document :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/get-job-document-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-job-document-response))

(clojure.core/defn set-v-2-logging-options "Sets the logging options for the V2 logging service." ([] (set-v-2-logging-options {})) ([set-v-2-logging-options-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-set-v-2-logging-options-request set-v-2-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/set-v-2-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetV2LoggingOptions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef set-v-2-logging-options :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/set-v-2-logging-options-request) :ret clojure.core/true?)

(clojure.core/defn update-indexing-configuration "Updates the search configuration." ([] (update-indexing-configuration {})) ([update-indexing-configuration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-indexing-configuration-request update-indexing-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-indexing-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indexing/config", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-indexing-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateIndexingConfiguration", :http.request.configuration/output-deser-fn response-update-indexing-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-indexing-configuration :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/update-indexing-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-indexing-configuration-response))

(clojure.core/defn create-authorizer "Creates an authorizer." ([create-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-authorizer-request create-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAuthorizer", :http.request.configuration/output-deser-fn response-create-authorizer-response, :http.request.spec/error-spec {"ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-authorizer-response))

(clojure.core/defn list-scheduled-audits "Lists all of your scheduled audits." ([] (list-scheduled-audits {})) ([list-scheduled-audits-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-scheduled-audits-request list-scheduled-audits-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-scheduled-audits-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-scheduled-audits-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListScheduledAudits", :http.request.configuration/output-deser-fn response-list-scheduled-audits-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-scheduled-audits :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-scheduled-audits-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-scheduled-audits-response))

(clojure.core/defn list-ca-certificates "Lists the CA certificates registered for your AWS account.\n The results are paginated with a default page size of 25. You can use the\nreturned marker to retrieve additional results." ([] (list-ca-certificates {})) ([list-ca-certificates-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-ca-certificates-request list-ca-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-ca-certificates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-ca-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCACertificates", :http.request.configuration/output-deser-fn response-list-ca-certificates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-ca-certificates :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-ca-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-ca-certificates-response))

(clojure.core/defn create-ota-update "Creates an AWS IoT OTAUpdate on a target group of things or groups." ([create-ota-update-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-ota-update-request create-ota-update-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-ota-update-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates/{otaUpdateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-ota-update-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateOTAUpdate", :http.request.configuration/output-deser-fn response-create-ota-update-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-ota-update :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-ota-update-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-ota-update-response))

(clojure.core/defn list-violation-events "Lists the Device Defender security profile violations discovered during the\ngiven time period. You can use filters to limit the results to those alerts\nissued for a particular security profile, behavior or thing (device)." ([list-violation-events-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-violation-events-request list-violation-events-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-violation-events-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/violation-events", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-violation-events-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListViolationEvents", :http.request.configuration/output-deser-fn response-list-violation-events-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-violation-events :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-violation-events-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-violation-events-response))

(clojure.core/defn list-v-2-logging-levels "Lists logging levels." ([] (list-v-2-logging-levels {})) ([list-v-2-logging-levels-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-v-2-logging-levels-request list-v-2-logging-levels-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-v-2-logging-levels-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingLevel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-v-2-logging-levels-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListV2LoggingLevels", :http.request.configuration/output-deser-fn response-list-v-2-logging-levels-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "NotConfiguredException" :portkey.aws.iot.-2015-05-28/not-configured-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-v-2-logging-levels :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-v-2-logging-levels-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-v-2-logging-levels-response))

(clojure.core/defn list-security-profiles "Lists the Device Defender security profiles you have created. You can use\nfilters to list only those security profiles associated with a thing group or\nonly those associated with your account." ([] (list-security-profiles {})) ([list-security-profiles-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-security-profiles-request list-security-profiles-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-security-profiles-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-security-profiles-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListSecurityProfiles", :http.request.configuration/output-deser-fn response-list-security-profiles-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-security-profiles :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-security-profiles-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-security-profiles-response))

(clojure.core/defn create-thing "Creates a thing record in the registry.\n This is a control plane operation. See Authorization\n(https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html) for\ninformation about authorizing control plane actions." ([create-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-thing-request create-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateThing", :http.request.configuration/output-deser-fn response-create-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef create-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-thing-response))

(clojure.core/defn delete-account-audit-configuration "Restores the default settings for Device Defender audits for this account. Any\nconfiguration data you entered is deleted and all audit checks are reset to\ndisabled." ([] (delete-account-audit-configuration {})) ([delete-account-audit-configuration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-account-audit-configuration-request delete-account-audit-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-account-audit-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/configuration", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-account-audit-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAccountAuditConfiguration", :http.request.configuration/output-deser-fn response-delete-account-audit-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-account-audit-configuration :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/delete-account-audit-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-account-audit-configuration-response))

(clojure.core/defn delete-scheduled-audit "Deletes a scheduled audit." ([delete-scheduled-audit-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-scheduled-audit-request delete-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteScheduledAudit", :http.request.configuration/output-deser-fn response-delete-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-scheduled-audit-response))

(clojure.core/defn update-event-configurations "Updates the event configurations." ([] (update-event-configurations {})) ([update-event-configurations-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-event-configurations-request update-event-configurations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-event-configurations-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/event-configurations", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-event-configurations-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateEventConfigurations", :http.request.configuration/output-deser-fn response-update-event-configurations-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef update-event-configurations :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/update-event-configurations-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-event-configurations-response))

(clojure.core/defn create-topic-rule "Creates a rule. Creating rules is an administrator-level action. Any user who\nhas permission to create rules will be able to access data processed by the\nrule." ([create-topic-rule-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-topic-rule-request create-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"SqlParseException" :portkey.aws.iot.-2015-05-28/sql-parse-exception, "InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "ConflictingResourceUpdateException" :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef create-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn update-billing-group "Updates information about the billing group." ([update-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-billing-group-request update-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateBillingGroup", :http.request.configuration/output-deser-fn response-update-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-billing-group-response))

(clojure.core/defn accept-certificate-transfer "Accepts a pending certificate transfer. The default state of the certificate is\nINACTIVE.\n To check for pending certificate transfers, call ListCertificates to enumerate\nyour certificates." ([accept-certificate-transfer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-accept-certificate-transfer-request accept-certificate-transfer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accept-certificate-transfer/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/accept-certificate-transfer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AcceptCertificateTransfer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot.-2015-05-28/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef accept-certificate-transfer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/accept-certificate-transfer-request) :ret clojure.core/true?)

(clojure.core/defn get-registration-code "Gets a registration code used to register a CA certificate with AWS IoT." ([] (get-registration-code {})) ([get-registration-code-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-registration-code-request get-registration-code-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-registration-code-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/registrationcode", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-registration-code-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRegistrationCode", :http.request.configuration/output-deser-fn response-get-registration-code-response, :http.request.spec/error-spec {"ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception}})))))
(clojure.spec.alpha/fdef get-registration-code :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/get-registration-code-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-registration-code-response))

(clojure.core/defn list-policies "Lists your policies." ([] (list-policies {})) ([list-policies-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-policies-request list-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPolicies", :http.request.configuration/output-deser-fn response-list-policies-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-policies :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-policies-response))

(clojure.core/defn list-thing-registration-task-reports "Information about the thing registration tasks." ([list-thing-registration-task-reports-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-thing-registration-task-reports-request list-thing-registration-task-reports-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-thing-registration-task-reports-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks/{taskId}/reports", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-thing-registration-task-reports-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingRegistrationTaskReports", :http.request.configuration/output-deser-fn response-list-thing-registration-task-reports-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-thing-registration-task-reports :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-thing-registration-task-reports-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-thing-registration-task-reports-response))

(clojure.core/defn set-v-2-logging-level "Sets the logging level." ([set-v-2-logging-level-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-set-v-2-logging-level-request set-v-2-logging-level-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingLevel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/set-v-2-logging-level-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetV2LoggingLevel", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "NotConfiguredException" :portkey.aws.iot.-2015-05-28/not-configured-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef set-v-2-logging-level :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/set-v-2-logging-level-request) :ret clojure.core/true?)

(clojure.core/defn delete-registration-code "Deletes a CA certificate registration code." ([] (delete-registration-code {})) ([delete-registration-code-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-registration-code-request delete-registration-code-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-registration-code-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/registrationcode", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-registration-code-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRegistrationCode", :http.request.configuration/output-deser-fn response-delete-registration-code-response, :http.request.spec/error-spec {"ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-registration-code :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/delete-registration-code-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-registration-code-response))

(clojure.core/defn describe-ca-certificate "Describes a registered CA certificate." ([describe-ca-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-ca-certificate-request describe-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-ca-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeCACertificate", :http.request.configuration/output-deser-fn response-describe-ca-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-ca-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-ca-certificate-response))

(clojure.core/defn detach-thing-principal "Detaches the specified principal from the specified thing. A principal can be\nX.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or\nfederated identities.\n This call is asynchronous. It might take several seconds for the detachment to\npropagate." ([detach-thing-principal-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-detach-thing-principal-request detach-thing-principal-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/detach-thing-principal-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/detach-thing-principal-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachThingPrincipal", :http.request.configuration/output-deser-fn response-detach-thing-principal-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef detach-thing-principal :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/detach-thing-principal-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/detach-thing-principal-response))

(clojure.core/defn list-billing-groups "Lists the billing groups you have created." ([] (list-billing-groups {})) ([list-billing-groups-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-billing-groups-request list-billing-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-billing-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-billing-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBillingGroups", :http.request.configuration/output-deser-fn response-list-billing-groups-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef list-billing-groups :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-billing-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-billing-groups-response))

(clojure.core/defn create-security-profile "Creates a Device Defender security profile." ([create-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-security-profile-request create-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSecurityProfile", :http.request.configuration/output-deser-fn response-create-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-security-profile-response))

(clojure.core/defn list-thing-registration-tasks "List bulk thing provisioning tasks." ([] (list-thing-registration-tasks {})) ([list-thing-registration-tasks-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-thing-registration-tasks-request list-thing-registration-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-thing-registration-tasks-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-thing-registration-tasks-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingRegistrationTasks", :http.request.configuration/output-deser-fn response-list-thing-registration-tasks-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-thing-registration-tasks :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-thing-registration-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-thing-registration-tasks-response))

(clojure.core/defn associate-targets-with-job "Associates a group with a continuous job. The following criteria must be met:\n * The job must have been created with the targetSelection field set to\n\"CONTINUOUS\".\n * The job status must currently be \"IN_PROGRESS\".\n * The total number of targets associated with a job must not exceed 100." ([associate-targets-with-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-associate-targets-with-job-request associate-targets-with-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/associate-targets-with-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/associate-targets-with-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateTargetsWithJob", :http.request.configuration/output-deser-fn response-associate-targets-with-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef associate-targets-with-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/associate-targets-with-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/associate-targets-with-job-response))

(clojure.core/defn get-indexing-configuration "Gets the search configuration." ([] (get-indexing-configuration {})) ([get-indexing-configuration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-indexing-configuration-request get-indexing-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-indexing-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indexing/config", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-indexing-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetIndexingConfiguration", :http.request.configuration/output-deser-fn response-get-indexing-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef get-indexing-configuration :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/get-indexing-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-indexing-configuration-response))

(clojure.core/defn cancel-job-execution "Cancels the execution of a job for a given thing." ([cancel-job-execution-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-cancel-job-execution-request cancel-job-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs/{jobId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/cancel-job-execution-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelJobExecution", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InvalidStateTransitionException" :portkey.aws.iot.-2015-05-28/invalid-state-transition-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception}})))))
(clojure.spec.alpha/fdef cancel-job-execution :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/cancel-job-execution-request) :ret clojure.core/true?)

(clojure.core/defn create-dynamic-thing-group "Creates a dynamic thing group." ([create-dynamic-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-dynamic-thing-group-request create-dynamic-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-dynamic-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/dynamic-thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-dynamic-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDynamicThingGroup", :http.request.configuration/output-deser-fn response-create-dynamic-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "InvalidQueryException" :portkey.aws.iot.-2015-05-28/invalid-query-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef create-dynamic-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-dynamic-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-dynamic-thing-group-response))

(clojure.core/defn list-outgoing-certificates "Lists certificates that are being transferred but not yet accepted." ([] (list-outgoing-certificates {})) ([list-outgoing-certificates-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-outgoing-certificates-request list-outgoing-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-outgoing-certificates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates-out-going", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-outgoing-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListOutgoingCertificates", :http.request.configuration/output-deser-fn response-list-outgoing-certificates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-outgoing-certificates :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-outgoing-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-outgoing-certificates-response))

(clojure.core/defn start-thing-registration-task "Creates a bulk thing provisioning task." ([start-thing-registration-task-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-start-thing-registration-task-request start-thing-registration-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/start-thing-registration-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/start-thing-registration-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartThingRegistrationTask", :http.request.configuration/output-deser-fn response-start-thing-registration-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef start-thing-registration-task :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/start-thing-registration-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/start-thing-registration-task-response))

(clojure.core/defn update-account-audit-configuration "Configures or reconfigures the Device Defender audit settings for this account.\nSettings include how audit notifications are sent and which audit checks are\nenabled or disabled." ([] (update-account-audit-configuration {})) ([update-account-audit-configuration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-account-audit-configuration-request update-account-audit-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-account-audit-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/configuration", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-account-audit-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAccountAuditConfiguration", :http.request.configuration/output-deser-fn response-update-account-audit-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-account-audit-configuration :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/update-account-audit-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-account-audit-configuration-response))

(clojure.core/defn list-streams "Lists all of the streams in your AWS account." ([] (list-streams {})) ([list-streams-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-streams-request list-streams-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-streams-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-streams-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListStreams", :http.request.configuration/output-deser-fn response-list-streams-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-streams :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-streams-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-streams-response))

(clojure.core/defn list-thing-groups-for-thing "List the thing groups to which the specified thing belongs." ([list-thing-groups-for-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-thing-groups-for-thing-request list-thing-groups-for-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-thing-groups-for-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/thing-groups", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-thing-groups-for-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingGroupsForThing", :http.request.configuration/output-deser-fn response-list-thing-groups-for-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-thing-groups-for-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-thing-groups-for-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-thing-groups-for-thing-response))

(clojure.core/defn delete-v-2-logging-level "Deletes a logging level." ([delete-v-2-logging-level-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-v-2-logging-level-request delete-v-2-logging-level-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingLevel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-v-2-logging-level-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteV2LoggingLevel", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-v-2-logging-level :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-v-2-logging-level-request) :ret clojure.core/true?)

(clojure.core/defn delete-ca-certificate "Deletes a registered CA certificate." ([delete-ca-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-ca-certificate-request delete-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-ca-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCACertificate", :http.request.configuration/output-deser-fn response-delete-ca-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "CertificateStateException" :portkey.aws.iot.-2015-05-28/certificate-state-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-ca-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-ca-certificate-response))

(clojure.core/defn list-tags-for-resource "Lists the tags (metadata) you have assigned to the resource." ([list-tags-for-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-tags-for-resource-request list-tags-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-tags-for-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-tags-for-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-list-tags-for-resource-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-tags-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-tags-for-resource-response))

(clojure.core/defn list-principal-things "Lists the things associated with the specified principal. A principal can be\nX.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or\nfederated identities." ([list-principal-things-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-principal-things-request list-principal-things-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-principal-things-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principals/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-principal-things-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPrincipalThings", :http.request.configuration/output-deser-fn response-list-principal-things-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-principal-things :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-principal-things-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-principal-things-response))

(clojure.core/defn test-invoke-authorizer "Tests a custom authorization behavior by invoking a specified custom authorizer.\nUse this to test and debug the custom authorization behavior of devices that\nconnect to the AWS IoT device gateway." ([test-invoke-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-test-invoke-authorizer-request test-invoke-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/test-invoke-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}/test", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/test-invoke-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestInvokeAuthorizer", :http.request.configuration/output-deser-fn response-test-invoke-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "InvalidResponseException" :portkey.aws.iot.-2015-05-28/invalid-response-exception}})))))
(clojure.spec.alpha/fdef test-invoke-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/test-invoke-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/test-invoke-authorizer-response))

(clojure.core/defn describe-account-audit-configuration "Gets information about the Device Defender audit settings for this account.\nSettings include how audit notifications are sent and which audit checks are\nenabled or disabled." ([] (describe-account-audit-configuration {})) ([describe-account-audit-configuration-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-account-audit-configuration-request describe-account-audit-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-account-audit-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/configuration", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-account-audit-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAccountAuditConfiguration", :http.request.configuration/output-deser-fn response-describe-account-audit-configuration-response, :http.request.spec/error-spec {"ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-account-audit-configuration :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/describe-account-audit-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-account-audit-configuration-response))

(clojure.core/defn delete-role-alias "Deletes a role alias" ([delete-role-alias-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-role-alias-request delete-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRoleAlias", :http.request.configuration/output-deser-fn response-delete-role-alias-response, :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot.-2015-05-28/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-role-alias-response))

(clojure.core/defn list-audit-findings "Lists the findings (results) of a Device Defender audit or of the audits\nperformed during a specified time period. (Findings are retained for 180 days.)" ([] (list-audit-findings {})) ([list-audit-findings-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-audit-findings-request list-audit-findings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-audit-findings-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/findings", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-audit-findings-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAuditFindings", :http.request.configuration/output-deser-fn response-list-audit-findings-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-audit-findings :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-audit-findings-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-audit-findings-response))

(clojure.core/defn create-policy-version "Creates a new version of the specified AWS IoT policy. To update a policy,\ncreate a new policy version. A managed policy can have up to five versions. If\nthe policy has five versions, you must use DeletePolicyVersion to delete an\nexisting version before you create a new one.\n Optionally, you can set the new version as the policy's default version. The\ndefault version is the operative version (that is, the version that is in effect\nfor the certificates to which the policy is attached)." ([create-policy-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-policy-version-request create-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-policy-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePolicyVersion", :http.request.configuration/output-deser-fn response-create-policy-version-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "MalformedPolicyException" :portkey.aws.iot.-2015-05-28/malformed-policy-exception, "VersionsLimitExceededException" :portkey.aws.iot.-2015-05-28/versions-limit-exceeded-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-policy-version-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-policy-version-response))

(clojure.core/defn list-role-aliases "Lists the role aliases registered in your account." ([] (list-role-aliases {})) ([list-role-aliases-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-role-aliases-request list-role-aliases-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-role-aliases-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-role-aliases-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListRoleAliases", :http.request.configuration/output-deser-fn response-list-role-aliases-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-role-aliases :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-role-aliases-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-role-aliases-response))

(clojure.core/defn describe-job "Describes a job." ([describe-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-job-request describe-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeJob", :http.request.configuration/output-deser-fn response-describe-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-job-response))

(clojure.core/defn describe-endpoint "Returns a unique endpoint specific to the AWS account making the call." ([] (describe-endpoint {})) ([describe-endpoint-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-endpoint-request describe-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-endpoint-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/endpoint", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-endpoint-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEndpoint", :http.request.configuration/output-deser-fn response-describe-endpoint-response, :http.request.spec/error-spec {"InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef describe-endpoint :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/describe-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-endpoint-response))

(clojure.core/defn list-ota-updates "Lists OTA updates." ([] (list-ota-updates {})) ([list-ota-updates-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-ota-updates-request list-ota-updates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-ota-updates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-ota-updates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListOTAUpdates", :http.request.configuration/output-deser-fn response-list-ota-updates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-ota-updates :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-ota-updates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-ota-updates-response))

(clojure.core/defn register-certificate "Registers a device certificate with AWS IoT. If you have more than one CA\ncertificate that has the same subject field, you must specify the CA certificate\nthat was used to sign the device certificate being registered." ([register-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-register-certificate-request register-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/register-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificate/register", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/register-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterCertificate", :http.request.configuration/output-deser-fn response-register-certificate-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "CertificateStateException" :portkey.aws.iot.-2015-05-28/certificate-state-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "CertificateValidationException" :portkey.aws.iot.-2015-05-28/certificate-validation-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "CertificateConflictException" :portkey.aws.iot.-2015-05-28/certificate-conflict-exception}})))))
(clojure.spec.alpha/fdef register-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/register-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/register-certificate-response))

(clojure.core/defn list-job-executions-for-job "Lists the job executions for a job." ([list-job-executions-for-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-job-executions-for-job-request list-job-executions-for-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-job-executions-for-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-job-executions-for-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListJobExecutionsForJob", :http.request.configuration/output-deser-fn response-list-job-executions-for-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-job-executions-for-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-job-executions-for-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-job-executions-for-job-response))

(clojure.core/defn describe-thing-group "Describe a thing group." ([describe-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-thing-group-request describe-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThingGroup", :http.request.configuration/output-deser-fn response-describe-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-thing-group-response))

(clojure.core/defn list-security-profiles-for-target "Lists the Device Defender security profiles attached to a target (thing group)." ([list-security-profiles-for-target-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-security-profiles-for-target-request list-security-profiles-for-target-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-security-profiles-for-target-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles-for-target", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-security-profiles-for-target-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListSecurityProfilesForTarget", :http.request.configuration/output-deser-fn response-list-security-profiles-for-target-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-security-profiles-for-target :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-security-profiles-for-target-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-security-profiles-for-target-response))

(clojure.core/defn list-job-executions-for-thing "Lists the job executions for the specified thing." ([list-job-executions-for-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-job-executions-for-thing-request list-job-executions-for-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-job-executions-for-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-job-executions-for-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListJobExecutionsForThing", :http.request.configuration/output-deser-fn response-list-job-executions-for-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-job-executions-for-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-job-executions-for-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-job-executions-for-thing-response))

(clojure.core/defn register-thing "Provisions a thing." ([register-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-register-thing-request register-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/register-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/register-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterThing", :http.request.configuration/output-deser-fn response-register-thing-response, :http.request.spec/error-spec {"InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ConflictingResourceUpdateException" :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception, "ResourceRegistrationFailureException" :portkey.aws.iot.-2015-05-28/resource-registration-failure-exception}})))))
(clojure.spec.alpha/fdef register-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/register-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/register-thing-response))

(clojure.core/defn delete-ota-update "Delete an OTA update." ([delete-ota-update-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-ota-update-request delete-ota-update-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-ota-update-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates/{otaUpdateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-ota-update-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteOTAUpdate", :http.request.configuration/output-deser-fn response-delete-ota-update-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception}})))))
(clojure.spec.alpha/fdef delete-ota-update :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-ota-update-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-ota-update-response))

(clojure.core/defn update-stream "Updates an existing stream. The stream version will be incremented by one." ([update-stream-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-stream-request update-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateStream", :http.request.configuration/output-deser-fn response-update-stream-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-stream-response))

(clojure.core/defn update-thing-group "Update a thing group." ([update-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-thing-group-request update-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateThingGroup", :http.request.configuration/output-deser-fn response-update-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-thing-group-response))

(clojure.core/defn describe-index "Describes a search index." ([describe-index-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-index-request describe-index-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-index-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indices/{indexName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-index-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeIndex", :http.request.configuration/output-deser-fn response-describe-index-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-index :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-index-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-index-response))

(clojure.core/defn get-policy "Gets information about the specified policy with the policy document of the\ndefault version." ([get-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-policy-request get-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-policy-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPolicy", :http.request.configuration/output-deser-fn response-get-policy-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef get-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/get-policy-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-policy-response))

(clojure.core/defn cancel-audit-task "Cancels an audit that is in progress. The audit can be either scheduled or\non-demand. If the audit is not in progress, an \"InvalidRequestException\" occurs." ([cancel-audit-task-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-cancel-audit-task-request cancel-audit-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/cancel-audit-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks/{taskId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/cancel-audit-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelAuditTask", :http.request.configuration/output-deser-fn response-cancel-audit-task-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef cancel-audit-task :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/cancel-audit-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cancel-audit-task-response))

(clojure.core/defn delete-security-profile "Deletes a Device Defender security profile." ([delete-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-security-profile-request delete-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSecurityProfile", :http.request.configuration/output-deser-fn response-delete-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception}})))))
(clojure.spec.alpha/fdef delete-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-security-profile-response))

(clojure.core/defn enable-topic-rule "Enables the rule." ([enable-topic-rule-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-enable-topic-rule-request enable-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}/enable", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/enable-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef enable-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/enable-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn deprecate-thing-type "Deprecates a thing type. You can not associate new things with deprecated thing\ntype." ([deprecate-thing-type-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-deprecate-thing-type-request deprecate-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/deprecate-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}/deprecate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/deprecate-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeprecateThingType", :http.request.configuration/output-deser-fn response-deprecate-thing-type-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef deprecate-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/deprecate-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/deprecate-thing-type-response))

(clojure.core/defn list-targets-for-security-profile "Lists the targets (thing groups) associated with a given Device Defender\nsecurity profile." ([list-targets-for-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-targets-for-security-profile-request list-targets-for-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-targets-for-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-targets-for-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTargetsForSecurityProfile", :http.request.configuration/output-deser-fn response-list-targets-for-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-targets-for-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-targets-for-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-targets-for-security-profile-response))

(clojure.core/defn delete-thing-type "Deletes the specified thing type. You cannot delete a thing type if it has\nthings associated with it. To delete a thing type, first mark it as deprecated\nby calling DeprecateThingType, then remove any associated things by calling\nUpdateThing to change the thing type on any associated thing, and finally use\nDeleteThingType to delete the thing type." ([delete-thing-type-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-thing-type-request delete-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteThingType", :http.request.configuration/output-deser-fn response-delete-thing-type-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-thing-type-response))

(clojure.core/defn update-dynamic-thing-group "Updates a dynamic thing group." ([update-dynamic-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-dynamic-thing-group-request update-dynamic-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-dynamic-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/dynamic-thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-dynamic-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDynamicThingGroup", :http.request.configuration/output-deser-fn response-update-dynamic-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidQueryException" :portkey.aws.iot.-2015-05-28/invalid-query-exception}})))))
(clojure.spec.alpha/fdef update-dynamic-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-dynamic-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-dynamic-thing-group-response))

(clojure.core/defn list-thing-groups "List the thing groups in your account." ([] (list-thing-groups {})) ([list-thing-groups-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-thing-groups-request list-thing-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-thing-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-thing-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingGroups", :http.request.configuration/output-deser-fn response-list-thing-groups-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-thing-groups :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-thing-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-thing-groups-response))

(clojure.core/defn list-targets-for-policy "List targets for the specified policy." ([list-targets-for-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-targets-for-policy-request list-targets-for-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-targets-for-policy-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policy-targets/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-targets-for-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTargetsForPolicy", :http.request.configuration/output-deser-fn response-list-targets-for-policy-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef list-targets-for-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-targets-for-policy-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-targets-for-policy-response))

(clojure.core/defn replace-topic-rule "Replaces the rule. You must specify all parameters for the new rule. Creating\nrules is an administrator-level action. Any user who has permission to create\nrules will be able to access data processed by the rule." ([replace-topic-rule-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-replace-topic-rule-request replace-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/replace-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"SqlParseException" :portkey.aws.iot.-2015-05-28/sql-parse-exception, "InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef replace-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/replace-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn get-topic-rule "Gets information about the rule." ([get-topic-rule-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-topic-rule-request get-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-topic-rule-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTopicRule", :http.request.configuration/output-deser-fn response-get-topic-rule-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception}})))))
(clojure.spec.alpha/fdef get-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/get-topic-rule-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-topic-rule-response))

(clojure.core/defn attach-security-profile "Associates a Device Defender security profile with a thing group or with this\naccount. Each thing group or account can have up to five security profiles\nassociated with it." ([attach-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-attach-security-profile-request attach-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/attach-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/attach-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachSecurityProfile", :http.request.configuration/output-deser-fn response-attach-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef attach-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/attach-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attach-security-profile-response))

(clojure.core/defn reject-certificate-transfer "Rejects a pending certificate transfer. After AWS IoT rejects a certificate\ntransfer, the certificate status changes from PENDING_TRANSFER to INACTIVE.\n To check for pending certificate transfers, call ListCertificates to enumerate\nyour certificates.\n This operation can only be called by the transfer destination. After it is\ncalled, the certificate will be returned to the source's account in the INACTIVE\nstate." ([reject-certificate-transfer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-reject-certificate-transfer-request reject-certificate-transfer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/reject-certificate-transfer/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/reject-certificate-transfer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RejectCertificateTransfer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot.-2015-05-28/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef reject-certificate-transfer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/reject-certificate-transfer-request) :ret clojure.core/true?)

(clojure.core/defn remove-thing-from-thing-group "Remove the specified thing from the specified group." ([] (remove-thing-from-thing-group {})) ([remove-thing-from-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-remove-thing-from-thing-group-request remove-thing-from-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/remove-thing-from-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/removeThingFromThingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/remove-thing-from-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveThingFromThingGroup", :http.request.configuration/output-deser-fn response-remove-thing-from-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef remove-thing-from-thing-group :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/remove-thing-from-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/remove-thing-from-thing-group-response))

(clojure.core/defn delete-authorizer "Deletes an authorizer." ([delete-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-authorizer-request delete-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAuthorizer", :http.request.configuration/output-deser-fn response-delete-authorizer-response, :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot.-2015-05-28/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-authorizer-response))

(clojure.core/defn delete-thing "Deletes the specified thing. Returns successfully with no error if the deletion\nis successful or you specify a thing that doesn't exist." ([delete-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-thing-request delete-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteThing", :http.request.configuration/output-deser-fn response-delete-thing-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-thing-response))

(clojure.core/defn get-v-2-logging-options "Gets the fine grained logging options." ([] (get-v-2-logging-options {})) ([get-v-2-logging-options-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-v-2-logging-options-request get-v-2-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-v-2-logging-options-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-v-2-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetV2LoggingOptions", :http.request.configuration/output-deser-fn response-get-v-2-logging-options-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "NotConfiguredException" :portkey.aws.iot.-2015-05-28/not-configured-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-v-2-logging-options :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/get-v-2-logging-options-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-v-2-logging-options-response))

(clojure.core/defn list-certificates "Lists the certificates registered in your AWS account.\n The results are paginated with a default page size of 25. You can use the\nreturned marker to retrieve additional results." ([] (list-certificates {})) ([list-certificates-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-certificates-request list-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-certificates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCertificates", :http.request.configuration/output-deser-fn response-list-certificates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-certificates :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-certificates-response))

(clojure.core/defn list-thing-types "Lists the existing thing types." ([] (list-thing-types {})) ([list-thing-types-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-thing-types-request list-thing-types-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-thing-types-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-thing-types-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingTypes", :http.request.configuration/output-deser-fn response-list-thing-types-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-thing-types :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-thing-types-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-thing-types-response))

(clojure.core/defn detach-security-profile "Disassociates a Device Defender security profile from a thing group or from this\naccount." ([detach-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-detach-security-profile-request detach-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/detach-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/detach-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachSecurityProfile", :http.request.configuration/output-deser-fn response-detach-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef detach-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/detach-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/detach-security-profile-response))

(clojure.core/defn describe-thing "Gets information about the specified thing." ([describe-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-thing-request describe-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThing", :http.request.configuration/output-deser-fn response-describe-thing-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-thing-response))

(clojure.core/defn list-policy-principals "Lists the principals associated with the specified policy.\n Note: This API is deprecated. Please use ListTargetsForPolicy instead." ([list-policy-principals-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-policy-principals-request list-policy-principals-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-policy-principals-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policy-principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-policy-principals-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPolicyPrincipals", :http.request.configuration/output-deser-fn response-list-policy-principals-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-policy-principals :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-policy-principals-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-policy-principals-response))

(clojure.core/defn update-security-profile "Updates a Device Defender security profile." ([update-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-security-profile-request update-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateSecurityProfile", :http.request.configuration/output-deser-fn response-update-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-security-profile-response))

(clojure.core/defn validate-security-profile-behaviors "Validates a Device Defender security profile behaviors specification." ([validate-security-profile-behaviors-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-validate-security-profile-behaviors-request validate-security-profile-behaviors-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/validate-security-profile-behaviors-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profile-behaviors/validate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/validate-security-profile-behaviors-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ValidateSecurityProfileBehaviors", :http.request.configuration/output-deser-fn response-validate-security-profile-behaviors-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef validate-security-profile-behaviors :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/validate-security-profile-behaviors-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/validate-security-profile-behaviors-response))

(clojure.core/defn create-scheduled-audit "Creates a scheduled audit that is run at a specified time interval." ([create-scheduled-audit-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-scheduled-audit-request create-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateScheduledAudit", :http.request.configuration/output-deser-fn response-create-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef create-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-scheduled-audit-response))

(clojure.core/defn set-default-policy-version "Sets the specified version of the specified policy as the policy's default\n(operative) version. This action affects all certificates to which the policy is\nattached. To list the principals the policy is attached to, use the\nListPrincipalPolicy API." ([set-default-policy-version-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-set-default-policy-version-request set-default-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version/{policyVersionId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/set-default-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetDefaultPolicyVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef set-default-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/set-default-policy-version-request) :ret clojure.core/true?)

(clojure.core/defn create-policy "Creates an AWS IoT policy.\n The created policy is the default version for the policy. This operation\ncreates a policy version with a version identifier of 1 and sets 1 as the\npolicy's default version." ([create-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-policy-request create-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-policy-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePolicy", :http.request.configuration/output-deser-fn response-create-policy-response, :http.request.spec/error-spec {"ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "MalformedPolicyException" :portkey.aws.iot.-2015-05-28/malformed-policy-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-policy-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-policy-response))

(clojure.core/defn describe-thing-type "Gets information about the specified thing type." ([describe-thing-type-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-thing-type-request describe-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThingType", :http.request.configuration/output-deser-fn response-describe-thing-type-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-thing-type-response))

(clojure.core/defn attach-thing-principal "Attaches the specified principal to the specified thing. A principal can be\nX.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or\nfederated identities." ([attach-thing-principal-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-attach-thing-principal-request attach-thing-principal-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/attach-thing-principal-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/attach-thing-principal-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachThingPrincipal", :http.request.configuration/output-deser-fn response-attach-thing-principal-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef attach-thing-principal :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/attach-thing-principal-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/attach-thing-principal-response))

(clojure.core/defn delete-thing-group "Deletes a thing group." ([delete-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-thing-group-request delete-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteThingGroup", :http.request.configuration/output-deser-fn response-delete-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-thing-group-response))

(clojure.core/defn list-attached-policies "Lists the policies attached to the specified thing group." ([list-attached-policies-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-attached-policies-request list-attached-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-attached-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/attached-policies/{target}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-attached-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAttachedPolicies", :http.request.configuration/output-deser-fn response-list-attached-policies-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef list-attached-policies :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-attached-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-attached-policies-response))

(clojure.core/defn create-keys-and-certificate "Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued\npublic key.\n Note This is the only time AWS IoT issues the private key for this certificate,\nso it is important to keep it in a secure location." ([] (create-keys-and-certificate {})) ([create-keys-and-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-keys-and-certificate-request create-keys-and-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-keys-and-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/keys-and-certificate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-keys-and-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateKeysAndCertificate", :http.request.configuration/output-deser-fn response-create-keys-and-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-keys-and-certificate :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/create-keys-and-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-keys-and-certificate-response))

(clojure.core/defn create-job "Creates a job." ([create-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-job-request create-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateJob", :http.request.configuration/output-deser-fn response-create-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-job-response))

(clojure.core/defn describe-authorizer "Describes an authorizer." ([describe-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-authorizer-request describe-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAuthorizer", :http.request.configuration/output-deser-fn response-describe-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-authorizer-response))

(clojure.core/defn register-ca-certificate "Registers a CA certificate with AWS IoT. This CA certificate can then be used to\nsign device certificates, which can be then registered with AWS IoT. You can\nregister up to 10 CA certificates per AWS account that have the same subject\nfield. This enables you to have up to 10 certificate authorities sign your\ndevice certificates. If you have more than one CA certificate registered, make\nsure you pass the CA certificate when you register your device certificates with\nthe RegisterCertificate API." ([register-ca-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-register-ca-certificate-request register-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/register-ca-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/register-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterCACertificate", :http.request.configuration/output-deser-fn response-register-ca-certificate-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "CertificateValidationException" :portkey.aws.iot.-2015-05-28/certificate-validation-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "RegistrationCodeValidationException" :portkey.aws.iot.-2015-05-28/registration-code-validation-exception}})))))
(clojure.spec.alpha/fdef register-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/register-ca-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/register-ca-certificate-response))

(clojure.core/defn untag-resource "Removes the given tags (metadata) from the resource." ([untag-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/untag-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/untag", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/untag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn response-untag-resource-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/untag-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/untag-resource-response))

(clojure.core/defn delete-job "Deletes a job and its related job executions.\n Deleting a job may take time, depending on the number of job executions created\nfor the job and various other factors. While the job is being deleted, the\nstatus of the job will be shown as \"DELETION_IN_PROGRESS\". Attempting to delete\nor cancel a job whose status is already \"DELETION_IN_PROGRESS\" will result in an\nerror.\n Only 10 jobs may have status \"DELETION_IN_PROGRESS\" at the same time, or a\nLimitExceededException will occur." ([delete-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-job-request delete-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteJob", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InvalidStateTransitionException" :portkey.aws.iot.-2015-05-28/invalid-state-transition-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-job-request) :ret clojure.core/true?)

(clojure.core/defn start-on-demand-audit-task "Starts an on-demand Device Defender audit." ([start-on-demand-audit-task-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-start-on-demand-audit-task-request start-on-demand-audit-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/start-on-demand-audit-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/start-on-demand-audit-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartOnDemandAuditTask", :http.request.configuration/output-deser-fn response-start-on-demand-audit-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef start-on-demand-audit-task :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/start-on-demand-audit-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/start-on-demand-audit-task-response))

(clojure.core/defn describe-event-configurations "Describes event configurations." ([] (describe-event-configurations {})) ([describe-event-configurations-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-event-configurations-request describe-event-configurations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-event-configurations-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/event-configurations", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-event-configurations-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEventConfigurations", :http.request.configuration/output-deser-fn response-describe-event-configurations-response, :http.request.spec/error-spec {"InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef describe-event-configurations :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/describe-event-configurations-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-event-configurations-response))

(clojure.core/defn disable-topic-rule "Disables the rule." ([disable-topic-rule-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-disable-topic-rule-request disable-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}/disable", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/disable-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisableTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef disable-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/disable-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn describe-thing-registration-task "Describes a bulk thing provisioning task." ([describe-thing-registration-task-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-thing-registration-task-request describe-thing-registration-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-thing-registration-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks/{taskId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-thing-registration-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThingRegistrationTask", :http.request.configuration/output-deser-fn response-describe-thing-registration-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-thing-registration-task :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-thing-registration-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-thing-registration-task-response))

(clojure.core/defn list-topic-rules "Lists the rules for the specific topic." ([] (list-topic-rules {})) ([list-topic-rules-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-topic-rules-request list-topic-rules-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-topic-rules-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-topic-rules-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTopicRules", :http.request.configuration/output-deser-fn response-list-topic-rules-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-topic-rules :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-topic-rules-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-topic-rules-response))

(clojure.core/defn list-active-violations "Lists the active violations for a given Device Defender security profile." ([] (list-active-violations {})) ([list-active-violations-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-active-violations-request list-active-violations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-active-violations-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/active-violations", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-active-violations-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListActiveViolations", :http.request.configuration/output-deser-fn response-list-active-violations-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-active-violations :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-active-violations-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-active-violations-response))

(clojure.core/defn update-scheduled-audit "Updates a scheduled audit, including what checks are performed and how often the\naudit takes place." ([update-scheduled-audit-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-scheduled-audit-request update-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateScheduledAudit", :http.request.configuration/output-deser-fn response-update-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-scheduled-audit-response))

(clojure.core/defn detach-principal-policy "Removes the specified policy from the specified certificate.\n Note: This API is deprecated. Please use DetachPolicy instead." ([detach-principal-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-detach-principal-policy-request detach-principal-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principal-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/detach-principal-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachPrincipalPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef detach-principal-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/detach-principal-policy-request) :ret clojure.core/true?)

(clojure.core/defn create-stream "Creates a stream for delivering one or more large files in chunks over MQTT. A\nstream transports data bytes in chunks or blocks packaged as MQTT messages from\na source like S3. You can have one or more files associated with a stream. The\ntotal size of a file associated with the stream cannot exceed more than 2 MB.\nThe stream will be created with version 0. If a stream is created with the same\nstreamID as a stream that existed and was deleted within last 90 days, we will\nresurrect that old stream by incrementing the version by 1." ([create-stream-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-stream-request create-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateStream", :http.request.configuration/output-deser-fn response-create-stream-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-stream-response))

(clojure.core/defn update-ca-certificate "Updates a registered CA certificate." ([update-ca-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-ca-certificate-request update-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateCACertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-ca-certificate-request) :ret clojure.core/true?)

(clojure.core/defn describe-scheduled-audit "Gets information about a scheduled audit." ([describe-scheduled-audit-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-scheduled-audit-request describe-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeScheduledAudit", :http.request.configuration/output-deser-fn response-describe-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-scheduled-audit-response))

(clojure.core/defn describe-security-profile "Gets information about a Device Defender security profile." ([describe-security-profile-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-security-profile-request describe-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSecurityProfile", :http.request.configuration/output-deser-fn response-describe-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-security-profile-response))

(clojure.core/defn describe-billing-group "Returns information about a billing group." ([describe-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-billing-group-request describe-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeBillingGroup", :http.request.configuration/output-deser-fn response-describe-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-billing-group-response))

(clojure.core/defn delete-topic-rule "Deletes the rule." ([delete-topic-rule-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-topic-rule-request delete-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot.-2015-05-28/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef delete-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn describe-stream "Gets information about a stream." ([describe-stream-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-stream-request describe-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeStream", :http.request.configuration/output-deser-fn response-describe-stream-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-stream-response))

(clojure.core/defn describe-certificate "Gets information about the specified certificate." ([describe-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-certificate-request describe-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeCertificate", :http.request.configuration/output-deser-fn response-describe-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-certificate-response))

(clojure.core/defn delete-dynamic-thing-group "Deletes a dynamic thing group." ([delete-dynamic-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-dynamic-thing-group-request delete-dynamic-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/delete-dynamic-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/dynamic-thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-dynamic-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDynamicThingGroup", :http.request.configuration/output-deser-fn response-delete-dynamic-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-dynamic-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-dynamic-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/delete-dynamic-thing-group-response))

(clojure.core/defn update-job "Updates supported fields of the specified job." ([update-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-job-request update-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateJob", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-job-request) :ret clojure.core/true?)

(clojure.core/defn set-logging-options "Sets the logging options.\n NOTE: use of this command is not recommended. Use SetV2LoggingOptions instead." ([set-logging-options-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-set-logging-options-request set-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/loggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/set-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetLoggingOptions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef set-logging-options :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/set-logging-options-request) :ret clojure.core/true?)

(clojure.core/defn test-authorization "Tests if a specified principal is authorized to perform an AWS IoT action on a\nspecified resource. Use this to test and debug the authorization behavior of\ndevices that connect to the AWS IoT device gateway." ([test-authorization-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-test-authorization-request test-authorization-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/test-authorization-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/test-authorization", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/test-authorization-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestAuthorization", :http.request.configuration/output-deser-fn response-test-authorization-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef test-authorization :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/test-authorization-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/test-authorization-response))

(clojure.core/defn describe-default-authorizer "Describes the default authorizer." ([] (describe-default-authorizer {})) ([describe-default-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-default-authorizer-request describe-default-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-default-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/default-authorizer", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-default-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDefaultAuthorizer", :http.request.configuration/output-deser-fn response-describe-default-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-default-authorizer :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/describe-default-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-default-authorizer-response))

(clojure.core/defn attach-policy "Attaches a policy to the specified target." ([attach-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-attach-policy-request attach-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/target-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/attach-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef attach-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/attach-policy-request) :ret clojure.core/true?)

(clojure.core/defn add-thing-to-billing-group "Adds a thing to a billing group." ([] (add-thing-to-billing-group {})) ([add-thing-to-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-add-thing-to-billing-group-request add-thing-to-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/add-thing-to-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/addThingToBillingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/add-thing-to-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddThingToBillingGroup", :http.request.configuration/output-deser-fn response-add-thing-to-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef add-thing-to-billing-group :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/add-thing-to-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/add-thing-to-billing-group-response))

(clojure.core/defn describe-job-execution "Describes a job execution." ([describe-job-execution-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-job-execution-request describe-job-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-job-execution-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-job-execution-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeJobExecution", :http.request.configuration/output-deser-fn response-describe-job-execution-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-job-execution :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-job-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-job-execution-response))

(clojure.core/defn update-thing-groups-for-thing "Updates the groups to which the thing belongs." ([] (update-thing-groups-for-thing {})) ([update-thing-groups-for-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-thing-groups-for-thing-request update-thing-groups-for-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-thing-groups-for-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/updateThingGroupsForThing", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-thing-groups-for-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateThingGroupsForThing", :http.request.configuration/output-deser-fn response-update-thing-groups-for-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-thing-groups-for-thing :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/update-thing-groups-for-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-thing-groups-for-thing-response))

(clojure.core/defn list-thing-principals "Lists the principals associated with the specified thing. A principal can be\nX.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or\nfederated identities." ([list-thing-principals-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-thing-principals-request list-thing-principals-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-thing-principals-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-thing-principals-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingPrincipals", :http.request.configuration/output-deser-fn response-list-thing-principals-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-thing-principals :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-thing-principals-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-thing-principals-response))

(clojure.core/defn stop-thing-registration-task "Cancels a bulk thing provisioning task." ([stop-thing-registration-task-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-stop-thing-registration-task-request stop-thing-registration-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/stop-thing-registration-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks/{taskId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/stop-thing-registration-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopThingRegistrationTask", :http.request.configuration/output-deser-fn response-stop-thing-registration-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef stop-thing-registration-task :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/stop-thing-registration-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/stop-thing-registration-task-response))

(clojure.core/defn list-principal-policies "Lists the policies attached to the specified principal. If you use an Cognito\nidentity, the ID must be in AmazonCognito Identity format\n(https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax).\n Note: This API is deprecated. Please use ListAttachedPolicies instead." ([list-principal-policies-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-principal-policies-request list-principal-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-principal-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principal-policies", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-principal-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPrincipalPolicies", :http.request.configuration/output-deser-fn response-list-principal-policies-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-principal-policies :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-principal-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-principal-policies-response))

(clojure.core/defn describe-role-alias "Describes a role alias." ([describe-role-alias-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-role-alias-request describe-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/describe-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/describe-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRoleAlias", :http.request.configuration/output-deser-fn response-describe-role-alias-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/describe-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/describe-role-alias-response))

(clojure.core/defn list-things-in-billing-group "Lists the things you have added to the given billing group." ([list-things-in-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-things-in-billing-group-request list-things-in-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-things-in-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-things-in-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingsInBillingGroup", :http.request.configuration/output-deser-fn response-list-things-in-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception}})))))
(clojure.spec.alpha/fdef list-things-in-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-things-in-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-things-in-billing-group-response))

(clojure.core/defn transfer-certificate "Transfers the specified certificate to the specified AWS account.\n You can cancel the transfer until it is acknowledged by the recipient.\n No notification is sent to the transfer destination's account. It is up to the\ncaller to notify the transfer target.\n The certificate being transferred must not be in the ACTIVE state. You can use\nthe UpdateCertificate API to deactivate it.\n The certificate must not have any policies attached to it. You can use the\nDetachPrincipalPolicy API to detach them." ([transfer-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-transfer-certificate-request transfer-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/transfer-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/transfer-certificate/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/transfer-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TransferCertificate", :http.request.configuration/output-deser-fn response-transfer-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "CertificateStateException" :portkey.aws.iot.-2015-05-28/certificate-state-exception, "TransferConflictException" :portkey.aws.iot.-2015-05-28/transfer-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef transfer-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/transfer-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/transfer-certificate-response))

(clojure.core/defn list-audit-tasks "Lists the Device Defender audits that have been performed during a given time\nperiod." ([list-audit-tasks-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-audit-tasks-request list-audit-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-audit-tasks-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-audit-tasks-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAuditTasks", :http.request.configuration/output-deser-fn response-list-audit-tasks-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-audit-tasks :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-audit-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-audit-tasks-response))

(clojure.core/defn delete-policy "Deletes the specified policy.\n A policy cannot be deleted if it has non-default versions or it is attached to\nany certificate.\n To delete a policy, use the DeletePolicyVersion API to delete all non-default\nversions of the policy; use the DetachPrincipalPolicy API to detach the policy\nfrom any certificate; and then use the DeletePolicy API to delete the policy.\n When a policy is deleted using DeletePolicy, its default version is deleted\nwith it." ([delete-policy-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-policy-request delete-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot.-2015-05-28/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-policy-request) :ret clojure.core/true?)

(clojure.core/defn update-thing "Updates the data for a thing." ([update-thing-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-thing-request update-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/update-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateThing", :http.request.configuration/output-deser-fn response-update-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "VersionConflictException" :portkey.aws.iot.-2015-05-28/version-conflict-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/update-thing-response))

(clojure.core/defn delete-certificate "Deletes the specified certificate.\n A certificate cannot be deleted if it has a policy attached to it or if its\nstatus is set to ACTIVE. To delete a certificate, first use the\nDetachPrincipalPolicy API to detach all policies. Next, use the\nUpdateCertificate API to set the certificate to the INACTIVE status." ([delete-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-certificate-request delete-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/delete-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"CertificateStateException" :portkey.aws.iot.-2015-05-28/certificate-state-exception, "DeleteConflictException" :portkey.aws.iot.-2015-05-28/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/delete-certificate-request) :ret clojure.core/true?)

(clojure.core/defn get-logging-options "Gets the logging options.\n NOTE: use of this command is not recommended. Use GetV2LoggingOptions instead." ([] (get-logging-options {})) ([get-logging-options-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-logging-options-request get-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-logging-options-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/loggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLoggingOptions", :http.request.configuration/output-deser-fn response-get-logging-options-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot.-2015-05-28/internal-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-logging-options :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/get-logging-options-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-logging-options-response))

(clojure.core/defn create-thing-group "Create a thing group.\n This is a control plane operation. See Authorization\n(https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html) for\ninformation about authorizing control plane actions." ([create-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-thing-group-request create-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateThingGroup", :http.request.configuration/output-deser-fn response-create-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-thing-group-response))

(clojure.core/defn remove-thing-from-billing-group "Removes the given thing from the billing group." ([] (remove-thing-from-billing-group {})) ([remove-thing-from-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-remove-thing-from-billing-group-request remove-thing-from-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/remove-thing-from-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/removeThingFromBillingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/remove-thing-from-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveThingFromBillingGroup", :http.request.configuration/output-deser-fn response-remove-thing-from-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef remove-thing-from-billing-group :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/remove-thing-from-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/remove-thing-from-billing-group-response))

(clojure.core/defn clear-default-authorizer "Clears the default authorizer." ([] (clear-default-authorizer {})) ([clear-default-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-clear-default-authorizer-request clear-default-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/clear-default-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/default-authorizer", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/clear-default-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ClearDefaultAuthorizer", :http.request.configuration/output-deser-fn response-clear-default-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef clear-default-authorizer :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/clear-default-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/clear-default-authorizer-response))

(clojure.core/defn create-billing-group "Creates a billing group." ([create-billing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-billing-group-request create-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBillingGroup", :http.request.configuration/output-deser-fn response-create-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-billing-group-response))

(clojure.core/defn add-thing-to-thing-group "Adds a thing to a thing group." ([] (add-thing-to-thing-group {})) ([add-thing-to-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-add-thing-to-thing-group-request add-thing-to-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/add-thing-to-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/addThingToThingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/add-thing-to-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddThingToThingGroup", :http.request.configuration/output-deser-fn response-add-thing-to-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef add-thing-to-thing-group :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/add-thing-to-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/add-thing-to-thing-group-response))

(clojure.core/defn get-effective-policies "Gets a list of the policies that have an effect on the authorization behavior of\nthe specified device when it connects to the AWS IoT device gateway." ([] (get-effective-policies {})) ([get-effective-policies-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-effective-policies-request get-effective-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/get-effective-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/effective-policies", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/get-effective-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetEffectivePolicies", :http.request.configuration/output-deser-fn response-get-effective-policies-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "LimitExceededException" :portkey.aws.iot.-2015-05-28/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef get-effective-policies :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/get-effective-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/get-effective-policies-response))

(clojure.core/defn list-things-in-thing-group "Lists the things in the specified group." ([list-things-in-thing-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-things-in-thing-group-request list-things-in-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-things-in-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-things-in-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingsInThingGroup", :http.request.configuration/output-deser-fn response-list-things-in-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-things-in-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/list-things-in-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-things-in-thing-group-response))

(clojure.core/defn create-thing-type "Creates a new thing type." ([create-thing-type-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-thing-type-request create-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateThingType", :http.request.configuration/output-deser-fn response-create-thing-type-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception}})))))
(clojure.spec.alpha/fdef create-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-thing-type-response))

(clojure.core/defn set-default-authorizer "Sets the default authorizer. This will be used if a websocket connection is made\nwithout specifying an authorizer." ([set-default-authorizer-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-set-default-authorizer-request set-default-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/set-default-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/default-authorizer", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/set-default-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetDefaultAuthorizer", :http.request.configuration/output-deser-fn response-set-default-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot.-2015-05-28/resource-already-exists-exception}})))))
(clojure.spec.alpha/fdef set-default-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/set-default-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/set-default-authorizer-response))

(clojure.core/defn update-certificate "Updates the status of the specified certificate. This operation is idempotent.\n Moving a certificate from the ACTIVE state (including REVOKED) will not\ndisconnect currently connected devices, but these devices will be unable to\nreconnect.\n The ACTIVE state is required to authenticate devices connecting to AWS IoT\nusing a certificate." ([update-certificate-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-certificate-request update-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/update-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "CertificateStateException" :portkey.aws.iot.-2015-05-28/certificate-state-exception, "InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/update-certificate-request) :ret clojure.core/true?)

(clojure.core/defn create-certificate-from-csr "Creates an X.509 certificate using the specified certificate signing request.\n Note: The CSR must include a public key that is either an RSA key with a length\nof at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves.\n Note: Reusing the same certificate signing request (CSR) results in a distinct\ncertificate.\n You can create multiple certificates in a batch by creating a directory,\ncopying multiple .csr files into that directory, and then specifying that\ndirectory on the command line. The following commands show how to create a batch\nof certificates given a batch of CSRs.\n Assuming a set of CSRs are located inside of the directory my-csr-directory:\n On Linux and OS X, the command is:\n $ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr\n--certificate-signing-request file://my-csr-directory/{}\n This command lists all of the CSRs in my-csr-directory and pipes each CSR file\nname to the aws iot create-certificate-from-csr AWS CLI command to create a\ncertificate for the corresponding CSR.\n The aws iot create-certificate-from-csr part of the command can also be run in\nparallel to speed up the certificate creation process:\n $ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr\n--certificate-signing-request file://my-csr-directory/{}\n On Windows PowerShell, the command to create certificates for all CSRs in\nmy-csr-directory is:\n > ls -Name my-csr-directory | %{aws iot create-certificate-from-csr\n--certificate-signing-request file://my-csr-directory/$_}\n On a Windows command prompt, the command to create certificates for all CSRs in\nmy-csr-directory is:\n > forfiles /p my-csr-directory /c \"cmd /c aws iot create-certificate-from-csr\n--certificate-signing-request file://@path\"" ([create-certificate-from-csr-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-certificate-from-csr-request create-certificate-from-csr-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/create-certificate-from-csr-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/create-certificate-from-csr-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCertificateFromCsr", :http.request.configuration/output-deser-fn response-create-certificate-from-csr-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-certificate-from-csr :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/create-certificate-from-csr-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/create-certificate-from-csr-response))

(clojure.core/defn list-jobs "Lists jobs." ([] (list-jobs {})) ([list-jobs-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-jobs-request list-jobs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-jobs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-jobs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListJobs", :http.request.configuration/output-deser-fn response-list-jobs-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-jobs :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-jobs-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-jobs-response))

(clojure.core/defn list-things "Lists your things. Use the attributeName and attributeValue parameters to filter\nyour things. For example, calling ListThings with attributeName=Color and\nattributeValue=Red retrieves all things in the registry that contain an\nattribute Color with the value Red." ([] (list-things {})) ([list-things-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-things-request list-things-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/list-things-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/list-things-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThings", :http.request.configuration/output-deser-fn response-list-things-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "UnauthorizedException" :portkey.aws.iot.-2015-05-28/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot.-2015-05-28/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-things :args (clojure.spec.alpha/? :portkey.aws.iot.-2015-05-28/list-things-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/list-things-response))

(clojure.core/defn cancel-job "Cancels a job." ([cancel-job-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-cancel-job-request cancel-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.iot.-2015-05-28/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot.-2015-05-28/cancel-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot.-2015-05-28/cancel-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelJob", :http.request.configuration/output-deser-fn response-cancel-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot.-2015-05-28/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot.-2015-05-28/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot.-2015-05-28/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot.-2015-05-28/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef cancel-job :args (clojure.spec.alpha/tuple :portkey.aws.iot.-2015-05-28/cancel-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot.-2015-05-28/cancel-job-response))
