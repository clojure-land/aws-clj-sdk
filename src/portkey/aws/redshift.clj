(ns portkey.aws.redshift (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope {:service "redshift", :region "ap-northeast-1"},
    :ssl-common-name "redshift.ap-northeast-1.amazonaws.com",
    :endpoint "https://redshift.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "redshift", :region "eu-west-1"},
    :ssl-common-name "redshift.eu-west-1.amazonaws.com",
    :endpoint "https://redshift.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "redshift", :region "us-east-2"},
    :ssl-common-name "redshift.us-east-2.amazonaws.com",
    :endpoint "https://redshift.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "redshift", :region "ap-southeast-2"},
    :ssl-common-name "redshift.ap-southeast-2.amazonaws.com",
    :endpoint "https://redshift.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "redshift", :region "cn-north-1"},
    :ssl-common-name "redshift.cn-north-1.amazonaws.com.cn",
    :endpoint "https://redshift.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "redshift", :region "sa-east-1"},
    :ssl-common-name "redshift.sa-east-1.amazonaws.com",
    :endpoint "https://redshift.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "redshift", :region "ap-southeast-1"},
    :ssl-common-name "redshift.ap-southeast-1.amazonaws.com",
    :endpoint "https://redshift.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "redshift", :region "cn-northwest-1"},
    :ssl-common-name "redshift.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://redshift.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "redshift", :region "ap-northeast-2"},
    :ssl-common-name "redshift.ap-northeast-2.amazonaws.com",
    :endpoint "https://redshift.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "redshift", :region "eu-west-3"},
    :ssl-common-name "redshift.eu-west-3.amazonaws.com",
    :endpoint "https://redshift.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "redshift", :region "ca-central-1"},
    :ssl-common-name "redshift.ca-central-1.amazonaws.com",
    :endpoint "https://redshift.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "redshift", :region "eu-central-1"},
    :ssl-common-name "redshift.eu-central-1.amazonaws.com",
    :endpoint "https://redshift.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "redshift", :region "eu-west-2"},
    :ssl-common-name "redshift.eu-west-2.amazonaws.com",
    :endpoint "https://redshift.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "redshift", :region "us-gov-west-1"},
    :ssl-common-name "redshift.us-gov-west-1.amazonaws.com",
    :endpoint "https://redshift.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "redshift", :region "us-west-2"},
    :ssl-common-name "redshift.us-west-2.amazonaws.com",
    :endpoint "https://redshift.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "redshift", :region "us-east-1"},
    :ssl-common-name "redshift.us-east-1.amazonaws.com",
    :endpoint "https://redshift.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "redshift", :region "us-west-1"},
    :ssl-common-name "redshift.us-west-1.amazonaws.com",
    :endpoint "https://redshift.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "redshift", :region "ap-south-1"},
    :ssl-common-name "redshift.ap-south-1.amazonaws.com",
    :endpoint "https://redshift.ap-south-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-subnet-identifier-list)

(clojure.core/declare ser-parameters-list)

(clojure.core/declare ser-tag-value-list)

(clojure.core/declare ser-source-ids-list)

(clojure.core/declare ser-parameter-apply-type)

(clojure.core/declare ser-source-type)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-iam-role-arn-list)

(clojure.core/declare ser-string)

(clojure.core/declare ser-parameter)

(clojure.core/declare ser-vpc-security-group-id-list)

(clojure.core/declare ser-t-stamp)

(clojure.core/declare ser-event-categories-list)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-boolean-optional)

(clojure.core/declare ser-cluster-security-group-name-list)

(clojure.core/declare ser-db-group-list)

(clojure.core/declare ser-integer-optional)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-subnet-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SubnetIdentifier"}))) input), :shape "SubnetIdentifierList", :type "list"})

(clojure.core/defn- ser-parameters-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter coll) #:http.request.field{:shape "Parameter", :location-name "Parameter"}))) input), :shape "ParametersList", :type "list"})

(clojure.core/defn- ser-tag-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "TagValue"}))) input), :shape "TagValueList", :type "list"})

(clojure.core/defn- ser-source-ids-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SourceId"}))) input), :shape "SourceIdsList", :type "list"})

(clojure.core/defn- ser-parameter-apply-type [input] #:http.request.field{:value (clojure.core/get {"static" "static", :static "static", "dynamic" "dynamic", :dynamic "dynamic"} input), :shape "ParameterApplyType"})

(clojure.core/defn- ser-source-type [input] #:http.request.field{:value (clojure.core/get {"cluster" "cluster", :cluster "cluster", "cluster-parameter-group" "cluster-parameter-group", :clusterparametergroup "cluster-parameter-group", "cluster-security-group" "cluster-security-group", :clustersecuritygroup "cluster-security-group", "cluster-snapshot" "cluster-snapshot", :clustersnapshot "cluster-snapshot"} input), :shape "SourceType"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag", :location-name "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "TagKey"}))) input), :shape "TagKeyList", :type "list"})

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-iam-role-arn-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "IamRoleArn"}))) input), :shape "IamRoleArnList", :type "list"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Parameter", :type "structure"} (clojure.core/contains? input :data-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :data-type)) #:http.request.field{:name "DataType", :shape "String"})) (clojure.core/contains? input :parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-name)) #:http.request.field{:name "ParameterName", :shape "String"})) (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :minimum-engine-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :minimum-engine-version)) #:http.request.field{:name "MinimumEngineVersion", :shape "String"})) (clojure.core/contains? input :allowed-values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :allowed-values)) #:http.request.field{:name "AllowedValues", :shape "String"})) (clojure.core/contains? input :apply-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-apply-type (input :apply-type)) #:http.request.field{:name "ApplyType", :shape "ParameterApplyType"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :is-modifiable) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :is-modifiable)) #:http.request.field{:name "IsModifiable", :shape "Boolean"})) (clojure.core/contains? input :parameter-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-value)) #:http.request.field{:name "ParameterValue", :shape "String"}))))

(clojure.core/defn- ser-vpc-security-group-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpcSecurityGroupId"}))) input), :shape "VpcSecurityGroupIdList", :type "list"})

(clojure.core/defn- ser-t-stamp [input] #:http.request.field{:value input, :shape "TStamp"})

(clojure.core/defn- ser-event-categories-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "EventCategory"}))) input), :shape "EventCategoriesList", :type "list"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String"}))))

(clojure.core/defn- ser-boolean-optional [input] #:http.request.field{:value input, :shape "BooleanOptional"})

(clojure.core/defn- ser-cluster-security-group-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ClusterSecurityGroupName"}))) input), :shape "ClusterSecurityGroupNameList", :type "list"})

(clojure.core/defn- ser-db-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "DbGroup"}))) input), :shape "DbGroupList", :type "list"})

(clojure.core/defn- ser-integer-optional [input] #:http.request.field{:value input, :shape "IntegerOptional"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-describe-table-restore-status-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :table-restore-request-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :table-restore-request-id)) #:http.request.field{:name "TableRestoreRequestId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"}) (clojure.core/into (ser-string (input :master-username)) #:http.request.field{:name "MasterUsername", :shape "String"}) (clojure.core/into (ser-string (input :master-user-password)) #:http.request.field{:name "MasterUserPassword", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "BooleanOptional"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :number-of-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :db-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :db-name)) #:http.request.field{:name "DBName", :shape "String"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :iam-roles)) #:http.request.field{:name "IamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-enable-logging-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :bucket-name)) #:http.request.field{:name "BucketName", :shape "String"})]} (clojure.core/contains? input :s-3-key-prefix) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-key-prefix)) #:http.request.field{:name "S3KeyPrefix", :shape "String"}))))

(clojure.core/defn- req-describe-hsm-client-certificates-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-resize-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-integer (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "Integer"})]} (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :classic) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :classic)) #:http.request.field{:name "Classic", :shape "BooleanOptional"}))))

(clojure.core/defn- req-enable-snapshot-copy-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :destination-region)) #:http.request.field{:name "DestinationRegion", :shape "String"})]} (clojure.core/contains? input :retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :retention-period)) #:http.request.field{:name "RetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :snapshot-copy-grant-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"}))))

(clojure.core/defn- req-describe-clusters-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-revoke-snapshot-access-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :account-with-restore-access)) #:http.request.field{:name "AccountWithRestoreAccess", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-event-subscriptions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :subscription-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-restore-from-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :owner-account) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :owner-account)) #:http.request.field{:name "OwnerAccount", :shape "String"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :iam-roles)) #:http.request.field{:name "IamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-hsm-configurations-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-describe-cluster-parameter-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-db-revision-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :revision-target)) #:http.request.field{:name "RevisionTarget", :shape "String"})]}))

(clojure.core/defn- req-authorize-cluster-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]} (clojure.core/contains? input :cidrip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidrip)) #:http.request.field{:name "CIDRIP", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"}))))

(clojure.core/defn- req-describe-resize-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-cluster-db-revisions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-default-cluster-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-family)) #:http.request.field{:name "ParameterGroupFamily", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-modify-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}))))

(clojure.core/defn- req-disable-logging-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-reserved-node-offerings-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-node-offering-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-node-offering-id)) #:http.request.field{:name "ReservedNodeOfferingId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-accept-reserved-node-exchange-input-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"}) (clojure.core/into (ser-string (input :target-reserved-node-offering-id)) #:http.request.field{:name "TargetReservedNodeOfferingId", :shape "String"})]}))

(clojure.core/defn- req-describe-events-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-identifier)) #:http.request.field{:name "SourceIdentifier", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-type (input :source-type)) #:http.request.field{:name "SourceType", :shape "SourceType"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration)) #:http.request.field{:name "Duration", :shape "IntegerOptional"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-revoke-cluster-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]} (clojure.core/contains? input :cidrip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidrip)) #:http.request.field{:name "CIDRIP", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"}))))

(clojure.core/defn- req-disable-snapshot-copy-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-delete-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})]}))

(clojure.core/defn- req-describe-cluster-security-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"}) (clojure.core/into (ser-parameters-list (input :parameters)) #:http.request.field{:name "Parameters", :shape "ParametersList"})]}))

(clojure.core/defn- req-create-tags-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})]}))

(clojure.core/defn- req-describe-cluster-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]} (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-tags-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :resource-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"})) (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-describe-cluster-snapshots-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"})) (clojure.core/contains? input :snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :owner-account) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :owner-account)) #:http.request.field{:name "OwnerAccount", :shape "String"})) (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :snapshot-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-type)) #:http.request.field{:name "SnapshotType", :shape "String"})) (clojure.core/contains? input :cluster-exists) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :cluster-exists)) #:http.request.field{:name "ClusterExists", :shape "BooleanOptional"}))))

(clojure.core/defn- req-describe-logging-status-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-delete-snapshot-copy-grant-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-cluster-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-reserved-nodes-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-node-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-modify-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "BooleanOptional"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :number-of-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :master-user-password) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :master-user-password)) #:http.request.field{:name "MasterUserPassword", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :new-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :new-cluster-identifier)) #:http.request.field{:name "NewClusterIdentifier", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-snapshot-copy-grants-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :snapshot-copy-grant-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-delete-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :skip-final-cluster-snapshot) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :skip-final-cluster-snapshot)) #:http.request.field{:name "SkipFinalClusterSnapshot", :shape "Boolean"})) (clojure.core/contains? input :final-cluster-snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :final-cluster-snapshot-identifier)) #:http.request.field{:name "FinalClusterSnapshotIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-cluster-tracks-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-reboot-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"}) (clojure.core/into (ser-string (input :sns-topic-arn)) #:http.request.field{:name "SnsTopicArn", :shape "String"})]} (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"})) (clojure.core/contains? input :source-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-ids-list (input :source-ids)) #:http.request.field{:name "SourceIds", :shape "SourceIdsList"})) (clojure.core/contains? input :event-categories) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-categories-list (input :event-categories)) #:http.request.field{:name "EventCategories", :shape "EventCategoriesList"})) (clojure.core/contains? input :severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :severity)) #:http.request.field{:name "Severity", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enabled)) #:http.request.field{:name "Enabled", :shape "BooleanOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-orderable-cluster-options-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-rotate-encryption-key-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"}) (clojure.core/into (ser-string (input :parameter-group-family)) #:http.request.field{:name "ParameterGroupFamily", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-create-hsm-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}) (clojure.core/into (ser-string (input :hsm-ip-address)) #:http.request.field{:name "HsmIpAddress", :shape "String"}) (clojure.core/into (ser-string (input :hsm-partition-name)) #:http.request.field{:name "HsmPartitionName", :shape "String"}) (clojure.core/into (ser-string (input :hsm-partition-password)) #:http.request.field{:name "HsmPartitionPassword", :shape "String"}) (clojure.core/into (ser-string (input :hsm-server-public-certificate)) #:http.request.field{:name "HsmServerPublicCertificate", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-tags-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})]}))

(clojure.core/defn- req-modify-snapshot-copy-retention-period-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-integer (input :retention-period)) #:http.request.field{:name "RetentionPeriod", :shape "Integer"})]}))

(clojure.core/defn- req-delete-hsm-client-certificate-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-event-categories-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"}))))

(clojure.core/defn- req-copy-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :source-snapshot-identifier)) #:http.request.field{:name "SourceSnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :target-snapshot-identifier)) #:http.request.field{:name "TargetSnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :source-snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-snapshot-cluster-identifier)) #:http.request.field{:name "SourceSnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-get-reserved-node-exchange-offerings-input-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-cluster-subnet-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-create-hsm-client-certificate-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-restore-table-from-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :source-database-name)) #:http.request.field{:name "SourceDatabaseName", :shape "String"}) (clojure.core/into (ser-string (input :source-table-name)) #:http.request.field{:name "SourceTableName", :shape "String"}) (clojure.core/into (ser-string (input :new-table-name)) #:http.request.field{:name "NewTableName", :shape "String"})]} (clojure.core/contains? input :source-schema-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-schema-name)) #:http.request.field{:name "SourceSchemaName", :shape "String"})) (clojure.core/contains? input :target-database-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-database-name)) #:http.request.field{:name "TargetDatabaseName", :shape "String"})) (clojure.core/contains? input :target-schema-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-schema-name)) #:http.request.field{:name "TargetSchemaName", :shape "String"}))))

(clojure.core/defn- req-modify-cluster-iam-roles-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :add-iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :add-iam-roles)) #:http.request.field{:name "AddIamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :remove-iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :remove-iam-roles)) #:http.request.field{:name "RemoveIamRoles", :shape "IamRoleArnList"}))))

(clojure.core/defn- req-describe-cluster-versions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-family) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-family)) #:http.request.field{:name "ClusterParameterGroupFamily", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-snapshot-copy-grant-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})]} (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-purchase-reserved-node-offering-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-offering-id)) #:http.request.field{:name "ReservedNodeOfferingId", :shape "String"})]} (clojure.core/contains? input :node-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :node-count)) #:http.request.field{:name "NodeCount", :shape "IntegerOptional"}))))

(clojure.core/defn- req-authorize-snapshot-access-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :account-with-restore-access)) #:http.request.field{:name "AccountWithRestoreAccess", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-reset-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]} (clojure.core/contains? input :reset-all-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reset-all-parameters)) #:http.request.field{:name "ResetAllParameters", :shape "Boolean"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters-list (input :parameters)) #:http.request.field{:name "Parameters", :shape "ParametersList"}))))

(clojure.core/defn- req-delete-hsm-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-get-cluster-credentials-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :db-user)) #:http.request.field{:name "DbUser", :shape "String"}) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :db-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :db-name)) #:http.request.field{:name "DbName", :shape "String"})) (clojure.core/contains? input :duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration-seconds)) #:http.request.field{:name "DurationSeconds", :shape "IntegerOptional"})) (clojure.core/contains? input :auto-create) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-create)) #:http.request.field{:name "AutoCreate", :shape "BooleanOptional"})) (clojure.core/contains? input :db-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-db-group-list (input :db-groups)) #:http.request.field{:name "DbGroups", :shape "DbGroupList"}))))

(clojure.core/defn- req-modify-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})]} (clojure.core/contains? input :sns-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sns-topic-arn)) #:http.request.field{:name "SnsTopicArn", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"})) (clojure.core/contains? input :source-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-ids-list (input :source-ids)) #:http.request.field{:name "SourceIds", :shape "SourceIdsList"})) (clojure.core/contains? input :event-categories) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-categories-list (input :event-categories)) #:http.request.field{:name "EventCategories", :shape "EventCategoriesList"})) (clojure.core/contains? input :severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :severity)) #:http.request.field{:name "Severity", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enabled)) #:http.request.field{:name "Enabled", :shape "BooleanOptional"}))))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/table-restore-request-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-table-restore-status-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-table-restore-status-message/cluster-identifier :portkey.aws.redshift.describe-table-restore-status-message/table-restore-request-id :portkey.aws.redshift.describe-table-restore-status-message/max-records :portkey.aws.redshift.describe-table-restore-status-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/source-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/vpc-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/vpc-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/additional-info (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/master-username (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/port (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-message/cluster-identifier :portkey.aws.redshift.create-cluster-message/node-type :portkey.aws.redshift.create-cluster-message/master-username :portkey.aws.redshift.create-cluster-message/master-user-password] :opt-un [:portkey.aws.redshift.create-cluster-message/enhanced-vpc-routing :portkey.aws.redshift.create-cluster-message/publicly-accessible :portkey.aws.redshift.create-cluster-message/preferred-maintenance-window :portkey.aws.redshift.create-cluster-message/encrypted :portkey.aws.redshift.create-cluster-message/hsm-client-certificate-identifier :portkey.aws.redshift.create-cluster-message/cluster-subnet-group-name :portkey.aws.redshift.create-cluster-message/number-of-nodes :portkey.aws.redshift.create-cluster-message/tags :portkey.aws.redshift.create-cluster-message/db-name :portkey.aws.redshift.create-cluster-message/vpc-security-group-ids :portkey.aws.redshift.create-cluster-message/availability-zone :portkey.aws.redshift.create-cluster-message/cluster-type :portkey.aws.redshift.create-cluster-message/cluster-security-groups :portkey.aws.redshift.create-cluster-message/additional-info :portkey.aws.redshift.create-cluster-message/elastic-ip :portkey.aws.redshift.create-cluster-message/hsm-configuration-identifier :portkey.aws.redshift.create-cluster-message/port :portkey.aws.redshift.create-cluster-message/maintenance-track-name :portkey.aws.redshift.create-cluster-message/kms-key-id :portkey.aws.redshift.create-cluster-message/allow-version-upgrade :portkey.aws.redshift.create-cluster-message/cluster-version :portkey.aws.redshift.create-cluster-message/automated-snapshot-retention-period :portkey.aws.redshift.create-cluster-message/iam-roles :portkey.aws.redshift.create-cluster-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/dependent-service-request-throttling-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot-copy-grant))

(clojure.spec.alpha/def :portkey.aws.redshift/insufficient-cluster-capacity-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subnet-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.enable-logging-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-logging-message/bucket-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-logging-message/s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/enable-logging-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.enable-logging-message/cluster-identifier :portkey.aws.redshift.enable-logging-message/bucket-name] :opt-un [:portkey.aws.redshift.enable-logging-message/s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/hsm-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/hsm-partition-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-configuration/hsm-configuration-identifier :portkey.aws.redshift.hsm-configuration/description :portkey.aws.redshift.hsm-configuration/hsm-ip-address :portkey.aws.redshift.hsm-configuration/hsm-partition-name :portkey.aws.redshift.hsm-configuration/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/avg-resize-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/total-resize-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/resize-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-encryption-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/resize-progress-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.resize-progress-message/avg-resize-rate-in-mega-bytes-per-second :portkey.aws.redshift/import-tables-not-started :portkey.aws.redshift.resize-progress-message/total-resize-data-in-mega-bytes :portkey.aws.redshift.resize-progress-message/target-cluster-type :portkey.aws.redshift.resize-progress-message/progress-in-mega-bytes :portkey.aws.redshift.resize-progress-message/status :portkey.aws.redshift.resize-progress-message/resize-type :portkey.aws.redshift.resize-progress-message/message :portkey.aws.redshift.resize-progress-message/target-node-type :portkey.aws.redshift/import-tables-completed :portkey.aws.redshift/import-tables-in-progress :portkey.aws.redshift.resize-progress-message/target-encryption-type :portkey.aws.redshift.resize-progress-message/estimated-time-to-completion-in-seconds :portkey.aws.redshift.resize-progress-message/target-number-of-nodes :portkey.aws.redshift.resize-progress-message/elapsed-time-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-hsm-client-certificates-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-hsm-client-certificates-message/hsm-client-certificate-identifier :portkey.aws.redshift.describe-hsm-client-certificates-message/max-records :portkey.aws.redshift.describe-hsm-client-certificates-message/marker :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-keys :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.redshift.maintenance-track/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.maintenance-track/database-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.maintenance-track/update-targets (clojure.spec.alpha/and :portkey.aws.redshift/eligible-tracks-to-update-list))
(clojure.spec.alpha/def :portkey.aws.redshift/maintenance-track (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.maintenance-track/maintenance-track-name :portkey.aws.redshift.maintenance-track/database-version :portkey.aws.redshift.maintenance-track/update-targets]))

(clojure.spec.alpha/def :portkey.aws.redshift/parameters-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/parameter))

(clojure.spec.alpha/def :portkey.aws.redshift/ec-2-security-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/ec-2-security-group))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-value-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status-type #{"CANCELED" "IN_PROGRESS" :in-progress :pending "PENDING" :canceled "SUCCEEDED" "FAILED" :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.redshift/import-tables-not-started (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-node/node-role (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-node/private-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-node/public-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-node/node-role :portkey.aws.redshift.cluster-node/private-ip-address :portkey.aws.redshift.cluster-node/public-ip-address]))

(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/classic (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/resize-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.resize-cluster-message/cluster-identifier :portkey.aws.redshift.resize-cluster-message/number-of-nodes] :opt-un [:portkey.aws.redshift.resize-cluster-message/cluster-type :portkey.aws.redshift.resize-cluster-message/node-type :portkey.aws.redshift.resize-cluster-message/classic]))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/currency-code (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/node-count (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/fixed-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/duration (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/usage-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/state (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/recurring-charges (clojure.spec.alpha/and :portkey.aws.redshift/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/offering-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-node/currency-code :portkey.aws.redshift.reserved-node/start-time :portkey.aws.redshift.reserved-node/node-count :portkey.aws.redshift.reserved-node/fixed-price :portkey.aws.redshift/reserved-node-offering-type :portkey.aws.redshift.reserved-node/reserved-node-offering-id :portkey.aws.redshift.reserved-node/duration :portkey.aws.redshift.reserved-node/reserved-node-id :portkey.aws.redshift.reserved-node/usage-price :portkey.aws.redshift.reserved-node/state :portkey.aws.redshift.reserved-node/recurring-charges :portkey.aws.redshift.reserved-node/offering-type :portkey.aws.redshift.reserved-node/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/destination-region (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/enable-snapshot-copy-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.enable-snapshot-copy-message/cluster-identifier :portkey.aws.redshift.enable-snapshot-copy-message/destination-region] :opt-un [:portkey.aws.redshift.enable-snapshot-copy-message/retention-period :portkey.aws.redshift.enable-snapshot-copy-message/snapshot-copy-grant-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-nodes-message/reserved-nodes (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-list))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-nodes-message/marker :portkey.aws.redshift.reserved-nodes-message/reserved-nodes]))

(clojure.spec.alpha/def :portkey.aws.redshift/double-optional clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.redshift/source-ids-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.track-list-message/maintenance-tracks (clojure.spec.alpha/and :portkey.aws.redshift/track-list))
(clojure.spec.alpha/def :portkey.aws.redshift.track-list-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/track-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.track-list-message/maintenance-tracks :portkey.aws.redshift.track-list-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/sns-no-authorization-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offerings-message/reserved-node-offerings (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-offering-list))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-node-offerings-message/marker :portkey.aws.redshift.reserved-node-offerings-message/reserved-node-offerings]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-elastic-ip-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-parameter-status))

(clojure.spec.alpha/def :portkey.aws.redshift/disable-snapshot-copy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/authorize-snapshot-access-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-clusters-message/cluster-identifier :portkey.aws.redshift.describe-clusters-message/max-records :portkey.aws.redshift.describe-clusters-message/marker :portkey.aws.redshift.describe-clusters-message/tag-keys :portkey.aws.redshift.describe-clusters-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.revoke-snapshot-access-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-snapshot-access-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-snapshot-access-message/account-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/revoke-snapshot-access-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.revoke-snapshot-access-message/snapshot-identifier :portkey.aws.redshift.revoke-snapshot-access-message/account-with-restore-access] :opt-un [:portkey.aws.redshift.revoke-snapshot-access-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-event-subscriptions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-event-subscriptions-message/subscription-name :portkey.aws.redshift.describe-event-subscriptions-message/max-records :portkey.aws.redshift.describe-event-subscriptions-message/marker :portkey.aws.redshift.describe-event-subscriptions-message/tag-keys :portkey.aws.redshift.describe-event-subscriptions-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/owner-account (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/additional-info (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/port (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/restore-from-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.restore-from-cluster-snapshot-message/enhanced-vpc-routing :portkey.aws.redshift.restore-from-cluster-snapshot-message/publicly-accessible :portkey.aws.redshift.restore-from-cluster-snapshot-message/preferred-maintenance-window :portkey.aws.redshift.restore-from-cluster-snapshot-message/owner-account :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-client-certificate-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-subnet-group-name :portkey.aws.redshift.restore-from-cluster-snapshot-message/vpc-security-group-ids :portkey.aws.redshift.restore-from-cluster-snapshot-message/availability-zone :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-security-groups :portkey.aws.redshift.restore-from-cluster-snapshot-message/additional-info :portkey.aws.redshift.restore-from-cluster-snapshot-message/elastic-ip :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-configuration-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/port :portkey.aws.redshift.restore-from-cluster-snapshot-message/maintenance-track-name :portkey.aws.redshift.restore-from-cluster-snapshot-message/kms-key-id :portkey.aws.redshift.restore-from-cluster-snapshot-message/allow-version-upgrade :portkey.aws.redshift.restore-from-cluster-snapshot-message/automated-snapshot-retention-period :portkey.aws.redshift.restore-from-cluster-snapshot-message/iam-roles :portkey.aws.redshift.restore-from-cluster-snapshot-message/node-type :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-cluster-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-parameter-group-message/parameter-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.subnet/subnet-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.subnet/subnet-availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/availability-zone))
(clojure.spec.alpha/def :portkey.aws.redshift.subnet/subnet-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/subnet (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.subnet/subnet-identifier :portkey.aws.redshift.subnet/subnet-availability-zone :portkey.aws.redshift.subnet/subnet-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-hsm-configurations-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-hsm-configurations-message/hsm-configuration-identifier :portkey.aws.redshift.describe-hsm-configurations-message/max-records :portkey.aws.redshift.describe-hsm-configurations-message/marker :portkey.aws.redshift.describe-hsm-configurations-message/tag-keys :portkey.aws.redshift.describe-hsm-configurations-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-parameter-groups-message/parameter-group-name :portkey.aws.redshift.describe-cluster-parameter-groups-message/max-records :portkey.aws.redshift.describe-cluster-parameter-groups-message/marker :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-keys :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-db-revision-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-db-revision-message/revision-target (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-db-revision-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-db-revision-message/cluster-identifier :portkey.aws.redshift.modify-cluster-db-revision-message/revision-target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revisions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revisions-message/cluster-db-revisions (clojure.spec.alpha/and :portkey.aws.redshift/cluster-db-revisions-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-db-revisions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-db-revisions-message/marker :portkey.aws.redshift.cluster-db-revisions-message/cluster-db-revisions]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-parameter-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-parameter-group]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-info-map-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event-info-map))

(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cidrip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/authorize-cluster-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cluster-security-group-name] :opt-un [:portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cidrip :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-name :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration-message/hsm-configurations (clojure.spec.alpha/and :portkey.aws.redshift/hsm-configuration-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-configuration-message/marker :portkey.aws.redshift.hsm-configuration-message/hsm-configurations]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-hsm-configuration-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-resize-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-resize-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-resize-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-s-3-bucket-name-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/supported-platforms-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/supported-platform))

(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/customer-aws-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/cust-subscription-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/subscription-creation-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/event-subscription (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-subscription/severity :portkey.aws.redshift/source-ids-list :portkey.aws.redshift.event-subscription/customer-aws-id :portkey.aws.redshift.event-subscription/tags :portkey.aws.redshift.event-subscription/source-type :portkey.aws.redshift.event-subscription/enabled :portkey.aws.redshift.event-subscription/status :portkey.aws.redshift.event-subscription/sns-topic-arn :portkey.aws.redshift/event-categories-list :portkey.aws.redshift.event-subscription/cust-subscription-id :portkey.aws.redshift.event-subscription/subscription-creation-time]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-db-revisions-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-db-revisions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-db-revisions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-db-revisions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-db-revisions-message/cluster-identifier :portkey.aws.redshift.describe-cluster-db-revisions-message/max-records :portkey.aws.redshift.describe-cluster-db-revisions-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/destination-region (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/retention-period (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-copy-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-snapshot-copy-status/destination-region :portkey.aws.redshift.cluster-snapshot-copy-status/retention-period :portkey.aws.redshift.cluster-snapshot-copy-status/snapshot-copy-grant-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-default-cluster-parameters-message/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-default-cluster-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-default-cluster-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-default-cluster-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-default-cluster-parameters-message/parameter-group-family] :opt-un [:portkey.aws.redshift.describe-default-cluster-parameters-message/max-records :portkey.aws.redshift.describe-default-cluster-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/describe-default-cluster-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/default-cluster-parameters]))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-message/snapshots (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-message/marker :portkey.aws.redshift.snapshot-message/snapshots]))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-severity-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-vpc-network-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-subnet-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.redshift/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-subnet-group-message/cluster-subnet-group-name :portkey.aws.redshift.modify-cluster-subnet-group-message/subnet-ids] :opt-un [:portkey.aws.redshift.modify-cluster-subnet-group-message/description]))

(clojure.spec.alpha/def :portkey.aws.redshift.disable-logging-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/disable-logging-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.disable-logging-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-node-offerings-message/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-node-offerings-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-node-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-reserved-node-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-reserved-node-offerings-message/reserved-node-offering-id :portkey.aws.redshift.describe-reserved-node-offerings-message/max-records :portkey.aws.redshift.describe-reserved-node-offerings-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering-type #{:regular :upgradable "Regular" "Upgradable"})

(clojure.spec.alpha/def :portkey.aws.redshift/revoke-cluster-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-table-restore-argument-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.accept-reserved-node-exchange-input-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.accept-reserved-node-exchange-input-message/target-reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/accept-reserved-node-exchange-input-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.accept-reserved-node-exchange-input-message/reserved-node-id :portkey.aws.redshift.accept-reserved-node-exchange-input-message/target-reserved-node-offering-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/orderable-cluster-options-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/orderable-cluster-option))

(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/logging-enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/bucket-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/last-successful-delivery-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/last-failure-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/last-failure-message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/logging-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.logging-status/logging-enabled :portkey.aws.redshift.logging-status/bucket-name :portkey.aws.redshift.logging-status/s-3-key-prefix :portkey.aws.redshift.logging-status/last-successful-delivery-time :portkey.aws.redshift.logging-status/last-failure-time :portkey.aws.redshift.logging-status/last-failure-message]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-security-group-message/marker :portkey.aws.redshift/cluster-security-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/reserved-node-offering))

(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/event-categories-map-list]))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/source-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/end-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/duration (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-events-message/source-identifier :portkey.aws.redshift/source-type :portkey.aws.redshift.describe-events-message/start-time :portkey.aws.redshift.describe-events-message/end-time :portkey.aws.redshift.describe-events-message/duration :portkey.aws.redshift.describe-events-message/max-records :portkey.aws.redshift.describe-events-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/parameter-apply-type #{"dynamic" "static" :static :dynamic})

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/authorization-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/bucket-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/ip-range-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/ip-range))

(clojure.spec.alpha/def :portkey.aws.redshift/copy-to-region-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/sns-topic-arn-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-public-key (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-identifier :portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-public-key :portkey.aws.redshift.hsm-client-certificate/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.events-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.events-message/events (clojure.spec.alpha/and :portkey.aws.redshift/event-list))
(clojure.spec.alpha/def :portkey.aws.redshift/events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.events-message/marker :portkey.aws.redshift.events-message/events]))

(clojure.spec.alpha/def :portkey.aws.redshift/source-type #{:clustersecuritygroup "cluster-parameter-group" "cluster" :cluster :clusterparametergroup :clustersnapshot "cluster-snapshot" "cluster-security-group"})

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/unauthorized-operation (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-category-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.event/source-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event/message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.event/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event/date (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.event/event-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event/source-identifier :portkey.aws.redshift/source-type :portkey.aws.redshift.event/message :portkey.aws.redshift.event/event-categories :portkey.aws.redshift.event/severity :portkey.aws.redshift.event/date :portkey.aws.redshift.event/event-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cidrip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/revoke-cluster-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cluster-security-group-name] :opt-un [:portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cidrip :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-name :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.redshift/rotate-encryption-key-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-hsm-client-certificate-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.disable-snapshot-copy-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/disable-snapshot-copy-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.disable-snapshot-copy-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.accept-reserved-node-exchange-output-message/exchanged-reserved-node (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node))
(clojure.spec.alpha/def :portkey.aws.redshift/accept-reserved-node-exchange-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.accept-reserved-node-exchange-output-message/exchanged-reserved-node]))

(clojure.spec.alpha/def :portkey.aws.redshift/availability-zone-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/availability-zone))

(clojure.spec.alpha/def :portkey.aws.redshift.availability-zone/name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.availability-zone/supported-platforms (clojure.spec.alpha/and :portkey.aws.redshift/supported-platforms-list))
(clojure.spec.alpha/def :portkey.aws.redshift/availability-zone (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.availability-zone/name :portkey.aws.redshift.availability-zone/supported-platforms]))

(clojure.spec.alpha/def :portkey.aws.redshift.event-subscriptions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/event-subscriptions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-subscriptions-message/marker :portkey.aws.redshift/event-subscriptions-list]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-event-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/event-subscription]))

(clojure.spec.alpha/def :portkey.aws.redshift/revision-targets-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/revision-target))

(clojure.spec.alpha/def :portkey.aws.redshift/restore-table-from-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/table-restore-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-event-subscription-message/subscription-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.supported-platform/name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/supported-platform (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.supported-platform/name]))

(clojure.spec.alpha/def :portkey.aws.redshift/sensitive-string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-subscription-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/reserved-node-offerings (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-offering-list))
(clojure.spec.alpha/def :portkey.aws.redshift/get-reserved-node-exchange-offerings-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/marker :portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/reserved-node-offerings]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-security-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-security-groups-message/cluster-security-group-name :portkey.aws.redshift.describe-cluster-security-groups-message/max-records :portkey.aws.redshift.describe-cluster-security-groups-message/marker :portkey.aws.redshift.describe-cluster-security-groups-message/tag-keys :portkey.aws.redshift.describe-cluster-security-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-groups (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-security-group))

(clojure.spec.alpha/def :portkey.aws.redshift.recurring-charge/recurring-charge-amount (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.recurring-charge/recurring-charge-frequency (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/recurring-charge (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.recurring-charge/recurring-charge-amount :portkey.aws.redshift.recurring-charge/recurring-charge-frequency]))

(clojure.spec.alpha/def :portkey.aws.redshift/track-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/maintenance-track))

(clojure.spec.alpha/def :portkey.aws.redshift/resize-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-parameter-group-message/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-parameter-group-message/parameter-group-name :portkey.aws.redshift.modify-cluster-parameter-group-message/parameters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/restore-from-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/authorization-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-tags-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-tags-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-tags-message/resource-name :portkey.aws.redshift.create-tags-message/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/reboot-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/subnet-already-in-use (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group-membership/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-security-group-membership/cluster-security-group-name :portkey.aws.redshift.cluster-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-iam-role/iam-role-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-iam-role/apply-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-iam-role (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-iam-role/iam-role-arn :portkey.aws.redshift.cluster-iam-role/apply-status]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-subnet (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/tag))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-security-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate-message/hsm-client-certificates (clojure.spec.alpha/and :portkey.aws.redshift/hsm-client-certificate-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-client-certificate-message/marker :portkey.aws.redshift.hsm-client-certificate-message/hsm-client-certificates]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/source (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-cluster-parameters-message/parameter-group-name] :opt-un [:portkey.aws.redshift.describe-cluster-parameters-message/source :portkey.aws.redshift.describe-cluster-parameters-message/max-records :portkey.aws.redshift.describe-cluster-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/resource-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-tags-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-tags-message/resource-name :portkey.aws.redshift.describe-tags-message/resource-type :portkey.aws.redshift.describe-tags-message/max-records :portkey.aws.redshift.describe-tags-message/marker :portkey.aws.redshift.describe-tags-message/tag-keys :portkey.aws.redshift.describe-tags-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/end-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/owner-account (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-exists (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-snapshots-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-snapshots-message/tag-keys :portkey.aws.redshift.describe-cluster-snapshots-message/tag-values :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-identifier :portkey.aws.redshift.describe-cluster-snapshots-message/end-time :portkey.aws.redshift.describe-cluster-snapshots-message/start-time :portkey.aws.redshift.describe-cluster-snapshots-message/owner-account :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-identifier :portkey.aws.redshift.describe-cluster-snapshots-message/max-records :portkey.aws.redshift.describe-cluster-snapshots-message/marker :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-type :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-exists]))

(clojure.spec.alpha/def :portkey.aws.redshift/unsupported-option-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-logging-status-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-logging-status-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-logging-status-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-already-exist-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-db-revisions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-db-revision))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-s-3-key-prefix-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-snapshot-copy-grant-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-snapshot-copy-grant-message/snapshot-copy-grant-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-public-key (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/elastic-resize-number-of-node-options (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-parameter-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-status-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/pending-actions (clojure.spec.alpha/and :portkey.aws.redshift/pending-actions-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/master-username (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-create-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-revision-number (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/modify-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/cluster-iam-role-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/vpc-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-nodes (clojure.spec.alpha/and :portkey.aws.redshift/cluster-nodes-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster/cluster-public-key :portkey.aws.redshift.cluster/enhanced-vpc-routing :portkey.aws.redshift.cluster/publicly-accessible :portkey.aws.redshift.cluster/preferred-maintenance-window :portkey.aws.redshift.cluster/encrypted :portkey.aws.redshift.cluster/cluster-identifier :portkey.aws.redshift/cluster-snapshot-copy-status :portkey.aws.redshift.cluster/cluster-subnet-group-name :portkey.aws.redshift.cluster/number-of-nodes :portkey.aws.redshift.cluster/elastic-resize-number-of-node-options :portkey.aws.redshift.cluster/tags :portkey.aws.redshift.cluster/db-name :portkey.aws.redshift.cluster/cluster-parameter-groups :portkey.aws.redshift.cluster/availability-zone :portkey.aws.redshift.cluster/pending-actions :portkey.aws.redshift.cluster/cluster-security-groups :portkey.aws.redshift.cluster/master-username :portkey.aws.redshift.cluster/cluster-status :portkey.aws.redshift.cluster/vpc-id :portkey.aws.redshift.cluster/maintenance-track-name :portkey.aws.redshift.cluster/kms-key-id :portkey.aws.redshift/restore-status :portkey.aws.redshift.cluster/cluster-create-time :portkey.aws.redshift.cluster/cluster-revision-number :portkey.aws.redshift.cluster/allow-version-upgrade :portkey.aws.redshift.cluster/cluster-version :portkey.aws.redshift.cluster/modify-status :portkey.aws.redshift/endpoint :portkey.aws.redshift.cluster/automated-snapshot-retention-period :portkey.aws.redshift.cluster/iam-roles :portkey.aws.redshift.cluster/vpc-security-groups :portkey.aws.redshift.cluster/cluster-nodes :portkey.aws.redshift/hsm-status :portkey.aws.redshift/elastic-ip-status :portkey.aws.redshift.cluster/node-type :portkey.aws.redshift/pending-modified-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/in-progress-table-restore-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/hsm-client-certificate))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-snapshot-copy-grant-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/currency-code (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/fixed-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/duration (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/usage-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/recurring-charges (clojure.spec.alpha/and :portkey.aws.redshift/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/offering-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-node-offering/currency-code :portkey.aws.redshift.reserved-node-offering/fixed-price :portkey.aws.redshift/reserved-node-offering-type :portkey.aws.redshift.reserved-node-offering/reserved-node-offering-id :portkey.aws.redshift.reserved-node-offering/duration :portkey.aws.redshift.reserved-node-offering/usage-price :portkey.aws.redshift.reserved-node-offering/recurring-charges :portkey.aws.redshift.reserved-node-offering/offering-type :portkey.aws.redshift.reserved-node-offering/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-snapshot-message/snapshot-identifier :portkey.aws.redshift.create-cluster-snapshot-message/cluster-identifier] :opt-un [:portkey.aws.redshift.create-cluster-snapshot-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/resize-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-security-group-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-security-group-message/cluster-security-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/accounts-with-restore-access-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/account-with-restore-access))

(clojure.spec.alpha/def :portkey.aws.redshift.vpc-security-group-membership/vpc-security-group-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.vpc-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/vpc-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.vpc-security-group-membership/vpc-security-group-id :portkey.aws.redshift.vpc-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.redshift/authorization-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-nodes-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-nodes-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-reserved-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-reserved-nodes-message/reserved-node-id :portkey.aws.redshift.describe-reserved-nodes-message/max-records :portkey.aws.redshift.describe-reserved-nodes-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-security-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/event-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/event-description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/event-info-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-info-map/event-id :portkey.aws.redshift.event-info-map/event-categories :portkey.aws.redshift.event-info-map/event-description :portkey.aws.redshift.event-info-map/severity]))

(clojure.spec.alpha/def :portkey.aws.redshift.update-target/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.update-target/database-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/update-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.update-target/maintenance-track-name :portkey.aws.redshift.update-target/database-version]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-event-id-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-subnet-group-message/cluster-subnet-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/pending-actions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/insufficient-s-3-bucket-policy-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-credentials/db-user (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-credentials/db-password (clojure.spec.alpha/and :portkey.aws.redshift/sensitive-string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-credentials/expiration (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-credentials (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-credentials/db-user :portkey.aws.redshift.cluster-credentials/db-password :portkey.aws.redshift.cluster-credentials/expiration]))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-snapshot-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-already-enabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/resource-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/ec-2-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.ec-2-security-group/status :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-name :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-owner-id :portkey.aws.redshift.ec-2-security-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.redshift/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-subnet-group-message/cluster-subnet-group-name :portkey.aws.redshift.create-cluster-subnet-group-message/description :portkey.aws.redshift.create-cluster-subnet-group-message/subnet-ids] :opt-un [:portkey.aws.redshift.create-cluster-subnet-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/new-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-message/cluster-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-message/enhanced-vpc-routing :portkey.aws.redshift.modify-cluster-message/publicly-accessible :portkey.aws.redshift.modify-cluster-message/preferred-maintenance-window :portkey.aws.redshift.modify-cluster-message/encrypted :portkey.aws.redshift.modify-cluster-message/hsm-client-certificate-identifier :portkey.aws.redshift.modify-cluster-message/number-of-nodes :portkey.aws.redshift.modify-cluster-message/vpc-security-group-ids :portkey.aws.redshift.modify-cluster-message/cluster-type :portkey.aws.redshift.modify-cluster-message/master-user-password :portkey.aws.redshift.modify-cluster-message/cluster-security-groups :portkey.aws.redshift.modify-cluster-message/elastic-ip :portkey.aws.redshift.modify-cluster-message/hsm-configuration-identifier :portkey.aws.redshift.modify-cluster-message/maintenance-track-name :portkey.aws.redshift.modify-cluster-message/kms-key-id :portkey.aws.redshift.modify-cluster-message/allow-version-upgrade :portkey.aws.redshift.modify-cluster-message/cluster-version :portkey.aws.redshift.modify-cluster-message/automated-snapshot-retention-period :portkey.aws.redshift.modify-cluster-message/new-cluster-identifier :portkey.aws.redshift.modify-cluster-message/node-type :portkey.aws.redshift.modify-cluster-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/copy-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-snapshot-copy-grant-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot-copy-grant]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-already-migrated-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-map-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event-categories-map))

(clojure.spec.alpha/def :portkey.aws.redshift/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift/iam-role-arn-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.parameter/data-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/parameter-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/source (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/minimum-engine-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/allowed-values (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/apply-type (clojure.spec.alpha/and :portkey.aws.redshift/parameter-apply-type))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/is-modifiable (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/parameter-value (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.parameter/data-type :portkey.aws.redshift.parameter/parameter-name :portkey.aws.redshift.parameter/source :portkey.aws.redshift.parameter/minimum-engine-version :portkey.aws.redshift.parameter/allowed-values :portkey.aws.redshift.parameter/apply-type :portkey.aws.redshift.parameter/description :portkey.aws.redshift.parameter/is-modifiable :portkey.aws.redshift.parameter/parameter-value]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-status/parameter-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-status/parameter-apply-error-description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-status/parameter-name :portkey.aws.redshift.cluster-parameter-status/parameter-apply-status :portkey.aws.redshift.cluster-parameter-status/parameter-apply-error-description]))

(clojure.spec.alpha/def :portkey.aws.redshift/vpc-security-group-id-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-status/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group-status/parameter-group-name :portkey.aws.redshift.cluster-parameter-group-status/parameter-apply-status :portkey.aws.redshift/cluster-parameter-status-list]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/current-restore-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/snapshot-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift/restore-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.restore-status/status :portkey.aws.redshift.restore-status/current-restore-rate-in-mega-bytes-per-second :portkey.aws.redshift.restore-status/snapshot-size-in-mega-bytes :portkey.aws.redshift.restore-status/progress-in-mega-bytes :portkey.aws.redshift.restore-status/elapsed-time-in-seconds :portkey.aws.redshift.restore-status/estimated-time-to-completion-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-snapshot-copy-grants-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-snapshot-copy-grants-message/snapshot-copy-grant-name :portkey.aws.redshift.describe-snapshot-copy-grants-message/max-records :portkey.aws.redshift.describe-snapshot-copy-grants-message/marker :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-keys :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/skip-final-cluster-snapshot (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/final-cluster-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-message/cluster-identifier] :opt-un [:portkey.aws.redshift.delete-cluster-message/skip-final-cluster-snapshot :portkey.aws.redshift.delete-cluster-message/final-cluster-snapshot-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-tracks-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-tracks-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-tracks-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-tracks-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-tracks-message/maintenance-track-name :portkey.aws.redshift.describe-cluster-tracks-message/max-records :portkey.aws.redshift.describe-cluster-tracks-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.reboot-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/reboot-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.reboot-cluster-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/incompatible-orderable-options (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/restorable-node-types (clojure.spec.alpha/and :portkey.aws.redshift/restorable-node-type-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-create-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/source-region (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/encrypted-with-hsm (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/owner-account (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/estimated-seconds-to-completion (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/actual-incremental-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/master-username (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/backup-progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/accounts-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift/accounts-with-restore-access-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/port (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/cluster-create-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/current-backup-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/total-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot/snapshot-identifier :portkey.aws.redshift.snapshot/restorable-node-types :portkey.aws.redshift.snapshot/snapshot-create-time :portkey.aws.redshift.snapshot/enhanced-vpc-routing :portkey.aws.redshift.snapshot/source-region :portkey.aws.redshift.snapshot/encrypted-with-hsm :portkey.aws.redshift.snapshot/encrypted :portkey.aws.redshift.snapshot/owner-account :portkey.aws.redshift.snapshot/cluster-identifier :portkey.aws.redshift.snapshot/number-of-nodes :portkey.aws.redshift.snapshot/tags :portkey.aws.redshift.snapshot/db-name :portkey.aws.redshift.snapshot/estimated-seconds-to-completion :portkey.aws.redshift.snapshot/availability-zone :portkey.aws.redshift.snapshot/status :portkey.aws.redshift.snapshot/snapshot-type :portkey.aws.redshift.snapshot/actual-incremental-backup-size-in-mega-bytes :portkey.aws.redshift.snapshot/master-username :portkey.aws.redshift.snapshot/backup-progress-in-mega-bytes :portkey.aws.redshift.snapshot/accounts-with-restore-access :portkey.aws.redshift.snapshot/port :portkey.aws.redshift.snapshot/vpc-id :portkey.aws.redshift.snapshot/maintenance-track-name :portkey.aws.redshift.snapshot/kms-key-id :portkey.aws.redshift.snapshot/cluster-create-time :portkey.aws.redshift.snapshot/cluster-version :portkey.aws.redshift.snapshot/elapsed-time-in-seconds :portkey.aws.redshift.snapshot/current-backup-rate-in-mega-bytes-per-second :portkey.aws.redshift.snapshot/node-type :portkey.aws.redshift.snapshot/total-backup-size-in-mega-bytes]))

(clojure.spec.alpha/def :portkey.aws.redshift/t-stamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-groups (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-subnet-group))

(clojure.spec.alpha/def :portkey.aws.redshift.event-categories-map/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-categories-map/events (clojure.spec.alpha/and :portkey.aws.redshift/event-info-map-list))
(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-categories-map/source-type :portkey.aws.redshift.event-categories-map/events]))

(clojure.spec.alpha/def :portkey.aws.redshift/event-subscription-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/source-ids (clojure.spec.alpha/and :portkey.aws.redshift/source-ids-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-event-subscription-message/subscription-name :portkey.aws.redshift.create-event-subscription-message/sns-topic-arn] :opt-un [:portkey.aws.redshift.create-event-subscription-message/source-type :portkey.aws.redshift.create-event-subscription-message/source-ids :portkey.aws.redshift.create-event-subscription-message/event-categories :portkey.aws.redshift.create-event-subscription-message/severity :portkey.aws.redshift.create-event-subscription-message/enabled :portkey.aws.redshift.create-event-subscription-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-parameter-group-status))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-db-revision-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/recurring-charge-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/recurring-charge))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant-message/snapshot-copy-grants (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-copy-grant-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-copy-grant-message/marker :portkey.aws.redshift.snapshot-copy-grant-message/snapshot-copy-grants]))

(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource-list-message/tagged-resources (clojure.spec.alpha/and :portkey.aws.redshift/tagged-resource-list))
(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource-list-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/tagged-resource-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.tagged-resource-list-message/tagged-resources :portkey.aws.redshift.tagged-resource-list-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-orderable-cluster-options-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-orderable-cluster-options-message/cluster-version :portkey.aws.redshift.describe-orderable-cluster-options-message/node-type :portkey.aws.redshift.describe-orderable-cluster-options-message/max-records :portkey.aws.redshift.describe-orderable-cluster-options-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-tag-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/dependent-service-unavailable-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.account-with-restore-access/account-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.account-with-restore-access/account-alias (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/account-with-restore-access (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.account-with-restore-access/account-id :portkey.aws.redshift.account-with-restore-access/account-alias]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/table-restore-status))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-details/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-details/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group-details/parameters :portkey.aws.redshift.cluster-parameter-group-details/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-version/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-version/cluster-parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-version/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-version/cluster-version :portkey.aws.redshift.cluster-version/cluster-parameter-group-family :portkey.aws.redshift.cluster-version/description]))

(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-options-message/orderable-cluster-options (clojure.spec.alpha/and :portkey.aws.redshift/orderable-cluster-options-list))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-options-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/orderable-cluster-options-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.orderable-cluster-options-message/orderable-cluster-options :portkey.aws.redshift.orderable-cluster-options-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.rotate-encryption-key-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/rotate-encryption-key-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.rotate-encryption-key-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.endpoint/address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.endpoint/port (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift/endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.endpoint/address :portkey.aws.redshift.endpoint/port]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-name :portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-family :portkey.aws.redshift.create-cluster-parameter-group-message/description] :opt-un [:portkey.aws.redshift.create-cluster-parameter-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/target-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/source-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/total-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/request-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/new-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/source-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/status (clojure.spec.alpha/and :portkey.aws.redshift/table-restore-status-type))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/source-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/table-restore-request-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/target-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.table-restore-status/snapshot-identifier :portkey.aws.redshift.table-restore-status/target-schema-name :portkey.aws.redshift.table-restore-status/source-schema-name :portkey.aws.redshift.table-restore-status/total-data-in-mega-bytes :portkey.aws.redshift.table-restore-status/cluster-identifier :portkey.aws.redshift.table-restore-status/request-time :portkey.aws.redshift.table-restore-status/new-table-name :portkey.aws.redshift.table-restore-status/progress-in-mega-bytes :portkey.aws.redshift.table-restore-status/source-database-name :portkey.aws.redshift.table-restore-status/status :portkey.aws.redshift.table-restore-status/message :portkey.aws.redshift.table-restore-status/source-table-name :portkey.aws.redshift.table-restore-status/table-restore-request-id :portkey.aws.redshift.table-restore-status/target-database-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-restore-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/import-tables-completed (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/reserved-node))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-already-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-server-public-certificate (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-hsm-configuration-message/hsm-configuration-identifier :portkey.aws.redshift.create-hsm-configuration-message/description :portkey.aws.redshift.create-hsm-configuration-message/hsm-ip-address :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-name :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-password :portkey.aws.redshift.create-hsm-configuration-message/hsm-server-public-certificate] :opt-un [:portkey.aws.redshift.create-hsm-configuration-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/import-tables-in-progress (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-subnet-group-message/marker :portkey.aws.redshift/cluster-subnet-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-tags-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-tags-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-tags-message/resource-name :portkey.aws.redshift.delete-tags-message/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/purchase-reserved-node-offering-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/reserved-node]))

(clojure.spec.alpha/def :portkey.aws.redshift.ip-range/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ip-range/cidrip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ip-range/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/ip-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.ip-range/status :portkey.aws.redshift.ip-range/cidrip :portkey.aws.redshift.ip-range/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.clusters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.clusters-message/clusters (clojure.spec.alpha/and :portkey.aws.redshift/cluster-list))
(clojure.spec.alpha/def :portkey.aws.redshift/clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.clusters-message/marker :portkey.aws.redshift.clusters-message/clusters]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/subnet-group-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/subnets (clojure.spec.alpha/and :portkey.aws.redshift/subnet-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-subnet-group/cluster-subnet-group-name :portkey.aws.redshift.cluster-subnet-group/description :portkey.aws.redshift.cluster-subnet-group/vpc-id :portkey.aws.redshift.cluster-subnet-group/subnet-group-status :portkey.aws.redshift.cluster-subnet-group/subnets :portkey.aws.redshift.cluster-subnet-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-client-certificate-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/hsm-client-certificate]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-nodes-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-node))

(clojure.spec.alpha/def :portkey.aws.redshift/revoke-snapshot-access-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-subnet-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-snapshot-copy-retention-period-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-snapshot-copy-retention-period-message/cluster-identifier :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/retention-period] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-snapshot-copy-retention-period-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-name-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-name :portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-hsm-client-certificate-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-hsm-client-certificate-message/hsm-client-certificate-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-event-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/event-subscription]))

(clojure.spec.alpha/def :portkey.aws.redshift.tag/key (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.tag/value (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.tag/key :portkey.aws.redshift.tag/value]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-categories-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-event-categories-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-event-categories-message/source-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/current-database-revision (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/database-revision-release-date (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/revision-targets (clojure.spec.alpha/and :portkey.aws.redshift/revision-targets-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-db-revision (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-db-revision/cluster-identifier :portkey.aws.redshift.cluster-db-revision/current-database-revision :portkey.aws.redshift.cluster-db-revision/database-revision-release-date :portkey.aws.redshift.cluster-db-revision/revision-targets]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-versions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-versions-message/cluster-versions (clojure.spec.alpha/and :portkey.aws.redshift/cluster-version-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-versions-message/marker :portkey.aws.redshift.cluster-versions-message/cluster-versions]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/boolean-optional clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.redshift/sns-invalid-topic-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-iam-role-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-iam-role))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-name-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource/resource-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/tagged-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/tag :portkey.aws.redshift.tagged-resource/resource-name :portkey.aws.redshift.tagged-resource/resource-type]))

(clojure.spec.alpha/def :portkey.aws.redshift/unknown-snapshot-copy-region-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/table-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.redshift/access-to-snapshot-denied-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/restorable-node-type-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/target-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/copy-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-identifier :portkey.aws.redshift.copy-cluster-snapshot-message/target-snapshot-identifier] :opt-un [:portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/eligible-tracks-to-update-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/update-target))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group/parameter-group-name :portkey.aws.redshift.cluster-parameter-group/parameter-group-family :portkey.aws.redshift.cluster-parameter-group/description :portkey.aws.redshift.cluster-parameter-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/get-reserved-node-exchange-offerings-input-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/reserved-node-id] :opt-un [:portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/max-records :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-subscriptions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event-subscription))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/hsm-configuration))

(clojure.spec.alpha/def :portkey.aws.redshift/authorize-cluster-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-subnet-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-subnet-groups-message/cluster-subnet-group-name :portkey.aws.redshift.describe-cluster-subnet-groups-message/max-records :portkey.aws.redshift.describe-cluster-subnet-groups-message/marker :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-keys :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-client-certificate-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-client-certificate-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-hsm-client-certificate-message/hsm-client-certificate-identifier] :opt-un [:portkey.aws.redshift.create-hsm-client-certificate-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/long-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-iam-roles-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/db-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-version-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-version))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-on-latest-revision-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/integer-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-status/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-status/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-status/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-status/hsm-client-certificate-identifier :portkey.aws.redshift.hsm-status/hsm-configuration-identifier :portkey.aws.redshift.hsm-status/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.elastic-ip-status/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.elastic-ip-status/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/elastic-ip-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.elastic-ip-status/elastic-ip :portkey.aws.redshift.elastic-ip-status/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/availability-zones (clojure.spec.alpha/and :portkey.aws.redshift/availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.redshift/orderable-cluster-option (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.orderable-cluster-option/cluster-version :portkey.aws.redshift.orderable-cluster-option/cluster-type :portkey.aws.redshift.orderable-cluster-option/node-type :portkey.aws.redshift.orderable-cluster-option/availability-zones]))

(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/new-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/restore-table-from-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.restore-table-from-cluster-snapshot-message/cluster-identifier :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/snapshot-identifier :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-database-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-table-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/new-table-name] :opt-un [:portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-schema-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-database-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-schema-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-iam-roles-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-iam-roles-message/add-iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-iam-roles-message/remove-iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-iam-roles-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-iam-roles-message/cluster-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-iam-roles-message/add-iam-roles :portkey.aws.redshift.modify-cluster-iam-roles-message/remove-iam-roles]))

(clojure.spec.alpha/def :portkey.aws.redshift/unsupported-operation-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/cluster-parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-versions-message/cluster-version :portkey.aws.redshift.describe-cluster-versions-message/cluster-parameter-group-family :portkey.aws.redshift.describe-cluster-versions-message/max-records :portkey.aws.redshift.describe-cluster-versions-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.revision-target/database-revision (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revision-target/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revision-target/database-revision-release-date (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/revision-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.revision-target/database-revision :portkey.aws.redshift.revision-target/description :portkey.aws.redshift.revision-target/database-revision-release-date]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-copy-grant-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-copy-grant-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-copy-grant-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-snapshot-copy-grant-message/snapshot-copy-grant-name] :opt-un [:portkey.aws.redshift.create-snapshot-copy-grant-message/kms-key-id :portkey.aws.redshift.create-snapshot-copy-grant-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/hsm-configuration]))

(clojure.spec.alpha/def :portkey.aws.redshift.purchase-reserved-node-offering-message/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.purchase-reserved-node-offering-message/node-count (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/purchase-reserved-node-offering-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.purchase-reserved-node-offering-message/reserved-node-offering-id] :opt-un [:portkey.aws.redshift.purchase-reserved-node-offering-message/node-count]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/ec-2-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/ec-2-security-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/ip-ranges (clojure.spec.alpha/and :portkey.aws.redshift/ip-range-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-security-group/cluster-security-group-name :portkey.aws.redshift.cluster-security-group/description :portkey.aws.redshift.cluster-security-group/ec-2-security-groups :portkey.aws.redshift.cluster-security-group/ip-ranges :portkey.aws.redshift.cluster-security-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/encryption-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/pending-modified-values (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.pending-modified-values/enhanced-vpc-routing :portkey.aws.redshift.pending-modified-values/publicly-accessible :portkey.aws.redshift.pending-modified-values/cluster-identifier :portkey.aws.redshift.pending-modified-values/number-of-nodes :portkey.aws.redshift.pending-modified-values/cluster-type :portkey.aws.redshift.pending-modified-values/master-user-password :portkey.aws.redshift.pending-modified-values/encryption-type :portkey.aws.redshift.pending-modified-values/maintenance-track-name :portkey.aws.redshift.pending-modified-values/cluster-version :portkey.aws.redshift.pending-modified-values/automated-snapshot-retention-period :portkey.aws.redshift.pending-modified-values/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift/subnet-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/subnet))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-reserved-node-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.authorize-snapshot-access-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-snapshot-access-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-snapshot-access-message/account-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/authorize-snapshot-access-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.authorize-snapshot-access-message/snapshot-identifier :portkey.aws.redshift.authorize-snapshot-access-message/account-with-restore-access] :opt-un [:portkey.aws.redshift.authorize-snapshot-access-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift.reset-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reset-cluster-parameter-group-message/reset-all-parameters (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.reset-cluster-parameter-group-message/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift/reset-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.reset-cluster-parameter-group-message/parameter-group-name] :opt-un [:portkey.aws.redshift.reset-cluster-parameter-group-message/reset-all-parameters :portkey.aws.redshift.reset-cluster-parameter-group-message/parameters]))

(clojure.spec.alpha/def :portkey.aws.redshift/enable-snapshot-copy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-groups-message/parameter-groups (clojure.spec.alpha/and :portkey.aws.redshift/parameter-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-groups-message/marker :portkey.aws.redshift.cluster-parameter-groups-message/parameter-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-copy-grant/snapshot-copy-grant-name :portkey.aws.redshift.snapshot-copy-grant/kms-key-id :portkey.aws.redshift.snapshot-copy-grant/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-hsm-configuration-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-hsm-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-hsm-configuration-message/hsm-configuration-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-security-group-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-security-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-security-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-security-group-message/cluster-security-group-name :portkey.aws.redshift.create-cluster-security-group-message/description] :opt-un [:portkey.aws.redshift.create-cluster-security-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/parameter-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-parameter-group))

(clojure.spec.alpha/def :portkey.aws.redshift/tagged-resource-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/tagged-resource))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-track-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status-message/table-restore-status-details (clojure.spec.alpha/and :portkey.aws.redshift/table-restore-status-list))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.table-restore-status-message/table-restore-status-details :portkey.aws.redshift.table-restore-status-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/db-user (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/duration-seconds (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/auto-create (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/db-groups (clojure.spec.alpha/and :portkey.aws.redshift/db-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift/get-cluster-credentials-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.get-cluster-credentials-message/db-user :portkey.aws.redshift.get-cluster-credentials-message/cluster-identifier] :opt-un [:portkey.aws.redshift.get-cluster-credentials-message/db-name :portkey.aws.redshift.get-cluster-credentials-message/duration-seconds :portkey.aws.redshift.get-cluster-credentials-message/auto-create :portkey.aws.redshift.get-cluster-credentials-message/db-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/source-ids (clojure.spec.alpha/and :portkey.aws.redshift/source-ids-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-event-subscription-message/subscription-name] :opt-un [:portkey.aws.redshift.modify-event-subscription-message/sns-topic-arn :portkey.aws.redshift.modify-event-subscription-message/source-type :portkey.aws.redshift.modify-event-subscription-message/source-ids :portkey.aws.redshift.modify-event-subscription-message/event-categories :portkey.aws.redshift.modify-event-subscription-message/severity :portkey.aws.redshift.modify-event-subscription-message/enabled]))

(clojure.spec.alpha/def :portkey.aws.redshift/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.redshift.default-cluster-parameters/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.default-cluster-parameters/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.default-cluster-parameters/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift/default-cluster-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.default-cluster-parameters/parameter-group-family :portkey.aws.redshift.default-cluster-parameters/marker :portkey.aws.redshift.default-cluster-parameters/parameters]))

(clojure.core/defn describe-cluster-parameters ([describe-cluster-parameters-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-parameters-message describe-cluster-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-group-details, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterParameters", :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-parameters :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-cluster-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-details))

(clojure.core/defn enable-snapshot-copy ([enable-snapshot-copy-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-enable-snapshot-copy-message enable-snapshot-copy-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/enable-snapshot-copy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/enable-snapshot-copy-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "EnableSnapshotCopy", :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "CopyToRegionDisabledFault" :portkey.aws.redshift/copy-to-region-disabled-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift/snapshot-copy-grant-not-found-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "SnapshotCopyAlreadyEnabledFault" :portkey.aws.redshift/snapshot-copy-already-enabled-fault, "IncompatibleOrderableOptions" :portkey.aws.redshift/incompatible-orderable-options, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "UnknownSnapshotCopyRegionFault" :portkey.aws.redshift/unknown-snapshot-copy-region-fault}})))))
(clojure.spec.alpha/fdef enable-snapshot-copy :args (clojure.spec.alpha/tuple :portkey.aws.redshift/enable-snapshot-copy-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/enable-snapshot-copy-result))

(clojure.core/defn disable-snapshot-copy ([disable-snapshot-copy-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-disable-snapshot-copy-message disable-snapshot-copy-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/disable-snapshot-copy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/disable-snapshot-copy-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DisableSnapshotCopy", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "SnapshotCopyAlreadyDisabledFault" :portkey.aws.redshift/snapshot-copy-already-disabled-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation}})))))
(clojure.spec.alpha/fdef disable-snapshot-copy :args (clojure.spec.alpha/tuple :portkey.aws.redshift/disable-snapshot-copy-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/disable-snapshot-copy-result))

(clojure.core/defn create-cluster ([create-cluster-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-cluster-message create-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateCluster", :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift/cluster-already-exists-fault, "InvalidVPCNetworkStateFault" :portkey.aws.redshift/invalid-vpc-network-state-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "ClusterQuotaExceededFault" :portkey.aws.redshift/cluster-quota-exceeded-fault, "InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef create-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-result))

(clojure.core/defn describe-cluster-snapshots ([] (describe-cluster-snapshots {})) ([describe-cluster-snapshots-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-snapshots-message describe-cluster-snapshots-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/snapshot-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-snapshots-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterSnapshots", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-snapshots :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-snapshots-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-message))

(clojure.core/defn create-hsm-client-certificate ([create-hsm-client-certificate-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-hsm-client-certificate-message create-hsm-client-certificate-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-hsm-client-certificate-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-hsm-client-certificate-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateHsmClientCertificate", :http.request.spec/error-spec {"HsmClientCertificateAlreadyExistsFault" :portkey.aws.redshift/hsm-client-certificate-already-exists-fault, "HsmClientCertificateQuotaExceededFault" :portkey.aws.redshift/hsm-client-certificate-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-hsm-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-hsm-client-certificate-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-hsm-client-certificate-result))

(clojure.core/defn delete-tags ([delete-tags-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-tags-message delete-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteTags", :http.request.spec/error-spec {"ResourceNotFoundFault" :portkey.aws.redshift/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef delete-tags :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-tags-message) :ret clojure.core/true?)

(clojure.core/defn describe-cluster-subnet-groups ([] (describe-cluster-subnet-groups {})) ([describe-cluster-subnet-groups-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-subnet-groups-message describe-cluster-subnet-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-subnet-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-subnet-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterSubnetGroups", :http.request.spec/error-spec {"ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-subnet-groups :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-subnet-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-subnet-group-message))

(clojure.core/defn delete-cluster-subnet-group ([delete-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-cluster-subnet-group-message delete-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteClusterSubnetGroup", :http.request.spec/error-spec {"InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault, "InvalidClusterSubnetStateFault" :portkey.aws.redshift/invalid-cluster-subnet-state-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-subnet-group-message) :ret clojure.core/true?)

(clojure.core/defn describe-events ([] (describe-events {})) ([describe-events-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-events-message describe-events-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/events-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-events-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeEvents", :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-events :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-events-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/events-message))

(clojure.core/defn rotate-encryption-key ([rotate-encryption-key-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-rotate-encryption-key-message rotate-encryption-key-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/rotate-encryption-key-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/rotate-encryption-key-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "RotateEncryptionKey", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef rotate-encryption-key :args (clojure.spec.alpha/tuple :portkey.aws.redshift/rotate-encryption-key-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/rotate-encryption-key-result))

(clojure.core/defn describe-hsm-configurations ([] (describe-hsm-configurations {})) ([describe-hsm-configurations-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-hsm-configurations-message describe-hsm-configurations-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/hsm-configuration-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-hsm-configurations-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeHsmConfigurations", :http.request.spec/error-spec {"HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-hsm-configurations :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-hsm-configurations-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/hsm-configuration-message))

(clojure.core/defn revoke-snapshot-access ([revoke-snapshot-access-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-revoke-snapshot-access-message revoke-snapshot-access-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/revoke-snapshot-access-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/revoke-snapshot-access-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "RevokeSnapshotAccess", :http.request.spec/error-spec {"AccessToSnapshotDeniedFault" :portkey.aws.redshift/access-to-snapshot-denied-fault, "AuthorizationNotFoundFault" :portkey.aws.redshift/authorization-not-found-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault}})))))
(clojure.spec.alpha/fdef revoke-snapshot-access :args (clojure.spec.alpha/tuple :portkey.aws.redshift/revoke-snapshot-access-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/revoke-snapshot-access-result))

(clojure.core/defn create-tags ([create-tags-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-tags-message create-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateTags", :http.request.spec/error-spec {"TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "ResourceNotFoundFault" :portkey.aws.redshift/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-tags :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-tags-message) :ret clojure.core/true?)

(clojure.core/defn restore-from-cluster-snapshot ([restore-from-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-restore-from-cluster-snapshot-message restore-from-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/restore-from-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/restore-from-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "RestoreFromClusterSnapshot", :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift/cluster-already-exists-fault, "InvalidVPCNetworkStateFault" :portkey.aws.redshift/invalid-vpc-network-state-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "ClusterQuotaExceededFault" :portkey.aws.redshift/cluster-quota-exceeded-fault, "InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidRestoreFault" :portkey.aws.redshift/invalid-restore-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "AccessToSnapshotDeniedFault" :portkey.aws.redshift/access-to-snapshot-denied-fault, "InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef restore-from-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/restore-from-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/restore-from-cluster-snapshot-result))

(clojure.core/defn modify-cluster-parameter-group ([modify-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-cluster-parameter-group-message modify-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifyClusterParameterGroup", :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "InvalidClusterParameterGroupStateFault" :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-name-message))

(clojure.core/defn describe-cluster-db-revisions ([] (describe-cluster-db-revisions {})) ([describe-cluster-db-revisions-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-db-revisions-message describe-cluster-db-revisions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-db-revisions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-db-revisions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterDbRevisions", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-db-revisions :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-db-revisions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-db-revisions-message))

(clojure.core/defn describe-table-restore-status ([] (describe-table-restore-status {})) ([describe-table-restore-status-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-table-restore-status-message describe-table-restore-status-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/table-restore-status-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-table-restore-status-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeTableRestoreStatus", :http.request.spec/error-spec {"TableRestoreNotFoundFault" :portkey.aws.redshift/table-restore-not-found-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-table-restore-status :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-table-restore-status-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/table-restore-status-message))

(clojure.core/defn revoke-cluster-security-group-ingress ([revoke-cluster-security-group-ingress-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-revoke-cluster-security-group-ingress-message revoke-cluster-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/revoke-cluster-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/revoke-cluster-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "RevokeClusterSecurityGroupIngress", :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "AuthorizationNotFoundFault" :portkey.aws.redshift/authorization-not-found-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault}})))))
(clojure.spec.alpha/fdef revoke-cluster-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.redshift/revoke-cluster-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/revoke-cluster-security-group-ingress-result))

(clojure.core/defn describe-cluster-tracks ([] (describe-cluster-tracks {})) ([describe-cluster-tracks-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-tracks-message describe-cluster-tracks-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/track-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-tracks-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterTracks", :http.request.spec/error-spec {"InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation}})))))
(clojure.spec.alpha/fdef describe-cluster-tracks :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-tracks-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/track-list-message))

(clojure.core/defn create-cluster-snapshot ([create-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-cluster-snapshot-message create-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateClusterSnapshot", :http.request.spec/error-spec {"ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift/cluster-snapshot-already-exists-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-snapshot-result))

(clojure.core/defn get-reserved-node-exchange-offerings ([get-reserved-node-exchange-offerings-input-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-get-reserved-node-exchange-offerings-input-message get-reserved-node-exchange-offerings-input-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/get-reserved-node-exchange-offerings-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/get-reserved-node-exchange-offerings-input-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "GetReservedNodeExchangeOfferings", :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift/reserved-node-not-found-fault, "InvalidReservedNodeStateFault" :portkey.aws.redshift/invalid-reserved-node-state-fault, "ReservedNodeAlreadyMigratedFault" :portkey.aws.redshift/reserved-node-already-migrated-fault, "ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef get-reserved-node-exchange-offerings :args (clojure.spec.alpha/tuple :portkey.aws.redshift/get-reserved-node-exchange-offerings-input-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/get-reserved-node-exchange-offerings-output-message))

(clojure.core/defn create-hsm-configuration ([create-hsm-configuration-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-hsm-configuration-message create-hsm-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-hsm-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-hsm-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateHsmConfiguration", :http.request.spec/error-spec {"HsmConfigurationAlreadyExistsFault" :portkey.aws.redshift/hsm-configuration-already-exists-fault, "HsmConfigurationQuotaExceededFault" :portkey.aws.redshift/hsm-configuration-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-hsm-configuration :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-hsm-configuration-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-hsm-configuration-result))

(clojure.core/defn delete-hsm-client-certificate ([delete-hsm-client-certificate-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-hsm-client-certificate-message delete-hsm-client-certificate-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-hsm-client-certificate-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteHsmClientCertificate", :http.request.spec/error-spec {"InvalidHsmClientCertificateStateFault" :portkey.aws.redshift/invalid-hsm-client-certificate-state-fault, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-hsm-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-hsm-client-certificate-message) :ret clojure.core/true?)

(clojure.core/defn describe-clusters ([] (describe-clusters {})) ([describe-clusters-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-clusters-message describe-clusters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/clusters-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-clusters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusters", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-clusters :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-clusters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/clusters-message))

(clojure.core/defn disable-logging ([disable-logging-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-disable-logging-message disable-logging-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/disable-logging-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DisableLogging", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef disable-logging :args (clojure.spec.alpha/tuple :portkey.aws.redshift/disable-logging-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/logging-status))

(clojure.core/defn delete-cluster-snapshot ([delete-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-cluster-snapshot-message delete-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/delete-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteClusterSnapshot", :http.request.spec/error-spec {"InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/delete-cluster-snapshot-result))

(clojure.core/defn create-snapshot-copy-grant ([create-snapshot-copy-grant-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-snapshot-copy-grant-message create-snapshot-copy-grant-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-snapshot-copy-grant-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-snapshot-copy-grant-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateSnapshotCopyGrant", :http.request.spec/error-spec {"SnapshotCopyGrantAlreadyExistsFault" :portkey.aws.redshift/snapshot-copy-grant-already-exists-fault, "SnapshotCopyGrantQuotaExceededFault" :portkey.aws.redshift/snapshot-copy-grant-quota-exceeded-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef create-snapshot-copy-grant :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-snapshot-copy-grant-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-snapshot-copy-grant-result))

(clojure.core/defn describe-tags ([] (describe-tags {})) ([describe-tags-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-tags-message describe-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/tagged-resource-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeTags", :http.request.spec/error-spec {"ResourceNotFoundFault" :portkey.aws.redshift/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-tags :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-tags-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/tagged-resource-list-message))

(clojure.core/defn modify-snapshot-copy-retention-period ([modify-snapshot-copy-retention-period-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-snapshot-copy-retention-period-message modify-snapshot-copy-retention-period-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/modify-snapshot-copy-retention-period-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-snapshot-copy-retention-period-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifySnapshotCopyRetentionPeriod", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "SnapshotCopyDisabledFault" :portkey.aws.redshift/snapshot-copy-disabled-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-snapshot-copy-retention-period :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-snapshot-copy-retention-period-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-snapshot-copy-retention-period-result))

(clojure.core/defn delete-event-subscription ([delete-event-subscription-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-event-subscription-message delete-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteEventSubscription", :http.request.spec/error-spec {"SubscriptionNotFoundFault" :portkey.aws.redshift/subscription-not-found-fault, "InvalidSubscriptionStateFault" :portkey.aws.redshift/invalid-subscription-state-fault}})))))
(clojure.spec.alpha/fdef delete-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-event-subscription-message) :ret clojure.core/true?)

(clojure.core/defn describe-default-cluster-parameters ([describe-default-cluster-parameters-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-default-cluster-parameters-message describe-default-cluster-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/describe-default-cluster-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-default-cluster-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeDefaultClusterParameters", :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-default-cluster-parameters :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-default-cluster-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/describe-default-cluster-parameters-result))

(clojure.core/defn copy-cluster-snapshot ([copy-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-copy-cluster-snapshot-message copy-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/copy-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/copy-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CopyClusterSnapshot", :http.request.spec/error-spec {"ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift/cluster-snapshot-already-exists-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault}})))))
(clojure.spec.alpha/fdef copy-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/copy-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/copy-cluster-snapshot-result))

(clojure.core/defn get-cluster-credentials ([get-cluster-credentials-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-get-cluster-credentials-message get-cluster-credentials-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-credentials, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/get-cluster-credentials-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "GetClusterCredentials", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef get-cluster-credentials :args (clojure.spec.alpha/tuple :portkey.aws.redshift/get-cluster-credentials-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-credentials))

(clojure.core/defn resize-cluster ([resize-cluster-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-resize-cluster-message resize-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/resize-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/resize-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ResizeCluster", :http.request.spec/error-spec {"InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "UnsupportedOptionFault" :portkey.aws.redshift/unsupported-option-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef resize-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/resize-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/resize-cluster-result))

(clojure.core/defn restore-table-from-cluster-snapshot ([restore-table-from-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-restore-table-from-cluster-snapshot-message restore-table-from-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/restore-table-from-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/restore-table-from-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "RestoreTableFromClusterSnapshot", :http.request.spec/error-spec {"ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InProgressTableRestoreQuotaExceededFault" :portkey.aws.redshift/in-progress-table-restore-quota-exceeded-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "InvalidTableRestoreArgumentFault" :portkey.aws.redshift/invalid-table-restore-argument-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef restore-table-from-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/restore-table-from-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/restore-table-from-cluster-snapshot-result))

(clojure.core/defn reset-cluster-parameter-group ([reset-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-reset-cluster-parameter-group-message reset-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/reset-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ResetClusterParameterGroup", :http.request.spec/error-spec {"InvalidClusterParameterGroupStateFault" :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef reset-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/reset-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-name-message))

(clojure.core/defn enable-logging ([enable-logging-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-enable-logging-message enable-logging-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/enable-logging-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "EnableLogging", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "BucketNotFoundFault" :portkey.aws.redshift/bucket-not-found-fault, "InsufficientS3BucketPolicyFault" :portkey.aws.redshift/insufficient-s-3-bucket-policy-fault, "InvalidS3KeyPrefixFault" :portkey.aws.redshift/invalid-s-3-key-prefix-fault, "InvalidS3BucketNameFault" :portkey.aws.redshift/invalid-s-3-bucket-name-fault}})))))
(clojure.spec.alpha/fdef enable-logging :args (clojure.spec.alpha/tuple :portkey.aws.redshift/enable-logging-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/logging-status))

(clojure.core/defn describe-event-categories ([] (describe-event-categories {})) ([describe-event-categories-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-event-categories-message describe-event-categories-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/event-categories-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-event-categories-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeEventCategories", :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-event-categories :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-event-categories-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-message))

(clojure.core/defn describe-cluster-versions ([] (describe-cluster-versions {})) ([describe-cluster-versions-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-versions-message describe-cluster-versions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-versions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-versions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterVersions", :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-cluster-versions :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-versions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-versions-message))

(clojure.core/defn describe-reserved-nodes ([] (describe-reserved-nodes {})) ([describe-reserved-nodes-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-reserved-nodes-message describe-reserved-nodes-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/reserved-nodes-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-reserved-nodes-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeReservedNodes", :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift/reserved-node-not-found-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef describe-reserved-nodes :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-reserved-nodes-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/reserved-nodes-message))

(clojure.core/defn modify-cluster ([modify-cluster-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-cluster-message modify-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifyCluster", :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift/cluster-already-exists-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "UnsupportedOptionFault" :portkey.aws.redshift/unsupported-option-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "TableLimitExceededFault" :portkey.aws.redshift/table-limit-exceeded-fault, "InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef modify-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-result))

(clojure.core/defn purchase-reserved-node-offering ([purchase-reserved-node-offering-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-purchase-reserved-node-offering-message purchase-reserved-node-offering-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/purchase-reserved-node-offering-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/purchase-reserved-node-offering-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "PurchaseReservedNodeOffering", :http.request.spec/error-spec {"ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "ReservedNodeAlreadyExistsFault" :portkey.aws.redshift/reserved-node-already-exists-fault, "ReservedNodeQuotaExceededFault" :portkey.aws.redshift/reserved-node-quota-exceeded-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef purchase-reserved-node-offering :args (clojure.spec.alpha/tuple :portkey.aws.redshift/purchase-reserved-node-offering-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/purchase-reserved-node-offering-result))

(clojure.core/defn describe-reserved-node-offerings ([] (describe-reserved-node-offerings {})) ([describe-reserved-node-offerings-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-reserved-node-offerings-message describe-reserved-node-offerings-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/reserved-node-offerings-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-reserved-node-offerings-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeReservedNodeOfferings", :http.request.spec/error-spec {"ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef describe-reserved-node-offerings :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-reserved-node-offerings-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-offerings-message))

(clojure.core/defn modify-cluster-db-revision ([modify-cluster-db-revision-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-cluster-db-revision-message modify-cluster-db-revision-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-db-revision-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-db-revision-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifyClusterDbRevision", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ClusterOnLatestRevisionFault" :portkey.aws.redshift/cluster-on-latest-revision-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-db-revision :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-db-revision-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-db-revision-result))

(clojure.core/defn delete-cluster-parameter-group ([delete-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-cluster-parameter-group-message delete-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteClusterParameterGroup", :http.request.spec/error-spec {"InvalidClusterParameterGroupStateFault" :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-parameter-group-message) :ret clojure.core/true?)

(clojure.core/defn accept-reserved-node-exchange ([accept-reserved-node-exchange-input-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-accept-reserved-node-exchange-input-message accept-reserved-node-exchange-input-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/accept-reserved-node-exchange-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/accept-reserved-node-exchange-input-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "AcceptReservedNodeExchange", :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift/reserved-node-not-found-fault, "InvalidReservedNodeStateFault" :portkey.aws.redshift/invalid-reserved-node-state-fault, "ReservedNodeAlreadyMigratedFault" :portkey.aws.redshift/reserved-node-already-migrated-fault, "ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault, "ReservedNodeAlreadyExistsFault" :portkey.aws.redshift/reserved-node-already-exists-fault}})))))
(clojure.spec.alpha/fdef accept-reserved-node-exchange :args (clojure.spec.alpha/tuple :portkey.aws.redshift/accept-reserved-node-exchange-input-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/accept-reserved-node-exchange-output-message))

(clojure.core/defn delete-snapshot-copy-grant ([delete-snapshot-copy-grant-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-snapshot-copy-grant-message delete-snapshot-copy-grant-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-snapshot-copy-grant-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteSnapshotCopyGrant", :http.request.spec/error-spec {"InvalidSnapshotCopyGrantStateFault" :portkey.aws.redshift/invalid-snapshot-copy-grant-state-fault, "SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift/snapshot-copy-grant-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-snapshot-copy-grant :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-snapshot-copy-grant-message) :ret clojure.core/true?)

(clojure.core/defn delete-cluster ([delete-cluster-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-cluster-message delete-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/delete-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteCluster", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift/cluster-snapshot-already-exists-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault}})))))
(clojure.spec.alpha/fdef delete-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/delete-cluster-result))

(clojure.core/defn modify-event-subscription ([modify-event-subscription-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-event-subscription-message modify-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/modify-event-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifyEventSubscription", :http.request.spec/error-spec {"SourceNotFoundFault" :portkey.aws.redshift/source-not-found-fault, "SNSNoAuthorizationFault" :portkey.aws.redshift/sns-no-authorization-fault, "SubscriptionSeverityNotFoundFault" :portkey.aws.redshift/subscription-severity-not-found-fault, "SubscriptionNotFoundFault" :portkey.aws.redshift/subscription-not-found-fault, "SNSTopicArnNotFoundFault" :portkey.aws.redshift/sns-topic-arn-not-found-fault, "SubscriptionCategoryNotFoundFault" :portkey.aws.redshift/subscription-category-not-found-fault, "InvalidSubscriptionStateFault" :portkey.aws.redshift/invalid-subscription-state-fault, "SubscriptionEventIdNotFoundFault" :portkey.aws.redshift/subscription-event-id-not-found-fault, "SNSInvalidTopicFault" :portkey.aws.redshift/sns-invalid-topic-fault}})))))
(clojure.spec.alpha/fdef modify-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-event-subscription-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-event-subscription-result))

(clojure.core/defn describe-hsm-client-certificates ([] (describe-hsm-client-certificates {})) ([describe-hsm-client-certificates-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-hsm-client-certificates-message describe-hsm-client-certificates-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/hsm-client-certificate-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-hsm-client-certificates-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeHsmClientCertificates", :http.request.spec/error-spec {"HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-hsm-client-certificates :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-hsm-client-certificates-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/hsm-client-certificate-message))

(clojure.core/defn create-event-subscription ([create-event-subscription-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-event-subscription-message create-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-event-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateEventSubscription", :http.request.spec/error-spec {"SourceNotFoundFault" :portkey.aws.redshift/source-not-found-fault, "SNSNoAuthorizationFault" :portkey.aws.redshift/sns-no-authorization-fault, "SubscriptionSeverityNotFoundFault" :portkey.aws.redshift/subscription-severity-not-found-fault, "SNSTopicArnNotFoundFault" :portkey.aws.redshift/sns-topic-arn-not-found-fault, "SubscriptionCategoryNotFoundFault" :portkey.aws.redshift/subscription-category-not-found-fault, "SubscriptionAlreadyExistFault" :portkey.aws.redshift/subscription-already-exist-fault, "SubscriptionEventIdNotFoundFault" :portkey.aws.redshift/subscription-event-id-not-found-fault, "EventSubscriptionQuotaExceededFault" :portkey.aws.redshift/event-subscription-quota-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "SNSInvalidTopicFault" :portkey.aws.redshift/sns-invalid-topic-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef create-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-event-subscription-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-event-subscription-result))

(clojure.core/defn create-cluster-security-group ([create-cluster-security-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-cluster-security-group-message create-cluster-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-security-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateClusterSecurityGroup", :http.request.spec/error-spec {"ClusterSecurityGroupAlreadyExistsFault" :portkey.aws.redshift/cluster-security-group-already-exists-fault, "ClusterSecurityGroupQuotaExceededFault" :portkey.aws.redshift/cluster-security-group-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-security-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-security-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-security-group-result))

(clojure.core/defn describe-snapshot-copy-grants ([] (describe-snapshot-copy-grants {})) ([describe-snapshot-copy-grants-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-snapshot-copy-grants-message describe-snapshot-copy-grants-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/snapshot-copy-grant-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-snapshot-copy-grants-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeSnapshotCopyGrants", :http.request.spec/error-spec {"SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift/snapshot-copy-grant-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-snapshot-copy-grants :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-snapshot-copy-grants-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-copy-grant-message))

(clojure.core/defn authorize-cluster-security-group-ingress ([authorize-cluster-security-group-ingress-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-authorize-cluster-security-group-ingress-message authorize-cluster-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/authorize-cluster-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/authorize-cluster-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "AuthorizeClusterSecurityGroupIngress", :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.redshift/authorization-already-exists-fault, "AuthorizationQuotaExceededFault" :portkey.aws.redshift/authorization-quota-exceeded-fault}})))))
(clojure.spec.alpha/fdef authorize-cluster-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.redshift/authorize-cluster-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/authorize-cluster-security-group-ingress-result))

(clojure.core/defn modify-cluster-subnet-group ([modify-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-cluster-subnet-group-message modify-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifyClusterSubnetGroup", :http.request.spec/error-spec {"ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "ClusterSubnetQuotaExceededFault" :portkey.aws.redshift/cluster-subnet-quota-exceeded-fault, "SubnetAlreadyInUse" :portkey.aws.redshift/subnet-already-in-use, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-subnet-group-result))

(clojure.core/defn delete-hsm-configuration ([delete-hsm-configuration-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-hsm-configuration-message delete-hsm-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-hsm-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteHsmConfiguration", :http.request.spec/error-spec {"InvalidHsmConfigurationStateFault" :portkey.aws.redshift/invalid-hsm-configuration-state-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-hsm-configuration :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-hsm-configuration-message) :ret clojure.core/true?)

(clojure.core/defn describe-event-subscriptions ([] (describe-event-subscriptions {})) ([describe-event-subscriptions-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-event-subscriptions-message describe-event-subscriptions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/event-subscriptions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-event-subscriptions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeEventSubscriptions", :http.request.spec/error-spec {"SubscriptionNotFoundFault" :portkey.aws.redshift/subscription-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-event-subscriptions :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-event-subscriptions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/event-subscriptions-message))

(clojure.core/defn create-cluster-parameter-group ([create-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-cluster-parameter-group-message create-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-parameter-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateClusterParameterGroup", :http.request.spec/error-spec {"ClusterParameterGroupQuotaExceededFault" :portkey.aws.redshift/cluster-parameter-group-quota-exceeded-fault, "ClusterParameterGroupAlreadyExistsFault" :portkey.aws.redshift/cluster-parameter-group-already-exists-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-parameter-group-result))

(clojure.core/defn describe-cluster-parameter-groups ([] (describe-cluster-parameter-groups {})) ([describe-cluster-parameter-groups-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-parameter-groups-message describe-cluster-parameter-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-groups-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-parameter-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterParameterGroups", :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-parameter-groups :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-parameter-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-groups-message))

(clojure.core/defn authorize-snapshot-access ([authorize-snapshot-access-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-authorize-snapshot-access-message authorize-snapshot-access-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/authorize-snapshot-access-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/authorize-snapshot-access-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "AuthorizeSnapshotAccess", :http.request.spec/error-spec {"ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.redshift/authorization-already-exists-fault, "AuthorizationQuotaExceededFault" :portkey.aws.redshift/authorization-quota-exceeded-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef authorize-snapshot-access :args (clojure.spec.alpha/tuple :portkey.aws.redshift/authorize-snapshot-access-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/authorize-snapshot-access-result))

(clojure.core/defn describe-logging-status ([describe-logging-status-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-logging-status-message describe-logging-status-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-logging-status-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeLoggingStatus", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-logging-status :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-logging-status-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/logging-status))

(clojure.core/defn describe-resize ([describe-resize-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-resize-message describe-resize-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/resize-progress-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-resize-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeResize", :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ResizeNotFoundFault" :portkey.aws.redshift/resize-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-resize :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-resize-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/resize-progress-message))

(clojure.core/defn reboot-cluster ([reboot-cluster-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-reboot-cluster-message reboot-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/reboot-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/reboot-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "RebootCluster", :http.request.spec/error-spec {"InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef reboot-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/reboot-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/reboot-cluster-result))

(clojure.core/defn describe-orderable-cluster-options ([] (describe-orderable-cluster-options {})) ([describe-orderable-cluster-options-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-orderable-cluster-options-message describe-orderable-cluster-options-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/orderable-cluster-options-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-orderable-cluster-options-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeOrderableClusterOptions", :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-orderable-cluster-options :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-orderable-cluster-options-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/orderable-cluster-options-message))

(clojure.core/defn create-cluster-subnet-group ([create-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-create-cluster-subnet-group-message create-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "CreateClusterSubnetGroup", :http.request.spec/error-spec {"ClusterSubnetGroupAlreadyExistsFault" :portkey.aws.redshift/cluster-subnet-group-already-exists-fault, "ClusterSubnetGroupQuotaExceededFault" :portkey.aws.redshift/cluster-subnet-group-quota-exceeded-fault, "ClusterSubnetQuotaExceededFault" :portkey.aws.redshift/cluster-subnet-quota-exceeded-fault, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef create-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-subnet-group-result))

(clojure.core/defn modify-cluster-iam-roles ([modify-cluster-iam-roles-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-modify-cluster-iam-roles-message modify-cluster-iam-roles-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-iam-roles-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-iam-roles-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "ModifyClusterIamRoles", :http.request.spec/error-spec {"InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-iam-roles :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-iam-roles-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-iam-roles-result))

(clojure.core/defn delete-cluster-security-group ([delete-cluster-security-group-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-delete-cluster-security-group-message delete-cluster-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DeleteClusterSecurityGroup", :http.request.spec/error-spec {"InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-security-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-security-group-message) :ret clojure.core/true?)

(clojure.core/defn describe-cluster-security-groups ([] (describe-cluster-security-groups {})) ([describe-cluster-security-groups-messageinput] (clojure.core/let [request-function-result__255528__auto__ (req-describe-cluster-security-groups-message describe-cluster-security-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__255528__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.spec/output-spec :portkey.aws.redshift/cluster-security-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-security-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/action "DescribeClusterSecurityGroups", :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-security-groups :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-security-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-message))
