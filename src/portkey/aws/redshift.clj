(ns portkey.aws.redshift (:require [portkey.aws]))

(def
 endpoints
 '{"us-gov-east-1"
   {:credential-scope {:service "redshift", :region "us-gov-east-1"},
    :ssl-common-name "redshift.us-gov-east-1.amazonaws.com",
    :endpoint "https://redshift.us-gov-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-1"
   {:credential-scope {:service "redshift", :region "ap-northeast-1"},
    :ssl-common-name "redshift.ap-northeast-1.amazonaws.com",
    :endpoint "https://redshift.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "redshift", :region "eu-west-1"},
    :ssl-common-name "redshift.eu-west-1.amazonaws.com",
    :endpoint "https://redshift.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "redshift", :region "us-east-2"},
    :ssl-common-name "redshift.us-east-2.amazonaws.com",
    :endpoint "https://redshift.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope {:service "redshift", :region "ap-southeast-2"},
    :ssl-common-name "redshift.ap-southeast-2.amazonaws.com",
    :endpoint "https://redshift.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "redshift", :region "cn-north-1"},
    :ssl-common-name "redshift.cn-north-1.amazonaws.com.cn",
    :endpoint "https://redshift.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "sa-east-1"
   {:credential-scope {:service "redshift", :region "sa-east-1"},
    :ssl-common-name "redshift.sa-east-1.amazonaws.com",
    :endpoint "https://redshift.sa-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope {:service "redshift", :region "ap-southeast-1"},
    :ssl-common-name "redshift.ap-southeast-1.amazonaws.com",
    :endpoint "https://redshift.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "cn-northwest-1"
   {:credential-scope {:service "redshift", :region "cn-northwest-1"},
    :ssl-common-name "redshift.cn-northwest-1.amazonaws.com.cn",
    :endpoint "https://redshift.cn-northwest-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope {:service "redshift", :region "ap-northeast-2"},
    :ssl-common-name "redshift.ap-northeast-2.amazonaws.com",
    :endpoint "https://redshift.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-west-3"
   {:credential-scope {:service "redshift", :region "eu-west-3"},
    :ssl-common-name "redshift.eu-west-3.amazonaws.com",
    :endpoint "https://redshift.eu-west-3.amazonaws.com",
    :signature-version :v4},
   "ca-central-1"
   {:credential-scope {:service "redshift", :region "ca-central-1"},
    :ssl-common-name "redshift.ca-central-1.amazonaws.com",
    :endpoint "https://redshift.ca-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "redshift", :region "eu-central-1"},
    :ssl-common-name "redshift.eu-central-1.amazonaws.com",
    :endpoint "https://redshift.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "redshift", :region "eu-west-2"},
    :ssl-common-name "redshift.eu-west-2.amazonaws.com",
    :endpoint "https://redshift.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope {:service "redshift", :region "us-gov-west-1"},
    :ssl-common-name "redshift.us-gov-west-1.amazonaws.com",
    :endpoint "https://redshift.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "redshift", :region "us-west-2"},
    :ssl-common-name "redshift.us-west-2.amazonaws.com",
    :endpoint "https://redshift.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "redshift", :region "us-east-1"},
    :ssl-common-name "redshift.us-east-1.amazonaws.com",
    :endpoint "https://redshift.us-east-1.amazonaws.com",
    :signature-version :v4},
   "us-west-1"
   {:credential-scope {:service "redshift", :region "us-west-1"},
    :ssl-common-name "redshift.us-west-1.amazonaws.com",
    :endpoint "https://redshift.us-west-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "redshift", :region "ap-south-1"},
    :ssl-common-name "redshift.ap-south-1.amazonaws.com",
    :endpoint "https://redshift.ap-south-1.amazonaws.com",
    :signature-version :v4},
   "eu-north-1"
   {:credential-scope {:service "redshift", :region "eu-north-1"},
    :ssl-common-name "redshift.eu-north-1.amazonaws.com",
    :endpoint "https://redshift.eu-north-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-subnet-identifier-list)

(clojure.core/declare ser-parameters-list)

(clojure.core/declare ser-tag-value-list)

(clojure.core/declare ser-snapshot-sorting-entity)

(clojure.core/declare ser-source-ids-list)

(clojure.core/declare ser-schedule-definition-list)

(clojure.core/declare ser-parameter-apply-type)

(clojure.core/declare ser-source-type)

(clojure.core/declare ser-sort-by-order)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-snapshot-identifier-list)

(clojure.core/declare ser-attribute-name-list)

(clojure.core/declare ser-delete-cluster-snapshot-message)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-iam-role-arn-list)

(clojure.core/declare ser-string)

(clojure.core/declare ser-parameter)

(clojure.core/declare ser-vpc-security-group-id-list)

(clojure.core/declare ser-t-stamp)

(clojure.core/declare ser-event-categories-list)

(clojure.core/declare ser-snapshot-sorting-entity-list)

(clojure.core/declare ser-snapshot-attribute-to-sort-by)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-boolean-optional)

(clojure.core/declare ser-cluster-security-group-name-list)

(clojure.core/declare ser-delete-cluster-snapshot-message-list)

(clojure.core/declare ser-db-group-list)

(clojure.core/declare ser-integer-optional)

(clojure.core/declare ser-boolean)

(clojure.core/defn- ser-subnet-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SubnetIdentifier"}))) input), :shape "SubnetIdentifierList", :type "list"})

(clojure.core/defn- ser-parameters-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-parameter coll) #:http.request.field{:shape "Parameter", :location-name "Parameter"}))) input), :shape "ParametersList", :type "list"})

(clojure.core/defn- ser-tag-value-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "TagValue"}))) input), :shape "TagValueList", :type "list"})

(clojure.core/defn- ser-snapshot-sorting-entity [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-snapshot-attribute-to-sort-by (:attribute input)) #:http.request.field{:name "Attribute", :shape "SnapshotAttributeToSortBy"})], :shape "SnapshotSortingEntity", :type "structure"} (clojure.core/contains? input :sort-order) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sort-by-order (input :sort-order)) #:http.request.field{:name "SortOrder", :shape "SortByOrder"}))))

(clojure.core/defn- ser-source-ids-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "SourceId"}))) input), :shape "SourceIdsList", :type "list"})

(clojure.core/defn- ser-schedule-definition-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ScheduleDefinition"}))) input), :shape "ScheduleDefinitionList", :type "list"})

(clojure.core/defn- ser-parameter-apply-type [input] #:http.request.field{:value (clojure.core/get {"static" "static", :static "static", "dynamic" "dynamic", :dynamic "dynamic"} input), :shape "ParameterApplyType"})

(clojure.core/defn- ser-source-type [input] #:http.request.field{:value (clojure.core/get {"cluster" "cluster", :cluster "cluster", "cluster-parameter-group" "cluster-parameter-group", :clusterparametergroup "cluster-parameter-group", "cluster-security-group" "cluster-security-group", :clustersecuritygroup "cluster-security-group", "cluster-snapshot" "cluster-snapshot", :clustersnapshot "cluster-snapshot"} input), :shape "SourceType"})

(clojure.core/defn- ser-sort-by-order [input] #:http.request.field{:value (clojure.core/get {"ASC" "ASC", :asc "ASC", "DESC" "DESC", :desc "DESC"} input), :shape "SortByOrder"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag", :location-name "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "TagKey"}))) input), :shape "TagKeyList", :type "list"})

(clojure.core/defn- ser-snapshot-identifier-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "String"}))) input), :shape "SnapshotIdentifierList", :type "list"})

(clojure.core/defn- ser-attribute-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "AttributeName"}))) input), :shape "AttributeNameList", :type "list"})

(clojure.core/defn- ser-delete-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:snapshot-identifier input)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})], :shape "DeleteClusterSnapshotMessage", :type "structure"} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "Integer"})

(clojure.core/defn- ser-iam-role-arn-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "IamRoleArn"}))) input), :shape "IamRoleArnList", :type "list"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Parameter", :type "structure"} (clojure.core/contains? input :data-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :data-type)) #:http.request.field{:name "DataType", :shape "String"})) (clojure.core/contains? input :parameter-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-name)) #:http.request.field{:name "ParameterName", :shape "String"})) (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :minimum-engine-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :minimum-engine-version)) #:http.request.field{:name "MinimumEngineVersion", :shape "String"})) (clojure.core/contains? input :allowed-values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :allowed-values)) #:http.request.field{:name "AllowedValues", :shape "String"})) (clojure.core/contains? input :apply-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameter-apply-type (input :apply-type)) #:http.request.field{:name "ApplyType", :shape "ParameterApplyType"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})) (clojure.core/contains? input :is-modifiable) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :is-modifiable)) #:http.request.field{:name "IsModifiable", :shape "Boolean"})) (clojure.core/contains? input :parameter-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-value)) #:http.request.field{:name "ParameterValue", :shape "String"}))))

(clojure.core/defn- ser-vpc-security-group-id-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "VpcSecurityGroupId"}))) input), :shape "VpcSecurityGroupIdList", :type "list"})

(clojure.core/defn- ser-t-stamp [input] #:http.request.field{:value input, :shape "TStamp"})

(clojure.core/defn- ser-event-categories-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "EventCategory"}))) input), :shape "EventCategoriesList", :type "list"})

(clojure.core/defn- ser-snapshot-sorting-entity-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-snapshot-sorting-entity coll) #:http.request.field{:shape "SnapshotSortingEntity", :location-name "SnapshotSortingEntity"}))) input), :shape "SnapshotSortingEntityList", :type "list"})

(clojure.core/defn- ser-snapshot-attribute-to-sort-by [input] #:http.request.field{:value (clojure.core/get {"SOURCE_TYPE" "SOURCE_TYPE", :source-type "SOURCE_TYPE", "TOTAL_SIZE" "TOTAL_SIZE", :total-size "TOTAL_SIZE", "CREATE_TIME" "CREATE_TIME", :create-time "CREATE_TIME"} input), :shape "SnapshotAttributeToSortBy"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :key)) #:http.request.field{:name "Key", :shape "String"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :value)) #:http.request.field{:name "Value", :shape "String"}))))

(clojure.core/defn- ser-boolean-optional [input] #:http.request.field{:value input, :shape "BooleanOptional"})

(clojure.core/defn- ser-cluster-security-group-name-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "ClusterSecurityGroupName"}))) input), :shape "ClusterSecurityGroupNameList", :type "list"})

(clojure.core/defn- ser-delete-cluster-snapshot-message-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-delete-cluster-snapshot-message coll) #:http.request.field{:shape "DeleteClusterSnapshotMessage", :location-name "DeleteClusterSnapshotMessage"}))) input), :shape "DeleteClusterSnapshotMessageList", :type "list"})

(clojure.core/defn- ser-db-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "String", :location-name "DbGroup"}))) input), :shape "DbGroupList", :type "list"})

(clojure.core/defn- ser-integer-optional [input] #:http.request.field{:value input, :shape "IntegerOptional"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "Boolean"})

(clojure.core/defn- req-describe-table-restore-status-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :table-restore-request-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :table-restore-request-id)) #:http.request.field{:name "TableRestoreRequestId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"}) (clojure.core/into (ser-string (input :master-username)) #:http.request.field{:name "MasterUsername", :shape "String"}) (clojure.core/into (ser-string (input :master-user-password)) #:http.request.field{:name "MasterUserPassword", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "BooleanOptional"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :number-of-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :db-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :db-name)) #:http.request.field{:name "DBName", :shape "String"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :iam-roles)) #:http.request.field{:name "IamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :snapshot-schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-schedule-identifier)) #:http.request.field{:name "SnapshotScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-enable-logging-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :bucket-name)) #:http.request.field{:name "BucketName", :shape "String"})]} (clojure.core/contains? input :s-3-key-prefix) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-key-prefix)) #:http.request.field{:name "S3KeyPrefix", :shape "String"}))))

(clojure.core/defn- req-describe-hsm-client-certificates-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-snapshot-schedule-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :disassociate-schedule) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :disassociate-schedule)) #:http.request.field{:name "DisassociateSchedule", :shape "BooleanOptional"}))))

(clojure.core/defn- req-resize-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-integer (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "Integer"})]} (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :classic) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :classic)) #:http.request.field{:name "Classic", :shape "BooleanOptional"}))))

(clojure.core/defn- req-enable-snapshot-copy-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :destination-region)) #:http.request.field{:name "DestinationRegion", :shape "String"})]} (clojure.core/contains? input :retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :retention-period)) #:http.request.field{:name "RetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :snapshot-copy-grant-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"}))))

(clojure.core/defn- req-describe-clusters-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-revoke-snapshot-access-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :account-with-restore-access)) #:http.request.field{:name "AccountWithRestoreAccess", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-event-subscriptions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :subscription-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-restore-from-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :owner-account) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :owner-account)) #:http.request.field{:name "OwnerAccount", :shape "String"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :additional-info) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :additional-info)) #:http.request.field{:name "AdditionalInfo", :shape "String"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :port)) #:http.request.field{:name "Port", :shape "IntegerOptional"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :iam-roles)) #:http.request.field{:name "IamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :snapshot-schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-schedule-identifier)) #:http.request.field{:name "SnapshotScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-hsm-configurations-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-describe-cluster-parameter-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-db-revision-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :revision-target)) #:http.request.field{:name "RevisionTarget", :shape "String"})]}))

(clojure.core/defn- req-authorize-cluster-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]} (clojure.core/contains? input :cidrip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidrip)) #:http.request.field{:name "CIDRIP", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"}))))

(clojure.core/defn- req-describe-resize-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-cancel-resize-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-cluster-db-revisions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-default-cluster-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-family)) #:http.request.field{:name "ParameterGroupFamily", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-modify-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean"}))))

(clojure.core/defn- req-modify-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}))))

(clojure.core/defn- req-disable-logging-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-reserved-node-offerings-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-node-offering-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-node-offering-id)) #:http.request.field{:name "ReservedNodeOfferingId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-snapshot-schedules-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"}))))

(clojure.core/defn- req-accept-reserved-node-exchange-input-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"}) (clojure.core/into (ser-string (input :target-reserved-node-offering-id)) #:http.request.field{:name "TargetReservedNodeOfferingId", :shape "String"})]}))

(clojure.core/defn- req-describe-events-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-identifier)) #:http.request.field{:name "SourceIdentifier", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-type (input :source-type)) #:http.request.field{:name "SourceType", :shape "SourceType"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration)) #:http.request.field{:name "Duration", :shape "IntegerOptional"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-batch-delete-cluster-snapshots-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-delete-cluster-snapshot-message-list (input :identifiers)) #:http.request.field{:name "Identifiers", :shape "DeleteClusterSnapshotMessageList"})]}))

(clojure.core/defn- req-revoke-cluster-security-group-ingress-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]} (clojure.core/contains? input :cidrip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cidrip)) #:http.request.field{:name "CIDRIP", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-name)) #:http.request.field{:name "EC2SecurityGroupName", :shape "String"})) (clojure.core/contains? input :ec-2-security-group-owner-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :ec-2-security-group-owner-id)) #:http.request.field{:name "EC2SecurityGroupOwnerId", :shape "String"}))))

(clojure.core/defn- req-disable-snapshot-copy-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-delete-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})]}))

(clojure.core/defn- req-describe-cluster-security-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-security-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-modify-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"}) (clojure.core/into (ser-parameters-list (input :parameters)) #:http.request.field{:name "Parameters", :shape "ParametersList"})]}))

(clojure.core/defn- req-create-tags-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})]}))

(clojure.core/defn- req-describe-cluster-parameters-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]} (clojure.core/contains? input :source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source)) #:http.request.field{:name "Source", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-tags-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :resource-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"})) (clojure.core/contains? input :resource-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :resource-type)) #:http.request.field{:name "ResourceType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-describe-cluster-snapshots-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"})) (clojure.core/contains? input :snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :end-time)) #:http.request.field{:name "EndTime", :shape "TStamp"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :start-time)) #:http.request.field{:name "StartTime", :shape "TStamp"})) (clojure.core/contains? input :owner-account) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :owner-account)) #:http.request.field{:name "OwnerAccount", :shape "String"})) (clojure.core/contains? input :cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :snapshot-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-type)) #:http.request.field{:name "SnapshotType", :shape "String"})) (clojure.core/contains? input :cluster-exists) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :cluster-exists)) #:http.request.field{:name "ClusterExists", :shape "BooleanOptional"})) (clojure.core/contains? input :sorting-entities) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-snapshot-sorting-entity-list (input :sorting-entities)) #:http.request.field{:name "SortingEntities", :shape "SnapshotSortingEntityList"}))))

(clojure.core/defn- req-describe-logging-status-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-delete-snapshot-copy-grant-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-cluster-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"})]}))

(clojure.core/defn- req-describe-reserved-nodes-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :reserved-node-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})]}))

(clojure.core/defn- req-delete-snapshot-schedule-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-subnet-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}) (clojure.core/into (ser-subnet-identifier-list (input :subnet-ids)) #:http.request.field{:name "SubnetIds", :shape "SubnetIdentifierList"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-modify-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :enhanced-vpc-routing) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enhanced-vpc-routing)) #:http.request.field{:name "EnhancedVpcRouting", :shape "BooleanOptional"})) (clojure.core/contains? input :publicly-accessible) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :publicly-accessible)) #:http.request.field{:name "PubliclyAccessible", :shape "BooleanOptional"})) (clojure.core/contains? input :preferred-maintenance-window) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-maintenance-window)) #:http.request.field{:name "PreferredMaintenanceWindow", :shape "String"})) (clojure.core/contains? input :encrypted) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :encrypted)) #:http.request.field{:name "Encrypted", :shape "BooleanOptional"})) (clojure.core/contains? input :hsm-client-certificate-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})) (clojure.core/contains? input :number-of-nodes) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :number-of-nodes)) #:http.request.field{:name "NumberOfNodes", :shape "IntegerOptional"})) (clojure.core/contains? input :vpc-security-group-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-vpc-security-group-id-list (input :vpc-security-group-ids)) #:http.request.field{:name "VpcSecurityGroupIds", :shape "VpcSecurityGroupIdList"})) (clojure.core/contains? input :cluster-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-type)) #:http.request.field{:name "ClusterType", :shape "String"})) (clojure.core/contains? input :master-user-password) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :master-user-password)) #:http.request.field{:name "MasterUserPassword", :shape "String"})) (clojure.core/contains? input :cluster-security-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cluster-security-group-name-list (input :cluster-security-groups)) #:http.request.field{:name "ClusterSecurityGroups", :shape "ClusterSecurityGroupNameList"})) (clojure.core/contains? input :elastic-ip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :elastic-ip)) #:http.request.field{:name "ElasticIp", :shape "String"})) (clojure.core/contains? input :hsm-configuration-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})) (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :allow-version-upgrade) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :allow-version-upgrade)) #:http.request.field{:name "AllowVersionUpgrade", :shape "BooleanOptional"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :automated-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :automated-snapshot-retention-period)) #:http.request.field{:name "AutomatedSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :new-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :new-cluster-identifier)) #:http.request.field{:name "NewClusterIdentifier", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-name)) #:http.request.field{:name "ClusterParameterGroupName", :shape "String"}))))

(clojure.core/defn- req-delete-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-describe-snapshot-copy-grants-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :snapshot-copy-grant-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-delete-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :skip-final-cluster-snapshot) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :skip-final-cluster-snapshot)) #:http.request.field{:name "SkipFinalClusterSnapshot", :shape "Boolean"})) (clojure.core/contains? input :final-cluster-snapshot-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :final-cluster-snapshot-identifier)) #:http.request.field{:name "FinalClusterSnapshotIdentifier", :shape "String"})) (clojure.core/contains? input :final-cluster-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :final-cluster-snapshot-retention-period)) #:http.request.field{:name "FinalClusterSnapshotRetentionPeriod", :shape "IntegerOptional"}))))

(clojure.core/defn- req-describe-cluster-tracks-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :maintenance-track-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :maintenance-track-name)) #:http.request.field{:name "MaintenanceTrackName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-reboot-cluster-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"}) (clojure.core/into (ser-string (input :sns-topic-arn)) #:http.request.field{:name "SnsTopicArn", :shape "String"})]} (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"})) (clojure.core/contains? input :source-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-ids-list (input :source-ids)) #:http.request.field{:name "SourceIds", :shape "SourceIdsList"})) (clojure.core/contains? input :event-categories) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-categories-list (input :event-categories)) #:http.request.field{:name "EventCategories", :shape "EventCategoriesList"})) (clojure.core/contains? input :severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :severity)) #:http.request.field{:name "Severity", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enabled)) #:http.request.field{:name "Enabled", :shape "BooleanOptional"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-orderable-cluster-options-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :node-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :node-type)) #:http.request.field{:name "NodeType", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-rotate-encryption-key-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]}))

(clojure.core/defn- req-modify-snapshot-schedule-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"}) (clojure.core/into (ser-schedule-definition-list (input :schedule-definitions)) #:http.request.field{:name "ScheduleDefinitions", :shape "ScheduleDefinitionList"})]}))

(clojure.core/defn- req-create-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"}) (clojure.core/into (ser-string (input :parameter-group-family)) #:http.request.field{:name "ParameterGroupFamily", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-create-hsm-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"}) (clojure.core/into (ser-string (input :hsm-ip-address)) #:http.request.field{:name "HsmIpAddress", :shape "String"}) (clojure.core/into (ser-string (input :hsm-partition-name)) #:http.request.field{:name "HsmPartitionName", :shape "String"}) (clojure.core/into (ser-string (input :hsm-partition-password)) #:http.request.field{:name "HsmPartitionPassword", :shape "String"}) (clojure.core/into (ser-string (input :hsm-server-public-certificate)) #:http.request.field{:name "HsmServerPublicCertificate", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-tags-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :resource-name)) #:http.request.field{:name "ResourceName", :shape "String"}) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})]}))

(clojure.core/defn- req-modify-snapshot-copy-retention-period-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-integer (input :retention-period)) #:http.request.field{:name "RetentionPeriod", :shape "Integer"})]} (clojure.core/contains? input :manual) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :manual)) #:http.request.field{:name "Manual", :shape "Boolean"}))))

(clojure.core/defn- req-delete-hsm-client-certificate-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})]}))

(clojure.core/defn- req-describe-event-categories-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"}))))

(clojure.core/defn- req-describe-account-attributes-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :attribute-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-name-list (input :attribute-names)) #:http.request.field{:name "AttributeNames", :shape "AttributeNameList"}))))

(clojure.core/defn- req-copy-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :source-snapshot-identifier)) #:http.request.field{:name "SourceSnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :target-snapshot-identifier)) #:http.request.field{:name "TargetSnapshotIdentifier", :shape "String"})]} (clojure.core/contains? input :source-snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-snapshot-cluster-identifier)) #:http.request.field{:name "SourceSnapshotClusterIdentifier", :shape "String"})) (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"}))))

(clojure.core/defn- req-get-reserved-node-exchange-offerings-input-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-id)) #:http.request.field{:name "ReservedNodeId", :shape "String"})]} (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-describe-cluster-subnet-groups-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-subnet-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-subnet-group-name)) #:http.request.field{:name "ClusterSubnetGroupName", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"})) (clojure.core/contains? input :tag-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "TagKeyList"})) (clojure.core/contains? input :tag-values) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value-list (input :tag-values)) #:http.request.field{:name "TagValues", :shape "TagValueList"}))))

(clojure.core/defn- req-create-hsm-client-certificate-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-client-certificate-identifier)) #:http.request.field{:name "HsmClientCertificateIdentifier", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-restore-table-from-cluster-snapshot-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :source-database-name)) #:http.request.field{:name "SourceDatabaseName", :shape "String"}) (clojure.core/into (ser-string (input :source-table-name)) #:http.request.field{:name "SourceTableName", :shape "String"}) (clojure.core/into (ser-string (input :new-table-name)) #:http.request.field{:name "NewTableName", :shape "String"})]} (clojure.core/contains? input :source-schema-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-schema-name)) #:http.request.field{:name "SourceSchemaName", :shape "String"})) (clojure.core/contains? input :target-database-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-database-name)) #:http.request.field{:name "TargetDatabaseName", :shape "String"})) (clojure.core/contains? input :target-schema-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :target-schema-name)) #:http.request.field{:name "TargetSchemaName", :shape "String"}))))

(clojure.core/defn- req-modify-cluster-iam-roles-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :add-iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :add-iam-roles)) #:http.request.field{:name "AddIamRoles", :shape "IamRoleArnList"})) (clojure.core/contains? input :remove-iam-roles) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iam-role-arn-list (input :remove-iam-roles)) #:http.request.field{:name "RemoveIamRoles", :shape "IamRoleArnList"}))))

(clojure.core/defn- req-describe-cluster-versions-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :cluster-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-version)) #:http.request.field{:name "ClusterVersion", :shape "String"})) (clojure.core/contains? input :cluster-parameter-group-family) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :cluster-parameter-group-family)) #:http.request.field{:name "ClusterParameterGroupFamily", :shape "String"})) (clojure.core/contains? input :max-records) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :max-records)) #:http.request.field{:name "MaxRecords", :shape "IntegerOptional"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :marker)) #:http.request.field{:name "Marker", :shape "String"}))))

(clojure.core/defn- req-create-snapshot-schedule-message [input] (clojure.core/cond-> {} (clojure.core/contains? input :schedule-definitions) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule-definition-list (input :schedule-definitions)) #:http.request.field{:name "ScheduleDefinitions", :shape "ScheduleDefinitionList"})) (clojure.core/contains? input :schedule-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-identifier)) #:http.request.field{:name "ScheduleIdentifier", :shape "String"})) (clojure.core/contains? input :schedule-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :schedule-description)) #:http.request.field{:name "ScheduleDescription", :shape "String"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"})) (clojure.core/contains? input :dry-run) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :dry-run)) #:http.request.field{:name "DryRun", :shape "BooleanOptional"})) (clojure.core/contains? input :next-invocations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :next-invocations)) #:http.request.field{:name "NextInvocations", :shape "IntegerOptional"}))))

(clojure.core/defn- req-create-snapshot-copy-grant-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-copy-grant-name)) #:http.request.field{:name "SnapshotCopyGrantName", :shape "String"})]} (clojure.core/contains? input :kms-key-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :kms-key-id)) #:http.request.field{:name "KmsKeyId", :shape "String"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-purchase-reserved-node-offering-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :reserved-node-offering-id)) #:http.request.field{:name "ReservedNodeOfferingId", :shape "String"})]} (clojure.core/contains? input :node-count) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :node-count)) #:http.request.field{:name "NodeCount", :shape "IntegerOptional"}))))

(clojure.core/defn- req-authorize-snapshot-access-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :snapshot-identifier)) #:http.request.field{:name "SnapshotIdentifier", :shape "String"}) (clojure.core/into (ser-string (input :account-with-restore-access)) #:http.request.field{:name "AccountWithRestoreAccess", :shape "String"})]} (clojure.core/contains? input :snapshot-cluster-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :snapshot-cluster-identifier)) #:http.request.field{:name "SnapshotClusterIdentifier", :shape "String"}))))

(clojure.core/defn- req-reset-cluster-parameter-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :parameter-group-name)) #:http.request.field{:name "ParameterGroupName", :shape "String"})]} (clojure.core/contains? input :reset-all-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :reset-all-parameters)) #:http.request.field{:name "ResetAllParameters", :shape "Boolean"})) (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters-list (input :parameters)) #:http.request.field{:name "Parameters", :shape "ParametersList"}))))

(clojure.core/defn- req-batch-modify-cluster-snapshots-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-snapshot-identifier-list (input :snapshot-identifier-list)) #:http.request.field{:name "SnapshotIdentifierList", :shape "SnapshotIdentifierList"})]} (clojure.core/contains? input :manual-snapshot-retention-period) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :manual-snapshot-retention-period)) #:http.request.field{:name "ManualSnapshotRetentionPeriod", :shape "IntegerOptional"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :force)) #:http.request.field{:name "Force", :shape "Boolean"}))))

(clojure.core/defn- req-delete-hsm-configuration-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :hsm-configuration-identifier)) #:http.request.field{:name "HsmConfigurationIdentifier", :shape "String"})]}))

(clojure.core/defn- req-create-cluster-security-group-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-security-group-name)) #:http.request.field{:name "ClusterSecurityGroupName", :shape "String"}) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "String"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "Tags", :shape "TagList"}))))

(clojure.core/defn- req-modify-cluster-maintenance-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :defer-maintenance) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :defer-maintenance)) #:http.request.field{:name "DeferMaintenance", :shape "BooleanOptional"})) (clojure.core/contains? input :defer-maintenance-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :defer-maintenance-identifier)) #:http.request.field{:name "DeferMaintenanceIdentifier", :shape "String"})) (clojure.core/contains? input :defer-maintenance-start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :defer-maintenance-start-time)) #:http.request.field{:name "DeferMaintenanceStartTime", :shape "TStamp"})) (clojure.core/contains? input :defer-maintenance-end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-t-stamp (input :defer-maintenance-end-time)) #:http.request.field{:name "DeferMaintenanceEndTime", :shape "TStamp"})) (clojure.core/contains? input :defer-maintenance-duration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :defer-maintenance-duration)) #:http.request.field{:name "DeferMaintenanceDuration", :shape "IntegerOptional"}))))

(clojure.core/defn- req-get-cluster-credentials-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :db-user)) #:http.request.field{:name "DbUser", :shape "String"}) (clojure.core/into (ser-string (input :cluster-identifier)) #:http.request.field{:name "ClusterIdentifier", :shape "String"})]} (clojure.core/contains? input :db-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :db-name)) #:http.request.field{:name "DbName", :shape "String"})) (clojure.core/contains? input :duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer-optional (input :duration-seconds)) #:http.request.field{:name "DurationSeconds", :shape "IntegerOptional"})) (clojure.core/contains? input :auto-create) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :auto-create)) #:http.request.field{:name "AutoCreate", :shape "BooleanOptional"})) (clojure.core/contains? input :db-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-db-group-list (input :db-groups)) #:http.request.field{:name "DbGroups", :shape "DbGroupList"}))))

(clojure.core/defn- req-modify-event-subscription-message [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-string (input :subscription-name)) #:http.request.field{:name "SubscriptionName", :shape "String"})]} (clojure.core/contains? input :sns-topic-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sns-topic-arn)) #:http.request.field{:name "SnsTopicArn", :shape "String"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :source-type)) #:http.request.field{:name "SourceType", :shape "String"})) (clojure.core/contains? input :source-ids) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-ids-list (input :source-ids)) #:http.request.field{:name "SourceIds", :shape "SourceIdsList"})) (clojure.core/contains? input :event-categories) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-categories-list (input :event-categories)) #:http.request.field{:name "EventCategories", :shape "EventCategoriesList"})) (clojure.core/contains? input :severity) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :severity)) #:http.request.field{:name "Severity", :shape "String"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean-optional (input :enabled)) #:http.request.field{:name "Enabled", :shape "BooleanOptional"}))))

(clojure.core/declare deser-vpc-security-group-membership-list)

(clojure.core/declare deser-snapshot-copy-grant-list)

(clojure.core/declare deser-hsm-configuration)

(clojure.core/declare deser-double)

(clojure.core/declare deser-maintenance-track)

(clojure.core/declare deser-parameters-list)

(clojure.core/declare deser-ec-2-security-group-list)

(clojure.core/declare deser-table-restore-status-type)

(clojure.core/declare deser-import-tables-not-started)

(clojure.core/declare deser-cluster-node)

(clojure.core/declare deser-attribute-list)

(clojure.core/declare deser-supported-operation-list)

(clojure.core/declare deser-reserved-node)

(clojure.core/declare deser-double-optional)

(clojure.core/declare deser-source-ids-list)

(clojure.core/declare deser-schedule-definition-list)

(clojure.core/declare deser-cluster-parameter-status-list)

(clojure.core/declare deser-snapshot-list)

(clojure.core/declare deser-associated-cluster-list)

(clojure.core/declare deser-subnet)

(clojure.core/declare deser-attribute-value-target)

(clojure.core/declare deser-event-info-map-list)

(clojure.core/declare deser-supported-platforms-list)

(clojure.core/declare deser-event-subscription)

(clojure.core/declare deser-cluster-snapshot-copy-status)

(clojure.core/declare deser-deferred-maintenance-windows-list)

(clojure.core/declare deser-reserved-node-offering-type)

(clojure.core/declare deser-orderable-cluster-options-list)

(clojure.core/declare deser-supported-operation)

(clojure.core/declare deser-reserved-node-offering-list)

(clojure.core/declare deser-parameter-apply-type)

(clojure.core/declare deser-ip-range-list)

(clojure.core/declare deser-snapshot-schedule-list)

(clojure.core/declare deser-event-list)

(clojure.core/declare deser-hsm-client-certificate)

(clojure.core/declare deser-source-type)

(clojure.core/declare deser-batch-snapshot-operation-error-list)

(clojure.core/declare deser-event)

(clojure.core/declare deser-availability-zone-list)

(clojure.core/declare deser-availability-zone)

(clojure.core/declare deser-revision-targets-list)

(clojure.core/declare deser-supported-platform)

(clojure.core/declare deser-sensitive-string)

(clojure.core/declare deser-cluster-list)

(clojure.core/declare deser-cluster-security-groups)

(clojure.core/declare deser-recurring-charge)

(clojure.core/declare deser-track-list)

(clojure.core/declare deser-batch-snapshot-operation-errors)

(clojure.core/declare deser-cluster-security-group-membership)

(clojure.core/declare deser-cluster-iam-role)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-cluster-db-revisions-list)

(clojure.core/declare deser-cluster)

(clojure.core/declare deser-hsm-client-certificate-list)

(clojure.core/declare deser-reserved-node-offering)

(clojure.core/declare deser-accounts-with-restore-access-list)

(clojure.core/declare deser-vpc-security-group-membership)

(clojure.core/declare deser-event-info-map)

(clojure.core/declare deser-update-target)

(clojure.core/declare deser-data-transfer-progress)

(clojure.core/declare deser-pending-actions-list)

(clojure.core/declare deser-snapshot-identifier-list)

(clojure.core/declare deser-ec-2-security-group)

(clojure.core/declare deser-event-categories-map-list)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-string)

(clojure.core/declare deser-parameter)

(clojure.core/declare deser-cluster-parameter-status)

(clojure.core/declare deser-cluster-parameter-group-status)

(clojure.core/declare deser-cluster-security-group-membership-list)

(clojure.core/declare deser-restore-status)

(clojure.core/declare deser-snapshot)

(clojure.core/declare deser-t-stamp)

(clojure.core/declare deser-cluster-subnet-groups)

(clojure.core/declare deser-event-categories-map)

(clojure.core/declare deser-cluster-parameter-group-status-list)

(clojure.core/declare deser-recurring-charge-list)

(clojure.core/declare deser-event-categories-list)

(clojure.core/declare deser-account-with-restore-access)

(clojure.core/declare deser-table-restore-status-list)

(clojure.core/declare deser-cluster-version)

(clojure.core/declare deser-snapshot-schedule)

(clojure.core/declare deser-endpoint)

(clojure.core/declare deser-table-restore-status)

(clojure.core/declare deser-long)

(clojure.core/declare deser-import-tables-completed)

(clojure.core/declare deser-reserved-node-list)

(clojure.core/declare deser-import-tables-in-progress)

(clojure.core/declare deser-snapshot-error-message)

(clojure.core/declare deser-attribute-value-list)

(clojure.core/declare deser-ip-range)

(clojure.core/declare deser-cluster-subnet-group)

(clojure.core/declare deser-cluster-nodes-list)

(clojure.core/declare deser-resize-info)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-cluster-db-revision)

(clojure.core/declare deser-schedule-state)

(clojure.core/declare deser-boolean-optional)

(clojure.core/declare deser-cluster-iam-role-list)

(clojure.core/declare deser-deferred-maintenance-window)

(clojure.core/declare deser-tagged-resource)

(clojure.core/declare deser-restorable-node-type-list)

(clojure.core/declare deser-cluster-associated-to-schedule)

(clojure.core/declare deser-eligible-tracks-to-update-list)

(clojure.core/declare deser-scheduled-snapshot-time-list)

(clojure.core/declare deser-cluster-parameter-group)

(clojure.core/declare deser-event-subscriptions-list)

(clojure.core/declare deser-hsm-configuration-list)

(clojure.core/declare deser-long-optional)

(clojure.core/declare deser-cluster-version-list)

(clojure.core/declare deser-integer-optional)

(clojure.core/declare deser-hsm-status)

(clojure.core/declare deser-elastic-ip-status)

(clojure.core/declare deser-orderable-cluster-option)

(clojure.core/declare deser-revision-target)

(clojure.core/declare deser-cluster-security-group)

(clojure.core/declare deser-pending-modified-values)

(clojure.core/declare deser-subnet-list)

(clojure.core/declare deser-account-attribute)

(clojure.core/declare deser-snapshot-copy-grant)

(clojure.core/declare deser-parameter-group-list)

(clojure.core/declare deser-tagged-resource-list)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-default-cluster-parameters)

(clojure.core/defn- deser-vpc-security-group-membership-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-vpc-security-group-membership coll))) input))

(clojure.core/defn- deser-snapshot-copy-grant-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-copy-grant coll))) input))

(clojure.core/defn- deser-hsm-configuration [input] (clojure.core/let [letvar1528357 {"HsmConfigurationIdentifier" (portkey.aws/search-for-tag input "HsmConfigurationIdentifier" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "HsmIpAddress" (portkey.aws/search-for-tag input "HsmIpAddress" :flattened? nil :xmlAttribute? nil), "HsmPartitionName" (portkey.aws/search-for-tag input "HsmPartitionName" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1528357 "HsmConfigurationIdentifier") (clojure.core/assoc :hsm-configuration-identifier (deser-string (clojure.core/get-in letvar1528357 ["HsmConfigurationIdentifier" :content]))) (letvar1528357 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1528357 ["Description" :content]))) (letvar1528357 "HsmIpAddress") (clojure.core/assoc :hsm-ip-address (deser-string (clojure.core/get-in letvar1528357 ["HsmIpAddress" :content]))) (letvar1528357 "HsmPartitionName") (clojure.core/assoc :hsm-partition-name (deser-string (clojure.core/get-in letvar1528357 ["HsmPartitionName" :content]))) (letvar1528357 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1528357 ["Tags" :content]))))))

(clojure.core/defn- deser-double [input] (java.lang.Double. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-maintenance-track [input] (clojure.core/let [letvar1528467 {"MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "DatabaseVersion" (portkey.aws/search-for-tag input "DatabaseVersion" :flattened? nil :xmlAttribute? nil), "UpdateTargets" (portkey.aws/search-for-tag input "UpdateTargets" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1528467 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar1528467 ["MaintenanceTrackName" :content]))) (letvar1528467 "DatabaseVersion") (clojure.core/assoc :database-version (deser-string (clojure.core/get-in letvar1528467 ["DatabaseVersion" :content]))) (letvar1528467 "UpdateTargets") (clojure.core/assoc :update-targets (deser-eligible-tracks-to-update-list (clojure.core/get-in letvar1528467 ["UpdateTargets" :content]))))))

(clojure.core/defn- deser-parameters-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-parameter coll))) input))

(clojure.core/defn- deser-ec-2-security-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ec-2-security-group coll))) input))

(clojure.core/defn- deser-table-restore-status-type [input] (clojure.core/get {"PENDING" :pending, "IN_PROGRESS" :in-progress, "SUCCEEDED" :succeeded, "FAILED" :failed, "CANCELED" :canceled} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-import-tables-not-started [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cluster-node [input] (clojure.core/let [letvar1528631 {"NodeRole" (portkey.aws/search-for-tag input "NodeRole" :flattened? nil :xmlAttribute? nil), "PrivateIPAddress" (portkey.aws/search-for-tag input "PrivateIPAddress" :flattened? nil :xmlAttribute? nil), "PublicIPAddress" (portkey.aws/search-for-tag input "PublicIPAddress" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1528631 "NodeRole") (clojure.core/assoc :node-role (deser-string (clojure.core/get-in letvar1528631 ["NodeRole" :content]))) (letvar1528631 "PrivateIPAddress") (clojure.core/assoc :private-ip-address (deser-string (clojure.core/get-in letvar1528631 ["PrivateIPAddress" :content]))) (letvar1528631 "PublicIPAddress") (clojure.core/assoc :public-ip-address (deser-string (clojure.core/get-in letvar1528631 ["PublicIPAddress" :content]))))))

(clojure.core/defn- deser-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-attribute coll))) input))

(clojure.core/defn- deser-supported-operation-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-supported-operation coll))) input))

(clojure.core/defn- deser-reserved-node [input] (clojure.core/let [letvar1528773 {"CurrencyCode" (portkey.aws/search-for-tag input "CurrencyCode" :flattened? nil :xmlAttribute? nil), "StartTime" (portkey.aws/search-for-tag input "StartTime" :flattened? nil :xmlAttribute? nil), "NodeCount" (portkey.aws/search-for-tag input "NodeCount" :flattened? nil :xmlAttribute? nil), "FixedPrice" (portkey.aws/search-for-tag input "FixedPrice" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingType" (portkey.aws/search-for-tag input "ReservedNodeOfferingType" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingId" (portkey.aws/search-for-tag input "ReservedNodeOfferingId" :flattened? nil :xmlAttribute? nil), "Duration" (portkey.aws/search-for-tag input "Duration" :flattened? nil :xmlAttribute? nil), "ReservedNodeId" (portkey.aws/search-for-tag input "ReservedNodeId" :flattened? nil :xmlAttribute? nil), "UsagePrice" (portkey.aws/search-for-tag input "UsagePrice" :flattened? nil :xmlAttribute? nil), "State" (portkey.aws/search-for-tag input "State" :flattened? nil :xmlAttribute? nil), "RecurringCharges" (portkey.aws/search-for-tag input "RecurringCharges" :flattened? nil :xmlAttribute? nil), "OfferingType" (portkey.aws/search-for-tag input "OfferingType" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1528773 "CurrencyCode") (clojure.core/assoc :currency-code (deser-string (clojure.core/get-in letvar1528773 ["CurrencyCode" :content]))) (letvar1528773 "StartTime") (clojure.core/assoc :start-time (deser-t-stamp (clojure.core/get-in letvar1528773 ["StartTime" :content]))) (letvar1528773 "NodeCount") (clojure.core/assoc :node-count (deser-integer (clojure.core/get-in letvar1528773 ["NodeCount" :content]))) (letvar1528773 "FixedPrice") (clojure.core/assoc :fixed-price (deser-double (clojure.core/get-in letvar1528773 ["FixedPrice" :content]))) (letvar1528773 "ReservedNodeOfferingType") (clojure.core/assoc :reserved-node-offering-type (deser-reserved-node-offering-type (clojure.core/get-in letvar1528773 ["ReservedNodeOfferingType" :content]))) (letvar1528773 "ReservedNodeOfferingId") (clojure.core/assoc :reserved-node-offering-id (deser-string (clojure.core/get-in letvar1528773 ["ReservedNodeOfferingId" :content]))) (letvar1528773 "Duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar1528773 ["Duration" :content]))) (letvar1528773 "ReservedNodeId") (clojure.core/assoc :reserved-node-id (deser-string (clojure.core/get-in letvar1528773 ["ReservedNodeId" :content]))) (letvar1528773 "UsagePrice") (clojure.core/assoc :usage-price (deser-double (clojure.core/get-in letvar1528773 ["UsagePrice" :content]))) (letvar1528773 "State") (clojure.core/assoc :state (deser-string (clojure.core/get-in letvar1528773 ["State" :content]))) (letvar1528773 "RecurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charge-list (clojure.core/get-in letvar1528773 ["RecurringCharges" :content]))) (letvar1528773 "OfferingType") (clojure.core/assoc :offering-type (deser-string (clojure.core/get-in letvar1528773 ["OfferingType" :content]))) (letvar1528773 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar1528773 ["NodeType" :content]))))))

(clojure.core/defn- deser-double-optional [input] (java.lang.Double. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-source-ids-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-schedule-definition-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cluster-parameter-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-parameter-status coll))) input))

(clojure.core/defn- deser-snapshot-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot coll))) input))

(clojure.core/defn- deser-associated-cluster-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-associated-to-schedule coll))) input))

(clojure.core/defn- deser-subnet [input] (clojure.core/let [letvar1528968 {"SubnetIdentifier" (portkey.aws/search-for-tag input "SubnetIdentifier" :flattened? nil :xmlAttribute? nil), "SubnetAvailabilityZone" (portkey.aws/search-for-tag input "SubnetAvailabilityZone" :flattened? nil :xmlAttribute? nil), "SubnetStatus" (portkey.aws/search-for-tag input "SubnetStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1528968 "SubnetIdentifier") (clojure.core/assoc :subnet-identifier (deser-string (clojure.core/get-in letvar1528968 ["SubnetIdentifier" :content]))) (letvar1528968 "SubnetAvailabilityZone") (clojure.core/assoc :subnet-availability-zone (deser-availability-zone (clojure.core/get-in letvar1528968 ["SubnetAvailabilityZone" :content]))) (letvar1528968 "SubnetStatus") (clojure.core/assoc :subnet-status (deser-string (clojure.core/get-in letvar1528968 ["SubnetStatus" :content]))))))

(clojure.core/defn- deser-attribute-value-target [input] (clojure.core/let [letvar1529076 {"AttributeValue" (portkey.aws/search-for-tag input "AttributeValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529076 "AttributeValue") (clojure.core/assoc :attribute-value (deser-string (clojure.core/get-in letvar1529076 ["AttributeValue" :content]))))))

(clojure.core/defn- deser-event-info-map-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event-info-map coll))) input))

(clojure.core/defn- deser-supported-platforms-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-supported-platform coll))) input))

(clojure.core/defn- deser-event-subscription [input] (clojure.core/let [letvar1529218 {"Severity" (portkey.aws/search-for-tag input "Severity" :flattened? nil :xmlAttribute? nil), "SourceIdsList" (portkey.aws/search-for-tag input "SourceIdsList" :flattened? nil :xmlAttribute? nil), "CustomerAwsId" (portkey.aws/search-for-tag input "CustomerAwsId" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Enabled" (portkey.aws/search-for-tag input "Enabled" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "SnsTopicArn" (portkey.aws/search-for-tag input "SnsTopicArn" :flattened? nil :xmlAttribute? nil), "EventCategoriesList" (portkey.aws/search-for-tag input "EventCategoriesList" :flattened? nil :xmlAttribute? nil), "CustSubscriptionId" (portkey.aws/search-for-tag input "CustSubscriptionId" :flattened? nil :xmlAttribute? nil), "SubscriptionCreationTime" (portkey.aws/search-for-tag input "SubscriptionCreationTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529218 "Severity") (clojure.core/assoc :severity (deser-string (clojure.core/get-in letvar1529218 ["Severity" :content]))) (letvar1529218 "SourceIdsList") (clojure.core/assoc :source-ids-list (deser-source-ids-list (clojure.core/get-in letvar1529218 ["SourceIdsList" :content]))) (letvar1529218 "CustomerAwsId") (clojure.core/assoc :customer-aws-id (deser-string (clojure.core/get-in letvar1529218 ["CustomerAwsId" :content]))) (letvar1529218 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1529218 ["Tags" :content]))) (letvar1529218 "SourceType") (clojure.core/assoc :source-type (deser-string (clojure.core/get-in letvar1529218 ["SourceType" :content]))) (letvar1529218 "Enabled") (clojure.core/assoc :enabled (deser-boolean (clojure.core/get-in letvar1529218 ["Enabled" :content]))) (letvar1529218 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1529218 ["Status" :content]))) (letvar1529218 "SnsTopicArn") (clojure.core/assoc :sns-topic-arn (deser-string (clojure.core/get-in letvar1529218 ["SnsTopicArn" :content]))) (letvar1529218 "EventCategoriesList") (clojure.core/assoc :event-categories-list (deser-event-categories-list (clojure.core/get-in letvar1529218 ["EventCategoriesList" :content]))) (letvar1529218 "CustSubscriptionId") (clojure.core/assoc :cust-subscription-id (deser-string (clojure.core/get-in letvar1529218 ["CustSubscriptionId" :content]))) (letvar1529218 "SubscriptionCreationTime") (clojure.core/assoc :subscription-creation-time (deser-t-stamp (clojure.core/get-in letvar1529218 ["SubscriptionCreationTime" :content]))))))

(clojure.core/defn- deser-cluster-snapshot-copy-status [input] (clojure.core/let [letvar1529326 {"DestinationRegion" (portkey.aws/search-for-tag input "DestinationRegion" :flattened? nil :xmlAttribute? nil), "RetentionPeriod" (portkey.aws/search-for-tag input "RetentionPeriod" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "ManualSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "SnapshotCopyGrantName" (portkey.aws/search-for-tag input "SnapshotCopyGrantName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529326 "DestinationRegion") (clojure.core/assoc :destination-region (deser-string (clojure.core/get-in letvar1529326 ["DestinationRegion" :content]))) (letvar1529326 "RetentionPeriod") (clojure.core/assoc :retention-period (deser-long (clojure.core/get-in letvar1529326 ["RetentionPeriod" :content]))) (letvar1529326 "ManualSnapshotRetentionPeriod") (clojure.core/assoc :manual-snapshot-retention-period (deser-integer (clojure.core/get-in letvar1529326 ["ManualSnapshotRetentionPeriod" :content]))) (letvar1529326 "SnapshotCopyGrantName") (clojure.core/assoc :snapshot-copy-grant-name (deser-string (clojure.core/get-in letvar1529326 ["SnapshotCopyGrantName" :content]))))))

(clojure.core/defn- deser-deferred-maintenance-windows-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-deferred-maintenance-window coll))) input))

(clojure.core/defn- deser-reserved-node-offering-type [input] (clojure.core/get {"Regular" :regular, "Upgradable" :upgradable} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-orderable-cluster-options-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-orderable-cluster-option coll))) input))

(clojure.core/defn- deser-supported-operation [input] (clojure.core/let [letvar1529473 {"OperationName" (portkey.aws/search-for-tag input "OperationName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529473 "OperationName") (clojure.core/assoc :operation-name (deser-string (clojure.core/get-in letvar1529473 ["OperationName" :content]))))))

(clojure.core/defn- deser-reserved-node-offering-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-node-offering coll))) input))

(clojure.core/defn- deser-parameter-apply-type [input] (clojure.core/get {"static" :static, "dynamic" :dynamic} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-ip-range-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ip-range coll))) input))

(clojure.core/defn- deser-snapshot-schedule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-schedule coll))) input))

(clojure.core/defn- deser-event-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event coll))) input))

(clojure.core/defn- deser-hsm-client-certificate [input] (clojure.core/let [letvar1529654 {"HsmClientCertificateIdentifier" (portkey.aws/search-for-tag input "HsmClientCertificateIdentifier" :flattened? nil :xmlAttribute? nil), "HsmClientCertificatePublicKey" (portkey.aws/search-for-tag input "HsmClientCertificatePublicKey" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529654 "HsmClientCertificateIdentifier") (clojure.core/assoc :hsm-client-certificate-identifier (deser-string (clojure.core/get-in letvar1529654 ["HsmClientCertificateIdentifier" :content]))) (letvar1529654 "HsmClientCertificatePublicKey") (clojure.core/assoc :hsm-client-certificate-public-key (deser-string (clojure.core/get-in letvar1529654 ["HsmClientCertificatePublicKey" :content]))) (letvar1529654 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1529654 ["Tags" :content]))))))

(clojure.core/defn- deser-source-type [input] (clojure.core/get {"cluster" :cluster, "cluster-parameter-group" :clusterparametergroup, "cluster-security-group" :clustersecuritygroup, "cluster-snapshot" :clustersnapshot} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-batch-snapshot-operation-error-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-error-message coll))) input))

(clojure.core/defn- deser-event [input] (clojure.core/let [letvar1529784 {"SourceIdentifier" (portkey.aws/search-for-tag input "SourceIdentifier" :flattened? nil :xmlAttribute? nil), "SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Message" (portkey.aws/search-for-tag input "Message" :flattened? nil :xmlAttribute? nil), "EventCategories" (portkey.aws/search-for-tag input "EventCategories" :flattened? nil :xmlAttribute? nil), "Severity" (portkey.aws/search-for-tag input "Severity" :flattened? nil :xmlAttribute? nil), "Date" (portkey.aws/search-for-tag input "Date" :flattened? nil :xmlAttribute? nil), "EventId" (portkey.aws/search-for-tag input "EventId" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529784 "SourceIdentifier") (clojure.core/assoc :source-identifier (deser-string (clojure.core/get-in letvar1529784 ["SourceIdentifier" :content]))) (letvar1529784 "SourceType") (clojure.core/assoc :source-type (deser-source-type (clojure.core/get-in letvar1529784 ["SourceType" :content]))) (letvar1529784 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1529784 ["Message" :content]))) (letvar1529784 "EventCategories") (clojure.core/assoc :event-categories (deser-event-categories-list (clojure.core/get-in letvar1529784 ["EventCategories" :content]))) (letvar1529784 "Severity") (clojure.core/assoc :severity (deser-string (clojure.core/get-in letvar1529784 ["Severity" :content]))) (letvar1529784 "Date") (clojure.core/assoc :date (deser-t-stamp (clojure.core/get-in letvar1529784 ["Date" :content]))) (letvar1529784 "EventId") (clojure.core/assoc :event-id (deser-string (clojure.core/get-in letvar1529784 ["EventId" :content]))))))

(clojure.core/defn- deser-availability-zone-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-availability-zone coll))) input))

(clojure.core/defn- deser-availability-zone [input] (clojure.core/let [letvar1529909 {"Name" (portkey.aws/search-for-tag input "Name" :flattened? nil :xmlAttribute? nil), "SupportedPlatforms" (portkey.aws/search-for-tag input "SupportedPlatforms" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1529909 "Name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1529909 ["Name" :content]))) (letvar1529909 "SupportedPlatforms") (clojure.core/assoc :supported-platforms (deser-supported-platforms-list (clojure.core/get-in letvar1529909 ["SupportedPlatforms" :content]))))))

(clojure.core/defn- deser-revision-targets-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-revision-target coll))) input))

(clojure.core/defn- deser-supported-platform [input] (clojure.core/let [letvar1530034 {"Name" (portkey.aws/search-for-tag input "Name" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530034 "Name") (clojure.core/assoc :name (deser-string (clojure.core/get-in letvar1530034 ["Name" :content]))))))

(clojure.core/defn- deser-sensitive-string [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-cluster-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster coll))) input))

(clojure.core/defn- deser-cluster-security-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-security-group coll))) input))

(clojure.core/defn- deser-recurring-charge [input] (clojure.core/let [letvar1530181 {"RecurringChargeAmount" (portkey.aws/search-for-tag input "RecurringChargeAmount" :flattened? nil :xmlAttribute? nil), "RecurringChargeFrequency" (portkey.aws/search-for-tag input "RecurringChargeFrequency" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530181 "RecurringChargeAmount") (clojure.core/assoc :recurring-charge-amount (deser-double (clojure.core/get-in letvar1530181 ["RecurringChargeAmount" :content]))) (letvar1530181 "RecurringChargeFrequency") (clojure.core/assoc :recurring-charge-frequency (deser-string (clojure.core/get-in letvar1530181 ["RecurringChargeFrequency" :content]))))))

(clojure.core/defn- deser-track-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-maintenance-track coll))) input))

(clojure.core/defn- deser-batch-snapshot-operation-errors [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-snapshot-error-message coll))) input))

(clojure.core/defn- deser-cluster-security-group-membership [input] (clojure.core/let [letvar1530323 {"ClusterSecurityGroupName" (portkey.aws/search-for-tag input "ClusterSecurityGroupName" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530323 "ClusterSecurityGroupName") (clojure.core/assoc :cluster-security-group-name (deser-string (clojure.core/get-in letvar1530323 ["ClusterSecurityGroupName" :content]))) (letvar1530323 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1530323 ["Status" :content]))))))

(clojure.core/defn- deser-cluster-iam-role [input] (clojure.core/let [letvar1530431 {"IamRoleArn" (portkey.aws/search-for-tag input "IamRoleArn" :flattened? nil :xmlAttribute? nil), "ApplyStatus" (portkey.aws/search-for-tag input "ApplyStatus" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530431 "IamRoleArn") (clojure.core/assoc :iam-role-arn (deser-string (clojure.core/get-in letvar1530431 ["IamRoleArn" :content]))) (letvar1530431 "ApplyStatus") (clojure.core/assoc :apply-status (deser-string (clojure.core/get-in letvar1530431 ["ApplyStatus" :content]))))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-cluster-db-revisions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-db-revision coll))) input))

(clojure.core/defn- deser-cluster [input] (clojure.core/let [letvar1530573 {"ClusterPublicKey" (portkey.aws/search-for-tag input "ClusterPublicKey" :flattened? nil :xmlAttribute? nil), "EnhancedVpcRouting" (portkey.aws/search-for-tag input "EnhancedVpcRouting" :flattened? nil :xmlAttribute? nil), "PubliclyAccessible" (portkey.aws/search-for-tag input "PubliclyAccessible" :flattened? nil :xmlAttribute? nil), "PreferredMaintenanceWindow" (portkey.aws/search-for-tag input "PreferredMaintenanceWindow" :flattened? nil :xmlAttribute? nil), "Encrypted" (portkey.aws/search-for-tag input "Encrypted" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "ClusterSnapshotCopyStatus" (portkey.aws/search-for-tag input "ClusterSnapshotCopyStatus" :flattened? nil :xmlAttribute? nil), "ClusterSubnetGroupName" (portkey.aws/search-for-tag input "ClusterSubnetGroupName" :flattened? nil :xmlAttribute? nil), "NumberOfNodes" (portkey.aws/search-for-tag input "NumberOfNodes" :flattened? nil :xmlAttribute? nil), "ElasticResizeNumberOfNodeOptions" (portkey.aws/search-for-tag input "ElasticResizeNumberOfNodeOptions" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "DBName" (portkey.aws/search-for-tag input "DBName" :flattened? nil :xmlAttribute? nil), "ClusterParameterGroups" (portkey.aws/search-for-tag input "ClusterParameterGroups" :flattened? nil :xmlAttribute? nil), "AvailabilityZone" (portkey.aws/search-for-tag input "AvailabilityZone" :flattened? nil :xmlAttribute? nil), "PendingActions" (portkey.aws/search-for-tag input "PendingActions" :flattened? nil :xmlAttribute? nil), "ClusterSecurityGroups" (portkey.aws/search-for-tag input "ClusterSecurityGroups" :flattened? nil :xmlAttribute? nil), "MasterUsername" (portkey.aws/search-for-tag input "MasterUsername" :flattened? nil :xmlAttribute? nil), "SnapshotScheduleState" (portkey.aws/search-for-tag input "SnapshotScheduleState" :flattened? nil :xmlAttribute? nil), "DataTransferProgress" (portkey.aws/search-for-tag input "DataTransferProgress" :flattened? nil :xmlAttribute? nil), "ClusterStatus" (portkey.aws/search-for-tag input "ClusterStatus" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil), "RestoreStatus" (portkey.aws/search-for-tag input "RestoreStatus" :flattened? nil :xmlAttribute? nil), "ClusterCreateTime" (portkey.aws/search-for-tag input "ClusterCreateTime" :flattened? nil :xmlAttribute? nil), "ClusterRevisionNumber" (portkey.aws/search-for-tag input "ClusterRevisionNumber" :flattened? nil :xmlAttribute? nil), "AllowVersionUpgrade" (portkey.aws/search-for-tag input "AllowVersionUpgrade" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "ManualSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ModifyStatus" (portkey.aws/search-for-tag input "ModifyStatus" :flattened? nil :xmlAttribute? nil), "Endpoint" (portkey.aws/search-for-tag input "Endpoint" :flattened? nil :xmlAttribute? nil), "AutomatedSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "AutomatedSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "IamRoles" (portkey.aws/search-for-tag input "IamRoles" :flattened? nil :xmlAttribute? nil), "ResizeInfo" (portkey.aws/search-for-tag input "ResizeInfo" :flattened? nil :xmlAttribute? nil), "VpcSecurityGroups" (portkey.aws/search-for-tag input "VpcSecurityGroups" :flattened? nil :xmlAttribute? nil), "SnapshotScheduleIdentifier" (portkey.aws/search-for-tag input "SnapshotScheduleIdentifier" :flattened? nil :xmlAttribute? nil), "DeferredMaintenanceWindows" (portkey.aws/search-for-tag input "DeferredMaintenanceWindows" :flattened? nil :xmlAttribute? nil), "ClusterNodes" (portkey.aws/search-for-tag input "ClusterNodes" :flattened? nil :xmlAttribute? nil), "HsmStatus" (portkey.aws/search-for-tag input "HsmStatus" :flattened? nil :xmlAttribute? nil), "ElasticIpStatus" (portkey.aws/search-for-tag input "ElasticIpStatus" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil), "PendingModifiedValues" (portkey.aws/search-for-tag input "PendingModifiedValues" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530573 "ClusterPublicKey") (clojure.core/assoc :cluster-public-key (deser-string (clojure.core/get-in letvar1530573 ["ClusterPublicKey" :content]))) (letvar1530573 "EnhancedVpcRouting") (clojure.core/assoc :enhanced-vpc-routing (deser-boolean (clojure.core/get-in letvar1530573 ["EnhancedVpcRouting" :content]))) (letvar1530573 "PubliclyAccessible") (clojure.core/assoc :publicly-accessible (deser-boolean (clojure.core/get-in letvar1530573 ["PubliclyAccessible" :content]))) (letvar1530573 "PreferredMaintenanceWindow") (clojure.core/assoc :preferred-maintenance-window (deser-string (clojure.core/get-in letvar1530573 ["PreferredMaintenanceWindow" :content]))) (letvar1530573 "Encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar1530573 ["Encrypted" :content]))) (letvar1530573 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar1530573 ["ClusterIdentifier" :content]))) (letvar1530573 "ClusterSnapshotCopyStatus") (clojure.core/assoc :cluster-snapshot-copy-status (deser-cluster-snapshot-copy-status (clojure.core/get-in letvar1530573 ["ClusterSnapshotCopyStatus" :content]))) (letvar1530573 "ClusterSubnetGroupName") (clojure.core/assoc :cluster-subnet-group-name (deser-string (clojure.core/get-in letvar1530573 ["ClusterSubnetGroupName" :content]))) (letvar1530573 "NumberOfNodes") (clojure.core/assoc :number-of-nodes (deser-integer (clojure.core/get-in letvar1530573 ["NumberOfNodes" :content]))) (letvar1530573 "ElasticResizeNumberOfNodeOptions") (clojure.core/assoc :elastic-resize-number-of-node-options (deser-string (clojure.core/get-in letvar1530573 ["ElasticResizeNumberOfNodeOptions" :content]))) (letvar1530573 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1530573 ["Tags" :content]))) (letvar1530573 "DBName") (clojure.core/assoc :db-name (deser-string (clojure.core/get-in letvar1530573 ["DBName" :content]))) (letvar1530573 "ClusterParameterGroups") (clojure.core/assoc :cluster-parameter-groups (deser-cluster-parameter-group-status-list (clojure.core/get-in letvar1530573 ["ClusterParameterGroups" :content]))) (letvar1530573 "AvailabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar1530573 ["AvailabilityZone" :content]))) (letvar1530573 "PendingActions") (clojure.core/assoc :pending-actions (deser-pending-actions-list (clojure.core/get-in letvar1530573 ["PendingActions" :content]))) (letvar1530573 "ClusterSecurityGroups") (clojure.core/assoc :cluster-security-groups (deser-cluster-security-group-membership-list (clojure.core/get-in letvar1530573 ["ClusterSecurityGroups" :content]))) (letvar1530573 "MasterUsername") (clojure.core/assoc :master-username (deser-string (clojure.core/get-in letvar1530573 ["MasterUsername" :content]))) (letvar1530573 "SnapshotScheduleState") (clojure.core/assoc :snapshot-schedule-state (deser-schedule-state (clojure.core/get-in letvar1530573 ["SnapshotScheduleState" :content]))) (letvar1530573 "DataTransferProgress") (clojure.core/assoc :data-transfer-progress (deser-data-transfer-progress (clojure.core/get-in letvar1530573 ["DataTransferProgress" :content]))) (letvar1530573 "ClusterStatus") (clojure.core/assoc :cluster-status (deser-string (clojure.core/get-in letvar1530573 ["ClusterStatus" :content]))) (letvar1530573 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar1530573 ["VpcId" :content]))) (letvar1530573 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar1530573 ["MaintenanceTrackName" :content]))) (letvar1530573 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar1530573 ["KmsKeyId" :content]))) (letvar1530573 "RestoreStatus") (clojure.core/assoc :restore-status (deser-restore-status (clojure.core/get-in letvar1530573 ["RestoreStatus" :content]))) (letvar1530573 "ClusterCreateTime") (clojure.core/assoc :cluster-create-time (deser-t-stamp (clojure.core/get-in letvar1530573 ["ClusterCreateTime" :content]))) (letvar1530573 "ClusterRevisionNumber") (clojure.core/assoc :cluster-revision-number (deser-string (clojure.core/get-in letvar1530573 ["ClusterRevisionNumber" :content]))) (letvar1530573 "AllowVersionUpgrade") (clojure.core/assoc :allow-version-upgrade (deser-boolean (clojure.core/get-in letvar1530573 ["AllowVersionUpgrade" :content]))) (letvar1530573 "ManualSnapshotRetentionPeriod") (clojure.core/assoc :manual-snapshot-retention-period (deser-integer (clojure.core/get-in letvar1530573 ["ManualSnapshotRetentionPeriod" :content]))) (letvar1530573 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar1530573 ["ClusterVersion" :content]))) (letvar1530573 "ModifyStatus") (clojure.core/assoc :modify-status (deser-string (clojure.core/get-in letvar1530573 ["ModifyStatus" :content]))) (letvar1530573 "Endpoint") (clojure.core/assoc :endpoint (deser-endpoint (clojure.core/get-in letvar1530573 ["Endpoint" :content]))) (letvar1530573 "AutomatedSnapshotRetentionPeriod") (clojure.core/assoc :automated-snapshot-retention-period (deser-integer (clojure.core/get-in letvar1530573 ["AutomatedSnapshotRetentionPeriod" :content]))) (letvar1530573 "IamRoles") (clojure.core/assoc :iam-roles (deser-cluster-iam-role-list (clojure.core/get-in letvar1530573 ["IamRoles" :content]))) (letvar1530573 "ResizeInfo") (clojure.core/assoc :resize-info (deser-resize-info (clojure.core/get-in letvar1530573 ["ResizeInfo" :content]))) (letvar1530573 "VpcSecurityGroups") (clojure.core/assoc :vpc-security-groups (deser-vpc-security-group-membership-list (clojure.core/get-in letvar1530573 ["VpcSecurityGroups" :content]))) (letvar1530573 "SnapshotScheduleIdentifier") (clojure.core/assoc :snapshot-schedule-identifier (deser-string (clojure.core/get-in letvar1530573 ["SnapshotScheduleIdentifier" :content]))) (letvar1530573 "DeferredMaintenanceWindows") (clojure.core/assoc :deferred-maintenance-windows (deser-deferred-maintenance-windows-list (clojure.core/get-in letvar1530573 ["DeferredMaintenanceWindows" :content]))) (letvar1530573 "ClusterNodes") (clojure.core/assoc :cluster-nodes (deser-cluster-nodes-list (clojure.core/get-in letvar1530573 ["ClusterNodes" :content]))) (letvar1530573 "HsmStatus") (clojure.core/assoc :hsm-status (deser-hsm-status (clojure.core/get-in letvar1530573 ["HsmStatus" :content]))) (letvar1530573 "ElasticIpStatus") (clojure.core/assoc :elastic-ip-status (deser-elastic-ip-status (clojure.core/get-in letvar1530573 ["ElasticIpStatus" :content]))) (letvar1530573 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar1530573 ["NodeType" :content]))) (letvar1530573 "PendingModifiedValues") (clojure.core/assoc :pending-modified-values (deser-pending-modified-values (clojure.core/get-in letvar1530573 ["PendingModifiedValues" :content]))))))

(clojure.core/defn- deser-hsm-client-certificate-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-hsm-client-certificate coll))) input))

(clojure.core/defn- deser-reserved-node-offering [input] (clojure.core/let [letvar1530698 {"CurrencyCode" (portkey.aws/search-for-tag input "CurrencyCode" :flattened? nil :xmlAttribute? nil), "FixedPrice" (portkey.aws/search-for-tag input "FixedPrice" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingType" (portkey.aws/search-for-tag input "ReservedNodeOfferingType" :flattened? nil :xmlAttribute? nil), "ReservedNodeOfferingId" (portkey.aws/search-for-tag input "ReservedNodeOfferingId" :flattened? nil :xmlAttribute? nil), "Duration" (portkey.aws/search-for-tag input "Duration" :flattened? nil :xmlAttribute? nil), "UsagePrice" (portkey.aws/search-for-tag input "UsagePrice" :flattened? nil :xmlAttribute? nil), "RecurringCharges" (portkey.aws/search-for-tag input "RecurringCharges" :flattened? nil :xmlAttribute? nil), "OfferingType" (portkey.aws/search-for-tag input "OfferingType" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530698 "CurrencyCode") (clojure.core/assoc :currency-code (deser-string (clojure.core/get-in letvar1530698 ["CurrencyCode" :content]))) (letvar1530698 "FixedPrice") (clojure.core/assoc :fixed-price (deser-double (clojure.core/get-in letvar1530698 ["FixedPrice" :content]))) (letvar1530698 "ReservedNodeOfferingType") (clojure.core/assoc :reserved-node-offering-type (deser-reserved-node-offering-type (clojure.core/get-in letvar1530698 ["ReservedNodeOfferingType" :content]))) (letvar1530698 "ReservedNodeOfferingId") (clojure.core/assoc :reserved-node-offering-id (deser-string (clojure.core/get-in letvar1530698 ["ReservedNodeOfferingId" :content]))) (letvar1530698 "Duration") (clojure.core/assoc :duration (deser-integer (clojure.core/get-in letvar1530698 ["Duration" :content]))) (letvar1530698 "UsagePrice") (clojure.core/assoc :usage-price (deser-double (clojure.core/get-in letvar1530698 ["UsagePrice" :content]))) (letvar1530698 "RecurringCharges") (clojure.core/assoc :recurring-charges (deser-recurring-charge-list (clojure.core/get-in letvar1530698 ["RecurringCharges" :content]))) (letvar1530698 "OfferingType") (clojure.core/assoc :offering-type (deser-string (clojure.core/get-in letvar1530698 ["OfferingType" :content]))) (letvar1530698 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar1530698 ["NodeType" :content]))))))

(clojure.core/defn- deser-accounts-with-restore-access-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-account-with-restore-access coll))) input))

(clojure.core/defn- deser-vpc-security-group-membership [input] (clojure.core/let [letvar1530823 {"VpcSecurityGroupId" (portkey.aws/search-for-tag input "VpcSecurityGroupId" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530823 "VpcSecurityGroupId") (clojure.core/assoc :vpc-security-group-id (deser-string (clojure.core/get-in letvar1530823 ["VpcSecurityGroupId" :content]))) (letvar1530823 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1530823 ["Status" :content]))))))

(clojure.core/defn- deser-event-info-map [input] (clojure.core/let [letvar1530931 {"EventId" (portkey.aws/search-for-tag input "EventId" :flattened? nil :xmlAttribute? nil), "EventCategories" (portkey.aws/search-for-tag input "EventCategories" :flattened? nil :xmlAttribute? nil), "EventDescription" (portkey.aws/search-for-tag input "EventDescription" :flattened? nil :xmlAttribute? nil), "Severity" (portkey.aws/search-for-tag input "Severity" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1530931 "EventId") (clojure.core/assoc :event-id (deser-string (clojure.core/get-in letvar1530931 ["EventId" :content]))) (letvar1530931 "EventCategories") (clojure.core/assoc :event-categories (deser-event-categories-list (clojure.core/get-in letvar1530931 ["EventCategories" :content]))) (letvar1530931 "EventDescription") (clojure.core/assoc :event-description (deser-string (clojure.core/get-in letvar1530931 ["EventDescription" :content]))) (letvar1530931 "Severity") (clojure.core/assoc :severity (deser-string (clojure.core/get-in letvar1530931 ["Severity" :content]))))))

(clojure.core/defn- deser-update-target [input] (clojure.core/let [letvar1531039 {"MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "DatabaseVersion" (portkey.aws/search-for-tag input "DatabaseVersion" :flattened? nil :xmlAttribute? nil), "SupportedOperations" (portkey.aws/search-for-tag input "SupportedOperations" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531039 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar1531039 ["MaintenanceTrackName" :content]))) (letvar1531039 "DatabaseVersion") (clojure.core/assoc :database-version (deser-string (clojure.core/get-in letvar1531039 ["DatabaseVersion" :content]))) (letvar1531039 "SupportedOperations") (clojure.core/assoc :supported-operations (deser-supported-operation-list (clojure.core/get-in letvar1531039 ["SupportedOperations" :content]))))))

(clojure.core/defn- deser-data-transfer-progress [input] (clojure.core/let [letvar1531147 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "CurrentRateInMegaBytesPerSecond" (portkey.aws/search-for-tag input "CurrentRateInMegaBytesPerSecond" :flattened? nil :xmlAttribute? nil), "TotalDataInMegaBytes" (portkey.aws/search-for-tag input "TotalDataInMegaBytes" :flattened? nil :xmlAttribute? nil), "DataTransferredInMegaBytes" (portkey.aws/search-for-tag input "DataTransferredInMegaBytes" :flattened? nil :xmlAttribute? nil), "EstimatedTimeToCompletionInSeconds" (portkey.aws/search-for-tag input "EstimatedTimeToCompletionInSeconds" :flattened? nil :xmlAttribute? nil), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag input "ElapsedTimeInSeconds" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531147 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1531147 ["Status" :content]))) (letvar1531147 "CurrentRateInMegaBytesPerSecond") (clojure.core/assoc :current-rate-in-mega-bytes-per-second (deser-double-optional (clojure.core/get-in letvar1531147 ["CurrentRateInMegaBytesPerSecond" :content]))) (letvar1531147 "TotalDataInMegaBytes") (clojure.core/assoc :total-data-in-mega-bytes (deser-long (clojure.core/get-in letvar1531147 ["TotalDataInMegaBytes" :content]))) (letvar1531147 "DataTransferredInMegaBytes") (clojure.core/assoc :data-transferred-in-mega-bytes (deser-long (clojure.core/get-in letvar1531147 ["DataTransferredInMegaBytes" :content]))) (letvar1531147 "EstimatedTimeToCompletionInSeconds") (clojure.core/assoc :estimated-time-to-completion-in-seconds (deser-long-optional (clojure.core/get-in letvar1531147 ["EstimatedTimeToCompletionInSeconds" :content]))) (letvar1531147 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long-optional (clojure.core/get-in letvar1531147 ["ElapsedTimeInSeconds" :content]))))))

(clojure.core/defn- deser-pending-actions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-snapshot-identifier-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-ec-2-security-group [input] (clojure.core/let [letvar1531289 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroupName" (portkey.aws/search-for-tag input "EC2SecurityGroupName" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroupOwnerId" (portkey.aws/search-for-tag input "EC2SecurityGroupOwnerId" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531289 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1531289 ["Status" :content]))) (letvar1531289 "EC2SecurityGroupName") (clojure.core/assoc :ec-2-security-group-name (deser-string (clojure.core/get-in letvar1531289 ["EC2SecurityGroupName" :content]))) (letvar1531289 "EC2SecurityGroupOwnerId") (clojure.core/assoc :ec-2-security-group-owner-id (deser-string (clojure.core/get-in letvar1531289 ["EC2SecurityGroupOwnerId" :content]))) (letvar1531289 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1531289 ["Tags" :content]))))))

(clojure.core/defn- deser-event-categories-map-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event-categories-map coll))) input))

(clojure.core/defn- deser-integer [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-string [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-parameter [input] (clojure.core/let [letvar1531421 {"DataType" (portkey.aws/search-for-tag input "DataType" :flattened? nil :xmlAttribute? nil), "ParameterName" (portkey.aws/search-for-tag input "ParameterName" :flattened? nil :xmlAttribute? nil), "Source" (portkey.aws/search-for-tag input "Source" :flattened? nil :xmlAttribute? nil), "MinimumEngineVersion" (portkey.aws/search-for-tag input "MinimumEngineVersion" :flattened? nil :xmlAttribute? nil), "AllowedValues" (portkey.aws/search-for-tag input "AllowedValues" :flattened? nil :xmlAttribute? nil), "ApplyType" (portkey.aws/search-for-tag input "ApplyType" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "IsModifiable" (portkey.aws/search-for-tag input "IsModifiable" :flattened? nil :xmlAttribute? nil), "ParameterValue" (portkey.aws/search-for-tag input "ParameterValue" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531421 "DataType") (clojure.core/assoc :data-type (deser-string (clojure.core/get-in letvar1531421 ["DataType" :content]))) (letvar1531421 "ParameterName") (clojure.core/assoc :parameter-name (deser-string (clojure.core/get-in letvar1531421 ["ParameterName" :content]))) (letvar1531421 "Source") (clojure.core/assoc :source (deser-string (clojure.core/get-in letvar1531421 ["Source" :content]))) (letvar1531421 "MinimumEngineVersion") (clojure.core/assoc :minimum-engine-version (deser-string (clojure.core/get-in letvar1531421 ["MinimumEngineVersion" :content]))) (letvar1531421 "AllowedValues") (clojure.core/assoc :allowed-values (deser-string (clojure.core/get-in letvar1531421 ["AllowedValues" :content]))) (letvar1531421 "ApplyType") (clojure.core/assoc :apply-type (deser-parameter-apply-type (clojure.core/get-in letvar1531421 ["ApplyType" :content]))) (letvar1531421 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1531421 ["Description" :content]))) (letvar1531421 "IsModifiable") (clojure.core/assoc :is-modifiable (deser-boolean (clojure.core/get-in letvar1531421 ["IsModifiable" :content]))) (letvar1531421 "ParameterValue") (clojure.core/assoc :parameter-value (deser-string (clojure.core/get-in letvar1531421 ["ParameterValue" :content]))))))

(clojure.core/defn- deser-cluster-parameter-status [input] (clojure.core/let [letvar1531529 {"ParameterName" (portkey.aws/search-for-tag input "ParameterName" :flattened? nil :xmlAttribute? nil), "ParameterApplyStatus" (portkey.aws/search-for-tag input "ParameterApplyStatus" :flattened? nil :xmlAttribute? nil), "ParameterApplyErrorDescription" (portkey.aws/search-for-tag input "ParameterApplyErrorDescription" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531529 "ParameterName") (clojure.core/assoc :parameter-name (deser-string (clojure.core/get-in letvar1531529 ["ParameterName" :content]))) (letvar1531529 "ParameterApplyStatus") (clojure.core/assoc :parameter-apply-status (deser-string (clojure.core/get-in letvar1531529 ["ParameterApplyStatus" :content]))) (letvar1531529 "ParameterApplyErrorDescription") (clojure.core/assoc :parameter-apply-error-description (deser-string (clojure.core/get-in letvar1531529 ["ParameterApplyErrorDescription" :content]))))))

(clojure.core/defn- deser-cluster-parameter-group-status [input] (clojure.core/let [letvar1531637 {"ParameterGroupName" (portkey.aws/search-for-tag input "ParameterGroupName" :flattened? nil :xmlAttribute? nil), "ParameterApplyStatus" (portkey.aws/search-for-tag input "ParameterApplyStatus" :flattened? nil :xmlAttribute? nil), "ClusterParameterStatusList" (portkey.aws/search-for-tag input "ClusterParameterStatusList" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531637 "ParameterGroupName") (clojure.core/assoc :parameter-group-name (deser-string (clojure.core/get-in letvar1531637 ["ParameterGroupName" :content]))) (letvar1531637 "ParameterApplyStatus") (clojure.core/assoc :parameter-apply-status (deser-string (clojure.core/get-in letvar1531637 ["ParameterApplyStatus" :content]))) (letvar1531637 "ClusterParameterStatusList") (clojure.core/assoc :cluster-parameter-status-list (deser-cluster-parameter-status-list (clojure.core/get-in letvar1531637 ["ClusterParameterStatusList" :content]))))))

(clojure.core/defn- deser-cluster-security-group-membership-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-security-group-membership coll))) input))

(clojure.core/defn- deser-restore-status [input] (clojure.core/let [letvar1531762 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "CurrentRestoreRateInMegaBytesPerSecond" (portkey.aws/search-for-tag input "CurrentRestoreRateInMegaBytesPerSecond" :flattened? nil :xmlAttribute? nil), "SnapshotSizeInMegaBytes" (portkey.aws/search-for-tag input "SnapshotSizeInMegaBytes" :flattened? nil :xmlAttribute? nil), "ProgressInMegaBytes" (portkey.aws/search-for-tag input "ProgressInMegaBytes" :flattened? nil :xmlAttribute? nil), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag input "ElapsedTimeInSeconds" :flattened? nil :xmlAttribute? nil), "EstimatedTimeToCompletionInSeconds" (portkey.aws/search-for-tag input "EstimatedTimeToCompletionInSeconds" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531762 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1531762 ["Status" :content]))) (letvar1531762 "CurrentRestoreRateInMegaBytesPerSecond") (clojure.core/assoc :current-restore-rate-in-mega-bytes-per-second (deser-double (clojure.core/get-in letvar1531762 ["CurrentRestoreRateInMegaBytesPerSecond" :content]))) (letvar1531762 "SnapshotSizeInMegaBytes") (clojure.core/assoc :snapshot-size-in-mega-bytes (deser-long (clojure.core/get-in letvar1531762 ["SnapshotSizeInMegaBytes" :content]))) (letvar1531762 "ProgressInMegaBytes") (clojure.core/assoc :progress-in-mega-bytes (deser-long (clojure.core/get-in letvar1531762 ["ProgressInMegaBytes" :content]))) (letvar1531762 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long (clojure.core/get-in letvar1531762 ["ElapsedTimeInSeconds" :content]))) (letvar1531762 "EstimatedTimeToCompletionInSeconds") (clojure.core/assoc :estimated-time-to-completion-in-seconds (deser-long (clojure.core/get-in letvar1531762 ["EstimatedTimeToCompletionInSeconds" :content]))))))

(clojure.core/defn- deser-snapshot [input] (clojure.core/let [letvar1531870 {"SnapshotIdentifier" (portkey.aws/search-for-tag input "SnapshotIdentifier" :flattened? nil :xmlAttribute? nil), "RestorableNodeTypes" (portkey.aws/search-for-tag input "RestorableNodeTypes" :flattened? nil :xmlAttribute? nil), "SnapshotCreateTime" (portkey.aws/search-for-tag input "SnapshotCreateTime" :flattened? nil :xmlAttribute? nil), "EnhancedVpcRouting" (portkey.aws/search-for-tag input "EnhancedVpcRouting" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRemainingDays" (portkey.aws/search-for-tag input "ManualSnapshotRemainingDays" :flattened? nil :xmlAttribute? nil), "SourceRegion" (portkey.aws/search-for-tag input "SourceRegion" :flattened? nil :xmlAttribute? nil), "EncryptedWithHSM" (portkey.aws/search-for-tag input "EncryptedWithHSM" :flattened? nil :xmlAttribute? nil), "Encrypted" (portkey.aws/search-for-tag input "Encrypted" :flattened? nil :xmlAttribute? nil), "OwnerAccount" (portkey.aws/search-for-tag input "OwnerAccount" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "NumberOfNodes" (portkey.aws/search-for-tag input "NumberOfNodes" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "DBName" (portkey.aws/search-for-tag input "DBName" :flattened? nil :xmlAttribute? nil), "EstimatedSecondsToCompletion" (portkey.aws/search-for-tag input "EstimatedSecondsToCompletion" :flattened? nil :xmlAttribute? nil), "AvailabilityZone" (portkey.aws/search-for-tag input "AvailabilityZone" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "SnapshotType" (portkey.aws/search-for-tag input "SnapshotType" :flattened? nil :xmlAttribute? nil), "ActualIncrementalBackupSizeInMegaBytes" (portkey.aws/search-for-tag input "ActualIncrementalBackupSizeInMegaBytes" :flattened? nil :xmlAttribute? nil), "MasterUsername" (portkey.aws/search-for-tag input "MasterUsername" :flattened? nil :xmlAttribute? nil), "BackupProgressInMegaBytes" (portkey.aws/search-for-tag input "BackupProgressInMegaBytes" :flattened? nil :xmlAttribute? nil), "AccountsWithRestoreAccess" (portkey.aws/search-for-tag input "AccountsWithRestoreAccess" :flattened? nil :xmlAttribute? nil), "Port" (portkey.aws/search-for-tag input "Port" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil), "ClusterCreateTime" (portkey.aws/search-for-tag input "ClusterCreateTime" :flattened? nil :xmlAttribute? nil), "ManualSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "ManualSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag input "ElapsedTimeInSeconds" :flattened? nil :xmlAttribute? nil), "SnapshotRetentionStartTime" (portkey.aws/search-for-tag input "SnapshotRetentionStartTime" :flattened? nil :xmlAttribute? nil), "CurrentBackupRateInMegaBytesPerSecond" (portkey.aws/search-for-tag input "CurrentBackupRateInMegaBytesPerSecond" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil), "TotalBackupSizeInMegaBytes" (portkey.aws/search-for-tag input "TotalBackupSizeInMegaBytes" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531870 "SnapshotIdentifier") (clojure.core/assoc :snapshot-identifier (deser-string (clojure.core/get-in letvar1531870 ["SnapshotIdentifier" :content]))) (letvar1531870 "RestorableNodeTypes") (clojure.core/assoc :restorable-node-types (deser-restorable-node-type-list (clojure.core/get-in letvar1531870 ["RestorableNodeTypes" :content]))) (letvar1531870 "SnapshotCreateTime") (clojure.core/assoc :snapshot-create-time (deser-t-stamp (clojure.core/get-in letvar1531870 ["SnapshotCreateTime" :content]))) (letvar1531870 "EnhancedVpcRouting") (clojure.core/assoc :enhanced-vpc-routing (deser-boolean (clojure.core/get-in letvar1531870 ["EnhancedVpcRouting" :content]))) (letvar1531870 "ManualSnapshotRemainingDays") (clojure.core/assoc :manual-snapshot-remaining-days (deser-integer-optional (clojure.core/get-in letvar1531870 ["ManualSnapshotRemainingDays" :content]))) (letvar1531870 "SourceRegion") (clojure.core/assoc :source-region (deser-string (clojure.core/get-in letvar1531870 ["SourceRegion" :content]))) (letvar1531870 "EncryptedWithHSM") (clojure.core/assoc :encrypted-with-hsm (deser-boolean (clojure.core/get-in letvar1531870 ["EncryptedWithHSM" :content]))) (letvar1531870 "Encrypted") (clojure.core/assoc :encrypted (deser-boolean (clojure.core/get-in letvar1531870 ["Encrypted" :content]))) (letvar1531870 "OwnerAccount") (clojure.core/assoc :owner-account (deser-string (clojure.core/get-in letvar1531870 ["OwnerAccount" :content]))) (letvar1531870 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar1531870 ["ClusterIdentifier" :content]))) (letvar1531870 "NumberOfNodes") (clojure.core/assoc :number-of-nodes (deser-integer (clojure.core/get-in letvar1531870 ["NumberOfNodes" :content]))) (letvar1531870 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1531870 ["Tags" :content]))) (letvar1531870 "DBName") (clojure.core/assoc :db-name (deser-string (clojure.core/get-in letvar1531870 ["DBName" :content]))) (letvar1531870 "EstimatedSecondsToCompletion") (clojure.core/assoc :estimated-seconds-to-completion (deser-long (clojure.core/get-in letvar1531870 ["EstimatedSecondsToCompletion" :content]))) (letvar1531870 "AvailabilityZone") (clojure.core/assoc :availability-zone (deser-string (clojure.core/get-in letvar1531870 ["AvailabilityZone" :content]))) (letvar1531870 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1531870 ["Status" :content]))) (letvar1531870 "SnapshotType") (clojure.core/assoc :snapshot-type (deser-string (clojure.core/get-in letvar1531870 ["SnapshotType" :content]))) (letvar1531870 "ActualIncrementalBackupSizeInMegaBytes") (clojure.core/assoc :actual-incremental-backup-size-in-mega-bytes (deser-double (clojure.core/get-in letvar1531870 ["ActualIncrementalBackupSizeInMegaBytes" :content]))) (letvar1531870 "MasterUsername") (clojure.core/assoc :master-username (deser-string (clojure.core/get-in letvar1531870 ["MasterUsername" :content]))) (letvar1531870 "BackupProgressInMegaBytes") (clojure.core/assoc :backup-progress-in-mega-bytes (deser-double (clojure.core/get-in letvar1531870 ["BackupProgressInMegaBytes" :content]))) (letvar1531870 "AccountsWithRestoreAccess") (clojure.core/assoc :accounts-with-restore-access (deser-accounts-with-restore-access-list (clojure.core/get-in letvar1531870 ["AccountsWithRestoreAccess" :content]))) (letvar1531870 "Port") (clojure.core/assoc :port (deser-integer (clojure.core/get-in letvar1531870 ["Port" :content]))) (letvar1531870 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar1531870 ["VpcId" :content]))) (letvar1531870 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar1531870 ["MaintenanceTrackName" :content]))) (letvar1531870 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar1531870 ["KmsKeyId" :content]))) (letvar1531870 "ClusterCreateTime") (clojure.core/assoc :cluster-create-time (deser-t-stamp (clojure.core/get-in letvar1531870 ["ClusterCreateTime" :content]))) (letvar1531870 "ManualSnapshotRetentionPeriod") (clojure.core/assoc :manual-snapshot-retention-period (deser-integer-optional (clojure.core/get-in letvar1531870 ["ManualSnapshotRetentionPeriod" :content]))) (letvar1531870 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar1531870 ["ClusterVersion" :content]))) (letvar1531870 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long (clojure.core/get-in letvar1531870 ["ElapsedTimeInSeconds" :content]))) (letvar1531870 "SnapshotRetentionStartTime") (clojure.core/assoc :snapshot-retention-start-time (deser-t-stamp (clojure.core/get-in letvar1531870 ["SnapshotRetentionStartTime" :content]))) (letvar1531870 "CurrentBackupRateInMegaBytesPerSecond") (clojure.core/assoc :current-backup-rate-in-mega-bytes-per-second (deser-double (clojure.core/get-in letvar1531870 ["CurrentBackupRateInMegaBytesPerSecond" :content]))) (letvar1531870 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar1531870 ["NodeType" :content]))) (letvar1531870 "TotalBackupSizeInMegaBytes") (clojure.core/assoc :total-backup-size-in-mega-bytes (deser-double (clojure.core/get-in letvar1531870 ["TotalBackupSizeInMegaBytes" :content]))))))

(clojure.core/defn- deser-t-stamp [input] (portkey.aws/unbox-xml-primitive-value input))

(clojure.core/defn- deser-cluster-subnet-groups [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-subnet-group coll))) input))

(clojure.core/defn- deser-event-categories-map [input] (clojure.core/let [letvar1531997 {"SourceType" (portkey.aws/search-for-tag input "SourceType" :flattened? nil :xmlAttribute? nil), "Events" (portkey.aws/search-for-tag input "Events" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1531997 "SourceType") (clojure.core/assoc :source-type (deser-string (clojure.core/get-in letvar1531997 ["SourceType" :content]))) (letvar1531997 "Events") (clojure.core/assoc :events (deser-event-info-map-list (clojure.core/get-in letvar1531997 ["Events" :content]))))))

(clojure.core/defn- deser-cluster-parameter-group-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-parameter-group-status coll))) input))

(clojure.core/defn- deser-recurring-charge-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-recurring-charge coll))) input))

(clojure.core/defn- deser-event-categories-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-account-with-restore-access [input] (clojure.core/let [letvar1532156 {"AccountId" (portkey.aws/search-for-tag input "AccountId" :flattened? nil :xmlAttribute? nil), "AccountAlias" (portkey.aws/search-for-tag input "AccountAlias" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532156 "AccountId") (clojure.core/assoc :account-id (deser-string (clojure.core/get-in letvar1532156 ["AccountId" :content]))) (letvar1532156 "AccountAlias") (clojure.core/assoc :account-alias (deser-string (clojure.core/get-in letvar1532156 ["AccountAlias" :content]))))))

(clojure.core/defn- deser-table-restore-status-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-table-restore-status coll))) input))

(clojure.core/defn- deser-cluster-version [input] (clojure.core/let [letvar1532281 {"ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ClusterParameterGroupFamily" (portkey.aws/search-for-tag input "ClusterParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532281 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar1532281 ["ClusterVersion" :content]))) (letvar1532281 "ClusterParameterGroupFamily") (clojure.core/assoc :cluster-parameter-group-family (deser-string (clojure.core/get-in letvar1532281 ["ClusterParameterGroupFamily" :content]))) (letvar1532281 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1532281 ["Description" :content]))))))

(clojure.core/defn- deser-snapshot-schedule [input] (clojure.core/let [letvar1532389 {"ScheduleDefinitions" (portkey.aws/search-for-tag input "ScheduleDefinitions" :flattened? nil :xmlAttribute? nil), "ScheduleIdentifier" (portkey.aws/search-for-tag input "ScheduleIdentifier" :flattened? nil :xmlAttribute? nil), "ScheduleDescription" (portkey.aws/search-for-tag input "ScheduleDescription" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil), "NextInvocations" (portkey.aws/search-for-tag input "NextInvocations" :flattened? nil :xmlAttribute? nil), "AssociatedClusterCount" (portkey.aws/search-for-tag input "AssociatedClusterCount" :flattened? nil :xmlAttribute? nil), "AssociatedClusters" (portkey.aws/search-for-tag input "AssociatedClusters" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532389 "ScheduleDefinitions") (clojure.core/assoc :schedule-definitions (deser-schedule-definition-list (clojure.core/get-in letvar1532389 ["ScheduleDefinitions" :content]))) (letvar1532389 "ScheduleIdentifier") (clojure.core/assoc :schedule-identifier (deser-string (clojure.core/get-in letvar1532389 ["ScheduleIdentifier" :content]))) (letvar1532389 "ScheduleDescription") (clojure.core/assoc :schedule-description (deser-string (clojure.core/get-in letvar1532389 ["ScheduleDescription" :content]))) (letvar1532389 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1532389 ["Tags" :content]))) (letvar1532389 "NextInvocations") (clojure.core/assoc :next-invocations (deser-scheduled-snapshot-time-list (clojure.core/get-in letvar1532389 ["NextInvocations" :content]))) (letvar1532389 "AssociatedClusterCount") (clojure.core/assoc :associated-cluster-count (deser-integer-optional (clojure.core/get-in letvar1532389 ["AssociatedClusterCount" :content]))) (letvar1532389 "AssociatedClusters") (clojure.core/assoc :associated-clusters (deser-associated-cluster-list (clojure.core/get-in letvar1532389 ["AssociatedClusters" :content]))))))

(clojure.core/defn- deser-endpoint [input] (clojure.core/let [letvar1532497 {"Address" (portkey.aws/search-for-tag input "Address" :flattened? nil :xmlAttribute? nil), "Port" (portkey.aws/search-for-tag input "Port" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532497 "Address") (clojure.core/assoc :address (deser-string (clojure.core/get-in letvar1532497 ["Address" :content]))) (letvar1532497 "Port") (clojure.core/assoc :port (deser-integer (clojure.core/get-in letvar1532497 ["Port" :content]))))))

(clojure.core/defn- deser-table-restore-status [input] (clojure.core/let [letvar1532605 {"SnapshotIdentifier" (portkey.aws/search-for-tag input "SnapshotIdentifier" :flattened? nil :xmlAttribute? nil), "TargetSchemaName" (portkey.aws/search-for-tag input "TargetSchemaName" :flattened? nil :xmlAttribute? nil), "SourceSchemaName" (portkey.aws/search-for-tag input "SourceSchemaName" :flattened? nil :xmlAttribute? nil), "TotalDataInMegaBytes" (portkey.aws/search-for-tag input "TotalDataInMegaBytes" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "RequestTime" (portkey.aws/search-for-tag input "RequestTime" :flattened? nil :xmlAttribute? nil), "NewTableName" (portkey.aws/search-for-tag input "NewTableName" :flattened? nil :xmlAttribute? nil), "ProgressInMegaBytes" (portkey.aws/search-for-tag input "ProgressInMegaBytes" :flattened? nil :xmlAttribute? nil), "SourceDatabaseName" (portkey.aws/search-for-tag input "SourceDatabaseName" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "Message" (portkey.aws/search-for-tag input "Message" :flattened? nil :xmlAttribute? nil), "SourceTableName" (portkey.aws/search-for-tag input "SourceTableName" :flattened? nil :xmlAttribute? nil), "TableRestoreRequestId" (portkey.aws/search-for-tag input "TableRestoreRequestId" :flattened? nil :xmlAttribute? nil), "TargetDatabaseName" (portkey.aws/search-for-tag input "TargetDatabaseName" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532605 "SnapshotIdentifier") (clojure.core/assoc :snapshot-identifier (deser-string (clojure.core/get-in letvar1532605 ["SnapshotIdentifier" :content]))) (letvar1532605 "TargetSchemaName") (clojure.core/assoc :target-schema-name (deser-string (clojure.core/get-in letvar1532605 ["TargetSchemaName" :content]))) (letvar1532605 "SourceSchemaName") (clojure.core/assoc :source-schema-name (deser-string (clojure.core/get-in letvar1532605 ["SourceSchemaName" :content]))) (letvar1532605 "TotalDataInMegaBytes") (clojure.core/assoc :total-data-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar1532605 ["TotalDataInMegaBytes" :content]))) (letvar1532605 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar1532605 ["ClusterIdentifier" :content]))) (letvar1532605 "RequestTime") (clojure.core/assoc :request-time (deser-t-stamp (clojure.core/get-in letvar1532605 ["RequestTime" :content]))) (letvar1532605 "NewTableName") (clojure.core/assoc :new-table-name (deser-string (clojure.core/get-in letvar1532605 ["NewTableName" :content]))) (letvar1532605 "ProgressInMegaBytes") (clojure.core/assoc :progress-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar1532605 ["ProgressInMegaBytes" :content]))) (letvar1532605 "SourceDatabaseName") (clojure.core/assoc :source-database-name (deser-string (clojure.core/get-in letvar1532605 ["SourceDatabaseName" :content]))) (letvar1532605 "Status") (clojure.core/assoc :status (deser-table-restore-status-type (clojure.core/get-in letvar1532605 ["Status" :content]))) (letvar1532605 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1532605 ["Message" :content]))) (letvar1532605 "SourceTableName") (clojure.core/assoc :source-table-name (deser-string (clojure.core/get-in letvar1532605 ["SourceTableName" :content]))) (letvar1532605 "TableRestoreRequestId") (clojure.core/assoc :table-restore-request-id (deser-string (clojure.core/get-in letvar1532605 ["TableRestoreRequestId" :content]))) (letvar1532605 "TargetDatabaseName") (clojure.core/assoc :target-database-name (deser-string (clojure.core/get-in letvar1532605 ["TargetDatabaseName" :content]))))))

(clojure.core/defn- deser-long [input] (java.lang.Long. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-import-tables-completed [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-reserved-node-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-reserved-node coll))) input))

(clojure.core/defn- deser-import-tables-in-progress [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-snapshot-error-message [input] (clojure.core/let [letvar1532766 {"SnapshotIdentifier" (portkey.aws/search-for-tag input "SnapshotIdentifier" :flattened? nil :xmlAttribute? nil), "SnapshotClusterIdentifier" (portkey.aws/search-for-tag input "SnapshotClusterIdentifier" :flattened? nil :xmlAttribute? nil), "FailureCode" (portkey.aws/search-for-tag input "FailureCode" :flattened? nil :xmlAttribute? nil), "FailureReason" (portkey.aws/search-for-tag input "FailureReason" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532766 "SnapshotIdentifier") (clojure.core/assoc :snapshot-identifier (deser-string (clojure.core/get-in letvar1532766 ["SnapshotIdentifier" :content]))) (letvar1532766 "SnapshotClusterIdentifier") (clojure.core/assoc :snapshot-cluster-identifier (deser-string (clojure.core/get-in letvar1532766 ["SnapshotClusterIdentifier" :content]))) (letvar1532766 "FailureCode") (clojure.core/assoc :failure-code (deser-string (clojure.core/get-in letvar1532766 ["FailureCode" :content]))) (letvar1532766 "FailureReason") (clojure.core/assoc :failure-reason (deser-string (clojure.core/get-in letvar1532766 ["FailureReason" :content]))))))

(clojure.core/defn- deser-attribute-value-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attribute-value-target coll))) input))

(clojure.core/defn- deser-ip-range [input] (clojure.core/let [letvar1532891 {"Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil), "CIDRIP" (portkey.aws/search-for-tag input "CIDRIP" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532891 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1532891 ["Status" :content]))) (letvar1532891 "CIDRIP") (clojure.core/assoc :cidrip (deser-string (clojure.core/get-in letvar1532891 ["CIDRIP" :content]))) (letvar1532891 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1532891 ["Tags" :content]))))))

(clojure.core/defn- deser-cluster-subnet-group [input] (clojure.core/let [letvar1532999 {"ClusterSubnetGroupName" (portkey.aws/search-for-tag input "ClusterSubnetGroupName" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "VpcId" (portkey.aws/search-for-tag input "VpcId" :flattened? nil :xmlAttribute? nil), "SubnetGroupStatus" (portkey.aws/search-for-tag input "SubnetGroupStatus" :flattened? nil :xmlAttribute? nil), "Subnets" (portkey.aws/search-for-tag input "Subnets" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1532999 "ClusterSubnetGroupName") (clojure.core/assoc :cluster-subnet-group-name (deser-string (clojure.core/get-in letvar1532999 ["ClusterSubnetGroupName" :content]))) (letvar1532999 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1532999 ["Description" :content]))) (letvar1532999 "VpcId") (clojure.core/assoc :vpc-id (deser-string (clojure.core/get-in letvar1532999 ["VpcId" :content]))) (letvar1532999 "SubnetGroupStatus") (clojure.core/assoc :subnet-group-status (deser-string (clojure.core/get-in letvar1532999 ["SubnetGroupStatus" :content]))) (letvar1532999 "Subnets") (clojure.core/assoc :subnets (deser-subnet-list (clojure.core/get-in letvar1532999 ["Subnets" :content]))) (letvar1532999 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1532999 ["Tags" :content]))))))

(clojure.core/defn- deser-cluster-nodes-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-node coll))) input))

(clojure.core/defn- deser-resize-info [input] (clojure.core/let [letvar1533124 {"ResizeType" (portkey.aws/search-for-tag input "ResizeType" :flattened? nil :xmlAttribute? nil), "AllowCancelResize" (portkey.aws/search-for-tag input "AllowCancelResize" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533124 "ResizeType") (clojure.core/assoc :resize-type (deser-string (clojure.core/get-in letvar1533124 ["ResizeType" :content]))) (letvar1533124 "AllowCancelResize") (clojure.core/assoc :allow-cancel-resize (deser-boolean (clojure.core/get-in letvar1533124 ["AllowCancelResize" :content]))))))

(clojure.core/defn- deser-tag [input] (clojure.core/let [letvar1533232 {"Key" (portkey.aws/search-for-tag input "Key" :flattened? nil :xmlAttribute? nil), "Value" (portkey.aws/search-for-tag input "Value" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533232 "Key") (clojure.core/assoc :key (deser-string (clojure.core/get-in letvar1533232 ["Key" :content]))) (letvar1533232 "Value") (clojure.core/assoc :value (deser-string (clojure.core/get-in letvar1533232 ["Value" :content]))))))

(clojure.core/defn- deser-cluster-db-revision [input] (clojure.core/let [letvar1533340 {"ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "CurrentDatabaseRevision" (portkey.aws/search-for-tag input "CurrentDatabaseRevision" :flattened? nil :xmlAttribute? nil), "DatabaseRevisionReleaseDate" (portkey.aws/search-for-tag input "DatabaseRevisionReleaseDate" :flattened? nil :xmlAttribute? nil), "RevisionTargets" (portkey.aws/search-for-tag input "RevisionTargets" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533340 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar1533340 ["ClusterIdentifier" :content]))) (letvar1533340 "CurrentDatabaseRevision") (clojure.core/assoc :current-database-revision (deser-string (clojure.core/get-in letvar1533340 ["CurrentDatabaseRevision" :content]))) (letvar1533340 "DatabaseRevisionReleaseDate") (clojure.core/assoc :database-revision-release-date (deser-t-stamp (clojure.core/get-in letvar1533340 ["DatabaseRevisionReleaseDate" :content]))) (letvar1533340 "RevisionTargets") (clojure.core/assoc :revision-targets (deser-revision-targets-list (clojure.core/get-in letvar1533340 ["RevisionTargets" :content]))))))

(clojure.core/defn- deser-schedule-state [input] (clojure.core/get {"MODIFYING" :modifying, "ACTIVE" :active, "FAILED" :failed} (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-boolean-optional [input] (clojure.core/when-let [boolstr__21591__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__21591__auto__) true (clojure.core/= "false" boolstr__21591__auto__) false)))

(clojure.core/defn- deser-cluster-iam-role-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-iam-role coll))) input))

(clojure.core/defn- deser-deferred-maintenance-window [input] (clojure.core/let [letvar1533472 {"DeferMaintenanceIdentifier" (portkey.aws/search-for-tag input "DeferMaintenanceIdentifier" :flattened? nil :xmlAttribute? nil), "DeferMaintenanceStartTime" (portkey.aws/search-for-tag input "DeferMaintenanceStartTime" :flattened? nil :xmlAttribute? nil), "DeferMaintenanceEndTime" (portkey.aws/search-for-tag input "DeferMaintenanceEndTime" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533472 "DeferMaintenanceIdentifier") (clojure.core/assoc :defer-maintenance-identifier (deser-string (clojure.core/get-in letvar1533472 ["DeferMaintenanceIdentifier" :content]))) (letvar1533472 "DeferMaintenanceStartTime") (clojure.core/assoc :defer-maintenance-start-time (deser-t-stamp (clojure.core/get-in letvar1533472 ["DeferMaintenanceStartTime" :content]))) (letvar1533472 "DeferMaintenanceEndTime") (clojure.core/assoc :defer-maintenance-end-time (deser-t-stamp (clojure.core/get-in letvar1533472 ["DeferMaintenanceEndTime" :content]))))))

(clojure.core/defn- deser-tagged-resource [input] (clojure.core/let [letvar1533580 {"Tag" (portkey.aws/search-for-tag input "Tag" :flattened? nil :xmlAttribute? nil), "ResourceName" (portkey.aws/search-for-tag input "ResourceName" :flattened? nil :xmlAttribute? nil), "ResourceType" (portkey.aws/search-for-tag input "ResourceType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533580 "Tag") (clojure.core/assoc :tag (deser-tag (clojure.core/get-in letvar1533580 ["Tag" :content]))) (letvar1533580 "ResourceName") (clojure.core/assoc :resource-name (deser-string (clojure.core/get-in letvar1533580 ["ResourceName" :content]))) (letvar1533580 "ResourceType") (clojure.core/assoc :resource-type (deser-string (clojure.core/get-in letvar1533580 ["ResourceType" :content]))))))

(clojure.core/defn- deser-restorable-node-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-cluster-associated-to-schedule [input] (clojure.core/let [letvar1533705 {"ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "ScheduleAssociationState" (portkey.aws/search-for-tag input "ScheduleAssociationState" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533705 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar1533705 ["ClusterIdentifier" :content]))) (letvar1533705 "ScheduleAssociationState") (clojure.core/assoc :schedule-association-state (deser-schedule-state (clojure.core/get-in letvar1533705 ["ScheduleAssociationState" :content]))))))

(clojure.core/defn- deser-eligible-tracks-to-update-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-update-target coll))) input))

(clojure.core/defn- deser-scheduled-snapshot-time-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-t-stamp coll))) input))

(clojure.core/defn- deser-cluster-parameter-group [input] (clojure.core/let [letvar1533847 {"ParameterGroupName" (portkey.aws/search-for-tag input "ParameterGroupName" :flattened? nil :xmlAttribute? nil), "ParameterGroupFamily" (portkey.aws/search-for-tag input "ParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1533847 "ParameterGroupName") (clojure.core/assoc :parameter-group-name (deser-string (clojure.core/get-in letvar1533847 ["ParameterGroupName" :content]))) (letvar1533847 "ParameterGroupFamily") (clojure.core/assoc :parameter-group-family (deser-string (clojure.core/get-in letvar1533847 ["ParameterGroupFamily" :content]))) (letvar1533847 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1533847 ["Description" :content]))) (letvar1533847 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1533847 ["Tags" :content]))))))

(clojure.core/defn- deser-event-subscriptions-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-event-subscription coll))) input))

(clojure.core/defn- deser-hsm-configuration-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-hsm-configuration coll))) input))

(clojure.core/defn- deser-long-optional [input] (java.lang.Long. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-cluster-version-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-version coll))) input))

(clojure.core/defn- deser-integer-optional [input] (java.lang.Integer. (portkey.aws/unbox-xml-primitive-value input)))

(clojure.core/defn- deser-hsm-status [input] (clojure.core/let [letvar1534010 {"HsmClientCertificateIdentifier" (portkey.aws/search-for-tag input "HsmClientCertificateIdentifier" :flattened? nil :xmlAttribute? nil), "HsmConfigurationIdentifier" (portkey.aws/search-for-tag input "HsmConfigurationIdentifier" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534010 "HsmClientCertificateIdentifier") (clojure.core/assoc :hsm-client-certificate-identifier (deser-string (clojure.core/get-in letvar1534010 ["HsmClientCertificateIdentifier" :content]))) (letvar1534010 "HsmConfigurationIdentifier") (clojure.core/assoc :hsm-configuration-identifier (deser-string (clojure.core/get-in letvar1534010 ["HsmConfigurationIdentifier" :content]))) (letvar1534010 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1534010 ["Status" :content]))))))

(clojure.core/defn- deser-elastic-ip-status [input] (clojure.core/let [letvar1534118 {"ElasticIp" (portkey.aws/search-for-tag input "ElasticIp" :flattened? nil :xmlAttribute? nil), "Status" (portkey.aws/search-for-tag input "Status" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534118 "ElasticIp") (clojure.core/assoc :elastic-ip (deser-string (clojure.core/get-in letvar1534118 ["ElasticIp" :content]))) (letvar1534118 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1534118 ["Status" :content]))))))

(clojure.core/defn- deser-orderable-cluster-option [input] (clojure.core/let [letvar1534226 {"ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "ClusterType" (portkey.aws/search-for-tag input "ClusterType" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil), "AvailabilityZones" (portkey.aws/search-for-tag input "AvailabilityZones" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534226 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar1534226 ["ClusterVersion" :content]))) (letvar1534226 "ClusterType") (clojure.core/assoc :cluster-type (deser-string (clojure.core/get-in letvar1534226 ["ClusterType" :content]))) (letvar1534226 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar1534226 ["NodeType" :content]))) (letvar1534226 "AvailabilityZones") (clojure.core/assoc :availability-zones (deser-availability-zone-list (clojure.core/get-in letvar1534226 ["AvailabilityZones" :content]))))))

(clojure.core/defn- deser-revision-target [input] (clojure.core/let [letvar1534334 {"DatabaseRevision" (portkey.aws/search-for-tag input "DatabaseRevision" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "DatabaseRevisionReleaseDate" (portkey.aws/search-for-tag input "DatabaseRevisionReleaseDate" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534334 "DatabaseRevision") (clojure.core/assoc :database-revision (deser-string (clojure.core/get-in letvar1534334 ["DatabaseRevision" :content]))) (letvar1534334 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1534334 ["Description" :content]))) (letvar1534334 "DatabaseRevisionReleaseDate") (clojure.core/assoc :database-revision-release-date (deser-t-stamp (clojure.core/get-in letvar1534334 ["DatabaseRevisionReleaseDate" :content]))))))

(clojure.core/defn- deser-cluster-security-group [input] (clojure.core/let [letvar1534442 {"ClusterSecurityGroupName" (portkey.aws/search-for-tag input "ClusterSecurityGroupName" :flattened? nil :xmlAttribute? nil), "Description" (portkey.aws/search-for-tag input "Description" :flattened? nil :xmlAttribute? nil), "EC2SecurityGroups" (portkey.aws/search-for-tag input "EC2SecurityGroups" :flattened? nil :xmlAttribute? nil), "IPRanges" (portkey.aws/search-for-tag input "IPRanges" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534442 "ClusterSecurityGroupName") (clojure.core/assoc :cluster-security-group-name (deser-string (clojure.core/get-in letvar1534442 ["ClusterSecurityGroupName" :content]))) (letvar1534442 "Description") (clojure.core/assoc :description (deser-string (clojure.core/get-in letvar1534442 ["Description" :content]))) (letvar1534442 "EC2SecurityGroups") (clojure.core/assoc :ec-2-security-groups (deser-ec-2-security-group-list (clojure.core/get-in letvar1534442 ["EC2SecurityGroups" :content]))) (letvar1534442 "IPRanges") (clojure.core/assoc :ip-ranges (deser-ip-range-list (clojure.core/get-in letvar1534442 ["IPRanges" :content]))) (letvar1534442 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1534442 ["Tags" :content]))))))

(clojure.core/defn- deser-pending-modified-values [input] (clojure.core/let [letvar1534550 {"EnhancedVpcRouting" (portkey.aws/search-for-tag input "EnhancedVpcRouting" :flattened? nil :xmlAttribute? nil), "PubliclyAccessible" (portkey.aws/search-for-tag input "PubliclyAccessible" :flattened? nil :xmlAttribute? nil), "ClusterIdentifier" (portkey.aws/search-for-tag input "ClusterIdentifier" :flattened? nil :xmlAttribute? nil), "NumberOfNodes" (portkey.aws/search-for-tag input "NumberOfNodes" :flattened? nil :xmlAttribute? nil), "ClusterType" (portkey.aws/search-for-tag input "ClusterType" :flattened? nil :xmlAttribute? nil), "MasterUserPassword" (portkey.aws/search-for-tag input "MasterUserPassword" :flattened? nil :xmlAttribute? nil), "EncryptionType" (portkey.aws/search-for-tag input "EncryptionType" :flattened? nil :xmlAttribute? nil), "MaintenanceTrackName" (portkey.aws/search-for-tag input "MaintenanceTrackName" :flattened? nil :xmlAttribute? nil), "ClusterVersion" (portkey.aws/search-for-tag input "ClusterVersion" :flattened? nil :xmlAttribute? nil), "AutomatedSnapshotRetentionPeriod" (portkey.aws/search-for-tag input "AutomatedSnapshotRetentionPeriod" :flattened? nil :xmlAttribute? nil), "NodeType" (portkey.aws/search-for-tag input "NodeType" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534550 "EnhancedVpcRouting") (clojure.core/assoc :enhanced-vpc-routing (deser-boolean-optional (clojure.core/get-in letvar1534550 ["EnhancedVpcRouting" :content]))) (letvar1534550 "PubliclyAccessible") (clojure.core/assoc :publicly-accessible (deser-boolean-optional (clojure.core/get-in letvar1534550 ["PubliclyAccessible" :content]))) (letvar1534550 "ClusterIdentifier") (clojure.core/assoc :cluster-identifier (deser-string (clojure.core/get-in letvar1534550 ["ClusterIdentifier" :content]))) (letvar1534550 "NumberOfNodes") (clojure.core/assoc :number-of-nodes (deser-integer-optional (clojure.core/get-in letvar1534550 ["NumberOfNodes" :content]))) (letvar1534550 "ClusterType") (clojure.core/assoc :cluster-type (deser-string (clojure.core/get-in letvar1534550 ["ClusterType" :content]))) (letvar1534550 "MasterUserPassword") (clojure.core/assoc :master-user-password (deser-string (clojure.core/get-in letvar1534550 ["MasterUserPassword" :content]))) (letvar1534550 "EncryptionType") (clojure.core/assoc :encryption-type (deser-string (clojure.core/get-in letvar1534550 ["EncryptionType" :content]))) (letvar1534550 "MaintenanceTrackName") (clojure.core/assoc :maintenance-track-name (deser-string (clojure.core/get-in letvar1534550 ["MaintenanceTrackName" :content]))) (letvar1534550 "ClusterVersion") (clojure.core/assoc :cluster-version (deser-string (clojure.core/get-in letvar1534550 ["ClusterVersion" :content]))) (letvar1534550 "AutomatedSnapshotRetentionPeriod") (clojure.core/assoc :automated-snapshot-retention-period (deser-integer-optional (clojure.core/get-in letvar1534550 ["AutomatedSnapshotRetentionPeriod" :content]))) (letvar1534550 "NodeType") (clojure.core/assoc :node-type (deser-string (clojure.core/get-in letvar1534550 ["NodeType" :content]))))))

(clojure.core/defn- deser-subnet-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-subnet coll))) input))

(clojure.core/defn- deser-account-attribute [input] (clojure.core/let [letvar1534675 {"AttributeName" (portkey.aws/search-for-tag input "AttributeName" :flattened? nil :xmlAttribute? nil), "AttributeValues" (portkey.aws/search-for-tag input "AttributeValues" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534675 "AttributeName") (clojure.core/assoc :attribute-name (deser-string (clojure.core/get-in letvar1534675 ["AttributeName" :content]))) (letvar1534675 "AttributeValues") (clojure.core/assoc :attribute-values (deser-attribute-value-list (clojure.core/get-in letvar1534675 ["AttributeValues" :content]))))))

(clojure.core/defn- deser-snapshot-copy-grant [input] (clojure.core/let [letvar1534783 {"SnapshotCopyGrantName" (portkey.aws/search-for-tag input "SnapshotCopyGrantName" :flattened? nil :xmlAttribute? nil), "KmsKeyId" (portkey.aws/search-for-tag input "KmsKeyId" :flattened? nil :xmlAttribute? nil), "Tags" (portkey.aws/search-for-tag input "Tags" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534783 "SnapshotCopyGrantName") (clojure.core/assoc :snapshot-copy-grant-name (deser-string (clojure.core/get-in letvar1534783 ["SnapshotCopyGrantName" :content]))) (letvar1534783 "KmsKeyId") (clojure.core/assoc :kms-key-id (deser-string (clojure.core/get-in letvar1534783 ["KmsKeyId" :content]))) (letvar1534783 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1534783 ["Tags" :content]))))))

(clojure.core/defn- deser-parameter-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cluster-parameter-group coll))) input))

(clojure.core/defn- deser-tagged-resource-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tagged-resource coll))) input))

(clojure.core/defn- deser-boolean [input] (clojure.core/when-let [boolstr__21591__auto__ (portkey.aws/unbox-xml-primitive-value input)] (clojure.core/cond (clojure.core/= "true" boolstr__21591__auto__) true (clojure.core/= "false" boolstr__21591__auto__) false)))

(clojure.core/defn- deser-default-cluster-parameters [input] (clojure.core/let [letvar1534927 {"ParameterGroupFamily" (portkey.aws/search-for-tag input "ParameterGroupFamily" :flattened? nil :xmlAttribute? nil), "Marker" (portkey.aws/search-for-tag input "Marker" :flattened? nil :xmlAttribute? nil), "Parameters" (portkey.aws/search-for-tag input "Parameters" :flattened? nil :xmlAttribute? nil)}] (clojure.core/cond-> {} (letvar1534927 "ParameterGroupFamily") (clojure.core/assoc :parameter-group-family (deser-string (clojure.core/get-in letvar1534927 ["ParameterGroupFamily" :content]))) (letvar1534927 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1534927 ["Marker" :content]))) (letvar1534927 "Parameters") (clojure.core/assoc :parameters (deser-parameters-list (clojure.core/get-in letvar1534927 ["Parameters" :content]))))))

(clojure.core/defn- response-source-not-found-fault ([input] (response-source-not-found-fault nil input)) ([resultWrapper1534929 input] (clojure.core/let [rawinput1534928 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534930 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-dependent-service-request-throttling-fault ([input] (response-dependent-service-request-throttling-fault nil input)) ([resultWrapper1534932 input] (clojure.core/let [rawinput1534931 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534933 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-insufficient-cluster-capacity-fault ([input] (response-insufficient-cluster-capacity-fault nil input)) ([resultWrapper1534935 input] (clojure.core/let [rawinput1534934 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534936 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-resize-progress-message ([input] (response-resize-progress-message nil input)) ([resultWrapper1534938 input] (clojure.core/let [rawinput1534937 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534939 {"AvgResizeRateInMegaBytesPerSecond" (portkey.aws/search-for-tag rawinput1534937 "AvgResizeRateInMegaBytesPerSecond" :flattened? nil :result-wrapper resultWrapper1534938), "ImportTablesNotStarted" (portkey.aws/search-for-tag rawinput1534937 "ImportTablesNotStarted" :flattened? nil :result-wrapper resultWrapper1534938), "TotalResizeDataInMegaBytes" (portkey.aws/search-for-tag rawinput1534937 "TotalResizeDataInMegaBytes" :flattened? nil :result-wrapper resultWrapper1534938), "TargetClusterType" (portkey.aws/search-for-tag rawinput1534937 "TargetClusterType" :flattened? nil :result-wrapper resultWrapper1534938), "ProgressInMegaBytes" (portkey.aws/search-for-tag rawinput1534937 "ProgressInMegaBytes" :flattened? nil :result-wrapper resultWrapper1534938), "Status" (portkey.aws/search-for-tag rawinput1534937 "Status" :flattened? nil :result-wrapper resultWrapper1534938), "ResizeType" (portkey.aws/search-for-tag rawinput1534937 "ResizeType" :flattened? nil :result-wrapper resultWrapper1534938), "Message" (portkey.aws/search-for-tag rawinput1534937 "Message" :flattened? nil :result-wrapper resultWrapper1534938), "TargetNodeType" (portkey.aws/search-for-tag rawinput1534937 "TargetNodeType" :flattened? nil :result-wrapper resultWrapper1534938), "ImportTablesCompleted" (portkey.aws/search-for-tag rawinput1534937 "ImportTablesCompleted" :flattened? nil :result-wrapper resultWrapper1534938), "ImportTablesInProgress" (portkey.aws/search-for-tag rawinput1534937 "ImportTablesInProgress" :flattened? nil :result-wrapper resultWrapper1534938), "TargetEncryptionType" (portkey.aws/search-for-tag rawinput1534937 "TargetEncryptionType" :flattened? nil :result-wrapper resultWrapper1534938), "EstimatedTimeToCompletionInSeconds" (portkey.aws/search-for-tag rawinput1534937 "EstimatedTimeToCompletionInSeconds" :flattened? nil :result-wrapper resultWrapper1534938), "TargetNumberOfNodes" (portkey.aws/search-for-tag rawinput1534937 "TargetNumberOfNodes" :flattened? nil :result-wrapper resultWrapper1534938), "ElapsedTimeInSeconds" (portkey.aws/search-for-tag rawinput1534937 "ElapsedTimeInSeconds" :flattened? nil :result-wrapper resultWrapper1534938)}] (clojure.core/cond-> {} (letvar1534939 "AvgResizeRateInMegaBytesPerSecond") (clojure.core/assoc :avg-resize-rate-in-mega-bytes-per-second (deser-double-optional (clojure.core/get-in letvar1534939 ["AvgResizeRateInMegaBytesPerSecond" :content]))) (letvar1534939 "ImportTablesNotStarted") (clojure.core/assoc :import-tables-not-started (deser-import-tables-not-started (clojure.core/get-in letvar1534939 ["ImportTablesNotStarted" :content]))) (letvar1534939 "TotalResizeDataInMegaBytes") (clojure.core/assoc :total-resize-data-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar1534939 ["TotalResizeDataInMegaBytes" :content]))) (letvar1534939 "TargetClusterType") (clojure.core/assoc :target-cluster-type (deser-string (clojure.core/get-in letvar1534939 ["TargetClusterType" :content]))) (letvar1534939 "ProgressInMegaBytes") (clojure.core/assoc :progress-in-mega-bytes (deser-long-optional (clojure.core/get-in letvar1534939 ["ProgressInMegaBytes" :content]))) (letvar1534939 "Status") (clojure.core/assoc :status (deser-string (clojure.core/get-in letvar1534939 ["Status" :content]))) (letvar1534939 "ResizeType") (clojure.core/assoc :resize-type (deser-string (clojure.core/get-in letvar1534939 ["ResizeType" :content]))) (letvar1534939 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1534939 ["Message" :content]))) (letvar1534939 "TargetNodeType") (clojure.core/assoc :target-node-type (deser-string (clojure.core/get-in letvar1534939 ["TargetNodeType" :content]))) (letvar1534939 "ImportTablesCompleted") (clojure.core/assoc :import-tables-completed (deser-import-tables-completed (clojure.core/get-in letvar1534939 ["ImportTablesCompleted" :content]))) (letvar1534939 "ImportTablesInProgress") (clojure.core/assoc :import-tables-in-progress (deser-import-tables-in-progress (clojure.core/get-in letvar1534939 ["ImportTablesInProgress" :content]))) (letvar1534939 "TargetEncryptionType") (clojure.core/assoc :target-encryption-type (deser-string (clojure.core/get-in letvar1534939 ["TargetEncryptionType" :content]))) (letvar1534939 "EstimatedTimeToCompletionInSeconds") (clojure.core/assoc :estimated-time-to-completion-in-seconds (deser-long-optional (clojure.core/get-in letvar1534939 ["EstimatedTimeToCompletionInSeconds" :content]))) (letvar1534939 "TargetNumberOfNodes") (clojure.core/assoc :target-number-of-nodes (deser-integer-optional (clojure.core/get-in letvar1534939 ["TargetNumberOfNodes" :content]))) (letvar1534939 "ElapsedTimeInSeconds") (clojure.core/assoc :elapsed-time-in-seconds (deser-long-optional (clojure.core/get-in letvar1534939 ["ElapsedTimeInSeconds" :content])))))))

(clojure.core/defn- response-batch-modify-cluster-snapshots-limit-exceeded-fault ([input] (response-batch-modify-cluster-snapshots-limit-exceeded-fault nil input)) ([resultWrapper1534941 input] (clojure.core/let [rawinput1534940 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534942 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-account-attribute-list ([input] (response-account-attribute-list nil input)) ([resultWrapper1534944 input] (clojure.core/let [rawinput1534943 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534945 {"AccountAttributes" (portkey.aws/search-for-tag rawinput1534943 "AccountAttributes" :flattened? nil :result-wrapper resultWrapper1534944)}] (clojure.core/cond-> {} (letvar1534945 "AccountAttributes") (clojure.core/assoc :account-attributes (deser-attribute-list (clojure.core/get-in letvar1534945 ["AccountAttributes" :content])))))))

(clojure.core/defn- response-snapshot-schedule-already-exists-fault ([input] (response-snapshot-schedule-already-exists-fault nil input)) ([resultWrapper1534947 input] (clojure.core/let [rawinput1534946 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534948 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-already-exists-fault ([input] (response-reserved-node-already-exists-fault nil input)) ([resultWrapper1534950 input] (clojure.core/let [rawinput1534949 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534951 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-nodes-message ([input] (response-reserved-nodes-message nil input)) ([resultWrapper1534953 input] (clojure.core/let [rawinput1534952 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534954 {"Marker" (portkey.aws/search-for-tag rawinput1534952 "Marker" :flattened? nil :result-wrapper resultWrapper1534953), "ReservedNodes" (portkey.aws/search-for-tag rawinput1534952 "ReservedNodes" :flattened? nil :result-wrapper resultWrapper1534953)}] (clojure.core/cond-> {} (letvar1534954 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1534954 ["Marker" :content]))) (letvar1534954 "ReservedNodes") (clojure.core/assoc :reserved-nodes (deser-reserved-node-list (clojure.core/get-in letvar1534954 ["ReservedNodes" :content])))))))

(clojure.core/defn- response-invalid-schedule-fault ([input] (response-invalid-schedule-fault nil input)) ([resultWrapper1534956 input] (clojure.core/let [rawinput1534955 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534957 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-number-of-nodes-per-cluster-limit-exceeded-fault ([input] (response-number-of-nodes-per-cluster-limit-exceeded-fault nil input)) ([resultWrapper1534959 input] (clojure.core/let [rawinput1534958 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534960 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-track-list-message ([input] (response-track-list-message nil input)) ([resultWrapper1534962 input] (clojure.core/let [rawinput1534961 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534963 {"MaintenanceTracks" (portkey.aws/search-for-tag rawinput1534961 "MaintenanceTracks" :flattened? nil :result-wrapper resultWrapper1534962), "Marker" (portkey.aws/search-for-tag rawinput1534961 "Marker" :flattened? nil :result-wrapper resultWrapper1534962)}] (clojure.core/cond-> {} (letvar1534963 "MaintenanceTracks") (clojure.core/assoc :maintenance-tracks (deser-track-list (clojure.core/get-in letvar1534963 ["MaintenanceTracks" :content]))) (letvar1534963 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1534963 ["Marker" :content])))))))

(clojure.core/defn- response-sns-no-authorization-fault ([input] (response-sns-no-authorization-fault nil input)) ([resultWrapper1534965 input] (clojure.core/let [rawinput1534964 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534966 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-offerings-message ([input] (response-reserved-node-offerings-message nil input)) ([resultWrapper1534968 input] (clojure.core/let [rawinput1534967 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534969 {"Marker" (portkey.aws/search-for-tag rawinput1534967 "Marker" :flattened? nil :result-wrapper resultWrapper1534968), "ReservedNodeOfferings" (portkey.aws/search-for-tag rawinput1534967 "ReservedNodeOfferings" :flattened? nil :result-wrapper resultWrapper1534968)}] (clojure.core/cond-> {} (letvar1534969 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1534969 ["Marker" :content]))) (letvar1534969 "ReservedNodeOfferings") (clojure.core/assoc :reserved-node-offerings (deser-reserved-node-offering-list (clojure.core/get-in letvar1534969 ["ReservedNodeOfferings" :content])))))))

(clojure.core/defn- response-cluster-parameter-group-quota-exceeded-fault ([input] (response-cluster-parameter-group-quota-exceeded-fault nil input)) ([resultWrapper1534971 input] (clojure.core/let [rawinput1534970 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534972 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-elastic-ip-fault ([input] (response-invalid-elastic-ip-fault nil input)) ([resultWrapper1534974 input] (clojure.core/let [rawinput1534973 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534975 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-disable-snapshot-copy-result ([input] (response-disable-snapshot-copy-result nil input)) ([resultWrapper1534977 input] (clojure.core/let [rawinput1534976 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534978 {"Cluster" (portkey.aws/search-for-tag rawinput1534976 "Cluster" :flattened? nil :result-wrapper resultWrapper1534977)}] (clojure.core/cond-> {} (letvar1534978 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1534978 ["Cluster" :content])))))))

(clojure.core/defn- response-snapshot-schedule-update-in-progress-fault ([input] (response-snapshot-schedule-update-in-progress-fault nil input)) ([resultWrapper1534980 input] (clojure.core/let [rawinput1534979 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534981 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorize-snapshot-access-result ([input] (response-authorize-snapshot-access-result nil input)) ([resultWrapper1534983 input] (clojure.core/let [rawinput1534982 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534984 {"Snapshot" (portkey.aws/search-for-tag rawinput1534982 "Snapshot" :flattened? nil :result-wrapper resultWrapper1534983)}] (clojure.core/cond-> {} (letvar1534984 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar1534984 ["Snapshot" :content])))))))

(clojure.core/defn- response-hsm-client-certificate-quota-exceeded-fault ([input] (response-hsm-client-certificate-quota-exceeded-fault nil input)) ([resultWrapper1534986 input] (clojure.core/let [rawinput1534985 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534987 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-quota-exceeded-fault ([input] (response-cluster-subnet-quota-exceeded-fault nil input)) ([resultWrapper1534989 input] (clojure.core/let [rawinput1534988 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534990 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-db-revisions-message ([input] (response-cluster-db-revisions-message nil input)) ([resultWrapper1534992 input] (clojure.core/let [rawinput1534991 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534993 {"Marker" (portkey.aws/search-for-tag rawinput1534991 "Marker" :flattened? nil :result-wrapper resultWrapper1534992), "ClusterDbRevisions" (portkey.aws/search-for-tag rawinput1534991 "ClusterDbRevisions" :flattened? nil :result-wrapper resultWrapper1534992)}] (clojure.core/cond-> {} (letvar1534993 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1534993 ["Marker" :content]))) (letvar1534993 "ClusterDbRevisions") (clojure.core/assoc :cluster-db-revisions (deser-cluster-db-revisions-list (clojure.core/get-in letvar1534993 ["ClusterDbRevisions" :content])))))))

(clojure.core/defn- response-create-cluster-parameter-group-result ([input] (response-create-cluster-parameter-group-result nil input)) ([resultWrapper1534995 input] (clojure.core/let [rawinput1534994 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534996 {"ClusterParameterGroup" (portkey.aws/search-for-tag rawinput1534994 "ClusterParameterGroup" :flattened? nil :result-wrapper resultWrapper1534995)}] (clojure.core/cond-> {} (letvar1534996 "ClusterParameterGroup") (clojure.core/assoc :cluster-parameter-group (deser-cluster-parameter-group (clojure.core/get-in letvar1534996 ["ClusterParameterGroup" :content])))))))

(clojure.core/defn- response-cluster-parameter-group-already-exists-fault ([input] (response-cluster-parameter-group-already-exists-fault nil input)) ([resultWrapper1534998 input] (clojure.core/let [rawinput1534997 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1534999 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-not-found-fault ([input] (response-reserved-node-not-found-fault nil input)) ([resultWrapper1535001 input] (clojure.core/let [rawinput1535000 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535002 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-hsm-configuration-message ([input] (response-hsm-configuration-message nil input)) ([resultWrapper1535004 input] (clojure.core/let [rawinput1535003 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535005 {"Marker" (portkey.aws/search-for-tag rawinput1535003 "Marker" :flattened? nil :result-wrapper resultWrapper1535004), "HsmConfigurations" (portkey.aws/search-for-tag rawinput1535003 "HsmConfigurations" :flattened? nil :result-wrapper resultWrapper1535004)}] (clojure.core/cond-> {} (letvar1535005 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535005 ["Marker" :content]))) (letvar1535005 "HsmConfigurations") (clojure.core/assoc :hsm-configurations (deser-hsm-configuration-list (clojure.core/get-in letvar1535005 ["HsmConfigurations" :content])))))))

(clojure.core/defn- response-invalid-hsm-configuration-state-fault ([input] (response-invalid-hsm-configuration-state-fault nil input)) ([resultWrapper1535007 input] (clojure.core/let [rawinput1535006 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535008 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-already-exists-fault ([input] (response-cluster-already-exists-fault nil input)) ([resultWrapper1535010 input] (clojure.core/let [rawinput1535009 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535011 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-s-3-bucket-name-fault ([input] (response-invalid-s-3-bucket-name-fault nil input)) ([resultWrapper1535013 input] (clojure.core/let [rawinput1535012 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535014 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-customer-storage-message ([input] (response-customer-storage-message nil input)) ([resultWrapper1535016 input] (clojure.core/let [rawinput1535015 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535017 {"TotalBackupSizeInMegaBytes" (portkey.aws/search-for-tag rawinput1535015 "TotalBackupSizeInMegaBytes" :flattened? nil :result-wrapper resultWrapper1535016), "TotalProvisionedStorageInMegaBytes" (portkey.aws/search-for-tag rawinput1535015 "TotalProvisionedStorageInMegaBytes" :flattened? nil :result-wrapper resultWrapper1535016)}] (clojure.core/cond-> {} (letvar1535017 "TotalBackupSizeInMegaBytes") (clojure.core/assoc :total-backup-size-in-mega-bytes (deser-double (clojure.core/get-in letvar1535017 ["TotalBackupSizeInMegaBytes" :content]))) (letvar1535017 "TotalProvisionedStorageInMegaBytes") (clojure.core/assoc :total-provisioned-storage-in-mega-bytes (deser-double (clojure.core/get-in letvar1535017 ["TotalProvisionedStorageInMegaBytes" :content])))))))

(clojure.core/defn- response-describe-default-cluster-parameters-result ([input] (response-describe-default-cluster-parameters-result nil input)) ([resultWrapper1535019 input] (clojure.core/let [rawinput1535018 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535020 {"DefaultClusterParameters" (portkey.aws/search-for-tag rawinput1535018 "DefaultClusterParameters" :flattened? nil :result-wrapper resultWrapper1535019)}] (clojure.core/cond-> {} (letvar1535020 "DefaultClusterParameters") (clojure.core/assoc :default-cluster-parameters (deser-default-cluster-parameters (clojure.core/get-in letvar1535020 ["DefaultClusterParameters" :content])))))))

(clojure.core/defn- response-invalid-retention-period-fault ([input] (response-invalid-retention-period-fault nil input)) ([resultWrapper1535022 input] (clojure.core/let [rawinput1535021 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535023 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-message ([input] (response-snapshot-message nil input)) ([resultWrapper1535025 input] (clojure.core/let [rawinput1535024 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535026 {"Marker" (portkey.aws/search-for-tag rawinput1535024 "Marker" :flattened? nil :result-wrapper resultWrapper1535025), "Snapshots" (portkey.aws/search-for-tag rawinput1535024 "Snapshots" :flattened? nil :result-wrapper resultWrapper1535025)}] (clojure.core/cond-> {} (letvar1535026 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535026 ["Marker" :content]))) (letvar1535026 "Snapshots") (clojure.core/assoc :snapshots (deser-snapshot-list (clojure.core/get-in letvar1535026 ["Snapshots" :content])))))))

(clojure.core/defn- response-subscription-severity-not-found-fault ([input] (response-subscription-severity-not-found-fault nil input)) ([resultWrapper1535028 input] (clojure.core/let [rawinput1535027 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535029 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-vpc-network-state-fault ([input] (response-invalid-vpc-network-state-fault nil input)) ([resultWrapper1535031 input] (clojure.core/let [rawinput1535030 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535032 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-batch-modify-cluster-snapshots-output-message ([input] (response-batch-modify-cluster-snapshots-output-message nil input)) ([resultWrapper1535034 input] (clojure.core/let [rawinput1535033 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535035 {"Resources" (portkey.aws/search-for-tag rawinput1535033 "Resources" :flattened? nil :result-wrapper resultWrapper1535034), "Errors" (portkey.aws/search-for-tag rawinput1535033 "Errors" :flattened? nil :result-wrapper resultWrapper1535034)}] (clojure.core/cond-> {} (letvar1535035 "Resources") (clojure.core/assoc :resources (deser-snapshot-identifier-list (clojure.core/get-in letvar1535035 ["Resources" :content]))) (letvar1535035 "Errors") (clojure.core/assoc :errors (deser-batch-snapshot-operation-errors (clojure.core/get-in letvar1535035 ["Errors" :content])))))))

(clojure.core/defn- response-revoke-cluster-security-group-ingress-result ([input] (response-revoke-cluster-security-group-ingress-result nil input)) ([resultWrapper1535037 input] (clojure.core/let [rawinput1535036 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535038 {"ClusterSecurityGroup" (portkey.aws/search-for-tag rawinput1535036 "ClusterSecurityGroup" :flattened? nil :result-wrapper resultWrapper1535037)}] (clojure.core/cond-> {} (letvar1535038 "ClusterSecurityGroup") (clojure.core/assoc :cluster-security-group (deser-cluster-security-group (clojure.core/get-in letvar1535038 ["ClusterSecurityGroup" :content])))))))

(clojure.core/defn- response-invalid-table-restore-argument-fault ([input] (response-invalid-table-restore-argument-fault nil input)) ([resultWrapper1535040 input] (clojure.core/let [rawinput1535039 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535041 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-logging-status ([input] (response-logging-status nil input)) ([resultWrapper1535043 input] (clojure.core/let [rawinput1535042 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535044 {"LoggingEnabled" (portkey.aws/search-for-tag rawinput1535042 "LoggingEnabled" :flattened? nil :result-wrapper resultWrapper1535043), "BucketName" (portkey.aws/search-for-tag rawinput1535042 "BucketName" :flattened? nil :result-wrapper resultWrapper1535043), "S3KeyPrefix" (portkey.aws/search-for-tag rawinput1535042 "S3KeyPrefix" :flattened? nil :result-wrapper resultWrapper1535043), "LastSuccessfulDeliveryTime" (portkey.aws/search-for-tag rawinput1535042 "LastSuccessfulDeliveryTime" :flattened? nil :result-wrapper resultWrapper1535043), "LastFailureTime" (portkey.aws/search-for-tag rawinput1535042 "LastFailureTime" :flattened? nil :result-wrapper resultWrapper1535043), "LastFailureMessage" (portkey.aws/search-for-tag rawinput1535042 "LastFailureMessage" :flattened? nil :result-wrapper resultWrapper1535043)}] (clojure.core/cond-> {} (letvar1535044 "LoggingEnabled") (clojure.core/assoc :logging-enabled (deser-boolean (clojure.core/get-in letvar1535044 ["LoggingEnabled" :content]))) (letvar1535044 "BucketName") (clojure.core/assoc :bucket-name (deser-string (clojure.core/get-in letvar1535044 ["BucketName" :content]))) (letvar1535044 "S3KeyPrefix") (clojure.core/assoc :s-3-key-prefix (deser-string (clojure.core/get-in letvar1535044 ["S3KeyPrefix" :content]))) (letvar1535044 "LastSuccessfulDeliveryTime") (clojure.core/assoc :last-successful-delivery-time (deser-t-stamp (clojure.core/get-in letvar1535044 ["LastSuccessfulDeliveryTime" :content]))) (letvar1535044 "LastFailureTime") (clojure.core/assoc :last-failure-time (deser-t-stamp (clojure.core/get-in letvar1535044 ["LastFailureTime" :content]))) (letvar1535044 "LastFailureMessage") (clojure.core/assoc :last-failure-message (deser-string (clojure.core/get-in letvar1535044 ["LastFailureMessage" :content])))))))

(clojure.core/defn- response-snapshot-schedule-not-found-fault ([input] (response-snapshot-schedule-not-found-fault nil input)) ([resultWrapper1535046 input] (clojure.core/let [rawinput1535045 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535047 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-security-group-message ([input] (response-cluster-security-group-message nil input)) ([resultWrapper1535049 input] (clojure.core/let [rawinput1535048 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535050 {"Marker" (portkey.aws/search-for-tag rawinput1535048 "Marker" :flattened? nil :result-wrapper resultWrapper1535049), "ClusterSecurityGroups" (portkey.aws/search-for-tag rawinput1535048 "ClusterSecurityGroups" :flattened? nil :result-wrapper resultWrapper1535049)}] (clojure.core/cond-> {} (letvar1535050 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535050 ["Marker" :content]))) (letvar1535050 "ClusterSecurityGroups") (clojure.core/assoc :cluster-security-groups (deser-cluster-security-groups (clojure.core/get-in letvar1535050 ["ClusterSecurityGroups" :content])))))))

(clojure.core/defn- response-event-categories-message ([input] (response-event-categories-message nil input)) ([resultWrapper1535052 input] (clojure.core/let [rawinput1535051 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535053 {"EventCategoriesMapList" (portkey.aws/search-for-tag rawinput1535051 "EventCategoriesMapList" :flattened? nil :result-wrapper resultWrapper1535052)}] (clojure.core/cond-> {} (letvar1535053 "EventCategoriesMapList") (clojure.core/assoc :event-categories-map-list (deser-event-categories-map-list (clojure.core/get-in letvar1535053 ["EventCategoriesMapList" :content])))))))

(clojure.core/defn- response-hsm-configuration-already-exists-fault ([input] (response-hsm-configuration-already-exists-fault nil input)) ([resultWrapper1535055 input] (clojure.core/let [rawinput1535054 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535056 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-not-found-fault ([input] (response-subscription-not-found-fault nil input)) ([resultWrapper1535058 input] (clojure.core/let [rawinput1535057 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535059 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorization-already-exists-fault ([input] (response-authorization-already-exists-fault nil input)) ([resultWrapper1535061 input] (clojure.core/let [rawinput1535060 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535062 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-bucket-not-found-fault ([input] (response-bucket-not-found-fault nil input)) ([resultWrapper1535064 input] (clojure.core/let [rawinput1535063 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535065 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-copy-to-region-disabled-fault ([input] (response-copy-to-region-disabled-fault nil input)) ([resultWrapper1535067 input] (clojure.core/let [rawinput1535066 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535068 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-sns-topic-arn-not-found-fault ([input] (response-sns-topic-arn-not-found-fault nil input)) ([resultWrapper1535070 input] (clojure.core/let [rawinput1535069 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535071 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-events-message ([input] (response-events-message nil input)) ([resultWrapper1535073 input] (clojure.core/let [rawinput1535072 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535074 {"Marker" (portkey.aws/search-for-tag rawinput1535072 "Marker" :flattened? nil :result-wrapper resultWrapper1535073), "Events" (portkey.aws/search-for-tag rawinput1535072 "Events" :flattened? nil :result-wrapper resultWrapper1535073)}] (clojure.core/cond-> {} (letvar1535074 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535074 ["Marker" :content]))) (letvar1535074 "Events") (clojure.core/assoc :events (deser-event-list (clojure.core/get-in letvar1535074 ["Events" :content])))))))

(clojure.core/defn- response-create-cluster-snapshot-result ([input] (response-create-cluster-snapshot-result nil input)) ([resultWrapper1535076 input] (clojure.core/let [rawinput1535075 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535077 {"Snapshot" (portkey.aws/search-for-tag rawinput1535075 "Snapshot" :flattened? nil :result-wrapper resultWrapper1535076)}] (clojure.core/cond-> {} (letvar1535077 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar1535077 ["Snapshot" :content])))))))

(clojure.core/defn- response-cluster-security-group-quota-exceeded-fault ([input] (response-cluster-security-group-quota-exceeded-fault nil input)) ([resultWrapper1535079 input] (clojure.core/let [rawinput1535078 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535080 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unauthorized-operation ([input] (response-unauthorized-operation nil input)) ([resultWrapper1535082 input] (clojure.core/let [rawinput1535081 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535083 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-category-not-found-fault ([input] (response-subscription-category-not-found-fault nil input)) ([resultWrapper1535085 input] (clojure.core/let [rawinput1535084 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535086 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-rotate-encryption-key-result ([input] (response-rotate-encryption-key-result nil input)) ([resultWrapper1535088 input] (clojure.core/let [rawinput1535087 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535089 {"Cluster" (portkey.aws/search-for-tag rawinput1535087 "Cluster" :flattened? nil :result-wrapper resultWrapper1535088)}] (clojure.core/cond-> {} (letvar1535089 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535089 ["Cluster" :content])))))))

(clojure.core/defn- response-invalid-hsm-client-certificate-state-fault ([input] (response-invalid-hsm-client-certificate-state-fault nil input)) ([resultWrapper1535091 input] (clojure.core/let [rawinput1535090 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535092 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-accept-reserved-node-exchange-output-message ([input] (response-accept-reserved-node-exchange-output-message nil input)) ([resultWrapper1535094 input] (clojure.core/let [rawinput1535093 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535095 {"ExchangedReservedNode" (portkey.aws/search-for-tag rawinput1535093 "ExchangedReservedNode" :flattened? nil :result-wrapper resultWrapper1535094)}] (clojure.core/cond-> {} (letvar1535095 "ExchangedReservedNode") (clojure.core/assoc :exchanged-reserved-node (deser-reserved-node (clojure.core/get-in letvar1535095 ["ExchangedReservedNode" :content])))))))

(clojure.core/defn- response-event-subscriptions-message ([input] (response-event-subscriptions-message nil input)) ([resultWrapper1535097 input] (clojure.core/let [rawinput1535096 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535098 {"Marker" (portkey.aws/search-for-tag rawinput1535096 "Marker" :flattened? nil :result-wrapper resultWrapper1535097), "EventSubscriptionsList" (portkey.aws/search-for-tag rawinput1535096 "EventSubscriptionsList" :flattened? nil :result-wrapper resultWrapper1535097)}] (clojure.core/cond-> {} (letvar1535098 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535098 ["Marker" :content]))) (letvar1535098 "EventSubscriptionsList") (clojure.core/assoc :event-subscriptions-list (deser-event-subscriptions-list (clojure.core/get-in letvar1535098 ["EventSubscriptionsList" :content])))))))

(clojure.core/defn- response-create-event-subscription-result ([input] (response-create-event-subscription-result nil input)) ([resultWrapper1535100 input] (clojure.core/let [rawinput1535099 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535101 {"EventSubscription" (portkey.aws/search-for-tag rawinput1535099 "EventSubscription" :flattened? nil :result-wrapper resultWrapper1535100)}] (clojure.core/cond-> {} (letvar1535101 "EventSubscription") (clojure.core/assoc :event-subscription (deser-event-subscription (clojure.core/get-in letvar1535101 ["EventSubscription" :content])))))))

(clojure.core/defn- response-restore-table-from-cluster-snapshot-result ([input] (response-restore-table-from-cluster-snapshot-result nil input)) ([resultWrapper1535103 input] (clojure.core/let [rawinput1535102 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535104 {"TableRestoreStatus" (portkey.aws/search-for-tag rawinput1535102 "TableRestoreStatus" :flattened? nil :result-wrapper resultWrapper1535103)}] (clojure.core/cond-> {} (letvar1535104 "TableRestoreStatus") (clojure.core/assoc :table-restore-status (deser-table-restore-status (clojure.core/get-in letvar1535104 ["TableRestoreStatus" :content])))))))

(clojure.core/defn- response-invalid-subscription-state-fault ([input] (response-invalid-subscription-state-fault nil input)) ([resultWrapper1535106 input] (clojure.core/let [rawinput1535105 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535107 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-reserved-node-exchange-offerings-output-message ([input] (response-get-reserved-node-exchange-offerings-output-message nil input)) ([resultWrapper1535109 input] (clojure.core/let [rawinput1535108 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535110 {"Marker" (portkey.aws/search-for-tag rawinput1535108 "Marker" :flattened? nil :result-wrapper resultWrapper1535109), "ReservedNodeOfferings" (portkey.aws/search-for-tag rawinput1535108 "ReservedNodeOfferings" :flattened? nil :result-wrapper resultWrapper1535109)}] (clojure.core/cond-> {} (letvar1535110 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535110 ["Marker" :content]))) (letvar1535110 "ReservedNodeOfferings") (clojure.core/assoc :reserved-node-offerings (deser-reserved-node-offering-list (clojure.core/get-in letvar1535110 ["ReservedNodeOfferings" :content])))))))

(clojure.core/defn- response-resize-not-found-fault ([input] (response-resize-not-found-fault nil input)) ([resultWrapper1535112 input] (clojure.core/let [rawinput1535111 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535113 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-restore-from-cluster-snapshot-result ([input] (response-restore-from-cluster-snapshot-result nil input)) ([resultWrapper1535115 input] (clojure.core/let [rawinput1535114 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535116 {"Cluster" (portkey.aws/search-for-tag rawinput1535114 "Cluster" :flattened? nil :result-wrapper resultWrapper1535115)}] (clojure.core/cond-> {} (letvar1535116 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535116 ["Cluster" :content])))))))

(clojure.core/defn- response-authorization-not-found-fault ([input] (response-authorization-not-found-fault nil input)) ([resultWrapper1535118 input] (clojure.core/let [rawinput1535117 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535119 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-batch-delete-request-size-exceeded-fault ([input] (response-batch-delete-request-size-exceeded-fault nil input)) ([resultWrapper1535121 input] (clojure.core/let [rawinput1535120 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535122 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-snapshot-not-found-fault ([input] (response-cluster-snapshot-not-found-fault nil input)) ([resultWrapper1535124 input] (clojure.core/let [rawinput1535123 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535125 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reboot-cluster-result ([input] (response-reboot-cluster-result nil input)) ([resultWrapper1535127 input] (clojure.core/let [rawinput1535126 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535128 {"Cluster" (portkey.aws/search-for-tag rawinput1535126 "Cluster" :flattened? nil :result-wrapper resultWrapper1535127)}] (clojure.core/cond-> {} (letvar1535128 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535128 ["Cluster" :content])))))))

(clojure.core/defn- response-subnet-already-in-use ([input] (response-subnet-already-in-use nil input)) ([resultWrapper1535130 input] (clojure.core/let [rawinput1535129 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535131 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-quota-exceeded-fault ([input] (response-cluster-subnet-group-quota-exceeded-fault nil input)) ([resultWrapper1535133 input] (clojure.core/let [rawinput1535132 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535134 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-subnet ([input] (response-invalid-subnet nil input)) ([resultWrapper1535136 input] (clojure.core/let [rawinput1535135 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535137 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-cluster-security-group-result ([input] (response-create-cluster-security-group-result nil input)) ([resultWrapper1535139 input] (clojure.core/let [rawinput1535138 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535140 {"ClusterSecurityGroup" (portkey.aws/search-for-tag rawinput1535138 "ClusterSecurityGroup" :flattened? nil :result-wrapper resultWrapper1535139)}] (clojure.core/cond-> {} (letvar1535140 "ClusterSecurityGroup") (clojure.core/assoc :cluster-security-group (deser-cluster-security-group (clojure.core/get-in letvar1535140 ["ClusterSecurityGroup" :content])))))))

(clojure.core/defn- response-hsm-client-certificate-message ([input] (response-hsm-client-certificate-message nil input)) ([resultWrapper1535142 input] (clojure.core/let [rawinput1535141 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535143 {"Marker" (portkey.aws/search-for-tag rawinput1535141 "Marker" :flattened? nil :result-wrapper resultWrapper1535142), "HsmClientCertificates" (portkey.aws/search-for-tag rawinput1535141 "HsmClientCertificates" :flattened? nil :result-wrapper resultWrapper1535142)}] (clojure.core/cond-> {} (letvar1535143 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535143 ["Marker" :content]))) (letvar1535143 "HsmClientCertificates") (clojure.core/assoc :hsm-client-certificates (deser-hsm-client-certificate-list (clojure.core/get-in letvar1535143 ["HsmClientCertificates" :content])))))))

(clojure.core/defn- response-invalid-cluster-snapshot-schedule-state-fault ([input] (response-invalid-cluster-snapshot-schedule-state-fault nil input)) ([resultWrapper1535145 input] (clojure.core/let [rawinput1535144 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535146 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-snapshot-quota-exceeded-fault ([input] (response-cluster-snapshot-quota-exceeded-fault nil input)) ([resultWrapper1535148 input] (clojure.core/let [rawinput1535147 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535149 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-quota-exceeded-fault ([input] (response-reserved-node-quota-exceeded-fault nil input)) ([resultWrapper1535151 input] (clojure.core/let [rawinput1535150 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535152 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-hsm-client-certificate-not-found-fault ([input] (response-hsm-client-certificate-not-found-fault nil input)) ([resultWrapper1535154 input] (clojure.core/let [rawinput1535153 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535155 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-not-found-fault ([input] (response-cluster-subnet-group-not-found-fault nil input)) ([resultWrapper1535157 input] (clojure.core/let [rawinput1535156 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535158 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unsupported-option-fault ([input] (response-unsupported-option-fault nil input)) ([resultWrapper1535160 input] (clojure.core/let [rawinput1535159 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535161 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-hsm-configuration-not-found-fault ([input] (response-hsm-configuration-not-found-fault nil input)) ([resultWrapper1535163 input] (clojure.core/let [rawinput1535162 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535164 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-already-exist-fault ([input] (response-subscription-already-exist-fault nil input)) ([resultWrapper1535166 input] (clojure.core/let [rawinput1535165 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535167 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-s-3-key-prefix-fault ([input] (response-invalid-s-3-key-prefix-fault nil input)) ([resultWrapper1535169 input] (clojure.core/let [rawinput1535168 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535170 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-grant-not-found-fault ([input] (response-snapshot-copy-grant-not-found-fault nil input)) ([resultWrapper1535172 input] (clojure.core/let [rawinput1535171 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535173 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-in-progress-table-restore-quota-exceeded-fault ([input] (response-in-progress-table-restore-quota-exceeded-fault nil input)) ([resultWrapper1535175 input] (clojure.core/let [rawinput1535174 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535176 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-quota-exceeded-fault ([input] (response-cluster-quota-exceeded-fault nil input)) ([resultWrapper1535178 input] (clojure.core/let [rawinput1535177 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535179 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-snapshot-copy-grant-state-fault ([input] (response-invalid-snapshot-copy-grant-state-fault nil input)) ([resultWrapper1535181 input] (clojure.core/let [rawinput1535180 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535182 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-subnet-group-state-fault ([input] (response-invalid-cluster-subnet-group-state-fault nil input)) ([resultWrapper1535184 input] (clojure.core/let [rawinput1535183 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535185 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-result ([input] (response-modify-cluster-result nil input)) ([resultWrapper1535187 input] (clojure.core/let [rawinput1535186 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535188 {"Cluster" (portkey.aws/search-for-tag rawinput1535186 "Cluster" :flattened? nil :result-wrapper resultWrapper1535187)}] (clojure.core/cond-> {} (letvar1535188 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535188 ["Cluster" :content])))))))

(clojure.core/defn- response-limit-exceeded-fault ([input] (response-limit-exceeded-fault nil input)) ([resultWrapper1535190 input] (clojure.core/let [rawinput1535189 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535191 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-resize-cluster-result ([input] (response-resize-cluster-result nil input)) ([resultWrapper1535193 input] (clojure.core/let [rawinput1535192 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535194 {"Cluster" (portkey.aws/search-for-tag rawinput1535192 "Cluster" :flattened? nil :result-wrapper resultWrapper1535193)}] (clojure.core/cond-> {} (letvar1535194 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535194 ["Cluster" :content])))))))

(clojure.core/defn- response-schedule-definition-type-unsupported-fault ([input] (response-schedule-definition-type-unsupported-fault nil input)) ([resultWrapper1535196 input] (clojure.core/let [rawinput1535195 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535197 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorization-quota-exceeded-fault ([input] (response-authorization-quota-exceeded-fault nil input)) ([resultWrapper1535199 input] (clojure.core/let [rawinput1535198 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535200 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-security-group-state-fault ([input] (response-invalid-cluster-security-group-state-fault nil input)) ([resultWrapper1535202 input] (clojure.core/let [rawinput1535201 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535203 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-parameter-group-not-found-fault ([input] (response-cluster-parameter-group-not-found-fault nil input)) ([resultWrapper1535205 input] (clojure.core/let [rawinput1535204 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535206 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-subscription-event-id-not-found-fault ([input] (response-subscription-event-id-not-found-fault nil input)) ([resultWrapper1535208 input] (clojure.core/let [rawinput1535207 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535209 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-insufficient-s-3-bucket-policy-fault ([input] (response-insufficient-s-3-bucket-policy-fault nil input)) ([resultWrapper1535211 input] (clojure.core/let [rawinput1535210 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535212 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-credentials ([input] (response-cluster-credentials nil input)) ([resultWrapper1535214 input] (clojure.core/let [rawinput1535213 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535215 {"DbUser" (portkey.aws/search-for-tag rawinput1535213 "DbUser" :flattened? nil :result-wrapper resultWrapper1535214), "DbPassword" (portkey.aws/search-for-tag rawinput1535213 "DbPassword" :flattened? nil :result-wrapper resultWrapper1535214), "Expiration" (portkey.aws/search-for-tag rawinput1535213 "Expiration" :flattened? nil :result-wrapper resultWrapper1535214)}] (clojure.core/cond-> {} (letvar1535215 "DbUser") (clojure.core/assoc :db-user (deser-string (clojure.core/get-in letvar1535215 ["DbUser" :content]))) (letvar1535215 "DbPassword") (clojure.core/assoc :db-password (deser-sensitive-string (clojure.core/get-in letvar1535215 ["DbPassword" :content]))) (letvar1535215 "Expiration") (clojure.core/assoc :expiration (deser-t-stamp (clojure.core/get-in letvar1535215 ["Expiration" :content])))))))

(clojure.core/defn- response-hsm-configuration-quota-exceeded-fault ([input] (response-hsm-configuration-quota-exceeded-fault nil input)) ([resultWrapper1535217 input] (clojure.core/let [rawinput1535216 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535218 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-snapshot-state-fault ([input] (response-invalid-cluster-snapshot-state-fault nil input)) ([resultWrapper1535220 input] (clojure.core/let [rawinput1535219 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535221 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-already-enabled-fault ([input] (response-snapshot-copy-already-enabled-fault nil input)) ([resultWrapper1535223 input] (clojure.core/let [rawinput1535222 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535224 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-resource-not-found-fault ([input] (response-resource-not-found-fault nil input)) ([resultWrapper1535226 input] (clojure.core/let [rawinput1535225 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535227 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-copy-cluster-snapshot-result ([input] (response-copy-cluster-snapshot-result nil input)) ([resultWrapper1535229 input] (clojure.core/let [rawinput1535228 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535230 {"Snapshot" (portkey.aws/search-for-tag rawinput1535228 "Snapshot" :flattened? nil :result-wrapper resultWrapper1535229)}] (clojure.core/cond-> {} (letvar1535230 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar1535230 ["Snapshot" :content])))))))

(clojure.core/defn- response-create-snapshot-copy-grant-result ([input] (response-create-snapshot-copy-grant-result nil input)) ([resultWrapper1535232 input] (clojure.core/let [rawinput1535231 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535233 {"SnapshotCopyGrant" (portkey.aws/search-for-tag rawinput1535231 "SnapshotCopyGrant" :flattened? nil :result-wrapper resultWrapper1535232)}] (clojure.core/cond-> {} (letvar1535233 "SnapshotCopyGrant") (clojure.core/assoc :snapshot-copy-grant (deser-snapshot-copy-grant (clojure.core/get-in letvar1535233 ["SnapshotCopyGrant" :content])))))))

(clojure.core/defn- response-reserved-node-already-migrated-fault ([input] (response-reserved-node-already-migrated-fault nil input)) ([resultWrapper1535235 input] (clojure.core/let [rawinput1535234 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535236 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-grant-quota-exceeded-fault ([input] (response-snapshot-copy-grant-quota-exceeded-fault nil input)) ([resultWrapper1535238 input] (clojure.core/let [rawinput1535237 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535239 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-table-restore-not-found-fault ([input] (response-table-restore-not-found-fault nil input)) ([resultWrapper1535241 input] (clojure.core/let [rawinput1535240 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535242 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-security-group-already-exists-fault ([input] (response-cluster-security-group-already-exists-fault nil input)) ([resultWrapper1535244 input] (clojure.core/let [rawinput1535243 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535245 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-schedule-quota-exceeded-fault ([input] (response-snapshot-schedule-quota-exceeded-fault nil input)) ([resultWrapper1535247 input] (clojure.core/let [rawinput1535246 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535248 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-reserved-node-offering-not-found-fault ([input] (response-reserved-node-offering-not-found-fault nil input)) ([resultWrapper1535250 input] (clojure.core/let [rawinput1535249 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535251 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-security-group-not-found-fault ([input] (response-cluster-security-group-not-found-fault nil input)) ([resultWrapper1535253 input] (clojure.core/let [rawinput1535252 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535254 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-incompatible-orderable-options ([input] (response-incompatible-orderable-options nil input)) ([resultWrapper1535256 input] (clojure.core/let [rawinput1535255 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535257 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-cluster-snapshot-result ([input] (response-delete-cluster-snapshot-result nil input)) ([resultWrapper1535259 input] (clojure.core/let [rawinput1535258 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535260 {"Snapshot" (portkey.aws/search-for-tag rawinput1535258 "Snapshot" :flattened? nil :result-wrapper resultWrapper1535259)}] (clojure.core/cond-> {} (letvar1535260 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar1535260 ["Snapshot" :content])))))))

(clojure.core/defn- response-event-subscription-quota-exceeded-fault ([input] (response-event-subscription-quota-exceeded-fault nil input)) ([resultWrapper1535262 input] (clojure.core/let [rawinput1535261 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535263 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-db-revision-result ([input] (response-modify-cluster-db-revision-result nil input)) ([resultWrapper1535265 input] (clojure.core/let [rawinput1535264 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535266 {"Cluster" (portkey.aws/search-for-tag rawinput1535264 "Cluster" :flattened? nil :result-wrapper resultWrapper1535265)}] (clojure.core/cond-> {} (letvar1535266 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535266 ["Cluster" :content])))))))

(clojure.core/defn- response-create-cluster-result ([input] (response-create-cluster-result nil input)) ([resultWrapper1535268 input] (clojure.core/let [rawinput1535267 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535269 {"Cluster" (portkey.aws/search-for-tag rawinput1535267 "Cluster" :flattened? nil :result-wrapper resultWrapper1535268)}] (clojure.core/cond-> {} (letvar1535269 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535269 ["Cluster" :content])))))))

(clojure.core/defn- response-snapshot-copy-grant-message ([input] (response-snapshot-copy-grant-message nil input)) ([resultWrapper1535271 input] (clojure.core/let [rawinput1535270 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535272 {"Marker" (portkey.aws/search-for-tag rawinput1535270 "Marker" :flattened? nil :result-wrapper resultWrapper1535271), "SnapshotCopyGrants" (portkey.aws/search-for-tag rawinput1535270 "SnapshotCopyGrants" :flattened? nil :result-wrapper resultWrapper1535271)}] (clojure.core/cond-> {} (letvar1535272 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535272 ["Marker" :content]))) (letvar1535272 "SnapshotCopyGrants") (clojure.core/assoc :snapshot-copy-grants (deser-snapshot-copy-grant-list (clojure.core/get-in letvar1535272 ["SnapshotCopyGrants" :content])))))))

(clojure.core/defn- response-tagged-resource-list-message ([input] (response-tagged-resource-list-message nil input)) ([resultWrapper1535274 input] (clojure.core/let [rawinput1535273 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535275 {"TaggedResources" (portkey.aws/search-for-tag rawinput1535273 "TaggedResources" :flattened? nil :result-wrapper resultWrapper1535274), "Marker" (portkey.aws/search-for-tag rawinput1535273 "Marker" :flattened? nil :result-wrapper resultWrapper1535274)}] (clojure.core/cond-> {} (letvar1535275 "TaggedResources") (clojure.core/assoc :tagged-resources (deser-tagged-resource-list (clojure.core/get-in letvar1535275 ["TaggedResources" :content]))) (letvar1535275 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535275 ["Marker" :content])))))))

(clojure.core/defn- response-invalid-tag-fault ([input] (response-invalid-tag-fault nil input)) ([resultWrapper1535277 input] (clojure.core/let [rawinput1535276 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535278 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-dependent-service-unavailable-fault ([input] (response-dependent-service-unavailable-fault nil input)) ([resultWrapper1535280 input] (clojure.core/let [rawinput1535279 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535281 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-already-exists-fault ([input] (response-cluster-subnet-group-already-exists-fault nil input)) ([resultWrapper1535283 input] (clojure.core/let [rawinput1535282 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535284 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-parameter-group-details ([input] (response-cluster-parameter-group-details nil input)) ([resultWrapper1535286 input] (clojure.core/let [rawinput1535285 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535287 {"Parameters" (portkey.aws/search-for-tag rawinput1535285 "Parameters" :flattened? nil :result-wrapper resultWrapper1535286), "Marker" (portkey.aws/search-for-tag rawinput1535285 "Marker" :flattened? nil :result-wrapper resultWrapper1535286)}] (clojure.core/cond-> {} (letvar1535287 "Parameters") (clojure.core/assoc :parameters (deser-parameters-list (clojure.core/get-in letvar1535287 ["Parameters" :content]))) (letvar1535287 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535287 ["Marker" :content])))))))

(clojure.core/defn- response-orderable-cluster-options-message ([input] (response-orderable-cluster-options-message nil input)) ([resultWrapper1535289 input] (clojure.core/let [rawinput1535288 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535290 {"OrderableClusterOptions" (portkey.aws/search-for-tag rawinput1535288 "OrderableClusterOptions" :flattened? nil :result-wrapper resultWrapper1535289), "Marker" (portkey.aws/search-for-tag rawinput1535288 "Marker" :flattened? nil :result-wrapper resultWrapper1535289)}] (clojure.core/cond-> {} (letvar1535290 "OrderableClusterOptions") (clojure.core/assoc :orderable-cluster-options (deser-orderable-cluster-options-list (clojure.core/get-in letvar1535290 ["OrderableClusterOptions" :content]))) (letvar1535290 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535290 ["Marker" :content])))))))

(clojure.core/defn- response-snapshot-schedule ([input] (response-snapshot-schedule nil input)) ([resultWrapper1535292 input] (clojure.core/let [rawinput1535291 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535293 {"ScheduleDefinitions" (portkey.aws/search-for-tag rawinput1535291 "ScheduleDefinitions" :flattened? nil :result-wrapper resultWrapper1535292), "ScheduleIdentifier" (portkey.aws/search-for-tag rawinput1535291 "ScheduleIdentifier" :flattened? nil :result-wrapper resultWrapper1535292), "ScheduleDescription" (portkey.aws/search-for-tag rawinput1535291 "ScheduleDescription" :flattened? nil :result-wrapper resultWrapper1535292), "Tags" (portkey.aws/search-for-tag rawinput1535291 "Tags" :flattened? nil :result-wrapper resultWrapper1535292), "NextInvocations" (portkey.aws/search-for-tag rawinput1535291 "NextInvocations" :flattened? nil :result-wrapper resultWrapper1535292), "AssociatedClusterCount" (portkey.aws/search-for-tag rawinput1535291 "AssociatedClusterCount" :flattened? nil :result-wrapper resultWrapper1535292), "AssociatedClusters" (portkey.aws/search-for-tag rawinput1535291 "AssociatedClusters" :flattened? nil :result-wrapper resultWrapper1535292)}] (clojure.core/cond-> {} (letvar1535293 "ScheduleDefinitions") (clojure.core/assoc :schedule-definitions (deser-schedule-definition-list (clojure.core/get-in letvar1535293 ["ScheduleDefinitions" :content]))) (letvar1535293 "ScheduleIdentifier") (clojure.core/assoc :schedule-identifier (deser-string (clojure.core/get-in letvar1535293 ["ScheduleIdentifier" :content]))) (letvar1535293 "ScheduleDescription") (clojure.core/assoc :schedule-description (deser-string (clojure.core/get-in letvar1535293 ["ScheduleDescription" :content]))) (letvar1535293 "Tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1535293 ["Tags" :content]))) (letvar1535293 "NextInvocations") (clojure.core/assoc :next-invocations (deser-scheduled-snapshot-time-list (clojure.core/get-in letvar1535293 ["NextInvocations" :content]))) (letvar1535293 "AssociatedClusterCount") (clojure.core/assoc :associated-cluster-count (deser-integer-optional (clojure.core/get-in letvar1535293 ["AssociatedClusterCount" :content]))) (letvar1535293 "AssociatedClusters") (clojure.core/assoc :associated-clusters (deser-associated-cluster-list (clojure.core/get-in letvar1535293 ["AssociatedClusters" :content])))))))

(clojure.core/defn- response-describe-snapshot-schedules-output-message ([input] (response-describe-snapshot-schedules-output-message nil input)) ([resultWrapper1535295 input] (clojure.core/let [rawinput1535294 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535296 {"SnapshotSchedules" (portkey.aws/search-for-tag rawinput1535294 "SnapshotSchedules" :flattened? nil :result-wrapper resultWrapper1535295), "Marker" (portkey.aws/search-for-tag rawinput1535294 "Marker" :flattened? nil :result-wrapper resultWrapper1535295)}] (clojure.core/cond-> {} (letvar1535296 "SnapshotSchedules") (clojure.core/assoc :snapshot-schedules (deser-snapshot-schedule-list (clojure.core/get-in letvar1535296 ["SnapshotSchedules" :content]))) (letvar1535296 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535296 ["Marker" :content])))))))

(clojure.core/defn- response-invalid-restore-fault ([input] (response-invalid-restore-fault nil input)) ([resultWrapper1535298 input] (clojure.core/let [rawinput1535297 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535299 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-cluster-state-fault ([input] (response-invalid-cluster-state-fault nil input)) ([resultWrapper1535301 input] (clojure.core/let [rawinput1535300 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535302 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-already-disabled-fault ([input] (response-snapshot-copy-already-disabled-fault nil input)) ([resultWrapper1535304 input] (clojure.core/let [rawinput1535303 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535305 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-snapshot-copy-disabled-fault ([input] (response-snapshot-copy-disabled-fault nil input)) ([resultWrapper1535307 input] (clojure.core/let [rawinput1535306 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535308 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-not-found-fault ([input] (response-cluster-not-found-fault nil input)) ([resultWrapper1535310 input] (clojure.core/let [rawinput1535309 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535311 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-subnet-group-message ([input] (response-cluster-subnet-group-message nil input)) ([resultWrapper1535313 input] (clojure.core/let [rawinput1535312 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535314 {"Marker" (portkey.aws/search-for-tag rawinput1535312 "Marker" :flattened? nil :result-wrapper resultWrapper1535313), "ClusterSubnetGroups" (portkey.aws/search-for-tag rawinput1535312 "ClusterSubnetGroups" :flattened? nil :result-wrapper resultWrapper1535313)}] (clojure.core/cond-> {} (letvar1535314 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535314 ["Marker" :content]))) (letvar1535314 "ClusterSubnetGroups") (clojure.core/assoc :cluster-subnet-groups (deser-cluster-subnet-groups (clojure.core/get-in letvar1535314 ["ClusterSubnetGroups" :content])))))))

(clojure.core/defn- response-number-of-nodes-quota-exceeded-fault ([input] (response-number-of-nodes-quota-exceeded-fault nil input)) ([resultWrapper1535316 input] (clojure.core/let [rawinput1535315 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535317 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-purchase-reserved-node-offering-result ([input] (response-purchase-reserved-node-offering-result nil input)) ([resultWrapper1535319 input] (clojure.core/let [rawinput1535318 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535320 {"ReservedNode" (portkey.aws/search-for-tag rawinput1535318 "ReservedNode" :flattened? nil :result-wrapper resultWrapper1535319)}] (clojure.core/cond-> {} (letvar1535320 "ReservedNode") (clojure.core/assoc :reserved-node (deser-reserved-node (clojure.core/get-in letvar1535320 ["ReservedNode" :content])))))))

(clojure.core/defn- response-clusters-message ([input] (response-clusters-message nil input)) ([resultWrapper1535322 input] (clojure.core/let [rawinput1535321 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535323 {"Marker" (portkey.aws/search-for-tag rawinput1535321 "Marker" :flattened? nil :result-wrapper resultWrapper1535322), "Clusters" (portkey.aws/search-for-tag rawinput1535321 "Clusters" :flattened? nil :result-wrapper resultWrapper1535322)}] (clojure.core/cond-> {} (letvar1535323 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535323 ["Marker" :content]))) (letvar1535323 "Clusters") (clojure.core/assoc :clusters (deser-cluster-list (clojure.core/get-in letvar1535323 ["Clusters" :content])))))))

(clojure.core/defn- response-create-hsm-client-certificate-result ([input] (response-create-hsm-client-certificate-result nil input)) ([resultWrapper1535325 input] (clojure.core/let [rawinput1535324 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535326 {"HsmClientCertificate" (portkey.aws/search-for-tag rawinput1535324 "HsmClientCertificate" :flattened? nil :result-wrapper resultWrapper1535325)}] (clojure.core/cond-> {} (letvar1535326 "HsmClientCertificate") (clojure.core/assoc :hsm-client-certificate (deser-hsm-client-certificate (clojure.core/get-in letvar1535326 ["HsmClientCertificate" :content])))))))

(clojure.core/defn- response-revoke-snapshot-access-result ([input] (response-revoke-snapshot-access-result nil input)) ([resultWrapper1535328 input] (clojure.core/let [rawinput1535327 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535329 {"Snapshot" (portkey.aws/search-for-tag rawinput1535327 "Snapshot" :flattened? nil :result-wrapper resultWrapper1535328)}] (clojure.core/cond-> {} (letvar1535329 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar1535329 ["Snapshot" :content])))))))

(clojure.core/defn- response-invalid-cluster-subnet-state-fault ([input] (response-invalid-cluster-subnet-state-fault nil input)) ([resultWrapper1535331 input] (clojure.core/let [rawinput1535330 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535332 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-cluster-result ([input] (response-delete-cluster-result nil input)) ([resultWrapper1535334 input] (clojure.core/let [rawinput1535333 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535335 {"Cluster" (portkey.aws/search-for-tag rawinput1535333 "Cluster" :flattened? nil :result-wrapper resultWrapper1535334)}] (clojure.core/cond-> {} (letvar1535335 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535335 ["Cluster" :content])))))))

(clojure.core/defn- response-modify-snapshot-copy-retention-period-result ([input] (response-modify-snapshot-copy-retention-period-result nil input)) ([resultWrapper1535337 input] (clojure.core/let [rawinput1535336 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535338 {"Cluster" (portkey.aws/search-for-tag rawinput1535336 "Cluster" :flattened? nil :result-wrapper resultWrapper1535337)}] (clojure.core/cond-> {} (letvar1535338 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535338 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-parameter-group-name-message ([input] (response-cluster-parameter-group-name-message nil input)) ([resultWrapper1535340 input] (clojure.core/let [rawinput1535339 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535341 {"ParameterGroupName" (portkey.aws/search-for-tag rawinput1535339 "ParameterGroupName" :flattened? nil :result-wrapper resultWrapper1535340), "ParameterGroupStatus" (portkey.aws/search-for-tag rawinput1535339 "ParameterGroupStatus" :flattened? nil :result-wrapper resultWrapper1535340)}] (clojure.core/cond-> {} (letvar1535341 "ParameterGroupName") (clojure.core/assoc :parameter-group-name (deser-string (clojure.core/get-in letvar1535341 ["ParameterGroupName" :content]))) (letvar1535341 "ParameterGroupStatus") (clojure.core/assoc :parameter-group-status (deser-string (clojure.core/get-in letvar1535341 ["ParameterGroupStatus" :content])))))))

(clojure.core/defn- response-modify-event-subscription-result ([input] (response-modify-event-subscription-result nil input)) ([resultWrapper1535343 input] (clojure.core/let [rawinput1535342 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535344 {"EventSubscription" (portkey.aws/search-for-tag rawinput1535342 "EventSubscription" :flattened? nil :result-wrapper resultWrapper1535343)}] (clojure.core/cond-> {} (letvar1535344 "EventSubscription") (clojure.core/assoc :event-subscription (deser-event-subscription (clojure.core/get-in letvar1535344 ["EventSubscription" :content])))))))

(clojure.core/defn- response-modify-cluster-maintenance-result ([input] (response-modify-cluster-maintenance-result nil input)) ([resultWrapper1535346 input] (clojure.core/let [rawinput1535345 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535347 {"Cluster" (portkey.aws/search-for-tag rawinput1535345 "Cluster" :flattened? nil :result-wrapper resultWrapper1535346)}] (clojure.core/cond-> {} (letvar1535347 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535347 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-versions-message ([input] (response-cluster-versions-message nil input)) ([resultWrapper1535349 input] (clojure.core/let [rawinput1535348 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535350 {"Marker" (portkey.aws/search-for-tag rawinput1535348 "Marker" :flattened? nil :result-wrapper resultWrapper1535349), "ClusterVersions" (portkey.aws/search-for-tag rawinput1535348 "ClusterVersions" :flattened? nil :result-wrapper resultWrapper1535349)}] (clojure.core/cond-> {} (letvar1535350 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535350 ["Marker" :content]))) (letvar1535350 "ClusterVersions") (clojure.core/assoc :cluster-versions (deser-cluster-version-list (clojure.core/get-in letvar1535350 ["ClusterVersions" :content])))))))

(clojure.core/defn- response-snapshot-copy-grant-already-exists-fault ([input] (response-snapshot-copy-grant-already-exists-fault nil input)) ([resultWrapper1535352 input] (clojure.core/let [rawinput1535351 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535353 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-sns-invalid-topic-fault ([input] (response-sns-invalid-topic-fault nil input)) ([resultWrapper1535355 input] (clojure.core/let [rawinput1535354 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535356 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unknown-snapshot-copy-region-fault ([input] (response-unknown-snapshot-copy-region-fault nil input)) ([resultWrapper1535358 input] (clojure.core/let [rawinput1535357 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535359 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-table-limit-exceeded-fault ([input] (response-table-limit-exceeded-fault nil input)) ([resultWrapper1535361 input] (clojure.core/let [rawinput1535360 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535362 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-subnet-group-result ([input] (response-modify-cluster-subnet-group-result nil input)) ([resultWrapper1535364 input] (clojure.core/let [rawinput1535363 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535365 {"ClusterSubnetGroup" (portkey.aws/search-for-tag rawinput1535363 "ClusterSubnetGroup" :flattened? nil :result-wrapper resultWrapper1535364)}] (clojure.core/cond-> {} (letvar1535365 "ClusterSubnetGroup") (clojure.core/assoc :cluster-subnet-group (deser-cluster-subnet-group (clojure.core/get-in letvar1535365 ["ClusterSubnetGroup" :content])))))))

(clojure.core/defn- response-access-to-snapshot-denied-fault ([input] (response-access-to-snapshot-denied-fault nil input)) ([resultWrapper1535367 input] (clojure.core/let [rawinput1535366 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535368 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-batch-delete-cluster-snapshots-result ([input] (response-batch-delete-cluster-snapshots-result nil input)) ([resultWrapper1535370 input] (clojure.core/let [rawinput1535369 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535371 {"Resources" (portkey.aws/search-for-tag rawinput1535369 "Resources" :flattened? nil :result-wrapper resultWrapper1535370), "Errors" (portkey.aws/search-for-tag rawinput1535369 "Errors" :flattened? nil :result-wrapper resultWrapper1535370)}] (clojure.core/cond-> {} (letvar1535371 "Resources") (clojure.core/assoc :resources (deser-snapshot-identifier-list (clojure.core/get-in letvar1535371 ["Resources" :content]))) (letvar1535371 "Errors") (clojure.core/assoc :errors (deser-batch-snapshot-operation-error-list (clojure.core/get-in letvar1535371 ["Errors" :content])))))))

(clojure.core/defn- response-hsm-client-certificate-already-exists-fault ([input] (response-hsm-client-certificate-already-exists-fault nil input)) ([resultWrapper1535373 input] (clojure.core/let [rawinput1535372 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535374 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-cluster-subnet-group-result ([input] (response-create-cluster-subnet-group-result nil input)) ([resultWrapper1535376 input] (clojure.core/let [rawinput1535375 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535377 {"ClusterSubnetGroup" (portkey.aws/search-for-tag rawinput1535375 "ClusterSubnetGroup" :flattened? nil :result-wrapper resultWrapper1535376)}] (clojure.core/cond-> {} (letvar1535377 "ClusterSubnetGroup") (clojure.core/assoc :cluster-subnet-group (deser-cluster-subnet-group (clojure.core/get-in letvar1535377 ["ClusterSubnetGroup" :content])))))))

(clojure.core/defn- response-invalid-cluster-parameter-group-state-fault ([input] (response-invalid-cluster-parameter-group-state-fault nil input)) ([resultWrapper1535379 input] (clojure.core/let [rawinput1535378 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535380 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-authorize-cluster-security-group-ingress-result ([input] (response-authorize-cluster-security-group-ingress-result nil input)) ([resultWrapper1535382 input] (clojure.core/let [rawinput1535381 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535383 {"ClusterSecurityGroup" (portkey.aws/search-for-tag rawinput1535381 "ClusterSecurityGroup" :flattened? nil :result-wrapper resultWrapper1535382)}] (clojure.core/cond-> {} (letvar1535383 "ClusterSecurityGroup") (clojure.core/assoc :cluster-security-group (deser-cluster-security-group (clojure.core/get-in letvar1535383 ["ClusterSecurityGroup" :content])))))))

(clojure.core/defn- response-tag-limit-exceeded-fault ([input] (response-tag-limit-exceeded-fault nil input)) ([resultWrapper1535385 input] (clojure.core/let [rawinput1535384 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535386 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-modify-cluster-iam-roles-result ([input] (response-modify-cluster-iam-roles-result nil input)) ([resultWrapper1535388 input] (clojure.core/let [rawinput1535387 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535389 {"Cluster" (portkey.aws/search-for-tag rawinput1535387 "Cluster" :flattened? nil :result-wrapper resultWrapper1535388)}] (clojure.core/cond-> {} (letvar1535389 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535389 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-on-latest-revision-fault ([input] (response-cluster-on-latest-revision-fault nil input)) ([resultWrapper1535391 input] (clojure.core/let [rawinput1535390 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535392 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-cluster-snapshot-already-exists-fault ([input] (response-cluster-snapshot-already-exists-fault nil input)) ([resultWrapper1535394 input] (clojure.core/let [rawinput1535393 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535395 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-unsupported-operation-fault ([input] (response-unsupported-operation-fault nil input)) ([resultWrapper1535397 input] (clojure.core/let [rawinput1535396 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535398 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-hsm-configuration-result ([input] (response-create-hsm-configuration-result nil input)) ([resultWrapper1535400 input] (clojure.core/let [rawinput1535399 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535401 {"HsmConfiguration" (portkey.aws/search-for-tag rawinput1535399 "HsmConfiguration" :flattened? nil :result-wrapper resultWrapper1535400)}] (clojure.core/cond-> {} (letvar1535401 "HsmConfiguration") (clojure.core/assoc :hsm-configuration (deser-hsm-configuration (clojure.core/get-in letvar1535401 ["HsmConfiguration" :content])))))))

(clojure.core/defn- response-modify-cluster-snapshot-result ([input] (response-modify-cluster-snapshot-result nil input)) ([resultWrapper1535403 input] (clojure.core/let [rawinput1535402 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535404 {"Snapshot" (portkey.aws/search-for-tag rawinput1535402 "Snapshot" :flattened? nil :result-wrapper resultWrapper1535403)}] (clojure.core/cond-> {} (letvar1535404 "Snapshot") (clojure.core/assoc :snapshot (deser-snapshot (clojure.core/get-in letvar1535404 ["Snapshot" :content])))))))

(clojure.core/defn- response-invalid-reserved-node-state-fault ([input] (response-invalid-reserved-node-state-fault nil input)) ([resultWrapper1535406 input] (clojure.core/let [rawinput1535405 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535407 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-enable-snapshot-copy-result ([input] (response-enable-snapshot-copy-result nil input)) ([resultWrapper1535409 input] (clojure.core/let [rawinput1535408 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535410 {"Cluster" (portkey.aws/search-for-tag rawinput1535408 "Cluster" :flattened? nil :result-wrapper resultWrapper1535409)}] (clojure.core/cond-> {} (letvar1535410 "Cluster") (clojure.core/assoc :cluster (deser-cluster (clojure.core/get-in letvar1535410 ["Cluster" :content])))))))

(clojure.core/defn- response-cluster-parameter-groups-message ([input] (response-cluster-parameter-groups-message nil input)) ([resultWrapper1535412 input] (clojure.core/let [rawinput1535411 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535413 {"Marker" (portkey.aws/search-for-tag rawinput1535411 "Marker" :flattened? nil :result-wrapper resultWrapper1535412), "ParameterGroups" (portkey.aws/search-for-tag rawinput1535411 "ParameterGroups" :flattened? nil :result-wrapper resultWrapper1535412)}] (clojure.core/cond-> {} (letvar1535413 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535413 ["Marker" :content]))) (letvar1535413 "ParameterGroups") (clojure.core/assoc :parameter-groups (deser-parameter-group-list (clojure.core/get-in letvar1535413 ["ParameterGroups" :content])))))))

(clojure.core/defn- response-invalid-cluster-track-fault ([input] (response-invalid-cluster-track-fault nil input)) ([resultWrapper1535415 input] (clojure.core/let [rawinput1535414 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535416 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-table-restore-status-message ([input] (response-table-restore-status-message nil input)) ([resultWrapper1535418 input] (clojure.core/let [rawinput1535417 (clojure.core/some-> input :body portkey.aws/parse-xml-body) letvar1535419 {"TableRestoreStatusDetails" (portkey.aws/search-for-tag rawinput1535417 "TableRestoreStatusDetails" :flattened? nil :result-wrapper resultWrapper1535418), "Marker" (portkey.aws/search-for-tag rawinput1535417 "Marker" :flattened? nil :result-wrapper resultWrapper1535418)}] (clojure.core/cond-> {} (letvar1535419 "TableRestoreStatusDetails") (clojure.core/assoc :table-restore-status-details (deser-table-restore-status-list (clojure.core/get-in letvar1535419 ["TableRestoreStatusDetails" :content]))) (letvar1535419 "Marker") (clojure.core/assoc :marker (deser-string (clojure.core/get-in letvar1535419 ["Marker" :content])))))))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/table-restore-request-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-table-restore-status-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-table-restore-status-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-table-restore-status-message/cluster-identifier :portkey.aws.redshift.describe-table-restore-status-message/table-restore-request-id :portkey.aws.redshift.describe-table-restore-status-message/max-records :portkey.aws.redshift.describe-table-restore-status-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/source-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/vpc-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/vpc-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/additional-info (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/master-username (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/port (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/snapshot-schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-message/cluster-identifier :portkey.aws.redshift.create-cluster-message/node-type :portkey.aws.redshift.create-cluster-message/master-username :portkey.aws.redshift.create-cluster-message/master-user-password] :opt-un [:portkey.aws.redshift.create-cluster-message/enhanced-vpc-routing :portkey.aws.redshift.create-cluster-message/publicly-accessible :portkey.aws.redshift.create-cluster-message/preferred-maintenance-window :portkey.aws.redshift.create-cluster-message/encrypted :portkey.aws.redshift.create-cluster-message/hsm-client-certificate-identifier :portkey.aws.redshift.create-cluster-message/cluster-subnet-group-name :portkey.aws.redshift.create-cluster-message/number-of-nodes :portkey.aws.redshift.create-cluster-message/tags :portkey.aws.redshift.create-cluster-message/db-name :portkey.aws.redshift.create-cluster-message/vpc-security-group-ids :portkey.aws.redshift.create-cluster-message/availability-zone :portkey.aws.redshift.create-cluster-message/cluster-type :portkey.aws.redshift.create-cluster-message/cluster-security-groups :portkey.aws.redshift.create-cluster-message/additional-info :portkey.aws.redshift.create-cluster-message/elastic-ip :portkey.aws.redshift.create-cluster-message/hsm-configuration-identifier :portkey.aws.redshift.create-cluster-message/port :portkey.aws.redshift.create-cluster-message/maintenance-track-name :portkey.aws.redshift.create-cluster-message/kms-key-id :portkey.aws.redshift.create-cluster-message/allow-version-upgrade :portkey.aws.redshift.create-cluster-message/manual-snapshot-retention-period :portkey.aws.redshift.create-cluster-message/cluster-version :portkey.aws.redshift.create-cluster-message/automated-snapshot-retention-period :portkey.aws.redshift.create-cluster-message/iam-roles :portkey.aws.redshift.create-cluster-message/snapshot-schedule-identifier :portkey.aws.redshift.create-cluster-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/dependent-service-request-throttling-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot-copy-grant))

(clojure.spec.alpha/def :portkey.aws.redshift/insufficient-cluster-capacity-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subnet-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.enable-logging-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-logging-message/bucket-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-logging-message/s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/enable-logging-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.enable-logging-message/cluster-identifier :portkey.aws.redshift.enable-logging-message/bucket-name] :opt-un [:portkey.aws.redshift.enable-logging-message/s-3-key-prefix]))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/hsm-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/hsm-partition-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-configuration/hsm-configuration-identifier :portkey.aws.redshift.hsm-configuration/description :portkey.aws.redshift.hsm-configuration/hsm-ip-address :portkey.aws.redshift.hsm-configuration/hsm-partition-name :portkey.aws.redshift.hsm-configuration/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/avg-resize-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/total-resize-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/resize-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-encryption-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/target-number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-progress-message/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/resize-progress-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.resize-progress-message/avg-resize-rate-in-mega-bytes-per-second :portkey.aws.redshift/import-tables-not-started :portkey.aws.redshift.resize-progress-message/total-resize-data-in-mega-bytes :portkey.aws.redshift.resize-progress-message/target-cluster-type :portkey.aws.redshift.resize-progress-message/progress-in-mega-bytes :portkey.aws.redshift.resize-progress-message/status :portkey.aws.redshift.resize-progress-message/resize-type :portkey.aws.redshift.resize-progress-message/message :portkey.aws.redshift.resize-progress-message/target-node-type :portkey.aws.redshift/import-tables-completed :portkey.aws.redshift/import-tables-in-progress :portkey.aws.redshift.resize-progress-message/target-encryption-type :portkey.aws.redshift.resize-progress-message/estimated-time-to-completion-in-seconds :portkey.aws.redshift.resize-progress-message/target-number-of-nodes :portkey.aws.redshift.resize-progress-message/elapsed-time-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-hsm-client-certificates-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-hsm-client-certificates-message/hsm-client-certificate-identifier :portkey.aws.redshift.describe-hsm-client-certificates-message/max-records :portkey.aws.redshift.describe-hsm-client-certificates-message/marker :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-keys :portkey.aws.redshift.describe-hsm-client-certificates-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.redshift/batch-modify-cluster-snapshots-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.maintenance-track/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.maintenance-track/database-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.maintenance-track/update-targets (clojure.spec.alpha/and :portkey.aws.redshift/eligible-tracks-to-update-list))
(clojure.spec.alpha/def :portkey.aws.redshift/maintenance-track (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.maintenance-track/maintenance-track-name :portkey.aws.redshift.maintenance-track/database-version :portkey.aws.redshift.maintenance-track/update-targets]))

(clojure.spec.alpha/def :portkey.aws.redshift/parameters-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/parameter))

(clojure.spec.alpha/def :portkey.aws.redshift/ec-2-security-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/ec-2-security-group))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-value-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-snapshot-schedule-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-snapshot-schedule-message/disassociate-schedule (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-snapshot-schedule-message/cluster-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-snapshot-schedule-message/schedule-identifier :portkey.aws.redshift.modify-cluster-snapshot-schedule-message/disassociate-schedule]))

(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status-type #{"CANCELED" "IN_PROGRESS" :in-progress :pending "PENDING" :canceled "SUCCEEDED" "FAILED" :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.redshift/import-tables-not-started (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-node/node-role (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-node/private-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-node/public-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-node/node-role :portkey.aws.redshift.cluster-node/private-ip-address :portkey.aws.redshift.cluster-node/public-ip-address]))

(clojure.spec.alpha/def :portkey.aws.redshift/attribute-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/account-attribute))

(clojure.spec.alpha/def :portkey.aws.redshift/supported-operation-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/supported-operation))

(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-cluster-message/classic (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/resize-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.resize-cluster-message/cluster-identifier :portkey.aws.redshift.resize-cluster-message/number-of-nodes] :opt-un [:portkey.aws.redshift.resize-cluster-message/cluster-type :portkey.aws.redshift.resize-cluster-message/node-type :portkey.aws.redshift.resize-cluster-message/classic]))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/currency-code (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/node-count (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/fixed-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/duration (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/usage-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/state (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/recurring-charges (clojure.spec.alpha/and :portkey.aws.redshift/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/offering-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-node/currency-code :portkey.aws.redshift.reserved-node/start-time :portkey.aws.redshift.reserved-node/node-count :portkey.aws.redshift.reserved-node/fixed-price :portkey.aws.redshift/reserved-node-offering-type :portkey.aws.redshift.reserved-node/reserved-node-offering-id :portkey.aws.redshift.reserved-node/duration :portkey.aws.redshift.reserved-node/reserved-node-id :portkey.aws.redshift.reserved-node/usage-price :portkey.aws.redshift.reserved-node/state :portkey.aws.redshift.reserved-node/recurring-charges :portkey.aws.redshift.reserved-node/offering-type :portkey.aws.redshift.reserved-node/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.account-attribute-list/account-attributes (clojure.spec.alpha/and :portkey.aws.redshift/attribute-list))
(clojure.spec.alpha/def :portkey.aws.redshift/account-attribute-list (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.account-attribute-list/account-attributes]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-schedule-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/destination-region (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.enable-snapshot-copy-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/enable-snapshot-copy-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.enable-snapshot-copy-message/cluster-identifier :portkey.aws.redshift.enable-snapshot-copy-message/destination-region] :opt-un [:portkey.aws.redshift.enable-snapshot-copy-message/retention-period :portkey.aws.redshift.enable-snapshot-copy-message/snapshot-copy-grant-name :portkey.aws.redshift.enable-snapshot-copy-message/manual-snapshot-retention-period]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-nodes-message/reserved-nodes (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-list))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-nodes-message/marker :portkey.aws.redshift.reserved-nodes-message/reserved-nodes]))

(clojure.spec.alpha/def :portkey.aws.redshift/double-optional clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-sorting-entity/attribute (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-attribute-to-sort-by))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-sorting-entity/sort-order (clojure.spec.alpha/and :portkey.aws.redshift/sort-by-order))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-sorting-entity (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.snapshot-sorting-entity/attribute] :opt-un [:portkey.aws.redshift.snapshot-sorting-entity/sort-order]))

(clojure.spec.alpha/def :portkey.aws.redshift/source-ids-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-schedule-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.track-list-message/maintenance-tracks (clojure.spec.alpha/and :portkey.aws.redshift/track-list))
(clojure.spec.alpha/def :portkey.aws.redshift.track-list-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/track-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.track-list-message/maintenance-tracks :portkey.aws.redshift.track-list-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/sns-no-authorization-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offerings-message/reserved-node-offerings (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-offering-list))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-node-offerings-message/marker :portkey.aws.redshift.reserved-node-offerings-message/reserved-node-offerings]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/schedule-definition-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-elastic-ip-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-parameter-status))

(clojure.spec.alpha/def :portkey.aws.redshift/disable-snapshot-copy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-schedule-update-in-progress-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/authorize-snapshot-access-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-clusters-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-clusters-message/cluster-identifier :portkey.aws.redshift.describe-clusters-message/max-records :portkey.aws.redshift.describe-clusters-message/marker :portkey.aws.redshift.describe-clusters-message/tag-keys :portkey.aws.redshift.describe-clusters-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.revoke-snapshot-access-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-snapshot-access-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-snapshot-access-message/account-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/revoke-snapshot-access-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.revoke-snapshot-access-message/snapshot-identifier :portkey.aws.redshift.revoke-snapshot-access-message/account-with-restore-access] :opt-un [:portkey.aws.redshift.revoke-snapshot-access-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-subscriptions-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-event-subscriptions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-event-subscriptions-message/subscription-name :portkey.aws.redshift.describe-event-subscriptions-message/max-records :portkey.aws.redshift.describe-event-subscriptions-message/marker :portkey.aws.redshift.describe-event-subscriptions-message/tag-keys :portkey.aws.redshift.describe-event-subscriptions-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/associated-cluster-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-associated-to-schedule))

(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/owner-account (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/additional-info (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/port (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/restore-from-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.restore-from-cluster-snapshot-message/enhanced-vpc-routing :portkey.aws.redshift.restore-from-cluster-snapshot-message/publicly-accessible :portkey.aws.redshift.restore-from-cluster-snapshot-message/preferred-maintenance-window :portkey.aws.redshift.restore-from-cluster-snapshot-message/owner-account :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-client-certificate-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-subnet-group-name :portkey.aws.redshift.restore-from-cluster-snapshot-message/vpc-security-group-ids :portkey.aws.redshift.restore-from-cluster-snapshot-message/availability-zone :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-security-groups :portkey.aws.redshift.restore-from-cluster-snapshot-message/additional-info :portkey.aws.redshift.restore-from-cluster-snapshot-message/elastic-ip :portkey.aws.redshift.restore-from-cluster-snapshot-message/hsm-configuration-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/port :portkey.aws.redshift.restore-from-cluster-snapshot-message/maintenance-track-name :portkey.aws.redshift.restore-from-cluster-snapshot-message/kms-key-id :portkey.aws.redshift.restore-from-cluster-snapshot-message/allow-version-upgrade :portkey.aws.redshift.restore-from-cluster-snapshot-message/manual-snapshot-retention-period :portkey.aws.redshift.restore-from-cluster-snapshot-message/automated-snapshot-retention-period :portkey.aws.redshift.restore-from-cluster-snapshot-message/iam-roles :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-schedule-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/node-type :portkey.aws.redshift.restore-from-cluster-snapshot-message/snapshot-cluster-identifier :portkey.aws.redshift.restore-from-cluster-snapshot-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-parameter-group-message/parameter-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.subnet/subnet-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.subnet/subnet-availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/availability-zone))
(clojure.spec.alpha/def :portkey.aws.redshift.subnet/subnet-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/subnet (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.subnet/subnet-identifier :portkey.aws.redshift.subnet/subnet-availability-zone :portkey.aws.redshift.subnet/subnet-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-hsm-configurations-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-hsm-configurations-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-hsm-configurations-message/hsm-configuration-identifier :portkey.aws.redshift.describe-hsm-configurations-message/max-records :portkey.aws.redshift.describe-hsm-configurations-message/marker :portkey.aws.redshift.describe-hsm-configurations-message/tag-keys :portkey.aws.redshift.describe-hsm-configurations-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-parameter-groups-message/parameter-group-name :portkey.aws.redshift.describe-cluster-parameter-groups-message/max-records :portkey.aws.redshift.describe-cluster-parameter-groups-message/marker :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-keys :portkey.aws.redshift.describe-cluster-parameter-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-db-revision-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-db-revision-message/revision-target (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-db-revision-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-db-revision-message/cluster-identifier :portkey.aws.redshift.modify-cluster-db-revision-message/revision-target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.attribute-value-target/attribute-value (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/attribute-value-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.attribute-value-target/attribute-value]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revisions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revisions-message/cluster-db-revisions (clojure.spec.alpha/and :portkey.aws.redshift/cluster-db-revisions-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-db-revisions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-db-revisions-message/marker :portkey.aws.redshift.cluster-db-revisions-message/cluster-db-revisions]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-parameter-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-parameter-group]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-info-map-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event-info-map))

(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cidrip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/authorize-cluster-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cluster-security-group-name] :opt-un [:portkey.aws.redshift.authorize-cluster-security-group-ingress-message/cidrip :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-name :portkey.aws.redshift.authorize-cluster-security-group-ingress-message/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-configuration-message/hsm-configurations (clojure.spec.alpha/and :portkey.aws.redshift/hsm-configuration-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-configuration-message/marker :portkey.aws.redshift.hsm-configuration-message/hsm-configurations]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-hsm-configuration-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-resize-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-resize-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-resize-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-s-3-bucket-name-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cancel-resize-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cancel-resize-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.cancel-resize-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/supported-platforms-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/supported-platform))

(clojure.spec.alpha/def :portkey.aws.redshift.customer-storage-message/total-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.customer-storage-message/total-provisioned-storage-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift/customer-storage-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.customer-storage-message/total-backup-size-in-mega-bytes :portkey.aws.redshift.customer-storage-message/total-provisioned-storage-in-mega-bytes]))

(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/customer-aws-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/cust-subscription-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-subscription/subscription-creation-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/event-subscription (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-subscription/severity :portkey.aws.redshift/source-ids-list :portkey.aws.redshift.event-subscription/customer-aws-id :portkey.aws.redshift.event-subscription/tags :portkey.aws.redshift.event-subscription/source-type :portkey.aws.redshift.event-subscription/enabled :portkey.aws.redshift.event-subscription/status :portkey.aws.redshift.event-subscription/sns-topic-arn :portkey.aws.redshift/event-categories-list :portkey.aws.redshift.event-subscription/cust-subscription-id :portkey.aws.redshift.event-subscription/subscription-creation-time]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-db-revisions-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-db-revisions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-db-revisions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-db-revisions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-db-revisions-message/cluster-identifier :portkey.aws.redshift.describe-cluster-db-revisions-message/max-records :portkey.aws.redshift.describe-cluster-db-revisions-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/destination-region (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/retention-period (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-snapshot-copy-status/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-copy-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-snapshot-copy-status/destination-region :portkey.aws.redshift.cluster-snapshot-copy-status/retention-period :portkey.aws.redshift.cluster-snapshot-copy-status/manual-snapshot-retention-period :portkey.aws.redshift.cluster-snapshot-copy-status/snapshot-copy-grant-name]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-default-cluster-parameters-message/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-default-cluster-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-default-cluster-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-default-cluster-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-default-cluster-parameters-message/parameter-group-family] :opt-un [:portkey.aws.redshift.describe-default-cluster-parameters-message/max-records :portkey.aws.redshift.describe-default-cluster-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/describe-default-cluster-parameters-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/default-cluster-parameters]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-retention-period-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-message/snapshots (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-message/marker :portkey.aws.redshift.snapshot-message/snapshots]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-snapshot-message/force (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-snapshot-message/manual-snapshot-retention-period :portkey.aws.redshift.modify-cluster-snapshot-message/force]))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-severity-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-vpc-network-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-subnet-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.redshift/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-subnet-group-message/cluster-subnet-group-name :portkey.aws.redshift.modify-cluster-subnet-group-message/subnet-ids] :opt-un [:portkey.aws.redshift.modify-cluster-subnet-group-message/description]))

(clojure.spec.alpha/def :portkey.aws.redshift.batch-modify-cluster-snapshots-output-message/resources (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.batch-modify-cluster-snapshots-output-message/errors (clojure.spec.alpha/and :portkey.aws.redshift/batch-snapshot-operation-errors))
(clojure.spec.alpha/def :portkey.aws.redshift/batch-modify-cluster-snapshots-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.batch-modify-cluster-snapshots-output-message/resources :portkey.aws.redshift.batch-modify-cluster-snapshots-output-message/errors]))

(clojure.spec.alpha/def :portkey.aws.redshift.disable-logging-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/disable-logging-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.disable-logging-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-node-offerings-message/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-node-offerings-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-node-offerings-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-reserved-node-offerings-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-reserved-node-offerings-message/reserved-node-offering-id :portkey.aws.redshift.describe-reserved-node-offerings-message/max-records :portkey.aws.redshift.describe-reserved-node-offerings-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/deferred-maintenance-windows-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/deferred-maintenance-window))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering-type #{:regular :upgradable "Regular" "Upgradable"})

(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-snapshot-schedules-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-snapshot-schedules-message/cluster-identifier :portkey.aws.redshift.describe-snapshot-schedules-message/schedule-identifier :portkey.aws.redshift.describe-snapshot-schedules-message/tag-keys :portkey.aws.redshift.describe-snapshot-schedules-message/tag-values :portkey.aws.redshift.describe-snapshot-schedules-message/marker :portkey.aws.redshift.describe-snapshot-schedules-message/max-records]))

(clojure.spec.alpha/def :portkey.aws.redshift/revoke-cluster-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-table-restore-argument-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.accept-reserved-node-exchange-input-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.accept-reserved-node-exchange-input-message/target-reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/accept-reserved-node-exchange-input-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.accept-reserved-node-exchange-input-message/reserved-node-id :portkey.aws.redshift.accept-reserved-node-exchange-input-message/target-reserved-node-offering-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/orderable-cluster-options-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/orderable-cluster-option))

(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/logging-enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/bucket-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/s-3-key-prefix (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/last-successful-delivery-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/last-failure-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.logging-status/last-failure-message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/logging-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.logging-status/logging-enabled :portkey.aws.redshift.logging-status/bucket-name :portkey.aws.redshift.logging-status/s-3-key-prefix :portkey.aws.redshift.logging-status/last-successful-delivery-time :portkey.aws.redshift.logging-status/last-failure-time :portkey.aws.redshift.logging-status/last-failure-message]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-schedule-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-security-group-message/marker :portkey.aws.redshift/cluster-security-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.supported-operation/operation-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/supported-operation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.supported-operation/operation-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/reserved-node-offering))

(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/event-categories-map-list]))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/source-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/end-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/duration (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-events-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-events-message/source-identifier :portkey.aws.redshift/source-type :portkey.aws.redshift.describe-events-message/start-time :portkey.aws.redshift.describe-events-message/end-time :portkey.aws.redshift.describe-events-message/duration :portkey.aws.redshift.describe-events-message/max-records :portkey.aws.redshift.describe-events-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/parameter-apply-type #{"dynamic" "static" :static :dynamic})

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/authorization-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/bucket-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.batch-delete-cluster-snapshots-request/identifiers (clojure.spec.alpha/and :portkey.aws.redshift/delete-cluster-snapshot-message-list))
(clojure.spec.alpha/def :portkey.aws.redshift/batch-delete-cluster-snapshots-request (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.batch-delete-cluster-snapshots-request/identifiers] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/ip-range-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/ip-range))

(clojure.spec.alpha/def :portkey.aws.redshift/copy-to-region-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-schedule-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot-schedule))

(clojure.spec.alpha/def :portkey.aws.redshift/sns-topic-arn-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-public-key (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-identifier :portkey.aws.redshift.hsm-client-certificate/hsm-client-certificate-public-key :portkey.aws.redshift.hsm-client-certificate/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.events-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.events-message/events (clojure.spec.alpha/and :portkey.aws.redshift/event-list))
(clojure.spec.alpha/def :portkey.aws.redshift/events-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.events-message/marker :portkey.aws.redshift.events-message/events]))

(clojure.spec.alpha/def :portkey.aws.redshift/source-type #{:clustersecuritygroup "cluster-parameter-group" "cluster" :cluster :clusterparametergroup :clustersnapshot "cluster-snapshot" "cluster-security-group"})

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/unauthorized-operation (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/batch-snapshot-operation-error-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot-error-message))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-category-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.event/source-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event/message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.event/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event/date (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.event/event-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event/source-identifier :portkey.aws.redshift/source-type :portkey.aws.redshift.event/message :portkey.aws.redshift.event/event-categories :portkey.aws.redshift.event/severity :portkey.aws.redshift.event/date :portkey.aws.redshift.event/event-id]))

(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cidrip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/revoke-cluster-security-group-ingress-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cluster-security-group-name] :opt-un [:portkey.aws.redshift.revoke-cluster-security-group-ingress-message/cidrip :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-name :portkey.aws.redshift.revoke-cluster-security-group-ingress-message/ec-2-security-group-owner-id]))

(clojure.spec.alpha/def :portkey.aws.redshift/rotate-encryption-key-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-hsm-client-certificate-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.disable-snapshot-copy-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/disable-snapshot-copy-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.disable-snapshot-copy-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.accept-reserved-node-exchange-output-message/exchanged-reserved-node (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node))
(clojure.spec.alpha/def :portkey.aws.redshift/accept-reserved-node-exchange-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.accept-reserved-node-exchange-output-message/exchanged-reserved-node]))

(clojure.spec.alpha/def :portkey.aws.redshift/availability-zone-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/availability-zone))

(clojure.spec.alpha/def :portkey.aws.redshift.availability-zone/name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.availability-zone/supported-platforms (clojure.spec.alpha/and :portkey.aws.redshift/supported-platforms-list))
(clojure.spec.alpha/def :portkey.aws.redshift/availability-zone (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.availability-zone/name :portkey.aws.redshift.availability-zone/supported-platforms]))

(clojure.spec.alpha/def :portkey.aws.redshift.event-subscriptions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/event-subscriptions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-subscriptions-message/marker :portkey.aws.redshift/event-subscriptions-list]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-event-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/event-subscription]))

(clojure.spec.alpha/def :portkey.aws.redshift/sort-by-order #{:desc "DESC" :asc "ASC"})

(clojure.spec.alpha/def :portkey.aws.redshift/revision-targets-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/revision-target))

(clojure.spec.alpha/def :portkey.aws.redshift/restore-table-from-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/table-restore-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-event-subscription-message/subscription-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.supported-platform/name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/supported-platform (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.supported-platform/name]))

(clojure.spec.alpha/def :portkey.aws.redshift/sensitive-string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-subscription-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/reserved-node-offerings (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-offering-list))
(clojure.spec.alpha/def :portkey.aws.redshift/get-reserved-node-exchange-offerings-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/marker :portkey.aws.redshift.get-reserved-node-exchange-offerings-output-message/reserved-node-offerings]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-security-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-security-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-security-groups-message/cluster-security-group-name :portkey.aws.redshift.describe-cluster-security-groups-message/max-records :portkey.aws.redshift.describe-cluster-security-groups-message/marker :portkey.aws.redshift.describe-cluster-security-groups-message/tag-keys :portkey.aws.redshift.describe-cluster-security-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-groups (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-security-group))

(clojure.spec.alpha/def :portkey.aws.redshift.recurring-charge/recurring-charge-amount (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.recurring-charge/recurring-charge-frequency (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/recurring-charge (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.recurring-charge/recurring-charge-amount :portkey.aws.redshift.recurring-charge/recurring-charge-frequency]))

(clojure.spec.alpha/def :portkey.aws.redshift/track-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/maintenance-track))

(clojure.spec.alpha/def :portkey.aws.redshift/resize-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-parameter-group-message/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-parameter-group-message/parameter-group-name :portkey.aws.redshift.modify-cluster-parameter-group-message/parameters] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/restore-from-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/authorization-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/batch-delete-request-size-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-tags-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-tags-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-tags-message/resource-name :portkey.aws.redshift.create-tags-message/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/reboot-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/subnet-already-in-use (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/batch-snapshot-operation-errors (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot-error-message))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group-membership/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-security-group-membership/cluster-security-group-name :portkey.aws.redshift.cluster-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-iam-role/iam-role-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-iam-role/apply-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-iam-role (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-iam-role/iam-role-arn :portkey.aws.redshift.cluster-iam-role/apply-status]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-subnet (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/tag))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-security-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-client-certificate-message/hsm-client-certificates (clojure.spec.alpha/and :portkey.aws.redshift/hsm-client-certificate-list))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-client-certificate-message/marker :portkey.aws.redshift.hsm-client-certificate-message/hsm-client-certificates]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/source (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-parameters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-parameters-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-cluster-parameters-message/parameter-group-name] :opt-un [:portkey.aws.redshift.describe-cluster-parameters-message/source :portkey.aws.redshift.describe-cluster-parameters-message/max-records :portkey.aws.redshift.describe-cluster-parameters-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-snapshot-schedule-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/resource-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-tags-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-tags-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-tags-message/resource-name :portkey.aws.redshift.describe-tags-message/resource-type :portkey.aws.redshift.describe-tags-message/max-records :portkey.aws.redshift.describe-tags-message/marker :portkey.aws.redshift.describe-tags-message/tag-keys :portkey.aws.redshift.describe-tags-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/end-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/owner-account (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-exists (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-snapshots-message/sorting-entities (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-sorting-entity-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-snapshots-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-snapshots-message/tag-keys :portkey.aws.redshift.describe-cluster-snapshots-message/tag-values :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-identifier :portkey.aws.redshift.describe-cluster-snapshots-message/end-time :portkey.aws.redshift.describe-cluster-snapshots-message/start-time :portkey.aws.redshift.describe-cluster-snapshots-message/owner-account :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-identifier :portkey.aws.redshift.describe-cluster-snapshots-message/max-records :portkey.aws.redshift.describe-cluster-snapshots-message/marker :portkey.aws.redshift.describe-cluster-snapshots-message/snapshot-type :portkey.aws.redshift.describe-cluster-snapshots-message/cluster-exists :portkey.aws.redshift.describe-cluster-snapshots-message/sorting-entities]))

(clojure.spec.alpha/def :portkey.aws.redshift/unsupported-option-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-logging-status-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-logging-status-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.describe-logging-status-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-already-exist-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-db-revisions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-db-revision))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-s-3-key-prefix-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-snapshot-copy-grant-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-snapshot-copy-grant-message/snapshot-copy-grant-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-public-key (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/elastic-resize-number-of-node-options (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-parameter-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-status-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/pending-actions (clojure.spec.alpha/and :portkey.aws.redshift/pending-actions-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/master-username (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/snapshot-schedule-state (clojure.spec.alpha/and :portkey.aws.redshift/schedule-state))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-create-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-revision-number (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/modify-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/cluster-iam-role-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/vpc-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-membership-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/snapshot-schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/deferred-maintenance-windows (clojure.spec.alpha/and :portkey.aws.redshift/deferred-maintenance-windows-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/cluster-nodes (clojure.spec.alpha/and :portkey.aws.redshift/cluster-nodes-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster/cluster-public-key :portkey.aws.redshift.cluster/enhanced-vpc-routing :portkey.aws.redshift.cluster/publicly-accessible :portkey.aws.redshift.cluster/preferred-maintenance-window :portkey.aws.redshift.cluster/encrypted :portkey.aws.redshift.cluster/cluster-identifier :portkey.aws.redshift/cluster-snapshot-copy-status :portkey.aws.redshift.cluster/cluster-subnet-group-name :portkey.aws.redshift.cluster/number-of-nodes :portkey.aws.redshift.cluster/elastic-resize-number-of-node-options :portkey.aws.redshift.cluster/tags :portkey.aws.redshift.cluster/db-name :portkey.aws.redshift.cluster/cluster-parameter-groups :portkey.aws.redshift.cluster/availability-zone :portkey.aws.redshift.cluster/pending-actions :portkey.aws.redshift.cluster/cluster-security-groups :portkey.aws.redshift.cluster/master-username :portkey.aws.redshift.cluster/snapshot-schedule-state :portkey.aws.redshift/data-transfer-progress :portkey.aws.redshift.cluster/cluster-status :portkey.aws.redshift.cluster/vpc-id :portkey.aws.redshift.cluster/maintenance-track-name :portkey.aws.redshift.cluster/kms-key-id :portkey.aws.redshift/restore-status :portkey.aws.redshift.cluster/cluster-create-time :portkey.aws.redshift.cluster/cluster-revision-number :portkey.aws.redshift.cluster/allow-version-upgrade :portkey.aws.redshift.cluster/manual-snapshot-retention-period :portkey.aws.redshift.cluster/cluster-version :portkey.aws.redshift.cluster/modify-status :portkey.aws.redshift/endpoint :portkey.aws.redshift.cluster/automated-snapshot-retention-period :portkey.aws.redshift.cluster/iam-roles :portkey.aws.redshift/resize-info :portkey.aws.redshift.cluster/vpc-security-groups :portkey.aws.redshift.cluster/snapshot-schedule-identifier :portkey.aws.redshift.cluster/deferred-maintenance-windows :portkey.aws.redshift.cluster/cluster-nodes :portkey.aws.redshift/hsm-status :portkey.aws.redshift/elastic-ip-status :portkey.aws.redshift.cluster/node-type :portkey.aws.redshift/pending-modified-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/in-progress-table-restore-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/hsm-client-certificate))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-snapshot-copy-grant-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/currency-code (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/fixed-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/duration (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/usage-price (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/recurring-charges (clojure.spec.alpha/and :portkey.aws.redshift/recurring-charge-list))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/offering-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reserved-node-offering/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.reserved-node-offering/currency-code :portkey.aws.redshift.reserved-node-offering/fixed-price :portkey.aws.redshift/reserved-node-offering-type :portkey.aws.redshift.reserved-node-offering/reserved-node-offering-id :portkey.aws.redshift.reserved-node-offering/duration :portkey.aws.redshift.reserved-node-offering/usage-price :portkey.aws.redshift.reserved-node-offering/recurring-charges :portkey.aws.redshift.reserved-node-offering/offering-type :portkey.aws.redshift.reserved-node-offering/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-snapshot-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-snapshot-message/snapshot-identifier :portkey.aws.redshift.create-cluster-snapshot-message/cluster-identifier] :opt-un [:portkey.aws.redshift.create-cluster-snapshot-message/manual-snapshot-retention-period :portkey.aws.redshift.create-cluster-snapshot-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/resize-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-security-group-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-security-group-message/cluster-security-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/accounts-with-restore-access-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/account-with-restore-access))

(clojure.spec.alpha/def :portkey.aws.redshift.vpc-security-group-membership/vpc-security-group-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.vpc-security-group-membership/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/vpc-security-group-membership (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.vpc-security-group-membership/vpc-security-group-id :portkey.aws.redshift.vpc-security-group-membership/status]))

(clojure.spec.alpha/def :portkey.aws.redshift/schedule-definition-type-unsupported-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/authorization-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-nodes-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-nodes-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-reserved-nodes-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-reserved-nodes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-reserved-nodes-message/reserved-node-id :portkey.aws.redshift.describe-reserved-nodes-message/max-records :portkey.aws.redshift.describe-reserved-nodes-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-security-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/event-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/event-description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-info-map/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/event-info-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-info-map/event-id :portkey.aws.redshift.event-info-map/event-categories :portkey.aws.redshift.event-info-map/event-description :portkey.aws.redshift.event-info-map/severity]))

(clojure.spec.alpha/def :portkey.aws.redshift.update-target/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.update-target/database-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.update-target/supported-operations (clojure.spec.alpha/and :portkey.aws.redshift/supported-operation-list))
(clojure.spec.alpha/def :portkey.aws.redshift/update-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.update-target/maintenance-track-name :portkey.aws.redshift.update-target/database-version :portkey.aws.redshift.update-target/supported-operations]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/subscription-event-id-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.data-transfer-progress/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.data-transfer-progress/current-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.data-transfer-progress/total-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.data-transfer-progress/data-transferred-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.data-transfer-progress/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.data-transfer-progress/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/data-transfer-progress (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.data-transfer-progress/status :portkey.aws.redshift.data-transfer-progress/current-rate-in-mega-bytes-per-second :portkey.aws.redshift.data-transfer-progress/total-data-in-mega-bytes :portkey.aws.redshift.data-transfer-progress/data-transferred-in-mega-bytes :portkey.aws.redshift.data-transfer-progress/estimated-time-to-completion-in-seconds :portkey.aws.redshift.data-transfer-progress/elapsed-time-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-subnet-group-message/cluster-subnet-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/pending-actions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/insufficient-s-3-bucket-policy-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-credentials/db-user (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-credentials/db-password (clojure.spec.alpha/and :portkey.aws.redshift/sensitive-string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-credentials/expiration (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-credentials (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-credentials/db-user :portkey.aws.redshift.cluster-credentials/db-password :portkey.aws.redshift.cluster-credentials/expiration]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-identifier-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-snapshot-schedule-message/schedule-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/attribute-name-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-snapshot-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-already-enabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/resource-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-owner-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ec-2-security-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/ec-2-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.ec-2-security-group/status :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-name :portkey.aws.redshift.ec-2-security-group/ec-2-security-group-owner-id :portkey.aws.redshift.ec-2-security-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/subnet-ids (clojure.spec.alpha/and :portkey.aws.redshift/subnet-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-subnet-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-subnet-group-message/cluster-subnet-group-name :portkey.aws.redshift.create-cluster-subnet-group-message/description :portkey.aws.redshift.create-cluster-subnet-group-message/subnet-ids] :opt-un [:portkey.aws.redshift.create-cluster-subnet-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/preferred-maintenance-window (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/vpc-security-group-ids (clojure.spec.alpha/and :portkey.aws.redshift/vpc-security-group-id-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/allow-version-upgrade (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/new-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-message/cluster-parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-message/cluster-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-message/enhanced-vpc-routing :portkey.aws.redshift.modify-cluster-message/publicly-accessible :portkey.aws.redshift.modify-cluster-message/preferred-maintenance-window :portkey.aws.redshift.modify-cluster-message/encrypted :portkey.aws.redshift.modify-cluster-message/hsm-client-certificate-identifier :portkey.aws.redshift.modify-cluster-message/number-of-nodes :portkey.aws.redshift.modify-cluster-message/vpc-security-group-ids :portkey.aws.redshift.modify-cluster-message/cluster-type :portkey.aws.redshift.modify-cluster-message/master-user-password :portkey.aws.redshift.modify-cluster-message/cluster-security-groups :portkey.aws.redshift.modify-cluster-message/elastic-ip :portkey.aws.redshift.modify-cluster-message/hsm-configuration-identifier :portkey.aws.redshift.modify-cluster-message/maintenance-track-name :portkey.aws.redshift.modify-cluster-message/kms-key-id :portkey.aws.redshift.modify-cluster-message/allow-version-upgrade :portkey.aws.redshift.modify-cluster-message/manual-snapshot-retention-period :portkey.aws.redshift.modify-cluster-message/cluster-version :portkey.aws.redshift.modify-cluster-message/automated-snapshot-retention-period :portkey.aws.redshift.modify-cluster-message/new-cluster-identifier :portkey.aws.redshift.modify-cluster-message/node-type :portkey.aws.redshift.modify-cluster-message/cluster-parameter-group-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/copy-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-snapshot-copy-grant-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot-copy-grant]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-identifier] :opt-un [:portkey.aws.redshift.delete-cluster-snapshot-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-already-migrated-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-map-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event-categories-map))

(clojure.spec.alpha/def :portkey.aws.redshift/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift/iam-role-arn-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.parameter/data-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/parameter-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/source (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/minimum-engine-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/allowed-values (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/apply-type (clojure.spec.alpha/and :portkey.aws.redshift/parameter-apply-type))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/is-modifiable (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.parameter/parameter-value (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.parameter/data-type :portkey.aws.redshift.parameter/parameter-name :portkey.aws.redshift.parameter/source :portkey.aws.redshift.parameter/minimum-engine-version :portkey.aws.redshift.parameter/allowed-values :portkey.aws.redshift.parameter/apply-type :portkey.aws.redshift.parameter/description :portkey.aws.redshift.parameter/is-modifiable :portkey.aws.redshift.parameter/parameter-value]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-status/parameter-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-status/parameter-apply-error-description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-status/parameter-name :portkey.aws.redshift.cluster-parameter-status/parameter-apply-status :portkey.aws.redshift.cluster-parameter-status/parameter-apply-error-description]))

(clojure.spec.alpha/def :portkey.aws.redshift/vpc-security-group-id-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-status/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-status/parameter-apply-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group-status/parameter-group-name :portkey.aws.redshift.cluster-parameter-group-status/parameter-apply-status :portkey.aws.redshift/cluster-parameter-status-list]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-membership-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-security-group-membership))

(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/current-restore-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/snapshot-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-status/estimated-time-to-completion-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift/restore-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.restore-status/status :portkey.aws.redshift.restore-status/current-restore-rate-in-mega-bytes-per-second :portkey.aws.redshift.restore-status/snapshot-size-in-mega-bytes :portkey.aws.redshift.restore-status/progress-in-mega-bytes :portkey.aws.redshift.restore-status/elapsed-time-in-seconds :portkey.aws.redshift.restore-status/estimated-time-to-completion-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-snapshot-copy-grants-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-snapshot-copy-grants-message/snapshot-copy-grant-name :portkey.aws.redshift.describe-snapshot-copy-grants-message/max-records :portkey.aws.redshift.describe-snapshot-copy-grants-message/marker :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-keys :portkey.aws.redshift.describe-snapshot-copy-grants-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/skip-final-cluster-snapshot (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/final-cluster-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-cluster-message/final-cluster-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-cluster-message/cluster-identifier] :opt-un [:portkey.aws.redshift.delete-cluster-message/skip-final-cluster-snapshot :portkey.aws.redshift.delete-cluster-message/final-cluster-snapshot-identifier :portkey.aws.redshift.delete-cluster-message/final-cluster-snapshot-retention-period]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-tracks-message/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-tracks-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-tracks-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-tracks-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-tracks-message/maintenance-track-name :portkey.aws.redshift.describe-cluster-tracks-message/max-records :portkey.aws.redshift.describe-cluster-tracks-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-schedule-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.reboot-cluster-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/reboot-cluster-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.reboot-cluster-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-offering-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/incompatible-orderable-options (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/restorable-node-types (clojure.spec.alpha/and :portkey.aws.redshift/restorable-node-type-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-create-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/manual-snapshot-remaining-days (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/source-region (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/encrypted-with-hsm (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/encrypted (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/owner-account (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/estimated-seconds-to-completion (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/availability-zone (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/actual-incremental-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/master-username (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/backup-progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/accounts-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift/accounts-with-restore-access-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/port (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/cluster-create-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/elapsed-time-in-seconds (clojure.spec.alpha/and :portkey.aws.redshift/long))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/snapshot-retention-start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/current-backup-rate-in-mega-bytes-per-second (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot/total-backup-size-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/double))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot/snapshot-identifier :portkey.aws.redshift.snapshot/restorable-node-types :portkey.aws.redshift.snapshot/snapshot-create-time :portkey.aws.redshift.snapshot/enhanced-vpc-routing :portkey.aws.redshift.snapshot/manual-snapshot-remaining-days :portkey.aws.redshift.snapshot/source-region :portkey.aws.redshift.snapshot/encrypted-with-hsm :portkey.aws.redshift.snapshot/encrypted :portkey.aws.redshift.snapshot/owner-account :portkey.aws.redshift.snapshot/cluster-identifier :portkey.aws.redshift.snapshot/number-of-nodes :portkey.aws.redshift.snapshot/tags :portkey.aws.redshift.snapshot/db-name :portkey.aws.redshift.snapshot/estimated-seconds-to-completion :portkey.aws.redshift.snapshot/availability-zone :portkey.aws.redshift.snapshot/status :portkey.aws.redshift.snapshot/snapshot-type :portkey.aws.redshift.snapshot/actual-incremental-backup-size-in-mega-bytes :portkey.aws.redshift.snapshot/master-username :portkey.aws.redshift.snapshot/backup-progress-in-mega-bytes :portkey.aws.redshift.snapshot/accounts-with-restore-access :portkey.aws.redshift.snapshot/port :portkey.aws.redshift.snapshot/vpc-id :portkey.aws.redshift.snapshot/maintenance-track-name :portkey.aws.redshift.snapshot/kms-key-id :portkey.aws.redshift.snapshot/cluster-create-time :portkey.aws.redshift.snapshot/manual-snapshot-retention-period :portkey.aws.redshift.snapshot/cluster-version :portkey.aws.redshift.snapshot/elapsed-time-in-seconds :portkey.aws.redshift.snapshot/snapshot-retention-start-time :portkey.aws.redshift.snapshot/current-backup-rate-in-mega-bytes-per-second :portkey.aws.redshift.snapshot/node-type :portkey.aws.redshift.snapshot/total-backup-size-in-mega-bytes]))

(clojure.spec.alpha/def :portkey.aws.redshift/t-stamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-groups (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-subnet-group))

(clojure.spec.alpha/def :portkey.aws.redshift.event-categories-map/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.event-categories-map/events (clojure.spec.alpha/and :portkey.aws.redshift/event-info-map-list))
(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-map (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.event-categories-map/source-type :portkey.aws.redshift.event-categories-map/events]))

(clojure.spec.alpha/def :portkey.aws.redshift/event-subscription-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/source-ids (clojure.spec.alpha/and :portkey.aws.redshift/source-ids-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-event-subscription-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-event-subscription-message/subscription-name :portkey.aws.redshift.create-event-subscription-message/sns-topic-arn] :opt-un [:portkey.aws.redshift.create-event-subscription-message/source-type :portkey.aws.redshift.create-event-subscription-message/source-ids :portkey.aws.redshift.create-event-subscription-message/event-categories :portkey.aws.redshift.create-event-subscription-message/severity :portkey.aws.redshift.create-event-subscription-message/enabled :portkey.aws.redshift.create-event-subscription-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-parameter-group-status))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-db-revision-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/recurring-charge-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/recurring-charge))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant-message/snapshot-copy-grants (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-copy-grant-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-copy-grant-message/marker :portkey.aws.redshift.snapshot-copy-grant-message/snapshot-copy-grants]))

(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource-list-message/tagged-resources (clojure.spec.alpha/and :portkey.aws.redshift/tagged-resource-list))
(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource-list-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/tagged-resource-list-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.tagged-resource-list-message/tagged-resources :portkey.aws.redshift.tagged-resource-list-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-orderable-cluster-options-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-orderable-cluster-options-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-orderable-cluster-options-message/cluster-version :portkey.aws.redshift.describe-orderable-cluster-options-message/node-type :portkey.aws.redshift.describe-orderable-cluster-options-message/max-records :portkey.aws.redshift.describe-orderable-cluster-options-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/event-categories-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-tag-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/dependent-service-unavailable-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.account-with-restore-access/account-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.account-with-restore-access/account-alias (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/account-with-restore-access (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.account-with-restore-access/account-id :portkey.aws.redshift.account-with-restore-access/account-alias]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/table-restore-status))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-details/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-details/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group-details/parameters :portkey.aws.redshift.cluster-parameter-group-details/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-version/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-version/cluster-parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-version/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-version/cluster-version :portkey.aws.redshift.cluster-version/cluster-parameter-group-family :portkey.aws.redshift.cluster-version/description]))

(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-options-message/orderable-cluster-options (clojure.spec.alpha/and :portkey.aws.redshift/orderable-cluster-options-list))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-options-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/orderable-cluster-options-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.orderable-cluster-options-message/orderable-cluster-options :portkey.aws.redshift.orderable-cluster-options-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/schedule-definitions (clojure.spec.alpha/and :portkey.aws.redshift/schedule-definition-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/schedule-description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/next-invocations (clojure.spec.alpha/and :portkey.aws.redshift/scheduled-snapshot-time-list))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/associated-cluster-count (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-schedule/associated-clusters (clojure.spec.alpha/and :portkey.aws.redshift/associated-cluster-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-schedule/schedule-definitions :portkey.aws.redshift.snapshot-schedule/schedule-identifier :portkey.aws.redshift.snapshot-schedule/schedule-description :portkey.aws.redshift.snapshot-schedule/tags :portkey.aws.redshift.snapshot-schedule/next-invocations :portkey.aws.redshift.snapshot-schedule/associated-cluster-count :portkey.aws.redshift.snapshot-schedule/associated-clusters]))

(clojure.spec.alpha/def :portkey.aws.redshift.rotate-encryption-key-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/rotate-encryption-key-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.rotate-encryption-key-message/cluster-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-output-message/snapshot-schedules (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-schedule-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-snapshot-schedules-output-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-snapshot-schedules-output-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-snapshot-schedules-output-message/snapshot-schedules :portkey.aws.redshift.describe-snapshot-schedules-output-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-schedule-message/schedule-definitions (clojure.spec.alpha/and :portkey.aws.redshift/schedule-definition-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-snapshot-schedule-message/schedule-identifier :portkey.aws.redshift.modify-snapshot-schedule-message/schedule-definitions] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.endpoint/address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.endpoint/port (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift/endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.endpoint/address :portkey.aws.redshift.endpoint/port]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-parameter-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-name :portkey.aws.redshift.create-cluster-parameter-group-message/parameter-group-family :portkey.aws.redshift.create-cluster-parameter-group-message/description] :opt-un [:portkey.aws.redshift.create-cluster-parameter-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/target-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/source-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/total-data-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/request-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/new-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/progress-in-mega-bytes (clojure.spec.alpha/and :portkey.aws.redshift/long-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/source-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/status (clojure.spec.alpha/and :portkey.aws.redshift/table-restore-status-type))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/message (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/source-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/table-restore-request-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status/target-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.table-restore-status/snapshot-identifier :portkey.aws.redshift.table-restore-status/target-schema-name :portkey.aws.redshift.table-restore-status/source-schema-name :portkey.aws.redshift.table-restore-status/total-data-in-mega-bytes :portkey.aws.redshift.table-restore-status/cluster-identifier :portkey.aws.redshift.table-restore-status/request-time :portkey.aws.redshift.table-restore-status/new-table-name :portkey.aws.redshift.table-restore-status/progress-in-mega-bytes :portkey.aws.redshift.table-restore-status/source-database-name :portkey.aws.redshift.table-restore-status/status :portkey.aws.redshift.table-restore-status/message :portkey.aws.redshift.table-restore-status/source-table-name :portkey.aws.redshift.table-restore-status/table-restore-request-id :portkey.aws.redshift.table-restore-status/target-database-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-restore-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/import-tables-completed (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/reserved-node-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/reserved-node))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-sorting-entity-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/snapshot-sorting-entity))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-already-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-ip-address (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/hsm-server-public-certificate (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-configuration-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-hsm-configuration-message/hsm-configuration-identifier :portkey.aws.redshift.create-hsm-configuration-message/description :portkey.aws.redshift.create-hsm-configuration-message/hsm-ip-address :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-name :portkey.aws.redshift.create-hsm-configuration-message/hsm-partition-password :portkey.aws.redshift.create-hsm-configuration-message/hsm-server-public-certificate] :opt-un [:portkey.aws.redshift.create-hsm-configuration-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/import-tables-in-progress (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-disabled-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-not-found-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-subnet-group-message/marker :portkey.aws.redshift/cluster-subnet-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-tags-message/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.delete-tags-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-tags-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-tags-message/resource-name :portkey.aws.redshift.delete-tags-message/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-error-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-error-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-error-message/failure-code (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-error-message/failure-reason (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-error-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-error-message/snapshot-identifier :portkey.aws.redshift.snapshot-error-message/snapshot-cluster-identifier :portkey.aws.redshift.snapshot-error-message/failure-code :portkey.aws.redshift.snapshot-error-message/failure-reason]))

(clojure.spec.alpha/def :portkey.aws.redshift/attribute-value-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/attribute-value-target))

(clojure.spec.alpha/def :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-attribute-to-sort-by #{:total-size "CREATE_TIME" :source-type :create-time "SOURCE_TYPE" "TOTAL_SIZE"})

(clojure.spec.alpha/def :portkey.aws.redshift/purchase-reserved-node-offering-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/reserved-node]))

(clojure.spec.alpha/def :portkey.aws.redshift.ip-range/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ip-range/cidrip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.ip-range/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/ip-range (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.ip-range/status :portkey.aws.redshift.ip-range/cidrip :portkey.aws.redshift.ip-range/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.clusters-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.clusters-message/clusters (clojure.spec.alpha/and :portkey.aws.redshift/cluster-list))
(clojure.spec.alpha/def :portkey.aws.redshift/clusters-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.clusters-message/marker :portkey.aws.redshift.clusters-message/clusters]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/vpc-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/subnet-group-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/subnets (clojure.spec.alpha/and :portkey.aws.redshift/subnet-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-subnet-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-subnet-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-subnet-group/cluster-subnet-group-name :portkey.aws.redshift.cluster-subnet-group/description :portkey.aws.redshift.cluster-subnet-group/vpc-id :portkey.aws.redshift.cluster-subnet-group/subnet-group-status :portkey.aws.redshift.cluster-subnet-group/subnets :portkey.aws.redshift.cluster-subnet-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-client-certificate-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/hsm-client-certificate]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-nodes-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-node))

(clojure.spec.alpha/def :portkey.aws.redshift/revoke-snapshot-access-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-subnet-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/manual (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-snapshot-copy-retention-period-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-snapshot-copy-retention-period-message/cluster-identifier :portkey.aws.redshift.modify-snapshot-copy-retention-period-message/retention-period] :opt-un [:portkey.aws.redshift.modify-snapshot-copy-retention-period-message/manual]))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-snapshot-copy-retention-period-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group-name-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-name :portkey.aws.redshift.cluster-parameter-group-name-message/parameter-group-status]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-hsm-client-certificate-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-hsm-client-certificate-message/hsm-client-certificate-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.resize-info/resize-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.resize-info/allow-cancel-resize (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift/resize-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.resize-info/resize-type :portkey.aws.redshift.resize-info/allow-cancel-resize]))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-event-subscription-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/event-subscription]))

(clojure.spec.alpha/def :portkey.aws.redshift.tag/key (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.tag/value (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.tag/key :portkey.aws.redshift.tag/value]))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-maintenance-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-event-categories-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-event-categories-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-event-categories-message/source-type]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/current-database-revision (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/database-revision-release-date (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-db-revision/revision-targets (clojure.spec.alpha/and :portkey.aws.redshift/revision-targets-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-db-revision (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-db-revision/cluster-identifier :portkey.aws.redshift.cluster-db-revision/current-database-revision :portkey.aws.redshift.cluster-db-revision/database-revision-release-date :portkey.aws.redshift.cluster-db-revision/revision-targets]))

(clojure.spec.alpha/def :portkey.aws.redshift/schedule-state #{:modifying :active "ACTIVE" "FAILED" :failed "MODIFYING"})

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-versions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-versions-message/cluster-versions (clojure.spec.alpha/and :portkey.aws.redshift/cluster-version-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-versions-message/marker :portkey.aws.redshift.cluster-versions-message/cluster-versions]))

(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/boolean-optional clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.redshift/sns-invalid-topic-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-iam-role-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-iam-role))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group-name-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.deferred-maintenance-window/defer-maintenance-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.deferred-maintenance-window/defer-maintenance-start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.deferred-maintenance-window/defer-maintenance-end-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/deferred-maintenance-window (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.deferred-maintenance-window/defer-maintenance-identifier :portkey.aws.redshift.deferred-maintenance-window/defer-maintenance-start-time :portkey.aws.redshift.deferred-maintenance-window/defer-maintenance-end-time]))

(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource/resource-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.tagged-resource/resource-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/tagged-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/tag :portkey.aws.redshift.tagged-resource/resource-name :portkey.aws.redshift.tagged-resource/resource-type]))

(clojure.spec.alpha/def :portkey.aws.redshift/unknown-snapshot-copy-region-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/table-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.redshift/access-to-snapshot-denied-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/restorable-node-type-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-account-attributes-message/attribute-names (clojure.spec.alpha/and :portkey.aws.redshift/attribute-name-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-account-attributes-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-account-attributes-message/attribute-names]))

(clojure.spec.alpha/def :portkey.aws.redshift.batch-delete-cluster-snapshots-result/resources (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-identifier-list))
(clojure.spec.alpha/def :portkey.aws.redshift.batch-delete-cluster-snapshots-result/errors (clojure.spec.alpha/and :portkey.aws.redshift/batch-snapshot-operation-error-list))
(clojure.spec.alpha/def :portkey.aws.redshift/batch-delete-cluster-snapshots-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.batch-delete-cluster-snapshots-result/resources :portkey.aws.redshift.batch-delete-cluster-snapshots-result/errors]))

(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/target-snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.copy-cluster-snapshot-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/copy-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-identifier :portkey.aws.redshift.copy-cluster-snapshot-message/target-snapshot-identifier] :opt-un [:portkey.aws.redshift.copy-cluster-snapshot-message/source-snapshot-cluster-identifier :portkey.aws.redshift.copy-cluster-snapshot-message/manual-snapshot-retention-period]))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-client-certificate-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-associated-to-schedule/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-associated-to-schedule/schedule-association-state (clojure.spec.alpha/and :portkey.aws.redshift/schedule-state))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-associated-to-schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-associated-to-schedule/cluster-identifier :portkey.aws.redshift.cluster-associated-to-schedule/schedule-association-state]))

(clojure.spec.alpha/def :portkey.aws.redshift/eligible-tracks-to-update-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/update-target))

(clojure.spec.alpha/def :portkey.aws.redshift/scheduled-snapshot-time-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/t-stamp))

(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-subnet-group-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-subnet-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-group/parameter-group-name :portkey.aws.redshift.cluster-parameter-group/parameter-group-family :portkey.aws.redshift.cluster-parameter-group/description :portkey.aws.redshift.cluster-parameter-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/delete-cluster-snapshot-message-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/delete-cluster-snapshot-message))

(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/reserved-node-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/get-reserved-node-exchange-offerings-input-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/reserved-node-id] :opt-un [:portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/max-records :portkey.aws.redshift.get-reserved-node-exchange-offerings-input-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/event-subscriptions-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/event-subscription))

(clojure.spec.alpha/def :portkey.aws.redshift/hsm-configuration-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/hsm-configuration))

(clojure.spec.alpha/def :portkey.aws.redshift/authorize-cluster-security-group-ingress-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster-security-group]))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/cluster-subnet-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-keys (clojure.spec.alpha/and :portkey.aws.redshift/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-values (clojure.spec.alpha/and :portkey.aws.redshift/tag-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-subnet-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-subnet-groups-message/cluster-subnet-group-name :portkey.aws.redshift.describe-cluster-subnet-groups-message/max-records :portkey.aws.redshift.describe-cluster-subnet-groups-message/marker :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-keys :portkey.aws.redshift.describe-cluster-subnet-groups-message/tag-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/tag-limit-exceeded-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-client-certificate-message/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-hsm-client-certificate-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-client-certificate-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-hsm-client-certificate-message/hsm-client-certificate-identifier] :opt-un [:portkey.aws.redshift.create-hsm-client-certificate-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/long-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-iam-roles-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift/db-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/string))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-version-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-version))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-on-latest-revision-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift/integer-optional clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.redshift.hsm-status/hsm-client-certificate-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-status/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.hsm-status/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/hsm-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.hsm-status/hsm-client-certificate-identifier :portkey.aws.redshift.hsm-status/hsm-configuration-identifier :portkey.aws.redshift.hsm-status/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.elastic-ip-status/elastic-ip (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.elastic-ip-status/status (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/elastic-ip-status (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.elastic-ip-status/elastic-ip :portkey.aws.redshift.elastic-ip-status/status]))

(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.orderable-cluster-option/availability-zones (clojure.spec.alpha/and :portkey.aws.redshift/availability-zone-list))
(clojure.spec.alpha/def :portkey.aws.redshift/orderable-cluster-option (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.orderable-cluster-option/cluster-version :portkey.aws.redshift.orderable-cluster-option/cluster-type :portkey.aws.redshift.orderable-cluster-option/node-type :portkey.aws.redshift.orderable-cluster-option/availability-zones]))

(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-database-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-schema-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/new-table-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/restore-table-from-cluster-snapshot-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.restore-table-from-cluster-snapshot-message/cluster-identifier :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/snapshot-identifier :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-database-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-table-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/new-table-name] :opt-un [:portkey.aws.redshift.restore-table-from-cluster-snapshot-message/source-schema-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-database-name :portkey.aws.redshift.restore-table-from-cluster-snapshot-message/target-schema-name]))

(clojure.spec.alpha/def :portkey.aws.redshift/cluster-snapshot-already-exists-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-iam-roles-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-iam-roles-message/add-iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-iam-roles-message/remove-iam-roles (clojure.spec.alpha/and :portkey.aws.redshift/iam-role-arn-list))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-iam-roles-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-iam-roles-message/cluster-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-iam-roles-message/add-iam-roles :portkey.aws.redshift.modify-cluster-iam-roles-message/remove-iam-roles]))

(clojure.spec.alpha/def :portkey.aws.redshift/unsupported-operation-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/cluster-parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/max-records (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.describe-cluster-versions-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/describe-cluster-versions-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.describe-cluster-versions-message/cluster-version :portkey.aws.redshift.describe-cluster-versions-message/cluster-parameter-group-family :portkey.aws.redshift.describe-cluster-versions-message/max-records :portkey.aws.redshift.describe-cluster-versions-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.revision-target/database-revision (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revision-target/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.revision-target/database-revision-release-date (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift/revision-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.revision-target/database-revision :portkey.aws.redshift.revision-target/description :portkey.aws.redshift.revision-target/database-revision-release-date]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-schedule-message/schedule-definitions (clojure.spec.alpha/and :portkey.aws.redshift/schedule-definition-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-schedule-message/schedule-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-schedule-message/schedule-description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-schedule-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-schedule-message/dry-run (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-schedule-message/next-invocations (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/create-snapshot-schedule-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.create-snapshot-schedule-message/schedule-definitions :portkey.aws.redshift.create-snapshot-schedule-message/schedule-identifier :portkey.aws.redshift.create-snapshot-schedule-message/schedule-description :portkey.aws.redshift.create-snapshot-schedule-message/tags :portkey.aws.redshift.create-snapshot-schedule-message/dry-run :portkey.aws.redshift.create-snapshot-schedule-message/next-invocations]))

(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-copy-grant-message/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-copy-grant-message/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-snapshot-copy-grant-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-snapshot-copy-grant-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-snapshot-copy-grant-message/snapshot-copy-grant-name] :opt-un [:portkey.aws.redshift.create-snapshot-copy-grant-message/kms-key-id :portkey.aws.redshift.create-snapshot-copy-grant-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/create-hsm-configuration-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/hsm-configuration]))

(clojure.spec.alpha/def :portkey.aws.redshift.purchase-reserved-node-offering-message/reserved-node-offering-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.purchase-reserved-node-offering-message/node-count (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/purchase-reserved-node-offering-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.purchase-reserved-node-offering-message/reserved-node-offering-id] :opt-un [:portkey.aws.redshift.purchase-reserved-node-offering-message/node-count]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/ec-2-security-groups (clojure.spec.alpha/and :portkey.aws.redshift/ec-2-security-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/ip-ranges (clojure.spec.alpha/and :portkey.aws.redshift/ip-range-list))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-security-group/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-security-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-security-group/cluster-security-group-name :portkey.aws.redshift.cluster-security-group/description :portkey.aws.redshift.cluster-security-group/ec-2-security-groups :portkey.aws.redshift.cluster-security-group/ip-ranges :portkey.aws.redshift.cluster-security-group/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-snapshot-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/snapshot]))

(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/enhanced-vpc-routing (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/publicly-accessible (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/number-of-nodes (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/cluster-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/master-user-password (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/encryption-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/maintenance-track-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/cluster-version (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/automated-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.pending-modified-values/node-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/pending-modified-values (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.pending-modified-values/enhanced-vpc-routing :portkey.aws.redshift.pending-modified-values/publicly-accessible :portkey.aws.redshift.pending-modified-values/cluster-identifier :portkey.aws.redshift.pending-modified-values/number-of-nodes :portkey.aws.redshift.pending-modified-values/cluster-type :portkey.aws.redshift.pending-modified-values/master-user-password :portkey.aws.redshift.pending-modified-values/encryption-type :portkey.aws.redshift.pending-modified-values/maintenance-track-name :portkey.aws.redshift.pending-modified-values/cluster-version :portkey.aws.redshift.pending-modified-values/automated-snapshot-retention-period :portkey.aws.redshift.pending-modified-values/node-type]))

(clojure.spec.alpha/def :portkey.aws.redshift/subnet-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/subnet))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-reserved-node-state-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.authorize-snapshot-access-message/snapshot-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-snapshot-access-message/snapshot-cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.authorize-snapshot-access-message/account-with-restore-access (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/authorize-snapshot-access-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.authorize-snapshot-access-message/snapshot-identifier :portkey.aws.redshift.authorize-snapshot-access-message/account-with-restore-access] :opt-un [:portkey.aws.redshift.authorize-snapshot-access-message/snapshot-cluster-identifier]))

(clojure.spec.alpha/def :portkey.aws.redshift.reset-cluster-parameter-group-message/parameter-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.reset-cluster-parameter-group-message/reset-all-parameters (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift.reset-cluster-parameter-group-message/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift/reset-cluster-parameter-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.reset-cluster-parameter-group-message/parameter-group-name] :opt-un [:portkey.aws.redshift.reset-cluster-parameter-group-message/reset-all-parameters :portkey.aws.redshift.reset-cluster-parameter-group-message/parameters]))

(clojure.spec.alpha/def :portkey.aws.redshift.batch-modify-cluster-snapshots-message/manual-snapshot-retention-period (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.batch-modify-cluster-snapshots-message/force (clojure.spec.alpha/and :portkey.aws.redshift/boolean))
(clojure.spec.alpha/def :portkey.aws.redshift/batch-modify-cluster-snapshots-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift/snapshot-identifier-list] :opt-un [:portkey.aws.redshift.batch-modify-cluster-snapshots-message/manual-snapshot-retention-period :portkey.aws.redshift.batch-modify-cluster-snapshots-message/force]))

(clojure.spec.alpha/def :portkey.aws.redshift.account-attribute/attribute-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.account-attribute/attribute-values (clojure.spec.alpha/and :portkey.aws.redshift/attribute-value-list))
(clojure.spec.alpha/def :portkey.aws.redshift/account-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.account-attribute/attribute-name :portkey.aws.redshift.account-attribute/attribute-values]))

(clojure.spec.alpha/def :portkey.aws.redshift/enable-snapshot-copy-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift/cluster]))

(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-groups-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.cluster-parameter-groups-message/parameter-groups (clojure.spec.alpha/and :portkey.aws.redshift/parameter-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift/cluster-parameter-groups-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.cluster-parameter-groups-message/marker :portkey.aws.redshift.cluster-parameter-groups-message/parameter-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant/snapshot-copy-grant-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant/kms-key-id (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.snapshot-copy-grant/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/snapshot-copy-grant (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.snapshot-copy-grant/snapshot-copy-grant-name :portkey.aws.redshift.snapshot-copy-grant/kms-key-id :portkey.aws.redshift.snapshot-copy-grant/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift.delete-hsm-configuration-message/hsm-configuration-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/delete-hsm-configuration-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.delete-hsm-configuration-message/hsm-configuration-identifier] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-security-group-message/cluster-security-group-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-security-group-message/description (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.create-cluster-security-group-message/tags (clojure.spec.alpha/and :portkey.aws.redshift/tag-list))
(clojure.spec.alpha/def :portkey.aws.redshift/create-cluster-security-group-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.create-cluster-security-group-message/cluster-security-group-name :portkey.aws.redshift.create-cluster-security-group-message/description] :opt-un [:portkey.aws.redshift.create-cluster-security-group-message/tags]))

(clojure.spec.alpha/def :portkey.aws.redshift/parameter-group-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/cluster-parameter-group))

(clojure.spec.alpha/def :portkey.aws.redshift/tagged-resource-list (clojure.spec.alpha/coll-of :portkey.aws.redshift/tagged-resource))

(clojure.spec.alpha/def :portkey.aws.redshift/invalid-cluster-track-fault (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status-message/table-restore-status-details (clojure.spec.alpha/and :portkey.aws.redshift/table-restore-status-list))
(clojure.spec.alpha/def :portkey.aws.redshift.table-restore-status-message/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift/table-restore-status-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.table-restore-status-message/table-restore-status-details :portkey.aws.redshift.table-restore-status-message/marker]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-maintenance-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-start-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-end-time (clojure.spec.alpha/and :portkey.aws.redshift/t-stamp))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-duration (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-cluster-maintenance-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-cluster-maintenance-message/cluster-identifier] :opt-un [:portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-identifier :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-start-time :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-end-time :portkey.aws.redshift.modify-cluster-maintenance-message/defer-maintenance-duration]))

(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/db-user (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/db-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/cluster-identifier (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/duration-seconds (clojure.spec.alpha/and :portkey.aws.redshift/integer-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/auto-create (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift.get-cluster-credentials-message/db-groups (clojure.spec.alpha/and :portkey.aws.redshift/db-group-list))
(clojure.spec.alpha/def :portkey.aws.redshift/get-cluster-credentials-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.get-cluster-credentials-message/db-user :portkey.aws.redshift.get-cluster-credentials-message/cluster-identifier] :opt-un [:portkey.aws.redshift.get-cluster-credentials-message/db-name :portkey.aws.redshift.get-cluster-credentials-message/duration-seconds :portkey.aws.redshift.get-cluster-credentials-message/auto-create :portkey.aws.redshift.get-cluster-credentials-message/db-groups]))

(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/subscription-name (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/sns-topic-arn (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/source-type (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/source-ids (clojure.spec.alpha/and :portkey.aws.redshift/source-ids-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/event-categories (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-list))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/severity (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.modify-event-subscription-message/enabled (clojure.spec.alpha/and :portkey.aws.redshift/boolean-optional))
(clojure.spec.alpha/def :portkey.aws.redshift/modify-event-subscription-message (clojure.spec.alpha/keys :req-un [:portkey.aws.redshift.modify-event-subscription-message/subscription-name] :opt-un [:portkey.aws.redshift.modify-event-subscription-message/sns-topic-arn :portkey.aws.redshift.modify-event-subscription-message/source-type :portkey.aws.redshift.modify-event-subscription-message/source-ids :portkey.aws.redshift.modify-event-subscription-message/event-categories :portkey.aws.redshift.modify-event-subscription-message/severity :portkey.aws.redshift.modify-event-subscription-message/enabled]))

(clojure.spec.alpha/def :portkey.aws.redshift/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.redshift.default-cluster-parameters/parameter-group-family (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.default-cluster-parameters/marker (clojure.spec.alpha/and :portkey.aws.redshift/string))
(clojure.spec.alpha/def :portkey.aws.redshift.default-cluster-parameters/parameters (clojure.spec.alpha/and :portkey.aws.redshift/parameters-list))
(clojure.spec.alpha/def :portkey.aws.redshift/default-cluster-parameters (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.redshift.default-cluster-parameters/parameter-group-family :portkey.aws.redshift.default-cluster-parameters/marker :portkey.aws.redshift.default-cluster-parameters/parameters]))

(clojure.core/defn cancel-resize "Cancels a resize operation." ([cancel-resize-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-cancel-resize-message cancel-resize-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/resize-progress-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/cancel-resize-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CancelResizeResult", :http.request.configuration/action "CancelResize", :http.request.configuration/output-deser-fn response-resize-progress-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ResizeNotFoundFault" :portkey.aws.redshift/resize-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef cancel-resize :args (clojure.spec.alpha/tuple :portkey.aws.redshift/cancel-resize-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/resize-progress-message))

(clojure.core/defn describe-cluster-parameters "Returns a detailed list of parameters contained within the specified Amazon\nRedshift parameter group. For each parameter the response includes information\nsuch as parameter name, description, data type, value, whether the parameter\nvalue is modifiable, and so on.\n You can specify source filter to retrieve parameters of only specific type. For\nexample, to retrieve parameters that were modified by a user action such as from\nModifyClusterParameterGroup, you can specify source equal to user.\n For more information about parameters and parameter groups, go to Amazon\nRedshift Parameter Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([describe-cluster-parameters-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-parameters-message describe-cluster-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-group-details, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterParametersResult", :http.request.configuration/action "DescribeClusterParameters", :http.request.configuration/output-deser-fn response-cluster-parameter-group-details, :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-parameters :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-cluster-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-details))

(clojure.core/defn enable-snapshot-copy "Enables the automatic copy of snapshots from one region to another region for a\nspecified cluster." ([enable-snapshot-copy-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-snapshot-copy-message enable-snapshot-copy-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/enable-snapshot-copy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/enable-snapshot-copy-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "EnableSnapshotCopyResult", :http.request.configuration/action "EnableSnapshotCopy", :http.request.configuration/output-deser-fn response-enable-snapshot-copy-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault, "CopyToRegionDisabledFault" :portkey.aws.redshift/copy-to-region-disabled-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift/snapshot-copy-grant-not-found-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "SnapshotCopyAlreadyEnabledFault" :portkey.aws.redshift/snapshot-copy-already-enabled-fault, "IncompatibleOrderableOptions" :portkey.aws.redshift/incompatible-orderable-options, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "UnknownSnapshotCopyRegionFault" :portkey.aws.redshift/unknown-snapshot-copy-region-fault}})))))
(clojure.spec.alpha/fdef enable-snapshot-copy :args (clojure.spec.alpha/tuple :portkey.aws.redshift/enable-snapshot-copy-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/enable-snapshot-copy-result))

(clojure.core/defn disable-snapshot-copy "Disables the automatic copying of snapshots from one region to another region\nfor a specified cluster.\n If your cluster and its snapshots are encrypted using a customer master key\n(CMK) from AWS KMS, use DeleteSnapshotCopyGrant to delete the grant that grants\nAmazon Redshift permission to the CMK in the destination region." ([disable-snapshot-copy-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-disable-snapshot-copy-message disable-snapshot-copy-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/disable-snapshot-copy-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/disable-snapshot-copy-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DisableSnapshotCopyResult", :http.request.configuration/action "DisableSnapshotCopy", :http.request.configuration/output-deser-fn response-disable-snapshot-copy-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "SnapshotCopyAlreadyDisabledFault" :portkey.aws.redshift/snapshot-copy-already-disabled-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation}})))))
(clojure.spec.alpha/fdef disable-snapshot-copy :args (clojure.spec.alpha/tuple :portkey.aws.redshift/disable-snapshot-copy-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/disable-snapshot-copy-result))

(clojure.core/defn create-cluster "Creates a new cluster.\n To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster\nsubnet group name. The cluster subnet group identifies the subnets of your VPC\nthat Amazon Redshift uses when creating the cluster. For more information about\nmanaging clusters, go to Amazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide." ([create-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cluster-message create-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterResult", :http.request.configuration/action "CreateCluster", :http.request.configuration/output-deser-fn response-create-cluster-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift/cluster-already-exists-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault, "InvalidVPCNetworkStateFault" :portkey.aws.redshift/invalid-vpc-network-state-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift/snapshot-schedule-not-found-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "ClusterQuotaExceededFault" :portkey.aws.redshift/cluster-quota-exceeded-fault, "InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef create-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-result))

(clojure.core/defn describe-cluster-snapshots "Returns one or more snapshot objects, which contain metadata about your cluster\nsnapshots. By default, this operation returns information about all snapshots of\nall clusters that are owned by you AWS customer account. No information is\nreturned for snapshots owned by inactive AWS customer accounts.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all snapshots that match any combination of the specified keys\nand values. For example, if you have owner and environment for tag keys, and\nadmin and test for tag values, all snapshots that have any combination of those\nvalues are returned. Only snapshots that you own are returned in the response;\nshared snapshots are not returned with the tag key and tag value request\nparameters.\n If both tag keys and values are omitted from the request, snapshots are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-cluster-snapshots {})) ([describe-cluster-snapshots-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-snapshots-message describe-cluster-snapshots-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/snapshot-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-snapshots-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterSnapshotsResult", :http.request.configuration/action "DescribeClusterSnapshots", :http.request.configuration/output-deser-fn response-snapshot-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-snapshots :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-snapshots-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-message))

(clojure.core/defn describe-snapshot-schedules "Returns a list of snapshot schedules." ([] (describe-snapshot-schedules {})) ([describe-snapshot-schedules-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-snapshot-schedules-message describe-snapshot-schedules-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/describe-snapshot-schedules-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-snapshot-schedules-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeSnapshotSchedulesResult", :http.request.configuration/action "DescribeSnapshotSchedules", :http.request.configuration/output-deser-fn response-describe-snapshot-schedules-output-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-snapshot-schedules :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-snapshot-schedules-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/describe-snapshot-schedules-output-message))

(clojure.core/defn create-hsm-client-certificate "Creates an HSM client certificate that an Amazon Redshift cluster will use to\nconnect to the client's HSM in order to store and retrieve the keys used to\nencrypt the cluster databases.\n The command returns a public key, which you must store in the HSM. In addition\nto creating the HSM certificate, you must create an Amazon Redshift HSM\nconfiguration that provides a cluster the information needed to store and use\nencryption keys in the HSM. For more information, go to Hardware Security\nModules (http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html)\nin the Amazon Redshift Cluster Management Guide." ([create-hsm-client-certificate-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-hsm-client-certificate-message create-hsm-client-certificate-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-hsm-client-certificate-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-hsm-client-certificate-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateHsmClientCertificateResult", :http.request.configuration/action "CreateHsmClientCertificate", :http.request.configuration/output-deser-fn response-create-hsm-client-certificate-result, :http.request.spec/error-spec {"HsmClientCertificateAlreadyExistsFault" :portkey.aws.redshift/hsm-client-certificate-already-exists-fault, "HsmClientCertificateQuotaExceededFault" :portkey.aws.redshift/hsm-client-certificate-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-hsm-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-hsm-client-certificate-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-hsm-client-certificate-result))

(clojure.core/defn delete-tags "Deletes a tag or tags from a resource. You must provide the ARN of the resource\nfrom which you want to delete the tag or tags." ([delete-tags-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-tags-message delete-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTags", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundFault" :portkey.aws.redshift/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef delete-tags :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-tags-message) :ret clojure.core/true?)

(clojure.core/defn describe-cluster-subnet-groups "Returns one or more cluster subnet group objects, which contain metadata about\nyour cluster subnet groups. By default, this operation returns information about\nall cluster subnet groups that are defined in you AWS account.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all subnet groups that match any combination of the specified\nkeys and values. For example, if you have owner and environment for tag keys,\nand admin and test for tag values, all subnet groups that have any combination\nof those values are returned.\n If both tag keys and values are omitted from the request, subnet groups are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-cluster-subnet-groups {})) ([describe-cluster-subnet-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-subnet-groups-message describe-cluster-subnet-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-subnet-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-subnet-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterSubnetGroupsResult", :http.request.configuration/action "DescribeClusterSubnetGroups", :http.request.configuration/output-deser-fn response-cluster-subnet-group-message, :http.request.spec/error-spec {"ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-subnet-groups :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-subnet-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-subnet-group-message))

(clojure.core/defn delete-cluster-subnet-group "Deletes the specified cluster subnet group." ([delete-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cluster-subnet-group-message delete-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClusterSubnetGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault, "InvalidClusterSubnetStateFault" :portkey.aws.redshift/invalid-cluster-subnet-state-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-subnet-group-message) :ret clojure.core/true?)

(clojure.core/defn describe-events "Returns events related to clusters, security groups, snapshots, and parameter\ngroups for the past 14 days. Events specific to a particular cluster, security\ngroup, snapshot or parameter group can be obtained by providing the name as a\nparameter. By default, the past hour of events are returned." ([] (describe-events {})) ([describe-events-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-events-message describe-events-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/events-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-events-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventsResult", :http.request.configuration/action "DescribeEvents", :http.request.configuration/output-deser-fn response-events-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-events :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-events-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/events-message))

(clojure.core/defn rotate-encryption-key "Rotates the encryption keys for a cluster." ([rotate-encryption-key-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-rotate-encryption-key-message rotate-encryption-key-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/rotate-encryption-key-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/rotate-encryption-key-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RotateEncryptionKeyResult", :http.request.configuration/action "RotateEncryptionKey", :http.request.configuration/output-deser-fn response-rotate-encryption-key-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef rotate-encryption-key :args (clojure.spec.alpha/tuple :portkey.aws.redshift/rotate-encryption-key-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/rotate-encryption-key-result))

(clojure.core/defn describe-hsm-configurations "Returns information about the specified Amazon Redshift HSM configuration. If no\nconfiguration ID is specified, returns information about all the HSM\nconfigurations owned by your AWS customer account.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all HSM connections that match any combination of the specified\nkeys and values. For example, if you have owner and environment for tag keys,\nand admin and test for tag values, all HSM connections that have any combination\nof those values are returned.\n If both tag keys and values are omitted from the request, HSM connections are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-hsm-configurations {})) ([describe-hsm-configurations-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-hsm-configurations-message describe-hsm-configurations-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/hsm-configuration-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-hsm-configurations-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeHsmConfigurationsResult", :http.request.configuration/action "DescribeHsmConfigurations", :http.request.configuration/output-deser-fn response-hsm-configuration-message, :http.request.spec/error-spec {"HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-hsm-configurations :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-hsm-configurations-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/hsm-configuration-message))

(clojure.core/defn revoke-snapshot-access "Removes the ability of the specified AWS customer account to restore the\nspecified snapshot. If the account is currently restoring the snapshot, the\nrestore will run to completion.\n For more information about working with snapshots, go to Amazon Redshift\nSnapshots\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html) in\nthe Amazon Redshift Cluster Management Guide." ([revoke-snapshot-access-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-revoke-snapshot-access-message revoke-snapshot-access-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/revoke-snapshot-access-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/revoke-snapshot-access-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RevokeSnapshotAccessResult", :http.request.configuration/action "RevokeSnapshotAccess", :http.request.configuration/output-deser-fn response-revoke-snapshot-access-result, :http.request.spec/error-spec {"AccessToSnapshotDeniedFault" :portkey.aws.redshift/access-to-snapshot-denied-fault, "AuthorizationNotFoundFault" :portkey.aws.redshift/authorization-not-found-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault}})))))
(clojure.spec.alpha/fdef revoke-snapshot-access :args (clojure.spec.alpha/tuple :portkey.aws.redshift/revoke-snapshot-access-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/revoke-snapshot-access-result))

(clojure.core/defn create-tags "Adds one or more tags to a specified resource.\n A resource can have up to 50 tags. If you try to create more than 50 tags for a\nresource, you will receive an error and the attempt will fail.\n If you specify a key that already exists for the resource, the value for that\nkey will be updated with the new value." ([create-tags-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-tags-message create-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTags", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "ResourceNotFoundFault" :portkey.aws.redshift/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-tags :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-tags-message) :ret clojure.core/true?)

(clojure.core/defn restore-from-cluster-snapshot "Creates a new cluster from a snapshot. By default, Amazon Redshift creates the\nresulting cluster with the same configuration as the original cluster from which\nthe snapshot was created, except that the new cluster is created with the\ndefault cluster security and parameter groups. After Amazon Redshift creates the\ncluster, you can use the ModifyCluster API to associate a different security\ngroup and different parameter group with the restored cluster. If you are using\na DS node type, you can also choose to change to another DS node type of the\nsame size during restore.\n If you restore a cluster into a VPC, you must provide a cluster subnet group\nwhere you want the cluster restored.\n For more information about working with snapshots, go to Amazon Redshift\nSnapshots\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html) in\nthe Amazon Redshift Cluster Management Guide." ([restore-from-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-restore-from-cluster-snapshot-message restore-from-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/restore-from-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/restore-from-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RestoreFromClusterSnapshotResult", :http.request.configuration/action "RestoreFromClusterSnapshot", :http.request.configuration/output-deser-fn response-restore-from-cluster-snapshot-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift/cluster-already-exists-fault, "InvalidVPCNetworkStateFault" :portkey.aws.redshift/invalid-vpc-network-state-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift/snapshot-schedule-not-found-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "ClusterQuotaExceededFault" :portkey.aws.redshift/cluster-quota-exceeded-fault, "InvalidClusterSubnetGroupStateFault" :portkey.aws.redshift/invalid-cluster-subnet-group-state-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidRestoreFault" :portkey.aws.redshift/invalid-restore-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "AccessToSnapshotDeniedFault" :portkey.aws.redshift/access-to-snapshot-denied-fault, "InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef restore-from-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/restore-from-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/restore-from-cluster-snapshot-result))

(clojure.core/defn modify-cluster-parameter-group "Modifies the parameters of a parameter group.\n For more information about parameters and parameter groups, go to Amazon\nRedshift Parameter Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([modify-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-parameter-group-message modify-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterParameterGroupResult", :http.request.configuration/action "ModifyClusterParameterGroup", :http.request.configuration/output-deser-fn response-cluster-parameter-group-name-message, :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "InvalidClusterParameterGroupStateFault" :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-name-message))

(clojure.core/defn describe-cluster-db-revisions "Returns an array of ClusterDbRevision objects." ([] (describe-cluster-db-revisions {})) ([describe-cluster-db-revisions-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-db-revisions-message describe-cluster-db-revisions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-db-revisions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-db-revisions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterDbRevisionsResult", :http.request.configuration/action "DescribeClusterDbRevisions", :http.request.configuration/output-deser-fn response-cluster-db-revisions-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-db-revisions :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-db-revisions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-db-revisions-message))

(clojure.core/defn describe-table-restore-status "Lists the status of one or more table restore requests made using the\nRestoreTableFromClusterSnapshot API action. If you don't specify a value for the\nTableRestoreRequestId parameter, then DescribeTableRestoreStatus returns the\nstatus of all table restore requests ordered by the date and time of the request\nin ascending order. Otherwise DescribeTableRestoreStatus returns the status of\nthe table specified by TableRestoreRequestId." ([] (describe-table-restore-status {})) ([describe-table-restore-status-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-table-restore-status-message describe-table-restore-status-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/table-restore-status-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-table-restore-status-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeTableRestoreStatusResult", :http.request.configuration/action "DescribeTableRestoreStatus", :http.request.configuration/output-deser-fn response-table-restore-status-message, :http.request.spec/error-spec {"TableRestoreNotFoundFault" :portkey.aws.redshift/table-restore-not-found-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-table-restore-status :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-table-restore-status-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/table-restore-status-message))

(clojure.core/defn revoke-cluster-security-group-ingress "Revokes an ingress rule in an Amazon Redshift security group for a previously\nauthorized IP range or Amazon EC2 security group. To add an ingress rule, see\nAuthorizeClusterSecurityGroupIngress. For information about managing security\ngroups, go to Amazon Redshift Cluster Security Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([revoke-cluster-security-group-ingress-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-revoke-cluster-security-group-ingress-message revoke-cluster-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/revoke-cluster-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/revoke-cluster-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RevokeClusterSecurityGroupIngressResult", :http.request.configuration/action "RevokeClusterSecurityGroupIngress", :http.request.configuration/output-deser-fn response-revoke-cluster-security-group-ingress-result, :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "AuthorizationNotFoundFault" :portkey.aws.redshift/authorization-not-found-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault}})))))
(clojure.spec.alpha/fdef revoke-cluster-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.redshift/revoke-cluster-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/revoke-cluster-security-group-ingress-result))

(clojure.core/defn describe-cluster-tracks "Returns a list of all the available maintenance tracks." ([] (describe-cluster-tracks {})) ([describe-cluster-tracks-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-tracks-message describe-cluster-tracks-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/track-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-tracks-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterTracksResult", :http.request.configuration/action "DescribeClusterTracks", :http.request.configuration/output-deser-fn response-track-list-message, :http.request.spec/error-spec {"InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation}})))))
(clojure.spec.alpha/fdef describe-cluster-tracks :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-tracks-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/track-list-message))

(clojure.core/defn create-cluster-snapshot "Creates a manual snapshot of the specified cluster. The cluster must be in the\navailable state.\n For more information about working with snapshots, go to Amazon Redshift\nSnapshots\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html) in\nthe Amazon Redshift Cluster Management Guide." ([create-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cluster-snapshot-message create-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterSnapshotResult", :http.request.configuration/action "CreateClusterSnapshot", :http.request.configuration/output-deser-fn response-create-cluster-snapshot-result, :http.request.spec/error-spec {"ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift/cluster-snapshot-already-exists-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef create-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-snapshot-result))

(clojure.core/defn get-reserved-node-exchange-offerings "Returns an array of DC2 ReservedNodeOfferings that matches the payment type,\nterm, and usage price of the given DC1 reserved node." ([get-reserved-node-exchange-offerings-input-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-reserved-node-exchange-offerings-input-message get-reserved-node-exchange-offerings-input-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/get-reserved-node-exchange-offerings-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/get-reserved-node-exchange-offerings-input-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "GetReservedNodeExchangeOfferingsResult", :http.request.configuration/action "GetReservedNodeExchangeOfferings", :http.request.configuration/output-deser-fn response-get-reserved-node-exchange-offerings-output-message, :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift/reserved-node-not-found-fault, "InvalidReservedNodeStateFault" :portkey.aws.redshift/invalid-reserved-node-state-fault, "ReservedNodeAlreadyMigratedFault" :portkey.aws.redshift/reserved-node-already-migrated-fault, "ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef get-reserved-node-exchange-offerings :args (clojure.spec.alpha/tuple :portkey.aws.redshift/get-reserved-node-exchange-offerings-input-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/get-reserved-node-exchange-offerings-output-message))

(clojure.core/defn create-hsm-configuration "Creates an HSM configuration that contains the information required by an Amazon\nRedshift cluster to store and use database encryption keys in a Hardware\nSecurity Module (HSM). After creating the HSM configuration, you can specify it\nas a parameter when creating a cluster. The cluster will then store its\nencryption keys in the HSM.\n In addition to creating an HSM configuration, you must also create an HSM\nclient certificate. For more information, go to Hardware Security Modules\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html) in the\nAmazon Redshift Cluster Management Guide." ([create-hsm-configuration-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-hsm-configuration-message create-hsm-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-hsm-configuration-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-hsm-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateHsmConfigurationResult", :http.request.configuration/action "CreateHsmConfiguration", :http.request.configuration/output-deser-fn response-create-hsm-configuration-result, :http.request.spec/error-spec {"HsmConfigurationAlreadyExistsFault" :portkey.aws.redshift/hsm-configuration-already-exists-fault, "HsmConfigurationQuotaExceededFault" :portkey.aws.redshift/hsm-configuration-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-hsm-configuration :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-hsm-configuration-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-hsm-configuration-result))

(clojure.core/defn modify-snapshot-schedule "Modifies a snapshot schedule. Any schedule associated with a cluster is modified\nasynchronously." ([modify-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-snapshot-schedule-message modify-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/snapshot-schedule, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifySnapshotScheduleResult", :http.request.configuration/action "ModifySnapshotSchedule", :http.request.configuration/output-deser-fn response-snapshot-schedule, :http.request.spec/error-spec {"InvalidScheduleFault" :portkey.aws.redshift/invalid-schedule-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift/snapshot-schedule-not-found-fault, "SnapshotScheduleUpdateInProgressFault" :portkey.aws.redshift/snapshot-schedule-update-in-progress-fault}})))))
(clojure.spec.alpha/fdef modify-snapshot-schedule :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-snapshot-schedule-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-schedule))

(clojure.core/defn delete-hsm-client-certificate "Deletes the specified HSM client certificate." ([delete-hsm-client-certificate-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-hsm-client-certificate-message delete-hsm-client-certificate-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-hsm-client-certificate-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteHsmClientCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidHsmClientCertificateStateFault" :portkey.aws.redshift/invalid-hsm-client-certificate-state-fault, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-hsm-client-certificate :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-hsm-client-certificate-message) :ret clojure.core/true?)

(clojure.core/defn delete-snapshot-schedule "Deletes a snapshot schedule." ([delete-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-snapshot-schedule-message delete-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSnapshotSchedule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidClusterSnapshotScheduleStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-schedule-state-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift/snapshot-schedule-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-snapshot-schedule :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-snapshot-schedule-message) :ret clojure.core/true?)

(clojure.core/defn modify-cluster-maintenance "Modifies the maintenance settings of a cluster. For example, you can defer a\nmaintenance window. You can also update or cancel a deferment." ([modify-cluster-maintenance-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-maintenance-message modify-cluster-maintenance-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-maintenance-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-maintenance-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterMaintenanceResult", :http.request.configuration/action "ModifyClusterMaintenance", :http.request.configuration/output-deser-fn response-modify-cluster-maintenance-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-maintenance :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-maintenance-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-maintenance-result))

(clojure.core/defn describe-clusters "Returns properties of provisioned clusters including general cluster properties,\ncluster database properties, maintenance and backup properties, and security and\naccess properties. This operation supports pagination. For more information\nabout managing clusters, go to Amazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all clusters that match any combination of the specified keys\nand values. For example, if you have owner and environment for tag keys, and\nadmin and test for tag values, all clusters that have any combination of those\nvalues are returned.\n If both tag keys and values are omitted from the request, clusters are returned\nregardless of whether they have tag keys or values associated with them." ([] (describe-clusters {})) ([describe-clusters-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-clusters-message describe-clusters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/clusters-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-clusters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClustersResult", :http.request.configuration/action "DescribeClusters", :http.request.configuration/output-deser-fn response-clusters-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-clusters :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-clusters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/clusters-message))

(clojure.core/defn disable-logging "Stops logging information, such as queries and connection attempts, for the\nspecified Amazon Redshift cluster." ([disable-logging-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-disable-logging-message disable-logging-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/disable-logging-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DisableLoggingResult", :http.request.configuration/action "DisableLogging", :http.request.configuration/output-deser-fn response-logging-status, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef disable-logging :args (clojure.spec.alpha/tuple :portkey.aws.redshift/disable-logging-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/logging-status))

(clojure.core/defn batch-modify-cluster-snapshots "Modifies the settings for a list of snapshots." ([batch-modify-cluster-snapshots-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-batch-modify-cluster-snapshots-message batch-modify-cluster-snapshots-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/batch-modify-cluster-snapshots-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/batch-modify-cluster-snapshots-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "BatchModifyClusterSnapshotsResult", :http.request.configuration/action "BatchModifyClusterSnapshots", :http.request.configuration/output-deser-fn response-batch-modify-cluster-snapshots-output-message, :http.request.spec/error-spec {"InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault, "BatchModifyClusterSnapshotsLimitExceededFault" :portkey.aws.redshift/batch-modify-cluster-snapshots-limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef batch-modify-cluster-snapshots :args (clojure.spec.alpha/tuple :portkey.aws.redshift/batch-modify-cluster-snapshots-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/batch-modify-cluster-snapshots-output-message))

(clojure.core/defn delete-cluster-snapshot "Deletes the specified manual snapshot. The snapshot must be in the available\nstate, with no other users authorized to access the snapshot.\n Unlike automated snapshots, manual snapshots are retained even after you delete\nyour cluster. Amazon Redshift does not delete your manual snapshots. You must\ndelete manual snapshot explicitly to avoid getting charged. If other accounts\nare authorized to access the snapshot, you must revoke all of the authorizations\nbefore you can delete the snapshot." ([delete-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cluster-snapshot-message delete-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/delete-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteClusterSnapshotResult", :http.request.configuration/action "DeleteClusterSnapshot", :http.request.configuration/output-deser-fn response-delete-cluster-snapshot-result, :http.request.spec/error-spec {"InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/delete-cluster-snapshot-result))

(clojure.core/defn create-snapshot-copy-grant "Creates a snapshot copy grant that permits Amazon Redshift to use a customer\nmaster key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied\nsnapshots in a destination region.\n For more information about managing snapshot copy grants, go to Amazon Redshift\nDatabase Encryption\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html)\nin the Amazon Redshift Cluster Management Guide." ([create-snapshot-copy-grant-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-snapshot-copy-grant-message create-snapshot-copy-grant-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-snapshot-copy-grant-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-snapshot-copy-grant-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateSnapshotCopyGrantResult", :http.request.configuration/action "CreateSnapshotCopyGrant", :http.request.configuration/output-deser-fn response-create-snapshot-copy-grant-result, :http.request.spec/error-spec {"SnapshotCopyGrantAlreadyExistsFault" :portkey.aws.redshift/snapshot-copy-grant-already-exists-fault, "SnapshotCopyGrantQuotaExceededFault" :portkey.aws.redshift/snapshot-copy-grant-quota-exceeded-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef create-snapshot-copy-grant :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-snapshot-copy-grant-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-snapshot-copy-grant-result))

(clojure.core/defn describe-tags "Returns a list of tags. You can return tags from a specific resource by\nspecifying an ARN, or you can return all tags for a given type of resource, such\nas clusters, snapshots, and so on.\n The following are limitations for DescribeTags:\n * You cannot specify an ARN and a resource-type value together in the same\nrequest.\n * You cannot use the MaxRecords and Marker parameters together with the ARN\nparameter.\n * The MaxRecords parameter can be a range from 10 to 50 results to return in a\nrequest.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all resources that match any combination of the specified keys\nand values. For example, if you have owner and environment for tag keys, and\nadmin and test for tag values, all resources that have any combination of those\nvalues are returned.\n If both tag keys and values are omitted from the request, resources are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-tags {})) ([describe-tags-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-tags-message describe-tags-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/tagged-resource-list-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-tags-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeTagsResult", :http.request.configuration/action "DescribeTags", :http.request.configuration/output-deser-fn response-tagged-resource-list-message, :http.request.spec/error-spec {"ResourceNotFoundFault" :portkey.aws.redshift/resource-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-tags :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-tags-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/tagged-resource-list-message))

(clojure.core/defn modify-snapshot-copy-retention-period "Modifies the number of days to retain snapshots in the destination AWS Region\nafter they are copied from the source AWS Region. By default, this operation\nonly changes the retention period of copied automated snapshots. The retention\nperiods for both new and existing copied automated snapshots are updated with\nthe new retention period. You can set the manual option to change only the\nretention periods of copied manual snapshots. If you set this option, only newly\ncopied manual snapshots have the new retention period." ([modify-snapshot-copy-retention-period-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-snapshot-copy-retention-period-message modify-snapshot-copy-retention-period-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-snapshot-copy-retention-period-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-snapshot-copy-retention-period-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifySnapshotCopyRetentionPeriodResult", :http.request.configuration/action "ModifySnapshotCopyRetentionPeriod", :http.request.configuration/output-deser-fn response-modify-snapshot-copy-retention-period-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "SnapshotCopyDisabledFault" :portkey.aws.redshift/snapshot-copy-disabled-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef modify-snapshot-copy-retention-period :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-snapshot-copy-retention-period-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-snapshot-copy-retention-period-result))

(clojure.core/defn modify-cluster-snapshot "Modifies the settings for a snapshot." ([modify-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-snapshot-message modify-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterSnapshotResult", :http.request.configuration/action "ModifyClusterSnapshot", :http.request.configuration/output-deser-fn response-modify-cluster-snapshot-result, :http.request.spec/error-spec {"InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-snapshot-result))

(clojure.core/defn delete-event-subscription "Deletes an Amazon Redshift event notification subscription." ([delete-event-subscription-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-event-subscription-message delete-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteEventSubscription", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"SubscriptionNotFoundFault" :portkey.aws.redshift/subscription-not-found-fault, "InvalidSubscriptionStateFault" :portkey.aws.redshift/invalid-subscription-state-fault}})))))
(clojure.spec.alpha/fdef delete-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-event-subscription-message) :ret clojure.core/true?)

(clojure.core/defn describe-default-cluster-parameters "Returns a list of parameter settings for the specified parameter group family.\n For more information about parameters and parameter groups, go to Amazon\nRedshift Parameter Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([describe-default-cluster-parameters-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-default-cluster-parameters-message describe-default-cluster-parameters-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/describe-default-cluster-parameters-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-default-cluster-parameters-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeDefaultClusterParametersResult", :http.request.configuration/action "DescribeDefaultClusterParameters", :http.request.configuration/output-deser-fn response-describe-default-cluster-parameters-result, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-default-cluster-parameters :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-default-cluster-parameters-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/describe-default-cluster-parameters-result))

(clojure.core/defn copy-cluster-snapshot "Copies the specified automated cluster snapshot to a new manual cluster\nsnapshot. The source must be an automated snapshot and it must be in the\navailable state.\n When you delete a cluster, Amazon Redshift deletes any automated snapshots of\nthe cluster. Also, when the retention period of the snapshot expires, Amazon\nRedshift automatically deletes it. If you want to keep an automated snapshot for\na longer period, you can make a manual copy of the snapshot. Manual snapshots\nare retained until you delete them.\n For more information about working with snapshots, go to Amazon Redshift\nSnapshots\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html) in\nthe Amazon Redshift Cluster Management Guide." ([copy-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-copy-cluster-snapshot-message copy-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/copy-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/copy-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CopyClusterSnapshotResult", :http.request.configuration/action "CopyClusterSnapshot", :http.request.configuration/output-deser-fn response-copy-cluster-snapshot-result, :http.request.spec/error-spec {"ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift/cluster-snapshot-already-exists-fault, "ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef copy-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/copy-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/copy-cluster-snapshot-result))

(clojure.core/defn get-cluster-credentials "Returns a database user name and temporary password with temporary authorization\nto log on to an Amazon Redshift database. The action returns the database user\nname prefixed with IAM: if AutoCreate is False or IAMA: if AutoCreate is True.\nYou can optionally specify one or more database user groups that the user will\njoin at log on. By default, the temporary credentials expire in 900 seconds. You\ncan optionally specify a duration between 900 seconds (15 minutes) and 3600\nseconds (60 minutes). For more information, see Using IAM Authentication to\nGenerate Database User Credentials\n(http://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html)\nin the Amazon Redshift Cluster Management Guide.\n The AWS Identity and Access Management (IAM)user or role that executes\nGetClusterCredentials must have an IAM policy attached that allows access to all\nnecessary actions and resources. For more information about permissions, see\nResource Policies for GetClusterCredentials\n(http://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources)\nin the Amazon Redshift Cluster Management Guide.\n If the DbGroups parameter is specified, the IAM policy must allow the\nredshift:JoinGroup action with access to the listed dbgroups.\n In addition, if the AutoCreate parameter is set to True, then the policy must\ninclude the redshift:CreateClusterUser privilege.\n If the DbName parameter is specified, the IAM policy must allow access to the\nresource dbname for the specified database name." ([get-cluster-credentials-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-get-cluster-credentials-message get-cluster-credentials-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-credentials, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/get-cluster-credentials-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "GetClusterCredentialsResult", :http.request.configuration/action "GetClusterCredentials", :http.request.configuration/output-deser-fn response-cluster-credentials, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef get-cluster-credentials :args (clojure.spec.alpha/tuple :portkey.aws.redshift/get-cluster-credentials-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-credentials))

(clojure.core/defn resize-cluster "Changes the size of the cluster. You can change the cluster's type, or change\nthe number or type of nodes. The default behavior is to use the elastic resize\nmethod. With an elastic resize, your cluster is available for read and write\noperations more quickly than with the classic resize method.\n Elastic resize operations have the following restrictions:\n * You can only resize clusters of the following types:\n * dc2.large\n * dc2.8xlarge\n * ds2.xlarge\n * ds2.8xlarge\n * The type of nodes that you add must match the node type for the cluster." ([resize-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-resize-cluster-message resize-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/resize-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/resize-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ResizeClusterResult", :http.request.configuration/action "ResizeCluster", :http.request.configuration/output-deser-fn response-resize-cluster-result, :http.request.spec/error-spec {"InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "UnsupportedOptionFault" :portkey.aws.redshift/unsupported-option-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef resize-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/resize-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/resize-cluster-result))

(clojure.core/defn restore-table-from-cluster-snapshot "Creates a new table from a table in an Amazon Redshift cluster snapshot. You\nmust create the new table within the Amazon Redshift cluster that the snapshot\nwas taken from.\n You cannot use RestoreTableFromClusterSnapshot to restore a table with the same\nname as an existing table in an Amazon Redshift cluster. That is, you cannot\noverwrite an existing table in a cluster with a restored table. If you want to\nreplace your original table with a new, restored table, then rename or drop your\noriginal table before you call RestoreTableFromClusterSnapshot. When you have\nrenamed your original table, then you can pass the original name of the table as\nthe NewTableName parameter value in the call to RestoreTableFromClusterSnapshot.\nThis way, you can replace the original table with the table created from the\nsnapshot." ([restore-table-from-cluster-snapshot-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-restore-table-from-cluster-snapshot-message restore-table-from-cluster-snapshot-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/restore-table-from-cluster-snapshot-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/restore-table-from-cluster-snapshot-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RestoreTableFromClusterSnapshotResult", :http.request.configuration/action "RestoreTableFromClusterSnapshot", :http.request.configuration/output-deser-fn response-restore-table-from-cluster-snapshot-result, :http.request.spec/error-spec {"ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "InProgressTableRestoreQuotaExceededFault" :portkey.aws.redshift/in-progress-table-restore-quota-exceeded-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "InvalidTableRestoreArgumentFault" :portkey.aws.redshift/invalid-table-restore-argument-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef restore-table-from-cluster-snapshot :args (clojure.spec.alpha/tuple :portkey.aws.redshift/restore-table-from-cluster-snapshot-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/restore-table-from-cluster-snapshot-result))

(clojure.core/defn reset-cluster-parameter-group "Sets one or more parameters of the specified parameter group to their default\nvalues and sets the source values of the parameters to \"engine-default\". To\nreset the entire parameter group specify the ResetAllParameters parameter. For\nparameter changes to take effect you must reboot any associated clusters." ([reset-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-reset-cluster-parameter-group-message reset-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-group-name-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/reset-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ResetClusterParameterGroupResult", :http.request.configuration/action "ResetClusterParameterGroup", :http.request.configuration/output-deser-fn response-cluster-parameter-group-name-message, :http.request.spec/error-spec {"InvalidClusterParameterGroupStateFault" :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef reset-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/reset-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-group-name-message))

(clojure.core/defn enable-logging "Starts logging information, such as queries and connection attempts, for the\nspecified Amazon Redshift cluster." ([enable-logging-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-enable-logging-message enable-logging-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/enable-logging-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "EnableLoggingResult", :http.request.configuration/action "EnableLogging", :http.request.configuration/output-deser-fn response-logging-status, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "BucketNotFoundFault" :portkey.aws.redshift/bucket-not-found-fault, "InsufficientS3BucketPolicyFault" :portkey.aws.redshift/insufficient-s-3-bucket-policy-fault, "InvalidS3KeyPrefixFault" :portkey.aws.redshift/invalid-s-3-key-prefix-fault, "InvalidS3BucketNameFault" :portkey.aws.redshift/invalid-s-3-bucket-name-fault}})))))
(clojure.spec.alpha/fdef enable-logging :args (clojure.spec.alpha/tuple :portkey.aws.redshift/enable-logging-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/logging-status))

(clojure.core/defn describe-event-categories "Displays a list of event categories for all event source types, or for a\nspecified source type. For a list of the event categories and source types, go\nto Amazon Redshift Event Notifications\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html)." ([] (describe-event-categories {})) ([describe-event-categories-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-event-categories-message describe-event-categories-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/event-categories-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-event-categories-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventCategoriesResult", :http.request.configuration/action "DescribeEventCategories", :http.request.configuration/output-deser-fn response-event-categories-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-event-categories :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-event-categories-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/event-categories-message))

(clojure.core/defn describe-account-attributes "Returns a list of attributes attached to an account" ([] (describe-account-attributes {})) ([describe-account-attributes-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-account-attributes-message describe-account-attributes-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/account-attribute-list, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-account-attributes-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeAccountAttributesResult", :http.request.configuration/action "DescribeAccountAttributes", :http.request.configuration/output-deser-fn response-account-attribute-list, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-account-attributes :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-account-attributes-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/account-attribute-list))

(clojure.core/defn describe-cluster-versions "Returns descriptions of the available Amazon Redshift cluster versions. You can\ncall this operation even before creating any clusters to learn more about the\nAmazon Redshift versions. For more information about managing clusters, go to\nAmazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide." ([] (describe-cluster-versions {})) ([describe-cluster-versions-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-versions-message describe-cluster-versions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-versions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-versions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterVersionsResult", :http.request.configuration/action "DescribeClusterVersions", :http.request.configuration/output-deser-fn response-cluster-versions-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-cluster-versions :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-versions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-versions-message))

(clojure.core/defn describe-reserved-nodes "Returns the descriptions of the reserved nodes." ([] (describe-reserved-nodes {})) ([describe-reserved-nodes-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-nodes-message describe-reserved-nodes-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/reserved-nodes-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-reserved-nodes-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReservedNodesResult", :http.request.configuration/action "DescribeReservedNodes", :http.request.configuration/output-deser-fn response-reserved-nodes-message, :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift/reserved-node-not-found-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef describe-reserved-nodes :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-reserved-nodes-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/reserved-nodes-message))

(clojure.core/defn modify-cluster "Modifies the settings for a cluster. For example, you can add another security\nor parameter group, update the preferred maintenance window, or change the\nmaster user password. Resetting a cluster password or modifying the security\ngroups associated with a cluster do not need a reboot. However, modifying a\nparameter group requires a reboot for parameters to take effect. For more\ninformation about managing clusters, go to Amazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide.\n You can also change node type and the number of nodes to scale up or down the\ncluster. When resizing a cluster, you must specify both the number of nodes and\nthe node type even if one of the parameters does not change." ([modify-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-message modify-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterResult", :http.request.configuration/action "ModifyCluster", :http.request.configuration/output-deser-fn response-modify-cluster-result, :http.request.spec/error-spec {"DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InsufficientClusterCapacityFault" :portkey.aws.redshift/insufficient-cluster-capacity-fault, "NumberOfNodesPerClusterLimitExceededFault" :portkey.aws.redshift/number-of-nodes-per-cluster-limit-exceeded-fault, "InvalidElasticIpFault" :portkey.aws.redshift/invalid-elastic-ip-fault, "ClusterAlreadyExistsFault" :portkey.aws.redshift/cluster-already-exists-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "UnsupportedOptionFault" :portkey.aws.redshift/unsupported-option-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "NumberOfNodesQuotaExceededFault" :portkey.aws.redshift/number-of-nodes-quota-exceeded-fault, "TableLimitExceededFault" :portkey.aws.redshift/table-limit-exceeded-fault, "InvalidClusterTrackFault" :portkey.aws.redshift/invalid-cluster-track-fault}})))))
(clojure.spec.alpha/fdef modify-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-result))

(clojure.core/defn purchase-reserved-node-offering "Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set\nof reserved node offerings. You can purchase one or more of the offerings. You\ncan call the DescribeReservedNodeOfferings API to obtain the available reserved\nnode offerings. You can call this API by providing a specific reserved node\noffering and the number of nodes you want to reserve.\n For more information about reserved node offerings, go to Purchasing Reserved\nNodes\n(http://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html)\nin the Amazon Redshift Cluster Management Guide." ([purchase-reserved-node-offering-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-purchase-reserved-node-offering-message purchase-reserved-node-offering-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/purchase-reserved-node-offering-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/purchase-reserved-node-offering-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "PurchaseReservedNodeOfferingResult", :http.request.configuration/action "PurchaseReservedNodeOffering", :http.request.configuration/output-deser-fn response-purchase-reserved-node-offering-result, :http.request.spec/error-spec {"ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "ReservedNodeAlreadyExistsFault" :portkey.aws.redshift/reserved-node-already-exists-fault, "ReservedNodeQuotaExceededFault" :portkey.aws.redshift/reserved-node-quota-exceeded-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault}})))))
(clojure.spec.alpha/fdef purchase-reserved-node-offering :args (clojure.spec.alpha/tuple :portkey.aws.redshift/purchase-reserved-node-offering-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/purchase-reserved-node-offering-result))

(clojure.core/defn describe-reserved-node-offerings "Returns a list of the available reserved node offerings by Amazon Redshift with\ntheir descriptions including the node type, the fixed and recurring costs of\nreserving the node and duration the node will be reserved for you. These\ndescriptions help you determine which reserve node offering you want to\npurchase. You then use the unique offering ID in you call to\nPurchaseReservedNodeOffering to reserve one or more nodes for your Amazon\nRedshift cluster.\n For more information about reserved node offerings, go to Purchasing Reserved\nNodes\n(http://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html)\nin the Amazon Redshift Cluster Management Guide." ([] (describe-reserved-node-offerings {})) ([describe-reserved-node-offerings-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-reserved-node-offerings-message describe-reserved-node-offerings-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/reserved-node-offerings-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-reserved-node-offerings-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeReservedNodeOfferingsResult", :http.request.configuration/action "DescribeReservedNodeOfferings", :http.request.configuration/output-deser-fn response-reserved-node-offerings-message, :http.request.spec/error-spec {"ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault}})))))
(clojure.spec.alpha/fdef describe-reserved-node-offerings :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-reserved-node-offerings-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/reserved-node-offerings-message))

(clojure.core/defn modify-cluster-db-revision "Modifies the database revision of a cluster. The database revision is a unique\nrevision of the database running in a cluster." ([modify-cluster-db-revision-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-db-revision-message modify-cluster-db-revision-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-db-revision-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-db-revision-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterDbRevisionResult", :http.request.configuration/action "ModifyClusterDbRevision", :http.request.configuration/output-deser-fn response-modify-cluster-db-revision-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ClusterOnLatestRevisionFault" :portkey.aws.redshift/cluster-on-latest-revision-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-db-revision :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-db-revision-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-db-revision-result))

(clojure.core/defn delete-cluster-parameter-group "Deletes a specified Amazon Redshift parameter group.\n You cannot delete a parameter group if it is associated with a cluster." ([delete-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cluster-parameter-group-message delete-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClusterParameterGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidClusterParameterGroupStateFault" :portkey.aws.redshift/invalid-cluster-parameter-group-state-fault, "ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-parameter-group-message) :ret clojure.core/true?)

(clojure.core/defn accept-reserved-node-exchange "Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the\nconfiguration (term, payment type, or number of nodes) and no additional costs." ([accept-reserved-node-exchange-input-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-accept-reserved-node-exchange-input-message accept-reserved-node-exchange-input-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/accept-reserved-node-exchange-output-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/accept-reserved-node-exchange-input-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AcceptReservedNodeExchangeResult", :http.request.configuration/action "AcceptReservedNodeExchange", :http.request.configuration/output-deser-fn response-accept-reserved-node-exchange-output-message, :http.request.spec/error-spec {"ReservedNodeNotFoundFault" :portkey.aws.redshift/reserved-node-not-found-fault, "InvalidReservedNodeStateFault" :portkey.aws.redshift/invalid-reserved-node-state-fault, "ReservedNodeAlreadyMigratedFault" :portkey.aws.redshift/reserved-node-already-migrated-fault, "ReservedNodeOfferingNotFoundFault" :portkey.aws.redshift/reserved-node-offering-not-found-fault, "UnsupportedOperationFault" :portkey.aws.redshift/unsupported-operation-fault, "DependentServiceUnavailableFault" :portkey.aws.redshift/dependent-service-unavailable-fault, "ReservedNodeAlreadyExistsFault" :portkey.aws.redshift/reserved-node-already-exists-fault}})))))
(clojure.spec.alpha/fdef accept-reserved-node-exchange :args (clojure.spec.alpha/tuple :portkey.aws.redshift/accept-reserved-node-exchange-input-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/accept-reserved-node-exchange-output-message))

(clojure.core/defn delete-snapshot-copy-grant "Deletes the specified snapshot copy grant." ([delete-snapshot-copy-grant-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-snapshot-copy-grant-message delete-snapshot-copy-grant-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-snapshot-copy-grant-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSnapshotCopyGrant", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidSnapshotCopyGrantStateFault" :portkey.aws.redshift/invalid-snapshot-copy-grant-state-fault, "SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift/snapshot-copy-grant-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-snapshot-copy-grant :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-snapshot-copy-grant-message) :ret clojure.core/true?)

(clojure.core/defn delete-cluster "Deletes a previously provisioned cluster. A successful response from the web\nservice indicates that the request was received correctly. Use DescribeClusters\nto monitor the status of the deletion. The delete operation cannot be canceled\nor reverted once submitted. For more information about managing clusters, go to\nAmazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide.\n If you want to shut down the cluster and retain it for future use, set\nSkipFinalClusterSnapshot to false and specify a name for\nFinalClusterSnapshotIdentifier. You can later restore this snapshot to resume\nusing the cluster. If a final cluster snapshot is requested, the status of the\ncluster will be \"final-snapshot\" while the snapshot is being taken, then it's\n\"deleting\" once Amazon Redshift begins deleting the cluster.\n For more information about managing clusters, go to Amazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide." ([delete-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cluster-message delete-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/delete-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DeleteClusterResult", :http.request.configuration/action "DeleteCluster", :http.request.configuration/output-deser-fn response-delete-cluster-result, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterSnapshotAlreadyExistsFault" :portkey.aws.redshift/cluster-snapshot-already-exists-fault, "ClusterSnapshotQuotaExceededFault" :portkey.aws.redshift/cluster-snapshot-quota-exceeded-fault, "InvalidRetentionPeriodFault" :portkey.aws.redshift/invalid-retention-period-fault}})))))
(clojure.spec.alpha/fdef delete-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/delete-cluster-result))

(clojure.core/defn modify-event-subscription "Modifies an existing Amazon Redshift event notification subscription." ([modify-event-subscription-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-event-subscription-message modify-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-event-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyEventSubscriptionResult", :http.request.configuration/action "ModifyEventSubscription", :http.request.configuration/output-deser-fn response-modify-event-subscription-result, :http.request.spec/error-spec {"SourceNotFoundFault" :portkey.aws.redshift/source-not-found-fault, "SNSNoAuthorizationFault" :portkey.aws.redshift/sns-no-authorization-fault, "SubscriptionSeverityNotFoundFault" :portkey.aws.redshift/subscription-severity-not-found-fault, "SubscriptionNotFoundFault" :portkey.aws.redshift/subscription-not-found-fault, "SNSTopicArnNotFoundFault" :portkey.aws.redshift/sns-topic-arn-not-found-fault, "SubscriptionCategoryNotFoundFault" :portkey.aws.redshift/subscription-category-not-found-fault, "InvalidSubscriptionStateFault" :portkey.aws.redshift/invalid-subscription-state-fault, "SubscriptionEventIdNotFoundFault" :portkey.aws.redshift/subscription-event-id-not-found-fault, "SNSInvalidTopicFault" :portkey.aws.redshift/sns-invalid-topic-fault}})))))
(clojure.spec.alpha/fdef modify-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-event-subscription-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-event-subscription-result))

(clojure.core/defn describe-hsm-client-certificates "Returns information about the specified HSM client certificate. If no\ncertificate ID is specified, returns information about all the HSM certificates\nowned by your AWS customer account.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all HSM client certificates that match any combination of the\nspecified keys and values. For example, if you have owner and environment for\ntag keys, and admin and test for tag values, all HSM client certificates that\nhave any combination of those values are returned.\n If both tag keys and values are omitted from the request, HSM client\ncertificates are returned regardless of whether they have tag keys or values\nassociated with them." ([] (describe-hsm-client-certificates {})) ([describe-hsm-client-certificates-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-hsm-client-certificates-message describe-hsm-client-certificates-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/hsm-client-certificate-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-hsm-client-certificates-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeHsmClientCertificatesResult", :http.request.configuration/action "DescribeHsmClientCertificates", :http.request.configuration/output-deser-fn response-hsm-client-certificate-message, :http.request.spec/error-spec {"HsmClientCertificateNotFoundFault" :portkey.aws.redshift/hsm-client-certificate-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-hsm-client-certificates :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-hsm-client-certificates-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/hsm-client-certificate-message))

(clojure.core/defn create-event-subscription "Creates an Amazon Redshift event notification subscription. This action requires\nan ARN (Amazon Resource Name) of an Amazon SNS topic created by either the\nAmazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To\nobtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and\nsubscribe to the topic. The ARN is displayed in the SNS console.\n You can specify the source type, and lists of Amazon Redshift source IDs, event\ncategories, and event severities. Notifications will be sent for all events you\nwant that match those criteria. For example, you can specify source type =\ncluster, source ID = my-cluster-1 and mycluster2, event categories =\nAvailability, Backup, and severity = ERROR. The subscription will only send\nnotifications for those ERROR events in the Availability and Backup categories\nfor the specified clusters.\n If you specify both the source type and source IDs, such as source type =\ncluster and source identifier = my-cluster-1, notifications will be sent for all\nthe cluster events for my-cluster-1. If you specify a source type but do not\nspecify a source identifier, you will receive notice of the events for the\nobjects of that type in your AWS account. If you do not specify either the\nSourceType nor the SourceIdentifier, you will be notified of events generated\nfrom all Amazon Redshift sources belonging to your AWS account. You must specify\na source type if you specify a source ID." ([create-event-subscription-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-event-subscription-message create-event-subscription-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-event-subscription-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-event-subscription-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateEventSubscriptionResult", :http.request.configuration/action "CreateEventSubscription", :http.request.configuration/output-deser-fn response-create-event-subscription-result, :http.request.spec/error-spec {"SourceNotFoundFault" :portkey.aws.redshift/source-not-found-fault, "SNSNoAuthorizationFault" :portkey.aws.redshift/sns-no-authorization-fault, "SubscriptionSeverityNotFoundFault" :portkey.aws.redshift/subscription-severity-not-found-fault, "SNSTopicArnNotFoundFault" :portkey.aws.redshift/sns-topic-arn-not-found-fault, "SubscriptionCategoryNotFoundFault" :portkey.aws.redshift/subscription-category-not-found-fault, "SubscriptionAlreadyExistFault" :portkey.aws.redshift/subscription-already-exist-fault, "SubscriptionEventIdNotFoundFault" :portkey.aws.redshift/subscription-event-id-not-found-fault, "EventSubscriptionQuotaExceededFault" :portkey.aws.redshift/event-subscription-quota-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "SNSInvalidTopicFault" :portkey.aws.redshift/sns-invalid-topic-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef create-event-subscription :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-event-subscription-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-event-subscription-result))

(clojure.core/defn create-cluster-security-group "Creates a new Amazon Redshift security group. You use security groups to control\naccess to non-VPC clusters.\n For information about managing security groups, go to Amazon Redshift Cluster\nSecurity Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([create-cluster-security-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cluster-security-group-message create-cluster-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-security-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterSecurityGroupResult", :http.request.configuration/action "CreateClusterSecurityGroup", :http.request.configuration/output-deser-fn response-create-cluster-security-group-result, :http.request.spec/error-spec {"ClusterSecurityGroupAlreadyExistsFault" :portkey.aws.redshift/cluster-security-group-already-exists-fault, "ClusterSecurityGroupQuotaExceededFault" :portkey.aws.redshift/cluster-security-group-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-security-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-security-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-security-group-result))

(clojure.core/defn describe-snapshot-copy-grants "Returns a list of snapshot copy grants owned by the AWS account in the\ndestination region.\n For more information about managing snapshot copy grants, go to Amazon Redshift\nDatabase Encryption\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html)\nin the Amazon Redshift Cluster Management Guide." ([] (describe-snapshot-copy-grants {})) ([describe-snapshot-copy-grants-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-snapshot-copy-grants-message describe-snapshot-copy-grants-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/snapshot-copy-grant-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-snapshot-copy-grants-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeSnapshotCopyGrantsResult", :http.request.configuration/action "DescribeSnapshotCopyGrants", :http.request.configuration/output-deser-fn response-snapshot-copy-grant-message, :http.request.spec/error-spec {"SnapshotCopyGrantNotFoundFault" :portkey.aws.redshift/snapshot-copy-grant-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-snapshot-copy-grants :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-snapshot-copy-grants-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-copy-grant-message))

(clojure.core/defn modify-cluster-snapshot-schedule "Modifies a snapshot schedule for a cluster." ([modify-cluster-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-snapshot-schedule-message modify-cluster-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ModifyClusterSnapshotSchedule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "SnapshotScheduleNotFoundFault" :portkey.aws.redshift/snapshot-schedule-not-found-fault, "InvalidClusterSnapshotScheduleStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-schedule-state-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-snapshot-schedule :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-snapshot-schedule-message) :ret clojure.core/true?)

(clojure.core/defn authorize-cluster-security-group-ingress "Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending\non whether the application accessing your cluster is running on the Internet or\nan Amazon EC2 instance, you can authorize inbound access to either a Classless\nInterdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2\nsecurity group. You can add as many as 20 ingress rules to an Amazon Redshift\nsecurity group.\n If you authorize access to an Amazon EC2 security group, specify\nEC2SecurityGroupName and EC2SecurityGroupOwnerId. The Amazon EC2 security group\nand Amazon Redshift cluster must be in the same AWS Region.\n If you authorize access to a CIDR/IP address range, specify CIDRIP. For an\noverview of CIDR blocks, see the Wikipedia article on Classless Inter-Domain\nRouting (http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing).\n You must also associate the security group with a cluster so that clients\nrunning on these IP addresses or the EC2 instance are authorized to connect to\nthe cluster. For information about managing security groups, go to Working with\nSecurity Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([authorize-cluster-security-group-ingress-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-authorize-cluster-security-group-ingress-message authorize-cluster-security-group-ingress-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/authorize-cluster-security-group-ingress-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/authorize-cluster-security-group-ingress-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AuthorizeClusterSecurityGroupIngressResult", :http.request.configuration/action "AuthorizeClusterSecurityGroupIngress", :http.request.configuration/output-deser-fn response-authorize-cluster-security-group-ingress-result, :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.redshift/authorization-already-exists-fault, "AuthorizationQuotaExceededFault" :portkey.aws.redshift/authorization-quota-exceeded-fault}})))))
(clojure.spec.alpha/fdef authorize-cluster-security-group-ingress :args (clojure.spec.alpha/tuple :portkey.aws.redshift/authorize-cluster-security-group-ingress-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/authorize-cluster-security-group-ingress-result))

(clojure.core/defn modify-cluster-subnet-group "Modifies a cluster subnet group to include the specified list of VPC subnets.\nThe operation replaces the existing list of subnets with the new list of\nsubnets." ([modify-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-subnet-group-message modify-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterSubnetGroupResult", :http.request.configuration/action "ModifyClusterSubnetGroup", :http.request.configuration/output-deser-fn response-modify-cluster-subnet-group-result, :http.request.spec/error-spec {"ClusterSubnetGroupNotFoundFault" :portkey.aws.redshift/cluster-subnet-group-not-found-fault, "ClusterSubnetQuotaExceededFault" :portkey.aws.redshift/cluster-subnet-quota-exceeded-fault, "SubnetAlreadyInUse" :portkey.aws.redshift/subnet-already-in-use, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-subnet-group-result))

(clojure.core/defn delete-hsm-configuration "Deletes the specified Amazon Redshift HSM configuration." ([delete-hsm-configuration-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-hsm-configuration-message delete-hsm-configuration-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-hsm-configuration-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteHsmConfiguration", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidHsmConfigurationStateFault" :portkey.aws.redshift/invalid-hsm-configuration-state-fault, "HsmConfigurationNotFoundFault" :portkey.aws.redshift/hsm-configuration-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-hsm-configuration :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-hsm-configuration-message) :ret clojure.core/true?)

(clojure.core/defn describe-event-subscriptions "Lists descriptions of all the Amazon Redshift event notification subscriptions\nfor a customer account. If you specify a subscription name, lists the\ndescription for that subscription.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all event notification subscriptions that match any combination\nof the specified keys and values. For example, if you have owner and environment\nfor tag keys, and admin and test for tag values, all subscriptions that have any\ncombination of those values are returned.\n If both tag keys and values are omitted from the request, subscriptions are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-event-subscriptions {})) ([describe-event-subscriptions-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-event-subscriptions-message describe-event-subscriptions-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/event-subscriptions-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-event-subscriptions-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeEventSubscriptionsResult", :http.request.configuration/action "DescribeEventSubscriptions", :http.request.configuration/output-deser-fn response-event-subscriptions-message, :http.request.spec/error-spec {"SubscriptionNotFoundFault" :portkey.aws.redshift/subscription-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-event-subscriptions :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-event-subscriptions-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/event-subscriptions-message))

(clojure.core/defn describe-storage "Returns the total amount of snapshot usage and provisioned storage for a user in\nmegabytes." ([] (describe-storage {})) ([_] (clojure.core/let [request-function-result__22119__auto__ {}] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/customer-storage-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec nil, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeStorageResult", :http.request.configuration/action "DescribeStorage", :http.request.configuration/output-deser-fn response-customer-storage-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-storage :args clojure.core/empty? :ret (clojure.spec.alpha/and :portkey.aws.redshift/customer-storage-message))

(clojure.core/defn create-cluster-parameter-group "Creates an Amazon Redshift parameter group.\n Creating parameter groups is independent of creating clusters. You can\nassociate a cluster with a parameter group when you create the cluster. You can\nalso associate an existing cluster with a parameter group after the cluster is\ncreated by using ModifyCluster.\n Parameters in the parameter group define specific behavior that applies to the\ndatabases you create on the cluster. For more information about parameters and\nparameter groups, go to Amazon Redshift Parameter Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([create-cluster-parameter-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cluster-parameter-group-message create-cluster-parameter-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-parameter-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-parameter-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterParameterGroupResult", :http.request.configuration/action "CreateClusterParameterGroup", :http.request.configuration/output-deser-fn response-create-cluster-parameter-group-result, :http.request.spec/error-spec {"ClusterParameterGroupQuotaExceededFault" :portkey.aws.redshift/cluster-parameter-group-quota-exceeded-fault, "ClusterParameterGroupAlreadyExistsFault" :portkey.aws.redshift/cluster-parameter-group-already-exists-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef create-cluster-parameter-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-parameter-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-parameter-group-result))

(clojure.core/defn describe-cluster-parameter-groups "Returns a list of Amazon Redshift parameter groups, including parameter groups\nyou created and the default parameter group. For each parameter group, the\nresponse includes the parameter group name, description, and parameter group\nfamily name. You can optionally specify a name to retrieve the description of a\nspecific parameter group.\n For more information about parameters and parameter groups, go to Amazon\nRedshift Parameter Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html)\nin the Amazon Redshift Cluster Management Guide.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all parameter groups that match any combination of the\nspecified keys and values. For example, if you have owner and environment for\ntag keys, and admin and test for tag values, all parameter groups that have any\ncombination of those values are returned.\n If both tag keys and values are omitted from the request, parameter groups are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-cluster-parameter-groups {})) ([describe-cluster-parameter-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-parameter-groups-message describe-cluster-parameter-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-parameter-groups-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-parameter-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterParameterGroupsResult", :http.request.configuration/action "DescribeClusterParameterGroups", :http.request.configuration/output-deser-fn response-cluster-parameter-groups-message, :http.request.spec/error-spec {"ClusterParameterGroupNotFoundFault" :portkey.aws.redshift/cluster-parameter-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-parameter-groups :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-parameter-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-parameter-groups-message))

(clojure.core/defn authorize-snapshot-access "Authorizes the specified AWS customer account to restore the specified snapshot.\n For more information about working with snapshots, go to Amazon Redshift\nSnapshots\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html) in\nthe Amazon Redshift Cluster Management Guide." ([authorize-snapshot-access-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-authorize-snapshot-access-message authorize-snapshot-access-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/authorize-snapshot-access-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/authorize-snapshot-access-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "AuthorizeSnapshotAccessResult", :http.request.configuration/action "AuthorizeSnapshotAccess", :http.request.configuration/output-deser-fn response-authorize-snapshot-access-result, :http.request.spec/error-spec {"ClusterSnapshotNotFoundFault" :portkey.aws.redshift/cluster-snapshot-not-found-fault, "AuthorizationAlreadyExistsFault" :portkey.aws.redshift/authorization-already-exists-fault, "AuthorizationQuotaExceededFault" :portkey.aws.redshift/authorization-quota-exceeded-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault, "InvalidClusterSnapshotStateFault" :portkey.aws.redshift/invalid-cluster-snapshot-state-fault, "LimitExceededFault" :portkey.aws.redshift/limit-exceeded-fault}})))))
(clojure.spec.alpha/fdef authorize-snapshot-access :args (clojure.spec.alpha/tuple :portkey.aws.redshift/authorize-snapshot-access-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/authorize-snapshot-access-result))

(clojure.core/defn describe-logging-status "Describes whether information, such as queries and connection attempts, is being\nlogged for the specified Amazon Redshift cluster." ([describe-logging-status-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-logging-status-message describe-logging-status-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/logging-status, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-logging-status-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeLoggingStatusResult", :http.request.configuration/action "DescribeLoggingStatus", :http.request.configuration/output-deser-fn response-logging-status, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-logging-status :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-logging-status-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/logging-status))

(clojure.core/defn describe-resize "Returns information about the last resize operation for the specified cluster.\nIf no resize operation has ever been initiated for the specified cluster, a HTTP\n404 error is returned. If a resize operation was initiated and completed, the\nstatus of the resize remains as SUCCEEDED until the next resize.\n A resize operation can be requested using ModifyCluster and specifying a\ndifferent number or type of nodes for the cluster." ([describe-resize-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-resize-message describe-resize-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/resize-progress-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-resize-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeResizeResult", :http.request.configuration/action "DescribeResize", :http.request.configuration/output-deser-fn response-resize-progress-message, :http.request.spec/error-spec {"ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault, "ResizeNotFoundFault" :portkey.aws.redshift/resize-not-found-fault}})))))
(clojure.spec.alpha/fdef describe-resize :args (clojure.spec.alpha/tuple :portkey.aws.redshift/describe-resize-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/resize-progress-message))

(clojure.core/defn reboot-cluster "Reboots a cluster. This action is taken as soon as possible. It results in a\nmomentary outage to the cluster, during which the cluster status is set to\nrebooting. A cluster event is created when the reboot is completed. Any pending\ncluster modifications (see ModifyCluster) are applied at this reboot. For more\ninformation about managing clusters, go to Amazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide." ([reboot-cluster-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-reboot-cluster-message reboot-cluster-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/reboot-cluster-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/reboot-cluster-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "RebootClusterResult", :http.request.configuration/action "RebootCluster", :http.request.configuration/output-deser-fn response-reboot-cluster-result, :http.request.spec/error-spec {"InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef reboot-cluster :args (clojure.spec.alpha/tuple :portkey.aws.redshift/reboot-cluster-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/reboot-cluster-result))

(clojure.core/defn describe-orderable-cluster-options "Returns a list of orderable cluster options. Before you create a new cluster you\ncan use this operation to find what options are available, such as the EC2\nAvailability Zones (AZ) in the specific AWS Region that you can specify, and the\nnode types you can request. The node types differ by available storage, memory,\nCPU and price. With the cost involved you might want to obtain a list of cluster\noptions in the specific region and specify values when creating a cluster. For\nmore information about managing clusters, go to Amazon Redshift Clusters\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html) in\nthe Amazon Redshift Cluster Management Guide." ([] (describe-orderable-cluster-options {})) ([describe-orderable-cluster-options-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-orderable-cluster-options-message describe-orderable-cluster-options-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/orderable-cluster-options-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-orderable-cluster-options-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeOrderableClusterOptionsResult", :http.request.configuration/action "DescribeOrderableClusterOptions", :http.request.configuration/output-deser-fn response-orderable-cluster-options-message, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef describe-orderable-cluster-options :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-orderable-cluster-options-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/orderable-cluster-options-message))

(clojure.core/defn create-snapshot-schedule "Creates a new snapshot schedule." ([] (create-snapshot-schedule {})) ([create-snapshot-schedule-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-snapshot-schedule-message create-snapshot-schedule-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/snapshot-schedule, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-snapshot-schedule-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateSnapshotScheduleResult", :http.request.configuration/action "CreateSnapshotSchedule", :http.request.configuration/output-deser-fn response-snapshot-schedule, :http.request.spec/error-spec {"SnapshotScheduleAlreadyExistsFault" :portkey.aws.redshift/snapshot-schedule-already-exists-fault, "InvalidScheduleFault" :portkey.aws.redshift/invalid-schedule-fault, "SnapshotScheduleQuotaExceededFault" :portkey.aws.redshift/snapshot-schedule-quota-exceeded-fault, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "ScheduleDefinitionTypeUnsupportedFault" :portkey.aws.redshift/schedule-definition-type-unsupported-fault}})))))
(clojure.spec.alpha/fdef create-snapshot-schedule :args (clojure.spec.alpha/? :portkey.aws.redshift/create-snapshot-schedule-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/snapshot-schedule))

(clojure.core/defn create-cluster-subnet-group "Creates a new Amazon Redshift subnet group. You must provide a list of one or\nmore subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when\ncreating Amazon Redshift subnet group.\n For information about subnet groups, go to Amazon Redshift Cluster Subnet\nGroups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([create-cluster-subnet-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-create-cluster-subnet-group-message create-cluster-subnet-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/create-cluster-subnet-group-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/create-cluster-subnet-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "CreateClusterSubnetGroupResult", :http.request.configuration/action "CreateClusterSubnetGroup", :http.request.configuration/output-deser-fn response-create-cluster-subnet-group-result, :http.request.spec/error-spec {"ClusterSubnetGroupAlreadyExistsFault" :portkey.aws.redshift/cluster-subnet-group-already-exists-fault, "ClusterSubnetGroupQuotaExceededFault" :portkey.aws.redshift/cluster-subnet-group-quota-exceeded-fault, "ClusterSubnetQuotaExceededFault" :portkey.aws.redshift/cluster-subnet-quota-exceeded-fault, "InvalidSubnet" :portkey.aws.redshift/invalid-subnet, "UnauthorizedOperation" :portkey.aws.redshift/unauthorized-operation, "TagLimitExceededFault" :portkey.aws.redshift/tag-limit-exceeded-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault, "DependentServiceRequestThrottlingFault" :portkey.aws.redshift/dependent-service-request-throttling-fault}})))))
(clojure.spec.alpha/fdef create-cluster-subnet-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/create-cluster-subnet-group-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/create-cluster-subnet-group-result))

(clojure.core/defn modify-cluster-iam-roles "Modifies the list of AWS Identity and Access Management (IAM) roles that can be\nused by the cluster to access other AWS services.\n A cluster can have up to 10 IAM roles associated at any time." ([modify-cluster-iam-roles-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-modify-cluster-iam-roles-message modify-cluster-iam-roles-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/modify-cluster-iam-roles-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/modify-cluster-iam-roles-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "ModifyClusterIamRolesResult", :http.request.configuration/action "ModifyClusterIamRoles", :http.request.configuration/output-deser-fn response-modify-cluster-iam-roles-result, :http.request.spec/error-spec {"InvalidClusterStateFault" :portkey.aws.redshift/invalid-cluster-state-fault, "ClusterNotFoundFault" :portkey.aws.redshift/cluster-not-found-fault}})))))
(clojure.spec.alpha/fdef modify-cluster-iam-roles :args (clojure.spec.alpha/tuple :portkey.aws.redshift/modify-cluster-iam-roles-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/modify-cluster-iam-roles-result))

(clojure.core/defn batch-delete-cluster-snapshots "Deletes a set of cluster snapshots." ([batch-delete-cluster-snapshots-requestinput] (clojure.core/let [request-function-result__22119__auto__ (req-batch-delete-cluster-snapshots-request batch-delete-cluster-snapshots-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/batch-delete-cluster-snapshots-result, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/batch-delete-cluster-snapshots-request, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "BatchDeleteClusterSnapshotsResult", :http.request.configuration/action "BatchDeleteClusterSnapshots", :http.request.configuration/output-deser-fn response-batch-delete-cluster-snapshots-result, :http.request.spec/error-spec {"BatchDeleteRequestSizeExceededFault" :portkey.aws.redshift/batch-delete-request-size-exceeded-fault}})))))
(clojure.spec.alpha/fdef batch-delete-cluster-snapshots :args (clojure.spec.alpha/tuple :portkey.aws.redshift/batch-delete-cluster-snapshots-request) :ret (clojure.spec.alpha/and :portkey.aws.redshift/batch-delete-cluster-snapshots-result))

(clojure.core/defn delete-cluster-security-group "Deletes an Amazon Redshift security group.\n You cannot delete a security group that is associated with any clusters. You\ncannot delete the default security group.\n For information about managing security groups, go to Amazon Redshift Cluster\nSecurity Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html)\nin the Amazon Redshift Cluster Management Guide." ([delete-cluster-security-group-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-delete-cluster-security-group-message delete-cluster-security-group-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/delete-cluster-security-group-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteClusterSecurityGroup", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22118__auto__] {}), :http.request.spec/error-spec {"InvalidClusterSecurityGroupStateFault" :portkey.aws.redshift/invalid-cluster-security-group-state-fault, "ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault}})))))
(clojure.spec.alpha/fdef delete-cluster-security-group :args (clojure.spec.alpha/tuple :portkey.aws.redshift/delete-cluster-security-group-message) :ret clojure.core/true?)

(clojure.core/defn describe-cluster-security-groups "Returns information about Amazon Redshift security groups. If the name of a\nsecurity group is specified, the response will contain only information about\nonly that security group.\n For information about managing security groups, go to Amazon Redshift Cluster\nSecurity Groups\n(http://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html)\nin the Amazon Redshift Cluster Management Guide.\n If you specify both tag keys and tag values in the same request, Amazon\nRedshift returns all security groups that match any combination of the specified\nkeys and values. For example, if you have owner and environment for tag keys,\nand admin and test for tag values, all security groups that have any combination\nof those values are returned.\n If both tag keys and values are omitted from the request, security groups are\nreturned regardless of whether they have tag keys or values associated with\nthem." ([] (describe-cluster-security-groups {})) ([describe-cluster-security-groups-messageinput] (clojure.core/let [request-function-result__22119__auto__ (req-describe-cluster-security-groups-message describe-cluster-security-groups-messageinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22119__auto__ {:http.request.configuration/endpoints portkey.aws.redshift/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.redshift/cluster-security-group-message, :http.request.configuration/mime-type {"content-type" "application/x-www-form-urlencoded; charset=utf-8"}, :http.request.configuration/request-uri "/", :http.request.configuration/version "2012-12-01", :http.request.configuration/service-id "Redshift", :http.request.spec/input-spec :portkey.aws.redshift/describe-cluster-security-groups-message, :http.request.configuration/protocol "query", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper "DescribeClusterSecurityGroupsResult", :http.request.configuration/action "DescribeClusterSecurityGroups", :http.request.configuration/output-deser-fn response-cluster-security-group-message, :http.request.spec/error-spec {"ClusterSecurityGroupNotFoundFault" :portkey.aws.redshift/cluster-security-group-not-found-fault, "InvalidTagFault" :portkey.aws.redshift/invalid-tag-fault}})))))
(clojure.spec.alpha/fdef describe-cluster-security-groups :args (clojure.spec.alpha/? :portkey.aws.redshift/describe-cluster-security-groups-message) :ret (clojure.spec.alpha/and :portkey.aws.redshift/cluster-security-group-message))
