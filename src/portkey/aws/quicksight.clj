(ns portkey.aws.quicksight (:require [portkey.aws]))

(def endpoints 'nil)

(clojure.core/declare serboolean)

(clojure.core/declare ser-group-member-name)

(clojure.core/declare ser-group-name)

(clojure.core/declare ser-user-name)

(clojure.core/declare ser-session-lifetime-in-minutes)

(clojure.core/declare ser-user-role)

(clojure.core/declare ser-namespace)

(clojure.core/declare ser-aws-account-id)

(clojure.core/declare ser-string)

(clojure.core/declare ser-identity-type)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-group-description)

(clojure.core/defn- serboolean [input] #:http.request.field{:value input, :shape "boolean"})

(clojure.core/defn- ser-group-member-name [input] #:http.request.field{:value input, :shape "GroupMemberName"})

(clojure.core/defn- ser-group-name [input] #:http.request.field{:value input, :shape "GroupName"})

(clojure.core/defn- ser-user-name [input] #:http.request.field{:value input, :shape "UserName"})

(clojure.core/defn- ser-session-lifetime-in-minutes [input] #:http.request.field{:value input, :shape "SessionLifetimeInMinutes"})

(clojure.core/defn- ser-user-role [input] #:http.request.field{:value (clojure.core/get {:restricted-author "RESTRICTED_AUTHOR", :admin "ADMIN", :restricted-reader "RESTRICTED_READER", "RESTRICTED_AUTHOR" "RESTRICTED_AUTHOR", "ADMIN" "ADMIN", :author "AUTHOR", :reader "READER", "READER" "READER", "RESTRICTED_READER" "RESTRICTED_READER", "AUTHOR" "AUTHOR"} input), :shape "UserRole"})

(clojure.core/defn- ser-namespace [input] #:http.request.field{:value input, :shape "Namespace"})

(clojure.core/defn- ser-aws-account-id [input] #:http.request.field{:value input, :shape "AwsAccountId"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-identity-type [input] #:http.request.field{:value (clojure.core/get {"IAM" "IAM", :iam "IAM", "QUICKSIGHT" "QUICKSIGHT", :quicksight "QUICKSIGHT"} input), :shape "IdentityType"})

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-group-description [input] #:http.request.field{:value input, :shape "GroupDescription"})

(clojure.core/defn- req-update-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-user-name (input :user-name)) #:http.request.field{:name "UserName", :shape "UserName", :location "uri", :location-name "UserName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})], :body [(clojure.core/into (ser-string (input :email)) #:http.request.field{:name "Email", :shape "String"}) (clojure.core/into (ser-user-role (input :role)) #:http.request.field{:name "Role", :shape "UserRole"})]}))

(clojure.core/defn- req-list-user-groups-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-user-name (input :user-name)) #:http.request.field{:name "UserName", :shape "UserName", :location "uri", :location-name "UserName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location "querystring", :location-name "next-token"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true, :location "querystring", :location-name "max-results"}))))

(clojure.core/defn- req-list-users-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location "querystring", :location-name "next-token"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true, :location "querystring", :location-name "max-results"}))))

(clojure.core/defn- req-describe-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName", :location "uri", :location-name "GroupName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]}))

(clojure.core/defn- req-create-group-membership-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-group-member-name (input :member-name)) #:http.request.field{:name "MemberName", :shape "GroupMemberName", :location "uri", :location-name "MemberName"}) (clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName", :location "uri", :location-name "GroupName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]}))

(clojure.core/defn- req-describe-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-user-name (input :user-name)) #:http.request.field{:name "UserName", :shape "UserName", :location "uri", :location-name "UserName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]}))

(clojure.core/defn- req-get-dashboard-embed-url-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-string (input :dashboard-id)) #:http.request.field{:name "DashboardId", :shape "String", :location "uri", :location-name "DashboardId"})], :querystring [(clojure.core/into (ser-identity-type (input :identity-type)) #:http.request.field{:name "IdentityType", :shape "IdentityType", :location "querystring", :location-name "creds-type"})]} (clojure.core/contains? input :session-lifetime-in-minutes) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session-lifetime-in-minutes (input :session-lifetime-in-minutes)) #:http.request.field{:name "SessionLifetimeInMinutes", :shape "SessionLifetimeInMinutes", :location "querystring", :location-name "session-lifetime"})) (clojure.core/contains? input :undo-redo-disabled) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :undo-redo-disabled)) #:http.request.field{:name "UndoRedoDisabled", :shape "boolean", :location "querystring", :location-name "undo-redo-disabled"})) (clojure.core/contains? input :reset-disabled) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (serboolean (input :reset-disabled)) #:http.request.field{:name "ResetDisabled", :shape "boolean", :location "querystring", :location-name "reset-disabled"}))))

(clojure.core/defn- req-delete-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName", :location "uri", :location-name "GroupName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]}))

(clojure.core/defn- req-list-groups-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location "querystring", :location-name "next-token"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true, :location "querystring", :location-name "max-results"}))))

(clojure.core/defn- req-list-group-memberships-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName", :location "uri", :location-name "GroupName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "String", :location "querystring", :location-name "next-token"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :box true, :location "querystring", :location-name "max-results"}))))

(clojure.core/defn- req-create-group-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName"})], :uri [(clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-description (input :description)) #:http.request.field{:name "Description", :shape "GroupDescription"}))))

(clojure.core/defn- req-delete-user-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-user-name (input :user-name)) #:http.request.field{:name "UserName", :shape "UserName", :location "uri", :location-name "UserName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]}))

(clojure.core/defn- req-delete-group-membership-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-group-member-name (input :member-name)) #:http.request.field{:name "MemberName", :shape "GroupMemberName", :location "uri", :location-name "MemberName"}) (clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName", :location "uri", :location-name "GroupName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]}))

(clojure.core/defn- req-register-user-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-identity-type (input :identity-type)) #:http.request.field{:name "IdentityType", :shape "IdentityType"}) (clojure.core/into (ser-string (input :email)) #:http.request.field{:name "Email", :shape "String"}) (clojure.core/into (ser-user-role (input :user-role)) #:http.request.field{:name "UserRole", :shape "UserRole"})], :uri [(clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :iam-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :iam-arn)) #:http.request.field{:name "IamArn", :shape "String"})) (clojure.core/contains? input :session-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :session-name)) #:http.request.field{:name "SessionName", :shape "String"})) (clojure.core/contains? input :user-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-user-name (input :user-name)) #:http.request.field{:name "UserName", :shape "UserName"}))))

(clojure.core/defn- req-update-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-group-name (input :group-name)) #:http.request.field{:name "GroupName", :shape "GroupName", :location "uri", :location-name "GroupName"}) (clojure.core/into (ser-aws-account-id (input :aws-account-id)) #:http.request.field{:name "AwsAccountId", :shape "AwsAccountId", :location "uri", :location-name "AwsAccountId"}) (clojure.core/into (ser-namespace (input :namespace)) #:http.request.field{:name "Namespace", :shape "Namespace", :location "uri", :location-name "Namespace"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-group-description (input :description)) #:http.request.field{:name "Description", :shape "GroupDescription"}))))

(clojure.core/declare deser-user-list)

(clojure.core/declare deser-status-code)

(clojure.core/declare deser-group-list)

(clojure.core/declare deser-group-member-name)

(clojure.core/declare deser-user)

(clojure.core/declare deser-embedding-url)

(clojure.core/declare deser-group-name)

(clojure.core/declare deser-user-name)

(clojure.core/declare deser-user-role)

(clojure.core/declare deser-string)

(clojure.core/declare deser-identity-type)

(clojure.core/declare deser-group-member-list)

(clojure.core/declare deser-arn)

(clojure.core/declare deser-group-member)

(clojure.core/declare deser-group)

(clojure.core/declare deser-exception-resource-type)

(clojure.core/declare deser-group-description)

(clojure.core/declare deser-boolean)

(clojure.core/defn- deser-user-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-user coll))) input))

(clojure.core/defn- deser-status-code [input] input)

(clojure.core/defn- deser-group-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group coll))) input))

(clojure.core/defn- deser-group-member-name [input] input)

(clojure.core/defn- deser-user [input] (clojure.core/cond-> {} (clojure.core/contains? input "Arn") (clojure.core/assoc :arn (deser-arn (input "Arn"))) (clojure.core/contains? input "UserName") (clojure.core/assoc :user-name (deser-user-name (input "UserName"))) (clojure.core/contains? input "Email") (clojure.core/assoc :email (deser-string (input "Email"))) (clojure.core/contains? input "Role") (clojure.core/assoc :role (deser-user-role (input "Role"))) (clojure.core/contains? input "IdentityType") (clojure.core/assoc :identity-type (deser-identity-type (input "IdentityType"))) (clojure.core/contains? input "Active") (clojure.core/assoc :active (deser-boolean (input "Active")))))

(clojure.core/defn- deser-embedding-url [input] input)

(clojure.core/defn- deser-group-name [input] input)

(clojure.core/defn- deser-user-name [input] input)

(clojure.core/defn- deser-user-role [input] (clojure.core/get {"ADMIN" :admin, "AUTHOR" :author, "READER" :reader, "RESTRICTED_AUTHOR" :restricted-author, "RESTRICTED_READER" :restricted-reader} input))

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-identity-type [input] (clojure.core/get {"IAM" :iam, "QUICKSIGHT" :quicksight} input))

(clojure.core/defn- deser-group-member-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-member coll))) input))

(clojure.core/defn- deser-arn [input] input)

(clojure.core/defn- deser-group-member [input] (clojure.core/cond-> {} (clojure.core/contains? input "Arn") (clojure.core/assoc :arn (deser-arn (input "Arn"))) (clojure.core/contains? input "MemberName") (clojure.core/assoc :member-name (deser-group-member-name (input "MemberName")))))

(clojure.core/defn- deser-group [input] (clojure.core/cond-> {} (clojure.core/contains? input "Arn") (clojure.core/assoc :arn (deser-arn (input "Arn"))) (clojure.core/contains? input "GroupName") (clojure.core/assoc :group-name (deser-group-name (input "GroupName"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-group-description (input "Description")))))

(clojure.core/defn- deser-exception-resource-type [input] (clojure.core/get {"USER" :user, "GROUP" :group, "NAMESPACE" :namespace, "DATA_SOURCE" :data-source, "DATA_SET" :data-set, "VPC_CONNECTION" :vpc-connection, "INGESTION" :ingestion} input))

(clojure.core/defn- deser-group-description [input] input)

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- response-list-user-groups-response ([input] (response-list-user-groups-response nil input)) ([resultWrapper432132 input] (clojure.core/let [rawinput432131 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432133 {"GroupList" (rawinput432131 "GroupList"), "NextToken" (rawinput432131 "NextToken"), "RequestId" (rawinput432131 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432133 "GroupList") (clojure.core/assoc :group-list (deser-group-list (clojure.core/get-in letvar432133 ["GroupList"]))) (letvar432133 "NextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar432133 ["NextToken"]))) (letvar432133 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432133 ["RequestId"]))) (letvar432133 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432133 ["Status"])))))))

(clojure.core/defn- response-domain-not-whitelisted-exception ([input] (response-domain-not-whitelisted-exception nil input)) ([resultWrapper432135 input] (clojure.core/let [rawinput432134 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432136 {"Message" (rawinput432134 "Message"), "RequestId" (rawinput432134 "RequestId")}] (clojure.core/cond-> {} (letvar432136 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432136 ["Message"]))) (letvar432136 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432136 ["RequestId"])))))))

(clojure.core/defn- response-delete-group-membership-response ([input] (response-delete-group-membership-response nil input)) ([resultWrapper432138 input] (clojure.core/let [rawinput432137 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432139 {"RequestId" (rawinput432137 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432139 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432139 ["RequestId"]))) (letvar432139 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432139 ["Status"])))))))

(clojure.core/defn- response-identity-type-not-supported-exception ([input] (response-identity-type-not-supported-exception nil input)) ([resultWrapper432141 input] (clojure.core/let [rawinput432140 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432142 {"Message" (rawinput432140 "Message"), "RequestId" (rawinput432140 "RequestId")}] (clojure.core/cond-> {} (letvar432142 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432142 ["Message"]))) (letvar432142 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432142 ["RequestId"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper432144 input] (clojure.core/let [rawinput432143 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432145 {"Message" (rawinput432143 "Message"), "ResourceType" (rawinput432143 "ResourceType"), "RequestId" (rawinput432143 "RequestId")}] (clojure.core/cond-> {} (letvar432145 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432145 ["Message"]))) (letvar432145 "ResourceType") (clojure.core/assoc :resource-type (deser-exception-resource-type (clojure.core/get-in letvar432145 ["ResourceType"]))) (letvar432145 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432145 ["RequestId"])))))))

(clojure.core/defn- response-update-group-response ([input] (response-update-group-response nil input)) ([resultWrapper432147 input] (clojure.core/let [rawinput432146 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432148 {"Group" (rawinput432146 "Group"), "RequestId" (rawinput432146 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432148 "Group") (clojure.core/assoc :group (deser-group (clojure.core/get-in letvar432148 ["Group"]))) (letvar432148 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432148 ["RequestId"]))) (letvar432148 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432148 ["Status"])))))))

(clojure.core/defn- response-list-groups-response ([input] (response-list-groups-response nil input)) ([resultWrapper432150 input] (clojure.core/let [rawinput432149 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432151 {"GroupList" (rawinput432149 "GroupList"), "NextToken" (rawinput432149 "NextToken"), "RequestId" (rawinput432149 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432151 "GroupList") (clojure.core/assoc :group-list (deser-group-list (clojure.core/get-in letvar432151 ["GroupList"]))) (letvar432151 "NextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar432151 ["NextToken"]))) (letvar432151 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432151 ["RequestId"]))) (letvar432151 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432151 ["Status"])))))))

(clojure.core/defn- response-resource-exists-exception ([input] (response-resource-exists-exception nil input)) ([resultWrapper432153 input] (clojure.core/let [rawinput432152 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432154 {"Message" (rawinput432152 "Message"), "ResourceType" (rawinput432152 "ResourceType"), "RequestId" (rawinput432152 "RequestId")}] (clojure.core/cond-> {} (letvar432154 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432154 ["Message"]))) (letvar432154 "ResourceType") (clojure.core/assoc :resource-type (deser-exception-resource-type (clojure.core/get-in letvar432154 ["ResourceType"]))) (letvar432154 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432154 ["RequestId"])))))))

(clojure.core/defn- response-delete-group-response ([input] (response-delete-group-response nil input)) ([resultWrapper432156 input] (clojure.core/let [rawinput432155 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432157 {"RequestId" (rawinput432155 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432157 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432157 ["RequestId"]))) (letvar432157 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432157 ["Status"])))))))

(clojure.core/defn- response-update-user-response ([input] (response-update-user-response nil input)) ([resultWrapper432159 input] (clojure.core/let [rawinput432158 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432160 {"User" (rawinput432158 "User"), "RequestId" (rawinput432158 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432160 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar432160 ["User"]))) (letvar432160 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432160 ["RequestId"]))) (letvar432160 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432160 ["Status"])))))))

(clojure.core/defn- response-delete-user-response ([input] (response-delete-user-response nil input)) ([resultWrapper432162 input] (clojure.core/let [rawinput432161 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432163 {"RequestId" (rawinput432161 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432163 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432163 ["RequestId"]))) (letvar432163 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432163 ["Status"])))))))

(clojure.core/defn- response-invalid-next-token-exception ([input] (response-invalid-next-token-exception nil input)) ([resultWrapper432165 input] (clojure.core/let [rawinput432164 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432166 {"Message" (rawinput432164 "Message"), "RequestId" (rawinput432164 "RequestId")}] (clojure.core/cond-> {} (letvar432166 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432166 ["Message"]))) (letvar432166 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432166 ["RequestId"])))))))

(clojure.core/defn- response-internal-failure-exception ([input] (response-internal-failure-exception nil input)) ([resultWrapper432168 input] (clojure.core/let [rawinput432167 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432169 {"Message" (rawinput432167 "Message"), "RequestId" (rawinput432167 "RequestId")}] (clojure.core/cond-> {} (letvar432169 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432169 ["Message"]))) (letvar432169 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432169 ["RequestId"])))))))

(clojure.core/defn- response-get-dashboard-embed-url-response ([input] (response-get-dashboard-embed-url-response nil input)) ([resultWrapper432171 input] (clojure.core/let [rawinput432170 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432172 {"EmbedUrl" (rawinput432170 "EmbedUrl"), "Status" (clojure.core/get-in input [:status "Status"]), "RequestId" (rawinput432170 "RequestId")}] (clojure.core/cond-> {} (letvar432172 "EmbedUrl") (clojure.core/assoc :embed-url (deser-embedding-url (clojure.core/get-in letvar432172 ["EmbedUrl"]))) (letvar432172 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432172 ["Status"]))) (letvar432172 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432172 ["RequestId"])))))))

(clojure.core/defn- response-describe-user-response ([input] (response-describe-user-response nil input)) ([resultWrapper432174 input] (clojure.core/let [rawinput432173 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432175 {"User" (rawinput432173 "User"), "RequestId" (rawinput432173 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432175 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar432175 ["User"]))) (letvar432175 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432175 ["RequestId"]))) (letvar432175 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432175 ["Status"])))))))

(clojure.core/defn- response-resource-not-found-exception ([input] (response-resource-not-found-exception nil input)) ([resultWrapper432177 input] (clojure.core/let [rawinput432176 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432178 {"Message" (rawinput432176 "Message"), "ResourceType" (rawinput432176 "ResourceType"), "RequestId" (rawinput432176 "RequestId")}] (clojure.core/cond-> {} (letvar432178 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432178 ["Message"]))) (letvar432178 "ResourceType") (clojure.core/assoc :resource-type (deser-exception-resource-type (clojure.core/get-in letvar432178 ["ResourceType"]))) (letvar432178 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432178 ["RequestId"])))))))

(clojure.core/defn- response-access-denied-exception ([input] (response-access-denied-exception nil input)) ([resultWrapper432180 input] (clojure.core/let [rawinput432179 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432181 {"Message" (rawinput432179 "Message"), "RequestId" (rawinput432179 "RequestId")}] (clojure.core/cond-> {} (letvar432181 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432181 ["Message"]))) (letvar432181 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432181 ["RequestId"])))))))

(clojure.core/defn- response-list-group-memberships-response ([input] (response-list-group-memberships-response nil input)) ([resultWrapper432183 input] (clojure.core/let [rawinput432182 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432184 {"GroupMemberList" (rawinput432182 "GroupMemberList"), "NextToken" (rawinput432182 "NextToken"), "RequestId" (rawinput432182 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432184 "GroupMemberList") (clojure.core/assoc :group-member-list (deser-group-member-list (clojure.core/get-in letvar432184 ["GroupMemberList"]))) (letvar432184 "NextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar432184 ["NextToken"]))) (letvar432184 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432184 ["RequestId"]))) (letvar432184 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432184 ["Status"])))))))

(clojure.core/defn- response-create-group-membership-response ([input] (response-create-group-membership-response nil input)) ([resultWrapper432186 input] (clojure.core/let [rawinput432185 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432187 {"GroupMember" (rawinput432185 "GroupMember"), "RequestId" (rawinput432185 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432187 "GroupMember") (clojure.core/assoc :group-member (deser-group-member (clojure.core/get-in letvar432187 ["GroupMember"]))) (letvar432187 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432187 ["RequestId"]))) (letvar432187 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432187 ["Status"])))))))

(clojure.core/defn- response-unsupported-user-edition-exception ([input] (response-unsupported-user-edition-exception nil input)) ([resultWrapper432189 input] (clojure.core/let [rawinput432188 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432190 {"Message" (rawinput432188 "Message"), "RequestId" (rawinput432188 "RequestId")}] (clojure.core/cond-> {} (letvar432190 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432190 ["Message"]))) (letvar432190 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432190 ["RequestId"])))))))

(clojure.core/defn- response-register-user-response ([input] (response-register-user-response nil input)) ([resultWrapper432192 input] (clojure.core/let [rawinput432191 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432193 {"User" (rawinput432191 "User"), "UserInvitationUrl" (rawinput432191 "UserInvitationUrl"), "RequestId" (rawinput432191 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432193 "User") (clojure.core/assoc :user (deser-user (clojure.core/get-in letvar432193 ["User"]))) (letvar432193 "UserInvitationUrl") (clojure.core/assoc :user-invitation-url (deser-string (clojure.core/get-in letvar432193 ["UserInvitationUrl"]))) (letvar432193 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432193 ["RequestId"]))) (letvar432193 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432193 ["Status"])))))))

(clojure.core/defn- response-precondition-not-met-exception ([input] (response-precondition-not-met-exception nil input)) ([resultWrapper432195 input] (clojure.core/let [rawinput432194 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432196 {"Message" (rawinput432194 "Message"), "RequestId" (rawinput432194 "RequestId")}] (clojure.core/cond-> {} (letvar432196 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432196 ["Message"]))) (letvar432196 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432196 ["RequestId"])))))))

(clojure.core/defn- response-create-group-response ([input] (response-create-group-response nil input)) ([resultWrapper432198 input] (clojure.core/let [rawinput432197 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432199 {"Group" (rawinput432197 "Group"), "RequestId" (rawinput432197 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432199 "Group") (clojure.core/assoc :group (deser-group (clojure.core/get-in letvar432199 ["Group"]))) (letvar432199 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432199 ["RequestId"]))) (letvar432199 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432199 ["Status"])))))))

(clojure.core/defn- response-session-lifetime-in-minutes-invalid-exception ([input] (response-session-lifetime-in-minutes-invalid-exception nil input)) ([resultWrapper432201 input] (clojure.core/let [rawinput432200 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432202 {"Message" (rawinput432200 "Message"), "RequestId" (rawinput432200 "RequestId")}] (clojure.core/cond-> {} (letvar432202 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432202 ["Message"]))) (letvar432202 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432202 ["RequestId"])))))))

(clojure.core/defn- response-throttling-exception ([input] (response-throttling-exception nil input)) ([resultWrapper432204 input] (clojure.core/let [rawinput432203 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432205 {"Message" (rawinput432203 "Message"), "RequestId" (rawinput432203 "RequestId")}] (clojure.core/cond-> {} (letvar432205 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432205 ["Message"]))) (letvar432205 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432205 ["RequestId"])))))))

(clojure.core/defn- response-describe-group-response ([input] (response-describe-group-response nil input)) ([resultWrapper432207 input] (clojure.core/let [rawinput432206 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432208 {"Group" (rawinput432206 "Group"), "RequestId" (rawinput432206 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432208 "Group") (clojure.core/assoc :group (deser-group (clojure.core/get-in letvar432208 ["Group"]))) (letvar432208 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432208 ["RequestId"]))) (letvar432208 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432208 ["Status"])))))))

(clojure.core/defn- response-resource-unavailable-exception ([input] (response-resource-unavailable-exception nil input)) ([resultWrapper432210 input] (clojure.core/let [rawinput432209 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432211 {"Message" (rawinput432209 "Message"), "ResourceType" (rawinput432209 "ResourceType"), "RequestId" (rawinput432209 "RequestId")}] (clojure.core/cond-> {} (letvar432211 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432211 ["Message"]))) (letvar432211 "ResourceType") (clojure.core/assoc :resource-type (deser-exception-resource-type (clojure.core/get-in letvar432211 ["ResourceType"]))) (letvar432211 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432211 ["RequestId"])))))))

(clojure.core/defn- response-invalid-parameter-value-exception ([input] (response-invalid-parameter-value-exception nil input)) ([resultWrapper432213 input] (clojure.core/let [rawinput432212 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432214 {"Message" (rawinput432212 "Message"), "RequestId" (rawinput432212 "RequestId")}] (clojure.core/cond-> {} (letvar432214 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432214 ["Message"]))) (letvar432214 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432214 ["RequestId"])))))))

(clojure.core/defn- response-list-users-response ([input] (response-list-users-response nil input)) ([resultWrapper432216 input] (clojure.core/let [rawinput432215 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432217 {"UserList" (rawinput432215 "UserList"), "NextToken" (rawinput432215 "NextToken"), "RequestId" (rawinput432215 "RequestId"), "Status" (clojure.core/get-in input [:status "Status"])}] (clojure.core/cond-> {} (letvar432217 "UserList") (clojure.core/assoc :user-list (deser-user-list (clojure.core/get-in letvar432217 ["UserList"]))) (letvar432217 "NextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar432217 ["NextToken"]))) (letvar432217 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432217 ["RequestId"]))) (letvar432217 "Status") (clojure.core/assoc :status (deser-status-code (clojure.core/get-in letvar432217 ["Status"])))))))

(clojure.core/defn- response-quick-sight-user-not-found-exception ([input] (response-quick-sight-user-not-found-exception nil input)) ([resultWrapper432219 input] (clojure.core/let [rawinput432218 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar432220 {"Message" (rawinput432218 "Message"), "RequestId" (rawinput432218 "RequestId")}] (clojure.core/cond-> {} (letvar432220 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar432220 ["Message"]))) (letvar432220 "RequestId") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar432220 ["RequestId"])))))))

(clojure.spec.alpha/def :portkey.aws.quicksight/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.quicksight.update-user-request/email (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.update-user-request/role (clojure.spec.alpha/and :portkey.aws.quicksight/user-role))
(clojure.spec.alpha/def :portkey.aws.quicksight/update-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/user-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace :portkey.aws.quicksight.update-user-request/email :portkey.aws.quicksight.update-user-request/role] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight/user-list (clojure.spec.alpha/coll-of :portkey.aws.quicksight/user))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-user-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-user-groups-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/user-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.list-user-groups-request/next-token :portkey.aws.quicksight/max-results]))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-users-request/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-users-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.list-users-request/next-token :portkey.aws.quicksight/max-results]))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-user-groups-response/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-user-groups-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-user-groups-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-user-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group-list :portkey.aws.quicksight.list-user-groups-response/next-token :portkey.aws.quicksight.list-user-groups-response/request-id :portkey.aws.quicksight.list-user-groups-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight/status-code clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.quicksight.domain-not-whitelisted-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.domain-not-whitelisted-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/domain-not-whitelisted-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.domain-not-whitelisted-exception/message :portkey.aws.quicksight.domain-not-whitelisted-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.delete-group-membership-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.delete-group-membership-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/delete-group-membership-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.delete-group-membership-response/request-id :portkey.aws.quicksight.delete-group-membership-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight/describe-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight/group-list (clojure.spec.alpha/coll-of :portkey.aws.quicksight/group))

(clojure.spec.alpha/def :portkey.aws.quicksight/group-member-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 256)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\u0020-\u00FF]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.quicksight.identity-type-not-supported-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.identity-type-not-supported-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/identity-type-not-supported-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.identity-type-not-supported-exception/message :portkey.aws.quicksight.identity-type-not-supported-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.limit-exceeded-exception/resource-type (clojure.spec.alpha/and :portkey.aws.quicksight/exception-resource-type))
(clojure.spec.alpha/def :portkey.aws.quicksight.limit-exceeded-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.limit-exceeded-exception/message :portkey.aws.quicksight.limit-exceeded-exception/resource-type :portkey.aws.quicksight.limit-exceeded-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.update-group-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.update-group-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/update-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group :portkey.aws.quicksight.update-group-response/request-id :portkey.aws.quicksight.update-group-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-groups-response/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-groups-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-groups-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group-list :portkey.aws.quicksight.list-groups-response/next-token :portkey.aws.quicksight.list-groups-response/request-id :portkey.aws.quicksight.list-groups-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.resource-exists-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.resource-exists-exception/resource-type (clojure.spec.alpha/and :portkey.aws.quicksight/exception-resource-type))
(clojure.spec.alpha/def :portkey.aws.quicksight.resource-exists-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/resource-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.resource-exists-exception/message :portkey.aws.quicksight.resource-exists-exception/resource-type :portkey.aws.quicksight.resource-exists-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.user/email (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.user/role (clojure.spec.alpha/and :portkey.aws.quicksight/user-role))
(clojure.spec.alpha/def :portkey.aws.quicksight.user/active (clojure.spec.alpha/and :portkey.aws.quicksight/boolean))
(clojure.spec.alpha/def :portkey.aws.quicksight/user (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/arn :portkey.aws.quicksight/user-name :portkey.aws.quicksight.user/email :portkey.aws.quicksight.user/role :portkey.aws.quicksight/identity-type :portkey.aws.quicksight.user/active]))

(clojure.spec.alpha/def :portkey.aws.quicksight/embedding-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.quicksight/group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\u0020-\u00FF]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.quicksight.delete-group-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.delete-group-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/delete-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.delete-group-response/request-id :portkey.aws.quicksight.delete-group-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.update-user-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.update-user-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/update-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/user :portkey.aws.quicksight.update-user-response/request-id :portkey.aws.quicksight.update-user-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.delete-user-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.delete-user-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/delete-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.delete-user-response/request-id :portkey.aws.quicksight.delete-user-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.invalid-next-token-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.invalid-next-token-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/invalid-next-token-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.invalid-next-token-exception/message :portkey.aws.quicksight.invalid-next-token-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.create-group-membership-request/member-name (clojure.spec.alpha/and :portkey.aws.quicksight/group-member-name))
(clojure.spec.alpha/def :portkey.aws.quicksight/create-group-membership-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight.create-group-membership-request/member-name :portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight/user-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"[\u0020-\u00FF]+" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.quicksight.internal-failure-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.internal-failure-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/internal-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.internal-failure-exception/message :portkey.aws.quicksight.internal-failure-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.get-dashboard-embed-url-response/embed-url (clojure.spec.alpha/and :portkey.aws.quicksight/embedding-url))
(clojure.spec.alpha/def :portkey.aws.quicksight.get-dashboard-embed-url-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight.get-dashboard-embed-url-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/get-dashboard-embed-url-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.get-dashboard-embed-url-response/embed-url :portkey.aws.quicksight.get-dashboard-embed-url-response/status :portkey.aws.quicksight.get-dashboard-embed-url-response/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.describe-user-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.describe-user-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/describe-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/user :portkey.aws.quicksight.describe-user-response/request-id :portkey.aws.quicksight.describe-user-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight/describe-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/user-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight.get-dashboard-embed-url-request/dashboard-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.get-dashboard-embed-url-request/undo-redo-disabled (clojure.spec.alpha/and :portkey.aws.quicksight/boolean))
(clojure.spec.alpha/def :portkey.aws.quicksight.get-dashboard-embed-url-request/reset-disabled (clojure.spec.alpha/and :portkey.aws.quicksight/boolean))
(clojure.spec.alpha/def :portkey.aws.quicksight/get-dashboard-embed-url-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight.get-dashboard-embed-url-request/dashboard-id :portkey.aws.quicksight/identity-type] :opt-un [:portkey.aws.quicksight/session-lifetime-in-minutes :portkey.aws.quicksight.get-dashboard-embed-url-request/undo-redo-disabled :portkey.aws.quicksight.get-dashboard-embed-url-request/reset-disabled]))

(clojure.spec.alpha/def :portkey.aws.quicksight.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.resource-not-found-exception/resource-type (clojure.spec.alpha/and :portkey.aws.quicksight/exception-resource-type))
(clojure.spec.alpha/def :portkey.aws.quicksight.resource-not-found-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/resource-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.resource-not-found-exception/message :portkey.aws.quicksight.resource-not-found-exception/resource-type :portkey.aws.quicksight.resource-not-found-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight/session-lifetime-in-minutes clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.quicksight/user-role #{:restricted-author :admin :restricted-reader "RESTRICTED_AUTHOR" "ADMIN" :author :reader "READER" "RESTRICTED_READER" "AUTHOR"})

(clojure.spec.alpha/def :portkey.aws.quicksight/namespace (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"default" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.quicksight/aws-account-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 12 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 12)) (clojure.core/fn [s__21112__auto__] (clojure.core/re-matches #"^[0-9]{12}$" s__21112__auto__))))

(clojure.spec.alpha/def :portkey.aws.quicksight/delete-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight.access-denied-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.access-denied-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/access-denied-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.access-denied-exception/message :portkey.aws.quicksight.access-denied-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.quicksight/identity-type #{:quicksight "IAM" "QUICKSIGHT" :iam})

(clojure.spec.alpha/def :portkey.aws.quicksight.list-group-memberships-response/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-group-memberships-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-group-memberships-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-group-memberships-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group-member-list :portkey.aws.quicksight.list-group-memberships-response/next-token :portkey.aws.quicksight.list-group-memberships-response/request-id :portkey.aws.quicksight.list-group-memberships-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.create-group-membership-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.create-group-membership-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/create-group-membership-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group-member :portkey.aws.quicksight.create-group-membership-response/request-id :portkey.aws.quicksight.create-group-membership-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.unsupported-user-edition-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.unsupported-user-edition-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/unsupported-user-edition-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.unsupported-user-edition-exception/message :portkey.aws.quicksight.unsupported-user-edition-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.register-user-response/user-invitation-url (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.register-user-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.register-user-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/register-user-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/user :portkey.aws.quicksight.register-user-response/user-invitation-url :portkey.aws.quicksight.register-user-response/request-id :portkey.aws.quicksight.register-user-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight/group-member-list (clojure.spec.alpha/coll-of :portkey.aws.quicksight/group-member))

(clojure.spec.alpha/def :portkey.aws.quicksight/arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.quicksight.precondition-not-met-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.precondition-not-met-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/precondition-not-met-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.precondition-not-met-exception/message :portkey.aws.quicksight.precondition-not-met-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-groups-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.list-groups-request/next-token :portkey.aws.quicksight/max-results]))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-group-memberships-request/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-group-memberships-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.list-group-memberships-request/next-token :portkey.aws.quicksight/max-results]))

(clojure.spec.alpha/def :portkey.aws.quicksight.create-group-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.create-group-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/create-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group :portkey.aws.quicksight.create-group-response/request-id :portkey.aws.quicksight.create-group-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.create-group-request/description (clojure.spec.alpha/and :portkey.aws.quicksight/group-description))
(clojure.spec.alpha/def :portkey.aws.quicksight/create-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.create-group-request/description]))

(clojure.spec.alpha/def :portkey.aws.quicksight.session-lifetime-in-minutes-invalid-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.session-lifetime-in-minutes-invalid-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/session-lifetime-in-minutes-invalid-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.session-lifetime-in-minutes-invalid-exception/message :portkey.aws.quicksight.session-lifetime-in-minutes-invalid-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.group-member/member-name (clojure.spec.alpha/and :portkey.aws.quicksight/group-member-name))
(clojure.spec.alpha/def :portkey.aws.quicksight/group-member (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/arn :portkey.aws.quicksight.group-member/member-name]))

(clojure.spec.alpha/def :portkey.aws.quicksight/delete-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/user-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight/max-results (clojure.spec.alpha/int-in 1 100000))

(clojure.spec.alpha/def :portkey.aws.quicksight.throttling-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.throttling-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/throttling-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.throttling-exception/message :portkey.aws.quicksight.throttling-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.describe-group-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.describe-group-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/describe-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/group :portkey.aws.quicksight.describe-group-response/request-id :portkey.aws.quicksight.describe-group-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.group/description (clojure.spec.alpha/and :portkey.aws.quicksight/group-description))
(clojure.spec.alpha/def :portkey.aws.quicksight/group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/arn :portkey.aws.quicksight/group-name :portkey.aws.quicksight.group/description]))

(clojure.spec.alpha/def :portkey.aws.quicksight/exception-resource-type #{"DATA_SET" "USER" :group "VPC_CONNECTION" "NAMESPACE" "INGESTION" :data-source :ingestion :vpc-connection "DATA_SOURCE" :namespace :data-set :user "GROUP"})

(clojure.spec.alpha/def :portkey.aws.quicksight.resource-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.resource-unavailable-exception/resource-type (clojure.spec.alpha/and :portkey.aws.quicksight/exception-resource-type))
(clojure.spec.alpha/def :portkey.aws.quicksight.resource-unavailable-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/resource-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.resource-unavailable-exception/message :portkey.aws.quicksight.resource-unavailable-exception/resource-type :portkey.aws.quicksight.resource-unavailable-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.invalid-parameter-value-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.invalid-parameter-value-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/invalid-parameter-value-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.invalid-parameter-value-exception/message :portkey.aws.quicksight.invalid-parameter-value-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight.list-users-response/next-token (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-users-response/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.list-users-response/status (clojure.spec.alpha/and :portkey.aws.quicksight/status-code))
(clojure.spec.alpha/def :portkey.aws.quicksight/list-users-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight/user-list :portkey.aws.quicksight.list-users-response/next-token :portkey.aws.quicksight.list-users-response/request-id :portkey.aws.quicksight.list-users-response/status]))

(clojure.spec.alpha/def :portkey.aws.quicksight.quick-sight-user-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.quick-sight-user-not-found-exception/request-id (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/quick-sight-user-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.quicksight.quick-sight-user-not-found-exception/message :portkey.aws.quicksight.quick-sight-user-not-found-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.quicksight/group-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__21110__auto__] (clojure.core/<= 1 (clojure.core/count s__21110__auto__))) (clojure.core/fn [s__21111__auto__] (clojure.core/< (clojure.core/count s__21111__auto__) 512))))

(clojure.spec.alpha/def :portkey.aws.quicksight.delete-group-membership-request/member-name (clojure.spec.alpha/and :portkey.aws.quicksight/group-member-name))
(clojure.spec.alpha/def :portkey.aws.quicksight/delete-group-membership-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight.delete-group-membership-request/member-name :portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.quicksight.register-user-request/email (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.register-user-request/iam-arn (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight.register-user-request/session-name (clojure.spec.alpha/and :portkey.aws.quicksight/string))
(clojure.spec.alpha/def :portkey.aws.quicksight/register-user-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/identity-type :portkey.aws.quicksight.register-user-request/email :portkey.aws.quicksight/user-role :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.register-user-request/iam-arn :portkey.aws.quicksight.register-user-request/session-name :portkey.aws.quicksight/user-name]))

(clojure.spec.alpha/def :portkey.aws.quicksight.update-group-request/description (clojure.spec.alpha/and :portkey.aws.quicksight/group-description))
(clojure.spec.alpha/def :portkey.aws.quicksight/update-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.quicksight/group-name :portkey.aws.quicksight/aws-account-id :portkey.aws.quicksight/namespace] :opt-un [:portkey.aws.quicksight.update-group-request/description]))

(clojure.spec.alpha/def :portkey.aws.quicksight/boolean clojure.core/boolean?)

(clojure.core/defn delete-group "Removes a user group from Amazon QuickSight.\n The permissions resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:group/default/<group-name> .\n CLI Sample:\n aws quicksight delete-group -\\-aws-account-id=111122223333 -\\-namespace=default\n-\\-group-name=Sales-Management" ([delete-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-group-request delete-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/delete-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/delete-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteGroup", :http.request.configuration/output-deser-fn response-delete-group-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-group :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/delete-group-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/delete-group-response))

(clojure.core/defn list-groups "Lists all user groups in Amazon QuickSight.\n The permissions resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:group/default/*.\n The response is a list of group objects.\n CLI Sample:\n aws quicksight list-groups -\\-aws-account-id=111122223333 -\\-namespace=default" ([list-groups-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-groups-request list-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/list-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/list-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListGroups", :http.request.configuration/output-deser-fn response-list-groups-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InvalidNextTokenException" :portkey.aws.quicksight/invalid-next-token-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-groups :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/list-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/list-groups-response))

(clojure.core/defn describe-group "Returns an Amazon QuickSight group's description and Amazon Resource Name (ARN).\n The permissions resource is\narn:aws:quicksight:us-east-1:<relevant-aws-account-id>:group/default/<group-name>\n.\n The response is the group object.\n CLI Sample:\n aws quicksight describe-group -\\-aws-account-id=11112222333\n-\\-namespace=default -\\-group-name=Sales" ([describe-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-group-request describe-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/describe-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/describe-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeGroup", :http.request.configuration/output-deser-fn response-describe-group-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-group :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/describe-group-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/describe-group-response))

(clojure.core/defn create-group-membership "Adds an Amazon QuickSight user to an Amazon QuickSight group.\n The permissions resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:group/default/<group-name> .\n The condition resource is the user name.\n The condition key is quicksight:UserName.\n The response is the group member object.\n CLI Sample:\n aws quicksight create-group-membership --aws-account-id=111122223333\n--namespace=default --group-name=Sales --member-name=Pat" ([create-group-membership-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-group-membership-request create-group-membership-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/create-group-membership-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/create-group-membership-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateGroupMembership", :http.request.configuration/output-deser-fn response-create-group-membership-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-group-membership :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/create-group-membership-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/create-group-membership-response))

(clojure.core/defn register-user "Creates an Amazon QuickSight user, whose identity is associated with the AWS\nIdentity and Access Management (IAM) identity or role specified in the request.\n The permission resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:user/default/<user-name> .\n The condition resource is the Amazon Resource Name (ARN) for the IAM user or\nrole, and the session name.\n The condition keys are quicksight:IamArn and quicksight:SessionName.\n CLI Sample:\n aws quicksight register-user -\\-aws-account-id=111122223333\n-\\-namespace=default -\\-email=pat@example.com -\\-identity-type=IAM\n-\\-user-role=AUTHOR -\\-iam-arn=arn:aws:iam::111122223333:user/Pat" ([register-user-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-register-user-request register-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/register-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/users", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/register-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterUser", :http.request.configuration/output-deser-fn response-register-user-response, :http.request.spec/error-spec {"LimitExceededException" :portkey.aws.quicksight/limit-exceeded-exception, "ResourceExistsException" :portkey.aws.quicksight/resource-exists-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception}})))))
(clojure.spec.alpha/fdef register-user :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/register-user-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/register-user-response))

(clojure.core/defn list-user-groups "Lists the Amazon QuickSight groups that an Amazon QuickSight user is a member\nof.\n The permission resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:user/default/<user-name> .\n The response is a one or more group objects.\n CLI Sample:\n aws quicksight list-user-groups -\\-user-name=Pat -\\-aws-account-id=111122223333\n-\\-namespace=default -\\-region=us-east-1" ([list-user-groups-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-user-groups-request list-user-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/list-user-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/groups", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/list-user-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListUserGroups", :http.request.configuration/output-deser-fn response-list-user-groups-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-user-groups :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/list-user-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/list-user-groups-response))

(clojure.core/defn update-group "Changes a group description.\n The permissions resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:group/default/<group-name> .\n The response is a group object.\n CLI Sample:\n aws quicksight update-group --aws-account-id=111122223333 --namespace=default\n--group-name=Sales --description=\"Sales BI Dashboards\"" ([update-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-group-request update-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/update-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/update-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateGroup", :http.request.configuration/output-deser-fn response-update-group-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-group :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/update-group-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/update-group-response))

(clojure.core/defn delete-user "Deletes the Amazon QuickSight user that is associated with the identity of the\nAWS Identity and Access Management (IAM) user or role that's making the call.\nThe IAM user isn't deleted as a result of this call.\n The permission resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:user/default/<user-name> .\n CLI Sample:\n aws quicksight delete-user --aws-account-id=111122223333 --namespace=default\n--user-name=Pat" ([delete-user-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-user-request delete-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/delete-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/delete-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUser", :http.request.configuration/output-deser-fn response-delete-user-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-user :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/delete-user-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/delete-user-response))

(clojure.core/defn delete-group-membership "Removes a user from a group so that the user is no longer a member of the group.\n The permissions resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:group/default/<group-name> .\n The condition resource is the user name.\n The condition key is quicksight:UserName.\n CLI Sample:\n aws quicksight delete-group-membership --aws-account-id=111122223333\n--namespace=default --group-name=Sales-Management --member-name=Charlie" ([delete-group-membership-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-group-membership-request delete-group-membership-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/delete-group-membership-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/delete-group-membership-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteGroupMembership", :http.request.configuration/output-deser-fn response-delete-group-membership-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-group-membership :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/delete-group-membership-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/delete-group-membership-response))

(clojure.core/defn list-users "Returns a list of all of the Amazon QuickSight users belonging to this account.\n The permission resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:user/default/* .\n The response is a list of user objects, containing each user's Amazon Resource\nName (ARN), AWS Identity and Access Management (IAM) role, and email address.\n CLI Sample:\n aws quicksight list-users --aws-account-id=111122223333 --namespace=default" ([list-users-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-users-request list-users-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/list-users-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/users", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/list-users-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListUsers", :http.request.configuration/output-deser-fn response-list-users-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InvalidNextTokenException" :portkey.aws.quicksight/invalid-next-token-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-users :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/list-users-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/list-users-response))

(clojure.core/defn list-group-memberships "Lists member users in a group.\n The permissions resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:group/default/<group-name> .\n The response is a list of group member objects.\n CLI Sample:\n aws quicksight list-group-memberships -\\-aws-account-id=111122223333\n-\\-namespace=default" ([list-group-memberships-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-group-memberships-request list-group-memberships-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/list-group-memberships-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/list-group-memberships-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListGroupMemberships", :http.request.configuration/output-deser-fn response-list-group-memberships-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InvalidNextTokenException" :portkey.aws.quicksight/invalid-next-token-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-group-memberships :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/list-group-memberships-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/list-group-memberships-response))

(clojure.core/defn create-group "Creates an Amazon QuickSight group.\n The permissions resource is\narn:aws:quicksight:us-east-1:<relevant-aws-account-id>:group/default/<group-name>\n.\n The response is a group object.\n CLI Sample:\n aws quicksight create-group --aws-account-id=111122223333 --namespace=default\n--group-name=\"Sales-Management\" --description=\"Sales Management - Forecasting\"" ([create-group-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-group-request create-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/create-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/create-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateGroup", :http.request.configuration/output-deser-fn response-create-group-response, :http.request.spec/error-spec {"LimitExceededException" :portkey.aws.quicksight/limit-exceeded-exception, "ResourceExistsException" :portkey.aws.quicksight/resource-exists-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception}})))))
(clojure.spec.alpha/fdef create-group :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/create-group-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/create-group-response))

(clojure.core/defn get-dashboard-embed-url "Generates a server-side embeddable URL and authorization code. Before this can\nwork properly, first you need to configure the dashboards and user permissions.\nFor more information, see Embedding Amazon QuickSight Dashboards\n(https://docs.aws.amazon.com/en_us/quicksight/latest/user/embedding.html).\n Currently, you can use GetDashboardEmbedURL only from the server, not from the\nuser’s browser.\n CLI Sample:\n Assume the role with permissions enabled for actions: quickSight:RegisterUser\nand quicksight:GetDashboardEmbedURL. You can use assume-role,\nassume-role-with-web-identity, or assume-role-with-saml.\n aws sts assume-role --role-arn\n\"arn:aws:iam::111122223333:role/embedding_quicksight_dashboard_role\"\n--role-session-name embeddingsession\n If the user does not exist in QuickSight, register the user:\n aws quicksight register-user --aws-account-id 111122223333 --namespace default\n--identity-type IAM --iam-arn\n\"arn:aws:iam::111122223333:role/embedding_quicksight_dashboard_role\" --user-role\nREADER --session-name \"embeddingsession\" --email user123@example.com --region\nus-east-1\n Get the URL for the embedded dashboard\n aws quicksight get-dashboard-embed-url --aws-account-id 111122223333\n--dashboard-id 1a1ac2b2-3fc3-4b44-5e5d-c6db6778df89 --identity-type IAM" ([get-dashboard-embed-url-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-get-dashboard-embed-url-request get-dashboard-embed-url-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/get-dashboard-embed-url-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/dashboards/{DashboardId}/embed-url", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/get-dashboard-embed-url-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetDashboardEmbedUrl", :http.request.configuration/output-deser-fn response-get-dashboard-embed-url-response, :http.request.spec/error-spec {"DomainNotWhitelistedException" :portkey.aws.quicksight/domain-not-whitelisted-exception, "IdentityTypeNotSupportedException" :portkey.aws.quicksight/identity-type-not-supported-exception, "ResourceExistsException" :portkey.aws.quicksight/resource-exists-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "UnsupportedUserEditionException" :portkey.aws.quicksight/unsupported-user-edition-exception, "PreconditionNotMetException" :portkey.aws.quicksight/precondition-not-met-exception, "SessionLifetimeInMinutesInvalidException" :portkey.aws.quicksight/session-lifetime-in-minutes-invalid-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "QuickSightUserNotFoundException" :portkey.aws.quicksight/quick-sight-user-not-found-exception}})))))
(clojure.spec.alpha/fdef get-dashboard-embed-url :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/get-dashboard-embed-url-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/get-dashboard-embed-url-response))

(clojure.core/defn update-user "Updates an Amazon QuickSight user.\n The permission resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:user/default/<user-name> .\n The response is a user object that contains the user's Amazon QuickSight user\nname, email address, active or inactive status in Amazon QuickSight, Amazon\nQuickSight role, and Amazon Resource Name (ARN).\n CLI Sample:\n aws quicksight update-user --user-name=Pat --role=ADMIN\n--email=new_address@amazon.com --aws-account-id=111122223333 --namespace=default\n--region=us-east-1" ([update-user-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-user-request update-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/update-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/update-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateUser", :http.request.configuration/output-deser-fn response-update-user-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-user :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/update-user-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/update-user-response))

(clojure.core/defn describe-user "Returns information about a user, given the user name.\n The permission resource is\narn:aws:quicksight:us-east-1:<aws-account-id>:user/default/<user-name> .\n The response is a user object that contains the user's Amazon Resource Name\n(ARN), AWS Identity and Access Management (IAM) role, and email address.\n CLI Sample:\n aws quicksight describe-user --aws-account-id=111122223333 --namespace=default\n--user-name=Pat" ([describe-user-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-user-request describe-user-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.quicksight/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.quicksight/describe-user-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}", :http.request.configuration/version "2018-04-01", :http.request.configuration/service-id "QuickSight", :http.request.spec/input-spec :portkey.aws.quicksight/describe-user-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeUser", :http.request.configuration/output-deser-fn response-describe-user-response, :http.request.spec/error-spec {"AccessDeniedException" :portkey.aws.quicksight/access-denied-exception, "InvalidParameterValueException" :portkey.aws.quicksight/invalid-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.quicksight/resource-not-found-exception, "ThrottlingException" :portkey.aws.quicksight/throttling-exception, "InternalFailureException" :portkey.aws.quicksight/internal-failure-exception, "ResourceUnavailableException" :portkey.aws.quicksight/resource-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-user :args (clojure.spec.alpha/tuple :portkey.aws.quicksight/describe-user-request) :ret (clojure.spec.alpha/and :portkey.aws.quicksight/describe-user-response))
