(ns portkey.aws.iot (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope
    {:service "execute-api", :region "ap-northeast-1"},
    :ssl-common-name "iot.ap-northeast-1.amazonaws.com",
    :endpoint "https://iot.ap-northeast-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-1"
   {:credential-scope {:service "execute-api", :region "eu-west-1"},
    :ssl-common-name "iot.eu-west-1.amazonaws.com",
    :endpoint "https://iot.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "us-east-2"
   {:credential-scope {:service "execute-api", :region "us-east-2"},
    :ssl-common-name "iot.us-east-2.amazonaws.com",
    :endpoint "https://iot.us-east-2.amazonaws.com",
    :signature-version :v4},
   "ap-southeast-2"
   {:credential-scope
    {:service "execute-api", :region "ap-southeast-2"},
    :ssl-common-name "iot.ap-southeast-2.amazonaws.com",
    :endpoint "https://iot.ap-southeast-2.amazonaws.com",
    :signature-version :v4},
   "cn-north-1"
   {:credential-scope {:service "execute-api", :region "cn-north-1"},
    :ssl-common-name "iot.cn-north-1.amazonaws.com.cn",
    :endpoint "https://iot.cn-north-1.amazonaws.com.cn",
    :signature-version :v4},
   "ap-southeast-1"
   {:credential-scope
    {:service "execute-api", :region "ap-southeast-1"},
    :ssl-common-name "iot.ap-southeast-1.amazonaws.com",
    :endpoint "https://iot.ap-southeast-1.amazonaws.com",
    :signature-version :v4},
   "ap-northeast-2"
   {:credential-scope
    {:service "execute-api", :region "ap-northeast-2"},
    :ssl-common-name "iot.ap-northeast-2.amazonaws.com",
    :endpoint "https://iot.ap-northeast-2.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope {:service "execute-api", :region "eu-central-1"},
    :ssl-common-name "iot.eu-central-1.amazonaws.com",
    :endpoint "https://iot.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "eu-west-2"
   {:credential-scope {:service "execute-api", :region "eu-west-2"},
    :ssl-common-name "iot.eu-west-2.amazonaws.com",
    :endpoint "https://iot.eu-west-2.amazonaws.com",
    :signature-version :v4},
   "us-gov-west-1"
   {:credential-scope
    {:service "execute-api", :region "us-gov-west-1"},
    :ssl-common-name "iot.us-gov-west-1.amazonaws.com",
    :endpoint "https://iot.us-gov-west-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope {:service "execute-api", :region "us-west-2"},
    :ssl-common-name "iot.us-west-2.amazonaws.com",
    :endpoint "https://iot.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope {:service "execute-api", :region "us-east-1"},
    :ssl-common-name "iot.us-east-1.amazonaws.com",
    :endpoint "https://iot.us-east-1.amazonaws.com",
    :signature-version :v4},
   "ap-south-1"
   {:credential-scope {:service "execute-api", :region "ap-south-1"},
    :ssl-common-name "iot.ap-south-1.amazonaws.com",
    :endpoint "https://iot.ap-south-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-registry-max-results)

(clojure.core/declare ser-stream-id)

(clojure.core/declare ser-expected-version)

(clojure.core/declare ser-billing-group-arn)

(clojure.core/declare ser-auto-registration-status)

(clojure.core/declare ser-thing-indexing-mode)

(clojure.core/declare ser-billing-group-properties)

(clojure.core/declare ser-skyfall-max-results)

(clojure.core/declare ser-thing-group-description)

(clojure.core/declare ser-range-key-field)

(clojure.core/declare ser-thing-group-indexing-configuration)

(clojure.core/declare ser-security-profile-description)

(clojure.core/declare ser-in-progress-timeout-in-minutes)

(clojure.core/declare ser-thing-type-properties)

(clojure.core/declare ser-stream-name)

(clojure.core/declare ser-token-signature)

(clojure.core/declare ser-code-signing)

(clojure.core/declare ser-dynamo-d-bv-2-action)

(clojure.core/declare ser-audit-notification-target-configurations)

(clojure.core/declare ser-statistical-threshold)

(clojure.core/declare ser-override-dynamic-groups)

(clojure.core/declare ser-topic-rule-payload)

(clojure.core/declare ser-minimum-number-of-executed-things)

(clojure.core/declare ser-cidr)

(clojure.core/declare ser-platform)

(clojure.core/declare ser-delete-stream)

(clojure.core/declare ser-function-arn)

(clojure.core/declare ser-topic-pattern)

(clojure.core/declare ser-signature-algorithm)

(clojure.core/declare ser-query-version)

(clojure.core/declare ser-rule-name)

(clojure.core/declare ser-job-status)

(clojure.core/declare ser-code-signing-certificate-chain)

(clojure.core/declare ser-comment)

(clojure.core/declare ser-certificate-signing-request)

(clojure.core/declare ser-day-of-week)

(clojure.core/declare ser-page-size)

(clojure.core/declare ser-prefix)

(clojure.core/declare ser-message-id)

(clojure.core/declare ser-thing-type-description)

(clojure.core/declare ser-abort-criteria)

(clojure.core/declare ser-audit-task-type)

(clojure.core/declare ser-canned-access-control-list)

(clojure.core/declare ser-thing-group-id)

(clojure.core/declare ser-duration-seconds)

(clojure.core/declare ser-thing-type-name)

(clojure.core/declare ser-iot-events-action)

(clojure.core/declare ser-execution-number)

(clojure.core/declare ser-input-name)

(clojure.core/declare ser-additional-metrics-to-retain-list)

(clojure.core/declare ser-number-of-things)

(clojure.core/declare ser-key-value)

(clojure.core/declare ser-thing-group-arn)

(clojure.core/declare ser-attribute-name)

(clojure.core/declare ser-log-level)

(clojure.core/declare ser-target-audit-check-names)

(clojure.core/declare ser-policy-name)

(clojure.core/declare ser-action-list)

(clojure.core/declare ser-registration-config)

(clojure.core/declare ser-additional-parameter-map)

(clojure.core/declare ser-laser-max-results)

(clojure.core/declare ser-expires-in-sec)

(clojure.core/declare ser-thing-arn)

(clojure.core/declare ser-template-body)

(clojure.core/declare ser-behavior)

(clojure.core/declare ser-index-name)

(clojure.core/declare ser-endpoint-type)

(clojure.core/declare ser-certificate-name)

(clojure.core/declare ser-attribute-payload)

(clojure.core/declare ser-parameters)

(clojure.core/declare ser-inline-document)

(clojure.core/declare ser-state-value)

(clojure.core/declare ser-use-base-64)

(clojure.core/declare ser-abort-config)

(clojure.core/declare ser-certificate-path-on-device)

(clojure.core/declare ser-security-profile-target-arn)

(clojure.core/declare ser-day-of-month)

(clojure.core/declare ser-max-job-executions-per-min)

(clojure.core/declare ser-ca-certificate-status)

(clojure.core/declare ser-role-arn)

(clojure.core/declare ser-target-arn)

(clojure.core/declare ser-abort-criteria-list)

(clojure.core/declare ser-disable-all-logs)

(clojure.core/declare ser-registry-s-3-key-name)

(clojure.core/declare ser-partition-key)

(clojure.core/declare ser-flag)

(clojure.core/declare ser-marker)

(clojure.core/declare ser-tag-key)

(clojure.core/declare ser-ota-update-files)

(clojure.core/declare ser-start-signing-job-parameter)

(clojure.core/declare ser-destination)

(clojure.core/declare ser-comparison-operator)

(clojure.core/declare ser-task-id)

(clojure.core/declare ser-policy-names)

(clojure.core/declare ser-exponential-rollout-rate)

(clojure.core/declare ser-elasticsearch-type)

(clojure.core/declare ser-rate-increase-criteria)

(clojure.core/declare ser-set-as-active-flag)

(clojure.core/declare ser-force-delete-aws-job)

(clojure.core/declare ser-alert-targets)

(clojure.core/declare ser-aws-arn)

(clojure.core/declare ser-stream-files)

(clojure.core/declare ser-key-name)

(clojure.core/declare ser-log-target-type)

(clojure.core/declare ser-enabled)

(clojure.core/declare ser-query-string)

(clojure.core/declare ser-status)

(clojure.core/declare ser-behaviors)

(clojure.core/declare ser-allow-auto-registration)

(clojure.core/declare ser-event-type)

(clojure.core/declare ser-role-alias)

(clojure.core/declare ser-put-item-input)

(clojure.core/declare ser-log-target-name)

(clojure.core/declare ser-next-token)

(clojure.core/declare ser-behavior-metric)

(clojure.core/declare ser-ota-update-file)

(clojure.core/declare ser-range-key-value)

(clojure.core/declare ser-hash-key-value)

(clojure.core/declare ser-firehose-action)

(clojure.core/declare ser-consecutive-datapoints-to-alarm)

(clojure.core/declare ser-security-profile-name)

(clojure.core/declare ser-thing-group-properties)

(clojure.core/declare ser-cidrs)

(clojure.core/declare ser-topic)

(clojure.core/declare ser-alert-target-type)

(clojure.core/declare ser-job-document)

(clojure.core/declare ser-audit-check-name)

(clojure.core/declare ser-key)

(clojure.core/declare ser-recursive-without-default)

(clojure.core/declare ser-stream-description)

(clojure.core/declare ser-salesforce-token)

(clojure.core/declare ser-thing-group-indexing-mode)

(clojure.core/declare ser-target-selection)

(clojure.core/declare ser-remove-auto-registration)

(clojure.core/declare ser-attributes)

(clojure.core/declare ser-queue-url)

(clojure.core/declare ser-force-flag)

(clojure.core/declare ser-unsigned-long)

(clojure.core/declare ser-tag-list)

(clojure.core/declare ser-signature)

(clojure.core/declare ser-searchable-attributes)

(clojure.core/declare ser-tag-key-list)

(clojure.core/declare ser-message-format)

(clojure.core/declare ser-thing-indexing-configuration)

(clojure.core/declare ser-audit-frequency)

(clojure.core/declare ser-attribute-value)

(clojure.core/declare ser-ota-update-file-version)

(clojure.core/declare ser-dynamo-key-type)

(clojure.core/declare ser-public-key-map)

(clojure.core/declare ser-behavior-criteria)

(clojure.core/declare ser-signing-profile-parameter)

(clojure.core/declare ser-stream-file)

(clojure.core/declare ser-sns-action)

(clojure.core/declare ser-channel-name)

(clojure.core/declare ser-presigned-url-config)

(clojure.core/declare ser-undo-deprecate)

(clojure.core/declare ser-value)

(clojure.core/declare ser-credential-duration-seconds)

(clojure.core/declare ser-delete-alert-targets)

(clojure.core/declare ser-aws-job-executions-rollout-config)

(clojure.core/declare ser-description)

(clojure.core/declare ser-tag-value)

(clojure.core/declare ser-ota-update-description)

(clojure.core/declare ser-token-key-name)

(clojure.core/declare ser-policy-document)

(clojure.core/declare ser-port)

(clojure.core/declare ser-authorizer-status)

(clojure.core/declare ser-timeout-config)

(clojure.core/declare ser-aws-account-id)

(clojure.core/declare ser-message)

(clojure.core/declare ser-is-disabled)

(clojure.core/declare ser-resources)

(clojure.core/declare ser-attribute-key)

(clojure.core/declare ser-file-location)

(clojure.core/declare ser-log-target)

(clojure.core/declare ser-cloudwatch-metric-action)

(clojure.core/declare ser-audit-notification-target)

(clojure.core/declare ser-job-executions-rollout-config)

(clojure.core/declare ser-delete-behaviors)

(clojure.core/declare ser-attributes-map)

(clojure.core/declare ser-job-document-source)

(clojure.core/declare ser-remove-thing-type)

(clojure.core/declare ser-delivery-stream-name)

(clojure.core/declare ser-billing-group-description)

(clojure.core/declare ser-sqs-action)

(clojure.core/declare ser-s-3-version)

(clojure.core/declare ser-string)

(clojure.core/declare ser-cognito-identity-pool-id)

(clojure.core/declare ser-delete-additional-metrics-to-retain)

(clojure.core/declare ser-parameter)

(clojure.core/declare ser-details-value)

(clojure.core/declare ser-ports)

(clojure.core/declare ser-job-targets)

(clojure.core/declare ser-thing-connectivity-indexing-mode)

(clojure.core/declare ser-code-signing-signature)

(clojure.core/declare ser-alert-target-arn)

(clojure.core/declare ser-abort-threshold-percentage)

(clojure.core/declare ser-audit-notification-type)

(clojure.core/declare ser-report-type)

(clojure.core/declare ser-alarm-name)

(clojure.core/declare ser-hash-key-field)

(clojure.core/declare ser-targets)

(clojure.core/declare ser-thing-name)

(clojure.core/declare ser-republish-action)

(clojure.core/declare ser-resource-identifier)

(clojure.core/declare ser-s-3-key)

(clojure.core/declare ser-job-execution-status)

(clojure.core/declare ser-metric-value)

(clojure.core/declare ser-client-id)

(clojure.core/declare ser-audit-check-configurations)

(clojure.core/declare ser-delete-scheduled-audits)

(clojure.core/declare ser-elasticsearch-action)

(clojure.core/declare ser-s-3-location)

(clojure.core/declare ser-elasticsearch-index)

(clojure.core/declare ser-certificate-arn)

(clojure.core/declare ser-custom-code-signing)

(clojure.core/declare ser-set-as-active)

(clojure.core/declare ser-table-name)

(clojure.core/declare ser-s-3-bucket)

(clojure.core/declare ser-billing-group-name)

(clojure.core/declare ser-aws-iot-sql-version)

(clojure.core/declare ser-auth-infos)

(clojure.core/declare ser-stream)

(clojure.core/declare ser-sql)

(clojure.core/declare ser-details-key)

(clojure.core/declare ser-registry-s-3-bucket-name)

(clojure.core/declare ser-abort-action)

(clojure.core/declare ser-dynamo-db-action)

(clojure.core/declare ser-policy-version-id)

(clojure.core/declare ser-alert-target)

(clojure.core/declare ser-timestamp)

(clojure.core/declare ser-dynamo-operation)

(clojure.core/declare ser-resource-arn)

(clojure.core/declare ser-hash-algorithm)

(clojure.core/declare ser-certificate-status)

(clojure.core/declare ser-policy-version-identifier)

(clojure.core/declare ser-authorizer-name)

(clojure.core/declare ser-maximum-per-minute)

(clojure.core/declare ser-behavior-name)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-tag)

(clojure.core/declare ser-s-3-destination)

(clojure.core/declare ser-set-as-default)

(clojure.core/declare ser-resource)

(clojure.core/declare ser-reason-code)

(clojure.core/declare ser-job-execution-failure-type)

(clojure.core/declare ser-state-machine-name)

(clojure.core/declare ser-logging-options-payload)

(clojure.core/declare ser-elasticsearch-id)

(clojure.core/declare ser-file-id)

(clojure.core/declare ser-salesforce-action)

(clojure.core/declare ser-event-configurations)

(clojure.core/declare ser-salesforce-endpoint)

(clojure.core/declare ser-step-functions-action)

(clojure.core/declare ser-ascending-order)

(clojure.core/declare ser-auth-info)

(clojure.core/declare ser-target)

(clojure.core/declare ser-ge-max-results)

(clojure.core/declare ser-rollout-rate-per-minute)

(clojure.core/declare ser-optional-version)

(clojure.core/declare ser-action-type)

(clojure.core/declare ser-thing-group-name)

(clojure.core/declare ser-principal)

(clojure.core/declare ser-policy-target)

(clojure.core/declare ser-execution-name-prefix)

(clojure.core/declare ser-evaluation-statistic)

(clojure.core/declare ser-scheduled-audit-name)

(clojure.core/declare ser-cloudwatch-alarm-action)

(clojure.core/declare ser-signing-job-id)

(clojure.core/declare ser-lambda-action)

(clojure.core/declare ser-bucket-name)

(clojure.core/declare ser-certificate-id)

(clojure.core/declare ser-ota-update-status)

(clojure.core/declare ser-certificate-pem)

(clojure.core/declare ser-file-name)

(clojure.core/declare ser-ota-update-id)

(clojure.core/declare ser-action)

(clojure.core/declare ser-configuration)

(clojure.core/declare ser-token)

(clojure.core/declare ser-increment-factor)

(clojure.core/declare ser-job-description)

(clojure.core/declare ser-state-reason)

(clojure.core/declare ser-elasticsearch-endpoint)

(clojure.core/declare ser-signing-profile-name)

(clojure.core/declare ser-details-map)

(clojure.core/declare ser-consecutive-datapoints-to-clear)

(clojure.core/declare ser-force-delete)

(clojure.core/declare ser-recursive)

(clojure.core/declare ser-audit-check-configuration)

(clojure.core/declare ser-audit-task-status)

(clojure.core/declare ser-s-3-action)

(clojure.core/declare ser-iot-analytics-action)

(clojure.core/declare ser-kinesis-action)

(clojure.core/declare ser-query-max-results)

(clojure.core/declare ser-audit-task-id)

(clojure.core/declare ser-thing-group-list)

(clojure.core/declare ser-payload-field)

(clojure.core/declare ser-authorizer-function-arn)

(clojure.core/declare ser-firehose-separator)

(clojure.core/declare ser-job-id)

(clojure.core/defn- ser-registry-max-results [input] #:http.request.field{:value input, :shape "RegistryMaxResults"})

(clojure.core/defn- ser-stream-id [input] #:http.request.field{:value input, :shape "StreamId"})

(clojure.core/defn- ser-expected-version [input] #:http.request.field{:value input, :shape "ExpectedVersion"})

(clojure.core/defn- ser-billing-group-arn [input] #:http.request.field{:value input, :shape "BillingGroupArn"})

(clojure.core/defn- ser-auto-registration-status [input] #:http.request.field{:value (clojure.core/get {"ENABLE" "ENABLE", :enable "ENABLE", "DISABLE" "DISABLE", :disable "DISABLE"} input), :shape "AutoRegistrationStatus"})

(clojure.core/defn- ser-thing-indexing-mode [input] #:http.request.field{:value (clojure.core/get {"OFF" "OFF", :off "OFF", "REGISTRY" "REGISTRY", :registry "REGISTRY", "REGISTRY_AND_SHADOW" "REGISTRY_AND_SHADOW", :registry-and-shadow "REGISTRY_AND_SHADOW"} input), :shape "ThingIndexingMode"})

(clojure.core/defn- ser-billing-group-properties [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BillingGroupProperties", :type "structure"} (clojure.core/contains? input :billing-group-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-description (input :billing-group-description)) #:http.request.field{:name "billingGroupDescription", :shape "BillingGroupDescription"}))))

(clojure.core/defn- ser-skyfall-max-results [input] #:http.request.field{:value input, :shape "SkyfallMaxResults"})

(clojure.core/defn- ser-thing-group-description [input] #:http.request.field{:value input, :shape "ThingGroupDescription"})

(clojure.core/defn- ser-range-key-field [input] #:http.request.field{:value input, :shape "RangeKeyField"})

(clojure.core/defn- ser-thing-group-indexing-configuration [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-thing-group-indexing-mode (:thing-group-indexing-mode input)) #:http.request.field{:name "thingGroupIndexingMode", :shape "ThingGroupIndexingMode"})], :shape "ThingGroupIndexingConfiguration", :type "structure"}))

(clojure.core/defn- ser-security-profile-description [input] #:http.request.field{:value input, :shape "SecurityProfileDescription"})

(clojure.core/defn- ser-in-progress-timeout-in-minutes [input] #:http.request.field{:value input, :shape "InProgressTimeoutInMinutes"})

(clojure.core/defn- ser-thing-type-properties [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ThingTypeProperties", :type "structure"} (clojure.core/contains? input :thing-type-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-description (input :thing-type-description)) #:http.request.field{:name "thingTypeDescription", :shape "ThingTypeDescription"})) (clojure.core/contains? input :searchable-attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-searchable-attributes (input :searchable-attributes)) #:http.request.field{:name "searchableAttributes", :shape "SearchableAttributes"}))))

(clojure.core/defn- ser-stream-name [input] #:http.request.field{:value input, :shape "StreamName"})

(clojure.core/defn- ser-token-signature [input] #:http.request.field{:value input, :shape "TokenSignature"})

(clojure.core/defn- ser-code-signing [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CodeSigning", :type "structure"} (clojure.core/contains? input :aws-signer-job-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signing-job-id (input :aws-signer-job-id)) #:http.request.field{:name "awsSignerJobId", :shape "SigningJobId"})) (clojure.core/contains? input :start-signing-job-parameter) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-start-signing-job-parameter (input :start-signing-job-parameter)) #:http.request.field{:name "startSigningJobParameter", :shape "StartSigningJobParameter"})) (clojure.core/contains? input :custom-code-signing) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-custom-code-signing (input :custom-code-signing)) #:http.request.field{:name "customCodeSigning", :shape "CustomCodeSigning"}))))

(clojure.core/defn- ser-dynamo-d-bv-2-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-put-item-input (:put-item input)) #:http.request.field{:name "putItem", :shape "PutItemInput"})], :shape "DynamoDBv2Action", :type "structure"}))

(clojure.core/defn- ser-audit-notification-target-configurations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-audit-notification-type k) #:http.request.field{:map-info "key", :shape "AuditNotificationType"}) (clojure.core/into (ser-audit-notification-target v) #:http.request.field{:map-info "value", :shape "AuditNotificationTarget"})])) input), :shape "AuditNotificationTargetConfigurations", :type "map"})

(clojure.core/defn- ser-statistical-threshold [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StatisticalThreshold", :type "structure"} (clojure.core/contains? input :statistic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-evaluation-statistic (input :statistic)) #:http.request.field{:name "statistic", :shape "EvaluationStatistic"}))))

(clojure.core/defn- ser-override-dynamic-groups [input] #:http.request.field{:value input, :shape "OverrideDynamicGroups"})

(clojure.core/defn- ser-topic-rule-payload [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-sql (:sql input)) #:http.request.field{:name "sql", :shape "SQL"}) (clojure.core/into (ser-action-list (:actions input)) #:http.request.field{:name "actions", :shape "ActionList"})], :shape "TopicRulePayload", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-description (input :description)) #:http.request.field{:name "description", :shape "Description"})) (clojure.core/contains? input :rule-disabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-is-disabled (input :rule-disabled)) #:http.request.field{:name "ruleDisabled", :shape "IsDisabled"})) (clojure.core/contains? input :aws-iot-sql-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-iot-sql-version (input :aws-iot-sql-version)) #:http.request.field{:name "awsIotSqlVersion", :shape "AwsIotSqlVersion"})) (clojure.core/contains? input :error-action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :error-action)) #:http.request.field{:name "errorAction", :shape "Action"}))))

(clojure.core/defn- ser-minimum-number-of-executed-things [input] #:http.request.field{:value input, :shape "MinimumNumberOfExecutedThings"})

(clojure.core/defn- ser-cidr [input] #:http.request.field{:value input, :shape "Cidr"})

(clojure.core/defn- ser-platform [input] #:http.request.field{:value input, :shape "Platform"})

(clojure.core/defn- ser-delete-stream [input] #:http.request.field{:value input, :shape "DeleteStream"})

(clojure.core/defn- ser-function-arn [input] #:http.request.field{:value input, :shape "FunctionArn"})

(clojure.core/defn- ser-topic-pattern [input] #:http.request.field{:value input, :shape "TopicPattern"})

(clojure.core/defn- ser-signature-algorithm [input] #:http.request.field{:value input, :shape "SignatureAlgorithm"})

(clojure.core/defn- ser-query-version [input] #:http.request.field{:value input, :shape "QueryVersion"})

(clojure.core/defn- ser-rule-name [input] #:http.request.field{:value input, :shape "RuleName"})

(clojure.core/defn- ser-job-status [input] #:http.request.field{:value (clojure.core/get {"IN_PROGRESS" "IN_PROGRESS", :in-progress "IN_PROGRESS", "CANCELED" "CANCELED", :canceled "CANCELED", "COMPLETED" "COMPLETED", :completed "COMPLETED", "DELETION_IN_PROGRESS" "DELETION_IN_PROGRESS", :deletion-in-progress "DELETION_IN_PROGRESS"} input), :shape "JobStatus"})

(clojure.core/defn- ser-code-signing-certificate-chain [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CodeSigningCertificateChain", :type "structure"} (clojure.core/contains? input :certificate-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-name (input :certificate-name)) #:http.request.field{:name "certificateName", :shape "CertificateName"})) (clojure.core/contains? input :inline-document) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-inline-document (input :inline-document)) #:http.request.field{:name "inlineDocument", :shape "InlineDocument"}))))

(clojure.core/defn- ser-comment [input] #:http.request.field{:value input, :shape "Comment"})

(clojure.core/defn- ser-certificate-signing-request [input] #:http.request.field{:value input, :shape "CertificateSigningRequest"})

(clojure.core/defn- ser-day-of-week [input] #:http.request.field{:value (clojure.core/get {:wed "WED", "TUE" "TUE", "SAT" "SAT", "SUN" "SUN", :sat "SAT", "MON" "MON", :tue "TUE", :fri "FRI", :sun "SUN", "THU" "THU", "WED" "WED", "FRI" "FRI", :mon "MON", :thu "THU"} input), :shape "DayOfWeek"})

(clojure.core/defn- ser-page-size [input] #:http.request.field{:value input, :shape "PageSize"})

(clojure.core/defn- ser-prefix [input] #:http.request.field{:value input, :shape "Prefix"})

(clojure.core/defn- ser-message-id [input] #:http.request.field{:value input, :shape "MessageId"})

(clojure.core/defn- ser-thing-type-description [input] #:http.request.field{:value input, :shape "ThingTypeDescription"})

(clojure.core/defn- ser-abort-criteria [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-job-execution-failure-type (:failure-type input)) #:http.request.field{:name "failureType", :shape "JobExecutionFailureType"}) (clojure.core/into (ser-abort-action (:action input)) #:http.request.field{:name "action", :shape "AbortAction"}) (clojure.core/into (ser-abort-threshold-percentage (:threshold-percentage input)) #:http.request.field{:name "thresholdPercentage", :shape "AbortThresholdPercentage"}) (clojure.core/into (ser-minimum-number-of-executed-things (:min-number-of-executed-things input)) #:http.request.field{:name "minNumberOfExecutedThings", :shape "MinimumNumberOfExecutedThings"})], :shape "AbortCriteria", :type "structure"}))

(clojure.core/defn- ser-audit-task-type [input] #:http.request.field{:value (clojure.core/get {"ON_DEMAND_AUDIT_TASK" "ON_DEMAND_AUDIT_TASK", :on-demand-audit-task "ON_DEMAND_AUDIT_TASK", "SCHEDULED_AUDIT_TASK" "SCHEDULED_AUDIT_TASK", :scheduled-audit-task "SCHEDULED_AUDIT_TASK"} input), :shape "AuditTaskType"})

(clojure.core/defn- ser-canned-access-control-list [input] #:http.request.field{:value (clojure.core/get {"authenticated-read" "authenticated-read", :logdeliverywrite "log-delivery-write", :bucketownerfullcontrol "bucket-owner-full-control", "public-read-write" "public-read-write", :private "private", "bucket-owner-full-control" "bucket-owner-full-control", "private" "private", :bucketownerread "bucket-owner-read", :publicread "public-read", "aws-exec-read" "aws-exec-read", :publicreadwrite "public-read-write", :awsexecread "aws-exec-read", "bucket-owner-read" "bucket-owner-read", "public-read" "public-read", "log-delivery-write" "log-delivery-write", :authenticatedread "authenticated-read"} input), :shape "CannedAccessControlList"})

(clojure.core/defn- ser-thing-group-id [input] #:http.request.field{:value input, :shape "ThingGroupId"})

(clojure.core/defn- ser-duration-seconds [input] #:http.request.field{:value input, :shape "DurationSeconds"})

(clojure.core/defn- ser-thing-type-name [input] #:http.request.field{:value input, :shape "ThingTypeName"})

(clojure.core/defn- ser-iot-events-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-input-name (:input-name input)) #:http.request.field{:name "inputName", :shape "InputName"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "IotEventsAction", :type "structure"} (clojure.core/contains? input :message-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-id (input :message-id)) #:http.request.field{:name "messageId", :shape "MessageId"}))))

(clojure.core/defn- ser-execution-number [input] #:http.request.field{:value input, :shape "ExecutionNumber"})

(clojure.core/defn- ser-input-name [input] #:http.request.field{:value input, :shape "InputName"})

(clojure.core/defn- ser-additional-metrics-to-retain-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-behavior-metric coll) #:http.request.field{:shape "BehaviorMetric"}))) input), :shape "AdditionalMetricsToRetainList", :type "list"})

(clojure.core/defn- ser-number-of-things [input] #:http.request.field{:value input, :shape "NumberOfThings"})

(clojure.core/defn- ser-key-value [input] #:http.request.field{:value input, :shape "KeyValue"})

(clojure.core/defn- ser-thing-group-arn [input] #:http.request.field{:value input, :shape "ThingGroupArn"})

(clojure.core/defn- ser-attribute-name [input] #:http.request.field{:value input, :shape "AttributeName"})

(clojure.core/defn- ser-log-level [input] #:http.request.field{:value (clojure.core/get {"DISABLED" "DISABLED", :disabled "DISABLED", :warn "WARN", "WARN" "WARN", :debug "DEBUG", "ERROR" "ERROR", "DEBUG" "DEBUG", :info "INFO", :error "ERROR", "INFO" "INFO"} input), :shape "LogLevel"})

(clojure.core/defn- ser-target-audit-check-names [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-audit-check-name coll) #:http.request.field{:shape "AuditCheckName"}))) input), :shape "TargetAuditCheckNames", :type "list"})

(clojure.core/defn- ser-policy-name [input] #:http.request.field{:value input, :shape "PolicyName"})

(clojure.core/defn- ser-action-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-action coll) #:http.request.field{:shape "Action"}))) input), :shape "ActionList", :type "list", :max 10, :min 0})

(clojure.core/defn- ser-registration-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RegistrationConfig", :type "structure"} (clojure.core/contains? input :template-body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-template-body (input :template-body)) #:http.request.field{:name "templateBody", :shape "TemplateBody"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"}))))

(clojure.core/defn- ser-additional-parameter-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-key k) #:http.request.field{:map-info "key", :shape "AttributeKey"}) (clojure.core/into (ser-value v) #:http.request.field{:map-info "value", :shape "Value"})])) input), :shape "AdditionalParameterMap", :type "map"})

(clojure.core/defn- ser-laser-max-results [input] #:http.request.field{:value input, :shape "LaserMaxResults"})

(clojure.core/defn- ser-expires-in-sec [input] #:http.request.field{:value input, :shape "ExpiresInSec"})

(clojure.core/defn- ser-thing-arn [input] #:http.request.field{:value input, :shape "ThingArn"})

(clojure.core/defn- ser-template-body [input] #:http.request.field{:value input, :shape "TemplateBody"})

(clojure.core/defn- ser-behavior [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-behavior-name (:name input)) #:http.request.field{:name "name", :shape "BehaviorName"})], :shape "Behavior", :type "structure"} (clojure.core/contains? input :metric) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behavior-metric (input :metric)) #:http.request.field{:name "metric", :shape "BehaviorMetric"})) (clojure.core/contains? input :criteria) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behavior-criteria (input :criteria)) #:http.request.field{:name "criteria", :shape "BehaviorCriteria"}))))

(clojure.core/defn- ser-index-name [input] #:http.request.field{:value input, :shape "IndexName"})

(clojure.core/defn- ser-endpoint-type [input] #:http.request.field{:value input, :shape "EndpointType"})

(clojure.core/defn- ser-certificate-name [input] #:http.request.field{:value input, :shape "CertificateName"})

(clojure.core/defn- ser-attribute-payload [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttributePayload", :type "structure"} (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attributes (input :attributes)) #:http.request.field{:name "attributes", :shape "Attributes"})) (clojure.core/contains? input :merge) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-flag (input :merge)) #:http.request.field{:name "merge", :shape "Flag"}))))

(clojure.core/defn- ser-parameters [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-parameter k) #:http.request.field{:map-info "key", :shape "Parameter"}) (clojure.core/into (ser-value v) #:http.request.field{:map-info "value", :shape "Value"})])) input), :shape "Parameters", :type "map"})

(clojure.core/defn- ser-inline-document [input] #:http.request.field{:value input, :shape "InlineDocument"})

(clojure.core/defn- ser-state-value [input] #:http.request.field{:value input, :shape "StateValue"})

(clojure.core/defn- ser-use-base-64 [input] #:http.request.field{:value input, :shape "UseBase64"})

(clojure.core/defn- ser-abort-config [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-abort-criteria-list (:criteria-list input)) #:http.request.field{:name "criteriaList", :shape "AbortCriteriaList"})], :shape "AbortConfig", :type "structure"}))

(clojure.core/defn- ser-certificate-path-on-device [input] #:http.request.field{:value input, :shape "CertificatePathOnDevice"})

(clojure.core/defn- ser-security-profile-target-arn [input] #:http.request.field{:value input, :shape "SecurityProfileTargetArn"})

(clojure.core/defn- ser-day-of-month [input] #:http.request.field{:value input, :shape "DayOfMonth"})

(clojure.core/defn- ser-max-job-executions-per-min [input] #:http.request.field{:value input, :shape "MaxJobExecutionsPerMin"})

(clojure.core/defn- ser-ca-certificate-status [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE", "INACTIVE" "INACTIVE", :inactive "INACTIVE"} input), :shape "CACertificateStatus"})

(clojure.core/defn- ser-role-arn [input] #:http.request.field{:value input, :shape "RoleArn"})

(clojure.core/defn- ser-target-arn [input] #:http.request.field{:value input, :shape "TargetArn"})

(clojure.core/defn- ser-abort-criteria-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-abort-criteria coll) #:http.request.field{:shape "AbortCriteria"}))) input), :shape "AbortCriteriaList", :type "list", :min 1})

(clojure.core/defn- ser-disable-all-logs [input] #:http.request.field{:value input, :shape "DisableAllLogs"})

(clojure.core/defn- ser-registry-s-3-key-name [input] #:http.request.field{:value input, :shape "RegistryS3KeyName"})

(clojure.core/defn- ser-partition-key [input] #:http.request.field{:value input, :shape "PartitionKey"})

(clojure.core/defn- ser-flag [input] #:http.request.field{:value input, :shape "Flag"})

(clojure.core/defn- ser-marker [input] #:http.request.field{:value input, :shape "Marker"})

(clojure.core/defn- ser-tag-key [input] #:http.request.field{:value input, :shape "TagKey"})

(clojure.core/defn- ser-ota-update-files [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-ota-update-file coll) #:http.request.field{:shape "OTAUpdateFile"}))) input), :shape "OTAUpdateFiles", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-start-signing-job-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StartSigningJobParameter", :type "structure"} (clojure.core/contains? input :signing-profile-parameter) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signing-profile-parameter (input :signing-profile-parameter)) #:http.request.field{:name "signingProfileParameter", :shape "SigningProfileParameter"})) (clojure.core/contains? input :signing-profile-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signing-profile-name (input :signing-profile-name)) #:http.request.field{:name "signingProfileName", :shape "SigningProfileName"})) (clojure.core/contains? input :destination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-destination (input :destination)) #:http.request.field{:name "destination", :shape "Destination"}))))

(clojure.core/defn- ser-destination [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Destination", :type "structure"} (clojure.core/contains? input :s-3-destination) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-destination (input :s-3-destination)) #:http.request.field{:name "s3Destination", :shape "S3Destination"}))))

(clojure.core/defn- ser-comparison-operator [input] #:http.request.field{:value (clojure.core/get {"less-than-equals" "less-than-equals", :notinportset "not-in-port-set", :notincidrset "not-in-cidr-set", "greater-than" "greater-than", "not-in-port-set" "not-in-port-set", :lessthan "less-than", "greater-than-equals" "greater-than-equals", :lessthanequals "less-than-equals", :incidrset "in-cidr-set", "in-cidr-set" "in-cidr-set", "not-in-cidr-set" "not-in-cidr-set", :greaterthanequals "greater-than-equals", "in-port-set" "in-port-set", :inportset "in-port-set", :greaterthan "greater-than", "less-than" "less-than"} input), :shape "ComparisonOperator"})

(clojure.core/defn- ser-task-id [input] #:http.request.field{:value input, :shape "TaskId"})

(clojure.core/defn- ser-policy-names [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-policy-name coll) #:http.request.field{:shape "PolicyName"}))) input), :shape "PolicyNames", :type "list"})

(clojure.core/defn- ser-exponential-rollout-rate [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-rollout-rate-per-minute (:base-rate-per-minute input)) #:http.request.field{:name "baseRatePerMinute", :shape "RolloutRatePerMinute"}) (clojure.core/into (ser-increment-factor (:increment-factor input)) #:http.request.field{:name "incrementFactor", :shape "IncrementFactor"}) (clojure.core/into (ser-rate-increase-criteria (:rate-increase-criteria input)) #:http.request.field{:name "rateIncreaseCriteria", :shape "RateIncreaseCriteria"})], :shape "ExponentialRolloutRate", :type "structure"}))

(clojure.core/defn- ser-elasticsearch-type [input] #:http.request.field{:value input, :shape "ElasticsearchType"})

(clojure.core/defn- ser-rate-increase-criteria [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RateIncreaseCriteria", :type "structure"} (clojure.core/contains? input :number-of-notified-things) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-number-of-things (input :number-of-notified-things)) #:http.request.field{:name "numberOfNotifiedThings", :shape "NumberOfThings"})) (clojure.core/contains? input :number-of-succeeded-things) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-number-of-things (input :number-of-succeeded-things)) #:http.request.field{:name "numberOfSucceededThings", :shape "NumberOfThings"}))))

(clojure.core/defn- ser-set-as-active-flag [input] #:http.request.field{:value input, :shape "SetAsActiveFlag"})

(clojure.core/defn- ser-force-delete-aws-job [input] #:http.request.field{:value input, :shape "ForceDeleteAWSJob"})

(clojure.core/defn- ser-alert-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-alert-target-type k) #:http.request.field{:map-info "key", :shape "AlertTargetType"}) (clojure.core/into (ser-alert-target v) #:http.request.field{:map-info "value", :shape "AlertTarget"})])) input), :shape "AlertTargets", :type "map"})

(clojure.core/defn- ser-aws-arn [input] #:http.request.field{:value input, :shape "AwsArn"})

(clojure.core/defn- ser-stream-files [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-stream-file coll) #:http.request.field{:shape "StreamFile"}))) input), :shape "StreamFiles", :type "list", :max 50, :min 1})

(clojure.core/defn- ser-key-name [input] #:http.request.field{:value input, :shape "KeyName"})

(clojure.core/defn- ser-log-target-type [input] #:http.request.field{:value (clojure.core/get {"DEFAULT" "DEFAULT", :default "DEFAULT", "THING_GROUP" "THING_GROUP", :thing-group "THING_GROUP"} input), :shape "LogTargetType"})

(clojure.core/defn- ser-enabled [input] #:http.request.field{:value input, :shape "Enabled"})

(clojure.core/defn- ser-query-string [input] #:http.request.field{:value input, :shape "QueryString"})

(clojure.core/defn- ser-status [input] #:http.request.field{:value (clojure.core/get {"Failed" "Failed", "Cancelled" "Cancelled", :in-progress "InProgress", "Cancelling" "Cancelling", :completed "Completed", :cancelled "Cancelled", "InProgress" "InProgress", "Completed" "Completed", :cancelling "Cancelling", :failed "Failed"} input), :shape "Status"})

(clojure.core/defn- ser-behaviors [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-behavior coll) #:http.request.field{:shape "Behavior"}))) input), :shape "Behaviors", :type "list", :max 100})

(clojure.core/defn- ser-allow-auto-registration [input] #:http.request.field{:value input, :shape "AllowAutoRegistration"})

(clojure.core/defn- ser-event-type [input] #:http.request.field{:value (clojure.core/get {:ca-certificate "CA_CERTIFICATE", :thing-group "THING_GROUP", "THING_TYPE" "THING_TYPE", "THING_GROUP_HIERARCHY" "THING_GROUP_HIERARCHY", "JOB_EXECUTION" "JOB_EXECUTION", "CA_CERTIFICATE" "CA_CERTIFICATE", :thing-group-membership "THING_GROUP_MEMBERSHIP", :job-execution "JOB_EXECUTION", "THING_TYPE_ASSOCIATION" "THING_TYPE_ASSOCIATION", "JOB" "JOB", :thing-group-hierarchy "THING_GROUP_HIERARCHY", :policy "POLICY", :certificate "CERTIFICATE", :thing "THING", :thing-type "THING_TYPE", "POLICY" "POLICY", "THING_GROUP" "THING_GROUP", "THING_GROUP_MEMBERSHIP" "THING_GROUP_MEMBERSHIP", "THING" "THING", :job "JOB", "CERTIFICATE" "CERTIFICATE", :thing-type-association "THING_TYPE_ASSOCIATION"} input), :shape "EventType"})

(clojure.core/defn- ser-role-alias [input] #:http.request.field{:value input, :shape "RoleAlias"})

(clojure.core/defn- ser-put-item-input [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-table-name (:table-name input)) #:http.request.field{:name "tableName", :shape "TableName"})], :shape "PutItemInput", :type "structure"}))

(clojure.core/defn- ser-log-target-name [input] #:http.request.field{:value input, :shape "LogTargetName"})

(clojure.core/defn- ser-next-token [input] #:http.request.field{:value input, :shape "NextToken"})

(clojure.core/defn- ser-behavior-metric [input] #:http.request.field{:value input, :shape "BehaviorMetric"})

(clojure.core/defn- ser-ota-update-file [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "OTAUpdateFile", :type "structure"} (clojure.core/contains? input :file-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-name (input :file-name)) #:http.request.field{:name "fileName", :shape "FileName"})) (clojure.core/contains? input :file-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ota-update-file-version (input :file-version)) #:http.request.field{:name "fileVersion", :shape "OTAUpdateFileVersion"})) (clojure.core/contains? input :file-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-location (input :file-location)) #:http.request.field{:name "fileLocation", :shape "FileLocation"})) (clojure.core/contains? input :code-signing) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-code-signing (input :code-signing)) #:http.request.field{:name "codeSigning", :shape "CodeSigning"})) (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attributes-map (input :attributes)) #:http.request.field{:name "attributes", :shape "AttributesMap"}))))

(clojure.core/defn- ser-range-key-value [input] #:http.request.field{:value input, :shape "RangeKeyValue"})

(clojure.core/defn- ser-hash-key-value [input] #:http.request.field{:value input, :shape "HashKeyValue"})

(clojure.core/defn- ser-firehose-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-delivery-stream-name (:delivery-stream-name input)) #:http.request.field{:name "deliveryStreamName", :shape "DeliveryStreamName"})], :shape "FirehoseAction", :type "structure"} (clojure.core/contains? input :separator) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-firehose-separator (input :separator)) #:http.request.field{:name "separator", :shape "FirehoseSeparator"}))))

(clojure.core/defn- ser-consecutive-datapoints-to-alarm [input] #:http.request.field{:value input, :shape "ConsecutiveDatapointsToAlarm"})

(clojure.core/defn- ser-security-profile-name [input] #:http.request.field{:value input, :shape "SecurityProfileName"})

(clojure.core/defn- ser-thing-group-properties [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ThingGroupProperties", :type "structure"} (clojure.core/contains? input :thing-group-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-description (input :thing-group-description)) #:http.request.field{:name "thingGroupDescription", :shape "ThingGroupDescription"})) (clojure.core/contains? input :attribute-payload) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-payload (input :attribute-payload)) #:http.request.field{:name "attributePayload", :shape "AttributePayload"}))))

(clojure.core/defn- ser-cidrs [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-cidr coll) #:http.request.field{:shape "Cidr"}))) input), :shape "Cidrs", :type "list"})

(clojure.core/defn- ser-topic [input] #:http.request.field{:value input, :shape "Topic"})

(clojure.core/defn- ser-alert-target-type [input] #:http.request.field{:value (clojure.core/get {"SNS" "SNS", :sns "SNS"} input), :shape "AlertTargetType"})

(clojure.core/defn- ser-job-document [input] #:http.request.field{:value input, :shape "JobDocument"})

(clojure.core/defn- ser-audit-check-name [input] #:http.request.field{:value input, :shape "AuditCheckName"})

(clojure.core/defn- ser-key [input] #:http.request.field{:value input, :shape "Key"})

(clojure.core/defn- ser-recursive-without-default [input] #:http.request.field{:value input, :shape "RecursiveWithoutDefault"})

(clojure.core/defn- ser-stream-description [input] #:http.request.field{:value input, :shape "StreamDescription"})

(clojure.core/defn- ser-salesforce-token [input] #:http.request.field{:value input, :shape "SalesforceToken"})

(clojure.core/defn- ser-thing-group-indexing-mode [input] #:http.request.field{:value (clojure.core/get {"OFF" "OFF", :off "OFF", "ON" "ON", :on "ON"} input), :shape "ThingGroupIndexingMode"})

(clojure.core/defn- ser-target-selection [input] #:http.request.field{:value (clojure.core/get {"CONTINUOUS" "CONTINUOUS", :continuous "CONTINUOUS", "SNAPSHOT" "SNAPSHOT", :snapshot "SNAPSHOT"} input), :shape "TargetSelection"})

(clojure.core/defn- ser-remove-auto-registration [input] #:http.request.field{:value input, :shape "RemoveAutoRegistration"})

(clojure.core/defn- ser-attributes [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-name k) #:http.request.field{:map-info "key", :shape "AttributeName"}) (clojure.core/into (ser-attribute-value v) #:http.request.field{:map-info "value", :shape "AttributeValue"})])) input), :shape "Attributes", :type "map"})

(clojure.core/defn- ser-queue-url [input] #:http.request.field{:value input, :shape "QueueUrl"})

(clojure.core/defn- ser-force-flag [input] #:http.request.field{:value input, :shape "ForceFlag"})

(clojure.core/defn- ser-unsigned-long [input] #:http.request.field{:value input, :shape "UnsignedLong"})

(clojure.core/defn- ser-tag-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag coll) #:http.request.field{:shape "Tag"}))) input), :shape "TagList", :type "list"})

(clojure.core/defn- ser-signature [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "Signature"})

(clojure.core/defn- ser-searchable-attributes [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-attribute-name coll) #:http.request.field{:shape "AttributeName"}))) input), :shape "SearchableAttributes", :type "list"})

(clojure.core/defn- ser-tag-key-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-tag-key coll) #:http.request.field{:shape "TagKey"}))) input), :shape "TagKeyList", :type "list"})

(clojure.core/defn- ser-message-format [input] #:http.request.field{:value (clojure.core/get {"RAW" "RAW", :raw "RAW", "JSON" "JSON", :json "JSON"} input), :shape "MessageFormat"})

(clojure.core/defn- ser-thing-indexing-configuration [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-thing-indexing-mode (:thing-indexing-mode input)) #:http.request.field{:name "thingIndexingMode", :shape "ThingIndexingMode"})], :shape "ThingIndexingConfiguration", :type "structure"} (clojure.core/contains? input :thing-connectivity-indexing-mode) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-connectivity-indexing-mode (input :thing-connectivity-indexing-mode)) #:http.request.field{:name "thingConnectivityIndexingMode", :shape "ThingConnectivityIndexingMode"}))))

(clojure.core/defn- ser-audit-frequency [input] #:http.request.field{:value (clojure.core/get {"DAILY" "DAILY", :daily "DAILY", "WEEKLY" "WEEKLY", :weekly "WEEKLY", "BIWEEKLY" "BIWEEKLY", :biweekly "BIWEEKLY", "MONTHLY" "MONTHLY", :monthly "MONTHLY"} input), :shape "AuditFrequency"})

(clojure.core/defn- ser-attribute-value [input] #:http.request.field{:value input, :shape "AttributeValue"})

(clojure.core/defn- ser-ota-update-file-version [input] #:http.request.field{:value input, :shape "OTAUpdateFileVersion"})

(clojure.core/defn- ser-dynamo-key-type [input] #:http.request.field{:value (clojure.core/get {"STRING" "STRING", :string "STRING", "NUMBER" "NUMBER", :number "NUMBER"} input), :shape "DynamoKeyType"})

(clojure.core/defn- ser-public-key-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-key-name k) #:http.request.field{:map-info "key", :shape "KeyName"}) (clojure.core/into (ser-key-value v) #:http.request.field{:map-info "value", :shape "KeyValue"})])) input), :shape "PublicKeyMap", :type "map"})

(clojure.core/defn- ser-behavior-criteria [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BehaviorCriteria", :type "structure"} (clojure.core/contains? input :comparison-operator) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comparison-operator (input :comparison-operator)) #:http.request.field{:name "comparisonOperator", :shape "ComparisonOperator"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-metric-value (input :value)) #:http.request.field{:name "value", :shape "MetricValue"})) (clojure.core/contains? input :duration-seconds) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-duration-seconds (input :duration-seconds)) #:http.request.field{:name "durationSeconds", :shape "DurationSeconds"})) (clojure.core/contains? input :consecutive-datapoints-to-alarm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-consecutive-datapoints-to-alarm (input :consecutive-datapoints-to-alarm)) #:http.request.field{:name "consecutiveDatapointsToAlarm", :shape "ConsecutiveDatapointsToAlarm"})) (clojure.core/contains? input :consecutive-datapoints-to-clear) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-consecutive-datapoints-to-clear (input :consecutive-datapoints-to-clear)) #:http.request.field{:name "consecutiveDatapointsToClear", :shape "ConsecutiveDatapointsToClear"})) (clojure.core/contains? input :statistical-threshold) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-statistical-threshold (input :statistical-threshold)) #:http.request.field{:name "statisticalThreshold", :shape "StatisticalThreshold"}))))

(clojure.core/defn- ser-signing-profile-parameter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SigningProfileParameter", :type "structure"} (clojure.core/contains? input :certificate-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-arn (input :certificate-arn)) #:http.request.field{:name "certificateArn", :shape "CertificateArn"})) (clojure.core/contains? input :platform) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-platform (input :platform)) #:http.request.field{:name "platform", :shape "Platform"})) (clojure.core/contains? input :certificate-path-on-device) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-path-on-device (input :certificate-path-on-device)) #:http.request.field{:name "certificatePathOnDevice", :shape "CertificatePathOnDevice"}))))

(clojure.core/defn- ser-stream-file [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "StreamFile", :type "structure"} (clojure.core/contains? input :file-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-id (input :file-id)) #:http.request.field{:name "fileId", :shape "FileId"})) (clojure.core/contains? input :s-3-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-location (input :s-3-location)) #:http.request.field{:name "s3Location", :shape "S3Location"}))))

(clojure.core/defn- ser-sns-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:target-arn input)) #:http.request.field{:name "targetArn", :shape "AwsArn"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "SnsAction", :type "structure"} (clojure.core/contains? input :message-format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-format (input :message-format)) #:http.request.field{:name "messageFormat", :shape "MessageFormat"}))))

(clojure.core/defn- ser-channel-name [input] #:http.request.field{:value input, :shape "ChannelName"})

(clojure.core/defn- ser-presigned-url-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PresignedUrlConfig", :type "structure"} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :expires-in-sec) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-expires-in-sec (input :expires-in-sec)) #:http.request.field{:name "expiresInSec", :shape "ExpiresInSec"}))))

(clojure.core/defn- ser-undo-deprecate [input] #:http.request.field{:value input, :shape "UndoDeprecate"})

(clojure.core/defn- ser-value [input] #:http.request.field{:value input, :shape "Value"})

(clojure.core/defn- ser-credential-duration-seconds [input] #:http.request.field{:value input, :shape "CredentialDurationSeconds"})

(clojure.core/defn- ser-delete-alert-targets [input] #:http.request.field{:value input, :shape "DeleteAlertTargets"})

(clojure.core/defn- ser-aws-job-executions-rollout-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AwsJobExecutionsRolloutConfig", :type "structure"} (clojure.core/contains? input :maximum-per-minute) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-maximum-per-minute (input :maximum-per-minute)) #:http.request.field{:name "maximumPerMinute", :shape "MaximumPerMinute"}))))

(clojure.core/defn- ser-description [input] #:http.request.field{:value input, :shape "Description"})

(clojure.core/defn- ser-tag-value [input] #:http.request.field{:value input, :shape "TagValue"})

(clojure.core/defn- ser-ota-update-description [input] #:http.request.field{:value input, :shape "OTAUpdateDescription"})

(clojure.core/defn- ser-token-key-name [input] #:http.request.field{:value input, :shape "TokenKeyName"})

(clojure.core/defn- ser-policy-document [input] #:http.request.field{:value input, :shape "PolicyDocument"})

(clojure.core/defn- ser-port [input] #:http.request.field{:value input, :shape "Port"})

(clojure.core/defn- ser-authorizer-status [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE", "INACTIVE" "INACTIVE", :inactive "INACTIVE"} input), :shape "AuthorizerStatus"})

(clojure.core/defn- ser-timeout-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "TimeoutConfig", :type "structure"} (clojure.core/contains? input :in-progress-timeout-in-minutes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-in-progress-timeout-in-minutes (input :in-progress-timeout-in-minutes)) #:http.request.field{:name "inProgressTimeoutInMinutes", :shape "InProgressTimeoutInMinutes"}))))

(clojure.core/defn- ser-aws-account-id [input] #:http.request.field{:value input, :shape "AwsAccountId"})

(clojure.core/defn- ser-message [input] #:http.request.field{:value input, :shape "Message"})

(clojure.core/defn- ser-is-disabled [input] #:http.request.field{:value input, :shape "IsDisabled"})

(clojure.core/defn- ser-resources [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-resource coll) #:http.request.field{:shape "Resource"}))) input), :shape "Resources", :type "list"})

(clojure.core/defn- ser-attribute-key [input] #:http.request.field{:value input, :shape "AttributeKey"})

(clojure.core/defn- ser-file-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "FileLocation", :type "structure"} (clojure.core/contains? input :stream) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream (input :stream)) #:http.request.field{:name "stream", :shape "Stream"})) (clojure.core/contains? input :s-3-location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-location (input :s-3-location)) #:http.request.field{:name "s3Location", :shape "S3Location"}))))

(clojure.core/defn- ser-log-target [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-log-target-type (:target-type input)) #:http.request.field{:name "targetType", :shape "LogTargetType"})], :shape "LogTarget", :type "structure"} (clojure.core/contains? input :target-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-target-name (input :target-name)) #:http.request.field{:name "targetName", :shape "LogTargetName"}))))

(clojure.core/defn- ser-cloudwatch-metric-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-string (:metric-namespace input)) #:http.request.field{:name "metricNamespace", :shape "String"}) (clojure.core/into (ser-string (:metric-name input)) #:http.request.field{:name "metricName", :shape "String"}) (clojure.core/into (ser-string (:metric-value input)) #:http.request.field{:name "metricValue", :shape "String"}) (clojure.core/into (ser-string (:metric-unit input)) #:http.request.field{:name "metricUnit", :shape "String"})], :shape "CloudwatchMetricAction", :type "structure"} (clojure.core/contains? input :metric-timestamp) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :metric-timestamp)) #:http.request.field{:name "metricTimestamp", :shape "String"}))))

(clojure.core/defn- ser-audit-notification-target [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AuditNotificationTarget", :type "structure"} (clojure.core/contains? input :target-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-arn (input :target-arn)) #:http.request.field{:name "targetArn", :shape "TargetArn"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-enabled (input :enabled)) #:http.request.field{:name "enabled", :shape "Enabled"}))))

(clojure.core/defn- ser-job-executions-rollout-config [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "JobExecutionsRolloutConfig", :type "structure"} (clojure.core/contains? input :maximum-per-minute) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-job-executions-per-min (input :maximum-per-minute)) #:http.request.field{:name "maximumPerMinute", :shape "MaxJobExecutionsPerMin"})) (clojure.core/contains? input :exponential-rate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-exponential-rollout-rate (input :exponential-rate)) #:http.request.field{:name "exponentialRate", :shape "ExponentialRolloutRate"}))))

(clojure.core/defn- ser-delete-behaviors [input] #:http.request.field{:value input, :shape "DeleteBehaviors"})

(clojure.core/defn- ser-attributes-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-attribute-key k) #:http.request.field{:map-info "key", :shape "AttributeKey"}) (clojure.core/into (ser-value v) #:http.request.field{:map-info "value", :shape "Value"})])) input), :shape "AttributesMap", :type "map"})

(clojure.core/defn- ser-job-document-source [input] #:http.request.field{:value input, :shape "JobDocumentSource"})

(clojure.core/defn- ser-remove-thing-type [input] #:http.request.field{:value input, :shape "RemoveThingType"})

(clojure.core/defn- ser-delivery-stream-name [input] #:http.request.field{:value input, :shape "DeliveryStreamName"})

(clojure.core/defn- ser-billing-group-description [input] #:http.request.field{:value input, :shape "BillingGroupDescription"})

(clojure.core/defn- ser-sqs-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-queue-url (:queue-url input)) #:http.request.field{:name "queueUrl", :shape "QueueUrl"})], :shape "SqsAction", :type "structure"} (clojure.core/contains? input :use-base-64) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-use-base-64 (input :use-base-64)) #:http.request.field{:name "useBase64", :shape "UseBase64"}))))

(clojure.core/defn- ser-s-3-version [input] #:http.request.field{:value input, :shape "S3Version"})

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "String"})

(clojure.core/defn- ser-cognito-identity-pool-id [input] #:http.request.field{:value input, :shape "CognitoIdentityPoolId"})

(clojure.core/defn- ser-delete-additional-metrics-to-retain [input] #:http.request.field{:value input, :shape "DeleteAdditionalMetricsToRetain"})

(clojure.core/defn- ser-parameter [input] #:http.request.field{:value input, :shape "Parameter"})

(clojure.core/defn- ser-details-value [input] #:http.request.field{:value input, :shape "DetailsValue"})

(clojure.core/defn- ser-ports [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-port coll) #:http.request.field{:shape "Port"}))) input), :shape "Ports", :type "list"})

(clojure.core/defn- ser-job-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target-arn coll) #:http.request.field{:shape "TargetArn"}))) input), :shape "JobTargets", :type "list", :min 1})

(clojure.core/defn- ser-thing-connectivity-indexing-mode [input] #:http.request.field{:value (clojure.core/get {"OFF" "OFF", :off "OFF", "STATUS" "STATUS", :status "STATUS"} input), :shape "ThingConnectivityIndexingMode"})

(clojure.core/defn- ser-code-signing-signature [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CodeSigningSignature", :type "structure"} (clojure.core/contains? input :inline-document) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signature (input :inline-document)) #:http.request.field{:name "inlineDocument", :shape "Signature"}))))

(clojure.core/defn- ser-alert-target-arn [input] #:http.request.field{:value input, :shape "AlertTargetArn"})

(clojure.core/defn- ser-abort-threshold-percentage [input] #:http.request.field{:value input, :shape "AbortThresholdPercentage"})

(clojure.core/defn- ser-audit-notification-type [input] #:http.request.field{:value (clojure.core/get {"SNS" "SNS", :sns "SNS"} input), :shape "AuditNotificationType"})

(clojure.core/defn- ser-report-type [input] #:http.request.field{:value (clojure.core/get {"ERRORS" "ERRORS", :errors "ERRORS", "RESULTS" "RESULTS", :results "RESULTS"} input), :shape "ReportType"})

(clojure.core/defn- ser-alarm-name [input] #:http.request.field{:value input, :shape "AlarmName"})

(clojure.core/defn- ser-hash-key-field [input] #:http.request.field{:value input, :shape "HashKeyField"})

(clojure.core/defn- ser-targets [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-target coll) #:http.request.field{:shape "Target"}))) input), :shape "Targets", :type "list", :min 1})

(clojure.core/defn- ser-thing-name [input] #:http.request.field{:value input, :shape "ThingName"})

(clojure.core/defn- ser-republish-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-topic-pattern (:topic input)) #:http.request.field{:name "topic", :shape "TopicPattern"})], :shape "RepublishAction", :type "structure"}))

(clojure.core/defn- ser-resource-identifier [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ResourceIdentifier", :type "structure"} (clojure.core/contains? input :device-certificate-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-id (input :device-certificate-id)) #:http.request.field{:name "deviceCertificateId", :shape "CertificateId"})) (clojure.core/contains? input :ca-certificate-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-id (input :ca-certificate-id)) #:http.request.field{:name "caCertificateId", :shape "CertificateId"})) (clojure.core/contains? input :cognito-identity-pool-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cognito-identity-pool-id (input :cognito-identity-pool-id)) #:http.request.field{:name "cognitoIdentityPoolId", :shape "CognitoIdentityPoolId"})) (clojure.core/contains? input :client-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-id (input :client-id)) #:http.request.field{:name "clientId", :shape "ClientId"})) (clojure.core/contains? input :policy-version-identifier) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-version-identifier (input :policy-version-identifier)) #:http.request.field{:name "policyVersionIdentifier", :shape "PolicyVersionIdentifier"})) (clojure.core/contains? input :account) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-account-id (input :account)) #:http.request.field{:name "account", :shape "AwsAccountId"}))))

(clojure.core/defn- ser-s-3-key [input] #:http.request.field{:value input, :shape "S3Key"})

(clojure.core/defn- ser-job-execution-status [input] #:http.request.field{:value (clojure.core/get {"CANCELED" "CANCELED", :timed-out "TIMED_OUT", "IN_PROGRESS" "IN_PROGRESS", "TIMED_OUT" "TIMED_OUT", :in-progress "IN_PROGRESS", :rejected "REJECTED", "REMOVED" "REMOVED", :queued "QUEUED", :canceled "CANCELED", "SUCCEEDED" "SUCCEEDED", "REJECTED" "REJECTED", "QUEUED" "QUEUED", "FAILED" "FAILED", :removed "REMOVED", :failed "FAILED", :succeeded "SUCCEEDED"} input), :shape "JobExecutionStatus"})

(clojure.core/defn- ser-metric-value [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MetricValue", :type "structure"} (clojure.core/contains? input :count) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-unsigned-long (input :count)) #:http.request.field{:name "count", :shape "UnsignedLong"})) (clojure.core/contains? input :cidrs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cidrs (input :cidrs)) #:http.request.field{:name "cidrs", :shape "Cidrs"})) (clojure.core/contains? input :ports) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ports (input :ports)) #:http.request.field{:name "ports", :shape "Ports"}))))

(clojure.core/defn- ser-client-id [input] #:http.request.field{:value input, :shape "ClientId"})

(clojure.core/defn- ser-audit-check-configurations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-audit-check-name k) #:http.request.field{:map-info "key", :shape "AuditCheckName"}) (clojure.core/into (ser-audit-check-configuration v) #:http.request.field{:map-info "value", :shape "AuditCheckConfiguration"})])) input), :shape "AuditCheckConfigurations", :type "map"})

(clojure.core/defn- ser-delete-scheduled-audits [input] #:http.request.field{:value input, :shape "DeleteScheduledAudits"})

(clojure.core/defn- ser-elasticsearch-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-elasticsearch-endpoint (:endpoint input)) #:http.request.field{:name "endpoint", :shape "ElasticsearchEndpoint"}) (clojure.core/into (ser-elasticsearch-index (:index input)) #:http.request.field{:name "index", :shape "ElasticsearchIndex"}) (clojure.core/into (ser-elasticsearch-type (:type input)) #:http.request.field{:name "type", :shape "ElasticsearchType"}) (clojure.core/into (ser-elasticsearch-id (:id input)) #:http.request.field{:name "id", :shape "ElasticsearchId"})], :shape "ElasticsearchAction", :type "structure"}))

(clojure.core/defn- ser-s-3-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3Location", :type "structure"} (clojure.core/contains? input :bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket (input :bucket)) #:http.request.field{:name "bucket", :shape "S3Bucket"})) (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-key (input :key)) #:http.request.field{:name "key", :shape "S3Key"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-version (input :version)) #:http.request.field{:name "version", :shape "S3Version"}))))

(clojure.core/defn- ser-elasticsearch-index [input] #:http.request.field{:value input, :shape "ElasticsearchIndex"})

(clojure.core/defn- ser-certificate-arn [input] #:http.request.field{:value input, :shape "CertificateArn"})

(clojure.core/defn- ser-custom-code-signing [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CustomCodeSigning", :type "structure"} (clojure.core/contains? input :signature) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-code-signing-signature (input :signature)) #:http.request.field{:name "signature", :shape "CodeSigningSignature"})) (clojure.core/contains? input :certificate-chain) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-code-signing-certificate-chain (input :certificate-chain)) #:http.request.field{:name "certificateChain", :shape "CodeSigningCertificateChain"})) (clojure.core/contains? input :hash-algorithm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-hash-algorithm (input :hash-algorithm)) #:http.request.field{:name "hashAlgorithm", :shape "HashAlgorithm"})) (clojure.core/contains? input :signature-algorithm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-signature-algorithm (input :signature-algorithm)) #:http.request.field{:name "signatureAlgorithm", :shape "SignatureAlgorithm"}))))

(clojure.core/defn- ser-set-as-active [input] #:http.request.field{:value input, :shape "SetAsActive"})

(clojure.core/defn- ser-table-name [input] #:http.request.field{:value input, :shape "TableName"})

(clojure.core/defn- ser-s-3-bucket [input] #:http.request.field{:value input, :shape "S3Bucket"})

(clojure.core/defn- ser-billing-group-name [input] #:http.request.field{:value input, :shape "BillingGroupName"})

(clojure.core/defn- ser-aws-iot-sql-version [input] #:http.request.field{:value input, :shape "AwsIotSqlVersion"})

(clojure.core/defn- ser-auth-infos [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-auth-info coll) #:http.request.field{:shape "AuthInfo"}))) input), :shape "AuthInfos", :type "list", :max 10, :min 1})

(clojure.core/defn- ser-stream [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Stream", :type "structure"} (clojure.core/contains? input :stream-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId"})) (clojure.core/contains? input :file-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-file-id (input :file-id)) #:http.request.field{:name "fileId", :shape "FileId"}))))

(clojure.core/defn- ser-sql [input] #:http.request.field{:value input, :shape "SQL"})

(clojure.core/defn- ser-details-key [input] #:http.request.field{:value input, :shape "DetailsKey"})

(clojure.core/defn- ser-registry-s-3-bucket-name [input] #:http.request.field{:value input, :shape "RegistryS3BucketName"})

(clojure.core/defn- ser-abort-action [input] #:http.request.field{:value (clojure.core/get {"CANCEL" "CANCEL", :cancel "CANCEL"} input), :shape "AbortAction"})

(clojure.core/defn- ser-dynamo-db-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-table-name (:table-name input)) #:http.request.field{:name "tableName", :shape "TableName"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-hash-key-field (:hash-key-field input)) #:http.request.field{:name "hashKeyField", :shape "HashKeyField"}) (clojure.core/into (ser-hash-key-value (:hash-key-value input)) #:http.request.field{:name "hashKeyValue", :shape "HashKeyValue"})], :shape "DynamoDBAction", :type "structure"} (clojure.core/contains? input :range-key-value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-range-key-value (input :range-key-value)) #:http.request.field{:name "rangeKeyValue", :shape "RangeKeyValue"})) (clojure.core/contains? input :range-key-field) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-range-key-field (input :range-key-field)) #:http.request.field{:name "rangeKeyField", :shape "RangeKeyField"})) (clojure.core/contains? input :hash-key-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-key-type (input :hash-key-type)) #:http.request.field{:name "hashKeyType", :shape "DynamoKeyType"})) (clojure.core/contains? input :operation) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-operation (input :operation)) #:http.request.field{:name "operation", :shape "DynamoOperation"})) (clojure.core/contains? input :payload-field) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-payload-field (input :payload-field)) #:http.request.field{:name "payloadField", :shape "PayloadField"})) (clojure.core/contains? input :range-key-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-key-type (input :range-key-type)) #:http.request.field{:name "rangeKeyType", :shape "DynamoKeyType"}))))

(clojure.core/defn- ser-policy-version-id [input] #:http.request.field{:value input, :shape "PolicyVersionId"})

(clojure.core/defn- ser-alert-target [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-alert-target-arn (:alert-target-arn input)) #:http.request.field{:name "alertTargetArn", :shape "AlertTargetArn"}) (clojure.core/into (ser-role-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "RoleArn"})], :shape "AlertTarget", :type "structure"}))

(clojure.core/defn- ser-timestamp [input] #:http.request.field{:value input, :shape "Timestamp"})

(clojure.core/defn- ser-dynamo-operation [input] #:http.request.field{:value input, :shape "DynamoOperation"})

(clojure.core/defn- ser-resource-arn [input] #:http.request.field{:value input, :shape "ResourceArn"})

(clojure.core/defn- ser-hash-algorithm [input] #:http.request.field{:value input, :shape "HashAlgorithm"})

(clojure.core/defn- ser-certificate-status [input] #:http.request.field{:value (clojure.core/get {:inactive "INACTIVE", "REGISTER_INACTIVE" "REGISTER_INACTIVE", "REVOKED" "REVOKED", :revoked "REVOKED", :pending-activation "PENDING_ACTIVATION", :register-inactive "REGISTER_INACTIVE", :pending-transfer "PENDING_TRANSFER", :active "ACTIVE", "INACTIVE" "INACTIVE", "PENDING_ACTIVATION" "PENDING_ACTIVATION", "ACTIVE" "ACTIVE", "PENDING_TRANSFER" "PENDING_TRANSFER"} input), :shape "CertificateStatus"})

(clojure.core/defn- ser-policy-version-identifier [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PolicyVersionIdentifier", :type "structure"} (clojure.core/contains? input :policy-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName"})) (clojure.core/contains? input :policy-version-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId"}))))

(clojure.core/defn- ser-authorizer-name [input] #:http.request.field{:value input, :shape "AuthorizerName"})

(clojure.core/defn- ser-maximum-per-minute [input] #:http.request.field{:value input, :shape "MaximumPerMinute"})

(clojure.core/defn- ser-behavior-name [input] #:http.request.field{:value input, :shape "BehaviorName"})

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-tag [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Tag", :type "structure"} (clojure.core/contains? input :key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-key (input :key)) #:http.request.field{:name "Key", :shape "TagKey"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-value (input :value)) #:http.request.field{:name "Value", :shape "TagValue"}))))

(clojure.core/defn- ser-s-3-destination [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "S3Destination", :type "structure"} (clojure.core/contains? input :bucket) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-bucket (input :bucket)) #:http.request.field{:name "bucket", :shape "S3Bucket"})) (clojure.core/contains? input :prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-prefix (input :prefix)) #:http.request.field{:name "prefix", :shape "Prefix"}))))

(clojure.core/defn- ser-set-as-default [input] #:http.request.field{:value input, :shape "SetAsDefault"})

(clojure.core/defn- ser-resource [input] #:http.request.field{:value input, :shape "Resource"})

(clojure.core/defn- ser-reason-code [input] #:http.request.field{:value input, :shape "ReasonCode"})

(clojure.core/defn- ser-job-execution-failure-type [input] #:http.request.field{:value (clojure.core/get {"FAILED" "FAILED", :failed "FAILED", "REJECTED" "REJECTED", :rejected "REJECTED", "TIMED_OUT" "TIMED_OUT", :timed-out "TIMED_OUT", "ALL" "ALL", :all "ALL"} input), :shape "JobExecutionFailureType"})

(clojure.core/defn- ser-state-machine-name [input] #:http.request.field{:value input, :shape "StateMachineName"})

(clojure.core/defn- ser-logging-options-payload [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "LoggingOptionsPayload", :type "structure"} (clojure.core/contains? input :log-level) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-level (input :log-level)) #:http.request.field{:name "logLevel", :shape "LogLevel"}))))

(clojure.core/defn- ser-elasticsearch-id [input] #:http.request.field{:value input, :shape "ElasticsearchId"})

(clojure.core/defn- ser-file-id [input] #:http.request.field{:value input, :shape "FileId"})

(clojure.core/defn- ser-salesforce-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-salesforce-token (:token input)) #:http.request.field{:name "token", :shape "SalesforceToken"}) (clojure.core/into (ser-salesforce-endpoint (:url input)) #:http.request.field{:name "url", :shape "SalesforceEndpoint"})], :shape "SalesforceAction", :type "structure"}))

(clojure.core/defn- ser-event-configurations [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-event-type k) #:http.request.field{:map-info "key", :shape "EventType"}) (clojure.core/into (ser-configuration v) #:http.request.field{:map-info "value", :shape "Configuration"})])) input), :shape "EventConfigurations", :type "map"})

(clojure.core/defn- ser-salesforce-endpoint [input] #:http.request.field{:value input, :shape "SalesforceEndpoint"})

(clojure.core/defn- ser-step-functions-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-state-machine-name (:state-machine-name input)) #:http.request.field{:name "stateMachineName", :shape "StateMachineName"}) (clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"})], :shape "StepFunctionsAction", :type "structure"} (clojure.core/contains? input :execution-name-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-name-prefix (input :execution-name-prefix)) #:http.request.field{:name "executionNamePrefix", :shape "ExecutionNamePrefix"}))))

(clojure.core/defn- ser-ascending-order [input] #:http.request.field{:value input, :shape "AscendingOrder"})

(clojure.core/defn- ser-auth-info [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AuthInfo", :type "structure"} (clojure.core/contains? input :action-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action-type (input :action-type)) #:http.request.field{:name "actionType", :shape "ActionType"})) (clojure.core/contains? input :resources) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resources (input :resources)) #:http.request.field{:name "resources", :shape "Resources"}))))

(clojure.core/defn- ser-target [input] #:http.request.field{:value input, :shape "Target"})

(clojure.core/defn- ser-ge-max-results [input] #:http.request.field{:value input, :shape "GEMaxResults"})

(clojure.core/defn- ser-rollout-rate-per-minute [input] #:http.request.field{:value input, :shape "RolloutRatePerMinute"})

(clojure.core/defn- ser-optional-version [input] #:http.request.field{:value input, :shape "OptionalVersion"})

(clojure.core/defn- ser-action-type [input] #:http.request.field{:value (clojure.core/get {"PUBLISH" "PUBLISH", :publish "PUBLISH", "SUBSCRIBE" "SUBSCRIBE", :subscribe "SUBSCRIBE", "RECEIVE" "RECEIVE", :receive "RECEIVE", "CONNECT" "CONNECT", :connect "CONNECT"} input), :shape "ActionType"})

(clojure.core/defn- ser-thing-group-name [input] #:http.request.field{:value input, :shape "ThingGroupName"})

(clojure.core/defn- ser-principal [input] #:http.request.field{:value input, :shape "Principal"})

(clojure.core/defn- ser-policy-target [input] #:http.request.field{:value input, :shape "PolicyTarget"})

(clojure.core/defn- ser-execution-name-prefix [input] #:http.request.field{:value input, :shape "ExecutionNamePrefix"})

(clojure.core/defn- ser-evaluation-statistic [input] #:http.request.field{:value input, :shape "EvaluationStatistic"})

(clojure.core/defn- ser-scheduled-audit-name [input] #:http.request.field{:value input, :shape "ScheduledAuditName"})

(clojure.core/defn- ser-cloudwatch-alarm-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-alarm-name (:alarm-name input)) #:http.request.field{:name "alarmName", :shape "AlarmName"}) (clojure.core/into (ser-state-reason (:state-reason input)) #:http.request.field{:name "stateReason", :shape "StateReason"}) (clojure.core/into (ser-state-value (:state-value input)) #:http.request.field{:name "stateValue", :shape "StateValue"})], :shape "CloudwatchAlarmAction", :type "structure"}))

(clojure.core/defn- ser-signing-job-id [input] #:http.request.field{:value input, :shape "SigningJobId"})

(clojure.core/defn- ser-lambda-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-function-arn (:function-arn input)) #:http.request.field{:name "functionArn", :shape "FunctionArn"})], :shape "LambdaAction", :type "structure"}))

(clojure.core/defn- ser-bucket-name [input] #:http.request.field{:value input, :shape "BucketName"})

(clojure.core/defn- ser-certificate-id [input] #:http.request.field{:value input, :shape "CertificateId"})

(clojure.core/defn- ser-ota-update-status [input] #:http.request.field{:value (clojure.core/get {"CREATE_PENDING" "CREATE_PENDING", :create-pending "CREATE_PENDING", "CREATE_IN_PROGRESS" "CREATE_IN_PROGRESS", :create-in-progress "CREATE_IN_PROGRESS", "CREATE_COMPLETE" "CREATE_COMPLETE", :create-complete "CREATE_COMPLETE", "CREATE_FAILED" "CREATE_FAILED", :create-failed "CREATE_FAILED"} input), :shape "OTAUpdateStatus"})

(clojure.core/defn- ser-certificate-pem [input] #:http.request.field{:value input, :shape "CertificatePem"})

(clojure.core/defn- ser-file-name [input] #:http.request.field{:value input, :shape "FileName"})

(clojure.core/defn- ser-ota-update-id [input] #:http.request.field{:value input, :shape "OTAUpdateId"})

(clojure.core/defn- ser-action [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Action", :type "structure"} (clojure.core/contains? input :dynamo-db) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-db-action (input :dynamo-db)) #:http.request.field{:name "dynamoDB", :shape "DynamoDBAction"})) (clojure.core/contains? input :sns) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sns-action (input :sns)) #:http.request.field{:name "sns", :shape "SnsAction"})) (clojure.core/contains? input :cloudwatch-alarm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloudwatch-alarm-action (input :cloudwatch-alarm)) #:http.request.field{:name "cloudwatchAlarm", :shape "CloudwatchAlarmAction"})) (clojure.core/contains? input :iot-analytics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iot-analytics-action (input :iot-analytics)) #:http.request.field{:name "iotAnalytics", :shape "IotAnalyticsAction"})) (clojure.core/contains? input :republish) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-republish-action (input :republish)) #:http.request.field{:name "republish", :shape "RepublishAction"})) (clojure.core/contains? input :kinesis) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-kinesis-action (input :kinesis)) #:http.request.field{:name "kinesis", :shape "KinesisAction"})) (clojure.core/contains? input :s-3) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-s-3-action (input :s-3)) #:http.request.field{:name "s3", :shape "S3Action"})) (clojure.core/contains? input :salesforce) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-salesforce-action (input :salesforce)) #:http.request.field{:name "salesforce", :shape "SalesforceAction"})) (clojure.core/contains? input :sqs) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sqs-action (input :sqs)) #:http.request.field{:name "sqs", :shape "SqsAction"})) (clojure.core/contains? input :elasticsearch) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-elasticsearch-action (input :elasticsearch)) #:http.request.field{:name "elasticsearch", :shape "ElasticsearchAction"})) (clojure.core/contains? input :cloudwatch-metric) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cloudwatch-metric-action (input :cloudwatch-metric)) #:http.request.field{:name "cloudwatchMetric", :shape "CloudwatchMetricAction"})) (clojure.core/contains? input :firehose) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-firehose-action (input :firehose)) #:http.request.field{:name "firehose", :shape "FirehoseAction"})) (clojure.core/contains? input :dynamo-d-bv-2) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dynamo-d-bv-2-action (input :dynamo-d-bv-2)) #:http.request.field{:name "dynamoDBv2", :shape "DynamoDBv2Action"})) (clojure.core/contains? input :lambda) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-lambda-action (input :lambda)) #:http.request.field{:name "lambda", :shape "LambdaAction"})) (clojure.core/contains? input :step-functions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-step-functions-action (input :step-functions)) #:http.request.field{:name "stepFunctions", :shape "StepFunctionsAction"})) (clojure.core/contains? input :iot-events) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-iot-events-action (input :iot-events)) #:http.request.field{:name "iotEvents", :shape "IotEventsAction"}))))

(clojure.core/defn- ser-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Configuration", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-enabled (input :enabled)) #:http.request.field{:name "Enabled", :shape "Enabled"}))))

(clojure.core/defn- ser-token [input] #:http.request.field{:value input, :shape "Token"})

(clojure.core/defn- ser-increment-factor [input] #:http.request.field{:value input, :shape "IncrementFactor"})

(clojure.core/defn- ser-job-description [input] #:http.request.field{:value input, :shape "JobDescription"})

(clojure.core/defn- ser-state-reason [input] #:http.request.field{:value input, :shape "StateReason"})

(clojure.core/defn- ser-elasticsearch-endpoint [input] #:http.request.field{:value input, :shape "ElasticsearchEndpoint"})

(clojure.core/defn- ser-signing-profile-name [input] #:http.request.field{:value input, :shape "SigningProfileName"})

(clojure.core/defn- ser-details-map [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-details-key k) #:http.request.field{:map-info "key", :shape "DetailsKey"}) (clojure.core/into (ser-details-value v) #:http.request.field{:map-info "value", :shape "DetailsValue"})])) input), :shape "DetailsMap", :type "map"})

(clojure.core/defn- ser-consecutive-datapoints-to-clear [input] #:http.request.field{:value input, :shape "ConsecutiveDatapointsToClear"})

(clojure.core/defn- ser-force-delete [input] #:http.request.field{:value input, :shape "ForceDelete"})

(clojure.core/defn- ser-recursive [input] #:http.request.field{:value input, :shape "Recursive"})

(clojure.core/defn- ser-audit-check-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AuditCheckConfiguration", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-enabled (input :enabled)) #:http.request.field{:name "enabled", :shape "Enabled"}))))

(clojure.core/defn- ser-audit-task-status [input] #:http.request.field{:value (clojure.core/get {"IN_PROGRESS" "IN_PROGRESS", :in-progress "IN_PROGRESS", "COMPLETED" "COMPLETED", :completed "COMPLETED", "FAILED" "FAILED", :failed "FAILED", "CANCELED" "CANCELED", :canceled "CANCELED"} input), :shape "AuditTaskStatus"})

(clojure.core/defn- ser-s-3-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-bucket-name (:bucket-name input)) #:http.request.field{:name "bucketName", :shape "BucketName"}) (clojure.core/into (ser-key (:key input)) #:http.request.field{:name "key", :shape "Key"})], :shape "S3Action", :type "structure"} (clojure.core/contains? input :canned-acl) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-canned-access-control-list (input :canned-acl)) #:http.request.field{:name "cannedAcl", :shape "CannedAccessControlList"}))))

(clojure.core/defn- ser-iot-analytics-action [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "IotAnalyticsAction", :type "structure"} (clojure.core/contains? input :channel-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-arn (input :channel-arn)) #:http.request.field{:name "channelArn", :shape "AwsArn"})) (clojure.core/contains? input :channel-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-channel-name (input :channel-name)) #:http.request.field{:name "channelName", :shape "ChannelName"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "AwsArn"}))))

(clojure.core/defn- ser-kinesis-action [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-aws-arn (:role-arn input)) #:http.request.field{:name "roleArn", :shape "AwsArn"}) (clojure.core/into (ser-stream-name (:stream-name input)) #:http.request.field{:name "streamName", :shape "StreamName"})], :shape "KinesisAction", :type "structure"} (clojure.core/contains? input :partition-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-partition-key (input :partition-key)) #:http.request.field{:name "partitionKey", :shape "PartitionKey"}))))

(clojure.core/defn- ser-query-max-results [input] #:http.request.field{:value input, :shape "QueryMaxResults"})

(clojure.core/defn- ser-audit-task-id [input] #:http.request.field{:value input, :shape "AuditTaskId"})

(clojure.core/defn- ser-thing-group-list [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-thing-group-name coll) #:http.request.field{:shape "ThingGroupName"}))) input), :shape "ThingGroupList", :type "list"})

(clojure.core/defn- ser-payload-field [input] #:http.request.field{:value input, :shape "PayloadField"})

(clojure.core/defn- ser-authorizer-function-arn [input] #:http.request.field{:value input, :shape "AuthorizerFunctionArn"})

(clojure.core/defn- ser-firehose-separator [input] #:http.request.field{:value input, :shape "FirehoseSeparator"})

(clojure.core/defn- ser-job-id [input] #:http.request.field{:value input, :shape "JobId"})

(clojure.core/defn- req-start-on-demand-audit-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-target-audit-check-names (input :target-check-names)) #:http.request.field{:name "targetCheckNames", :shape "TargetAuditCheckNames"})]}))

(clojure.core/defn- req-accept-certificate-transfer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"}))))

(clojure.core/defn- req-delete-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-update-dynamic-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})], :body [(clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"})) (clojure.core/contains? input :index-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName"})) (clojure.core/contains? input :query-string) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-string (input :query-string)) #:http.request.field{:name "queryString", :shape "QueryString"})) (clojure.core/contains? input :query-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-version (input :query-version)) #:http.request.field{:name "queryVersion", :shape "QueryVersion"}))))

(clojure.core/defn- req-list-violation-events-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-timestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "Timestamp", :location "querystring", :location-name "startTime"}) (clojure.core/into (ser-timestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "Timestamp", :location "querystring", :location-name "endTime"})]} (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "querystring", :location-name "thingName"})) (clojure.core/contains? input :security-profile-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "querystring", :location-name "securityProfileName"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-authorizers-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-status (input :status)) #:http.request.field{:name "status", :shape "AuthorizerStatus", :location "querystring", :location-name "status"}))))

(clojure.core/defn- req-delete-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-deprecate-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]} (clojure.core/contains? input :undo-deprecate) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-undo-deprecate (input :undo-deprecate)) #:http.request.field{:name "undoDeprecate", :shape "UndoDeprecate"}))))

(clojure.core/defn- req-detach-principal-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-iot-principal"})]}))

(clojure.core/defn- req-list-things-in-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-test-invoke-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})], :body [(clojure.core/into (ser-token (input :token)) #:http.request.field{:name "token", :shape "Token"}) (clojure.core/into (ser-token-signature (input :token-signature)) #:http.request.field{:name "tokenSignature", :shape "TokenSignature"})]}))

(clojure.core/defn- req-register-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-certificate-pem (input :certificate-pem)) #:http.request.field{:name "certificatePem", :shape "CertificatePem"})]} (clojure.core/contains? input :ca-certificate-pem) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-pem (input :ca-certificate-pem)) #:http.request.field{:name "caCertificatePem", :shape "CertificatePem"})) (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active-flag (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActiveFlag", :deprecated true, :location "querystring", :location-name "setAsActive"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-certificate-status (input :status)) #:http.request.field{:name "status", :shape "CertificateStatus"}))))

(clojure.core/defn- req-create-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName"})) (clojure.core/contains? input :attribute-payload) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-payload (input :attribute-payload)) #:http.request.field{:name "attributePayload", :shape "AttributePayload"})) (clojure.core/contains? input :billing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName"}))))

(clojure.core/defn- req-list-ota-updates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :ota-update-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ota-update-status (input :ota-update-status)) #:http.request.field{:name "otaUpdateStatus", :shape "OTAUpdateStatus", :location "querystring", :location-name "otaUpdateStatus"}))))

(clojure.core/defn- req-transfer-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})], :querystring [(clojure.core/into (ser-aws-account-id (input :target-aws-account)) #:http.request.field{:name "targetAwsAccount", :shape "AwsAccountId", :location "querystring", :location-name "targetAwsAccount"})]} (clojure.core/contains? input :transfer-message) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :transfer-message)) #:http.request.field{:name "transferMessage", :shape "Message"}))))

(clojure.core/defn- req-update-event-configurations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :event-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-configurations (input :event-configurations)) #:http.request.field{:name "eventConfigurations", :shape "EventConfigurations"}))))

(clojure.core/defn- req-update-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})], :querystring [(clojure.core/into (ser-certificate-status (input :new-status)) #:http.request.field{:name "newStatus", :shape "CertificateStatus", :location "querystring", :location-name "newStatus"})]}))

(clojure.core/defn- req-list-billing-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :name-prefix-filter) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :name-prefix-filter)) #:http.request.field{:name "namePrefixFilter", :shape "BillingGroupName", :location "querystring", :location-name "namePrefixFilter"}))))

(clojure.core/defn- req-get-v-2-logging-options-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-create-keys-and-certificate-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"}))))

(clojure.core/defn- req-update-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]} (clojure.core/contains? input :new-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ca-certificate-status (input :new-status)) #:http.request.field{:name "newStatus", :shape "CACertificateStatus", :location "querystring", :location-name "newStatus"})) (clojure.core/contains? input :new-auto-registration-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-auto-registration-status (input :new-auto-registration-status)) #:http.request.field{:name "newAutoRegistrationStatus", :shape "AutoRegistrationStatus", :location "querystring", :location-name "newAutoRegistrationStatus"})) (clojure.core/contains? input :registration-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registration-config (input :registration-config)) #:http.request.field{:name "registrationConfig", :shape "RegistrationConfig"})) (clojure.core/contains? input :remove-auto-registration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-remove-auto-registration (input :remove-auto-registration)) #:http.request.field{:name "removeAutoRegistration", :shape "RemoveAutoRegistration"}))))

(clojure.core/defn- req-search-index-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-query-string (input :query-string)) #:http.request.field{:name "queryString", :shape "QueryString"})]} (clojure.core/contains? input :index-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "QueryMaxResults"})) (clojure.core/contains? input :query-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-version (input :query-version)) #:http.request.field{:name "queryVersion", :shape "QueryVersion"}))))

(clojure.core/defn- req-describe-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]}))

(clojure.core/defn- req-list-topic-rules-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :topic) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-topic (input :topic)) #:http.request.field{:name "topic", :shape "Topic", :location "querystring", :location-name "topic"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ge-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "GEMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :rule-disabled) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-is-disabled (input :rule-disabled)) #:http.request.field{:name "ruleDisabled", :shape "IsDisabled", :location "querystring", :location-name "ruleDisabled"}))))

(clojure.core/defn- req-list-outgoing-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-list-principal-policies-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-iot-principal"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-set-default-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"}) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId", :location "uri", :location-name "policyVersionId"})]}))

(clojure.core/defn- req-describe-default-authorizer-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-enable-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-create-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})], :body [(clojure.core/into (ser-stream-files (input :files)) #:http.request.field{:name "files", :shape "StreamFiles"}) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-description (input :description)) #:http.request.field{:name "description", :shape "StreamDescription"}))))

(clojure.core/defn- req-reject-certificate-transfer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]} (clojure.core/contains? input :reject-reason) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :reject-reason)) #:http.request.field{:name "rejectReason", :shape "Message"}))))

(clojure.core/defn- req-list-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-describe-audit-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-audit-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "AuditTaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-describe-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]}))

(clojure.core/defn- req-list-jobs-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-status (input :status)) #:http.request.field{:name "status", :shape "JobStatus", :location "querystring", :location-name "status"})) (clojure.core/contains? input :target-selection) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-selection (input :target-selection)) #:http.request.field{:name "targetSelection", :shape "TargetSelection", :location "querystring", :location-name "targetSelection"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-laser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "LaserMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :thing-group-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "querystring", :location-name "thingGroupName"})) (clojure.core/contains? input :thing-group-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-id (input :thing-group-id)) #:http.request.field{:name "thingGroupId", :shape "ThingGroupId", :location "querystring", :location-name "thingGroupId"}))))

(clojure.core/defn- req-list-tags-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-resource-arn (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "ResourceArn", :location "querystring", :location-name "resourceArn"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-attach-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-target (input :target)) #:http.request.field{:name "target", :shape "PolicyTarget"})]}))

(clojure.core/defn- req-describe-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]}))

(clojure.core/defn- req-delete-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-create-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :parent-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :parent-group-name)) #:http.request.field{:name "parentGroupName", :shape "ThingGroupName"})) (clojure.core/contains? input :thing-group-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-describe-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]}))

(clojure.core/defn- req-update-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})], :body [(clojure.core/into (ser-billing-group-properties (input :billing-group-properties)) #:http.request.field{:name "billingGroupProperties", :shape "BillingGroupProperties"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"}))))

(clojure.core/defn- req-describe-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]}))

(clojure.core/defn- req-set-v-2-logging-options-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "AwsArn"})) (clojure.core/contains? input :default-log-level) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-level (input :default-log-level)) #:http.request.field{:name "defaultLogLevel", :shape "LogLevel"})) (clojure.core/contains? input :disable-all-logs) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-disable-all-logs (input :disable-all-logs)) #:http.request.field{:name "disableAllLogs", :shape "DisableAllLogs"}))))

(clojure.core/defn- req-list-thing-types-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "querystring", :location-name "thingTypeName"}))))

(clojure.core/defn- req-delete-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-create-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})], :body [(clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]} (clojure.core/contains? input :credential-duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-credential-duration-seconds (input :credential-duration-seconds)) #:http.request.field{:name "credentialDurationSeconds", :shape "CredentialDurationSeconds"}))))

(clojure.core/defn- req-update-indexing-configuration-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-indexing-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-indexing-configuration (input :thing-indexing-configuration)) #:http.request.field{:name "thingIndexingConfiguration", :shape "ThingIndexingConfiguration"})) (clojure.core/contains? input :thing-group-indexing-configuration) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-indexing-configuration (input :thing-group-indexing-configuration)) #:http.request.field{:name "thingGroupIndexingConfiguration", :shape "ThingGroupIndexingConfiguration"}))))

(clojure.core/defn- req-update-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-description (input :description)) #:http.request.field{:name "description", :shape "StreamDescription"})) (clojure.core/contains? input :files) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-stream-files (input :files)) #:http.request.field{:name "files", :shape "StreamFiles"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"}))))

(clojure.core/defn- req-detach-thing-principal-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-principal"})]}))

(clojure.core/defn- req-list-indices-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "QueryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-thing-groups-for-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-attach-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})], :querystring [(clojure.core/into (ser-security-profile-target-arn (input :security-profile-target-arn)) #:http.request.field{:name "securityProfileTargetArn", :shape "SecurityProfileTargetArn", :location "querystring", :location-name "securityProfileTargetArn"})]}))

(clojure.core/defn- req-cancel-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :reason-code) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-reason-code (input :reason-code)) #:http.request.field{:name "reasonCode", :shape "ReasonCode"})) (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "comment", :shape "Comment"})) (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"}))))

(clojure.core/defn- req-create-certificate-from-csr-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-certificate-signing-request (input :certificate-signing-request)) #:http.request.field{:name "certificateSigningRequest", :shape "CertificateSigningRequest"})]} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"}))))

(clojure.core/defn- req-create-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :security-profile-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-description (input :security-profile-description)) #:http.request.field{:name "securityProfileDescription", :shape "SecurityProfileDescription"})) (clojure.core/contains? input :behaviors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behaviors (input :behaviors)) #:http.request.field{:name "behaviors", :shape "Behaviors"})) (clojure.core/contains? input :alert-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-alert-targets (input :alert-targets)) #:http.request.field{:name "alertTargets", :shape "AlertTargets"})) (clojure.core/contains? input :additional-metrics-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-additional-metrics-to-retain-list (input :additional-metrics-to-retain)) #:http.request.field{:name "additionalMetricsToRetain", :shape "AdditionalMetricsToRetainList"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-delete-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-list-active-violations-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "querystring", :location-name "thingName"})) (clojure.core/contains? input :security-profile-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "querystring", :location-name "securityProfileName"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-cancel-job-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"}) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"})) (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-expected-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "ExpectedVersion"})) (clojure.core/contains? input :status-details) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-details-map (input :status-details)) #:http.request.field{:name "statusDetails", :shape "DetailsMap"}))))

(clojure.core/defn- req-list-thing-principals-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]}))

(clojure.core/defn- req-describe-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})]}))

(clojure.core/defn- req-delete-dynamic-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"}))))

(clojure.core/defn- req-delete-registration-code-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-delete-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]}))

(clojure.core/defn- req-describe-index-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName", :location "uri", :location-name "indexName"})]}))

(clojure.core/defn- req-get-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-create-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-document (input :policy-document)) #:http.request.field{:name "policyDocument", :shape "PolicyDocument"})]}))

(clojure.core/defn- req-attach-principal-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-iot-principal"})]}))

(clojure.core/defn- req-create-dynamic-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})], :body [(clojure.core/into (ser-query-string (input :query-string)) #:http.request.field{:name "queryString", :shape "QueryString"})]} (clojure.core/contains? input :thing-group-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})) (clojure.core/contains? input :index-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-index-name (input :index-name)) #:http.request.field{:name "indexName", :shape "IndexName"})) (clojure.core/contains? input :query-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-query-version (input :query-version)) #:http.request.field{:name "queryVersion", :shape "QueryVersion"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-list-scheduled-audits-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-delete-ota-update-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-ota-update-id (input :ota-update-id)) #:http.request.field{:name "otaUpdateId", :shape "OTAUpdateId", :location "uri", :location-name "otaUpdateId"})]} (clojure.core/contains? input :delete-stream) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-stream (input :delete-stream)) #:http.request.field{:name "deleteStream", :shape "DeleteStream", :location "querystring", :location-name "deleteStream"})) (clojure.core/contains? input :force-delete-aws-job) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-delete-aws-job (input :force-delete-aws-job)) #:http.request.field{:name "forceDeleteAWSJob", :shape "ForceDeleteAWSJob", :location "querystring", :location-name "forceDeleteAWSJob"}))))

(clojure.core/defn- req-list-thing-registration-tasks-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-status (input :status)) #:http.request.field{:name "status", :shape "Status", :location "querystring", :location-name "status"}))))

(clojure.core/defn- req-delete-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})]}))

(clojure.core/defn- req-list-security-profiles-for-target-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-security-profile-target-arn (input :security-profile-target-arn)) #:http.request.field{:name "securityProfileTargetArn", :shape "SecurityProfileTargetArn", :location "querystring", :location-name "securityProfileTargetArn"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive (input :recursive)) #:http.request.field{:name "recursive", :shape "Recursive", :location "querystring", :location-name "recursive"}))))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-arn (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "ResourceArn"}) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})]}))

(clojure.core/defn- req-register-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-template-body (input :template-body)) #:http.request.field{:name "templateBody", :shape "TemplateBody"})]} (clojure.core/contains? input :parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-parameters (input :parameters)) #:http.request.field{:name "parameters", :shape "Parameters"}))))

(clojure.core/defn- req-list-targets-for-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"}))))

(clojure.core/defn- req-list-streams-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-stop-thing-registration-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "TaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-list-audit-findings-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :task-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "AuditTaskId"})) (clojure.core/contains? input :check-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-check-name (input :check-name)) #:http.request.field{:name "checkName", :shape "AuditCheckName"})) (clojure.core/contains? input :resource-identifier) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-resource-identifier (input :resource-identifier)) #:http.request.field{:name "resourceIdentifier", :shape "ResourceIdentifier"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "Timestamp"})) (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "Timestamp"}))))

(clojure.core/defn- req-list-role-aliases-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-describe-job-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"}) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :execution-number) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-execution-number (input :execution-number)) #:http.request.field{:name "executionNumber", :shape "ExecutionNumber", :location "querystring", :location-name "executionNumber"}))))

(clojure.core/defn- req-describe-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]}))

(clojure.core/defn- req-create-ota-update-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-ota-update-id (input :ota-update-id)) #:http.request.field{:name "otaUpdateId", :shape "OTAUpdateId", :location "uri", :location-name "otaUpdateId"})], :body [(clojure.core/into (ser-targets (input :targets)) #:http.request.field{:name "targets", :shape "Targets"}) (clojure.core/into (ser-ota-update-files (input :files)) #:http.request.field{:name "files", :shape "OTAUpdateFiles"}) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ota-update-description (input :description)) #:http.request.field{:name "description", :shape "OTAUpdateDescription"})) (clojure.core/contains? input :target-selection) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-selection (input :target-selection)) #:http.request.field{:name "targetSelection", :shape "TargetSelection"})) (clojure.core/contains? input :aws-job-executions-rollout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-aws-job-executions-rollout-config (input :aws-job-executions-rollout-config)) #:http.request.field{:name "awsJobExecutionsRolloutConfig", :shape "AwsJobExecutionsRolloutConfig"})) (clojure.core/contains? input :additional-parameters) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-additional-parameter-map (input :additional-parameters)) #:http.request.field{:name "additionalParameters", :shape "AdditionalParameterMap"}))))

(clojure.core/defn- req-delete-v-2-logging-level-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-log-target-type (input :target-type)) #:http.request.field{:name "targetType", :shape "LogTargetType", :location "querystring", :location-name "targetType"}) (clojure.core/into (ser-log-target-name (input :target-name)) #:http.request.field{:name "targetName", :shape "LogTargetName", :location "querystring", :location-name "targetName"})]}))

(clojure.core/defn- req-list-ca-certificates-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-delete-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]} (clojure.core/contains? input :force-delete) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-delete (input :force-delete)) #:http.request.field{:name "forceDelete", :shape "ForceDelete", :location "querystring", :location-name "forceDelete"}))))

(clojure.core/defn- req-cancel-certificate-transfer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "certificateId"})]}))

(clojure.core/defn- req-get-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]}))

(clojure.core/defn- req-create-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})], :body [(clojure.core/into (ser-job-targets (input :targets)) #:http.request.field{:name "targets", :shape "JobTargets"})]} (clojure.core/contains? input :target-selection) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-selection (input :target-selection)) #:http.request.field{:name "targetSelection", :shape "TargetSelection"})) (clojure.core/contains? input :timeout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-config (input :timeout-config)) #:http.request.field{:name "timeoutConfig", :shape "TimeoutConfig"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"})) (clojure.core/contains? input :document) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-document (input :document)) #:http.request.field{:name "document", :shape "JobDocument"})) (clojure.core/contains? input :abort-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-abort-config (input :abort-config)) #:http.request.field{:name "abortConfig", :shape "AbortConfig"})) (clojure.core/contains? input :document-source) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-document-source (input :document-source)) #:http.request.field{:name "documentSource", :shape "JobDocumentSource"})) (clojure.core/contains? input :presigned-url-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-presigned-url-config (input :presigned-url-config)) #:http.request.field{:name "presignedUrlConfig", :shape "PresignedUrlConfig"})) (clojure.core/contains? input :job-executions-rollout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-executions-rollout-config (input :job-executions-rollout-config)) #:http.request.field{:name "jobExecutionsRolloutConfig", :shape "JobExecutionsRolloutConfig"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-description (input :description)) #:http.request.field{:name "description", :shape "JobDescription"}))))

(clojure.core/defn- req-get-logging-options-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-describe-event-configurations-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-describe-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})]}))

(clojure.core/defn- req-delete-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]}))

(clojure.core/defn- req-delete-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]}))

(clojure.core/defn- req-delete-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"}) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId", :location "uri", :location-name "policyVersionId"})]}))

(clojure.core/defn- req-list-attached-policies-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-target (input :target)) #:http.request.field{:name "target", :shape "PolicyTarget", :location "uri", :location-name "target"})]} (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive (input :recursive)) #:http.request.field{:name "recursive", :shape "Recursive", :location "querystring", :location-name "recursive"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"}))))

(clojure.core/defn- req-set-default-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName"})]}))

(clojure.core/defn- req-describe-account-audit-configuration-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-remove-thing-from-thing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName"})) (clojure.core/contains? input :thing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-arn (input :thing-group-arn)) #:http.request.field{:name "thingGroupArn", :shape "ThingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"}))))

(clojure.core/defn- req-list-thing-groups-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :parent-group) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :parent-group)) #:http.request.field{:name "parentGroup", :shape "ThingGroupName", :location "querystring", :location-name "parentGroup"})) (clojure.core/contains? input :name-prefix-filter) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :name-prefix-filter)) #:http.request.field{:name "namePrefixFilter", :shape "ThingGroupName", :location "querystring", :location-name "namePrefixFilter"})) (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive-without-default (input :recursive)) #:http.request.field{:name "recursive", :shape "RecursiveWithoutDefault", :location "querystring", :location-name "recursive"}))))

(clojure.core/defn- req-remove-thing-from-billing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :billing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName"})) (clojure.core/contains? input :billing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-arn (input :billing-group-arn)) #:http.request.field{:name "billingGroupArn", :shape "BillingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"}))))

(clojure.core/defn- req-attach-thing-principal-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})], :header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-principal"})]}))

(clojure.core/defn- req-delete-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]}))

(clojure.core/defn- req-list-policy-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})]}))

(clojure.core/defn- req-get-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"}) (clojure.core/into (ser-policy-version-id (input :policy-version-id)) #:http.request.field{:name "policyVersionId", :shape "PolicyVersionId", :location "uri", :location-name "policyVersionId"})]}))

(clojure.core/defn- req-list-principal-things-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal", :location "header", :location-name "x-amzn-principal"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-endpoint-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :endpoint-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-type (input :endpoint-type)) #:http.request.field{:name "endpointType", :shape "EndpointType", :location "querystring", :location-name "endpointType"}))))

(clojure.core/defn- req-list-targets-for-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-certificates-by-ca-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :ca-certificate-id)) #:http.request.field{:name "caCertificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-update-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})]} (clojure.core/contains? input :delete-behaviors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-behaviors (input :delete-behaviors)) #:http.request.field{:name "deleteBehaviors", :shape "DeleteBehaviors"})) (clojure.core/contains? input :additional-metrics-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-additional-metrics-to-retain-list (input :additional-metrics-to-retain)) #:http.request.field{:name "additionalMetricsToRetain", :shape "AdditionalMetricsToRetainList"})) (clojure.core/contains? input :behaviors) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-behaviors (input :behaviors)) #:http.request.field{:name "behaviors", :shape "Behaviors"})) (clojure.core/contains? input :security-profile-description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-security-profile-description (input :security-profile-description)) #:http.request.field{:name "securityProfileDescription", :shape "SecurityProfileDescription"})) (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion", :location "querystring", :location-name "expectedVersion"})) (clojure.core/contains? input :delete-alert-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-alert-targets (input :delete-alert-targets)) #:http.request.field{:name "deleteAlertTargets", :shape "DeleteAlertTargets"})) (clojure.core/contains? input :delete-additional-metrics-to-retain) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-additional-metrics-to-retain (input :delete-additional-metrics-to-retain)) #:http.request.field{:name "deleteAdditionalMetricsToRetain", :shape "DeleteAdditionalMetricsToRetain"})) (clojure.core/contains? input :alert-targets) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-alert-targets (input :alert-targets)) #:http.request.field{:name "alertTargets", :shape "AlertTargets"}))))

(clojure.core/defn- req-delete-account-audit-configuration-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :delete-scheduled-audits) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-delete-scheduled-audits (input :delete-scheduled-audits)) #:http.request.field{:name "deleteScheduledAudits", :shape "DeleteScheduledAudits", :location "querystring", :location-name "deleteScheduledAudits"}))))

(clojure.core/defn- req-get-ota-update-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-ota-update-id (input :ota-update-id)) #:http.request.field{:name "otaUpdateId", :shape "OTAUpdateId", :location "uri", :location-name "otaUpdateId"})]}))

(clojure.core/defn- req-clear-default-authorizer-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-register-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-certificate-pem (input :ca-certificate)) #:http.request.field{:name "caCertificate", :shape "CertificatePem"}) (clojure.core/into (ser-certificate-pem (input :verification-certificate)) #:http.request.field{:name "verificationCertificate", :shape "CertificatePem"})]} (clojure.core/contains? input :set-as-active) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-active (input :set-as-active)) #:http.request.field{:name "setAsActive", :shape "SetAsActive", :location "querystring", :location-name "setAsActive"})) (clojure.core/contains? input :allow-auto-registration) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-allow-auto-registration (input :allow-auto-registration)) #:http.request.field{:name "allowAutoRegistration", :shape "AllowAutoRegistration", :location "querystring", :location-name "allowAutoRegistration"})) (clojure.core/contains? input :registration-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registration-config (input :registration-config)) #:http.request.field{:name "registrationConfig", :shape "RegistrationConfig"}))))

(clojure.core/defn- req-list-policies-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-describe-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]}))

(clojure.core/defn- req-create-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})], :body [(clojure.core/into (ser-authorizer-function-arn (input :authorizer-function-arn)) #:http.request.field{:name "authorizerFunctionArn", :shape "AuthorizerFunctionArn"}) (clojure.core/into (ser-token-key-name (input :token-key-name)) #:http.request.field{:name "tokenKeyName", :shape "TokenKeyName"}) (clojure.core/into (ser-public-key-map (input :token-signing-public-keys)) #:http.request.field{:name "tokenSigningPublicKeys", :shape "PublicKeyMap"})]} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-status (input :status)) #:http.request.field{:name "status", :shape "AuthorizerStatus"}))))

(clojure.core/defn- req-set-v-2-logging-level-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-log-target (input :log-target)) #:http.request.field{:name "logTarget", :shape "LogTarget"}) (clojure.core/into (ser-log-level (input :log-level)) #:http.request.field{:name "logLevel", :shape "LogLevel"})]}))

(clojure.core/defn- req-get-job-document-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]}))

(clojure.core/defn- req-describe-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-stream-id (input :stream-id)) #:http.request.field{:name "streamId", :shape "StreamId", :location "uri", :location-name "streamId"})]}))

(clojure.core/defn- req-disable-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})]}))

(clojure.core/defn- req-detach-security-profile-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-security-profile-name (input :security-profile-name)) #:http.request.field{:name "securityProfileName", :shape "SecurityProfileName", :location "uri", :location-name "securityProfileName"})], :querystring [(clojure.core/into (ser-security-profile-target-arn (input :security-profile-target-arn)) #:http.request.field{:name "securityProfileTargetArn", :shape "SecurityProfileTargetArn", :location "querystring", :location-name "securityProfileTargetArn"})]}))

(clojure.core/defn- req-list-job-executions-for-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-execution-status (input :status)) #:http.request.field{:name "status", :shape "JobExecutionStatus", :location "querystring", :location-name "status"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-laser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "LaserMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-update-thing-groups-for-thing-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-groups-to-add) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-list (input :thing-groups-to-add)) #:http.request.field{:name "thingGroupsToAdd", :shape "ThingGroupList"})) (clojure.core/contains? input :thing-groups-to-remove) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-list (input :thing-groups-to-remove)) #:http.request.field{:name "thingGroupsToRemove", :shape "ThingGroupList"})) (clojure.core/contains? input :override-dynamic-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-override-dynamic-groups (input :override-dynamic-groups)) #:http.request.field{:name "overrideDynamicGroups", :shape "OverrideDynamicGroups"}))))

(clojure.core/defn- req-create-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-audit-frequency (input :frequency)) #:http.request.field{:name "frequency", :shape "AuditFrequency"}) (clojure.core/into (ser-target-audit-check-names (input :target-check-names)) #:http.request.field{:name "targetCheckNames", :shape "TargetAuditCheckNames"})], :uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]} (clojure.core/contains? input :day-of-month) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-month (input :day-of-month)) #:http.request.field{:name "dayOfMonth", :shape "DayOfMonth"})) (clojure.core/contains? input :day-of-week) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-week (input :day-of-week)) #:http.request.field{:name "dayOfWeek", :shape "DayOfWeek"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-update-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName"})) (clojure.core/contains? input :attribute-payload) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-payload (input :attribute-payload)) #:http.request.field{:name "attributePayload", :shape "AttributePayload"})) (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"})) (clojure.core/contains? input :remove-thing-type) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-remove-thing-type (input :remove-thing-type)) #:http.request.field{:name "removeThingType", :shape "RemoveThingType"}))))

(clojure.core/defn- req-describe-ca-certificate-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-certificate-id (input :certificate-id)) #:http.request.field{:name "certificateId", :shape "CertificateId", :location "uri", :location-name "caCertificateId"})]}))

(clojure.core/defn- req-test-authorization-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-auth-infos (input :auth-infos)) #:http.request.field{:name "authInfos", :shape "AuthInfos"})]} (clojure.core/contains? input :principal) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal"})) (clojure.core/contains? input :cognito-identity-pool-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cognito-identity-pool-id (input :cognito-identity-pool-id)) #:http.request.field{:name "cognitoIdentityPoolId", :shape "CognitoIdentityPoolId"})) (clojure.core/contains? input :client-id) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-client-id (input :client-id)) #:http.request.field{:name "clientId", :shape "ClientId", :location "querystring", :location-name "clientId"})) (clojure.core/contains? input :policy-names-to-add) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-names (input :policy-names-to-add)) #:http.request.field{:name "policyNamesToAdd", :shape "PolicyNames"})) (clojure.core/contains? input :policy-names-to-skip) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-policy-names (input :policy-names-to-skip)) #:http.request.field{:name "policyNamesToSkip", :shape "PolicyNames"}))))

(clojure.core/defn- req-list-policy-principals-request [input] (clojure.core/cond-> #:http.request.configuration{:header [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "header", :location-name "x-amzn-iot-policy"})]} (clojure.core/contains? input :marker) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-marker (input :marker)) #:http.request.field{:name "marker", :shape "Marker", :location "querystring", :location-name "marker"})) (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-page-size (input :page-size)) #:http.request.field{:name "pageSize", :shape "PageSize", :location "querystring", :location-name "pageSize"})) (clojure.core/contains? input :ascending-order) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-ascending-order (input :ascending-order)) #:http.request.field{:name "ascendingOrder", :shape "AscendingOrder", :location "querystring", :location-name "isAscendingOrder"}))))

(clojure.core/defn- req-validate-security-profile-behaviors-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-behaviors (input :behaviors)) #:http.request.field{:name "behaviors", :shape "Behaviors"})]}))

(clojure.core/defn- req-detach-policy-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-target (input :target)) #:http.request.field{:name "target", :shape "PolicyTarget"})]}))

(clojure.core/defn- req-add-thing-to-thing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :thing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName"})) (clojure.core/contains? input :thing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-group-arn (input :thing-group-arn)) #:http.request.field{:name "thingGroupArn", :shape "ThingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"})) (clojure.core/contains? input :override-dynamic-groups) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-override-dynamic-groups (input :override-dynamic-groups)) #:http.request.field{:name "overrideDynamicGroups", :shape "OverrideDynamicGroups"}))))

(clojure.core/defn- req-update-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-description (input :description)) #:http.request.field{:name "description", :shape "JobDescription"})) (clojure.core/contains? input :presigned-url-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-presigned-url-config (input :presigned-url-config)) #:http.request.field{:name "presignedUrlConfig", :shape "PresignedUrlConfig"})) (clojure.core/contains? input :job-executions-rollout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-executions-rollout-config (input :job-executions-rollout-config)) #:http.request.field{:name "jobExecutionsRolloutConfig", :shape "JobExecutionsRolloutConfig"})) (clojure.core/contains? input :abort-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-abort-config (input :abort-config)) #:http.request.field{:name "abortConfig", :shape "AbortConfig"})) (clojure.core/contains? input :timeout-config) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-timeout-config (input :timeout-config)) #:http.request.field{:name "timeoutConfig", :shape "TimeoutConfig"}))))

(clojure.core/defn- req-list-things-in-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})]} (clojure.core/contains? input :recursive) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recursive (input :recursive)) #:http.request.field{:name "recursive", :shape "Recursive", :location "querystring", :location-name "recursive"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-delete-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"}))))

(clojure.core/defn- req-cancel-audit-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-audit-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "AuditTaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-list-audit-tasks-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-timestamp (input :start-time)) #:http.request.field{:name "startTime", :shape "Timestamp", :location "querystring", :location-name "startTime"}) (clojure.core/into (ser-timestamp (input :end-time)) #:http.request.field{:name "endTime", :shape "Timestamp", :location "querystring", :location-name "endTime"})]} (clojure.core/contains? input :task-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-task-type (input :task-type)) #:http.request.field{:name "taskType", :shape "AuditTaskType", :location "querystring", :location-name "taskType"})) (clojure.core/contains? input :task-status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-task-status (input :task-status)) #:http.request.field{:name "taskStatus", :shape "AuditTaskStatus", :location "querystring", :location-name "taskStatus"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-describe-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]}))

(clojure.core/defn- req-update-thing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-group-name (input :thing-group-name)) #:http.request.field{:name "thingGroupName", :shape "ThingGroupName", :location "uri", :location-name "thingGroupName"})], :body [(clojure.core/into (ser-thing-group-properties (input :thing-group-properties)) #:http.request.field{:name "thingGroupProperties", :shape "ThingGroupProperties"})]} (clojure.core/contains? input :expected-version) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-optional-version (input :expected-version)) #:http.request.field{:name "expectedVersion", :shape "OptionalVersion"}))))

(clojure.core/defn- req-add-thing-to-billing-group-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :billing-group-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName"})) (clojure.core/contains? input :billing-group-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-arn (input :billing-group-arn)) #:http.request.field{:name "billingGroupArn", :shape "BillingGroupArn"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName"})) (clojure.core/contains? input :thing-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-arn (input :thing-arn)) #:http.request.field{:name "thingArn", :shape "ThingArn"}))))

(clojure.core/defn- req-start-thing-registration-task-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-template-body (input :template-body)) #:http.request.field{:name "templateBody", :shape "TemplateBody"}) (clojure.core/into (ser-registry-s-3-bucket-name (input :input-file-bucket)) #:http.request.field{:name "inputFileBucket", :shape "RegistryS3BucketName"}) (clojure.core/into (ser-registry-s-3-key-name (input :input-file-key)) #:http.request.field{:name "inputFileKey", :shape "RegistryS3KeyName"}) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})]}))

(clojure.core/defn- req-list-security-profiles-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-set-logging-options-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-logging-options-payload (input :logging-options-payload)) #:http.request.field{:name "loggingOptionsPayload", :shape "LoggingOptionsPayload"})]}))

(clojure.core/defn- req-list-thing-registration-task-reports-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "TaskId", :location "uri", :location-name "taskId"})], :querystring [(clojure.core/into (ser-report-type (input :report-type)) #:http.request.field{:name "reportType", :shape "ReportType", :location "querystring", :location-name "reportType"})]} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-list-v-2-logging-levels-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :target-type) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-log-target-type (input :target-type)) #:http.request.field{:name "targetType", :shape "LogTargetType", :location "querystring", :location-name "targetType"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-skyfall-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "SkyfallMaxResults", :location "querystring", :location-name "maxResults"}))))

(clojure.core/defn- req-create-thing-type-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "uri", :location-name "thingTypeName"})]} (clojure.core/contains? input :thing-type-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-properties (input :thing-type-properties)) #:http.request.field{:name "thingTypeProperties", :shape "ThingTypeProperties"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-create-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})], :body [(clojure.core/into (ser-topic-rule-payload (input :topic-rule-payload)) #:http.request.field{:name "topicRulePayload", :shape "TopicRulePayload"})]} (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/header] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :tags)) #:http.request.field{:name "tags", :shape "String", :location "header", :location-name "x-amz-tagging"}))))

(clojure.core/defn- req-delete-job-execution-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"}) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"}) (clojure.core/into (ser-execution-number (input :execution-number)) #:http.request.field{:name "executionNumber", :shape "ExecutionNumber", :location "uri", :location-name "executionNumber"})]} (clojure.core/contains? input :force) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-force-flag (input :force)) #:http.request.field{:name "force", :shape "ForceFlag", :location "querystring", :location-name "force"}))))

(clojure.core/defn- req-update-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})]} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :credential-duration-seconds) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-credential-duration-seconds (input :credential-duration-seconds)) #:http.request.field{:name "credentialDurationSeconds", :shape "CredentialDurationSeconds"}))))

(clojure.core/defn- req-delete-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})]}))

(clojure.core/defn- req-list-things-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-registry-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "RegistryMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :attribute-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-name (input :attribute-name)) #:http.request.field{:name "attributeName", :shape "AttributeName", :location "querystring", :location-name "attributeName"})) (clojure.core/contains? input :attribute-value) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-value (input :attribute-value)) #:http.request.field{:name "attributeValue", :shape "AttributeValue", :location "querystring", :location-name "attributeValue"})) (clojure.core/contains? input :thing-type-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-type-name (input :thing-type-name)) #:http.request.field{:name "thingTypeName", :shape "ThingTypeName", :location "querystring", :location-name "thingTypeName"}))))

(clojure.core/defn- req-update-authorizer-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-authorizer-name (input :authorizer-name)) #:http.request.field{:name "authorizerName", :shape "AuthorizerName", :location "uri", :location-name "authorizerName"})]} (clojure.core/contains? input :authorizer-function-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-function-arn (input :authorizer-function-arn)) #:http.request.field{:name "authorizerFunctionArn", :shape "AuthorizerFunctionArn"})) (clojure.core/contains? input :token-key-name) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-token-key-name (input :token-key-name)) #:http.request.field{:name "tokenKeyName", :shape "TokenKeyName"})) (clojure.core/contains? input :token-signing-public-keys) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-public-key-map (input :token-signing-public-keys)) #:http.request.field{:name "tokenSigningPublicKeys", :shape "PublicKeyMap"})) (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-authorizer-status (input :status)) #:http.request.field{:name "status", :shape "AuthorizerStatus"}))))

(clojure.core/defn- req-describe-thing-registration-task-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-task-id (input :task-id)) #:http.request.field{:name "taskId", :shape "TaskId", :location "uri", :location-name "taskId"})]}))

(clojure.core/defn- req-get-indexing-configuration-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-list-job-executions-for-thing-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "uri", :location-name "thingName"})]} (clojure.core/contains? input :status) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-job-execution-status (input :status)) #:http.request.field{:name "status", :shape "JobExecutionStatus", :location "querystring", :location-name "status"})) (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-laser-max-results (input :max-results)) #:http.request.field{:name "maxResults", :shape "LaserMaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-next-token (input :next-token)) #:http.request.field{:name "nextToken", :shape "NextToken", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-replace-topic-rule-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-rule-name (input :rule-name)) #:http.request.field{:name "ruleName", :shape "RuleName", :location "uri", :location-name "ruleName"})], :body [(clojure.core/into (ser-topic-rule-payload (input :topic-rule-payload)) #:http.request.field{:name "topicRulePayload", :shape "TopicRulePayload"})]}))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-resource-arn (input :resource-arn)) #:http.request.field{:name "resourceArn", :shape "ResourceArn"}) (clojure.core/into (ser-tag-key-list (input :tag-keys)) #:http.request.field{:name "tagKeys", :shape "TagKeyList"})]}))

(clojure.core/defn- req-get-registration-code-request [input] (clojure.core/cond-> {}))

(clojure.core/defn- req-update-account-audit-configuration-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-role-arn (input :role-arn)) #:http.request.field{:name "roleArn", :shape "RoleArn"})) (clojure.core/contains? input :audit-notification-target-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-notification-target-configurations (input :audit-notification-target-configurations)) #:http.request.field{:name "auditNotificationTargetConfigurations", :shape "AuditNotificationTargetConfigurations"})) (clojure.core/contains? input :audit-check-configurations) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-check-configurations (input :audit-check-configurations)) #:http.request.field{:name "auditCheckConfigurations", :shape "AuditCheckConfigurations"}))))

(clojure.core/defn- req-create-policy-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-policy-name (input :policy-name)) #:http.request.field{:name "policyName", :shape "PolicyName", :location "uri", :location-name "policyName"})], :body [(clojure.core/into (ser-policy-document (input :policy-document)) #:http.request.field{:name "policyDocument", :shape "PolicyDocument"})]} (clojure.core/contains? input :set-as-default) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-as-default (input :set-as-default)) #:http.request.field{:name "setAsDefault", :shape "SetAsDefault", :location "querystring", :location-name "setAsDefault"}))))

(clojure.core/defn- req-delete-role-alias-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-role-alias (input :role-alias)) #:http.request.field{:name "roleAlias", :shape "RoleAlias", :location "uri", :location-name "roleAlias"})]}))

(clojure.core/defn- req-associate-targets-with-job-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-job-targets (input :targets)) #:http.request.field{:name "targets", :shape "JobTargets"})], :uri [(clojure.core/into (ser-job-id (input :job-id)) #:http.request.field{:name "jobId", :shape "JobId", :location "uri", :location-name "jobId"})]} (clojure.core/contains? input :comment) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-comment (input :comment)) #:http.request.field{:name "comment", :shape "Comment"}))))

(clojure.core/defn- req-create-billing-group-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-billing-group-name (input :billing-group-name)) #:http.request.field{:name "billingGroupName", :shape "BillingGroupName", :location "uri", :location-name "billingGroupName"})]} (clojure.core/contains? input :billing-group-properties) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-billing-group-properties (input :billing-group-properties)) #:http.request.field{:name "billingGroupProperties", :shape "BillingGroupProperties"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-tag-list (input :tags)) #:http.request.field{:name "tags", :shape "TagList"}))))

(clojure.core/defn- req-get-effective-policies-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :principal) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-principal (input :principal)) #:http.request.field{:name "principal", :shape "Principal"})) (clojure.core/contains? input :cognito-identity-pool-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-cognito-identity-pool-id (input :cognito-identity-pool-id)) #:http.request.field{:name "cognitoIdentityPoolId", :shape "CognitoIdentityPoolId"})) (clojure.core/contains? input :thing-name) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-thing-name (input :thing-name)) #:http.request.field{:name "thingName", :shape "ThingName", :location "querystring", :location-name "thingName"}))))

(clojure.core/defn- req-update-scheduled-audit-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-scheduled-audit-name (input :scheduled-audit-name)) #:http.request.field{:name "scheduledAuditName", :shape "ScheduledAuditName", :location "uri", :location-name "scheduledAuditName"})]} (clojure.core/contains? input :frequency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-audit-frequency (input :frequency)) #:http.request.field{:name "frequency", :shape "AuditFrequency"})) (clojure.core/contains? input :day-of-month) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-month (input :day-of-month)) #:http.request.field{:name "dayOfMonth", :shape "DayOfMonth"})) (clojure.core/contains? input :day-of-week) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-day-of-week (input :day-of-week)) #:http.request.field{:name "dayOfWeek", :shape "DayOfWeek"})) (clojure.core/contains? input :target-check-names) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-target-audit-check-names (input :target-check-names)) #:http.request.field{:name "targetCheckNames", :shape "TargetAuditCheckNames"}))))

(clojure.core/declare deser-audit-task-metadata-list)

(clojure.core/declare deser-audit-finding-severity)

(clojure.core/declare deser-stream-id)

(clojure.core/declare deser-billing-group-arn)

(clojure.core/declare deser-compliant-checks-count)

(clojure.core/declare deser-auto-registration-status)

(clojure.core/declare deser-security-profile-targets)

(clojure.core/declare deser-thing-indexing-mode)

(clojure.core/declare deser-canceled-checks-count)

(clojure.core/declare deser-billing-group-properties)

(clojure.core/declare deser-thing-group-description)

(clojure.core/declare deser-scheduled-audit-arn)

(clojure.core/declare deser-outgoing-certificates)

(clojure.core/declare deser-range-key-field)

(clojure.core/declare deser-thing-group-indexing-configuration)

(clojure.core/declare deser-security-profile-description)

(clojure.core/declare deser-thing-attribute-list)

(clojure.core/declare deser-thing-group-document-list)

(clojure.core/declare deser-ota-update-arn)

(clojure.core/declare deser-log-target-configurations)

(clojure.core/declare deser-in-progress-timeout-in-minutes)

(clojure.core/declare deser-thing-type-properties)

(clojure.core/declare deser-stream-name)

(clojure.core/declare deser-job-execution-summary-for-job)

(clojure.core/declare deser-code-signing)

(clojure.core/declare deser-dynamo-d-bv-2-action)

(clojure.core/declare deser-audit-notification-target-configurations)

(clojure.core/declare deser-statistical-threshold)

(clojure.core/declare deser-ota-update-summary)

(clojure.core/declare deser-minimum-number-of-executed-things)

(clojure.core/declare deser-cidr)

(clojure.core/declare deser-active-violations)

(clojure.core/declare deser-string-map)

(clojure.core/declare deser-platform)

(clojure.core/declare deser-stream-info)

(clojure.core/declare deser-private-key)

(clojure.core/declare deser-explicit-deny)

(clojure.core/declare deser-deprecation-date)

(clojure.core/declare deser-function-arn)

(clojure.core/declare deser-resource-logical-id)

(clojure.core/declare deser-topic-pattern)

(clojure.core/declare deser-removed-things)

(clojure.core/declare deser-signature-algorithm)

(clojure.core/declare deser-index-status)

(clojure.core/declare deser-query-version)

(clojure.core/declare deser-rule-name)

(clojure.core/declare deser-violation-event)

(clojure.core/declare deser-s-3-file-url-list)

(clojure.core/declare deser-non-compliant-resources-count)

(clojure.core/declare deser-job-status)

(clojure.core/declare deser-failed-things)

(clojure.core/declare deser-code-signing-certificate-chain)

(clojure.core/declare deser-comment)

(clojure.core/declare deser-missing-context-values)

(clojure.core/declare deser-day-of-week)

(clojure.core/declare deser-prefix)

(clojure.core/declare deser-message-id)

(clojure.core/declare deser-security-profile-target)

(clojure.core/declare deser-thing-type-description)

(clojure.core/declare deser-streams-summary)

(clojure.core/declare deser-thing-attribute)

(clojure.core/declare deser-abort-criteria)

(clojure.core/declare deser-validation-error)

(clojure.core/declare deser-index-names-list)

(clojure.core/declare deser-audit-task-type)

(clojure.core/declare deser-canned-access-control-list)

(clojure.core/declare deser-connectivity-timestamp)

(clojure.core/declare deser-thing-group-id)

(clojure.core/declare deser-duration-seconds)

(clojure.core/declare deser-thing-type-name)

(clojure.core/declare deser-violation-events)

(clojure.core/declare deser-iot-events-action)

(clojure.core/declare deser-execution-number)

(clojure.core/declare deser-input-name)

(clojure.core/declare deserresource-id)

(clojure.core/declare deser-additional-metrics-to-retain-list)

(clojure.core/declare deser-number-of-things)

(clojure.core/declare deser-non-compliant-resource)

(clojure.core/declare deser-key-value)

(clojure.core/declare deser-thing-group-arn)

(clojure.core/declare deser-attribute-name)

(clojure.core/declare deser-outgoing-certificate)

(clojure.core/declare deser-canceled-things)

(clojure.core/declare deser-last-modified-date)

(clojure.core/declare deser-log-level)

(clojure.core/declare deser-target-audit-check-names)

(clojure.core/declare deser-effective-policies)

(clojure.core/declare deser-policy-name)

(clojure.core/declare deser-ca-certificates)

(clojure.core/declare desererror-message)

(clojure.core/declare deser-action-list)

(clojure.core/declare deser-active-violation)

(clojure.core/declare deser-registration-config)

(clojure.core/declare deser-additional-parameter-map)

(clojure.core/declare deser-json-document)

(clojure.core/declare deser-expires-in-sec)

(clojure.core/declare deser-thing-arn)

(clojure.core/declare deser-template-body)

(clojure.core/declare deser-behavior)

(clojure.core/declare deser-index-name)

(clojure.core/declare deser-certificates)

(clojure.core/declare deser-thing-type-metadata)

(clojure.core/declare deser-certificate-name)

(clojure.core/declare deser-attribute-payload)

(clojure.core/declare deser-scheduled-audit-metadata-list)

(clojure.core/declare deser-inline-document)

(clojure.core/declare deser-state-value)

(clojure.core/declare deser-reason-for-non-compliance-code)

(clojure.core/declare deser-use-base-64)

(clojure.core/declare deser-abort-config)

(clojure.core/declare deser-certificate-path-on-device)

(clojure.core/declare deser-security-profile-target-arn)

(clojure.core/declare deser-day-of-month)

(clojure.core/declare deser-principal-arn)

(clojure.core/declare deser-max-job-executions-per-min)

(clojure.core/declare deser-ca-certificate-status)

(clojure.core/declare deser-role-arn)

(clojure.core/declare deser-target-arn)

(clojure.core/declare deser-security-profile-target-mappings)

(clojure.core/declare deser-abort-criteria-list)

(clojure.core/declare deser-disable-all-logs)

(clojure.core/declare deser-registry-s-3-key-name)

(clojure.core/declare deser-partition-key)

(clojure.core/declare deser-audit-check-details)

(clojure.core/declare deser-audit-details)

(clojure.core/declare deser-flag)

(clojure.core/declare deser-certificate-description)

(clojure.core/declare deser-principal-id)

(clojure.core/declare deser-marker)

(clojure.core/declare deser-index-schema)

(clojure.core/declare deser-tag-key)

(clojure.core/declare deser-ota-update-files)

(clojure.core/declare deser-thing-document-list)

(clojure.core/declare deser-start-signing-job-parameter)

(clojure.core/declare deser-destination)

(clojure.core/declare deser-task-id-list)

(clojure.core/declare deser-rule-arn)

(clojure.core/declare deser-count)

(clojure.core/declare deser-non-compliant-checks-count)

(clojure.core/declare deser-comparison-operator)

(clojure.core/declare deser-task-id)

(clojure.core/declare deser-thing-type-definition)

(clojure.core/declare deser-billing-group-id)

(clojure.core/declare deser-thing-name-list)

(clojure.core/declare deser-policy-targets)

(clojure.core/declare deser-forced)

(clojure.core/declare deser-resource-arns)

(clojure.core/declare deser-exponential-rollout-rate)

(clojure.core/declare deser-job-execution-summary)

(clojure.core/declare deser-elasticsearch-type)

(clojure.core/declare deser-waiting-for-data-collection-checks-count)

(clojure.core/declare deser-thing-group-name-list)

(clojure.core/declare deser-rate-increase-criteria)

(clojure.core/declare deser-thing-type-arn)

(clojure.core/declare deser-rejected-things)

(clojure.core/declare deser-alert-targets)

(clojure.core/declare deser-implicit-deny)

(clojure.core/declare deser-aws-arn)

(clojure.core/declare deser-stream-files)

(clojure.core/declare deser-key-name)

(clojure.core/declare deser-log-target-type)

(clojure.core/declare deser-enabled)

(clojure.core/declare deser-query-string)

(clojure.core/declare deser-status)

(clojure.core/declare deser-behaviors)

(clojure.core/declare deser-audit-findings)

(clojure.core/declare deser-auth-results)

(clojure.core/declare deser-policy-version)

(clojure.core/declare deser-event-type)

(clojure.core/declare deser-in-progress-checks-count)

(clojure.core/declare deser-role-alias)

(clojure.core/declare deser-log-target-configuration)

(clojure.core/declare deser-put-item-input)

(clojure.core/declare deser-succeeded-things)

(clojure.core/declare deser-log-target-name)

(clojure.core/declare deser-next-token)

(clojure.core/declare deser-behavior-metric)

(clojure.core/declare deser-ota-update-file)

(clojure.core/declare deser-range-key-value)

(clojure.core/declare deser-hash-key-value)

(clojure.core/declare deser-firehose-action)

(clojure.core/declare deser-role-alias-arn)

(clojure.core/declare deser-scheduled-audit-metadata)

(clojure.core/declare deser-consecutive-datapoints-to-alarm)

(clojure.core/declare deser-error-message)

(clojure.core/declare deser-total-checks-count)

(clojure.core/declare deser-security-profile-name)

(clojure.core/declare deser-timed-out-things)

(clojure.core/declare deser-thing-group-properties)

(clojure.core/declare deser-cidrs)

(clojure.core/declare deser-audit-task-metadata)

(clojure.core/declare deser-alert-target-type)

(clojure.core/declare deser-job-document)

(clojure.core/declare deser-audit-check-name)

(clojure.core/declare deser-key)

(clojure.core/declare deser-stream-description)

(clojure.core/declare deser-salesforce-token)

(clojure.core/declare deser-thing-group-metadata)

(clojure.core/declare deser-thing-group-indexing-mode)

(clojure.core/declare deser-target-selection)

(clojure.core/declare deser-attributes)

(clojure.core/declare deser-queue-url)

(clojure.core/declare deser-unsigned-long)

(clojure.core/declare deser-role-aliases)

(clojure.core/declare deser-authorizer-summary)

(clojure.core/declare deser-tag-list)

(clojure.core/declare deser-signature)

(clojure.core/declare deser-ota-update-error-message)

(clojure.core/declare deser-check-compliant)

(clojure.core/declare deser-searchable-attributes)

(clojure.core/declare deser-job-summary-list)

(clojure.core/declare deser-audit-check-run-status)

(clojure.core/declare deser-message-format)

(clojure.core/declare deser-date-type)

(clojure.core/declare deser-thing-indexing-configuration)

(clojure.core/declare deser-role-alias-description)

(clojure.core/declare deser-audit-frequency)

(clojure.core/declare deser-attribute-value)

(clojure.core/declare deser-ota-update-file-version)

(clojure.core/declare deser-aws-iot-job-arn)

(clojure.core/declare deser-dynamo-key-type)

(clojure.core/declare deser-thing-id)

(clojure.core/declare deser-public-key-map)

(clojure.core/declare deser-behavior-criteria)

(clojure.core/declare deser-reason-for-non-compliance)

(clojure.core/declare deser-security-profile-identifiers)

(clojure.core/declare deser-error-code)

(clojure.core/declare deser-stream-arn)

(clojure.core/declare deser-signing-profile-parameter)

(clojure.core/declare deser-stream-file)

(clojure.core/declare deser-sns-action)

(clojure.core/declare deser-channel-name)

(clojure.core/declare deser-presigned-url-config)

(clojure.core/declare deser-related-resource)

(clojure.core/declare deser-queued-things)

(clojure.core/declare deser-value)

(clojure.core/declare deser-credential-duration-seconds)

(clojure.core/declare deser-audit-finding)

(clojure.core/declare deser-job-execution-summary-for-job-list)

(clojure.core/declare deser-aws-job-executions-rollout-config)

(clojure.core/declare deser-description)

(clojure.core/declare deser-tag-value)

(clojure.core/declare deser-ota-update-description)

(clojure.core/declare deser-token-key-name)

(clojure.core/declare deser-policy-document)

(clojure.core/declare deser-port)

(clojure.core/declare deser-billing-group-metadata)

(clojure.core/declare deser-authorizer-status)

(clojure.core/declare deser-group-name-and-arn)

(clojure.core/declare deser-timeout-config)

(clojure.core/declare deser-aws-account-id)

(clojure.core/declare deser-message)

(clojure.core/declare deser-is-disabled)

(clojure.core/declare deser-dynamic-group-status)

(clojure.core/declare deser-resources)

(clojure.core/declare deser-policy-documents)

(clojure.core/declare deser-auth-decision)

(clojure.core/declare deser-attribute-key)

(clojure.core/declare deser-billing-group-name-and-arn-list)

(clojure.core/declare deser-file-location)

(clojure.core/declare deser-log-target)

(clojure.core/declare deser-cloudwatch-metric-action)

(clojure.core/declare deser-audit-notification-target)

(clojure.core/declare deser-job-executions-rollout-config)

(clojure.core/declare deser-stream-summary)

(clojure.core/declare deser-error-info)

(clojure.core/declare deser-attributes-map)

(clojure.core/declare deser-job-document-source)

(clojure.core/declare deser-thing-group-document)

(clojure.core/declare deser-authorizer-description)

(clojure.core/declare deser-delivery-stream-name)

(clojure.core/declare deser-billing-group-description)

(clojure.core/declare deser-sqs-action)

(clojure.core/declare deser-s-3-version)

(clojure.core/declare deser-string)

(clojure.core/declare deser-cognito-identity-pool-id)

(clojure.core/declare deser-details-value)

(clojure.core/declare deser-ports)

(clojure.core/declare deser-allowed)

(clojure.core/declare deser-percentage)

(clojure.core/declare deser-job-targets)

(clojure.core/declare deser-missing-context-value)

(clojure.core/declare deser-thing-connectivity-indexing-mode)

(clojure.core/declare deser-denied)

(clojure.core/declare deser-policy-arn)

(clojure.core/declare deser-code-signing-signature)

(clojure.core/declare deser-alert-target-arn)

(clojure.core/declare deser-abort-threshold-percentage)

(clojure.core/declare deser-audit-notification-type)

(clojure.core/declare deser-s-3-file-url)

(clojure.core/declare deser-report-type)

(clojure.core/declare deser-thing-type-id)

(clojure.core/declare deser-resource-type)

(clojure.core/declare deser-alarm-name)

(clojure.core/declare deser-job-execution-status-details)

(clojure.core/declare deser-hash-key-field)

(clojure.core/declare deser-targets)

(clojure.core/declare deser-thing-name)

(clojure.core/declare deser-republish-action)

(clojure.core/declare deser-resource-identifier)

(clojure.core/declare deser-s-3-key)

(clojure.core/declare deser-authorizer-arn)

(clojure.core/declare deser-stream-version)

(clojure.core/declare deser-job-execution-status)

(clojure.core/declare deser-metric-value)

(clojure.core/declare deser-job-process-details)

(clojure.core/declare deser-client-id)

(clojure.core/declare deser-audit-check-configurations)

(clojure.core/declare deser-elasticsearch-action)

(clojure.core/declare deser-s-3-location)

(clojure.core/declare deser-task-statistics)

(clojure.core/declare deser-elasticsearch-index)

(clojure.core/declare deser-policies)

(clojure.core/declare deser-certificate-arn)

(clojure.core/declare deser-custom-code-signing)

(clojure.core/declare deser-table-name)

(clojure.core/declare deser-s-3-bucket)

(clojure.core/declare deser-billing-group-name)

(clojure.core/declare deser-aws-iot-sql-version)

(clojure.core/declare deser-stream)

(clojure.core/declare deser-sql)

(clojure.core/declare deser-details-key)

(clojure.core/declare deser-registry-s-3-bucket-name)

(clojure.core/declare deser-creation-date)

(clojure.core/declare deser-abort-action)

(clojure.core/declare deser-dynamo-db-action)

(clojure.core/declare deser-violation-event-type)

(clojure.core/declare deser-total-resources-count)

(clojure.core/declare deser-topic-rule-list)

(clojure.core/declare deser-security-profile-arn)

(clojure.core/declare deser-policy-version-id)

(clojure.core/declare deser-alert-target)

(clojure.core/declare deser-timestamp)

(clojure.core/declare deser-dynamo-operation)

(clojure.core/declare deser-resource-arn)

(clojure.core/declare deser-authorizers)

(clojure.core/declare deser-processing-target-name-list)

(clojure.core/declare deser-hash-algorithm)

(clojure.core/declare deser-certificate-status)

(clojure.core/declare deser-policy-version-identifier)

(clojure.core/declare deser-security-profile-identifier)

(clojure.core/declare deser-thing-group-name-and-arn-list)

(clojure.core/declare deser-customer-version)

(clojure.core/declare deser-authorizer-name)

(clojure.core/declare deser-policy)

(clojure.core/declare deser-thing-connectivity)

(clojure.core/declare deser-key-pair)

(clojure.core/declare deser-maximum-per-minute)

(clojure.core/declare deser-behavior-name)

(clojure.core/declare deser-tag)

(clojure.core/declare deser-s-3-destination)

(clojure.core/declare deser-resource)

(clojure.core/declare deser-version)

(clojure.core/declare deser-reason-code)

(clojure.core/declare deser-job-execution-failure-type)

(clojure.core/declare deser-state-machine-name)

(clojure.core/declare deser-elasticsearch-id)

(clojure.core/declare deser-file-id)

(clojure.core/declare deser-processing-target-name)

(clojure.core/declare deserresource-arn)

(clojure.core/declare deser-salesforce-action)

(clojure.core/declare deser-event-configurations)

(clojure.core/declare deser-version-number)

(clojure.core/declare deser-salesforce-endpoint)

(clojure.core/declare deser-step-functions-action)

(clojure.core/declare deser-job)

(clojure.core/declare deser-is-default-version)

(clojure.core/declare deser-auth-info)

(clojure.core/declare deser-target)

(clojure.core/declare deser-rollout-rate-per-minute)

(clojure.core/declare deser-code)

(clojure.core/declare deser-certificate-validity)

(clojure.core/declare deser-violation-id)

(clojure.core/declare deser-action-type)

(clojure.core/declare deser-job-execution-summary-for-thing-list)

(clojure.core/declare deser-thing-group-name)

(clojure.core/declare deser-policy-target)

(clojure.core/declare deser-ca-certificate-description)

(clojure.core/declare deser-execution-name-prefix)

(clojure.core/declare deser-transfer-data)

(clojure.core/declare deser-evaluation-statistic)

(clojure.core/declare deser-scheduled-audit-name)

(clojure.core/declare deser-policy-versions)

(clojure.core/declare deser-cloudwatch-alarm-action)

(clojure.core/declare deser-signing-job-id)

(clojure.core/declare deser-lambda-action)

(clojure.core/declare deser-bucket-name)

(clojure.core/declare deser-failed-checks-count)

(clojure.core/declare deser-certificate-id)

(clojure.core/declare deser-ota-updates-summary)

(clojure.core/declare deser-ota-update-status)

(clojure.core/declare deser-related-resources)

(clojure.core/declare deser-endpoint-address)

(clojure.core/declare deser-in-progress-things)

(clojure.core/declare deser-certificate-pem)

(clojure.core/declare deser-file-name)

(clojure.core/declare deser-job-summary)

(clojure.core/declare deser-thing-document)

(clojure.core/declare deser-ota-update-id)

(clojure.core/declare deser-action)

(clojure.core/declare deser-configuration)

(clojure.core/declare deser-thing-type-list)

(clojure.core/declare deser-created-at-date)

(clojure.core/declare deser-job-execution-summary-for-thing)

(clojure.core/declare deser-certificate)

(clojure.core/declare deser-increment-factor)

(clojure.core/declare deser-job-description)

(clojure.core/declare deser-state-reason)

(clojure.core/declare deser-aws-iot-job-id)

(clojure.core/declare deser-approximate-seconds-before-timed-out)

(clojure.core/declare deser-elasticsearch-endpoint)

(clojure.core/declare deser-ota-update-info)

(clojure.core/declare deser-signing-profile-name)

(clojure.core/declare deser-effective-policy)

(clojure.core/declare deser-details-map)

(clojure.core/declare deser-consecutive-datapoints-to-clear)

(clojure.core/declare deser-audit-check-configuration)

(clojure.core/declare deser-audit-task-status)

(clojure.core/declare deser-s-3-action)

(clojure.core/declare deser-job-execution)

(clojure.core/declare deser-iot-analytics-action)

(clojure.core/declare deser-security-profile-target-mapping)

(clojure.core/declare deser-generation-id)

(clojure.core/declare deser-kinesis-action)

(clojure.core/declare deser-ca-certificate)

(clojure.core/declare deser-public-key)

(clojure.core/declare deser-job-arn)

(clojure.core/declare deser-valid)

(clojure.core/declare deser-audit-task-id)

(clojure.core/declare deser-payload-field)

(clojure.core/declare deser-authorizer-function-arn)

(clojure.core/declare deser-topic-rule-list-item)

(clojure.core/declare deser-is-authenticated)

(clojure.core/declare deser-firehose-separator)

(clojure.core/declare deser-seconds)

(clojure.core/declare deser-auth-result)

(clojure.core/declare deser-principals)

(clojure.core/declare deser-validation-errors)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-topic-rule)

(clojure.core/declare deser-registration-code)

(clojure.core/declare deser-job-id)

(clojure.core/defn- deser-audit-task-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-audit-task-metadata coll))) input))

(clojure.core/defn- deser-audit-finding-severity [input] (clojure.core/get {"CRITICAL" :critical, "HIGH" :high, "MEDIUM" :medium, "LOW" :low} input))

(clojure.core/defn- deser-stream-id [input] input)

(clojure.core/defn- deser-billing-group-arn [input] input)

(clojure.core/defn- deser-compliant-checks-count [input] input)

(clojure.core/defn- deser-auto-registration-status [input] (clojure.core/get {"ENABLE" :enable, "DISABLE" :disable} input))

(clojure.core/defn- deser-security-profile-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-profile-target coll))) input))

(clojure.core/defn- deser-thing-indexing-mode [input] (clojure.core/get {"OFF" :off, "REGISTRY" :registry, "REGISTRY_AND_SHADOW" :registry-and-shadow} input))

(clojure.core/defn- deser-canceled-checks-count [input] input)

(clojure.core/defn- deser-billing-group-properties [input] (clojure.core/cond-> {} (clojure.core/contains? input "billingGroupDescription") (clojure.core/assoc :billing-group-description (deser-billing-group-description (input "billingGroupDescription")))))

(clojure.core/defn- deser-thing-group-description [input] input)

(clojure.core/defn- deser-scheduled-audit-arn [input] input)

(clojure.core/defn- deser-outgoing-certificates [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-outgoing-certificate coll))) input))

(clojure.core/defn- deser-range-key-field [input] input)

(clojure.core/defn- deser-thing-group-indexing-configuration [input] (clojure.core/cond-> {:thing-group-indexing-mode (deser-thing-group-indexing-mode (input "thingGroupIndexingMode"))}))

(clojure.core/defn- deser-security-profile-description [input] input)

(clojure.core/defn- deser-thing-attribute-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-attribute coll))) input))

(clojure.core/defn- deser-thing-group-document-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-group-document coll))) input))

(clojure.core/defn- deser-ota-update-arn [input] input)

(clojure.core/defn- deser-log-target-configurations [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-log-target-configuration coll))) input))

(clojure.core/defn- deser-in-progress-timeout-in-minutes [input] input)

(clojure.core/defn- deser-thing-type-properties [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingTypeDescription") (clojure.core/assoc :thing-type-description (deser-thing-type-description (input "thingTypeDescription"))) (clojure.core/contains? input "searchableAttributes") (clojure.core/assoc :searchable-attributes (deser-searchable-attributes (input "searchableAttributes")))))

(clojure.core/defn- deser-stream-name [input] input)

(clojure.core/defn- deser-job-execution-summary-for-job [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (input "thingArn"))) (clojure.core/contains? input "jobExecutionSummary") (clojure.core/assoc :job-execution-summary (deser-job-execution-summary (input "jobExecutionSummary")))))

(clojure.core/defn- deser-code-signing [input] (clojure.core/cond-> {} (clojure.core/contains? input "awsSignerJobId") (clojure.core/assoc :aws-signer-job-id (deser-signing-job-id (input "awsSignerJobId"))) (clojure.core/contains? input "startSigningJobParameter") (clojure.core/assoc :start-signing-job-parameter (deser-start-signing-job-parameter (input "startSigningJobParameter"))) (clojure.core/contains? input "customCodeSigning") (clojure.core/assoc :custom-code-signing (deser-custom-code-signing (input "customCodeSigning")))))

(clojure.core/defn- deser-dynamo-d-bv-2-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :put-item (deser-put-item-input (input "putItem"))}))

(clojure.core/defn- deser-audit-notification-target-configurations [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-audit-notification-type k) (deser-audit-notification-target v)])) input))

(clojure.core/defn- deser-statistical-threshold [input] (clojure.core/cond-> {} (clojure.core/contains? input "statistic") (clojure.core/assoc :statistic (deser-evaluation-statistic (input "statistic")))))

(clojure.core/defn- deser-ota-update-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "otaUpdateId") (clojure.core/assoc :ota-update-id (deser-ota-update-id (input "otaUpdateId"))) (clojure.core/contains? input "otaUpdateArn") (clojure.core/assoc :ota-update-arn (deser-ota-update-arn (input "otaUpdateArn"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-minimum-number-of-executed-things [input] input)

(clojure.core/defn- deser-cidr [input] input)

(clojure.core/defn- deser-active-violations [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-active-violation coll))) input))

(clojure.core/defn- deser-string-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-platform [input] input)

(clojure.core/defn- deser-stream-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-stream-id (input "streamId"))) (clojure.core/contains? input "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (input "streamArn"))) (clojure.core/contains? input "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (input "streamVersion"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-stream-description (input "description"))) (clojure.core/contains? input "files") (clojure.core/assoc :files (deser-stream-files (input "files"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-date-type (input "createdAt"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn")))))

(clojure.core/defn- deser-private-key [input] input)

(clojure.core/defn- deser-explicit-deny [input] (clojure.core/cond-> {} (clojure.core/contains? input "policies") (clojure.core/assoc :policies (deser-policies (input "policies")))))

(clojure.core/defn- deser-deprecation-date [input] input)

(clojure.core/defn- deser-function-arn [input] input)

(clojure.core/defn- deser-resource-logical-id [input] input)

(clojure.core/defn- deser-topic-pattern [input] input)

(clojure.core/defn- deser-removed-things [input] input)

(clojure.core/defn- deser-signature-algorithm [input] input)

(clojure.core/defn- deser-index-status [input] (clojure.core/get {"ACTIVE" :active, "BUILDING" :building, "REBUILDING" :rebuilding} input))

(clojure.core/defn- deser-query-version [input] input)

(clojure.core/defn- deser-rule-name [input] input)

(clojure.core/defn- deser-violation-event [input] (clojure.core/cond-> {} (clojure.core/contains? input "violationId") (clojure.core/assoc :violation-id (deser-violation-id (input "violationId"))) (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (input "securityProfileName"))) (clojure.core/contains? input "behavior") (clojure.core/assoc :behavior (deser-behavior (input "behavior"))) (clojure.core/contains? input "metricValue") (clojure.core/assoc :metric-value (deser-metric-value (input "metricValue"))) (clojure.core/contains? input "violationEventType") (clojure.core/assoc :violation-event-type (deser-violation-event-type (input "violationEventType"))) (clojure.core/contains? input "violationEventTime") (clojure.core/assoc :violation-event-time (deser-timestamp (input "violationEventTime")))))

(clojure.core/defn- deser-s-3-file-url-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-s-3-file-url coll))) input))

(clojure.core/defn- deser-non-compliant-resources-count [input] input)

(clojure.core/defn- deser-job-status [input] (clojure.core/get {"IN_PROGRESS" :in-progress, "CANCELED" :canceled, "COMPLETED" :completed, "DELETION_IN_PROGRESS" :deletion-in-progress} input))

(clojure.core/defn- deser-failed-things [input] input)

(clojure.core/defn- deser-code-signing-certificate-chain [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateName") (clojure.core/assoc :certificate-name (deser-certificate-name (input "certificateName"))) (clojure.core/contains? input "inlineDocument") (clojure.core/assoc :inline-document (deser-inline-document (input "inlineDocument")))))

(clojure.core/defn- deser-comment [input] input)

(clojure.core/defn- deser-missing-context-values [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-missing-context-value coll))) input))

(clojure.core/defn- deser-day-of-week [input] (clojure.core/get {"SUN" :sun, "MON" :mon, "TUE" :tue, "WED" :wed, "THU" :thu, "FRI" :fri, "SAT" :sat} input))

(clojure.core/defn- deser-prefix [input] input)

(clojure.core/defn- deser-message-id [input] input)

(clojure.core/defn- deser-security-profile-target [input] (clojure.core/cond-> {:arn (deser-security-profile-target-arn (input "arn"))}))

(clojure.core/defn- deser-thing-type-description [input] input)

(clojure.core/defn- deser-streams-summary [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stream-summary coll))) input))

(clojure.core/defn- deser-thing-attribute [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (input "thingTypeName"))) (clojure.core/contains? input "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (input "thingArn"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-version (input "version")))))

(clojure.core/defn- deser-abort-criteria [input] (clojure.core/cond-> {:failure-type (deser-job-execution-failure-type (input "failureType")), :action (deser-abort-action (input "action")), :threshold-percentage (deser-abort-threshold-percentage (input "thresholdPercentage")), :min-number-of-executed-things (deser-minimum-number-of-executed-things (input "minNumberOfExecutedThings"))}))

(clojure.core/defn- deser-validation-error [input] (clojure.core/cond-> {} (clojure.core/contains? input "errorMessage") (clojure.core/assoc :error-message (deser-error-message (input "errorMessage")))))

(clojure.core/defn- deser-index-names-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-index-name coll))) input))

(clojure.core/defn- deser-audit-task-type [input] (clojure.core/get {"ON_DEMAND_AUDIT_TASK" :on-demand-audit-task, "SCHEDULED_AUDIT_TASK" :scheduled-audit-task} input))

(clojure.core/defn- deser-canned-access-control-list [input] (clojure.core/get {"private" :private, "public-read" :publicread, "public-read-write" :publicreadwrite, "aws-exec-read" :awsexecread, "authenticated-read" :authenticatedread, "bucket-owner-read" :bucketownerread, "bucket-owner-full-control" :bucketownerfullcontrol, "log-delivery-write" :logdeliverywrite} input))

(clojure.core/defn- deser-connectivity-timestamp [input] input)

(clojure.core/defn- deser-thing-group-id [input] input)

(clojure.core/defn- deser-duration-seconds [input] input)

(clojure.core/defn- deser-thing-type-name [input] input)

(clojure.core/defn- deser-violation-events [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-violation-event coll))) input))

(clojure.core/defn- deser-iot-events-action [input] (clojure.core/cond-> {:input-name (deser-input-name (input "inputName")), :role-arn (deser-aws-arn (input "roleArn"))} (clojure.core/contains? input "messageId") (clojure.core/assoc :message-id (deser-message-id (input "messageId")))))

(clojure.core/defn- deser-execution-number [input] input)

(clojure.core/defn- deser-input-name [input] input)

(clojure.core/defn- deserresource-id [input] input)

(clojure.core/defn- deser-additional-metrics-to-retain-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-behavior-metric coll))) input))

(clojure.core/defn- deser-number-of-things [input] input)

(clojure.core/defn- deser-non-compliant-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "resourceIdentifier") (clojure.core/assoc :resource-identifier (deser-resource-identifier (input "resourceIdentifier"))) (clojure.core/contains? input "additionalInfo") (clojure.core/assoc :additional-info (deser-string-map (input "additionalInfo")))))

(clojure.core/defn- deser-key-value [input] input)

(clojure.core/defn- deser-thing-group-arn [input] input)

(clojure.core/defn- deser-attribute-name [input] input)

(clojure.core/defn- deser-outgoing-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId"))) (clojure.core/contains? input "transferredTo") (clojure.core/assoc :transferred-to (deser-aws-account-id (input "transferredTo"))) (clojure.core/contains? input "transferDate") (clojure.core/assoc :transfer-date (deser-date-type (input "transferDate"))) (clojure.core/contains? input "transferMessage") (clojure.core/assoc :transfer-message (deser-message (input "transferMessage"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-canceled-things [input] input)

(clojure.core/defn- deser-last-modified-date [input] input)

(clojure.core/defn- deser-log-level [input] (clojure.core/get {"DEBUG" :debug, "INFO" :info, "ERROR" :error, "WARN" :warn, "DISABLED" :disabled} input))

(clojure.core/defn- deser-target-audit-check-names [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-audit-check-name coll))) input))

(clojure.core/defn- deser-effective-policies [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-effective-policy coll))) input))

(clojure.core/defn- deser-policy-name [input] input)

(clojure.core/defn- deser-ca-certificates [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ca-certificate coll))) input))

(clojure.core/defn- desererror-message [input] input)

(clojure.core/defn- deser-action-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-action coll))) input))

(clojure.core/defn- deser-active-violation [input] (clojure.core/cond-> {} (clojure.core/contains? input "violationId") (clojure.core/assoc :violation-id (deser-violation-id (input "violationId"))) (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (input "securityProfileName"))) (clojure.core/contains? input "behavior") (clojure.core/assoc :behavior (deser-behavior (input "behavior"))) (clojure.core/contains? input "lastViolationValue") (clojure.core/assoc :last-violation-value (deser-metric-value (input "lastViolationValue"))) (clojure.core/contains? input "lastViolationTime") (clojure.core/assoc :last-violation-time (deser-timestamp (input "lastViolationTime"))) (clojure.core/contains? input "violationStartTime") (clojure.core/assoc :violation-start-time (deser-timestamp (input "violationStartTime")))))

(clojure.core/defn- deser-registration-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "templateBody") (clojure.core/assoc :template-body (deser-template-body (input "templateBody"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn")))))

(clojure.core/defn- deser-additional-parameter-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-key k) (deser-value v)])) input))

(clojure.core/defn- deser-json-document [input] input)

(clojure.core/defn- deser-expires-in-sec [input] input)

(clojure.core/defn- deser-thing-arn [input] input)

(clojure.core/defn- deser-template-body [input] input)

(clojure.core/defn- deser-behavior [input] (clojure.core/cond-> {:name (deser-behavior-name (input "name"))} (clojure.core/contains? input "metric") (clojure.core/assoc :metric (deser-behavior-metric (input "metric"))) (clojure.core/contains? input "criteria") (clojure.core/assoc :criteria (deser-behavior-criteria (input "criteria")))))

(clojure.core/defn- deser-index-name [input] input)

(clojure.core/defn- deser-certificates [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-certificate coll))) input))

(clojure.core/defn- deser-thing-type-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "deprecated") (clojure.core/assoc :deprecated (deser-boolean (input "deprecated"))) (clojure.core/contains? input "deprecationDate") (clojure.core/assoc :deprecation-date (deser-deprecation-date (input "deprecationDate"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (input "creationDate")))))

(clojure.core/defn- deser-certificate-name [input] input)

(clojure.core/defn- deser-attribute-payload [input] (clojure.core/cond-> {} (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "merge") (clojure.core/assoc :merge (deser-flag (input "merge")))))

(clojure.core/defn- deser-scheduled-audit-metadata-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-scheduled-audit-metadata coll))) input))

(clojure.core/defn- deser-inline-document [input] input)

(clojure.core/defn- deser-state-value [input] input)

(clojure.core/defn- deser-reason-for-non-compliance-code [input] input)

(clojure.core/defn- deser-use-base-64 [input] input)

(clojure.core/defn- deser-abort-config [input] (clojure.core/cond-> {:criteria-list (deser-abort-criteria-list (input "criteriaList"))}))

(clojure.core/defn- deser-certificate-path-on-device [input] input)

(clojure.core/defn- deser-security-profile-target-arn [input] input)

(clojure.core/defn- deser-day-of-month [input] input)

(clojure.core/defn- deser-principal-arn [input] input)

(clojure.core/defn- deser-max-job-executions-per-min [input] input)

(clojure.core/defn- deser-ca-certificate-status [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive} input))

(clojure.core/defn- deser-role-arn [input] input)

(clojure.core/defn- deser-target-arn [input] input)

(clojure.core/defn- deser-security-profile-target-mappings [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-profile-target-mapping coll))) input))

(clojure.core/defn- deser-abort-criteria-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-abort-criteria coll))) input))

(clojure.core/defn- deser-disable-all-logs [input] input)

(clojure.core/defn- deser-registry-s-3-key-name [input] input)

(clojure.core/defn- deser-partition-key [input] input)

(clojure.core/defn- deser-audit-check-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "checkRunStatus") (clojure.core/assoc :check-run-status (deser-audit-check-run-status (input "checkRunStatus"))) (clojure.core/contains? input "checkCompliant") (clojure.core/assoc :check-compliant (deser-check-compliant (input "checkCompliant"))) (clojure.core/contains? input "totalResourcesCount") (clojure.core/assoc :total-resources-count (deser-total-resources-count (input "totalResourcesCount"))) (clojure.core/contains? input "nonCompliantResourcesCount") (clojure.core/assoc :non-compliant-resources-count (deser-non-compliant-resources-count (input "nonCompliantResourcesCount"))) (clojure.core/contains? input "errorCode") (clojure.core/assoc :error-code (deser-error-code (input "errorCode"))) (clojure.core/contains? input "message") (clojure.core/assoc :message (deser-error-message (input "message")))))

(clojure.core/defn- deser-audit-details [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-audit-check-name k) (deser-audit-check-details v)])) input))

(clojure.core/defn- deser-flag [input] input)

(clojure.core/defn- deser-certificate-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "customerVersion") (clojure.core/assoc :customer-version (deser-customer-version (input "customerVersion"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (input "certificatePem"))) (clojure.core/contains? input "caCertificateId") (clojure.core/assoc :ca-certificate-id (deser-certificate-id (input "caCertificateId"))) (clojure.core/contains? input "validity") (clojure.core/assoc :validity (deser-certificate-validity (input "validity"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate"))) (clojure.core/contains? input "ownedBy") (clojure.core/assoc :owned-by (deser-aws-account-id (input "ownedBy"))) (clojure.core/contains? input "transferData") (clojure.core/assoc :transfer-data (deser-transfer-data (input "transferData"))) (clojure.core/contains? input "generationId") (clojure.core/assoc :generation-id (deser-generation-id (input "generationId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-certificate-status (input "status"))) (clojure.core/contains? input "previousOwnedBy") (clojure.core/assoc :previous-owned-by (deser-aws-account-id (input "previousOwnedBy"))) (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId")))))

(clojure.core/defn- deser-principal-id [input] input)

(clojure.core/defn- deser-marker [input] input)

(clojure.core/defn- deser-index-schema [input] input)

(clojure.core/defn- deser-tag-key [input] input)

(clojure.core/defn- deser-ota-update-files [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ota-update-file coll))) input))

(clojure.core/defn- deser-thing-document-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-document coll))) input))

(clojure.core/defn- deser-start-signing-job-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "signingProfileParameter") (clojure.core/assoc :signing-profile-parameter (deser-signing-profile-parameter (input "signingProfileParameter"))) (clojure.core/contains? input "signingProfileName") (clojure.core/assoc :signing-profile-name (deser-signing-profile-name (input "signingProfileName"))) (clojure.core/contains? input "destination") (clojure.core/assoc :destination (deser-destination (input "destination")))))

(clojure.core/defn- deser-destination [input] (clojure.core/cond-> {} (clojure.core/contains? input "s3Destination") (clojure.core/assoc :s-3-destination (deser-s-3-destination (input "s3Destination")))))

(clojure.core/defn- deser-task-id-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-task-id coll))) input))

(clojure.core/defn- deser-rule-arn [input] input)

(clojure.core/defn- deser-count [input] input)

(clojure.core/defn- deser-non-compliant-checks-count [input] input)

(clojure.core/defn- deser-comparison-operator [input] (clojure.core/get {"less-than" :lessthan, "less-than-equals" :lessthanequals, "greater-than" :greaterthan, "greater-than-equals" :greaterthanequals, "in-cidr-set" :incidrset, "not-in-cidr-set" :notincidrset, "in-port-set" :inportset, "not-in-port-set" :notinportset} input))

(clojure.core/defn- deser-task-id [input] input)

(clojure.core/defn- deser-thing-type-definition [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (input "thingTypeName"))) (clojure.core/contains? input "thingTypeArn") (clojure.core/assoc :thing-type-arn (deser-thing-type-arn (input "thingTypeArn"))) (clojure.core/contains? input "thingTypeProperties") (clojure.core/assoc :thing-type-properties (deser-thing-type-properties (input "thingTypeProperties"))) (clojure.core/contains? input "thingTypeMetadata") (clojure.core/assoc :thing-type-metadata (deser-thing-type-metadata (input "thingTypeMetadata")))))

(clojure.core/defn- deser-billing-group-id [input] input)

(clojure.core/defn- deser-thing-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-name coll))) input))

(clojure.core/defn- deser-policy-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy-target coll))) input))

(clojure.core/defn- deser-forced [input] input)

(clojure.core/defn- deser-resource-arns [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-resource-logical-id k) (deser-resource-arn v)])) input))

(clojure.core/defn- deser-exponential-rollout-rate [input] (clojure.core/cond-> {:base-rate-per-minute (deser-rollout-rate-per-minute (input "baseRatePerMinute")), :increment-factor (deser-increment-factor (input "incrementFactor")), :rate-increase-criteria (deser-rate-increase-criteria (input "rateIncreaseCriteria"))}))

(clojure.core/defn- deser-job-execution-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-execution-status (input "status"))) (clojure.core/contains? input "queuedAt") (clojure.core/assoc :queued-at (deser-date-type (input "queuedAt"))) (clojure.core/contains? input "startedAt") (clojure.core/assoc :started-at (deser-date-type (input "startedAt"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "executionNumber") (clojure.core/assoc :execution-number (deser-execution-number (input "executionNumber")))))

(clojure.core/defn- deser-elasticsearch-type [input] input)

(clojure.core/defn- deser-waiting-for-data-collection-checks-count [input] input)

(clojure.core/defn- deser-thing-group-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-group-name coll))) input))

(clojure.core/defn- deser-rate-increase-criteria [input] (clojure.core/cond-> {} (clojure.core/contains? input "numberOfNotifiedThings") (clojure.core/assoc :number-of-notified-things (deser-number-of-things (input "numberOfNotifiedThings"))) (clojure.core/contains? input "numberOfSucceededThings") (clojure.core/assoc :number-of-succeeded-things (deser-number-of-things (input "numberOfSucceededThings")))))

(clojure.core/defn- deser-thing-type-arn [input] input)

(clojure.core/defn- deser-rejected-things [input] input)

(clojure.core/defn- deser-alert-targets [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-alert-target-type k) (deser-alert-target v)])) input))

(clojure.core/defn- deser-implicit-deny [input] (clojure.core/cond-> {} (clojure.core/contains? input "policies") (clojure.core/assoc :policies (deser-policies (input "policies")))))

(clojure.core/defn- deser-aws-arn [input] input)

(clojure.core/defn- deser-stream-files [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-stream-file coll))) input))

(clojure.core/defn- deser-key-name [input] input)

(clojure.core/defn- deser-log-target-type [input] (clojure.core/get {"DEFAULT" :default, "THING_GROUP" :thing-group} input))

(clojure.core/defn- deser-enabled [input] input)

(clojure.core/defn- deser-query-string [input] input)

(clojure.core/defn- deser-status [input] (clojure.core/get {"InProgress" :in-progress, "Completed" :completed, "Failed" :failed, "Cancelled" :cancelled, "Cancelling" :cancelling} input))

(clojure.core/defn- deser-behaviors [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-behavior coll))) input))

(clojure.core/defn- deser-audit-findings [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-audit-finding coll))) input))

(clojure.core/defn- deser-auth-results [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-auth-result coll))) input))

(clojure.core/defn- deser-policy-version [input] (clojure.core/cond-> {} (clojure.core/contains? input "versionId") (clojure.core/assoc :version-id (deser-policy-version-id (input "versionId"))) (clojure.core/contains? input "isDefaultVersion") (clojure.core/assoc :is-default-version (deser-is-default-version (input "isDefaultVersion"))) (clojure.core/contains? input "createDate") (clojure.core/assoc :create-date (deser-date-type (input "createDate")))))

(clojure.core/defn- deser-event-type [input] (clojure.core/get {"THING_TYPE" :thing-type, "THING_GROUP_HIERARCHY" :thing-group-hierarchy, "JOB_EXECUTION" :job-execution, "CA_CERTIFICATE" :ca-certificate, "THING_TYPE_ASSOCIATION" :thing-type-association, "JOB" :job, "POLICY" :policy, "THING_GROUP" :thing-group, "THING_GROUP_MEMBERSHIP" :thing-group-membership, "THING" :thing, "CERTIFICATE" :certificate} input))

(clojure.core/defn- deser-in-progress-checks-count [input] input)

(clojure.core/defn- deser-role-alias [input] input)

(clojure.core/defn- deser-log-target-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "logTarget") (clojure.core/assoc :log-target (deser-log-target (input "logTarget"))) (clojure.core/contains? input "logLevel") (clojure.core/assoc :log-level (deser-log-level (input "logLevel")))))

(clojure.core/defn- deser-put-item-input [input] (clojure.core/cond-> {:table-name (deser-table-name (input "tableName"))}))

(clojure.core/defn- deser-succeeded-things [input] input)

(clojure.core/defn- deser-log-target-name [input] input)

(clojure.core/defn- deser-next-token [input] input)

(clojure.core/defn- deser-behavior-metric [input] input)

(clojure.core/defn- deser-ota-update-file [input] (clojure.core/cond-> {} (clojure.core/contains? input "fileName") (clojure.core/assoc :file-name (deser-file-name (input "fileName"))) (clojure.core/contains? input "fileVersion") (clojure.core/assoc :file-version (deser-ota-update-file-version (input "fileVersion"))) (clojure.core/contains? input "fileLocation") (clojure.core/assoc :file-location (deser-file-location (input "fileLocation"))) (clojure.core/contains? input "codeSigning") (clojure.core/assoc :code-signing (deser-code-signing (input "codeSigning"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes-map (input "attributes")))))

(clojure.core/defn- deser-range-key-value [input] input)

(clojure.core/defn- deser-hash-key-value [input] input)

(clojure.core/defn- deser-firehose-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :delivery-stream-name (deser-delivery-stream-name (input "deliveryStreamName"))} (clojure.core/contains? input "separator") (clojure.core/assoc :separator (deser-firehose-separator (input "separator")))))

(clojure.core/defn- deser-role-alias-arn [input] input)

(clojure.core/defn- deser-scheduled-audit-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "scheduledAuditName") (clojure.core/assoc :scheduled-audit-name (deser-scheduled-audit-name (input "scheduledAuditName"))) (clojure.core/contains? input "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (input "scheduledAuditArn"))) (clojure.core/contains? input "frequency") (clojure.core/assoc :frequency (deser-audit-frequency (input "frequency"))) (clojure.core/contains? input "dayOfMonth") (clojure.core/assoc :day-of-month (deser-day-of-month (input "dayOfMonth"))) (clojure.core/contains? input "dayOfWeek") (clojure.core/assoc :day-of-week (deser-day-of-week (input "dayOfWeek")))))

(clojure.core/defn- deser-consecutive-datapoints-to-alarm [input] input)

(clojure.core/defn- deser-error-message [input] input)

(clojure.core/defn- deser-total-checks-count [input] input)

(clojure.core/defn- deser-security-profile-name [input] input)

(clojure.core/defn- deser-timed-out-things [input] input)

(clojure.core/defn- deser-thing-group-properties [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingGroupDescription") (clojure.core/assoc :thing-group-description (deser-thing-group-description (input "thingGroupDescription"))) (clojure.core/contains? input "attributePayload") (clojure.core/assoc :attribute-payload (deser-attribute-payload (input "attributePayload")))))

(clojure.core/defn- deser-cidrs [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-cidr coll))) input))

(clojure.core/defn- deser-audit-task-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "taskId") (clojure.core/assoc :task-id (deser-audit-task-id (input "taskId"))) (clojure.core/contains? input "taskStatus") (clojure.core/assoc :task-status (deser-audit-task-status (input "taskStatus"))) (clojure.core/contains? input "taskType") (clojure.core/assoc :task-type (deser-audit-task-type (input "taskType")))))

(clojure.core/defn- deser-alert-target-type [input] (clojure.core/get {"SNS" :sns} input))

(clojure.core/defn- deser-job-document [input] input)

(clojure.core/defn- deser-audit-check-name [input] input)

(clojure.core/defn- deser-key [input] input)

(clojure.core/defn- deser-stream-description [input] input)

(clojure.core/defn- deser-salesforce-token [input] input)

(clojure.core/defn- deser-thing-group-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "parentGroupName") (clojure.core/assoc :parent-group-name (deser-thing-group-name (input "parentGroupName"))) (clojure.core/contains? input "rootToParentThingGroups") (clojure.core/assoc :root-to-parent-thing-groups (deser-thing-group-name-and-arn-list (input "rootToParentThingGroups"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (input "creationDate")))))

(clojure.core/defn- deser-thing-group-indexing-mode [input] (clojure.core/get {"OFF" :off, "ON" :on} input))

(clojure.core/defn- deser-target-selection [input] (clojure.core/get {"CONTINUOUS" :continuous, "SNAPSHOT" :snapshot} input))

(clojure.core/defn- deser-attributes [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-name k) (deser-attribute-value v)])) input))

(clojure.core/defn- deser-queue-url [input] input)

(clojure.core/defn- deser-unsigned-long [input] input)

(clojure.core/defn- deser-role-aliases [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-role-alias coll))) input))

(clojure.core/defn- deser-authorizer-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (input "authorizerName"))) (clojure.core/contains? input "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (input "authorizerArn")))))

(clojure.core/defn- deser-tag-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-tag coll))) input))

(clojure.core/defn- deser-signature [input] (portkey.aws/base64-decode input))

(clojure.core/defn- deser-ota-update-error-message [input] input)

(clojure.core/defn- deser-check-compliant [input] input)

(clojure.core/defn- deser-searchable-attributes [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-attribute-name coll))) input))

(clojure.core/defn- deser-job-summary-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-job-summary coll))) input))

(clojure.core/defn- deser-audit-check-run-status [input] (clojure.core/get {"IN_PROGRESS" :in-progress, "WAITING_FOR_DATA_COLLECTION" :waiting-for-data-collection, "CANCELED" :canceled, "COMPLETED_COMPLIANT" :completed-compliant, "COMPLETED_NON_COMPLIANT" :completed-non-compliant, "FAILED" :failed} input))

(clojure.core/defn- deser-message-format [input] (clojure.core/get {"RAW" :raw, "JSON" :json} input))

(clojure.core/defn- deser-date-type [input] input)

(clojure.core/defn- deser-thing-indexing-configuration [input] (clojure.core/cond-> {:thing-indexing-mode (deser-thing-indexing-mode (input "thingIndexingMode"))} (clojure.core/contains? input "thingConnectivityIndexingMode") (clojure.core/assoc :thing-connectivity-indexing-mode (deser-thing-connectivity-indexing-mode (input "thingConnectivityIndexingMode")))))

(clojure.core/defn- deser-role-alias-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "roleAlias") (clojure.core/assoc :role-alias (deser-role-alias (input "roleAlias"))) (clojure.core/contains? input "roleAliasArn") (clojure.core/assoc :role-alias-arn (deser-role-alias-arn (input "roleAliasArn"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn"))) (clojure.core/contains? input "owner") (clojure.core/assoc :owner (deser-aws-account-id (input "owner"))) (clojure.core/contains? input "credentialDurationSeconds") (clojure.core/assoc :credential-duration-seconds (deser-credential-duration-seconds (input "credentialDurationSeconds"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate")))))

(clojure.core/defn- deser-audit-frequency [input] (clojure.core/get {"DAILY" :daily, "WEEKLY" :weekly, "BIWEEKLY" :biweekly, "MONTHLY" :monthly} input))

(clojure.core/defn- deser-attribute-value [input] input)

(clojure.core/defn- deser-ota-update-file-version [input] input)

(clojure.core/defn- deser-aws-iot-job-arn [input] input)

(clojure.core/defn- deser-dynamo-key-type [input] (clojure.core/get {"STRING" :string, "NUMBER" :number} input))

(clojure.core/defn- deser-thing-id [input] input)

(clojure.core/defn- deser-public-key-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-key-name k) (deser-key-value v)])) input))

(clojure.core/defn- deser-behavior-criteria [input] (clojure.core/cond-> {} (clojure.core/contains? input "comparisonOperator") (clojure.core/assoc :comparison-operator (deser-comparison-operator (input "comparisonOperator"))) (clojure.core/contains? input "value") (clojure.core/assoc :value (deser-metric-value (input "value"))) (clojure.core/contains? input "durationSeconds") (clojure.core/assoc :duration-seconds (deser-duration-seconds (input "durationSeconds"))) (clojure.core/contains? input "consecutiveDatapointsToAlarm") (clojure.core/assoc :consecutive-datapoints-to-alarm (deser-consecutive-datapoints-to-alarm (input "consecutiveDatapointsToAlarm"))) (clojure.core/contains? input "consecutiveDatapointsToClear") (clojure.core/assoc :consecutive-datapoints-to-clear (deser-consecutive-datapoints-to-clear (input "consecutiveDatapointsToClear"))) (clojure.core/contains? input "statisticalThreshold") (clojure.core/assoc :statistical-threshold (deser-statistical-threshold (input "statisticalThreshold")))))

(clojure.core/defn- deser-reason-for-non-compliance [input] input)

(clojure.core/defn- deser-security-profile-identifiers [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-security-profile-identifier coll))) input))

(clojure.core/defn- deser-error-code [input] input)

(clojure.core/defn- deser-stream-arn [input] input)

(clojure.core/defn- deser-signing-profile-parameter [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "platform") (clojure.core/assoc :platform (deser-platform (input "platform"))) (clojure.core/contains? input "certificatePathOnDevice") (clojure.core/assoc :certificate-path-on-device (deser-certificate-path-on-device (input "certificatePathOnDevice")))))

(clojure.core/defn- deser-stream-file [input] (clojure.core/cond-> {} (clojure.core/contains? input "fileId") (clojure.core/assoc :file-id (deser-file-id (input "fileId"))) (clojure.core/contains? input "s3Location") (clojure.core/assoc :s-3-location (deser-s-3-location (input "s3Location")))))

(clojure.core/defn- deser-sns-action [input] (clojure.core/cond-> {:target-arn (deser-aws-arn (input "targetArn")), :role-arn (deser-aws-arn (input "roleArn"))} (clojure.core/contains? input "messageFormat") (clojure.core/assoc :message-format (deser-message-format (input "messageFormat")))))

(clojure.core/defn- deser-channel-name [input] input)

(clojure.core/defn- deser-presigned-url-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn"))) (clojure.core/contains? input "expiresInSec") (clojure.core/assoc :expires-in-sec (deser-expires-in-sec (input "expiresInSec")))))

(clojure.core/defn- deser-related-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "resourceType") (clojure.core/assoc :resource-type (deser-resource-type (input "resourceType"))) (clojure.core/contains? input "resourceIdentifier") (clojure.core/assoc :resource-identifier (deser-resource-identifier (input "resourceIdentifier"))) (clojure.core/contains? input "additionalInfo") (clojure.core/assoc :additional-info (deser-string-map (input "additionalInfo")))))

(clojure.core/defn- deser-queued-things [input] input)

(clojure.core/defn- deser-value [input] input)

(clojure.core/defn- deser-credential-duration-seconds [input] input)

(clojure.core/defn- deser-audit-finding [input] (clojure.core/cond-> {} (clojure.core/contains? input "taskStartTime") (clojure.core/assoc :task-start-time (deser-timestamp (input "taskStartTime"))) (clojure.core/contains? input "checkName") (clojure.core/assoc :check-name (deser-audit-check-name (input "checkName"))) (clojure.core/contains? input "relatedResources") (clojure.core/assoc :related-resources (deser-related-resources (input "relatedResources"))) (clojure.core/contains? input "findingTime") (clojure.core/assoc :finding-time (deser-timestamp (input "findingTime"))) (clojure.core/contains? input "reasonForNonComplianceCode") (clojure.core/assoc :reason-for-non-compliance-code (deser-reason-for-non-compliance-code (input "reasonForNonComplianceCode"))) (clojure.core/contains? input "taskId") (clojure.core/assoc :task-id (deser-audit-task-id (input "taskId"))) (clojure.core/contains? input "severity") (clojure.core/assoc :severity (deser-audit-finding-severity (input "severity"))) (clojure.core/contains? input "nonCompliantResource") (clojure.core/assoc :non-compliant-resource (deser-non-compliant-resource (input "nonCompliantResource"))) (clojure.core/contains? input "reasonForNonCompliance") (clojure.core/assoc :reason-for-non-compliance (deser-reason-for-non-compliance (input "reasonForNonCompliance")))))

(clojure.core/defn- deser-job-execution-summary-for-job-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-job-execution-summary-for-job coll))) input))

(clojure.core/defn- deser-aws-job-executions-rollout-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "maximumPerMinute") (clojure.core/assoc :maximum-per-minute (deser-maximum-per-minute (input "maximumPerMinute")))))

(clojure.core/defn- deser-description [input] input)

(clojure.core/defn- deser-tag-value [input] input)

(clojure.core/defn- deser-ota-update-description [input] input)

(clojure.core/defn- deser-token-key-name [input] input)

(clojure.core/defn- deser-policy-document [input] input)

(clojure.core/defn- deser-port [input] input)

(clojure.core/defn- deser-billing-group-metadata [input] (clojure.core/cond-> {} (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (input "creationDate")))))

(clojure.core/defn- deser-authorizer-status [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive} input))

(clojure.core/defn- deser-group-name-and-arn [input] (clojure.core/cond-> {} (clojure.core/contains? input "groupName") (clojure.core/assoc :group-name (deser-thing-group-name (input "groupName"))) (clojure.core/contains? input "groupArn") (clojure.core/assoc :group-arn (deser-thing-group-arn (input "groupArn")))))

(clojure.core/defn- deser-timeout-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "inProgressTimeoutInMinutes") (clojure.core/assoc :in-progress-timeout-in-minutes (deser-in-progress-timeout-in-minutes (input "inProgressTimeoutInMinutes")))))

(clojure.core/defn- deser-aws-account-id [input] input)

(clojure.core/defn- deser-message [input] input)

(clojure.core/defn- deser-is-disabled [input] input)

(clojure.core/defn- deser-dynamic-group-status [input] (clojure.core/get {"ACTIVE" :active, "BUILDING" :building, "REBUILDING" :rebuilding} input))

(clojure.core/defn- deser-resources [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-resource coll))) input))

(clojure.core/defn- deser-policy-documents [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy-document coll))) input))

(clojure.core/defn- deser-auth-decision [input] (clojure.core/get {"ALLOWED" :allowed, "EXPLICIT_DENY" :explicit-deny, "IMPLICIT_DENY" :implicit-deny} input))

(clojure.core/defn- deser-attribute-key [input] input)

(clojure.core/defn- deser-billing-group-name-and-arn-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-name-and-arn coll))) input))

(clojure.core/defn- deser-file-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "stream") (clojure.core/assoc :stream (deser-stream (input "stream"))) (clojure.core/contains? input "s3Location") (clojure.core/assoc :s-3-location (deser-s-3-location (input "s3Location")))))

(clojure.core/defn- deser-log-target [input] (clojure.core/cond-> {:target-type (deser-log-target-type (input "targetType"))} (clojure.core/contains? input "targetName") (clojure.core/assoc :target-name (deser-log-target-name (input "targetName")))))

(clojure.core/defn- deser-cloudwatch-metric-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :metric-namespace (deser-string (input "metricNamespace")), :metric-name (deser-string (input "metricName")), :metric-value (deser-string (input "metricValue")), :metric-unit (deser-string (input "metricUnit"))} (clojure.core/contains? input "metricTimestamp") (clojure.core/assoc :metric-timestamp (deser-string (input "metricTimestamp")))))

(clojure.core/defn- deser-audit-notification-target [input] (clojure.core/cond-> {} (clojure.core/contains? input "targetArn") (clojure.core/assoc :target-arn (deser-target-arn (input "targetArn"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (input "roleArn"))) (clojure.core/contains? input "enabled") (clojure.core/assoc :enabled (deser-enabled (input "enabled")))))

(clojure.core/defn- deser-job-executions-rollout-config [input] (clojure.core/cond-> {} (clojure.core/contains? input "maximumPerMinute") (clojure.core/assoc :maximum-per-minute (deser-max-job-executions-per-min (input "maximumPerMinute"))) (clojure.core/contains? input "exponentialRate") (clojure.core/assoc :exponential-rate (deser-exponential-rollout-rate (input "exponentialRate")))))

(clojure.core/defn- deser-stream-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-stream-id (input "streamId"))) (clojure.core/contains? input "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (input "streamArn"))) (clojure.core/contains? input "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (input "streamVersion"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-stream-description (input "description")))))

(clojure.core/defn- deser-error-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "code") (clojure.core/assoc :code (deser-code (input "code"))) (clojure.core/contains? input "message") (clojure.core/assoc :message (deser-ota-update-error-message (input "message")))))

(clojure.core/defn- deser-attributes-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-attribute-key k) (deser-value v)])) input))

(clojure.core/defn- deser-job-document-source [input] input)

(clojure.core/defn- deser-thing-group-document [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (input "thingGroupName"))) (clojure.core/contains? input "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (input "thingGroupId"))) (clojure.core/contains? input "thingGroupDescription") (clojure.core/assoc :thing-group-description (deser-thing-group-description (input "thingGroupDescription"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "parentGroupNames") (clojure.core/assoc :parent-group-names (deser-thing-group-name-list (input "parentGroupNames")))))

(clojure.core/defn- deser-authorizer-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (input "authorizerName"))) (clojure.core/contains? input "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (input "authorizerArn"))) (clojure.core/contains? input "authorizerFunctionArn") (clojure.core/assoc :authorizer-function-arn (deser-authorizer-function-arn (input "authorizerFunctionArn"))) (clojure.core/contains? input "tokenKeyName") (clojure.core/assoc :token-key-name (deser-token-key-name (input "tokenKeyName"))) (clojure.core/contains? input "tokenSigningPublicKeys") (clojure.core/assoc :token-signing-public-keys (deser-public-key-map (input "tokenSigningPublicKeys"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-authorizer-status (input "status"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate")))))

(clojure.core/defn- deser-delivery-stream-name [input] input)

(clojure.core/defn- deser-billing-group-description [input] input)

(clojure.core/defn- deser-sqs-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :queue-url (deser-queue-url (input "queueUrl"))} (clojure.core/contains? input "useBase64") (clojure.core/assoc :use-base-64 (deser-use-base-64 (input "useBase64")))))

(clojure.core/defn- deser-s-3-version [input] input)

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-cognito-identity-pool-id [input] input)

(clojure.core/defn- deser-details-value [input] input)

(clojure.core/defn- deser-ports [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-port coll))) input))

(clojure.core/defn- deser-allowed [input] (clojure.core/cond-> {} (clojure.core/contains? input "policies") (clojure.core/assoc :policies (deser-policies (input "policies")))))

(clojure.core/defn- deser-percentage [input] input)

(clojure.core/defn- deser-job-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target-arn coll))) input))

(clojure.core/defn- deser-missing-context-value [input] input)

(clojure.core/defn- deser-thing-connectivity-indexing-mode [input] (clojure.core/get {"OFF" :off, "STATUS" :status} input))

(clojure.core/defn- deser-denied [input] (clojure.core/cond-> {} (clojure.core/contains? input "implicitDeny") (clojure.core/assoc :implicit-deny (deser-implicit-deny (input "implicitDeny"))) (clojure.core/contains? input "explicitDeny") (clojure.core/assoc :explicit-deny (deser-explicit-deny (input "explicitDeny")))))

(clojure.core/defn- deser-policy-arn [input] input)

(clojure.core/defn- deser-code-signing-signature [input] (clojure.core/cond-> {} (clojure.core/contains? input "inlineDocument") (clojure.core/assoc :inline-document (deser-signature (input "inlineDocument")))))

(clojure.core/defn- deser-alert-target-arn [input] input)

(clojure.core/defn- deser-abort-threshold-percentage [input] input)

(clojure.core/defn- deser-audit-notification-type [input] (clojure.core/get {"SNS" :sns} input))

(clojure.core/defn- deser-s-3-file-url [input] input)

(clojure.core/defn- deser-report-type [input] (clojure.core/get {"ERRORS" :errors, "RESULTS" :results} input))

(clojure.core/defn- deser-thing-type-id [input] input)

(clojure.core/defn- deser-resource-type [input] (clojure.core/get {"DEVICE_CERTIFICATE" :device-certificate, "CA_CERTIFICATE" :ca-certificate, "IOT_POLICY" :iot-policy, "COGNITO_IDENTITY_POOL" :cognito-identity-pool, "CLIENT_ID" :client-id, "ACCOUNT_SETTINGS" :account-settings} input))

(clojure.core/defn- deser-alarm-name [input] input)

(clojure.core/defn- deser-job-execution-status-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "detailsMap") (clojure.core/assoc :details-map (deser-details-map (input "detailsMap")))))

(clojure.core/defn- deser-hash-key-field [input] input)

(clojure.core/defn- deser-targets [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-target coll))) input))

(clojure.core/defn- deser-thing-name [input] input)

(clojure.core/defn- deser-republish-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :topic (deser-topic-pattern (input "topic"))}))

(clojure.core/defn- deser-resource-identifier [input] (clojure.core/cond-> {} (clojure.core/contains? input "deviceCertificateId") (clojure.core/assoc :device-certificate-id (deser-certificate-id (input "deviceCertificateId"))) (clojure.core/contains? input "caCertificateId") (clojure.core/assoc :ca-certificate-id (deser-certificate-id (input "caCertificateId"))) (clojure.core/contains? input "cognitoIdentityPoolId") (clojure.core/assoc :cognito-identity-pool-id (deser-cognito-identity-pool-id (input "cognitoIdentityPoolId"))) (clojure.core/contains? input "clientId") (clojure.core/assoc :client-id (deser-client-id (input "clientId"))) (clojure.core/contains? input "policyVersionIdentifier") (clojure.core/assoc :policy-version-identifier (deser-policy-version-identifier (input "policyVersionIdentifier"))) (clojure.core/contains? input "account") (clojure.core/assoc :account (deser-aws-account-id (input "account")))))

(clojure.core/defn- deser-s-3-key [input] input)

(clojure.core/defn- deser-authorizer-arn [input] input)

(clojure.core/defn- deser-stream-version [input] input)

(clojure.core/defn- deser-job-execution-status [input] (clojure.core/get {"QUEUED" :queued, "IN_PROGRESS" :in-progress, "SUCCEEDED" :succeeded, "FAILED" :failed, "TIMED_OUT" :timed-out, "REJECTED" :rejected, "REMOVED" :removed, "CANCELED" :canceled} input))

(clojure.core/defn- deser-metric-value [input] (clojure.core/cond-> {} (clojure.core/contains? input "count") (clojure.core/assoc :count (deser-unsigned-long (input "count"))) (clojure.core/contains? input "cidrs") (clojure.core/assoc :cidrs (deser-cidrs (input "cidrs"))) (clojure.core/contains? input "ports") (clojure.core/assoc :ports (deser-ports (input "ports")))))

(clojure.core/defn- deser-job-process-details [input] (clojure.core/cond-> {} (clojure.core/contains? input "numberOfTimedOutThings") (clojure.core/assoc :number-of-timed-out-things (deser-timed-out-things (input "numberOfTimedOutThings"))) (clojure.core/contains? input "numberOfCanceledThings") (clojure.core/assoc :number-of-canceled-things (deser-canceled-things (input "numberOfCanceledThings"))) (clojure.core/contains? input "numberOfQueuedThings") (clojure.core/assoc :number-of-queued-things (deser-queued-things (input "numberOfQueuedThings"))) (clojure.core/contains? input "numberOfInProgressThings") (clojure.core/assoc :number-of-in-progress-things (deser-in-progress-things (input "numberOfInProgressThings"))) (clojure.core/contains? input "numberOfRemovedThings") (clojure.core/assoc :number-of-removed-things (deser-removed-things (input "numberOfRemovedThings"))) (clojure.core/contains? input "numberOfFailedThings") (clojure.core/assoc :number-of-failed-things (deser-failed-things (input "numberOfFailedThings"))) (clojure.core/contains? input "numberOfSucceededThings") (clojure.core/assoc :number-of-succeeded-things (deser-succeeded-things (input "numberOfSucceededThings"))) (clojure.core/contains? input "numberOfRejectedThings") (clojure.core/assoc :number-of-rejected-things (deser-rejected-things (input "numberOfRejectedThings"))) (clojure.core/contains? input "processingTargets") (clojure.core/assoc :processing-targets (deser-processing-target-name-list (input "processingTargets")))))

(clojure.core/defn- deser-client-id [input] input)

(clojure.core/defn- deser-audit-check-configurations [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-audit-check-name k) (deser-audit-check-configuration v)])) input))

(clojure.core/defn- deser-elasticsearch-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :endpoint (deser-elasticsearch-endpoint (input "endpoint")), :index (deser-elasticsearch-index (input "index")), :type (deser-elasticsearch-type (input "type")), :id (deser-elasticsearch-id (input "id"))}))

(clojure.core/defn- deser-s-3-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "bucket") (clojure.core/assoc :bucket (deser-s-3-bucket (input "bucket"))) (clojure.core/contains? input "key") (clojure.core/assoc :key (deser-s-3-key (input "key"))) (clojure.core/contains? input "version") (clojure.core/assoc :version (deser-s-3-version (input "version")))))

(clojure.core/defn- deser-task-statistics [input] (clojure.core/cond-> {} (clojure.core/contains? input "totalChecks") (clojure.core/assoc :total-checks (deser-total-checks-count (input "totalChecks"))) (clojure.core/contains? input "inProgressChecks") (clojure.core/assoc :in-progress-checks (deser-in-progress-checks-count (input "inProgressChecks"))) (clojure.core/contains? input "waitingForDataCollectionChecks") (clojure.core/assoc :waiting-for-data-collection-checks (deser-waiting-for-data-collection-checks-count (input "waitingForDataCollectionChecks"))) (clojure.core/contains? input "compliantChecks") (clojure.core/assoc :compliant-checks (deser-compliant-checks-count (input "compliantChecks"))) (clojure.core/contains? input "nonCompliantChecks") (clojure.core/assoc :non-compliant-checks (deser-non-compliant-checks-count (input "nonCompliantChecks"))) (clojure.core/contains? input "failedChecks") (clojure.core/assoc :failed-checks (deser-failed-checks-count (input "failedChecks"))) (clojure.core/contains? input "canceledChecks") (clojure.core/assoc :canceled-checks (deser-canceled-checks-count (input "canceledChecks")))))

(clojure.core/defn- deser-elasticsearch-index [input] input)

(clojure.core/defn- deser-policies [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy coll))) input))

(clojure.core/defn- deser-certificate-arn [input] input)

(clojure.core/defn- deser-custom-code-signing [input] (clojure.core/cond-> {} (clojure.core/contains? input "signature") (clojure.core/assoc :signature (deser-code-signing-signature (input "signature"))) (clojure.core/contains? input "certificateChain") (clojure.core/assoc :certificate-chain (deser-code-signing-certificate-chain (input "certificateChain"))) (clojure.core/contains? input "hashAlgorithm") (clojure.core/assoc :hash-algorithm (deser-hash-algorithm (input "hashAlgorithm"))) (clojure.core/contains? input "signatureAlgorithm") (clojure.core/assoc :signature-algorithm (deser-signature-algorithm (input "signatureAlgorithm")))))

(clojure.core/defn- deser-table-name [input] input)

(clojure.core/defn- deser-s-3-bucket [input] input)

(clojure.core/defn- deser-billing-group-name [input] input)

(clojure.core/defn- deser-aws-iot-sql-version [input] input)

(clojure.core/defn- deser-stream [input] (clojure.core/cond-> {} (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-stream-id (input "streamId"))) (clojure.core/contains? input "fileId") (clojure.core/assoc :file-id (deser-file-id (input "fileId")))))

(clojure.core/defn- deser-sql [input] input)

(clojure.core/defn- deser-details-key [input] input)

(clojure.core/defn- deser-registry-s-3-bucket-name [input] input)

(clojure.core/defn- deser-creation-date [input] input)

(clojure.core/defn- deser-abort-action [input] (clojure.core/get {"CANCEL" :cancel} input))

(clojure.core/defn- deser-dynamo-db-action [input] (clojure.core/cond-> {:table-name (deser-table-name (input "tableName")), :role-arn (deser-aws-arn (input "roleArn")), :hash-key-field (deser-hash-key-field (input "hashKeyField")), :hash-key-value (deser-hash-key-value (input "hashKeyValue"))} (clojure.core/contains? input "rangeKeyValue") (clojure.core/assoc :range-key-value (deser-range-key-value (input "rangeKeyValue"))) (clojure.core/contains? input "rangeKeyField") (clojure.core/assoc :range-key-field (deser-range-key-field (input "rangeKeyField"))) (clojure.core/contains? input "hashKeyType") (clojure.core/assoc :hash-key-type (deser-dynamo-key-type (input "hashKeyType"))) (clojure.core/contains? input "operation") (clojure.core/assoc :operation (deser-dynamo-operation (input "operation"))) (clojure.core/contains? input "payloadField") (clojure.core/assoc :payload-field (deser-payload-field (input "payloadField"))) (clojure.core/contains? input "rangeKeyType") (clojure.core/assoc :range-key-type (deser-dynamo-key-type (input "rangeKeyType")))))

(clojure.core/defn- deser-violation-event-type [input] (clojure.core/get {"in-alarm" :inalarm, "alarm-cleared" :alarmcleared, "alarm-invalidated" :alarminvalidated} input))

(clojure.core/defn- deser-total-resources-count [input] input)

(clojure.core/defn- deser-topic-rule-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-topic-rule-list-item coll))) input))

(clojure.core/defn- deser-security-profile-arn [input] input)

(clojure.core/defn- deser-policy-version-id [input] input)

(clojure.core/defn- deser-alert-target [input] (clojure.core/cond-> {:alert-target-arn (deser-alert-target-arn (input "alertTargetArn")), :role-arn (deser-role-arn (input "roleArn"))}))

(clojure.core/defn- deser-timestamp [input] input)

(clojure.core/defn- deser-dynamo-operation [input] input)

(clojure.core/defn- deser-resource-arn [input] input)

(clojure.core/defn- deser-authorizers [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-authorizer-summary coll))) input))

(clojure.core/defn- deser-processing-target-name-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-processing-target-name coll))) input))

(clojure.core/defn- deser-hash-algorithm [input] input)

(clojure.core/defn- deser-certificate-status [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive, "REVOKED" :revoked, "PENDING_TRANSFER" :pending-transfer, "REGISTER_INACTIVE" :register-inactive, "PENDING_ACTIVATION" :pending-activation} input))

(clojure.core/defn- deser-policy-version-identifier [input] (clojure.core/cond-> {} (clojure.core/contains? input "policyName") (clojure.core/assoc :policy-name (deser-policy-name (input "policyName"))) (clojure.core/contains? input "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (input "policyVersionId")))))

(clojure.core/defn- deser-security-profile-identifier [input] (clojure.core/cond-> {:name (deser-security-profile-name (input "name")), :arn (deser-security-profile-arn (input "arn"))}))

(clojure.core/defn- deser-thing-group-name-and-arn-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-group-name-and-arn coll))) input))

(clojure.core/defn- deser-customer-version [input] input)

(clojure.core/defn- deser-authorizer-name [input] input)

(clojure.core/defn- deser-policy [input] (clojure.core/cond-> {} (clojure.core/contains? input "policyName") (clojure.core/assoc :policy-name (deser-policy-name (input "policyName"))) (clojure.core/contains? input "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (input "policyArn")))))

(clojure.core/defn- deser-thing-connectivity [input] (clojure.core/cond-> {} (clojure.core/contains? input "connected") (clojure.core/assoc :connected (deser-boolean (input "connected"))) (clojure.core/contains? input "timestamp") (clojure.core/assoc :timestamp (deser-connectivity-timestamp (input "timestamp")))))

(clojure.core/defn- deser-key-pair [input] (clojure.core/cond-> {} (clojure.core/contains? input "PublicKey") (clojure.core/assoc :public-key (deser-public-key (input "PublicKey"))) (clojure.core/contains? input "PrivateKey") (clojure.core/assoc :private-key (deser-private-key (input "PrivateKey")))))

(clojure.core/defn- deser-maximum-per-minute [input] input)

(clojure.core/defn- deser-behavior-name [input] input)

(clojure.core/defn- deser-tag [input] (clojure.core/cond-> {} (clojure.core/contains? input "Key") (clojure.core/assoc :key (deser-tag-key (input "Key"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-tag-value (input "Value")))))

(clojure.core/defn- deser-s-3-destination [input] (clojure.core/cond-> {} (clojure.core/contains? input "bucket") (clojure.core/assoc :bucket (deser-s-3-bucket (input "bucket"))) (clojure.core/contains? input "prefix") (clojure.core/assoc :prefix (deser-prefix (input "prefix")))))

(clojure.core/defn- deser-resource [input] input)

(clojure.core/defn- deser-version [input] input)

(clojure.core/defn- deser-reason-code [input] input)

(clojure.core/defn- deser-job-execution-failure-type [input] (clojure.core/get {"FAILED" :failed, "REJECTED" :rejected, "TIMED_OUT" :timed-out, "ALL" :all} input))

(clojure.core/defn- deser-state-machine-name [input] input)

(clojure.core/defn- deser-elasticsearch-id [input] input)

(clojure.core/defn- deser-file-id [input] input)

(clojure.core/defn- deser-processing-target-name [input] input)

(clojure.core/defn- deserresource-arn [input] input)

(clojure.core/defn- deser-salesforce-action [input] (clojure.core/cond-> {:token (deser-salesforce-token (input "token")), :url (deser-salesforce-endpoint (input "url"))}))

(clojure.core/defn- deser-event-configurations [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-event-type k) (deser-configuration v)])) input))

(clojure.core/defn- deser-version-number [input] input)

(clojure.core/defn- deser-salesforce-endpoint [input] input)

(clojure.core/defn- deser-step-functions-action [input] (clojure.core/cond-> {:state-machine-name (deser-state-machine-name (input "stateMachineName")), :role-arn (deser-aws-arn (input "roleArn"))} (clojure.core/contains? input "executionNamePrefix") (clojure.core/assoc :execution-name-prefix (deser-execution-name-prefix (input "executionNamePrefix")))))

(clojure.core/defn- deser-job [input] (clojure.core/cond-> {} (clojure.core/contains? input "targetSelection") (clojure.core/assoc :target-selection (deser-target-selection (input "targetSelection"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-date-type (input "createdAt"))) (clojure.core/contains? input "timeoutConfig") (clojure.core/assoc :timeout-config (deser-timeout-config (input "timeoutConfig"))) (clojure.core/contains? input "completedAt") (clojure.core/assoc :completed-at (deser-date-type (input "completedAt"))) (clojure.core/contains? input "abortConfig") (clojure.core/assoc :abort-config (deser-abort-config (input "abortConfig"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-status (input "status"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "targets") (clojure.core/assoc :targets (deser-job-targets (input "targets"))) (clojure.core/contains? input "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (input "jobArn"))) (clojure.core/contains? input "presignedUrlConfig") (clojure.core/assoc :presigned-url-config (deser-presigned-url-config (input "presignedUrlConfig"))) (clojure.core/contains? input "reasonCode") (clojure.core/assoc :reason-code (deser-reason-code (input "reasonCode"))) (clojure.core/contains? input "jobProcessDetails") (clojure.core/assoc :job-process-details (deser-job-process-details (input "jobProcessDetails"))) (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "comment") (clojure.core/assoc :comment (deser-comment (input "comment"))) (clojure.core/contains? input "jobExecutionsRolloutConfig") (clojure.core/assoc :job-executions-rollout-config (deser-job-executions-rollout-config (input "jobExecutionsRolloutConfig"))) (clojure.core/contains? input "forceCanceled") (clojure.core/assoc :force-canceled (deser-forced (input "forceCanceled"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-job-description (input "description")))))

(clojure.core/defn- deser-is-default-version [input] input)

(clojure.core/defn- deser-auth-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "actionType") (clojure.core/assoc :action-type (deser-action-type (input "actionType"))) (clojure.core/contains? input "resources") (clojure.core/assoc :resources (deser-resources (input "resources")))))

(clojure.core/defn- deser-target [input] input)

(clojure.core/defn- deser-rollout-rate-per-minute [input] input)

(clojure.core/defn- deser-code [input] input)

(clojure.core/defn- deser-certificate-validity [input] (clojure.core/cond-> {} (clojure.core/contains? input "notBefore") (clojure.core/assoc :not-before (deser-date-type (input "notBefore"))) (clojure.core/contains? input "notAfter") (clojure.core/assoc :not-after (deser-date-type (input "notAfter")))))

(clojure.core/defn- deser-violation-id [input] input)

(clojure.core/defn- deser-action-type [input] (clojure.core/get {"PUBLISH" :publish, "SUBSCRIBE" :subscribe, "RECEIVE" :receive, "CONNECT" :connect} input))

(clojure.core/defn- deser-job-execution-summary-for-thing-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-job-execution-summary-for-thing coll))) input))

(clojure.core/defn- deser-thing-group-name [input] input)

(clojure.core/defn- deser-policy-target [input] input)

(clojure.core/defn- deser-ca-certificate-description [input] (clojure.core/cond-> {} (clojure.core/contains? input "customerVersion") (clojure.core/assoc :customer-version (deser-customer-version (input "customerVersion"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (input "certificatePem"))) (clojure.core/contains? input "validity") (clojure.core/assoc :validity (deser-certificate-validity (input "validity"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate"))) (clojure.core/contains? input "ownedBy") (clojure.core/assoc :owned-by (deser-aws-account-id (input "ownedBy"))) (clojure.core/contains? input "autoRegistrationStatus") (clojure.core/assoc :auto-registration-status (deser-auto-registration-status (input "autoRegistrationStatus"))) (clojure.core/contains? input "generationId") (clojure.core/assoc :generation-id (deser-generation-id (input "generationId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-ca-certificate-status (input "status"))) (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId")))))

(clojure.core/defn- deser-execution-name-prefix [input] input)

(clojure.core/defn- deser-transfer-data [input] (clojure.core/cond-> {} (clojure.core/contains? input "transferMessage") (clojure.core/assoc :transfer-message (deser-message (input "transferMessage"))) (clojure.core/contains? input "rejectReason") (clojure.core/assoc :reject-reason (deser-message (input "rejectReason"))) (clojure.core/contains? input "transferDate") (clojure.core/assoc :transfer-date (deser-date-type (input "transferDate"))) (clojure.core/contains? input "acceptDate") (clojure.core/assoc :accept-date (deser-date-type (input "acceptDate"))) (clojure.core/contains? input "rejectDate") (clojure.core/assoc :reject-date (deser-date-type (input "rejectDate")))))

(clojure.core/defn- deser-evaluation-statistic [input] input)

(clojure.core/defn- deser-scheduled-audit-name [input] input)

(clojure.core/defn- deser-policy-versions [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-policy-version coll))) input))

(clojure.core/defn- deser-cloudwatch-alarm-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :alarm-name (deser-alarm-name (input "alarmName")), :state-reason (deser-state-reason (input "stateReason")), :state-value (deser-state-value (input "stateValue"))}))

(clojure.core/defn- deser-signing-job-id [input] input)

(clojure.core/defn- deser-lambda-action [input] (clojure.core/cond-> {:function-arn (deser-function-arn (input "functionArn"))}))

(clojure.core/defn- deser-bucket-name [input] input)

(clojure.core/defn- deser-failed-checks-count [input] input)

(clojure.core/defn- deser-certificate-id [input] input)

(clojure.core/defn- deser-ota-updates-summary [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-ota-update-summary coll))) input))

(clojure.core/defn- deser-ota-update-status [input] (clojure.core/get {"CREATE_PENDING" :create-pending, "CREATE_IN_PROGRESS" :create-in-progress, "CREATE_COMPLETE" :create-complete, "CREATE_FAILED" :create-failed} input))

(clojure.core/defn- deser-related-resources [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-related-resource coll))) input))

(clojure.core/defn- deser-endpoint-address [input] input)

(clojure.core/defn- deser-in-progress-things [input] input)

(clojure.core/defn- deser-certificate-pem [input] input)

(clojure.core/defn- deser-file-name [input] input)

(clojure.core/defn- deser-job-summary [input] (clojure.core/cond-> {} (clojure.core/contains? input "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (input "jobArn"))) (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (input "thingGroupId"))) (clojure.core/contains? input "targetSelection") (clojure.core/assoc :target-selection (deser-target-selection (input "targetSelection"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-status (input "status"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-date-type (input "createdAt"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "completedAt") (clojure.core/assoc :completed-at (deser-date-type (input "completedAt")))))

(clojure.core/defn- deser-thing-document [input] (clojure.core/cond-> {} (clojure.core/contains? input "thingName") (clojure.core/assoc :thing-name (deser-thing-name (input "thingName"))) (clojure.core/contains? input "thingId") (clojure.core/assoc :thing-id (deser-thing-id (input "thingId"))) (clojure.core/contains? input "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (input "thingTypeName"))) (clojure.core/contains? input "thingGroupNames") (clojure.core/assoc :thing-group-names (deser-thing-group-name-list (input "thingGroupNames"))) (clojure.core/contains? input "attributes") (clojure.core/assoc :attributes (deser-attributes (input "attributes"))) (clojure.core/contains? input "shadow") (clojure.core/assoc :shadow (deser-json-document (input "shadow"))) (clojure.core/contains? input "connectivity") (clojure.core/assoc :connectivity (deser-thing-connectivity (input "connectivity")))))

(clojure.core/defn- deser-ota-update-id [input] input)

(clojure.core/defn- deser-action [input] (clojure.core/cond-> {} (clojure.core/contains? input "dynamoDB") (clojure.core/assoc :dynamo-db (deser-dynamo-db-action (input "dynamoDB"))) (clojure.core/contains? input "sns") (clojure.core/assoc :sns (deser-sns-action (input "sns"))) (clojure.core/contains? input "cloudwatchAlarm") (clojure.core/assoc :cloudwatch-alarm (deser-cloudwatch-alarm-action (input "cloudwatchAlarm"))) (clojure.core/contains? input "iotAnalytics") (clojure.core/assoc :iot-analytics (deser-iot-analytics-action (input "iotAnalytics"))) (clojure.core/contains? input "republish") (clojure.core/assoc :republish (deser-republish-action (input "republish"))) (clojure.core/contains? input "kinesis") (clojure.core/assoc :kinesis (deser-kinesis-action (input "kinesis"))) (clojure.core/contains? input "s3") (clojure.core/assoc :s-3 (deser-s-3-action (input "s3"))) (clojure.core/contains? input "salesforce") (clojure.core/assoc :salesforce (deser-salesforce-action (input "salesforce"))) (clojure.core/contains? input "sqs") (clojure.core/assoc :sqs (deser-sqs-action (input "sqs"))) (clojure.core/contains? input "elasticsearch") (clojure.core/assoc :elasticsearch (deser-elasticsearch-action (input "elasticsearch"))) (clojure.core/contains? input "cloudwatchMetric") (clojure.core/assoc :cloudwatch-metric (deser-cloudwatch-metric-action (input "cloudwatchMetric"))) (clojure.core/contains? input "firehose") (clojure.core/assoc :firehose (deser-firehose-action (input "firehose"))) (clojure.core/contains? input "dynamoDBv2") (clojure.core/assoc :dynamo-d-bv-2 (deser-dynamo-d-bv-2-action (input "dynamoDBv2"))) (clojure.core/contains? input "lambda") (clojure.core/assoc :lambda (deser-lambda-action (input "lambda"))) (clojure.core/contains? input "stepFunctions") (clojure.core/assoc :step-functions (deser-step-functions-action (input "stepFunctions"))) (clojure.core/contains? input "iotEvents") (clojure.core/assoc :iot-events (deser-iot-events-action (input "iotEvents")))))

(clojure.core/defn- deser-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-enabled (input "Enabled")))))

(clojure.core/defn- deser-thing-type-list [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-thing-type-definition coll))) input))

(clojure.core/defn- deser-created-at-date [input] input)

(clojure.core/defn- deser-job-execution-summary-for-thing [input] (clojure.core/cond-> {} (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "jobExecutionSummary") (clojure.core/assoc :job-execution-summary (deser-job-execution-summary (input "jobExecutionSummary")))))

(clojure.core/defn- deser-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-certificate-status (input "status"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-increment-factor [input] input)

(clojure.core/defn- deser-job-description [input] input)

(clojure.core/defn- deser-state-reason [input] input)

(clojure.core/defn- deser-aws-iot-job-id [input] input)

(clojure.core/defn- deser-approximate-seconds-before-timed-out [input] input)

(clojure.core/defn- deser-elasticsearch-endpoint [input] input)

(clojure.core/defn- deser-ota-update-info [input] (clojure.core/cond-> {} (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate"))) (clojure.core/contains? input "awsJobExecutionsRolloutConfig") (clojure.core/assoc :aws-job-executions-rollout-config (deser-aws-job-executions-rollout-config (input "awsJobExecutionsRolloutConfig"))) (clojure.core/contains? input "targetSelection") (clojure.core/assoc :target-selection (deser-target-selection (input "targetSelection"))) (clojure.core/contains? input "otaUpdateId") (clojure.core/assoc :ota-update-id (deser-ota-update-id (input "otaUpdateId"))) (clojure.core/contains? input "otaUpdateStatus") (clojure.core/assoc :ota-update-status (deser-ota-update-status (input "otaUpdateStatus"))) (clojure.core/contains? input "otaUpdateFiles") (clojure.core/assoc :ota-update-files (deser-ota-update-files (input "otaUpdateFiles"))) (clojure.core/contains? input "errorInfo") (clojure.core/assoc :error-info (deser-error-info (input "errorInfo"))) (clojure.core/contains? input "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (input "lastModifiedDate"))) (clojure.core/contains? input "otaUpdateArn") (clojure.core/assoc :ota-update-arn (deser-ota-update-arn (input "otaUpdateArn"))) (clojure.core/contains? input "targets") (clojure.core/assoc :targets (deser-targets (input "targets"))) (clojure.core/contains? input "awsIotJobArn") (clojure.core/assoc :aws-iot-job-arn (deser-aws-iot-job-arn (input "awsIotJobArn"))) (clojure.core/contains? input "awsIotJobId") (clojure.core/assoc :aws-iot-job-id (deser-aws-iot-job-id (input "awsIotJobId"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-ota-update-description (input "description"))) (clojure.core/contains? input "additionalParameters") (clojure.core/assoc :additional-parameters (deser-additional-parameter-map (input "additionalParameters")))))

(clojure.core/defn- deser-signing-profile-name [input] input)

(clojure.core/defn- deser-effective-policy [input] (clojure.core/cond-> {} (clojure.core/contains? input "policyName") (clojure.core/assoc :policy-name (deser-policy-name (input "policyName"))) (clojure.core/contains? input "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (input "policyArn"))) (clojure.core/contains? input "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (input "policyDocument")))))

(clojure.core/defn- deser-details-map [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-details-key k) (deser-details-value v)])) input))

(clojure.core/defn- deser-consecutive-datapoints-to-clear [input] input)

(clojure.core/defn- deser-audit-check-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "enabled") (clojure.core/assoc :enabled (deser-enabled (input "enabled")))))

(clojure.core/defn- deser-audit-task-status [input] (clojure.core/get {"IN_PROGRESS" :in-progress, "COMPLETED" :completed, "FAILED" :failed, "CANCELED" :canceled} input))

(clojure.core/defn- deser-s-3-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :bucket-name (deser-bucket-name (input "bucketName")), :key (deser-key (input "key"))} (clojure.core/contains? input "cannedAcl") (clojure.core/assoc :canned-acl (deser-canned-access-control-list (input "cannedAcl")))))

(clojure.core/defn- deser-job-execution [input] (clojure.core/cond-> {} (clojure.core/contains? input "queuedAt") (clojure.core/assoc :queued-at (deser-date-type (input "queuedAt"))) (clojure.core/contains? input "startedAt") (clojure.core/assoc :started-at (deser-date-type (input "startedAt"))) (clojure.core/contains? input "approximateSecondsBeforeTimedOut") (clojure.core/assoc :approximate-seconds-before-timed-out (deser-approximate-seconds-before-timed-out (input "approximateSecondsBeforeTimedOut"))) (clojure.core/contains? input "statusDetails") (clojure.core/assoc :status-details (deser-job-execution-status-details (input "statusDetails"))) (clojure.core/contains? input "executionNumber") (clojure.core/assoc :execution-number (deser-execution-number (input "executionNumber"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-job-execution-status (input "status"))) (clojure.core/contains? input "lastUpdatedAt") (clojure.core/assoc :last-updated-at (deser-date-type (input "lastUpdatedAt"))) (clojure.core/contains? input "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (input "thingArn"))) (clojure.core/contains? input "jobId") (clojure.core/assoc :job-id (deser-job-id (input "jobId"))) (clojure.core/contains? input "versionNumber") (clojure.core/assoc :version-number (deser-version-number (input "versionNumber"))) (clojure.core/contains? input "forceCanceled") (clojure.core/assoc :force-canceled (deser-forced (input "forceCanceled")))))

(clojure.core/defn- deser-iot-analytics-action [input] (clojure.core/cond-> {} (clojure.core/contains? input "channelArn") (clojure.core/assoc :channel-arn (deser-aws-arn (input "channelArn"))) (clojure.core/contains? input "channelName") (clojure.core/assoc :channel-name (deser-channel-name (input "channelName"))) (clojure.core/contains? input "roleArn") (clojure.core/assoc :role-arn (deser-aws-arn (input "roleArn")))))

(clojure.core/defn- deser-security-profile-target-mapping [input] (clojure.core/cond-> {} (clojure.core/contains? input "securityProfileIdentifier") (clojure.core/assoc :security-profile-identifier (deser-security-profile-identifier (input "securityProfileIdentifier"))) (clojure.core/contains? input "target") (clojure.core/assoc :target (deser-security-profile-target (input "target")))))

(clojure.core/defn- deser-generation-id [input] input)

(clojure.core/defn- deser-kinesis-action [input] (clojure.core/cond-> {:role-arn (deser-aws-arn (input "roleArn")), :stream-name (deser-stream-name (input "streamName"))} (clojure.core/contains? input "partitionKey") (clojure.core/assoc :partition-key (deser-partition-key (input "partitionKey")))))

(clojure.core/defn- deser-ca-certificate [input] (clojure.core/cond-> {} (clojure.core/contains? input "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (input "certificateArn"))) (clojure.core/contains? input "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (input "certificateId"))) (clojure.core/contains? input "status") (clojure.core/assoc :status (deser-ca-certificate-status (input "status"))) (clojure.core/contains? input "creationDate") (clojure.core/assoc :creation-date (deser-date-type (input "creationDate")))))

(clojure.core/defn- deser-public-key [input] input)

(clojure.core/defn- deser-job-arn [input] input)

(clojure.core/defn- deser-valid [input] input)

(clojure.core/defn- deser-audit-task-id [input] input)

(clojure.core/defn- deser-payload-field [input] input)

(clojure.core/defn- deser-authorizer-function-arn [input] input)

(clojure.core/defn- deser-topic-rule-list-item [input] (clojure.core/cond-> {} (clojure.core/contains? input "ruleArn") (clojure.core/assoc :rule-arn (deser-rule-arn (input "ruleArn"))) (clojure.core/contains? input "ruleName") (clojure.core/assoc :rule-name (deser-rule-name (input "ruleName"))) (clojure.core/contains? input "topicPattern") (clojure.core/assoc :topic-pattern (deser-topic-pattern (input "topicPattern"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-created-at-date (input "createdAt"))) (clojure.core/contains? input "ruleDisabled") (clojure.core/assoc :rule-disabled (deser-is-disabled (input "ruleDisabled")))))

(clojure.core/defn- deser-is-authenticated [input] input)

(clojure.core/defn- deser-firehose-separator [input] input)

(clojure.core/defn- deser-seconds [input] input)

(clojure.core/defn- deser-auth-result [input] (clojure.core/cond-> {} (clojure.core/contains? input "authInfo") (clojure.core/assoc :auth-info (deser-auth-info (input "authInfo"))) (clojure.core/contains? input "allowed") (clojure.core/assoc :allowed (deser-allowed (input "allowed"))) (clojure.core/contains? input "denied") (clojure.core/assoc :denied (deser-denied (input "denied"))) (clojure.core/contains? input "authDecision") (clojure.core/assoc :auth-decision (deser-auth-decision (input "authDecision"))) (clojure.core/contains? input "missingContextValues") (clojure.core/assoc :missing-context-values (deser-missing-context-values (input "missingContextValues")))))

(clojure.core/defn- deser-principals [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-principal-arn coll))) input))

(clojure.core/defn- deser-validation-errors [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-validation-error coll))) input))

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- deser-topic-rule [input] (clojure.core/cond-> {} (clojure.core/contains? input "ruleName") (clojure.core/assoc :rule-name (deser-rule-name (input "ruleName"))) (clojure.core/contains? input "sql") (clojure.core/assoc :sql (deser-sql (input "sql"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-description (input "description"))) (clojure.core/contains? input "createdAt") (clojure.core/assoc :created-at (deser-created-at-date (input "createdAt"))) (clojure.core/contains? input "actions") (clojure.core/assoc :actions (deser-action-list (input "actions"))) (clojure.core/contains? input "ruleDisabled") (clojure.core/assoc :rule-disabled (deser-is-disabled (input "ruleDisabled"))) (clojure.core/contains? input "awsIotSqlVersion") (clojure.core/assoc :aws-iot-sql-version (deser-aws-iot-sql-version (input "awsIotSqlVersion"))) (clojure.core/contains? input "errorAction") (clojure.core/assoc :error-action (deser-action (input "errorAction")))))

(clojure.core/defn- deser-registration-code [input] input)

(clojure.core/defn- deser-job-id [input] input)

(clojure.core/defn- response-delete-stream-response ([input] (response-delete-stream-response nil input)) ([resultWrapper1204876 input] (clojure.core/let [rawinput1204875 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204877 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-effective-policies-response ([input] (response-get-effective-policies-response nil input)) ([resultWrapper1204879 input] (clojure.core/let [rawinput1204878 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204880 {"effectivePolicies" (rawinput1204878 "effectivePolicies")}] (clojure.core/cond-> {} (letvar1204880 "effectivePolicies") (clojure.core/assoc :effective-policies (deser-effective-policies (clojure.core/get-in letvar1204880 ["effectivePolicies"])))))))

(clojure.core/defn- response-list-policy-versions-response ([input] (response-list-policy-versions-response nil input)) ([resultWrapper1204882 input] (clojure.core/let [rawinput1204881 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204883 {"policyVersions" (rawinput1204881 "policyVersions")}] (clojure.core/cond-> {} (letvar1204883 "policyVersions") (clojure.core/assoc :policy-versions (deser-policy-versions (clojure.core/get-in letvar1204883 ["policyVersions"])))))))

(clojure.core/defn- response-delete-scheduled-audit-response ([input] (response-delete-scheduled-audit-response nil input)) ([resultWrapper1204885 input] (clojure.core/let [rawinput1204884 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204886 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-event-configurations-response ([input] (response-describe-event-configurations-response nil input)) ([resultWrapper1204888 input] (clojure.core/let [rawinput1204887 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204889 {"eventConfigurations" (rawinput1204887 "eventConfigurations"), "creationDate" (rawinput1204887 "creationDate"), "lastModifiedDate" (rawinput1204887 "lastModifiedDate")}] (clojure.core/cond-> {} (letvar1204889 "eventConfigurations") (clojure.core/assoc :event-configurations (deser-event-configurations (clojure.core/get-in letvar1204889 ["eventConfigurations"]))) (letvar1204889 "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (clojure.core/get-in letvar1204889 ["creationDate"]))) (letvar1204889 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-last-modified-date (clojure.core/get-in letvar1204889 ["lastModifiedDate"])))))))

(clojure.core/defn- response-unauthorized-exception ([input] (response-unauthorized-exception nil input)) ([resultWrapper1204891 input] (clojure.core/let [rawinput1204890 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204892 {"message" (rawinput1204890 "message")}] (clojure.core/cond-> {} (letvar1204892 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1204892 ["message"])))))))

(clojure.core/defn- response-update-security-profile-response ([input] (response-update-security-profile-response nil input)) ([resultWrapper1204894 input] (clojure.core/let [rawinput1204893 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204895 {"creationDate" (rawinput1204893 "creationDate"), "securityProfileArn" (rawinput1204893 "securityProfileArn"), "additionalMetricsToRetain" (rawinput1204893 "additionalMetricsToRetain"), "behaviors" (rawinput1204893 "behaviors"), "lastModifiedDate" (rawinput1204893 "lastModifiedDate"), "securityProfileDescription" (rawinput1204893 "securityProfileDescription"), "version" (rawinput1204893 "version"), "securityProfileName" (rawinput1204893 "securityProfileName"), "alertTargets" (rawinput1204893 "alertTargets")}] (clojure.core/cond-> {} (letvar1204895 "creationDate") (clojure.core/assoc :creation-date (deser-timestamp (clojure.core/get-in letvar1204895 ["creationDate"]))) (letvar1204895 "securityProfileArn") (clojure.core/assoc :security-profile-arn (deser-security-profile-arn (clojure.core/get-in letvar1204895 ["securityProfileArn"]))) (letvar1204895 "additionalMetricsToRetain") (clojure.core/assoc :additional-metrics-to-retain (deser-additional-metrics-to-retain-list (clojure.core/get-in letvar1204895 ["additionalMetricsToRetain"]))) (letvar1204895 "behaviors") (clojure.core/assoc :behaviors (deser-behaviors (clojure.core/get-in letvar1204895 ["behaviors"]))) (letvar1204895 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-timestamp (clojure.core/get-in letvar1204895 ["lastModifiedDate"]))) (letvar1204895 "securityProfileDescription") (clojure.core/assoc :security-profile-description (deser-security-profile-description (clojure.core/get-in letvar1204895 ["securityProfileDescription"]))) (letvar1204895 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1204895 ["version"]))) (letvar1204895 "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (clojure.core/get-in letvar1204895 ["securityProfileName"]))) (letvar1204895 "alertTargets") (clojure.core/assoc :alert-targets (deser-alert-targets (clojure.core/get-in letvar1204895 ["alertTargets"])))))))

(clojure.core/defn- response-list-targets-for-policy-response ([input] (response-list-targets-for-policy-response nil input)) ([resultWrapper1204897 input] (clojure.core/let [rawinput1204896 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204898 {"targets" (rawinput1204896 "targets"), "nextMarker" (rawinput1204896 "nextMarker")}] (clojure.core/cond-> {} (letvar1204898 "targets") (clojure.core/assoc :targets (deser-policy-targets (clojure.core/get-in letvar1204898 ["targets"]))) (letvar1204898 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1204898 ["nextMarker"])))))))

(clojure.core/defn- response-detach-thing-principal-response ([input] (response-detach-thing-principal-response nil input)) ([resultWrapper1204900 input] (clojure.core/let [rawinput1204899 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204901 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-thing-registration-task-response ([input] (response-start-thing-registration-task-response nil input)) ([resultWrapper1204903 input] (clojure.core/let [rawinput1204902 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204904 {"taskId" (rawinput1204902 "taskId")}] (clojure.core/cond-> {} (letvar1204904 "taskId") (clojure.core/assoc :task-id (deser-task-id (clojure.core/get-in letvar1204904 ["taskId"])))))))

(clojure.core/defn- response-list-thing-groups-response ([input] (response-list-thing-groups-response nil input)) ([resultWrapper1204906 input] (clojure.core/let [rawinput1204905 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204907 {"thingGroups" (rawinput1204905 "thingGroups"), "nextToken" (rawinput1204905 "nextToken")}] (clojure.core/cond-> {} (letvar1204907 "thingGroups") (clojure.core/assoc :thing-groups (deser-thing-group-name-and-arn-list (clojure.core/get-in letvar1204907 ["thingGroups"]))) (letvar1204907 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204907 ["nextToken"])))))))

(clojure.core/defn- response-delete-registration-code-response ([input] (response-delete-registration-code-response nil input)) ([resultWrapper1204909 input] (clojure.core/let [rawinput1204908 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204910 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-security-profiles-for-target-response ([input] (response-list-security-profiles-for-target-response nil input)) ([resultWrapper1204912 input] (clojure.core/let [rawinput1204911 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204913 {"securityProfileTargetMappings" (rawinput1204911 "securityProfileTargetMappings"), "nextToken" (rawinput1204911 "nextToken")}] (clojure.core/cond-> {} (letvar1204913 "securityProfileTargetMappings") (clojure.core/assoc :security-profile-target-mappings (deser-security-profile-target-mappings (clojure.core/get-in letvar1204913 ["securityProfileTargetMappings"]))) (letvar1204913 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204913 ["nextToken"])))))))

(clojure.core/defn- response-list-principal-things-response ([input] (response-list-principal-things-response nil input)) ([resultWrapper1204915 input] (clojure.core/let [rawinput1204914 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204916 {"things" (rawinput1204914 "things"), "nextToken" (rawinput1204914 "nextToken")}] (clojure.core/cond-> {} (letvar1204916 "things") (clojure.core/assoc :things (deser-thing-name-list (clojure.core/get-in letvar1204916 ["things"]))) (letvar1204916 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204916 ["nextToken"])))))))

(clojure.core/defn- response-create-billing-group-response ([input] (response-create-billing-group-response nil input)) ([resultWrapper1204918 input] (clojure.core/let [rawinput1204917 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204919 {"billingGroupName" (rawinput1204917 "billingGroupName"), "billingGroupArn" (rawinput1204917 "billingGroupArn"), "billingGroupId" (rawinput1204917 "billingGroupId")}] (clojure.core/cond-> {} (letvar1204919 "billingGroupName") (clojure.core/assoc :billing-group-name (deser-billing-group-name (clojure.core/get-in letvar1204919 ["billingGroupName"]))) (letvar1204919 "billingGroupArn") (clojure.core/assoc :billing-group-arn (deser-billing-group-arn (clojure.core/get-in letvar1204919 ["billingGroupArn"]))) (letvar1204919 "billingGroupId") (clojure.core/assoc :billing-group-id (deser-billing-group-id (clojure.core/get-in letvar1204919 ["billingGroupId"])))))))

(clojure.core/defn- response-create-ota-update-response ([input] (response-create-ota-update-response nil input)) ([resultWrapper1204921 input] (clojure.core/let [rawinput1204920 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204922 {"otaUpdateId" (rawinput1204920 "otaUpdateId"), "awsIotJobId" (rawinput1204920 "awsIotJobId"), "otaUpdateArn" (rawinput1204920 "otaUpdateArn"), "awsIotJobArn" (rawinput1204920 "awsIotJobArn"), "otaUpdateStatus" (rawinput1204920 "otaUpdateStatus")}] (clojure.core/cond-> {} (letvar1204922 "otaUpdateId") (clojure.core/assoc :ota-update-id (deser-ota-update-id (clojure.core/get-in letvar1204922 ["otaUpdateId"]))) (letvar1204922 "awsIotJobId") (clojure.core/assoc :aws-iot-job-id (deser-aws-iot-job-id (clojure.core/get-in letvar1204922 ["awsIotJobId"]))) (letvar1204922 "otaUpdateArn") (clojure.core/assoc :ota-update-arn (deser-ota-update-arn (clojure.core/get-in letvar1204922 ["otaUpdateArn"]))) (letvar1204922 "awsIotJobArn") (clojure.core/assoc :aws-iot-job-arn (deser-aws-iot-job-arn (clojure.core/get-in letvar1204922 ["awsIotJobArn"]))) (letvar1204922 "otaUpdateStatus") (clojure.core/assoc :ota-update-status (deser-ota-update-status (clojure.core/get-in letvar1204922 ["otaUpdateStatus"])))))))

(clojure.core/defn- response-cancel-job-response ([input] (response-cancel-job-response nil input)) ([resultWrapper1204924 input] (clojure.core/let [rawinput1204923 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204925 {"jobArn" (rawinput1204923 "jobArn"), "jobId" (rawinput1204923 "jobId"), "description" (rawinput1204923 "description")}] (clojure.core/cond-> {} (letvar1204925 "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (clojure.core/get-in letvar1204925 ["jobArn"]))) (letvar1204925 "jobId") (clojure.core/assoc :job-id (deser-job-id (clojure.core/get-in letvar1204925 ["jobId"]))) (letvar1204925 "description") (clojure.core/assoc :description (deser-job-description (clojure.core/get-in letvar1204925 ["description"])))))))

(clojure.core/defn- response-list-scheduled-audits-response ([input] (response-list-scheduled-audits-response nil input)) ([resultWrapper1204927 input] (clojure.core/let [rawinput1204926 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204928 {"scheduledAudits" (rawinput1204926 "scheduledAudits"), "nextToken" (rawinput1204926 "nextToken")}] (clojure.core/cond-> {} (letvar1204928 "scheduledAudits") (clojure.core/assoc :scheduled-audits (deser-scheduled-audit-metadata-list (clojure.core/get-in letvar1204928 ["scheduledAudits"]))) (letvar1204928 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204928 ["nextToken"])))))))

(clojure.core/defn- response-list-targets-for-security-profile-response ([input] (response-list-targets-for-security-profile-response nil input)) ([resultWrapper1204930 input] (clojure.core/let [rawinput1204929 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204931 {"securityProfileTargets" (rawinput1204929 "securityProfileTargets"), "nextToken" (rawinput1204929 "nextToken")}] (clojure.core/cond-> {} (letvar1204931 "securityProfileTargets") (clojure.core/assoc :security-profile-targets (deser-security-profile-targets (clojure.core/get-in letvar1204931 ["securityProfileTargets"]))) (letvar1204931 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204931 ["nextToken"])))))))

(clojure.core/defn- response-create-role-alias-response ([input] (response-create-role-alias-response nil input)) ([resultWrapper1204933 input] (clojure.core/let [rawinput1204932 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204934 {"roleAlias" (rawinput1204932 "roleAlias"), "roleAliasArn" (rawinput1204932 "roleAliasArn")}] (clojure.core/cond-> {} (letvar1204934 "roleAlias") (clojure.core/assoc :role-alias (deser-role-alias (clojure.core/get-in letvar1204934 ["roleAlias"]))) (letvar1204934 "roleAliasArn") (clojure.core/assoc :role-alias-arn (deser-role-alias-arn (clojure.core/get-in letvar1204934 ["roleAliasArn"])))))))

(clojure.core/defn- response-describe-thing-response ([input] (response-describe-thing-response nil input)) ([resultWrapper1204936 input] (clojure.core/let [rawinput1204935 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204937 {"defaultClientId" (rawinput1204935 "defaultClientId"), "thingName" (rawinput1204935 "thingName"), "thingId" (rawinput1204935 "thingId"), "thingArn" (rawinput1204935 "thingArn"), "thingTypeName" (rawinput1204935 "thingTypeName"), "attributes" (rawinput1204935 "attributes"), "version" (rawinput1204935 "version"), "billingGroupName" (rawinput1204935 "billingGroupName")}] (clojure.core/cond-> {} (letvar1204937 "defaultClientId") (clojure.core/assoc :default-client-id (deser-client-id (clojure.core/get-in letvar1204937 ["defaultClientId"]))) (letvar1204937 "thingName") (clojure.core/assoc :thing-name (deser-thing-name (clojure.core/get-in letvar1204937 ["thingName"]))) (letvar1204937 "thingId") (clojure.core/assoc :thing-id (deser-thing-id (clojure.core/get-in letvar1204937 ["thingId"]))) (letvar1204937 "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (clojure.core/get-in letvar1204937 ["thingArn"]))) (letvar1204937 "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (clojure.core/get-in letvar1204937 ["thingTypeName"]))) (letvar1204937 "attributes") (clojure.core/assoc :attributes (deser-attributes (clojure.core/get-in letvar1204937 ["attributes"]))) (letvar1204937 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1204937 ["version"]))) (letvar1204937 "billingGroupName") (clojure.core/assoc :billing-group-name (deser-billing-group-name (clojure.core/get-in letvar1204937 ["billingGroupName"])))))))

(clojure.core/defn- response-certificate-state-exception ([input] (response-certificate-state-exception nil input)) ([resultWrapper1204939 input] (clojure.core/let [rawinput1204938 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204940 {"message" (rawinput1204938 "message")}] (clojure.core/cond-> {} (letvar1204940 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1204940 ["message"])))))))

(clojure.core/defn- response-test-invoke-authorizer-response ([input] (response-test-invoke-authorizer-response nil input)) ([resultWrapper1204942 input] (clojure.core/let [rawinput1204941 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204943 {"isAuthenticated" (rawinput1204941 "isAuthenticated"), "principalId" (rawinput1204941 "principalId"), "policyDocuments" (rawinput1204941 "policyDocuments"), "refreshAfterInSeconds" (rawinput1204941 "refreshAfterInSeconds"), "disconnectAfterInSeconds" (rawinput1204941 "disconnectAfterInSeconds")}] (clojure.core/cond-> {} (letvar1204943 "isAuthenticated") (clojure.core/assoc :is-authenticated (deser-is-authenticated (clojure.core/get-in letvar1204943 ["isAuthenticated"]))) (letvar1204943 "principalId") (clojure.core/assoc :principal-id (deser-principal-id (clojure.core/get-in letvar1204943 ["principalId"]))) (letvar1204943 "policyDocuments") (clojure.core/assoc :policy-documents (deser-policy-documents (clojure.core/get-in letvar1204943 ["policyDocuments"]))) (letvar1204943 "refreshAfterInSeconds") (clojure.core/assoc :refresh-after-in-seconds (deser-seconds (clojure.core/get-in letvar1204943 ["refreshAfterInSeconds"]))) (letvar1204943 "disconnectAfterInSeconds") (clojure.core/assoc :disconnect-after-in-seconds (deser-seconds (clojure.core/get-in letvar1204943 ["disconnectAfterInSeconds"])))))))

(clojure.core/defn- response-invalid-request-exception ([input] (response-invalid-request-exception nil input)) ([resultWrapper1204945 input] (clojure.core/let [rawinput1204944 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204946 {"message" (rawinput1204944 "message")}] (clojure.core/cond-> {} (letvar1204946 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1204946 ["message"])))))))

(clojure.core/defn- response-cancel-audit-task-response ([input] (response-cancel-audit-task-response nil input)) ([resultWrapper1204948 input] (clojure.core/let [rawinput1204947 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204949 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-tags-for-resource-response ([input] (response-list-tags-for-resource-response nil input)) ([resultWrapper1204951 input] (clojure.core/let [rawinput1204950 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204952 {"tags" (rawinput1204950 "tags"), "nextToken" (rawinput1204950 "nextToken")}] (clojure.core/cond-> {} (letvar1204952 "tags") (clojure.core/assoc :tags (deser-tag-list (clojure.core/get-in letvar1204952 ["tags"]))) (letvar1204952 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204952 ["nextToken"])))))))

(clojure.core/defn- response-certificate-validation-exception ([input] (response-certificate-validation-exception nil input)) ([resultWrapper1204954 input] (clojure.core/let [rawinput1204953 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204955 {"message" (rawinput1204953 "message")}] (clojure.core/cond-> {} (letvar1204955 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1204955 ["message"])))))))

(clojure.core/defn- response-update-thing-group-response ([input] (response-update-thing-group-response nil input)) ([resultWrapper1204957 input] (clojure.core/let [rawinput1204956 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204958 {"version" (rawinput1204956 "version")}] (clojure.core/cond-> {} (letvar1204958 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1204958 ["version"])))))))

(clojure.core/defn- response-get-logging-options-response ([input] (response-get-logging-options-response nil input)) ([resultWrapper1204960 input] (clojure.core/let [rawinput1204959 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204961 {"roleArn" (rawinput1204959 "roleArn"), "logLevel" (rawinput1204959 "logLevel")}] (clojure.core/cond-> {} (letvar1204961 "roleArn") (clojure.core/assoc :role-arn (deser-aws-arn (clojure.core/get-in letvar1204961 ["roleArn"]))) (letvar1204961 "logLevel") (clojure.core/assoc :log-level (deser-log-level (clojure.core/get-in letvar1204961 ["logLevel"])))))))

(clojure.core/defn- response-get-v-2-logging-options-response ([input] (response-get-v-2-logging-options-response nil input)) ([resultWrapper1204963 input] (clojure.core/let [rawinput1204962 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204964 {"roleArn" (rawinput1204962 "roleArn"), "defaultLogLevel" (rawinput1204962 "defaultLogLevel"), "disableAllLogs" (rawinput1204962 "disableAllLogs")}] (clojure.core/cond-> {} (letvar1204964 "roleArn") (clojure.core/assoc :role-arn (deser-aws-arn (clojure.core/get-in letvar1204964 ["roleArn"]))) (letvar1204964 "defaultLogLevel") (clojure.core/assoc :default-log-level (deser-log-level (clojure.core/get-in letvar1204964 ["defaultLogLevel"]))) (letvar1204964 "disableAllLogs") (clojure.core/assoc :disable-all-logs (deser-disable-all-logs (clojure.core/get-in letvar1204964 ["disableAllLogs"])))))))

(clojure.core/defn- response-list-thing-groups-for-thing-response ([input] (response-list-thing-groups-for-thing-response nil input)) ([resultWrapper1204966 input] (clojure.core/let [rawinput1204965 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204967 {"thingGroups" (rawinput1204965 "thingGroups"), "nextToken" (rawinput1204965 "nextToken")}] (clojure.core/cond-> {} (letvar1204967 "thingGroups") (clojure.core/assoc :thing-groups (deser-thing-group-name-and-arn-list (clojure.core/get-in letvar1204967 ["thingGroups"]))) (letvar1204967 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204967 ["nextToken"])))))))

(clojure.core/defn- response-describe-account-audit-configuration-response ([input] (response-describe-account-audit-configuration-response nil input)) ([resultWrapper1204969 input] (clojure.core/let [rawinput1204968 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204970 {"roleArn" (rawinput1204968 "roleArn"), "auditNotificationTargetConfigurations" (rawinput1204968 "auditNotificationTargetConfigurations"), "auditCheckConfigurations" (rawinput1204968 "auditCheckConfigurations")}] (clojure.core/cond-> {} (letvar1204970 "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (clojure.core/get-in letvar1204970 ["roleArn"]))) (letvar1204970 "auditNotificationTargetConfigurations") (clojure.core/assoc :audit-notification-target-configurations (deser-audit-notification-target-configurations (clojure.core/get-in letvar1204970 ["auditNotificationTargetConfigurations"]))) (letvar1204970 "auditCheckConfigurations") (clojure.core/assoc :audit-check-configurations (deser-audit-check-configurations (clojure.core/get-in letvar1204970 ["auditCheckConfigurations"])))))))

(clojure.core/defn- response-describe-index-response ([input] (response-describe-index-response nil input)) ([resultWrapper1204972 input] (clojure.core/let [rawinput1204971 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204973 {"indexName" (rawinput1204971 "indexName"), "indexStatus" (rawinput1204971 "indexStatus"), "schema" (rawinput1204971 "schema")}] (clojure.core/cond-> {} (letvar1204973 "indexName") (clojure.core/assoc :index-name (deser-index-name (clojure.core/get-in letvar1204973 ["indexName"]))) (letvar1204973 "indexStatus") (clojure.core/assoc :index-status (deser-index-status (clojure.core/get-in letvar1204973 ["indexStatus"]))) (letvar1204973 "schema") (clojure.core/assoc :schema (deser-index-schema (clojure.core/get-in letvar1204973 ["schema"])))))))

(clojure.core/defn- response-list-certificates-response ([input] (response-list-certificates-response nil input)) ([resultWrapper1204975 input] (clojure.core/let [rawinput1204974 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204976 {"certificates" (rawinput1204974 "certificates"), "nextMarker" (rawinput1204974 "nextMarker")}] (clojure.core/cond-> {} (letvar1204976 "certificates") (clojure.core/assoc :certificates (deser-certificates (clojure.core/get-in letvar1204976 ["certificates"]))) (letvar1204976 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1204976 ["nextMarker"])))))))

(clojure.core/defn- response-list-things-in-billing-group-response ([input] (response-list-things-in-billing-group-response nil input)) ([resultWrapper1204978 input] (clojure.core/let [rawinput1204977 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204979 {"things" (rawinput1204977 "things"), "nextToken" (rawinput1204977 "nextToken")}] (clojure.core/cond-> {} (letvar1204979 "things") (clojure.core/assoc :things (deser-thing-name-list (clojure.core/get-in letvar1204979 ["things"]))) (letvar1204979 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204979 ["nextToken"])))))))

(clojure.core/defn- response-describe-audit-task-response ([input] (response-describe-audit-task-response nil input)) ([resultWrapper1204981 input] (clojure.core/let [rawinput1204980 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204982 {"taskStatus" (rawinput1204980 "taskStatus"), "taskType" (rawinput1204980 "taskType"), "taskStartTime" (rawinput1204980 "taskStartTime"), "taskStatistics" (rawinput1204980 "taskStatistics"), "scheduledAuditName" (rawinput1204980 "scheduledAuditName"), "auditDetails" (rawinput1204980 "auditDetails")}] (clojure.core/cond-> {} (letvar1204982 "taskStatus") (clojure.core/assoc :task-status (deser-audit-task-status (clojure.core/get-in letvar1204982 ["taskStatus"]))) (letvar1204982 "taskType") (clojure.core/assoc :task-type (deser-audit-task-type (clojure.core/get-in letvar1204982 ["taskType"]))) (letvar1204982 "taskStartTime") (clojure.core/assoc :task-start-time (deser-timestamp (clojure.core/get-in letvar1204982 ["taskStartTime"]))) (letvar1204982 "taskStatistics") (clojure.core/assoc :task-statistics (deser-task-statistics (clojure.core/get-in letvar1204982 ["taskStatistics"]))) (letvar1204982 "scheduledAuditName") (clojure.core/assoc :scheduled-audit-name (deser-scheduled-audit-name (clojure.core/get-in letvar1204982 ["scheduledAuditName"]))) (letvar1204982 "auditDetails") (clojure.core/assoc :audit-details (deser-audit-details (clojure.core/get-in letvar1204982 ["auditDetails"])))))))

(clojure.core/defn- response-get-topic-rule-response ([input] (response-get-topic-rule-response nil input)) ([resultWrapper1204984 input] (clojure.core/let [rawinput1204983 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204985 {"ruleArn" (rawinput1204983 "ruleArn"), "rule" (rawinput1204983 "rule")}] (clojure.core/cond-> {} (letvar1204985 "ruleArn") (clojure.core/assoc :rule-arn (deser-rule-arn (clojure.core/get-in letvar1204985 ["ruleArn"]))) (letvar1204985 "rule") (clojure.core/assoc :rule (deser-topic-rule (clojure.core/get-in letvar1204985 ["rule"])))))))

(clojure.core/defn- response-list-things-in-thing-group-response ([input] (response-list-things-in-thing-group-response nil input)) ([resultWrapper1204987 input] (clojure.core/let [rawinput1204986 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204988 {"things" (rawinput1204986 "things"), "nextToken" (rawinput1204986 "nextToken")}] (clojure.core/cond-> {} (letvar1204988 "things") (clojure.core/assoc :things (deser-thing-name-list (clojure.core/get-in letvar1204988 ["things"]))) (letvar1204988 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204988 ["nextToken"])))))))

(clojure.core/defn- response-describe-ca-certificate-response ([input] (response-describe-ca-certificate-response nil input)) ([resultWrapper1204990 input] (clojure.core/let [rawinput1204989 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204991 {"certificateDescription" (rawinput1204989 "certificateDescription"), "registrationConfig" (rawinput1204989 "registrationConfig")}] (clojure.core/cond-> {} (letvar1204991 "certificateDescription") (clojure.core/assoc :certificate-description (deser-ca-certificate-description (clojure.core/get-in letvar1204991 ["certificateDescription"]))) (letvar1204991 "registrationConfig") (clojure.core/assoc :registration-config (deser-registration-config (clojure.core/get-in letvar1204991 ["registrationConfig"])))))))

(clojure.core/defn- response-list-streams-response ([input] (response-list-streams-response nil input)) ([resultWrapper1204993 input] (clojure.core/let [rawinput1204992 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204994 {"streams" (rawinput1204992 "streams"), "nextToken" (rawinput1204992 "nextToken")}] (clojure.core/cond-> {} (letvar1204994 "streams") (clojure.core/assoc :streams (deser-streams-summary (clojure.core/get-in letvar1204994 ["streams"]))) (letvar1204994 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1204994 ["nextToken"])))))))

(clojure.core/defn- response-create-job-response ([input] (response-create-job-response nil input)) ([resultWrapper1204996 input] (clojure.core/let [rawinput1204995 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1204997 {"jobArn" (rawinput1204995 "jobArn"), "jobId" (rawinput1204995 "jobId"), "description" (rawinput1204995 "description")}] (clojure.core/cond-> {} (letvar1204997 "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (clojure.core/get-in letvar1204997 ["jobArn"]))) (letvar1204997 "jobId") (clojure.core/assoc :job-id (deser-job-id (clojure.core/get-in letvar1204997 ["jobId"]))) (letvar1204997 "description") (clojure.core/assoc :description (deser-job-description (clojure.core/get-in letvar1204997 ["description"])))))))

(clojure.core/defn- response-update-role-alias-response ([input] (response-update-role-alias-response nil input)) ([resultWrapper1204999 input] (clojure.core/let [rawinput1204998 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205000 {"roleAlias" (rawinput1204998 "roleAlias"), "roleAliasArn" (rawinput1204998 "roleAliasArn")}] (clojure.core/cond-> {} (letvar1205000 "roleAlias") (clojure.core/assoc :role-alias (deser-role-alias (clojure.core/get-in letvar1205000 ["roleAlias"]))) (letvar1205000 "roleAliasArn") (clojure.core/assoc :role-alias-arn (deser-role-alias-arn (clojure.core/get-in letvar1205000 ["roleAliasArn"])))))))

(clojure.core/defn- response-list-indices-response ([input] (response-list-indices-response nil input)) ([resultWrapper1205002 input] (clojure.core/let [rawinput1205001 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205003 {"indexNames" (rawinput1205001 "indexNames"), "nextToken" (rawinput1205001 "nextToken")}] (clojure.core/cond-> {} (letvar1205003 "indexNames") (clojure.core/assoc :index-names (deser-index-names-list (clojure.core/get-in letvar1205003 ["indexNames"]))) (letvar1205003 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205003 ["nextToken"])))))))

(clojure.core/defn- response-invalid-query-exception ([input] (response-invalid-query-exception nil input)) ([resultWrapper1205005 input] (clojure.core/let [rawinput1205004 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205006 {"message" (rawinput1205004 "message")}] (clojure.core/cond-> {} (letvar1205006 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205006 ["message"])))))))

(clojure.core/defn- response-list-violation-events-response ([input] (response-list-violation-events-response nil input)) ([resultWrapper1205008 input] (clojure.core/let [rawinput1205007 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205009 {"violationEvents" (rawinput1205007 "violationEvents"), "nextToken" (rawinput1205007 "nextToken")}] (clojure.core/cond-> {} (letvar1205009 "violationEvents") (clojure.core/assoc :violation-events (deser-violation-events (clojure.core/get-in letvar1205009 ["violationEvents"]))) (letvar1205009 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205009 ["nextToken"])))))))

(clojure.core/defn- response-describe-thing-registration-task-response ([input] (response-describe-thing-registration-task-response nil input)) ([resultWrapper1205011 input] (clojure.core/let [rawinput1205010 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205012 {"message" (rawinput1205010 "message"), "creationDate" (rawinput1205010 "creationDate"), "templateBody" (rawinput1205010 "templateBody"), "inputFileBucket" (rawinput1205010 "inputFileBucket"), "roleArn" (rawinput1205010 "roleArn"), "lastModifiedDate" (rawinput1205010 "lastModifiedDate"), "status" (rawinput1205010 "status"), "successCount" (rawinput1205010 "successCount"), "failureCount" (rawinput1205010 "failureCount"), "percentageProgress" (rawinput1205010 "percentageProgress"), "inputFileKey" (rawinput1205010 "inputFileKey"), "taskId" (rawinput1205010 "taskId")}] (clojure.core/cond-> {} (letvar1205012 "message") (clojure.core/assoc :message (deser-error-message (clojure.core/get-in letvar1205012 ["message"]))) (letvar1205012 "creationDate") (clojure.core/assoc :creation-date (deser-creation-date (clojure.core/get-in letvar1205012 ["creationDate"]))) (letvar1205012 "templateBody") (clojure.core/assoc :template-body (deser-template-body (clojure.core/get-in letvar1205012 ["templateBody"]))) (letvar1205012 "inputFileBucket") (clojure.core/assoc :input-file-bucket (deser-registry-s-3-bucket-name (clojure.core/get-in letvar1205012 ["inputFileBucket"]))) (letvar1205012 "roleArn") (clojure.core/assoc :role-arn (deser-role-arn (clojure.core/get-in letvar1205012 ["roleArn"]))) (letvar1205012 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-last-modified-date (clojure.core/get-in letvar1205012 ["lastModifiedDate"]))) (letvar1205012 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar1205012 ["status"]))) (letvar1205012 "successCount") (clojure.core/assoc :success-count (deser-count (clojure.core/get-in letvar1205012 ["successCount"]))) (letvar1205012 "failureCount") (clojure.core/assoc :failure-count (deser-count (clojure.core/get-in letvar1205012 ["failureCount"]))) (letvar1205012 "percentageProgress") (clojure.core/assoc :percentage-progress (deser-percentage (clojure.core/get-in letvar1205012 ["percentageProgress"]))) (letvar1205012 "inputFileKey") (clojure.core/assoc :input-file-key (deser-registry-s-3-key-name (clojure.core/get-in letvar1205012 ["inputFileKey"]))) (letvar1205012 "taskId") (clojure.core/assoc :task-id (deser-task-id (clojure.core/get-in letvar1205012 ["taskId"])))))))

(clojure.core/defn- response-create-stream-response ([input] (response-create-stream-response nil input)) ([resultWrapper1205014 input] (clojure.core/let [rawinput1205013 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205015 {"streamId" (rawinput1205013 "streamId"), "streamArn" (rawinput1205013 "streamArn"), "description" (rawinput1205013 "description"), "streamVersion" (rawinput1205013 "streamVersion")}] (clojure.core/cond-> {} (letvar1205015 "streamId") (clojure.core/assoc :stream-id (deser-stream-id (clojure.core/get-in letvar1205015 ["streamId"]))) (letvar1205015 "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (clojure.core/get-in letvar1205015 ["streamArn"]))) (letvar1205015 "description") (clojure.core/assoc :description (deser-stream-description (clojure.core/get-in letvar1205015 ["description"]))) (letvar1205015 "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (clojure.core/get-in letvar1205015 ["streamVersion"])))))))

(clojure.core/defn- response-update-event-configurations-response ([input] (response-update-event-configurations-response nil input)) ([resultWrapper1205017 input] (clojure.core/let [rawinput1205016 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205018 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-principal-policies-response ([input] (response-list-principal-policies-response nil input)) ([resultWrapper1205020 input] (clojure.core/let [rawinput1205019 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205021 {"policies" (rawinput1205019 "policies"), "nextMarker" (rawinput1205019 "nextMarker")}] (clojure.core/cond-> {} (letvar1205021 "policies") (clojure.core/assoc :policies (deser-policies (clojure.core/get-in letvar1205021 ["policies"]))) (letvar1205021 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205021 ["nextMarker"])))))))

(clojure.core/defn- response-update-stream-response ([input] (response-update-stream-response nil input)) ([resultWrapper1205023 input] (clojure.core/let [rawinput1205022 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205024 {"streamId" (rawinput1205022 "streamId"), "streamArn" (rawinput1205022 "streamArn"), "description" (rawinput1205022 "description"), "streamVersion" (rawinput1205022 "streamVersion")}] (clojure.core/cond-> {} (letvar1205024 "streamId") (clojure.core/assoc :stream-id (deser-stream-id (clojure.core/get-in letvar1205024 ["streamId"]))) (letvar1205024 "streamArn") (clojure.core/assoc :stream-arn (deser-stream-arn (clojure.core/get-in letvar1205024 ["streamArn"]))) (letvar1205024 "description") (clojure.core/assoc :description (deser-stream-description (clojure.core/get-in letvar1205024 ["description"]))) (letvar1205024 "streamVersion") (clojure.core/assoc :stream-version (deser-stream-version (clojure.core/get-in letvar1205024 ["streamVersion"])))))))

(clojure.core/defn- response-delete-conflict-exception ([input] (response-delete-conflict-exception nil input)) ([resultWrapper1205026 input] (clojure.core/let [rawinput1205025 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205027 {"message" (rawinput1205025 "message")}] (clojure.core/cond-> {} (letvar1205027 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205027 ["message"])))))))

(clojure.core/defn- response-list-thing-registration-tasks-response ([input] (response-list-thing-registration-tasks-response nil input)) ([resultWrapper1205029 input] (clojure.core/let [rawinput1205028 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205030 {"taskIds" (rawinput1205028 "taskIds"), "nextToken" (rawinput1205028 "nextToken")}] (clojure.core/cond-> {} (letvar1205030 "taskIds") (clojure.core/assoc :task-ids (deser-task-id-list (clojure.core/get-in letvar1205030 ["taskIds"]))) (letvar1205030 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205030 ["nextToken"])))))))

(clojure.core/defn- response-transfer-certificate-response ([input] (response-transfer-certificate-response nil input)) ([resultWrapper1205032 input] (clojure.core/let [rawinput1205031 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205033 {"transferredCertificateArn" (rawinput1205031 "transferredCertificateArn")}] (clojure.core/cond-> {} (letvar1205033 "transferredCertificateArn") (clojure.core/assoc :transferred-certificate-arn (deser-certificate-arn (clojure.core/get-in letvar1205033 ["transferredCertificateArn"])))))))

(clojure.core/defn- response-limit-exceeded-exception ([input] (response-limit-exceeded-exception nil input)) ([resultWrapper1205035 input] (clojure.core/let [rawinput1205034 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205036 {"message" (rawinput1205034 "message")}] (clojure.core/cond-> {} (letvar1205036 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205036 ["message"])))))))

(clojure.core/defn- response-deprecate-thing-type-response ([input] (response-deprecate-thing-type-response nil input)) ([resultWrapper1205038 input] (clojure.core/let [rawinput1205037 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205039 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-topic-rules-response ([input] (response-list-topic-rules-response nil input)) ([resultWrapper1205041 input] (clojure.core/let [rawinput1205040 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205042 {"rules" (rawinput1205040 "rules"), "nextToken" (rawinput1205040 "nextToken")}] (clojure.core/cond-> {} (letvar1205042 "rules") (clojure.core/assoc :rules (deser-topic-rule-list (clojure.core/get-in letvar1205042 ["rules"]))) (letvar1205042 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205042 ["nextToken"])))))))

(clojure.core/defn- response-describe-thing-type-response ([input] (response-describe-thing-type-response nil input)) ([resultWrapper1205044 input] (clojure.core/let [rawinput1205043 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205045 {"thingTypeName" (rawinput1205043 "thingTypeName"), "thingTypeId" (rawinput1205043 "thingTypeId"), "thingTypeArn" (rawinput1205043 "thingTypeArn"), "thingTypeProperties" (rawinput1205043 "thingTypeProperties"), "thingTypeMetadata" (rawinput1205043 "thingTypeMetadata")}] (clojure.core/cond-> {} (letvar1205045 "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (clojure.core/get-in letvar1205045 ["thingTypeName"]))) (letvar1205045 "thingTypeId") (clojure.core/assoc :thing-type-id (deser-thing-type-id (clojure.core/get-in letvar1205045 ["thingTypeId"]))) (letvar1205045 "thingTypeArn") (clojure.core/assoc :thing-type-arn (deser-thing-type-arn (clojure.core/get-in letvar1205045 ["thingTypeArn"]))) (letvar1205045 "thingTypeProperties") (clojure.core/assoc :thing-type-properties (deser-thing-type-properties (clojure.core/get-in letvar1205045 ["thingTypeProperties"]))) (letvar1205045 "thingTypeMetadata") (clojure.core/assoc :thing-type-metadata (deser-thing-type-metadata (clojure.core/get-in letvar1205045 ["thingTypeMetadata"])))))))

(clojure.core/defn- response-resource-already-exists-exception ([input] (response-resource-already-exists-exception nil input)) ([resultWrapper1205047 input] (clojure.core/let [rawinput1205046 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205048 {"message" (rawinput1205046 "message"), "resourceId" (rawinput1205046 "resourceId"), "resourceArn" (rawinput1205046 "resourceArn")}] (clojure.core/cond-> {} (letvar1205048 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205048 ["message"]))) (letvar1205048 "resourceId") (clojure.core/assoc :resource-id (deserresource-id (clojure.core/get-in letvar1205048 ["resourceId"]))) (letvar1205048 "resourceArn") (clojure.core/assoc :resource-arn (deserresource-arn (clojure.core/get-in letvar1205048 ["resourceArn"])))))))

(clojure.core/defn- response-list-certificates-by-ca-response ([input] (response-list-certificates-by-ca-response nil input)) ([resultWrapper1205050 input] (clojure.core/let [rawinput1205049 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205051 {"certificates" (rawinput1205049 "certificates"), "nextMarker" (rawinput1205049 "nextMarker")}] (clojure.core/cond-> {} (letvar1205051 "certificates") (clojure.core/assoc :certificates (deser-certificates (clojure.core/get-in letvar1205051 ["certificates"]))) (letvar1205051 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205051 ["nextMarker"])))))))

(clojure.core/defn- response-list-ca-certificates-response ([input] (response-list-ca-certificates-response nil input)) ([resultWrapper1205053 input] (clojure.core/let [rawinput1205052 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205054 {"certificates" (rawinput1205052 "certificates"), "nextMarker" (rawinput1205052 "nextMarker")}] (clojure.core/cond-> {} (letvar1205054 "certificates") (clojure.core/assoc :certificates (deser-ca-certificates (clojure.core/get-in letvar1205054 ["certificates"]))) (letvar1205054 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205054 ["nextMarker"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper1205056 input] (clojure.core/let [rawinput1205055 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205057 {"message" (rawinput1205055 "message")}] (clojure.core/cond-> {} (letvar1205057 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205057 ["message"])))))))

(clojure.core/defn- response-create-keys-and-certificate-response ([input] (response-create-keys-and-certificate-response nil input)) ([resultWrapper1205059 input] (clojure.core/let [rawinput1205058 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205060 {"certificateArn" (rawinput1205058 "certificateArn"), "certificateId" (rawinput1205058 "certificateId"), "certificatePem" (rawinput1205058 "certificatePem"), "keyPair" (rawinput1205058 "keyPair")}] (clojure.core/cond-> {} (letvar1205060 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar1205060 ["certificateArn"]))) (letvar1205060 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar1205060 ["certificateId"]))) (letvar1205060 "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (clojure.core/get-in letvar1205060 ["certificatePem"]))) (letvar1205060 "keyPair") (clojure.core/assoc :key-pair (deser-key-pair (clojure.core/get-in letvar1205060 ["keyPair"])))))))

(clojure.core/defn- response-list-active-violations-response ([input] (response-list-active-violations-response nil input)) ([resultWrapper1205062 input] (clojure.core/let [rawinput1205061 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205063 {"activeViolations" (rawinput1205061 "activeViolations"), "nextToken" (rawinput1205061 "nextToken")}] (clojure.core/cond-> {} (letvar1205063 "activeViolations") (clojure.core/assoc :active-violations (deser-active-violations (clojure.core/get-in letvar1205063 ["activeViolations"]))) (letvar1205063 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205063 ["nextToken"])))))))

(clojure.core/defn- response-update-thing-groups-for-thing-response ([input] (response-update-thing-groups-for-thing-response nil input)) ([resultWrapper1205065 input] (clojure.core/let [rawinput1205064 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205066 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-search-index-response ([input] (response-search-index-response nil input)) ([resultWrapper1205068 input] (clojure.core/let [rawinput1205067 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205069 {"nextToken" (rawinput1205067 "nextToken"), "things" (rawinput1205067 "things"), "thingGroups" (rawinput1205067 "thingGroups")}] (clojure.core/cond-> {} (letvar1205069 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205069 ["nextToken"]))) (letvar1205069 "things") (clojure.core/assoc :things (deser-thing-document-list (clojure.core/get-in letvar1205069 ["things"]))) (letvar1205069 "thingGroups") (clojure.core/assoc :thing-groups (deser-thing-group-document-list (clojure.core/get-in letvar1205069 ["thingGroups"])))))))

(clojure.core/defn- response-tag-resource-response ([input] (response-tag-resource-response nil input)) ([resultWrapper1205071 input] (clojure.core/let [rawinput1205070 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205072 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-default-authorizer-response ([input] (response-describe-default-authorizer-response nil input)) ([resultWrapper1205074 input] (clojure.core/let [rawinput1205073 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205075 {"authorizerDescription" (rawinput1205073 "authorizerDescription")}] (clojure.core/cond-> {} (letvar1205075 "authorizerDescription") (clojure.core/assoc :authorizer-description (deser-authorizer-description (clojure.core/get-in letvar1205075 ["authorizerDescription"])))))))

(clojure.core/defn- response-list-role-aliases-response ([input] (response-list-role-aliases-response nil input)) ([resultWrapper1205077 input] (clojure.core/let [rawinput1205076 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205078 {"roleAliases" (rawinput1205076 "roleAliases"), "nextMarker" (rawinput1205076 "nextMarker")}] (clojure.core/cond-> {} (letvar1205078 "roleAliases") (clojure.core/assoc :role-aliases (deser-role-aliases (clojure.core/get-in letvar1205078 ["roleAliases"]))) (letvar1205078 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205078 ["nextMarker"])))))))

(clojure.core/defn- response-list-attached-policies-response ([input] (response-list-attached-policies-response nil input)) ([resultWrapper1205080 input] (clojure.core/let [rawinput1205079 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205081 {"policies" (rawinput1205079 "policies"), "nextMarker" (rawinput1205079 "nextMarker")}] (clojure.core/cond-> {} (letvar1205081 "policies") (clojure.core/assoc :policies (deser-policies (clojure.core/get-in letvar1205081 ["policies"]))) (letvar1205081 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205081 ["nextMarker"])))))))

(clojure.core/defn- response-update-scheduled-audit-response ([input] (response-update-scheduled-audit-response nil input)) ([resultWrapper1205083 input] (clojure.core/let [rawinput1205082 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205084 {"scheduledAuditArn" (rawinput1205082 "scheduledAuditArn")}] (clojure.core/cond-> {} (letvar1205084 "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (clojure.core/get-in letvar1205084 ["scheduledAuditArn"])))))))

(clojure.core/defn- response-list-thing-registration-task-reports-response ([input] (response-list-thing-registration-task-reports-response nil input)) ([resultWrapper1205086 input] (clojure.core/let [rawinput1205085 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205087 {"resourceLinks" (rawinput1205085 "resourceLinks"), "reportType" (rawinput1205085 "reportType"), "nextToken" (rawinput1205085 "nextToken")}] (clojure.core/cond-> {} (letvar1205087 "resourceLinks") (clojure.core/assoc :resource-links (deser-s-3-file-url-list (clojure.core/get-in letvar1205087 ["resourceLinks"]))) (letvar1205087 "reportType") (clojure.core/assoc :report-type (deser-report-type (clojure.core/get-in letvar1205087 ["reportType"]))) (letvar1205087 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205087 ["nextToken"])))))))

(clojure.core/defn- response-detach-security-profile-response ([input] (response-detach-security-profile-response nil input)) ([resultWrapper1205089 input] (clojure.core/let [rawinput1205088 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205090 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-certificate-from-csr-response ([input] (response-create-certificate-from-csr-response nil input)) ([resultWrapper1205092 input] (clojure.core/let [rawinput1205091 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205093 {"certificateArn" (rawinput1205091 "certificateArn"), "certificateId" (rawinput1205091 "certificateId"), "certificatePem" (rawinput1205091 "certificatePem")}] (clojure.core/cond-> {} (letvar1205093 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar1205093 ["certificateArn"]))) (letvar1205093 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar1205093 ["certificateId"]))) (letvar1205093 "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (clojure.core/get-in letvar1205093 ["certificatePem"])))))))

(clojure.core/defn- response-list-security-profiles-response ([input] (response-list-security-profiles-response nil input)) ([resultWrapper1205095 input] (clojure.core/let [rawinput1205094 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205096 {"securityProfileIdentifiers" (rawinput1205094 "securityProfileIdentifiers"), "nextToken" (rawinput1205094 "nextToken")}] (clojure.core/cond-> {} (letvar1205096 "securityProfileIdentifiers") (clojure.core/assoc :security-profile-identifiers (deser-security-profile-identifiers (clojure.core/get-in letvar1205096 ["securityProfileIdentifiers"]))) (letvar1205096 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205096 ["nextToken"])))))))

(clojure.core/defn- response-internal-failure-exception ([input] (response-internal-failure-exception nil input)) ([resultWrapper1205098 input] (clojure.core/let [rawinput1205097 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205099 {"message" (rawinput1205097 "message")}] (clojure.core/cond-> {} (letvar1205099 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205099 ["message"])))))))

(clojure.core/defn- response-get-policy-version-response ([input] (response-get-policy-version-response nil input)) ([resultWrapper1205101 input] (clojure.core/let [rawinput1205100 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205102 {"policyArn" (rawinput1205100 "policyArn"), "policyName" (rawinput1205100 "policyName"), "policyDocument" (rawinput1205100 "policyDocument"), "policyVersionId" (rawinput1205100 "policyVersionId"), "isDefaultVersion" (rawinput1205100 "isDefaultVersion"), "creationDate" (rawinput1205100 "creationDate"), "lastModifiedDate" (rawinput1205100 "lastModifiedDate"), "generationId" (rawinput1205100 "generationId")}] (clojure.core/cond-> {} (letvar1205102 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar1205102 ["policyArn"]))) (letvar1205102 "policyName") (clojure.core/assoc :policy-name (deser-policy-name (clojure.core/get-in letvar1205102 ["policyName"]))) (letvar1205102 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar1205102 ["policyDocument"]))) (letvar1205102 "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (clojure.core/get-in letvar1205102 ["policyVersionId"]))) (letvar1205102 "isDefaultVersion") (clojure.core/assoc :is-default-version (deser-is-default-version (clojure.core/get-in letvar1205102 ["isDefaultVersion"]))) (letvar1205102 "creationDate") (clojure.core/assoc :creation-date (deser-date-type (clojure.core/get-in letvar1205102 ["creationDate"]))) (letvar1205102 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (clojure.core/get-in letvar1205102 ["lastModifiedDate"]))) (letvar1205102 "generationId") (clojure.core/assoc :generation-id (deser-generation-id (clojure.core/get-in letvar1205102 ["generationId"])))))))

(clojure.core/defn- response-versions-limit-exceeded-exception ([input] (response-versions-limit-exceeded-exception nil input)) ([resultWrapper1205104 input] (clojure.core/let [rawinput1205103 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205105 {"message" (rawinput1205103 "message")}] (clojure.core/cond-> {} (letvar1205105 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205105 ["message"])))))))

(clojure.core/defn- response-delete-billing-group-response ([input] (response-delete-billing-group-response nil input)) ([resultWrapper1205107 input] (clojure.core/let [rawinput1205106 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205108 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-remove-thing-from-thing-group-response ([input] (response-remove-thing-from-thing-group-response nil input)) ([resultWrapper1205110 input] (clojure.core/let [rawinput1205109 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205111 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-get-registration-code-response ([input] (response-get-registration-code-response nil input)) ([resultWrapper1205113 input] (clojure.core/let [rawinput1205112 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205114 {"registrationCode" (rawinput1205112 "registrationCode")}] (clojure.core/cond-> {} (letvar1205114 "registrationCode") (clojure.core/assoc :registration-code (deser-registration-code (clojure.core/get-in letvar1205114 ["registrationCode"])))))))

(clojure.core/defn- response-resource-not-found-exception ([input] (response-resource-not-found-exception nil input)) ([resultWrapper1205116 input] (clojure.core/let [rawinput1205115 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205117 {"message" (rawinput1205115 "message")}] (clojure.core/cond-> {} (letvar1205117 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205117 ["message"])))))))

(clojure.core/defn- response-list-audit-tasks-response ([input] (response-list-audit-tasks-response nil input)) ([resultWrapper1205119 input] (clojure.core/let [rawinput1205118 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205120 {"tasks" (rawinput1205118 "tasks"), "nextToken" (rawinput1205118 "nextToken")}] (clojure.core/cond-> {} (letvar1205120 "tasks") (clojure.core/assoc :tasks (deser-audit-task-metadata-list (clojure.core/get-in letvar1205120 ["tasks"]))) (letvar1205120 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205120 ["nextToken"])))))))

(clojure.core/defn- response-describe-thing-group-response ([input] (response-describe-thing-group-response nil input)) ([resultWrapper1205122 input] (clojure.core/let [rawinput1205121 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205123 {"indexName" (rawinput1205121 "indexName"), "status" (rawinput1205121 "status"), "thingGroupId" (rawinput1205121 "thingGroupId"), "queryVersion" (rawinput1205121 "queryVersion"), "thingGroupName" (rawinput1205121 "thingGroupName"), "thingGroupProperties" (rawinput1205121 "thingGroupProperties"), "version" (rawinput1205121 "version"), "thingGroupArn" (rawinput1205121 "thingGroupArn"), "queryString" (rawinput1205121 "queryString"), "thingGroupMetadata" (rawinput1205121 "thingGroupMetadata")}] (clojure.core/cond-> {} (letvar1205123 "indexName") (clojure.core/assoc :index-name (deser-index-name (clojure.core/get-in letvar1205123 ["indexName"]))) (letvar1205123 "status") (clojure.core/assoc :status (deser-dynamic-group-status (clojure.core/get-in letvar1205123 ["status"]))) (letvar1205123 "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (clojure.core/get-in letvar1205123 ["thingGroupId"]))) (letvar1205123 "queryVersion") (clojure.core/assoc :query-version (deser-query-version (clojure.core/get-in letvar1205123 ["queryVersion"]))) (letvar1205123 "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (clojure.core/get-in letvar1205123 ["thingGroupName"]))) (letvar1205123 "thingGroupProperties") (clojure.core/assoc :thing-group-properties (deser-thing-group-properties (clojure.core/get-in letvar1205123 ["thingGroupProperties"]))) (letvar1205123 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1205123 ["version"]))) (letvar1205123 "thingGroupArn") (clojure.core/assoc :thing-group-arn (deser-thing-group-arn (clojure.core/get-in letvar1205123 ["thingGroupArn"]))) (letvar1205123 "queryString") (clojure.core/assoc :query-string (deser-query-string (clojure.core/get-in letvar1205123 ["queryString"]))) (letvar1205123 "thingGroupMetadata") (clojure.core/assoc :thing-group-metadata (deser-thing-group-metadata (clojure.core/get-in letvar1205123 ["thingGroupMetadata"])))))))

(clojure.core/defn- response-not-configured-exception ([input] (response-not-configured-exception nil input)) ([resultWrapper1205125 input] (clojure.core/let [rawinput1205124 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205126 {"message" (rawinput1205124 "message")}] (clojure.core/cond-> {} (letvar1205126 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205126 ["message"])))))))

(clojure.core/defn- response-delete-thing-type-response ([input] (response-delete-thing-type-response nil input)) ([resultWrapper1205128 input] (clojure.core/let [rawinput1205127 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205129 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-ca-certificate-response ([input] (response-delete-ca-certificate-response nil input)) ([resultWrapper1205131 input] (clojure.core/let [rawinput1205130 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205132 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-response-exception ([input] (response-invalid-response-exception nil input)) ([resultWrapper1205134 input] (clojure.core/let [rawinput1205133 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205135 {"message" (rawinput1205133 "message")}] (clojure.core/cond-> {} (letvar1205135 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205135 ["message"])))))))

(clojure.core/defn- response-index-not-ready-exception ([input] (response-index-not-ready-exception nil input)) ([resultWrapper1205137 input] (clojure.core/let [rawinput1205136 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205138 {"message" (rawinput1205136 "message")}] (clojure.core/cond-> {} (letvar1205138 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205138 ["message"])))))))

(clojure.core/defn- response-delete-dynamic-thing-group-response ([input] (response-delete-dynamic-thing-group-response nil input)) ([resultWrapper1205140 input] (clojure.core/let [rawinput1205139 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205141 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-associate-targets-with-job-response ([input] (response-associate-targets-with-job-response nil input)) ([resultWrapper1205143 input] (clojure.core/let [rawinput1205142 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205144 {"jobArn" (rawinput1205142 "jobArn"), "jobId" (rawinput1205142 "jobId"), "description" (rawinput1205142 "description")}] (clojure.core/cond-> {} (letvar1205144 "jobArn") (clojure.core/assoc :job-arn (deser-job-arn (clojure.core/get-in letvar1205144 ["jobArn"]))) (letvar1205144 "jobId") (clojure.core/assoc :job-id (deser-job-id (clojure.core/get-in letvar1205144 ["jobId"]))) (letvar1205144 "description") (clojure.core/assoc :description (deser-job-description (clojure.core/get-in letvar1205144 ["description"])))))))

(clojure.core/defn- response-describe-job-execution-response ([input] (response-describe-job-execution-response nil input)) ([resultWrapper1205146 input] (clojure.core/let [rawinput1205145 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205147 {"execution" (rawinput1205145 "execution")}] (clojure.core/cond-> {} (letvar1205147 "execution") (clojure.core/assoc :execution (deser-job-execution (clojure.core/get-in letvar1205147 ["execution"])))))))

(clojure.core/defn- response-remove-thing-from-billing-group-response ([input] (response-remove-thing-from-billing-group-response nil input)) ([resultWrapper1205149 input] (clojure.core/let [rawinput1205148 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205150 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-start-on-demand-audit-task-response ([input] (response-start-on-demand-audit-task-response nil input)) ([resultWrapper1205152 input] (clojure.core/let [rawinput1205151 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205153 {"taskId" (rawinput1205151 "taskId")}] (clojure.core/cond-> {} (letvar1205153 "taskId") (clojure.core/assoc :task-id (deser-audit-task-id (clojure.core/get-in letvar1205153 ["taskId"])))))))

(clojure.core/defn- response-sql-parse-exception ([input] (response-sql-parse-exception nil input)) ([resultWrapper1205155 input] (clojure.core/let [rawinput1205154 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205156 {"message" (rawinput1205154 "message")}] (clojure.core/cond-> {} (letvar1205156 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205156 ["message"])))))))

(clojure.core/defn- response-update-authorizer-response ([input] (response-update-authorizer-response nil input)) ([resultWrapper1205158 input] (clojure.core/let [rawinput1205157 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205159 {"authorizerName" (rawinput1205157 "authorizerName"), "authorizerArn" (rawinput1205157 "authorizerArn")}] (clojure.core/cond-> {} (letvar1205159 "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (clojure.core/get-in letvar1205159 ["authorizerName"]))) (letvar1205159 "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (clojure.core/get-in letvar1205159 ["authorizerArn"])))))))

(clojure.core/defn- response-describe-scheduled-audit-response ([input] (response-describe-scheduled-audit-response nil input)) ([resultWrapper1205161 input] (clojure.core/let [rawinput1205160 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205162 {"frequency" (rawinput1205160 "frequency"), "dayOfMonth" (rawinput1205160 "dayOfMonth"), "dayOfWeek" (rawinput1205160 "dayOfWeek"), "targetCheckNames" (rawinput1205160 "targetCheckNames"), "scheduledAuditName" (rawinput1205160 "scheduledAuditName"), "scheduledAuditArn" (rawinput1205160 "scheduledAuditArn")}] (clojure.core/cond-> {} (letvar1205162 "frequency") (clojure.core/assoc :frequency (deser-audit-frequency (clojure.core/get-in letvar1205162 ["frequency"]))) (letvar1205162 "dayOfMonth") (clojure.core/assoc :day-of-month (deser-day-of-month (clojure.core/get-in letvar1205162 ["dayOfMonth"]))) (letvar1205162 "dayOfWeek") (clojure.core/assoc :day-of-week (deser-day-of-week (clojure.core/get-in letvar1205162 ["dayOfWeek"]))) (letvar1205162 "targetCheckNames") (clojure.core/assoc :target-check-names (deser-target-audit-check-names (clojure.core/get-in letvar1205162 ["targetCheckNames"]))) (letvar1205162 "scheduledAuditName") (clojure.core/assoc :scheduled-audit-name (deser-scheduled-audit-name (clojure.core/get-in letvar1205162 ["scheduledAuditName"]))) (letvar1205162 "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (clojure.core/get-in letvar1205162 ["scheduledAuditArn"])))))))

(clojure.core/defn- response-get-indexing-configuration-response ([input] (response-get-indexing-configuration-response nil input)) ([resultWrapper1205164 input] (clojure.core/let [rawinput1205163 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205165 {"thingIndexingConfiguration" (rawinput1205163 "thingIndexingConfiguration"), "thingGroupIndexingConfiguration" (rawinput1205163 "thingGroupIndexingConfiguration")}] (clojure.core/cond-> {} (letvar1205165 "thingIndexingConfiguration") (clojure.core/assoc :thing-indexing-configuration (deser-thing-indexing-configuration (clojure.core/get-in letvar1205165 ["thingIndexingConfiguration"]))) (letvar1205165 "thingGroupIndexingConfiguration") (clojure.core/assoc :thing-group-indexing-configuration (deser-thing-group-indexing-configuration (clojure.core/get-in letvar1205165 ["thingGroupIndexingConfiguration"])))))))

(clojure.core/defn- response-list-authorizers-response ([input] (response-list-authorizers-response nil input)) ([resultWrapper1205167 input] (clojure.core/let [rawinput1205166 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205168 {"authorizers" (rawinput1205166 "authorizers"), "nextMarker" (rawinput1205166 "nextMarker")}] (clojure.core/cond-> {} (letvar1205168 "authorizers") (clojure.core/assoc :authorizers (deser-authorizers (clojure.core/get-in letvar1205168 ["authorizers"]))) (letvar1205168 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205168 ["nextMarker"])))))))

(clojure.core/defn- response-internal-exception ([input] (response-internal-exception nil input)) ([resultWrapper1205170 input] (clojure.core/let [rawinput1205169 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205171 {"message" (rawinput1205169 "message")}] (clojure.core/cond-> {} (letvar1205171 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205171 ["message"])))))))

(clojure.core/defn- response-get-policy-response ([input] (response-get-policy-response nil input)) ([resultWrapper1205173 input] (clojure.core/let [rawinput1205172 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205174 {"policyName" (rawinput1205172 "policyName"), "policyArn" (rawinput1205172 "policyArn"), "policyDocument" (rawinput1205172 "policyDocument"), "defaultVersionId" (rawinput1205172 "defaultVersionId"), "creationDate" (rawinput1205172 "creationDate"), "lastModifiedDate" (rawinput1205172 "lastModifiedDate"), "generationId" (rawinput1205172 "generationId")}] (clojure.core/cond-> {} (letvar1205174 "policyName") (clojure.core/assoc :policy-name (deser-policy-name (clojure.core/get-in letvar1205174 ["policyName"]))) (letvar1205174 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar1205174 ["policyArn"]))) (letvar1205174 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar1205174 ["policyDocument"]))) (letvar1205174 "defaultVersionId") (clojure.core/assoc :default-version-id (deser-policy-version-id (clojure.core/get-in letvar1205174 ["defaultVersionId"]))) (letvar1205174 "creationDate") (clojure.core/assoc :creation-date (deser-date-type (clojure.core/get-in letvar1205174 ["creationDate"]))) (letvar1205174 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-date-type (clojure.core/get-in letvar1205174 ["lastModifiedDate"]))) (letvar1205174 "generationId") (clojure.core/assoc :generation-id (deser-generation-id (clojure.core/get-in letvar1205174 ["generationId"])))))))

(clojure.core/defn- response-version-conflict-exception ([input] (response-version-conflict-exception nil input)) ([resultWrapper1205176 input] (clojure.core/let [rawinput1205175 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205177 {"message" (rawinput1205175 "message")}] (clojure.core/cond-> {} (letvar1205177 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205177 ["message"])))))))

(clojure.core/defn- response-create-policy-response ([input] (response-create-policy-response nil input)) ([resultWrapper1205179 input] (clojure.core/let [rawinput1205178 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205180 {"policyName" (rawinput1205178 "policyName"), "policyArn" (rawinput1205178 "policyArn"), "policyDocument" (rawinput1205178 "policyDocument"), "policyVersionId" (rawinput1205178 "policyVersionId")}] (clojure.core/cond-> {} (letvar1205180 "policyName") (clojure.core/assoc :policy-name (deser-policy-name (clojure.core/get-in letvar1205180 ["policyName"]))) (letvar1205180 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar1205180 ["policyArn"]))) (letvar1205180 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar1205180 ["policyDocument"]))) (letvar1205180 "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (clojure.core/get-in letvar1205180 ["policyVersionId"])))))))

(clojure.core/defn- response-list-audit-findings-response ([input] (response-list-audit-findings-response nil input)) ([resultWrapper1205182 input] (clojure.core/let [rawinput1205181 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205183 {"findings" (rawinput1205181 "findings"), "nextToken" (rawinput1205181 "nextToken")}] (clojure.core/cond-> {} (letvar1205183 "findings") (clojure.core/assoc :findings (deser-audit-findings (clojure.core/get-in letvar1205183 ["findings"]))) (letvar1205183 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205183 ["nextToken"])))))))

(clojure.core/defn- response-resource-registration-failure-exception ([input] (response-resource-registration-failure-exception nil input)) ([resultWrapper1205185 input] (clojure.core/let [rawinput1205184 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205186 {"message" (rawinput1205184 "message")}] (clojure.core/cond-> {} (letvar1205186 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205186 ["message"])))))))

(clojure.core/defn- response-add-thing-to-billing-group-response ([input] (response-add-thing-to-billing-group-response nil input)) ([resultWrapper1205188 input] (clojure.core/let [rawinput1205187 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205189 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-thing-response ([input] (response-update-thing-response nil input)) ([resultWrapper1205191 input] (clojure.core/let [rawinput1205190 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205192 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-security-profile-response ([input] (response-delete-security-profile-response nil input)) ([resultWrapper1205194 input] (clojure.core/let [rawinput1205193 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205195 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-invalid-state-transition-exception ([input] (response-invalid-state-transition-exception nil input)) ([resultWrapper1205197 input] (clojure.core/let [rawinput1205196 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205198 {"message" (rawinput1205196 "message")}] (clojure.core/cond-> {} (letvar1205198 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205198 ["message"])))))))

(clojure.core/defn- response-describe-certificate-response ([input] (response-describe-certificate-response nil input)) ([resultWrapper1205200 input] (clojure.core/let [rawinput1205199 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205201 {"certificateDescription" (rawinput1205199 "certificateDescription")}] (clojure.core/cond-> {} (letvar1205201 "certificateDescription") (clojure.core/assoc :certificate-description (deser-certificate-description (clojure.core/get-in letvar1205201 ["certificateDescription"])))))))

(clojure.core/defn- response-conflicting-resource-update-exception ([input] (response-conflicting-resource-update-exception nil input)) ([resultWrapper1205203 input] (clojure.core/let [rawinput1205202 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205204 {"message" (rawinput1205202 "message")}] (clojure.core/cond-> {} (letvar1205204 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205204 ["message"])))))))

(clojure.core/defn- response-describe-role-alias-response ([input] (response-describe-role-alias-response nil input)) ([resultWrapper1205206 input] (clojure.core/let [rawinput1205205 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205207 {"roleAliasDescription" (rawinput1205205 "roleAliasDescription")}] (clojure.core/cond-> {} (letvar1205207 "roleAliasDescription") (clojure.core/assoc :role-alias-description (deser-role-alias-description (clojure.core/get-in letvar1205207 ["roleAliasDescription"])))))))

(clojure.core/defn- response-get-job-document-response ([input] (response-get-job-document-response nil input)) ([resultWrapper1205209 input] (clojure.core/let [rawinput1205208 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205210 {"document" (rawinput1205208 "document")}] (clojure.core/cond-> {} (letvar1205210 "document") (clojure.core/assoc :document (deser-job-document (clojure.core/get-in letvar1205210 ["document"])))))))

(clojure.core/defn- response-describe-job-response ([input] (response-describe-job-response nil input)) ([resultWrapper1205212 input] (clojure.core/let [rawinput1205211 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205213 {"documentSource" (rawinput1205211 "documentSource"), "job" (rawinput1205211 "job")}] (clojure.core/cond-> {} (letvar1205213 "documentSource") (clojure.core/assoc :document-source (deser-job-document-source (clojure.core/get-in letvar1205213 ["documentSource"]))) (letvar1205213 "job") (clojure.core/assoc :job (deser-job (clojure.core/get-in letvar1205213 ["job"])))))))

(clojure.core/defn- response-list-v-2-logging-levels-response ([input] (response-list-v-2-logging-levels-response nil input)) ([resultWrapper1205215 input] (clojure.core/let [rawinput1205214 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205216 {"logTargetConfigurations" (rawinput1205214 "logTargetConfigurations"), "nextToken" (rawinput1205214 "nextToken")}] (clojure.core/cond-> {} (letvar1205216 "logTargetConfigurations") (clojure.core/assoc :log-target-configurations (deser-log-target-configurations (clojure.core/get-in letvar1205216 ["logTargetConfigurations"]))) (letvar1205216 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205216 ["nextToken"])))))))

(clojure.core/defn- response-register-certificate-response ([input] (response-register-certificate-response nil input)) ([resultWrapper1205218 input] (clojure.core/let [rawinput1205217 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205219 {"certificateArn" (rawinput1205217 "certificateArn"), "certificateId" (rawinput1205217 "certificateId")}] (clojure.core/cond-> {} (letvar1205219 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar1205219 ["certificateArn"]))) (letvar1205219 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar1205219 ["certificateId"])))))))

(clojure.core/defn- response-transfer-already-completed-exception ([input] (response-transfer-already-completed-exception nil input)) ([resultWrapper1205221 input] (clojure.core/let [rawinput1205220 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205222 {"message" (rawinput1205220 "message")}] (clojure.core/cond-> {} (letvar1205222 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205222 ["message"])))))))

(clojure.core/defn- response-list-thing-principals-response ([input] (response-list-thing-principals-response nil input)) ([resultWrapper1205224 input] (clojure.core/let [rawinput1205223 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205225 {"principals" (rawinput1205223 "principals")}] (clojure.core/cond-> {} (letvar1205225 "principals") (clojure.core/assoc :principals (deser-principals (clojure.core/get-in letvar1205225 ["principals"])))))))

(clojure.core/defn- response-create-thing-group-response ([input] (response-create-thing-group-response nil input)) ([resultWrapper1205227 input] (clojure.core/let [rawinput1205226 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205228 {"thingGroupName" (rawinput1205226 "thingGroupName"), "thingGroupArn" (rawinput1205226 "thingGroupArn"), "thingGroupId" (rawinput1205226 "thingGroupId")}] (clojure.core/cond-> {} (letvar1205228 "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (clojure.core/get-in letvar1205228 ["thingGroupName"]))) (letvar1205228 "thingGroupArn") (clojure.core/assoc :thing-group-arn (deser-thing-group-arn (clojure.core/get-in letvar1205228 ["thingGroupArn"]))) (letvar1205228 "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (clojure.core/get-in letvar1205228 ["thingGroupId"])))))))

(clojure.core/defn- response-stop-thing-registration-task-response ([input] (response-stop-thing-registration-task-response nil input)) ([resultWrapper1205230 input] (clojure.core/let [rawinput1205229 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205231 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-billing-group-response ([input] (response-update-billing-group-response nil input)) ([resultWrapper1205233 input] (clojure.core/let [rawinput1205232 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205234 {"version" (rawinput1205232 "version")}] (clojure.core/cond-> {} (letvar1205234 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1205234 ["version"])))))))

(clojure.core/defn- response-validate-security-profile-behaviors-response ([input] (response-validate-security-profile-behaviors-response nil input)) ([resultWrapper1205236 input] (clojure.core/let [rawinput1205235 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205237 {"valid" (rawinput1205235 "valid"), "validationErrors" (rawinput1205235 "validationErrors")}] (clojure.core/cond-> {} (letvar1205237 "valid") (clojure.core/assoc :valid (deser-valid (clojure.core/get-in letvar1205237 ["valid"]))) (letvar1205237 "validationErrors") (clojure.core/assoc :validation-errors (deser-validation-errors (clojure.core/get-in letvar1205237 ["validationErrors"])))))))

(clojure.core/defn- response-delete-thing-response ([input] (response-delete-thing-response nil input)) ([resultWrapper1205239 input] (clojure.core/let [rawinput1205238 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205240 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-policy-principals-response ([input] (response-list-policy-principals-response nil input)) ([resultWrapper1205242 input] (clojure.core/let [rawinput1205241 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205243 {"principals" (rawinput1205241 "principals"), "nextMarker" (rawinput1205241 "nextMarker")}] (clojure.core/cond-> {} (letvar1205243 "principals") (clojure.core/assoc :principals (deser-principals (clojure.core/get-in letvar1205243 ["principals"]))) (letvar1205243 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205243 ["nextMarker"])))))))

(clojure.core/defn- response-list-thing-types-response ([input] (response-list-thing-types-response nil input)) ([resultWrapper1205245 input] (clojure.core/let [rawinput1205244 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205246 {"thingTypes" (rawinput1205244 "thingTypes"), "nextToken" (rawinput1205244 "nextToken")}] (clojure.core/cond-> {} (letvar1205246 "thingTypes") (clojure.core/assoc :thing-types (deser-thing-type-list (clojure.core/get-in letvar1205246 ["thingTypes"]))) (letvar1205246 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205246 ["nextToken"])))))))

(clojure.core/defn- response-list-job-executions-for-thing-response ([input] (response-list-job-executions-for-thing-response nil input)) ([resultWrapper1205248 input] (clojure.core/let [rawinput1205247 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205249 {"executionSummaries" (rawinput1205247 "executionSummaries"), "nextToken" (rawinput1205247 "nextToken")}] (clojure.core/cond-> {} (letvar1205249 "executionSummaries") (clojure.core/assoc :execution-summaries (deser-job-execution-summary-for-thing-list (clojure.core/get-in letvar1205249 ["executionSummaries"]))) (letvar1205249 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205249 ["nextToken"])))))))

(clojure.core/defn- response-create-thing-response ([input] (response-create-thing-response nil input)) ([resultWrapper1205251 input] (clojure.core/let [rawinput1205250 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205252 {"thingName" (rawinput1205250 "thingName"), "thingArn" (rawinput1205250 "thingArn"), "thingId" (rawinput1205250 "thingId")}] (clojure.core/cond-> {} (letvar1205252 "thingName") (clojure.core/assoc :thing-name (deser-thing-name (clojure.core/get-in letvar1205252 ["thingName"]))) (letvar1205252 "thingArn") (clojure.core/assoc :thing-arn (deser-thing-arn (clojure.core/get-in letvar1205252 ["thingArn"]))) (letvar1205252 "thingId") (clojure.core/assoc :thing-id (deser-thing-id (clojure.core/get-in letvar1205252 ["thingId"])))))))

(clojure.core/defn- response-clear-default-authorizer-response ([input] (response-clear-default-authorizer-response nil input)) ([resultWrapper1205254 input] (clojure.core/let [rawinput1205253 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205255 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-dynamic-thing-group-response ([input] (response-create-dynamic-thing-group-response nil input)) ([resultWrapper1205257 input] (clojure.core/let [rawinput1205256 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205258 {"thingGroupName" (rawinput1205256 "thingGroupName"), "thingGroupArn" (rawinput1205256 "thingGroupArn"), "thingGroupId" (rawinput1205256 "thingGroupId"), "indexName" (rawinput1205256 "indexName"), "queryString" (rawinput1205256 "queryString"), "queryVersion" (rawinput1205256 "queryVersion")}] (clojure.core/cond-> {} (letvar1205258 "thingGroupName") (clojure.core/assoc :thing-group-name (deser-thing-group-name (clojure.core/get-in letvar1205258 ["thingGroupName"]))) (letvar1205258 "thingGroupArn") (clojure.core/assoc :thing-group-arn (deser-thing-group-arn (clojure.core/get-in letvar1205258 ["thingGroupArn"]))) (letvar1205258 "thingGroupId") (clojure.core/assoc :thing-group-id (deser-thing-group-id (clojure.core/get-in letvar1205258 ["thingGroupId"]))) (letvar1205258 "indexName") (clojure.core/assoc :index-name (deser-index-name (clojure.core/get-in letvar1205258 ["indexName"]))) (letvar1205258 "queryString") (clojure.core/assoc :query-string (deser-query-string (clojure.core/get-in letvar1205258 ["queryString"]))) (letvar1205258 "queryVersion") (clojure.core/assoc :query-version (deser-query-version (clojure.core/get-in letvar1205258 ["queryVersion"])))))))

(clojure.core/defn- response-describe-authorizer-response ([input] (response-describe-authorizer-response nil input)) ([resultWrapper1205260 input] (clojure.core/let [rawinput1205259 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205261 {"authorizerDescription" (rawinput1205259 "authorizerDescription")}] (clojure.core/cond-> {} (letvar1205261 "authorizerDescription") (clojure.core/assoc :authorizer-description (deser-authorizer-description (clojure.core/get-in letvar1205261 ["authorizerDescription"])))))))

(clojure.core/defn- response-create-authorizer-response ([input] (response-create-authorizer-response nil input)) ([resultWrapper1205263 input] (clojure.core/let [rawinput1205262 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205264 {"authorizerName" (rawinput1205262 "authorizerName"), "authorizerArn" (rawinput1205262 "authorizerArn")}] (clojure.core/cond-> {} (letvar1205264 "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (clojure.core/get-in letvar1205264 ["authorizerName"]))) (letvar1205264 "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (clojure.core/get-in letvar1205264 ["authorizerArn"])))))))

(clojure.core/defn- response-delete-authorizer-response ([input] (response-delete-authorizer-response nil input)) ([resultWrapper1205266 input] (clojure.core/let [rawinput1205265 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205267 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-job-executions-for-job-response ([input] (response-list-job-executions-for-job-response nil input)) ([resultWrapper1205269 input] (clojure.core/let [rawinput1205268 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205270 {"executionSummaries" (rawinput1205268 "executionSummaries"), "nextToken" (rawinput1205268 "nextToken")}] (clojure.core/cond-> {} (letvar1205270 "executionSummaries") (clojure.core/assoc :execution-summaries (deser-job-execution-summary-for-job-list (clojure.core/get-in letvar1205270 ["executionSummaries"]))) (letvar1205270 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205270 ["nextToken"])))))))

(clojure.core/defn- response-malformed-policy-exception ([input] (response-malformed-policy-exception nil input)) ([resultWrapper1205272 input] (clojure.core/let [rawinput1205271 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205273 {"message" (rawinput1205271 "message")}] (clojure.core/cond-> {} (letvar1205273 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205273 ["message"])))))))

(clojure.core/defn- response-get-ota-update-response ([input] (response-get-ota-update-response nil input)) ([resultWrapper1205275 input] (clojure.core/let [rawinput1205274 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205276 {"otaUpdateInfo" (rawinput1205274 "otaUpdateInfo")}] (clojure.core/cond-> {} (letvar1205276 "otaUpdateInfo") (clojure.core/assoc :ota-update-info (deser-ota-update-info (clojure.core/get-in letvar1205276 ["otaUpdateInfo"])))))))

(clojure.core/defn- response-register-ca-certificate-response ([input] (response-register-ca-certificate-response nil input)) ([resultWrapper1205278 input] (clojure.core/let [rawinput1205277 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205279 {"certificateArn" (rawinput1205277 "certificateArn"), "certificateId" (rawinput1205277 "certificateId")}] (clojure.core/cond-> {} (letvar1205279 "certificateArn") (clojure.core/assoc :certificate-arn (deser-certificate-arn (clojure.core/get-in letvar1205279 ["certificateArn"]))) (letvar1205279 "certificateId") (clojure.core/assoc :certificate-id (deser-certificate-id (clojure.core/get-in letvar1205279 ["certificateId"])))))))

(clojure.core/defn- response-add-thing-to-thing-group-response ([input] (response-add-thing-to-thing-group-response nil input)) ([resultWrapper1205281 input] (clojure.core/let [rawinput1205280 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205282 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-create-scheduled-audit-response ([input] (response-create-scheduled-audit-response nil input)) ([resultWrapper1205284 input] (clojure.core/let [rawinput1205283 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205285 {"scheduledAuditArn" (rawinput1205283 "scheduledAuditArn")}] (clojure.core/cond-> {} (letvar1205285 "scheduledAuditArn") (clojure.core/assoc :scheduled-audit-arn (deser-scheduled-audit-arn (clojure.core/get-in letvar1205285 ["scheduledAuditArn"])))))))

(clojure.core/defn- response-describe-billing-group-response ([input] (response-describe-billing-group-response nil input)) ([resultWrapper1205287 input] (clojure.core/let [rawinput1205286 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205288 {"billingGroupName" (rawinput1205286 "billingGroupName"), "billingGroupId" (rawinput1205286 "billingGroupId"), "billingGroupArn" (rawinput1205286 "billingGroupArn"), "version" (rawinput1205286 "version"), "billingGroupProperties" (rawinput1205286 "billingGroupProperties"), "billingGroupMetadata" (rawinput1205286 "billingGroupMetadata")}] (clojure.core/cond-> {} (letvar1205288 "billingGroupName") (clojure.core/assoc :billing-group-name (deser-billing-group-name (clojure.core/get-in letvar1205288 ["billingGroupName"]))) (letvar1205288 "billingGroupId") (clojure.core/assoc :billing-group-id (deser-billing-group-id (clojure.core/get-in letvar1205288 ["billingGroupId"]))) (letvar1205288 "billingGroupArn") (clojure.core/assoc :billing-group-arn (deser-billing-group-arn (clojure.core/get-in letvar1205288 ["billingGroupArn"]))) (letvar1205288 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1205288 ["version"]))) (letvar1205288 "billingGroupProperties") (clojure.core/assoc :billing-group-properties (deser-billing-group-properties (clojure.core/get-in letvar1205288 ["billingGroupProperties"]))) (letvar1205288 "billingGroupMetadata") (clojure.core/assoc :billing-group-metadata (deser-billing-group-metadata (clojure.core/get-in letvar1205288 ["billingGroupMetadata"])))))))

(clojure.core/defn- response-throttling-exception ([input] (response-throttling-exception nil input)) ([resultWrapper1205290 input] (clojure.core/let [rawinput1205289 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205291 {"message" (rawinput1205289 "message")}] (clojure.core/cond-> {} (letvar1205291 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205291 ["message"])))))))

(clojure.core/defn- response-describe-security-profile-response ([input] (response-describe-security-profile-response nil input)) ([resultWrapper1205293 input] (clojure.core/let [rawinput1205292 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205294 {"creationDate" (rawinput1205292 "creationDate"), "securityProfileArn" (rawinput1205292 "securityProfileArn"), "additionalMetricsToRetain" (rawinput1205292 "additionalMetricsToRetain"), "behaviors" (rawinput1205292 "behaviors"), "lastModifiedDate" (rawinput1205292 "lastModifiedDate"), "securityProfileDescription" (rawinput1205292 "securityProfileDescription"), "version" (rawinput1205292 "version"), "securityProfileName" (rawinput1205292 "securityProfileName"), "alertTargets" (rawinput1205292 "alertTargets")}] (clojure.core/cond-> {} (letvar1205294 "creationDate") (clojure.core/assoc :creation-date (deser-timestamp (clojure.core/get-in letvar1205294 ["creationDate"]))) (letvar1205294 "securityProfileArn") (clojure.core/assoc :security-profile-arn (deser-security-profile-arn (clojure.core/get-in letvar1205294 ["securityProfileArn"]))) (letvar1205294 "additionalMetricsToRetain") (clojure.core/assoc :additional-metrics-to-retain (deser-additional-metrics-to-retain-list (clojure.core/get-in letvar1205294 ["additionalMetricsToRetain"]))) (letvar1205294 "behaviors") (clojure.core/assoc :behaviors (deser-behaviors (clojure.core/get-in letvar1205294 ["behaviors"]))) (letvar1205294 "lastModifiedDate") (clojure.core/assoc :last-modified-date (deser-timestamp (clojure.core/get-in letvar1205294 ["lastModifiedDate"]))) (letvar1205294 "securityProfileDescription") (clojure.core/assoc :security-profile-description (deser-security-profile-description (clojure.core/get-in letvar1205294 ["securityProfileDescription"]))) (letvar1205294 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1205294 ["version"]))) (letvar1205294 "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (clojure.core/get-in letvar1205294 ["securityProfileName"]))) (letvar1205294 "alertTargets") (clojure.core/assoc :alert-targets (deser-alert-targets (clojure.core/get-in letvar1205294 ["alertTargets"])))))))

(clojure.core/defn- response-list-policies-response ([input] (response-list-policies-response nil input)) ([resultWrapper1205296 input] (clojure.core/let [rawinput1205295 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205297 {"policies" (rawinput1205295 "policies"), "nextMarker" (rawinput1205295 "nextMarker")}] (clojure.core/cond-> {} (letvar1205297 "policies") (clojure.core/assoc :policies (deser-policies (clojure.core/get-in letvar1205297 ["policies"]))) (letvar1205297 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205297 ["nextMarker"])))))))

(clojure.core/defn- response-transfer-conflict-exception ([input] (response-transfer-conflict-exception nil input)) ([resultWrapper1205299 input] (clojure.core/let [rawinput1205298 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205300 {"message" (rawinput1205298 "message")}] (clojure.core/cond-> {} (letvar1205300 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205300 ["message"])))))))

(clojure.core/defn- response-attach-security-profile-response ([input] (response-attach-security-profile-response nil input)) ([resultWrapper1205302 input] (clojure.core/let [rawinput1205301 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205303 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-registration-code-validation-exception ([input] (response-registration-code-validation-exception nil input)) ([resultWrapper1205305 input] (clojure.core/let [rawinput1205304 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205306 {"message" (rawinput1205304 "message")}] (clojure.core/cond-> {} (letvar1205306 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205306 ["message"])))))))

(clojure.core/defn- response-test-authorization-response ([input] (response-test-authorization-response nil input)) ([resultWrapper1205308 input] (clojure.core/let [rawinput1205307 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205309 {"authResults" (rawinput1205307 "authResults")}] (clojure.core/cond-> {} (letvar1205309 "authResults") (clojure.core/assoc :auth-results (deser-auth-results (clojure.core/get-in letvar1205309 ["authResults"])))))))

(clojure.core/defn- response-list-jobs-response ([input] (response-list-jobs-response nil input)) ([resultWrapper1205311 input] (clojure.core/let [rawinput1205310 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205312 {"jobs" (rawinput1205310 "jobs"), "nextToken" (rawinput1205310 "nextToken")}] (clojure.core/cond-> {} (letvar1205312 "jobs") (clojure.core/assoc :jobs (deser-job-summary-list (clojure.core/get-in letvar1205312 ["jobs"]))) (letvar1205312 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205312 ["nextToken"])))))))

(clojure.core/defn- response-attach-thing-principal-response ([input] (response-attach-thing-principal-response nil input)) ([resultWrapper1205314 input] (clojure.core/let [rawinput1205313 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205315 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-update-dynamic-thing-group-response ([input] (response-update-dynamic-thing-group-response nil input)) ([resultWrapper1205317 input] (clojure.core/let [rawinput1205316 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205318 {"version" (rawinput1205316 "version")}] (clojure.core/cond-> {} (letvar1205318 "version") (clojure.core/assoc :version (deser-version (clojure.core/get-in letvar1205318 ["version"])))))))

(clojure.core/defn- response-untag-resource-response ([input] (response-untag-resource-response nil input)) ([resultWrapper1205320 input] (clojure.core/let [rawinput1205319 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205321 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-describe-stream-response ([input] (response-describe-stream-response nil input)) ([resultWrapper1205323 input] (clojure.core/let [rawinput1205322 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205324 {"streamInfo" (rawinput1205322 "streamInfo")}] (clojure.core/cond-> {} (letvar1205324 "streamInfo") (clojure.core/assoc :stream-info (deser-stream-info (clojure.core/get-in letvar1205324 ["streamInfo"])))))))

(clojure.core/defn- response-create-policy-version-response ([input] (response-create-policy-version-response nil input)) ([resultWrapper1205326 input] (clojure.core/let [rawinput1205325 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205327 {"policyArn" (rawinput1205325 "policyArn"), "policyDocument" (rawinput1205325 "policyDocument"), "policyVersionId" (rawinput1205325 "policyVersionId"), "isDefaultVersion" (rawinput1205325 "isDefaultVersion")}] (clojure.core/cond-> {} (letvar1205327 "policyArn") (clojure.core/assoc :policy-arn (deser-policy-arn (clojure.core/get-in letvar1205327 ["policyArn"]))) (letvar1205327 "policyDocument") (clojure.core/assoc :policy-document (deser-policy-document (clojure.core/get-in letvar1205327 ["policyDocument"]))) (letvar1205327 "policyVersionId") (clojure.core/assoc :policy-version-id (deser-policy-version-id (clojure.core/get-in letvar1205327 ["policyVersionId"]))) (letvar1205327 "isDefaultVersion") (clojure.core/assoc :is-default-version (deser-is-default-version (clojure.core/get-in letvar1205327 ["isDefaultVersion"])))))))

(clojure.core/defn- response-create-security-profile-response ([input] (response-create-security-profile-response nil input)) ([resultWrapper1205329 input] (clojure.core/let [rawinput1205328 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205330 {"securityProfileName" (rawinput1205328 "securityProfileName"), "securityProfileArn" (rawinput1205328 "securityProfileArn")}] (clojure.core/cond-> {} (letvar1205330 "securityProfileName") (clojure.core/assoc :security-profile-name (deser-security-profile-name (clojure.core/get-in letvar1205330 ["securityProfileName"]))) (letvar1205330 "securityProfileArn") (clojure.core/assoc :security-profile-arn (deser-security-profile-arn (clojure.core/get-in letvar1205330 ["securityProfileArn"])))))))

(clojure.core/defn- response-describe-endpoint-response ([input] (response-describe-endpoint-response nil input)) ([resultWrapper1205332 input] (clojure.core/let [rawinput1205331 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205333 {"endpointAddress" (rawinput1205331 "endpointAddress")}] (clojure.core/cond-> {} (letvar1205333 "endpointAddress") (clojure.core/assoc :endpoint-address (deser-endpoint-address (clojure.core/get-in letvar1205333 ["endpointAddress"])))))))

(clojure.core/defn- response-delete-thing-group-response ([input] (response-delete-thing-group-response nil input)) ([resultWrapper1205335 input] (clojure.core/let [rawinput1205334 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205336 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-account-audit-configuration-response ([input] (response-delete-account-audit-configuration-response nil input)) ([resultWrapper1205338 input] (clojure.core/let [rawinput1205337 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205339 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-set-default-authorizer-response ([input] (response-set-default-authorizer-response nil input)) ([resultWrapper1205341 input] (clojure.core/let [rawinput1205340 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205342 {"authorizerName" (rawinput1205340 "authorizerName"), "authorizerArn" (rawinput1205340 "authorizerArn")}] (clojure.core/cond-> {} (letvar1205342 "authorizerName") (clojure.core/assoc :authorizer-name (deser-authorizer-name (clojure.core/get-in letvar1205342 ["authorizerName"]))) (letvar1205342 "authorizerArn") (clojure.core/assoc :authorizer-arn (deser-authorizer-arn (clojure.core/get-in letvar1205342 ["authorizerArn"])))))))

(clojure.core/defn- response-list-billing-groups-response ([input] (response-list-billing-groups-response nil input)) ([resultWrapper1205344 input] (clojure.core/let [rawinput1205343 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205345 {"billingGroups" (rawinput1205343 "billingGroups"), "nextToken" (rawinput1205343 "nextToken")}] (clojure.core/cond-> {} (letvar1205345 "billingGroups") (clojure.core/assoc :billing-groups (deser-billing-group-name-and-arn-list (clojure.core/get-in letvar1205345 ["billingGroups"]))) (letvar1205345 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205345 ["nextToken"])))))))

(clojure.core/defn- response-update-indexing-configuration-response ([input] (response-update-indexing-configuration-response nil input)) ([resultWrapper1205347 input] (clojure.core/let [rawinput1205346 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205348 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-things-response ([input] (response-list-things-response nil input)) ([resultWrapper1205350 input] (clojure.core/let [rawinput1205349 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205351 {"things" (rawinput1205349 "things"), "nextToken" (rawinput1205349 "nextToken")}] (clojure.core/cond-> {} (letvar1205351 "things") (clojure.core/assoc :things (deser-thing-attribute-list (clojure.core/get-in letvar1205351 ["things"]))) (letvar1205351 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205351 ["nextToken"])))))))

(clojure.core/defn- response-create-thing-type-response ([input] (response-create-thing-type-response nil input)) ([resultWrapper1205353 input] (clojure.core/let [rawinput1205352 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205354 {"thingTypeName" (rawinput1205352 "thingTypeName"), "thingTypeArn" (rawinput1205352 "thingTypeArn"), "thingTypeId" (rawinput1205352 "thingTypeId")}] (clojure.core/cond-> {} (letvar1205354 "thingTypeName") (clojure.core/assoc :thing-type-name (deser-thing-type-name (clojure.core/get-in letvar1205354 ["thingTypeName"]))) (letvar1205354 "thingTypeArn") (clojure.core/assoc :thing-type-arn (deser-thing-type-arn (clojure.core/get-in letvar1205354 ["thingTypeArn"]))) (letvar1205354 "thingTypeId") (clojure.core/assoc :thing-type-id (deser-thing-type-id (clojure.core/get-in letvar1205354 ["thingTypeId"])))))))

(clojure.core/defn- response-certificate-conflict-exception ([input] (response-certificate-conflict-exception nil input)) ([resultWrapper1205356 input] (clojure.core/let [rawinput1205355 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205357 {"message" (rawinput1205355 "message")}] (clojure.core/cond-> {} (letvar1205357 "message") (clojure.core/assoc :message (desererror-message (clojure.core/get-in letvar1205357 ["message"])))))))

(clojure.core/defn- response-list-outgoing-certificates-response ([input] (response-list-outgoing-certificates-response nil input)) ([resultWrapper1205359 input] (clojure.core/let [rawinput1205358 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205360 {"outgoingCertificates" (rawinput1205358 "outgoingCertificates"), "nextMarker" (rawinput1205358 "nextMarker")}] (clojure.core/cond-> {} (letvar1205360 "outgoingCertificates") (clojure.core/assoc :outgoing-certificates (deser-outgoing-certificates (clojure.core/get-in letvar1205360 ["outgoingCertificates"]))) (letvar1205360 "nextMarker") (clojure.core/assoc :next-marker (deser-marker (clojure.core/get-in letvar1205360 ["nextMarker"])))))))

(clojure.core/defn- response-delete-role-alias-response ([input] (response-delete-role-alias-response nil input)) ([resultWrapper1205362 input] (clojure.core/let [rawinput1205361 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205363 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-delete-ota-update-response ([input] (response-delete-ota-update-response nil input)) ([resultWrapper1205365 input] (clojure.core/let [rawinput1205364 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205366 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-register-thing-response ([input] (response-register-thing-response nil input)) ([resultWrapper1205368 input] (clojure.core/let [rawinput1205367 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205369 {"certificatePem" (rawinput1205367 "certificatePem"), "resourceArns" (rawinput1205367 "resourceArns")}] (clojure.core/cond-> {} (letvar1205369 "certificatePem") (clojure.core/assoc :certificate-pem (deser-certificate-pem (clojure.core/get-in letvar1205369 ["certificatePem"]))) (letvar1205369 "resourceArns") (clojure.core/assoc :resource-arns (deser-resource-arns (clojure.core/get-in letvar1205369 ["resourceArns"])))))))

(clojure.core/defn- response-update-account-audit-configuration-response ([input] (response-update-account-audit-configuration-response nil input)) ([resultWrapper1205371 input] (clojure.core/let [rawinput1205370 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205372 {}] (clojure.core/cond-> {}))))

(clojure.core/defn- response-list-ota-updates-response ([input] (response-list-ota-updates-response nil input)) ([resultWrapper1205374 input] (clojure.core/let [rawinput1205373 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1205375 {"otaUpdates" (rawinput1205373 "otaUpdates"), "nextToken" (rawinput1205373 "nextToken")}] (clojure.core/cond-> {} (letvar1205375 "otaUpdates") (clojure.core/assoc :ota-updates (deser-ota-updates-summary (clojure.core/get-in letvar1205375 ["otaUpdates"]))) (letvar1205375 "nextToken") (clojure.core/assoc :next-token (deser-next-token (clojure.core/get-in letvar1205375 ["nextToken"])))))))

(clojure.spec.alpha/def :portkey.aws.iot/delete-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.start-on-demand-audit-task-request/target-check-names (clojure.spec.alpha/and :portkey.aws.iot/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot/start-on-demand-audit-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.start-on-demand-audit-task-request/target-check-names] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/audit-task-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.iot/audit-task-metadata))

(clojure.spec.alpha/def :portkey.aws.iot.accept-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.accept-certificate-transfer-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot/accept-certificate-transfer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.accept-certificate-transfer-request/certificate-id] :opt-un [:portkey.aws.iot.accept-certificate-transfer-request/set-as-active]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-billing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/delete-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-billing-group-request/billing-group-name] :opt-un [:portkey.aws.iot.delete-billing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-request/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-request/query-string (clojure.spec.alpha/and :portkey.aws.iot/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-request/query-version (clojure.spec.alpha/and :portkey.aws.iot/query-version))
(clojure.spec.alpha/def :portkey.aws.iot/update-dynamic-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-dynamic-thing-group-request/thing-group-name :portkey.aws.iot.update-dynamic-thing-group-request/thing-group-properties] :opt-un [:portkey.aws.iot.update-dynamic-thing-group-request/expected-version :portkey.aws.iot.update-dynamic-thing-group-request/index-name :portkey.aws.iot.update-dynamic-thing-group-request/query-string :portkey.aws.iot.update-dynamic-thing-group-request/query-version]))

(clojure.spec.alpha/def :portkey.aws.iot/audit-finding-severity #{"CRITICAL" :medium "LOW" :high :critical "HIGH" :low "MEDIUM"})

(clojure.spec.alpha/def :portkey.aws.iot/registry-max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot/stream-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.get-effective-policies-response/effective-policies (clojure.spec.alpha/and :portkey.aws.iot/effective-policies))
(clojure.spec.alpha/def :portkey.aws.iot/get-effective-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-effective-policies-response/effective-policies]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-versions-response/policy-versions (clojure.spec.alpha/and :portkey.aws.iot/policy-versions))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-versions-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-policy-versions-response/policy-versions]))

(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-request/start-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-request/end-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-violation-events-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-violation-events-request/start-time :portkey.aws.iot.list-violation-events-request/end-time] :opt-un [:portkey.aws.iot.list-violation-events-request/thing-name :portkey.aws.iot.list-violation-events-request/security-profile-name :portkey.aws.iot.list-violation-events-request/next-token :portkey.aws.iot.list-violation-events-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/expected-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/delete-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/billing-group-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/compliant-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/auto-registration-status #{:disable "DISABLE" :enable "ENABLE"})

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-targets (clojure.spec.alpha/coll-of :portkey.aws.iot/security-profile-target))

(clojure.spec.alpha/def :portkey.aws.iot/thing-indexing-mode #{"REGISTRY_AND_SHADOW" :registry "REGISTRY" :registry-and-shadow :off "OFF"})

(clojure.spec.alpha/def :portkey.aws.iot/canceled-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.billing-group-properties/billing-group-description (clojure.spec.alpha/and :portkey.aws.iot/billing-group-description))
(clojure.spec.alpha/def :portkey.aws.iot/billing-group-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.billing-group-properties/billing-group-description]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-event-configurations-response/event-configurations (clojure.spec.alpha/and :portkey.aws.iot/event-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.describe-event-configurations-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.describe-event-configurations-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/last-modified-date))
(clojure.spec.alpha/def :portkey.aws.iot/describe-event-configurations-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-event-configurations-response/event-configurations :portkey.aws.iot.describe-event-configurations-response/creation-date :portkey.aws.iot.describe-event-configurations-response/last-modified-date]))

(clojure.spec.alpha/def :portkey.aws.iot/skyfall-max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-authorizers-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-authorizers-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-authorizers-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot.list-authorizers-request/status (clojure.spec.alpha/and :portkey.aws.iot/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot/list-authorizers-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-authorizers-request/page-size :portkey.aws.iot.list-authorizers-request/marker :portkey.aws.iot.list-authorizers-request/ascending-order :portkey.aws.iot.list-authorizers-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-security-profile-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/delete-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.delete-security-profile-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot/scheduled-audit-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.deprecate-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.deprecate-thing-type-request/undo-deprecate (clojure.spec.alpha/and :portkey.aws.iot/undo-deprecate))
(clojure.spec.alpha/def :portkey.aws.iot/deprecate-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.deprecate-thing-type-request/thing-type-name] :opt-un [:portkey.aws.iot.deprecate-thing-type-request/undo-deprecate]))

(clojure.spec.alpha/def :portkey.aws.iot.unauthorized-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/unauthorized-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.unauthorized-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/outgoing-certificates (clojure.spec.alpha/coll-of :portkey.aws.iot/outgoing-certificate))

(clojure.spec.alpha/def :portkey.aws.iot.detach-principal-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.detach-principal-policy-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/detach-principal-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.detach-principal-policy-request/policy-name :portkey.aws.iot.detach-principal-policy-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/security-profile-arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/behaviors (clojure.spec.alpha/and :portkey.aws.iot/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-response/alert-targets (clojure.spec.alpha/and :portkey.aws.iot/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot/update-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-security-profile-response/creation-date :portkey.aws.iot.update-security-profile-response/security-profile-arn :portkey.aws.iot.update-security-profile-response/additional-metrics-to-retain :portkey.aws.iot.update-security-profile-response/behaviors :portkey.aws.iot.update-security-profile-response/last-modified-date :portkey.aws.iot.update-security-profile-response/security-profile-description :portkey.aws.iot.update-security-profile-response/version :portkey.aws.iot.update-security-profile-response/security-profile-name :portkey.aws.iot.update-security-profile-response/alert-targets]))

(clojure.spec.alpha/def :portkey.aws.iot/range-key-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-billing-group-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-billing-group-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-in-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-things-in-billing-group-request/billing-group-name] :opt-un [:portkey.aws.iot.list-things-in-billing-group-request/next-token :portkey.aws.iot.list-things-in-billing-group-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-group-indexing-configuration/thing-group-indexing-mode (clojure.spec.alpha/and :portkey.aws.iot/thing-group-indexing-mode))
(clojure.spec.alpha/def :portkey.aws.iot/thing-group-indexing-configuration (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.thing-group-indexing-configuration/thing-group-indexing-mode] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1000)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-policy-response/targets (clojure.spec.alpha/and :portkey.aws.iot/policy-targets))
(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-policy-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-targets-for-policy-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-targets-for-policy-response/targets :portkey.aws.iot.list-targets-for-policy-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-attribute))

(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-request/token (clojure.spec.alpha/and :portkey.aws.iot/token))
(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-request/token-signature (clojure.spec.alpha/and :portkey.aws.iot/token-signature))
(clojure.spec.alpha/def :portkey.aws.iot/test-invoke-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.test-invoke-authorizer-request/authorizer-name :portkey.aws.iot.test-invoke-authorizer-request/token :portkey.aws.iot.test-invoke-authorizer-request/token-signature] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-document-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-group-document))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/log-target-configurations (clojure.spec.alpha/coll-of :portkey.aws.iot/log-target-configuration))

(clojure.spec.alpha/def :portkey.aws.iot/in-progress-timeout-in-minutes clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.thing-type-properties/thing-type-description (clojure.spec.alpha/and :portkey.aws.iot/thing-type-description))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-properties/searchable-attributes (clojure.spec.alpha/and :portkey.aws.iot/searchable-attributes))
(clojure.spec.alpha/def :portkey.aws.iot/thing-type-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-type-properties/thing-type-description :portkey.aws.iot.thing-type-properties/searchable-attributes]))

(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/ca-certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active-flag))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot/register-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.register-certificate-request/certificate-pem] :opt-un [:portkey.aws.iot.register-certificate-request/ca-certificate-pem :portkey.aws.iot.register-certificate-request/set-as-active :portkey.aws.iot.register-certificate-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot/detach-thing-principal-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-thing-request/thing-name] :opt-un [:portkey.aws.iot.create-thing-request/thing-type-name :portkey.aws.iot.create-thing-request/attribute-payload :portkey.aws.iot.create-thing-request/billing-group-name]))

(clojure.spec.alpha/def :portkey.aws.iot/stream-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/token-signature (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2560)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[A-Za-z0-9+/]+={0,2}" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.start-thing-registration-task-response/task-id (clojure.spec.alpha/and :portkey.aws.iot/task-id))
(clojure.spec.alpha/def :portkey.aws.iot/start-thing-registration-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.start-thing-registration-task-response/task-id]))

(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary-for-job/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary-for-job/job-execution-summary (clojure.spec.alpha/and :portkey.aws.iot/job-execution-summary))
(clojure.spec.alpha/def :portkey.aws.iot/job-execution-summary-for-job (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-execution-summary-for-job/thing-arn :portkey.aws.iot.job-execution-summary-for-job/job-execution-summary]))

(clojure.spec.alpha/def :portkey.aws.iot.code-signing/aws-signer-job-id (clojure.spec.alpha/and :portkey.aws.iot/signing-job-id))
(clojure.spec.alpha/def :portkey.aws.iot.code-signing/start-signing-job-parameter (clojure.spec.alpha/and :portkey.aws.iot/start-signing-job-parameter))
(clojure.spec.alpha/def :portkey.aws.iot.code-signing/custom-code-signing (clojure.spec.alpha/and :portkey.aws.iot/custom-code-signing))
(clojure.spec.alpha/def :portkey.aws.iot/code-signing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.code-signing/aws-signer-job-id :portkey.aws.iot.code-signing/start-signing-job-parameter :portkey.aws.iot.code-signing/custom-code-signing]))

(clojure.spec.alpha/def :portkey.aws.iot.dynamo-d-bv-2-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-d-bv-2-action/put-item (clojure.spec.alpha/and :portkey.aws.iot/put-item-input))
(clojure.spec.alpha/def :portkey.aws.iot/dynamo-d-bv-2-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.dynamo-d-bv-2-action/role-arn :portkey.aws.iot.dynamo-d-bv-2-action/put-item] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/audit-notification-target-configurations (clojure.spec.alpha/map-of :portkey.aws.iot/audit-notification-type :portkey.aws.iot/audit-notification-target))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-response/thing-groups (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-groups-response/thing-groups :portkey.aws.iot.list-thing-groups-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.statistical-threshold/statistic (clojure.spec.alpha/and :portkey.aws.iot/evaluation-statistic))
(clojure.spec.alpha/def :portkey.aws.iot/statistical-threshold (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.statistical-threshold/statistic]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-registration-code-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-for-target-response/security-profile-target-mappings (clojure.spec.alpha/and :portkey.aws.iot/security-profile-target-mappings))
(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-for-target-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-security-profiles-for-target-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-security-profiles-for-target-response/security-profile-target-mappings :portkey.aws.iot.list-security-profiles-for-target-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/override-dynamic-groups clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/sql (clojure.spec.alpha/and :portkey.aws.iot/sql))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/description (clojure.spec.alpha/and :portkey.aws.iot/description))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/actions (clojure.spec.alpha/and :portkey.aws.iot/action-list))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/aws-iot-sql-version (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-sql-version))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/error-action (clojure.spec.alpha/and :portkey.aws.iot/action))
(clojure.spec.alpha/def :portkey.aws.iot/topic-rule-payload (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.topic-rule-payload/sql :portkey.aws.iot.topic-rule-payload/actions] :opt-un [:portkey.aws.iot.topic-rule-payload/description :portkey.aws.iot.topic-rule-payload/rule-disabled :portkey.aws.iot.topic-rule-payload/aws-iot-sql-version :portkey.aws.iot.topic-rule-payload/error-action]))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-things-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-principal-things-response/things :portkey.aws.iot.list-principal-things-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.ota-update-summary/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-summary/ota-update-arn (clojure.spec.alpha/and :portkey.aws.iot/ota-update-arn))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-summary/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/ota-update-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.ota-update-summary/ota-update-id :portkey.aws.iot.ota-update-summary/ota-update-arn :portkey.aws.iot.ota-update-summary/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot/minimum-number-of-executed-things (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot/cidr (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 2 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 43)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-fA-F0-9:\.\/]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/active-violations (clojure.spec.alpha/coll-of :portkey.aws.iot/active-violation))

(clojure.spec.alpha/def :portkey.aws.iot.create-billing-group-response/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-billing-group-response/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-billing-group-response/billing-group-id (clojure.spec.alpha/and :portkey.aws.iot/billing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot/create-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-billing-group-response/billing-group-name :portkey.aws.iot.create-billing-group-response/billing-group-arn :portkey.aws.iot.create-billing-group-response/billing-group-id]))

(clojure.spec.alpha/def :portkey.aws.iot/string-map (clojure.spec.alpha/map-of :portkey.aws.iot/string :portkey.aws.iot/string))

(clojure.spec.alpha/def :portkey.aws.iot/platform (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.stream-info/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/stream-arn (clojure.spec.alpha/and :portkey.aws.iot/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/stream-version (clojure.spec.alpha/and :portkey.aws.iot/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/description (clojure.spec.alpha/and :portkey.aws.iot/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/files (clojure.spec.alpha/and :portkey.aws.iot/stream-files))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/created-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.stream-info/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot/stream-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.stream-info/stream-id :portkey.aws.iot.stream-info/stream-arn :portkey.aws.iot.stream-info/stream-version :portkey.aws.iot.stream-info/description :portkey.aws.iot.stream-info/files :portkey.aws.iot.stream-info/created-at :portkey.aws.iot.stream-info/last-updated-at :portkey.aws.iot.stream-info/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/private-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-response/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-response/aws-iot-job-id (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-job-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-response/ota-update-arn (clojure.spec.alpha/and :portkey.aws.iot/ota-update-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-response/aws-iot-job-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-response/ota-update-status (clojure.spec.alpha/and :portkey.aws.iot/ota-update-status))
(clojure.spec.alpha/def :portkey.aws.iot/create-ota-update-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-ota-update-response/ota-update-id :portkey.aws.iot.create-ota-update-response/aws-iot-job-id :portkey.aws.iot.create-ota-update-response/ota-update-arn :portkey.aws.iot.create-ota-update-response/aws-iot-job-arn :portkey.aws.iot.create-ota-update-response/ota-update-status]))

(clojure.spec.alpha/def :portkey.aws.iot.list-ota-updates-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-ota-updates-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-ota-updates-request/ota-update-status (clojure.spec.alpha/and :portkey.aws.iot/ota-update-status))
(clojure.spec.alpha/def :portkey.aws.iot/list-ota-updates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-ota-updates-request/max-results :portkey.aws.iot.list-ota-updates-request/next-token :portkey.aws.iot.list-ota-updates-request/ota-update-status]))

(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-response/job-arn (clojure.spec.alpha/and :portkey.aws.iot/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-response/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-response/description (clojure.spec.alpha/and :portkey.aws.iot/job-description))
(clojure.spec.alpha/def :portkey.aws.iot/cancel-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.cancel-job-response/job-arn :portkey.aws.iot.cancel-job-response/job-id :portkey.aws.iot.cancel-job-response/description]))

(clojure.spec.alpha/def :portkey.aws.iot.list-scheduled-audits-response/scheduled-audits (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-metadata-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-scheduled-audits-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-scheduled-audits-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-scheduled-audits-response/scheduled-audits :portkey.aws.iot.list-scheduled-audits-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-request/target-aws-account (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-request/transfer-message (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.transfer-certificate-request/certificate-id :portkey.aws.iot.transfer-certificate-request/target-aws-account] :opt-un [:portkey.aws.iot.transfer-certificate-request/transfer-message]))

(clojure.spec.alpha/def :portkey.aws.iot.update-event-configurations-request/event-configurations (clojure.spec.alpha/and :portkey.aws.iot/event-configurations))
(clojure.spec.alpha/def :portkey.aws.iot/update-event-configurations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-event-configurations-request/event-configurations]))

(clojure.spec.alpha/def :portkey.aws.iot.explicit-deny/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot/explicit-deny (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.explicit-deny/policies]))

(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-security-profile-response/security-profile-targets (clojure.spec.alpha/and :portkey.aws.iot/security-profile-targets))
(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-security-profile-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-targets-for-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-targets-for-security-profile-response/security-profile-targets :portkey.aws.iot.list-targets-for-security-profile-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/deprecation-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot/delete-stream clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.update-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.update-certificate-request/new-status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot/update-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-certificate-request/certificate-id :portkey.aws.iot.update-certificate-request/new-status] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/function-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-billing-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-billing-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-billing-groups-request/name-prefix-filter (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-billing-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-billing-groups-request/next-token :portkey.aws.iot.list-billing-groups-request/max-results :portkey.aws.iot.list-billing-groups-request/name-prefix-filter]))

(clojure.spec.alpha/def :portkey.aws.iot/resource-logical-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/topic-pattern (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-role-alias-response/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.create-role-alias-response/role-alias-arn (clojure.spec.alpha/and :portkey.aws.iot/role-alias-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-role-alias-response/role-alias :portkey.aws.iot.create-role-alias-response/role-alias-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/removed-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/get-v-2-logging-options-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/signature-algorithm (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/index-status #{:building "REBUILDING" :active "BUILDING" "ACTIVE" :rebuilding})

(clojure.spec.alpha/def :portkey.aws.iot/query-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/rule-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_]+$" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.violation-event/violation-id (clojure.spec.alpha/and :portkey.aws.iot/violation-id))
(clojure.spec.alpha/def :portkey.aws.iot.violation-event/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.violation-event/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.violation-event/behavior (clojure.spec.alpha/and :portkey.aws.iot/behavior))
(clojure.spec.alpha/def :portkey.aws.iot.violation-event/metric-value (clojure.spec.alpha/and :portkey.aws.iot/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.violation-event/violation-event-type (clojure.spec.alpha/and :portkey.aws.iot/violation-event-type))
(clojure.spec.alpha/def :portkey.aws.iot.violation-event/violation-event-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot/violation-event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.violation-event/violation-id :portkey.aws.iot.violation-event/thing-name :portkey.aws.iot.violation-event/security-profile-name :portkey.aws.iot.violation-event/behavior :portkey.aws.iot.violation-event/metric-value :portkey.aws.iot.violation-event/violation-event-type :portkey.aws.iot.violation-event/violation-event-time]))

(clojure.spec.alpha/def :portkey.aws.iot/s-3-file-url-list (clojure.spec.alpha/coll-of :portkey.aws.iot/s-3-file-url))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/default-client-id (clojure.spec.alpha/and :portkey.aws.iot/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/thing-id (clojure.spec.alpha/and :portkey.aws.iot/thing-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-thing-response/default-client-id :portkey.aws.iot.describe-thing-response/thing-name :portkey.aws.iot.describe-thing-response/thing-id :portkey.aws.iot.describe-thing-response/thing-arn :portkey.aws.iot.describe-thing-response/thing-type-name :portkey.aws.iot.describe-thing-response/attributes :portkey.aws.iot.describe-thing-response/version :portkey.aws.iot.describe-thing-response/billing-group-name]))

(clojure.spec.alpha/def :portkey.aws.iot/non-compliant-resources-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/job-status #{"COMPLETED" "CANCELED" "IN_PROGRESS" :in-progress :completed :deletion-in-progress :canceled "DELETION_IN_PROGRESS"})

(clojure.spec.alpha/def :portkey.aws.iot/failed-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.code-signing-certificate-chain/certificate-name (clojure.spec.alpha/and :portkey.aws.iot/certificate-name))
(clojure.spec.alpha/def :portkey.aws.iot.code-signing-certificate-chain/inline-document (clojure.spec.alpha/and :portkey.aws.iot/inline-document))
(clojure.spec.alpha/def :portkey.aws.iot/code-signing-certificate-chain (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.code-signing-certificate-chain/certificate-name :portkey.aws.iot.code-signing-certificate-chain/inline-document]))

(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot/create-keys-and-certificate-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-keys-and-certificate-request/set-as-active]))

(clojure.spec.alpha/def :portkey.aws.iot.update-ca-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.update-ca-certificate-request/new-status (clojure.spec.alpha/and :portkey.aws.iot/ca-certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.update-ca-certificate-request/new-auto-registration-status (clojure.spec.alpha/and :portkey.aws.iot/auto-registration-status))
(clojure.spec.alpha/def :portkey.aws.iot.update-ca-certificate-request/registration-config (clojure.spec.alpha/and :portkey.aws.iot/registration-config))
(clojure.spec.alpha/def :portkey.aws.iot.update-ca-certificate-request/remove-auto-registration (clojure.spec.alpha/and :portkey.aws.iot/remove-auto-registration))
(clojure.spec.alpha/def :portkey.aws.iot/update-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-ca-certificate-request/certificate-id] :opt-un [:portkey.aws.iot.update-ca-certificate-request/new-status :portkey.aws.iot.update-ca-certificate-request/new-auto-registration-status :portkey.aws.iot.update-ca-certificate-request/registration-config :portkey.aws.iot.update-ca-certificate-request/remove-auto-registration]))

(clojure.spec.alpha/def :portkey.aws.iot.search-index-request/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.search-index-request/query-string (clojure.spec.alpha/and :portkey.aws.iot/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.search-index-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.search-index-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/query-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.search-index-request/query-version (clojure.spec.alpha/and :portkey.aws.iot/query-version))
(clojure.spec.alpha/def :portkey.aws.iot/search-index-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.search-index-request/query-string] :opt-un [:portkey.aws.iot.search-index-request/index-name :portkey.aws.iot.search-index-request/next-token :portkey.aws.iot.search-index-request/max-results :portkey.aws.iot.search-index-request/query-version]))

(clojure.spec.alpha/def :portkey.aws.iot/comment (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-state-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-state-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.certificate-state-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-signing-request (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot/missing-context-values (clojure.spec.alpha/coll-of :portkey.aws.iot/missing-context-value))

(clojure.spec.alpha/def :portkey.aws.iot/day-of-week #{:wed "TUE" "SAT" "SUN" :sat "MON" :tue :fri :sun "THU" "WED" "FRI" :mon :thu})

(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-response/is-authenticated (clojure.spec.alpha/and :portkey.aws.iot/is-authenticated))
(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-response/principal-id (clojure.spec.alpha/and :portkey.aws.iot/principal-id))
(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-response/policy-documents (clojure.spec.alpha/and :portkey.aws.iot/policy-documents))
(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-response/refresh-after-in-seconds (clojure.spec.alpha/and :portkey.aws.iot/seconds))
(clojure.spec.alpha/def :portkey.aws.iot.test-invoke-authorizer-response/disconnect-after-in-seconds (clojure.spec.alpha/and :portkey.aws.iot/seconds))
(clojure.spec.alpha/def :portkey.aws.iot/test-invoke-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.test-invoke-authorizer-response/is-authenticated :portkey.aws.iot.test-invoke-authorizer-response/principal-id :portkey.aws.iot.test-invoke-authorizer-response/policy-documents :portkey.aws.iot.test-invoke-authorizer-response/refresh-after-in-seconds :portkey.aws.iot.test-invoke-authorizer-response/disconnect-after-in-seconds]))

(clojure.spec.alpha/def :portkey.aws.iot/page-size (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.invalid-request-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/invalid-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.invalid-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/cancel-audit-task-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-tags-for-resource-response/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-tags-for-resource-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-tags-for-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-tags-for-resource-response/tags :portkey.aws.iot.list-tags-for-resource-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/prefix (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/message-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot.security-profile-target/arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot/security-profile-target (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.security-profile-target/arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-validation-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-validation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.certificate-validation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/streams-summary (clojure.spec.alpha/coll-of :portkey.aws.iot/stream-summary))

(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot/thing-attribute (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-attribute/thing-name :portkey.aws.iot.thing-attribute/thing-type-name :portkey.aws.iot.thing-attribute/thing-arn :portkey.aws.iot.thing-attribute/attributes :portkey.aws.iot.thing-attribute/version]))

(clojure.spec.alpha/def :portkey.aws.iot.abort-criteria/failure-type (clojure.spec.alpha/and :portkey.aws.iot/job-execution-failure-type))
(clojure.spec.alpha/def :portkey.aws.iot.abort-criteria/action (clojure.spec.alpha/and :portkey.aws.iot/abort-action))
(clojure.spec.alpha/def :portkey.aws.iot.abort-criteria/threshold-percentage (clojure.spec.alpha/and :portkey.aws.iot/abort-threshold-percentage))
(clojure.spec.alpha/def :portkey.aws.iot.abort-criteria/min-number-of-executed-things (clojure.spec.alpha/and :portkey.aws.iot/minimum-number-of-executed-things))
(clojure.spec.alpha/def :portkey.aws.iot/abort-criteria (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.abort-criteria/failure-type :portkey.aws.iot.abort-criteria/action :portkey.aws.iot.abort-criteria/threshold-percentage :portkey.aws.iot.abort-criteria/min-number-of-executed-things] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.validation-error/error-message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/validation-error (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.validation-error/error-message]))

(clojure.spec.alpha/def :portkey.aws.iot/index-names-list (clojure.spec.alpha/coll-of :portkey.aws.iot/index-name))

(clojure.spec.alpha/def :portkey.aws.iot.update-thing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot/update-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-thing-group-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-security-profile-request/security-profile-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/topic (clojure.spec.alpha/and :portkey.aws.iot/topic))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/ge-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot/list-topic-rules-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-topic-rules-request/topic :portkey.aws.iot.list-topic-rules-request/max-results :portkey.aws.iot.list-topic-rules-request/next-token :portkey.aws.iot.list-topic-rules-request/rule-disabled]))

(clojure.spec.alpha/def :portkey.aws.iot/audit-task-type #{"SCHEDULED_AUDIT_TASK" :scheduled-audit-task "ON_DEMAND_AUDIT_TASK" :on-demand-audit-task})

(clojure.spec.alpha/def :portkey.aws.iot/canned-access-control-list #{"authenticated-read" :logdeliverywrite :bucketownerfullcontrol "public-read-write" :private "bucket-owner-full-control" "private" :bucketownerread :publicread "aws-exec-read" :publicreadwrite :awsexecread "bucket-owner-read" "public-read" "log-delivery-write" :authenticatedread})

(clojure.spec.alpha/def :portkey.aws.iot/connectivity-timestamp clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/duration-seconds clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-outgoing-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-outgoing-certificates-request/page-size :portkey.aws.iot.list-outgoing-certificates-request/marker :portkey.aws.iot.list-outgoing-certificates-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/violation-events (clojure.spec.alpha/coll-of :portkey.aws.iot/violation-event))

(clojure.spec.alpha/def :portkey.aws.iot.iot-events-action/input-name (clojure.spec.alpha/and :portkey.aws.iot/input-name))
(clojure.spec.alpha/def :portkey.aws.iot.iot-events-action/message-id (clojure.spec.alpha/and :portkey.aws.iot/message-id))
(clojure.spec.alpha/def :portkey.aws.iot.iot-events-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot/iot-events-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.iot-events-action/input-name :portkey.aws.iot.iot-events-action/role-arn] :opt-un [:portkey.aws.iot.iot-events-action/message-id]))

(clojure.spec.alpha/def :portkey.aws.iot/execution-number clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-policies-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-principal-policies-request/principal] :opt-un [:portkey.aws.iot.list-principal-policies-request/marker :portkey.aws.iot.list-principal-policies-request/page-size :portkey.aws.iot.list-principal-policies-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/input-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot/resource-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/additional-metrics-to-retain-list (clojure.spec.alpha/coll-of :portkey.aws.iot/behavior-metric))

(clojure.spec.alpha/def :portkey.aws.iot/number-of-things (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot.non-compliant-resource/resource-type (clojure.spec.alpha/and :portkey.aws.iot/resource-type))
(clojure.spec.alpha/def :portkey.aws.iot.non-compliant-resource/resource-identifier (clojure.spec.alpha/and :portkey.aws.iot/resource-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.non-compliant-resource/additional-info (clojure.spec.alpha/and :portkey.aws.iot/string-map))
(clojure.spec.alpha/def :portkey.aws.iot/non-compliant-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.non-compliant-resource/resource-type :portkey.aws.iot.non-compliant-resource/resource-identifier :portkey.aws.iot.non-compliant-resource/additional-info]))

(clojure.spec.alpha/def :portkey.aws.iot/key-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 5120))))

(clojure.spec.alpha/def :portkey.aws.iot.get-logging-options-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-logging-options-response/log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot/get-logging-options-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-logging-options-response/role-arn :portkey.aws.iot.get-logging-options-response/log-level]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-v-2-logging-options-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-v-2-logging-options-response/default-log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.get-v-2-logging-options-response/disable-all-logs (clojure.spec.alpha/and :portkey.aws.iot/disable-all-logs))
(clojure.spec.alpha/def :portkey.aws.iot/get-v-2-logging-options-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-v-2-logging-options-response/role-arn :portkey.aws.iot.get-v-2-logging-options-response/default-log-level :portkey.aws.iot.get-v-2-logging-options-response/disable-all-logs]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-for-thing-response/thing-groups (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-for-thing-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-groups-for-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-groups-for-thing-response/thing-groups :portkey.aws.iot.list-thing-groups-for-thing-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/attribute-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.,@/:#-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/transferred-to (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/transfer-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/transfer-message (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/outgoing-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.outgoing-certificate/certificate-arn :portkey.aws.iot.outgoing-certificate/certificate-id :portkey.aws.iot.outgoing-certificate/transferred-to :portkey.aws.iot.outgoing-certificate/transfer-date :portkey.aws.iot.outgoing-certificate/transfer-message :portkey.aws.iot.outgoing-certificate/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-account-audit-configuration-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-account-audit-configuration-response/audit-notification-target-configurations (clojure.spec.alpha/and :portkey.aws.iot/audit-notification-target-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.describe-account-audit-configuration-response/audit-check-configurations (clojure.spec.alpha/and :portkey.aws.iot/audit-check-configurations))
(clojure.spec.alpha/def :portkey.aws.iot/describe-account-audit-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-account-audit-configuration-response/role-arn :portkey.aws.iot.describe-account-audit-configuration-response/audit-notification-target-configurations :portkey.aws.iot.describe-account-audit-configuration-response/audit-check-configurations]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-index-response/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-index-response/index-status (clojure.spec.alpha/and :portkey.aws.iot/index-status))
(clojure.spec.alpha/def :portkey.aws.iot.describe-index-response/schema (clojure.spec.alpha/and :portkey.aws.iot/index-schema))
(clojure.spec.alpha/def :portkey.aws.iot/describe-index-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-index-response/index-name :portkey.aws.iot.describe-index-response/index-status :portkey.aws.iot.describe-index-response/schema]))

(clojure.spec.alpha/def :portkey.aws.iot/canceled-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/last-modified-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-response/certificates (clojure.spec.alpha/and :portkey.aws.iot/certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-certificates-response/certificates :portkey.aws.iot.list-certificates-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.set-default-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.set-default-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/set-default-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.set-default-policy-version-request/policy-name :portkey.aws.iot.set-default-policy-version-request/policy-version-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/describe-default-authorizer-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-billing-group-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-billing-group-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-in-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-things-in-billing-group-response/things :portkey.aws.iot.list-things-in-billing-group-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.enable-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/enable-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.enable-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/log-level #{"DISABLED" :disabled :warn "WARN" :debug "ERROR" "DEBUG" :info :error "INFO"})

(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-response/task-status (clojure.spec.alpha/and :portkey.aws.iot/audit-task-status))
(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-response/task-type (clojure.spec.alpha/and :portkey.aws.iot/audit-task-type))
(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-response/task-start-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-response/task-statistics (clojure.spec.alpha/and :portkey.aws.iot/task-statistics))
(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-response/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-response/audit-details (clojure.spec.alpha/and :portkey.aws.iot/audit-details))
(clojure.spec.alpha/def :portkey.aws.iot/describe-audit-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-audit-task-response/task-status :portkey.aws.iot.describe-audit-task-response/task-type :portkey.aws.iot.describe-audit-task-response/task-start-time :portkey.aws.iot.describe-audit-task-response/task-statistics :portkey.aws.iot.describe-audit-task-response/scheduled-audit-name :portkey.aws.iot.describe-audit-task-response/audit-details]))

(clojure.spec.alpha/def :portkey.aws.iot/target-audit-check-names (clojure.spec.alpha/coll-of :portkey.aws.iot/audit-check-name))

(clojure.spec.alpha/def :portkey.aws.iot/effective-policies (clojure.spec.alpha/coll-of :portkey.aws.iot/effective-policy))

(clojure.spec.alpha/def :portkey.aws.iot.create-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-stream-request/description (clojure.spec.alpha/and :portkey.aws.iot/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.create-stream-request/files (clojure.spec.alpha/and :portkey.aws.iot/stream-files))
(clojure.spec.alpha/def :portkey.aws.iot.create-stream-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-stream-request/stream-id :portkey.aws.iot.create-stream-request/files :portkey.aws.iot.create-stream-request/role-arn] :opt-un [:portkey.aws.iot.create-stream-request/description]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w+=,.@-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/ca-certificates (clojure.spec.alpha/coll-of :portkey.aws.iot/ca-certificate))

(clojure.spec.alpha/def :portkey.aws.iot/error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/action-list (clojure.spec.alpha/coll-of :portkey.aws.iot/action :min-count 0 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.iot.active-violation/violation-id (clojure.spec.alpha/and :portkey.aws.iot/violation-id))
(clojure.spec.alpha/def :portkey.aws.iot.active-violation/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.active-violation/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.active-violation/behavior (clojure.spec.alpha/and :portkey.aws.iot/behavior))
(clojure.spec.alpha/def :portkey.aws.iot.active-violation/last-violation-value (clojure.spec.alpha/and :portkey.aws.iot/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.active-violation/last-violation-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.active-violation/violation-start-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot/active-violation (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.active-violation/violation-id :portkey.aws.iot.active-violation/thing-name :portkey.aws.iot.active-violation/security-profile-name :portkey.aws.iot.active-violation/behavior :portkey.aws.iot.active-violation/last-violation-value :portkey.aws.iot.active-violation/last-violation-time :portkey.aws.iot.active-violation/violation-start-time]))

(clojure.spec.alpha/def :portkey.aws.iot.reject-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.reject-certificate-transfer-request/reject-reason (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot/reject-certificate-transfer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.reject-certificate-transfer-request/certificate-id] :opt-un [:portkey.aws.iot.reject-certificate-transfer-request/reject-reason]))

(clojure.spec.alpha/def :portkey.aws.iot.registration-config/template-body (clojure.spec.alpha/and :portkey.aws.iot/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.registration-config/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot/registration-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.registration-config/template-body :portkey.aws.iot.registration-config/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-certificates-request/page-size :portkey.aws.iot.list-certificates-request/marker :portkey.aws.iot.list-certificates-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/additional-parameter-map (clojure.spec.alpha/map-of :portkey.aws.iot/attribute-key :portkey.aws.iot/value))

(clojure.spec.alpha/def :portkey.aws.iot/json-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/laser-max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot/expires-in-sec clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/thing-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.describe-audit-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-audit-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-audit-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-thing-request/thing-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/template-body (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.behavior/name (clojure.spec.alpha/and :portkey.aws.iot/behavior-name))
(clojure.spec.alpha/def :portkey.aws.iot.behavior/metric (clojure.spec.alpha/and :portkey.aws.iot/behavior-metric))
(clojure.spec.alpha/def :portkey.aws.iot.behavior/criteria (clojure.spec.alpha/and :portkey.aws.iot/behavior-criteria))
(clojure.spec.alpha/def :portkey.aws.iot/behavior (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.behavior/name] :opt-un [:portkey.aws.iot.behavior/metric :portkey.aws.iot.behavior/criteria]))

(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-request/status (clojure.spec.alpha/and :portkey.aws.iot/job-status))
(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-request/target-selection (clojure.spec.alpha/and :portkey.aws.iot/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/laser-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-request/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot/list-jobs-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-jobs-request/status :portkey.aws.iot.list-jobs-request/target-selection :portkey.aws.iot.list-jobs-request/max-results :portkey.aws.iot.list-jobs-request/next-token :portkey.aws.iot.list-jobs-request/thing-group-name :portkey.aws.iot.list-jobs-request/thing-group-id]))

(clojure.spec.alpha/def :portkey.aws.iot/index-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.get-topic-rule-response/rule-arn (clojure.spec.alpha/and :portkey.aws.iot/rule-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-topic-rule-response/rule (clojure.spec.alpha/and :portkey.aws.iot/topic-rule))
(clojure.spec.alpha/def :portkey.aws.iot/get-topic-rule-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-topic-rule-response/rule-arn :portkey.aws.iot.get-topic-rule-response/rule]))

(clojure.spec.alpha/def :portkey.aws.iot.list-tags-for-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.iot/resource-arn))
(clojure.spec.alpha/def :portkey.aws.iot.list-tags-for-resource-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-tags-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-tags-for-resource-request/resource-arn] :opt-un [:portkey.aws.iot.list-tags-for-resource-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/certificates (clojure.spec.alpha/coll-of :portkey.aws.iot/certificate))

(clojure.spec.alpha/def :portkey.aws.iot/endpoint-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.attach-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.attach-policy-request/target (clojure.spec.alpha/and :portkey.aws.iot/policy-target))
(clojure.spec.alpha/def :portkey.aws.iot/attach-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.attach-policy-request/policy-name :portkey.aws.iot.attach-policy-request/target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.thing-type-metadata/deprecated (clojure.spec.alpha/and :portkey.aws.iot/boolean))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-metadata/deprecation-date (clojure.spec.alpha/and :portkey.aws.iot/deprecation-date))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot/thing-type-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-type-metadata/deprecated :portkey.aws.iot.thing-type-metadata/deprecation-date :portkey.aws.iot.thing-type-metadata/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-job-request/job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.delete-thing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-request/parent-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.create-thing-group-request/parent-group-name :portkey.aws.iot.create-thing-group-request/thing-group-properties :portkey.aws.iot.create-thing-group-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.attribute-payload/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.attribute-payload/merge (clojure.spec.alpha/and :portkey.aws.iot/flag))
(clojure.spec.alpha/def :portkey.aws.iot/attribute-payload (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.attribute-payload/attributes :portkey.aws.iot.attribute-payload/merge]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-thing-type-request/thing-type-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/parameters (clojure.spec.alpha/map-of :portkey.aws.iot/parameter :portkey.aws.iot/value))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-thing-group-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-thing-group-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-in-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-things-in-thing-group-response/things :portkey.aws.iot.list-things-in-thing-group-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/scheduled-audit-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.iot/scheduled-audit-metadata))

(clojure.spec.alpha/def :portkey.aws.iot/inline-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.describe-ca-certificate-response/certificate-description (clojure.spec.alpha/and :portkey.aws.iot/ca-certificate-description))
(clojure.spec.alpha/def :portkey.aws.iot.describe-ca-certificate-response/registration-config (clojure.spec.alpha/and :portkey.aws.iot/registration-config))
(clojure.spec.alpha/def :portkey.aws.iot/describe-ca-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-ca-certificate-response/certificate-description :portkey.aws.iot.describe-ca-certificate-response/registration-config]))

(clojure.spec.alpha/def :portkey.aws.iot/state-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.update-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-billing-group-request/billing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/billing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.update-billing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/update-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-billing-group-request/billing-group-name :portkey.aws.iot.update-billing-group-request/billing-group-properties] :opt-un [:portkey.aws.iot.update-billing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot/reason-for-non-compliance-code (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/use-base-64 clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.list-streams-response/streams (clojure.spec.alpha/and :portkey.aws.iot/streams-summary))
(clojure.spec.alpha/def :portkey.aws.iot.list-streams-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-streams-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-streams-response/streams :portkey.aws.iot.list-streams-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.create-job-response/job-arn (clojure.spec.alpha/and :portkey.aws.iot/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-response/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-response/description (clojure.spec.alpha/and :portkey.aws.iot/job-description))
(clojure.spec.alpha/def :portkey.aws.iot/create-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-job-response/job-arn :portkey.aws.iot.create-job-response/job-id :portkey.aws.iot.create-job-response/description]))

(clojure.spec.alpha/def :portkey.aws.iot.abort-config/criteria-list (clojure.spec.alpha/and :portkey.aws.iot/abort-criteria-list))
(clojure.spec.alpha/def :portkey.aws.iot/abort-config (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.abort-config/criteria-list] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-path-on-device (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-target-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/day-of-month (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"^([1-9]|[12][0-9]|3[01])$|^LAST$" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.describe-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-certificate-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/principal-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.update-role-alias-response/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.update-role-alias-response/role-alias-arn (clojure.spec.alpha/and :portkey.aws.iot/role-alias-arn))
(clojure.spec.alpha/def :portkey.aws.iot/update-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-role-alias-response/role-alias :portkey.aws.iot.update-role-alias-response/role-alias-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.list-indices-response/index-names (clojure.spec.alpha/and :portkey.aws.iot/index-names-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-indices-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-indices-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-indices-response/index-names :portkey.aws.iot.list-indices-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.set-v-2-logging-options-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.set-v-2-logging-options-request/default-log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot.set-v-2-logging-options-request/disable-all-logs (clojure.spec.alpha/and :portkey.aws.iot/disable-all-logs))
(clojure.spec.alpha/def :portkey.aws.iot/set-v-2-logging-options-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.set-v-2-logging-options-request/role-arn :portkey.aws.iot.set-v-2-logging-options-request/default-log-level :portkey.aws.iot.set-v-2-logging-options-request/disable-all-logs]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-types-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-types-request/next-token :portkey.aws.iot.list-thing-types-request/max-results :portkey.aws.iot.list-thing-types-request/thing-type-name]))

(clojure.spec.alpha/def :portkey.aws.iot/max-job-executions-per-min (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot/ca-certificate-status #{:inactive :active "INACTIVE" "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.iot/role-arn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 20 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.iot.invalid-query-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/invalid-query-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.invalid-query-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/target-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-response/violation-events (clojure.spec.alpha/and :portkey.aws.iot/violation-events))
(clojure.spec.alpha/def :portkey.aws.iot.list-violation-events-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-violation-events-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-violation-events-response/violation-events :portkey.aws.iot.list-violation-events-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/template-body (clojure.spec.alpha/and :portkey.aws.iot/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/input-file-bucket (clojure.spec.alpha/and :portkey.aws.iot/registry-s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/last-modified-date))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/status (clojure.spec.alpha/and :portkey.aws.iot/status))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/success-count (clojure.spec.alpha/and :portkey.aws.iot/count))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/failure-count (clojure.spec.alpha/and :portkey.aws.iot/count))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/percentage-progress (clojure.spec.alpha/and :portkey.aws.iot/percentage))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/input-file-key (clojure.spec.alpha/and :portkey.aws.iot/registry-s-3-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-response/task-id (clojure.spec.alpha/and :portkey.aws.iot/task-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-registration-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-thing-registration-task-response/message :portkey.aws.iot.describe-thing-registration-task-response/creation-date :portkey.aws.iot.describe-thing-registration-task-response/template-body :portkey.aws.iot.describe-thing-registration-task-response/input-file-bucket :portkey.aws.iot.describe-thing-registration-task-response/role-arn :portkey.aws.iot.describe-thing-registration-task-response/last-modified-date :portkey.aws.iot.describe-thing-registration-task-response/status :portkey.aws.iot.describe-thing-registration-task-response/success-count :portkey.aws.iot.describe-thing-registration-task-response/failure-count :portkey.aws.iot.describe-thing-registration-task-response/percentage-progress :portkey.aws.iot.describe-thing-registration-task-response/input-file-key :portkey.aws.iot.describe-thing-registration-task-response/task-id]))

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-target-mappings (clojure.spec.alpha/coll-of :portkey.aws.iot/security-profile-target-mapping))

(clojure.spec.alpha/def :portkey.aws.iot/abort-criteria-list (clojure.spec.alpha/coll-of :portkey.aws.iot/abort-criteria :min-count 1))

(clojure.spec.alpha/def :portkey.aws.iot/disable-all-logs clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/registry-s-3-key-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1024)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9!_.*'()-\/]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/partition-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-stream-response/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-stream-response/stream-arn (clojure.spec.alpha/and :portkey.aws.iot/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-stream-response/description (clojure.spec.alpha/and :portkey.aws.iot/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.create-stream-response/stream-version (clojure.spec.alpha/and :portkey.aws.iot/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot/create-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-stream-response/stream-id :portkey.aws.iot.create-stream-response/stream-arn :portkey.aws.iot.create-stream-response/description :portkey.aws.iot.create-stream-response/stream-version]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-thing-request/thing-name] :opt-un [:portkey.aws.iot.delete-thing-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.create-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.create-role-alias-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-role-alias-request/credential-duration-seconds (clojure.spec.alpha/and :portkey.aws.iot/credential-duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot/create-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-role-alias-request/role-alias :portkey.aws.iot.create-role-alias-request/role-arn] :opt-un [:portkey.aws.iot.create-role-alias-request/credential-duration-seconds]))

(clojure.spec.alpha/def :portkey.aws.iot/update-event-configurations-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-principal-policies-response/policies :portkey.aws.iot.list-principal-policies-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.update-indexing-configuration-request/thing-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot/thing-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot.update-indexing-configuration-request/thing-group-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot/thing-group-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot/update-indexing-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-indexing-configuration-request/thing-indexing-configuration :portkey.aws.iot.update-indexing-configuration-request/thing-group-indexing-configuration]))

(clojure.spec.alpha/def :portkey.aws.iot.audit-check-details/check-run-status (clojure.spec.alpha/and :portkey.aws.iot/audit-check-run-status))
(clojure.spec.alpha/def :portkey.aws.iot.audit-check-details/check-compliant (clojure.spec.alpha/and :portkey.aws.iot/check-compliant))
(clojure.spec.alpha/def :portkey.aws.iot.audit-check-details/total-resources-count (clojure.spec.alpha/and :portkey.aws.iot/total-resources-count))
(clojure.spec.alpha/def :portkey.aws.iot.audit-check-details/non-compliant-resources-count (clojure.spec.alpha/and :portkey.aws.iot/non-compliant-resources-count))
(clojure.spec.alpha/def :portkey.aws.iot.audit-check-details/error-code (clojure.spec.alpha/and :portkey.aws.iot/error-code))
(clojure.spec.alpha/def :portkey.aws.iot.audit-check-details/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/audit-check-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.audit-check-details/check-run-status :portkey.aws.iot.audit-check-details/check-compliant :portkey.aws.iot.audit-check-details/total-resources-count :portkey.aws.iot.audit-check-details/non-compliant-resources-count :portkey.aws.iot.audit-check-details/error-code :portkey.aws.iot.audit-check-details/message]))

(clojure.spec.alpha/def :portkey.aws.iot/audit-details (clojure.spec.alpha/map-of :portkey.aws.iot/audit-check-name :portkey.aws.iot/audit-check-details))

(clojure.spec.alpha/def :portkey.aws.iot/flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/customer-version (clojure.spec.alpha/and :portkey.aws.iot/customer-version))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/validity (clojure.spec.alpha/and :portkey.aws.iot/certificate-validity))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/owned-by (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/transfer-data (clojure.spec.alpha/and :portkey.aws.iot/transfer-data))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/generation-id (clojure.spec.alpha/and :portkey.aws.iot/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/previous-owned-by (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.certificate-description/customer-version :portkey.aws.iot.certificate-description/creation-date :portkey.aws.iot.certificate-description/certificate-pem :portkey.aws.iot.certificate-description/ca-certificate-id :portkey.aws.iot.certificate-description/validity :portkey.aws.iot.certificate-description/last-modified-date :portkey.aws.iot.certificate-description/owned-by :portkey.aws.iot.certificate-description/transfer-data :portkey.aws.iot.certificate-description/generation-id :portkey.aws.iot.certificate-description/status :portkey.aws.iot.certificate-description/previous-owned-by :portkey.aws.iot.certificate-description/certificate-arn :portkey.aws.iot.certificate-description/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot.update-stream-response/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.update-stream-response/stream-arn (clojure.spec.alpha/and :portkey.aws.iot/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.update-stream-response/description (clojure.spec.alpha/and :portkey.aws.iot/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.update-stream-response/stream-version (clojure.spec.alpha/and :portkey.aws.iot/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot/update-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-stream-response/stream-id :portkey.aws.iot.update-stream-response/stream-arn :portkey.aws.iot.update-stream-response/description :portkey.aws.iot.update-stream-response/stream-version]))

(clojure.spec.alpha/def :portkey.aws.iot/principal-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.delete-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/delete-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.delete-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/marker (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[A-Za-z0-9+/]+={0,2}" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.update-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.update-stream-request/description (clojure.spec.alpha/and :portkey.aws.iot/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot.update-stream-request/files (clojure.spec.alpha/and :portkey.aws.iot/stream-files))
(clojure.spec.alpha/def :portkey.aws.iot.update-stream-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot/update-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-stream-request/stream-id] :opt-un [:portkey.aws.iot.update-stream-request/description :portkey.aws.iot.update-stream-request/files :portkey.aws.iot.update-stream-request/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/index-schema (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-tasks-response/task-ids (clojure.spec.alpha/and :portkey.aws.iot/task-id-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-tasks-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-registration-tasks-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-registration-tasks-response/task-ids :portkey.aws.iot.list-thing-registration-tasks-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/tag-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-files (clojure.spec.alpha/coll-of :portkey.aws.iot/ota-update-file :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.iot/thing-document-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-document))

(clojure.spec.alpha/def :portkey.aws.iot.start-signing-job-parameter/signing-profile-parameter (clojure.spec.alpha/and :portkey.aws.iot/signing-profile-parameter))
(clojure.spec.alpha/def :portkey.aws.iot.start-signing-job-parameter/signing-profile-name (clojure.spec.alpha/and :portkey.aws.iot/signing-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.start-signing-job-parameter/destination (clojure.spec.alpha/and :portkey.aws.iot/destination))
(clojure.spec.alpha/def :portkey.aws.iot/start-signing-job-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.start-signing-job-parameter/signing-profile-parameter :portkey.aws.iot.start-signing-job-parameter/signing-profile-name :portkey.aws.iot.start-signing-job-parameter/destination]))

(clojure.spec.alpha/def :portkey.aws.iot.destination/s-3-destination (clojure.spec.alpha/and :portkey.aws.iot/s-3-destination))
(clojure.spec.alpha/def :portkey.aws.iot/destination (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.destination/s-3-destination]))

(clojure.spec.alpha/def :portkey.aws.iot/task-id-list (clojure.spec.alpha/coll-of :portkey.aws.iot/task-id))

(clojure.spec.alpha/def :portkey.aws.iot.detach-thing-principal-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.detach-thing-principal-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/detach-thing-principal-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.detach-thing-principal-request/thing-name :portkey.aws.iot.detach-thing-principal-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/rule-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-response/transferred-certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.transfer-certificate-response/transferred-certificate-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.list-indices-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-indices-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/query-max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-indices-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-indices-request/next-token :portkey.aws.iot.list-indices-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-for-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-for-thing-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-for-thing-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-groups-for-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-thing-groups-for-thing-request/thing-name] :opt-un [:portkey.aws.iot.list-thing-groups-for-thing-request/next-token :portkey.aws.iot.list-thing-groups-for-thing-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/non-compliant-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/comparison-operator #{"less-than-equals" :notinportset :notincidrset "greater-than" "not-in-port-set" :lessthan "greater-than-equals" :lessthanequals :incidrset "in-cidr-set" "not-in-cidr-set" :greaterthanequals "in-port-set" :inportset :greaterthan "less-than"})

(clojure.spec.alpha/def :portkey.aws.iot/task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 40))))

(clojure.spec.alpha/def :portkey.aws.iot.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-metadata (clojure.spec.alpha/and :portkey.aws.iot/thing-type-metadata))
(clojure.spec.alpha/def :portkey.aws.iot/thing-type-definition (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-type-definition/thing-type-name :portkey.aws.iot.thing-type-definition/thing-type-arn :portkey.aws.iot.thing-type-definition/thing-type-properties :portkey.aws.iot.thing-type-definition/thing-type-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot.attach-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.attach-security-profile-request/security-profile-target-arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot/attach-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.attach-security-profile-request/security-profile-name :portkey.aws.iot.attach-security-profile-request/security-profile-target-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/deprecate-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/policy-names (clojure.spec.alpha/coll-of :portkey.aws.iot/policy-name))

(clojure.spec.alpha/def :portkey.aws.iot/billing-group-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-response/rules (clojure.spec.alpha/and :portkey.aws.iot/topic-rule-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-topic-rules-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-topic-rules-response/rules :portkey.aws.iot.list-topic-rules-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-name))

(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-request/reason-code (clojure.spec.alpha/and :portkey.aws.iot/reason-code))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-request/comment (clojure.spec.alpha/and :portkey.aws.iot/comment))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-request/force (clojure.spec.alpha/and :portkey.aws.iot/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot/cancel-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.cancel-job-request/job-id] :opt-un [:portkey.aws.iot.cancel-job-request/reason-code :portkey.aws.iot.cancel-job-request/comment :portkey.aws.iot.cancel-job-request/force]))

(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-request/certificate-signing-request (clojure.spec.alpha/and :portkey.aws.iot/certificate-signing-request))
(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot/create-certificate-from-csr-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-certificate-from-csr-request/certificate-signing-request] :opt-un [:portkey.aws.iot.create-certificate-from-csr-request/set-as-active]))

(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-request/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-request/behaviors (clojure.spec.alpha/and :portkey.aws.iot/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-request/alert-targets (clojure.spec.alpha/and :portkey.aws.iot/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-request/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot/create-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.create-security-profile-request/security-profile-description :portkey.aws.iot.create-security-profile-request/behaviors :portkey.aws.iot.create-security-profile-request/alert-targets :portkey.aws.iot.create-security-profile-request/additional-metrics-to-retain :portkey.aws.iot.create-security-profile-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-targets (clojure.spec.alpha/coll-of :portkey.aws.iot/policy-target))

(clojure.spec.alpha/def :portkey.aws.iot/forced clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/resource-arns (clojure.spec.alpha/map-of :portkey.aws.iot/resource-logical-id :portkey.aws.iot/resource-arn))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-id (clojure.spec.alpha/and :portkey.aws.iot/thing-type-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-metadata (clojure.spec.alpha/and :portkey.aws.iot/thing-type-metadata))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-thing-type-response/thing-type-name :portkey.aws.iot.describe-thing-type-response/thing-type-id :portkey.aws.iot.describe-thing-type-response/thing-type-arn :portkey.aws.iot.describe-thing-type-response/thing-type-properties :portkey.aws.iot.describe-thing-type-response/thing-type-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot.exponential-rollout-rate/base-rate-per-minute (clojure.spec.alpha/and :portkey.aws.iot/rollout-rate-per-minute))
(clojure.spec.alpha/def :portkey.aws.iot.exponential-rollout-rate/increment-factor (clojure.spec.alpha/and :portkey.aws.iot/increment-factor))
(clojure.spec.alpha/def :portkey.aws.iot.exponential-rollout-rate/rate-increase-criteria (clojure.spec.alpha/and :portkey.aws.iot/rate-increase-criteria))
(clojure.spec.alpha/def :portkey.aws.iot/exponential-rollout-rate (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.exponential-rollout-rate/base-rate-per-minute :portkey.aws.iot.exponential-rollout-rate/increment-factor :portkey.aws.iot.exponential-rollout-rate/rate-increase-criteria] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary/status (clojure.spec.alpha/and :portkey.aws.iot/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary/queued-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary/started-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary/execution-number (clojure.spec.alpha/and :portkey.aws.iot/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot/job-execution-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-execution-summary/status :portkey.aws.iot.job-execution-summary/queued-at :portkey.aws.iot.job-execution-summary/started-at :portkey.aws.iot.job-execution-summary/last-updated-at :portkey.aws.iot.job-execution-summary/execution-number]))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.delete-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/waiting-for-data-collection-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-group-name))

(clojure.spec.alpha/def :portkey.aws.iot.rate-increase-criteria/number-of-notified-things (clojure.spec.alpha/and :portkey.aws.iot/number-of-things))
(clojure.spec.alpha/def :portkey.aws.iot.rate-increase-criteria/number-of-succeeded-things (clojure.spec.alpha/and :portkey.aws.iot/number-of-things))
(clojure.spec.alpha/def :portkey.aws.iot/rate-increase-criteria (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.rate-increase-criteria/number-of-notified-things :portkey.aws.iot.rate-increase-criteria/number-of-succeeded-things]))

(clojure.spec.alpha/def :portkey.aws.iot/set-as-active-flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.resource-already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/resource-already-exists-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.resource-already-exists-exception/message :portkey.aws.iot/resource-id :portkey.aws.iot/resource-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/rejected-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/force-delete-aws-job clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-by-ca-response/certificates (clojure.spec.alpha/and :portkey.aws.iot/certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-by-ca-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-by-ca-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-certificates-by-ca-response/certificates :portkey.aws.iot.list-certificates-by-ca-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot/alert-targets (clojure.spec.alpha/map-of :portkey.aws.iot/alert-target-type :portkey.aws.iot/alert-target))

(clojure.spec.alpha/def :portkey.aws.iot.list-active-violations-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-active-violations-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-active-violations-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-active-violations-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-active-violations-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-active-violations-request/thing-name :portkey.aws.iot.list-active-violations-request/security-profile-name :portkey.aws.iot.list-active-violations-request/next-token :portkey.aws.iot.list-active-violations-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-execution-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-execution-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-execution-request/force (clojure.spec.alpha/and :portkey.aws.iot/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-execution-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/expected-version))
(clojure.spec.alpha/def :portkey.aws.iot.cancel-job-execution-request/status-details (clojure.spec.alpha/and :portkey.aws.iot/details-map))
(clojure.spec.alpha/def :portkey.aws.iot/cancel-job-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.cancel-job-execution-request/job-id :portkey.aws.iot.cancel-job-execution-request/thing-name] :opt-un [:portkey.aws.iot.cancel-job-execution-request/force :portkey.aws.iot.cancel-job-execution-request/expected-version :portkey.aws.iot.cancel-job-execution-request/status-details]))

(clojure.spec.alpha/def :portkey.aws.iot.implicit-deny/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot/implicit-deny (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.implicit-deny/policies]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-principals-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-principals-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-thing-principals-request/thing-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-ca-certificates-response/certificates (clojure.spec.alpha/and :portkey.aws.iot/ca-certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-ca-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-ca-certificates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-ca-certificates-response/certificates :portkey.aws.iot.list-ca-certificates-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-authorizer-request/authorizer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/service-unavailable-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/key-pair (clojure.spec.alpha/and :portkey.aws.iot/key-pair))
(clojure.spec.alpha/def :portkey.aws.iot/create-keys-and-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-keys-and-certificate-response/certificate-arn :portkey.aws.iot.create-keys-and-certificate-response/certificate-id :portkey.aws.iot.create-keys-and-certificate-response/certificate-pem :portkey.aws.iot.create-keys-and-certificate-response/key-pair]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-dynamic-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-dynamic-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/delete-dynamic-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-dynamic-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.delete-dynamic-thing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot/aws-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/stream-files (clojure.spec.alpha/coll-of :portkey.aws.iot/stream-file :min-count 1 :max-count 50))

(clojure.spec.alpha/def :portkey.aws.iot/delete-registration-code-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-active-violations-response/active-violations (clojure.spec.alpha/and :portkey.aws.iot/active-violations))
(clojure.spec.alpha/def :portkey.aws.iot.list-active-violations-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-active-violations-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-active-violations-response/active-violations :portkey.aws.iot.list-active-violations-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/key-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/log-target-type #{:thing-group :default "THING_GROUP" "DEFAULT"})

(clojure.spec.alpha/def :portkey.aws.iot/enabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/query-string (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot/status #{"Failed" "Cancelled" :in-progress "Cancelling" :completed :cancelled "InProgress" "Completed" :cancelling :failed})

(clojure.spec.alpha/def :portkey.aws.iot/behaviors (clojure.spec.alpha/coll-of :portkey.aws.iot/behavior :max-count 100))

(clojure.spec.alpha/def :portkey.aws.iot/allow-auto-registration clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/audit-findings (clojure.spec.alpha/coll-of :portkey.aws.iot/audit-finding))

(clojure.spec.alpha/def :portkey.aws.iot/auth-results (clojure.spec.alpha/coll-of :portkey.aws.iot/auth-result))

(clojure.spec.alpha/def :portkey.aws.iot.policy-version/version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.policy-version/is-default-version (clojure.spec.alpha/and :portkey.aws.iot/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot.policy-version/create-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/policy-version (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.policy-version/version-id :portkey.aws.iot.policy-version/is-default-version :portkey.aws.iot.policy-version/create-date]))

(clojure.spec.alpha/def :portkey.aws.iot/event-type #{:ca-certificate :thing-group "THING_TYPE" "THING_GROUP_HIERARCHY" "JOB_EXECUTION" "CA_CERTIFICATE" :thing-group-membership :job-execution "THING_TYPE_ASSOCIATION" "JOB" :thing-group-hierarchy :policy :certificate :thing :thing-type "POLICY" "THING_GROUP" "THING_GROUP_MEMBERSHIP" "THING" :job "CERTIFICATE" :thing-type-association})

(clojure.spec.alpha/def :portkey.aws.iot/in-progress-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/update-thing-groups-for-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/role-alias (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w=,@-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.log-target-configuration/log-target (clojure.spec.alpha/and :portkey.aws.iot/log-target))
(clojure.spec.alpha/def :portkey.aws.iot.log-target-configuration/log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot/log-target-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.log-target-configuration/log-target :portkey.aws.iot.log-target-configuration/log-level]))

(clojure.spec.alpha/def :portkey.aws.iot.put-item-input/table-name (clojure.spec.alpha/and :portkey.aws.iot/table-name))
(clojure.spec.alpha/def :portkey.aws.iot/put-item-input (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.put-item-input/table-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.search-index-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.search-index-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-document-list))
(clojure.spec.alpha/def :portkey.aws.iot.search-index-response/thing-groups (clojure.spec.alpha/and :portkey.aws.iot/thing-group-document-list))
(clojure.spec.alpha/def :portkey.aws.iot/search-index-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.search-index-response/next-token :portkey.aws.iot.search-index-response/things :portkey.aws.iot.search-index-response/thing-groups]))

(clojure.spec.alpha/def :portkey.aws.iot/succeeded-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/log-target-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/next-token (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/behavior-metric (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.delete-ca-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/delete-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-ca-certificate-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.ota-update-file/file-name (clojure.spec.alpha/and :portkey.aws.iot/file-name))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-file/file-version (clojure.spec.alpha/and :portkey.aws.iot/ota-update-file-version))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-file/file-location (clojure.spec.alpha/and :portkey.aws.iot/file-location))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-file/code-signing (clojure.spec.alpha/and :portkey.aws.iot/code-signing))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-file/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes-map))
(clojure.spec.alpha/def :portkey.aws.iot/ota-update-file (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.ota-update-file/file-name :portkey.aws.iot.ota-update-file/file-version :portkey.aws.iot.ota-update-file/file-location :portkey.aws.iot.ota-update-file/code-signing :portkey.aws.iot.ota-update-file/attributes]))

(clojure.spec.alpha/def :portkey.aws.iot/tag-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/range-key-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/hash-key-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.firehose-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.firehose-action/delivery-stream-name (clojure.spec.alpha/and :portkey.aws.iot/delivery-stream-name))
(clojure.spec.alpha/def :portkey.aws.iot.firehose-action/separator (clojure.spec.alpha/and :portkey.aws.iot/firehose-separator))
(clojure.spec.alpha/def :portkey.aws.iot/firehose-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.firehose-action/role-arn :portkey.aws.iot.firehose-action/delivery-stream-name] :opt-un [:portkey.aws.iot.firehose-action/separator]))

(clojure.spec.alpha/def :portkey.aws.iot/role-alias-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.scheduled-audit-metadata/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.scheduled-audit-metadata/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot.scheduled-audit-metadata/frequency (clojure.spec.alpha/and :portkey.aws.iot/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.scheduled-audit-metadata/day-of-month (clojure.spec.alpha/and :portkey.aws.iot/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.scheduled-audit-metadata/day-of-week (clojure.spec.alpha/and :portkey.aws.iot/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot/scheduled-audit-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.scheduled-audit-metadata/scheduled-audit-name :portkey.aws.iot.scheduled-audit-metadata/scheduled-audit-arn :portkey.aws.iot.scheduled-audit-metadata/frequency :portkey.aws.iot.scheduled-audit-metadata/day-of-month :portkey.aws.iot.scheduled-audit-metadata/day-of-week]))

(clojure.spec.alpha/def :portkey.aws.iot/consecutive-datapoints-to-alarm (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.iot.describe-default-authorizer-response/authorizer-description (clojure.spec.alpha/and :portkey.aws.iot/authorizer-description))
(clojure.spec.alpha/def :portkey.aws.iot/describe-default-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-default-authorizer-response/authorizer-description]))

(clojure.spec.alpha/def :portkey.aws.iot/error-message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2048))))

(clojure.spec.alpha/def :portkey.aws.iot/total-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/timed-out-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.thing-group-properties/thing-group-description (clojure.spec.alpha/and :portkey.aws.iot/thing-group-description))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-properties/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot/thing-group-properties (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-group-properties/thing-group-description :portkey.aws.iot.thing-group-properties/attribute-payload]))

(clojure.spec.alpha/def :portkey.aws.iot/cidrs (clojure.spec.alpha/coll-of :portkey.aws.iot/cidr))

(clojure.spec.alpha/def :portkey.aws.iot.audit-task-metadata/task-id (clojure.spec.alpha/and :portkey.aws.iot/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.audit-task-metadata/task-status (clojure.spec.alpha/and :portkey.aws.iot/audit-task-status))
(clojure.spec.alpha/def :portkey.aws.iot.audit-task-metadata/task-type (clojure.spec.alpha/and :portkey.aws.iot/audit-task-type))
(clojure.spec.alpha/def :portkey.aws.iot/audit-task-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.audit-task-metadata/task-id :portkey.aws.iot.audit-task-metadata/task-status :portkey.aws.iot.audit-task-metadata/task-type]))

(clojure.spec.alpha/def :portkey.aws.iot.list-role-aliases-response/role-aliases (clojure.spec.alpha/and :portkey.aws.iot/role-aliases))
(clojure.spec.alpha/def :portkey.aws.iot.list-role-aliases-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-role-aliases-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-role-aliases-response/role-aliases :portkey.aws.iot.list-role-aliases-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot/topic (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.describe-index-request/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-index-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-index-request/index-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/alert-target-type #{:sns "SNS"})

(clojure.spec.alpha/def :portkey.aws.iot/job-document (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 32768))))

(clojure.spec.alpha/def :portkey.aws.iot/audit-check-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/get-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.get-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-request/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-policy-request/policy-name :portkey.aws.iot.create-policy-request/policy-document] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.attach-principal-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.attach-principal-policy-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/attach-principal-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.attach-principal-policy-request/policy-name :portkey.aws.iot.attach-principal-policy-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/recursive-without-default clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/stream-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/salesforce-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 40 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.list-attached-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot.list-attached-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-attached-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-attached-policies-response/policies :portkey.aws.iot.list-attached-policies-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-request/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-request/query-string (clojure.spec.alpha/and :portkey.aws.iot/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-request/query-version (clojure.spec.alpha/and :portkey.aws.iot/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot/create-dynamic-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-dynamic-thing-group-request/thing-group-name :portkey.aws.iot.create-dynamic-thing-group-request/query-string] :opt-un [:portkey.aws.iot.create-dynamic-thing-group-request/thing-group-properties :portkey.aws.iot.create-dynamic-thing-group-request/index-name :portkey.aws.iot.create-dynamic-thing-group-request/query-version :portkey.aws.iot.create-dynamic-thing-group-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.update-scheduled-audit-response/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot/update-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-scheduled-audit-response/scheduled-audit-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.list-scheduled-audits-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-scheduled-audits-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-scheduled-audits-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-scheduled-audits-request/next-token :portkey.aws.iot.list-scheduled-audits-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-response/resource-links (clojure.spec.alpha/and :portkey.aws.iot/s-3-file-url-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-response/report-type (clojure.spec.alpha/and :portkey.aws.iot/report-type))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-registration-task-reports-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-registration-task-reports-response/resource-links :portkey.aws.iot.list-thing-registration-task-reports-response/report-type :portkey.aws.iot.list-thing-registration-task-reports-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-group-metadata/parent-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-metadata/root-to-parent-thing-groups (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot/thing-group-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-group-metadata/parent-group-name :portkey.aws.iot.thing-group-metadata/root-to-parent-thing-groups :portkey.aws.iot.thing-group-metadata/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-indexing-mode #{"ON" :off :on "OFF"})

(clojure.spec.alpha/def :portkey.aws.iot/target-selection #{"SNAPSHOT" :continuous "CONTINUOUS" :snapshot})

(clojure.spec.alpha/def :portkey.aws.iot/detach-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-ota-update-request/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.delete-ota-update-request/delete-stream (clojure.spec.alpha/and :portkey.aws.iot/delete-stream))
(clojure.spec.alpha/def :portkey.aws.iot.delete-ota-update-request/force-delete-aws-job (clojure.spec.alpha/and :portkey.aws.iot/force-delete-aws-job))
(clojure.spec.alpha/def :portkey.aws.iot/delete-ota-update-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-ota-update-request/ota-update-id] :opt-un [:portkey.aws.iot.delete-ota-update-request/delete-stream :portkey.aws.iot.delete-ota-update-request/force-delete-aws-job]))

(clojure.spec.alpha/def :portkey.aws.iot/remove-auto-registration clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/attributes (clojure.spec.alpha/map-of :portkey.aws.iot/attribute-name :portkey.aws.iot/attribute-value))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-tasks-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-tasks-request/status (clojure.spec.alpha/and :portkey.aws.iot/status))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-registration-tasks-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-registration-tasks-request/next-token :portkey.aws.iot.list-thing-registration-tasks-request/max-results :portkey.aws.iot.list-thing-registration-tasks-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot/create-certificate-from-csr-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-certificate-from-csr-response/certificate-arn :portkey.aws.iot.create-certificate-from-csr-response/certificate-id :portkey.aws.iot.create-certificate-from-csr-response/certificate-pem]))

(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-response/security-profile-identifiers (clojure.spec.alpha/and :portkey.aws.iot/security-profile-identifiers))
(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-security-profiles-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-security-profiles-response/security-profile-identifiers :portkey.aws.iot.list-security-profiles-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot/delete-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-stream-request/stream-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-for-target-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-for-target-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-for-target-request/recursive (clojure.spec.alpha/and :portkey.aws.iot/recursive))
(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-for-target-request/security-profile-target-arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot/list-security-profiles-for-target-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-security-profiles-for-target-request/security-profile-target-arn] :opt-un [:portkey.aws.iot.list-security-profiles-for-target-request/next-token :portkey.aws.iot.list-security-profiles-for-target-request/max-results :portkey.aws.iot.list-security-profiles-for-target-request/recursive]))

(clojure.spec.alpha/def :portkey.aws.iot/queue-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/force-flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.tag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.iot/resource-arn))
(clojure.spec.alpha/def :portkey.aws.iot.tag-resource-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.tag-resource-request/resource-arn :portkey.aws.iot.tag-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/unsigned-long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.internal-failure-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/internal-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.internal-failure-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.register-thing-request/template-body (clojure.spec.alpha/and :portkey.aws.iot/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.register-thing-request/parameters (clojure.spec.alpha/and :portkey.aws.iot/parameters))
(clojure.spec.alpha/def :portkey.aws.iot/register-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.register-thing-request/template-body] :opt-un [:portkey.aws.iot.register-thing-request/parameters]))

(clojure.spec.alpha/def :portkey.aws.iot/role-aliases (clojure.spec.alpha/coll-of :portkey.aws.iot/role-alias))

(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-policy-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-policy-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot/list-targets-for-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-targets-for-policy-request/policy-name] :opt-un [:portkey.aws.iot.list-targets-for-policy-request/marker :portkey.aws.iot.list-targets-for-policy-request/page-size]))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/is-default-version (clojure.spec.alpha/and :portkey.aws.iot/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/generation-id (clojure.spec.alpha/and :portkey.aws.iot/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-version-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-policy-version-response/policy-arn :portkey.aws.iot.get-policy-version-response/policy-name :portkey.aws.iot.get-policy-version-response/policy-document :portkey.aws.iot.get-policy-version-response/policy-version-id :portkey.aws.iot.get-policy-version-response/is-default-version :portkey.aws.iot.get-policy-version-response/creation-date :portkey.aws.iot.get-policy-version-response/last-modified-date :portkey.aws.iot.get-policy-version-response/generation-id]))

(clojure.spec.alpha/def :portkey.aws.iot.list-streams-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-streams-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-streams-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-streams-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-streams-request/max-results :portkey.aws.iot.list-streams-request/next-token :portkey.aws.iot.list-streams-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.stop-thing-registration-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot/task-id))
(clojure.spec.alpha/def :portkey.aws.iot/stop-thing-registration-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.stop-thing-registration-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.authorizer-summary/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-summary/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot/authorizer-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.authorizer-summary/authorizer-name :portkey.aws.iot.authorizer-summary/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/tag-list (clojure.spec.alpha/coll-of :portkey.aws.iot/tag))

(clojure.spec.alpha/def :portkey.aws.iot/signature clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.iot.versions-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/versions-limit-exceeded-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.versions-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/task-id (clojure.spec.alpha/and :portkey.aws.iot/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/check-name (clojure.spec.alpha/and :portkey.aws.iot/audit-check-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/resource-identifier (clojure.spec.alpha/and :portkey.aws.iot/resource-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/start-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-request/end-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot/list-audit-findings-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-audit-findings-request/task-id :portkey.aws.iot.list-audit-findings-request/check-name :portkey.aws.iot.list-audit-findings-request/resource-identifier :portkey.aws.iot.list-audit-findings-request/max-results :portkey.aws.iot.list-audit-findings-request/next-token :portkey.aws.iot.list-audit-findings-request/start-time :portkey.aws.iot.list-audit-findings-request/end-time]))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/delete-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-role-aliases-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-role-aliases-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-role-aliases-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-role-aliases-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-role-aliases-request/page-size :portkey.aws.iot.list-role-aliases-request/marker :portkey.aws.iot.list-role-aliases-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-job-execution-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-job-execution-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-job-execution-request/execution-number (clojure.spec.alpha/and :portkey.aws.iot/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot/describe-job-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-job-execution-request/job-id :portkey.aws.iot.describe-job-execution-request/thing-name] :opt-un [:portkey.aws.iot.describe-job-execution-request/execution-number]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-thing-group-request/thing-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/check-compliant clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/searchable-attributes (clojure.spec.alpha/coll-of :portkey.aws.iot/attribute-name))

(clojure.spec.alpha/def :portkey.aws.iot/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.iot/tag-key))

(clojure.spec.alpha/def :portkey.aws.iot/job-summary-list (clojure.spec.alpha/coll-of :portkey.aws.iot/job-summary))

(clojure.spec.alpha/def :portkey.aws.iot/audit-check-run-status #{"CANCELED" "IN_PROGRESS" :in-progress "COMPLETED_NON_COMPLIANT" :waiting-for-data-collection :completed-non-compliant "COMPLETED_COMPLIANT" :canceled "WAITING_FOR_DATA_COLLECTION" "FAILED" :failed :completed-compliant})

(clojure.spec.alpha/def :portkey.aws.iot/message-format #{:raw "JSON" "RAW" :json})

(clojure.spec.alpha/def :portkey.aws.iot/date-type clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.thing-indexing-configuration/thing-indexing-mode (clojure.spec.alpha/and :portkey.aws.iot/thing-indexing-mode))
(clojure.spec.alpha/def :portkey.aws.iot.thing-indexing-configuration/thing-connectivity-indexing-mode (clojure.spec.alpha/and :portkey.aws.iot/thing-connectivity-indexing-mode))
(clojure.spec.alpha/def :portkey.aws.iot/thing-indexing-configuration (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.thing-indexing-configuration/thing-indexing-mode] :opt-un [:portkey.aws.iot.thing-indexing-configuration/thing-connectivity-indexing-mode]))

(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/role-alias-arn (clojure.spec.alpha/and :portkey.aws.iot/role-alias-arn))
(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/owner (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/credential-duration-seconds (clojure.spec.alpha/and :portkey.aws.iot/credential-duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.role-alias-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/role-alias-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.role-alias-description/role-alias :portkey.aws.iot.role-alias-description/role-alias-arn :portkey.aws.iot.role-alias-description/role-arn :portkey.aws.iot.role-alias-description/owner :portkey.aws.iot.role-alias-description/credential-duration-seconds :portkey.aws.iot.role-alias-description/creation-date :portkey.aws.iot.role-alias-description/last-modified-date]))

(clojure.spec.alpha/def :portkey.aws.iot/audit-frequency #{:daily :biweekly :monthly "MONTHLY" "WEEKLY" "DAILY" "BIWEEKLY" :weekly})

(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/description (clojure.spec.alpha/and :portkey.aws.iot/ota-update-description))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/targets (clojure.spec.alpha/and :portkey.aws.iot/targets))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/target-selection (clojure.spec.alpha/and :portkey.aws.iot/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/aws-job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot/aws-job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/files (clojure.spec.alpha/and :portkey.aws.iot/ota-update-files))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-ota-update-request/additional-parameters (clojure.spec.alpha/and :portkey.aws.iot/additional-parameter-map))
(clojure.spec.alpha/def :portkey.aws.iot/create-ota-update-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-ota-update-request/ota-update-id :portkey.aws.iot.create-ota-update-request/targets :portkey.aws.iot.create-ota-update-request/files :portkey.aws.iot.create-ota-update-request/role-arn] :opt-un [:portkey.aws.iot.create-ota-update-request/description :portkey.aws.iot.create-ota-update-request/target-selection :portkey.aws.iot.create-ota-update-request/aws-job-executions-rollout-config :portkey.aws.iot.create-ota-update-request/additional-parameters]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-v-2-logging-level-request/target-type (clojure.spec.alpha/and :portkey.aws.iot/log-target-type))
(clojure.spec.alpha/def :portkey.aws.iot.delete-v-2-logging-level-request/target-name (clojure.spec.alpha/and :portkey.aws.iot/log-target-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-v-2-logging-level-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-v-2-logging-level-request/target-type :portkey.aws.iot.delete-v-2-logging-level-request/target-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/attribute-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 800)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.,@/:#-]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-ca-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-ca-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-ca-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-ca-certificates-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-ca-certificates-request/page-size :portkey.aws.iot.list-ca-certificates-request/marker :portkey.aws.iot.list-ca-certificates-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/remove-thing-from-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-file-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/aws-iot-job-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/dynamo-key-type #{:number "NUMBER" :string "STRING"})

(clojure.spec.alpha/def :portkey.aws.iot/thing-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/public-key-map (clojure.spec.alpha/map-of :portkey.aws.iot/key-name :portkey.aws.iot/key-value))

(clojure.spec.alpha/def :portkey.aws.iot.delete-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.delete-certificate-request/force-delete (clojure.spec.alpha/and :portkey.aws.iot/force-delete))
(clojure.spec.alpha/def :portkey.aws.iot/delete-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-certificate-request/certificate-id] :opt-un [:portkey.aws.iot.delete-certificate-request/force-delete]))

(clojure.spec.alpha/def :portkey.aws.iot.cancel-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/cancel-certificate-transfer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.cancel-certificate-transfer-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.behavior-criteria/comparison-operator (clojure.spec.alpha/and :portkey.aws.iot/comparison-operator))
(clojure.spec.alpha/def :portkey.aws.iot.behavior-criteria/value (clojure.spec.alpha/and :portkey.aws.iot/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.behavior-criteria/duration-seconds (clojure.spec.alpha/and :portkey.aws.iot/duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot.behavior-criteria/consecutive-datapoints-to-alarm (clojure.spec.alpha/and :portkey.aws.iot/consecutive-datapoints-to-alarm))
(clojure.spec.alpha/def :portkey.aws.iot.behavior-criteria/consecutive-datapoints-to-clear (clojure.spec.alpha/and :portkey.aws.iot/consecutive-datapoints-to-clear))
(clojure.spec.alpha/def :portkey.aws.iot.behavior-criteria/statistical-threshold (clojure.spec.alpha/and :portkey.aws.iot/statistical-threshold))
(clojure.spec.alpha/def :portkey.aws.iot/behavior-criteria (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.behavior-criteria/comparison-operator :portkey.aws.iot.behavior-criteria/value :portkey.aws.iot.behavior-criteria/duration-seconds :portkey.aws.iot.behavior-criteria/consecutive-datapoints-to-alarm :portkey.aws.iot.behavior-criteria/consecutive-datapoints-to-clear :portkey.aws.iot.behavior-criteria/statistical-threshold]))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.get-policy-request/policy-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/reason-for-non-compliance (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/target-selection (clojure.spec.alpha/and :portkey.aws.iot/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/timeout-config (clojure.spec.alpha/and :portkey.aws.iot/timeout-config))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/document (clojure.spec.alpha/and :portkey.aws.iot/job-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/abort-config (clojure.spec.alpha/and :portkey.aws.iot/abort-config))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/document-source (clojure.spec.alpha/and :portkey.aws.iot/job-document-source))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/targets (clojure.spec.alpha/and :portkey.aws.iot/job-targets))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/presigned-url-config (clojure.spec.alpha/and :portkey.aws.iot/presigned-url-config))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot/job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.create-job-request/description (clojure.spec.alpha/and :portkey.aws.iot/job-description))
(clojure.spec.alpha/def :portkey.aws.iot/create-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-job-request/job-id :portkey.aws.iot.create-job-request/targets] :opt-un [:portkey.aws.iot.create-job-request/target-selection :portkey.aws.iot.create-job-request/timeout-config :portkey.aws.iot.create-job-request/tags :portkey.aws.iot.create-job-request/document :portkey.aws.iot.create-job-request/abort-config :portkey.aws.iot.create-job-request/document-source :portkey.aws.iot.create-job-request/presigned-url-config :portkey.aws.iot.create-job-request/job-executions-rollout-config :portkey.aws.iot.create-job-request/description]))

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-identifiers (clojure.spec.alpha/coll-of :portkey.aws.iot/security-profile-identifier))

(clojure.spec.alpha/def :portkey.aws.iot/error-code (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/stream-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-registration-code-response/registration-code (clojure.spec.alpha/and :portkey.aws.iot/registration-code))
(clojure.spec.alpha/def :portkey.aws.iot/get-registration-code-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-registration-code-response/registration-code]))

(clojure.spec.alpha/def :portkey.aws.iot/get-logging-options-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/resource-not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.resource-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-response/tasks (clojure.spec.alpha/and :portkey.aws.iot/audit-task-metadata-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-audit-tasks-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-audit-tasks-response/tasks :portkey.aws.iot.list-audit-tasks-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.signing-profile-parameter/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.signing-profile-parameter/platform (clojure.spec.alpha/and :portkey.aws.iot/platform))
(clojure.spec.alpha/def :portkey.aws.iot.signing-profile-parameter/certificate-path-on-device (clojure.spec.alpha/and :portkey.aws.iot/certificate-path-on-device))
(clojure.spec.alpha/def :portkey.aws.iot/signing-profile-parameter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.signing-profile-parameter/certificate-arn :portkey.aws.iot.signing-profile-parameter/platform :portkey.aws.iot.signing-profile-parameter/certificate-path-on-device]))

(clojure.spec.alpha/def :portkey.aws.iot.stream-file/file-id (clojure.spec.alpha/and :portkey.aws.iot/file-id))
(clojure.spec.alpha/def :portkey.aws.iot.stream-file/s-3-location (clojure.spec.alpha/and :portkey.aws.iot/s-3-location))
(clojure.spec.alpha/def :portkey.aws.iot/stream-file (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.stream-file/file-id :portkey.aws.iot.stream-file/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.iot.sns-action/target-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.sns-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.sns-action/message-format (clojure.spec.alpha/and :portkey.aws.iot/message-format))
(clojure.spec.alpha/def :portkey.aws.iot/sns-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.sns-action/target-arn :portkey.aws.iot.sns-action/role-arn] :opt-un [:portkey.aws.iot.sns-action/message-format]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/status (clojure.spec.alpha/and :portkey.aws.iot/dynamic-group-status))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/query-version (clojure.spec.alpha/and :portkey.aws.iot/query-version))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/query-string (clojure.spec.alpha/and :portkey.aws.iot/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-group-response/thing-group-metadata (clojure.spec.alpha/and :portkey.aws.iot/thing-group-metadata))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-thing-group-response/index-name :portkey.aws.iot.describe-thing-group-response/status :portkey.aws.iot.describe-thing-group-response/thing-group-id :portkey.aws.iot.describe-thing-group-response/query-version :portkey.aws.iot.describe-thing-group-response/thing-group-name :portkey.aws.iot.describe-thing-group-response/thing-group-properties :portkey.aws.iot.describe-thing-group-response/version :portkey.aws.iot.describe-thing-group-response/thing-group-arn :portkey.aws.iot.describe-thing-group-response/query-string :portkey.aws.iot.describe-thing-group-response/thing-group-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot/channel-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.not-configured-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/not-configured-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.not-configured-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.presigned-url-config/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.presigned-url-config/expires-in-sec (clojure.spec.alpha/and :portkey.aws.iot/expires-in-sec))
(clojure.spec.alpha/def :portkey.aws.iot/presigned-url-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.presigned-url-config/role-arn :portkey.aws.iot.presigned-url-config/expires-in-sec]))

(clojure.spec.alpha/def :portkey.aws.iot.related-resource/resource-type (clojure.spec.alpha/and :portkey.aws.iot/resource-type))
(clojure.spec.alpha/def :portkey.aws.iot.related-resource/resource-identifier (clojure.spec.alpha/and :portkey.aws.iot/resource-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.related-resource/additional-info (clojure.spec.alpha/and :portkey.aws.iot/string-map))
(clojure.spec.alpha/def :portkey.aws.iot/related-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.related-resource/resource-type :portkey.aws.iot.related-resource/resource-identifier :portkey.aws.iot.related-resource/additional-info]))

(clojure.spec.alpha/def :portkey.aws.iot/undo-deprecate clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/describe-event-configurations-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/delete-ca-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/queued-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.describe-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot/describe-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-role-alias-request/role-alias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.invalid-response-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/invalid-response-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.invalid-response-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-thing-type-request/thing-type-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/credential-duration-seconds (clojure.spec.alpha/int-in 900 3600))

(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/task-start-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/check-name (clojure.spec.alpha/and :portkey.aws.iot/audit-check-name))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/related-resources (clojure.spec.alpha/and :portkey.aws.iot/related-resources))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/finding-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/reason-for-non-compliance-code (clojure.spec.alpha/and :portkey.aws.iot/reason-for-non-compliance-code))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/task-id (clojure.spec.alpha/and :portkey.aws.iot/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/severity (clojure.spec.alpha/and :portkey.aws.iot/audit-finding-severity))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/non-compliant-resource (clojure.spec.alpha/and :portkey.aws.iot/non-compliant-resource))
(clojure.spec.alpha/def :portkey.aws.iot.audit-finding/reason-for-non-compliance (clojure.spec.alpha/and :portkey.aws.iot/reason-for-non-compliance))
(clojure.spec.alpha/def :portkey.aws.iot/audit-finding (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.audit-finding/task-start-time :portkey.aws.iot.audit-finding/check-name :portkey.aws.iot.audit-finding/related-resources :portkey.aws.iot.audit-finding/finding-time :portkey.aws.iot.audit-finding/reason-for-non-compliance-code :portkey.aws.iot.audit-finding/task-id :portkey.aws.iot.audit-finding/severity :portkey.aws.iot.audit-finding/non-compliant-resource :portkey.aws.iot.audit-finding/reason-for-non-compliance]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-alert-targets clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.index-not-ready-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/index-not-ready-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.index-not-ready-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/job-execution-summary-for-job-list (clojure.spec.alpha/coll-of :portkey.aws.iot/job-execution-summary-for-job))

(clojure.spec.alpha/def :portkey.aws.iot.aws-job-executions-rollout-config/maximum-per-minute (clojure.spec.alpha/and :portkey.aws.iot/maximum-per-minute))
(clojure.spec.alpha/def :portkey.aws.iot/aws-job-executions-rollout-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.aws-job-executions-rollout-config/maximum-per-minute]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-policy-request/policy-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/description (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/tag-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/delete-dynamic-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.associate-targets-with-job-response/job-arn (clojure.spec.alpha/and :portkey.aws.iot/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.associate-targets-with-job-response/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.associate-targets-with-job-response/description (clojure.spec.alpha/and :portkey.aws.iot/job-description))
(clojure.spec.alpha/def :portkey.aws.iot/associate-targets-with-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.associate-targets-with-job-response/job-arn :portkey.aws.iot.associate-targets-with-job-response/job-id :portkey.aws.iot.associate-targets-with-job-response/description]))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.describe-job-execution-response/execution (clojure.spec.alpha/and :portkey.aws.iot/job-execution))
(clojure.spec.alpha/def :portkey.aws.iot/describe-job-execution-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-job-execution-response/execution]))

(clojure.spec.alpha/def :portkey.aws.iot/token-key-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/remove-thing-from-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/delete-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-policy-version-request/policy-name :portkey.aws.iot.delete-policy-version-request/policy-version-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/policy-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/port (clojure.spec.alpha/int-in 0 65535))

(clojure.spec.alpha/def :portkey.aws.iot.list-attached-policies-request/target (clojure.spec.alpha/and :portkey.aws.iot/policy-target))
(clojure.spec.alpha/def :portkey.aws.iot.list-attached-policies-request/recursive (clojure.spec.alpha/and :portkey.aws.iot/recursive))
(clojure.spec.alpha/def :portkey.aws.iot.list-attached-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-attached-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot/list-attached-policies-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-attached-policies-request/target] :opt-un [:portkey.aws.iot.list-attached-policies-request/recursive :portkey.aws.iot.list-attached-policies-request/marker :portkey.aws.iot.list-attached-policies-request/page-size]))

(clojure.spec.alpha/def :portkey.aws.iot.billing-group-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot/billing-group-metadata (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.billing-group-metadata/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot/authorizer-status #{:inactive :active "INACTIVE" "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.iot.group-name-and-arn/group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.group-name-and-arn/group-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot/group-name-and-arn (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.group-name-and-arn/group-name :portkey.aws.iot.group-name-and-arn/group-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.timeout-config/in-progress-timeout-in-minutes (clojure.spec.alpha/and :portkey.aws.iot/in-progress-timeout-in-minutes))
(clojure.spec.alpha/def :portkey.aws.iot/timeout-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.timeout-config/in-progress-timeout-in-minutes]))

(clojure.spec.alpha/def :portkey.aws.iot.start-on-demand-audit-task-response/task-id (clojure.spec.alpha/and :portkey.aws.iot/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot/start-on-demand-audit-task-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.start-on-demand-audit-task-response/task-id]))

(clojure.spec.alpha/def :portkey.aws.iot/aws-account-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 12 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 12)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[0-9]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot/is-disabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/dynamic-group-status #{:building "REBUILDING" :active "BUILDING" "ACTIVE" :rebuilding})

(clojure.spec.alpha/def :portkey.aws.iot.sql-parse-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/sql-parse-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.sql-parse-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-response/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-response/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot/update-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-authorizer-response/authorizer-name :portkey.aws.iot.update-authorizer-response/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/resources (clojure.spec.alpha/coll-of :portkey.aws.iot/resource))

(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-response/frequency (clojure.spec.alpha/and :portkey.aws.iot/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-response/day-of-month (clojure.spec.alpha/and :portkey.aws.iot/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-response/day-of-week (clojure.spec.alpha/and :portkey.aws.iot/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-response/target-check-names (clojure.spec.alpha/and :portkey.aws.iot/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-response/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-response/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot/describe-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-scheduled-audit-response/frequency :portkey.aws.iot.describe-scheduled-audit-response/day-of-month :portkey.aws.iot.describe-scheduled-audit-response/day-of-week :portkey.aws.iot.describe-scheduled-audit-response/target-check-names :portkey.aws.iot.describe-scheduled-audit-response/scheduled-audit-name :portkey.aws.iot.describe-scheduled-audit-response/scheduled-audit-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-documents (clojure.spec.alpha/coll-of :portkey.aws.iot/policy-document))

(clojure.spec.alpha/def :portkey.aws.iot.get-indexing-configuration-response/thing-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot/thing-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot.get-indexing-configuration-response/thing-group-indexing-configuration (clojure.spec.alpha/and :portkey.aws.iot/thing-group-indexing-configuration))
(clojure.spec.alpha/def :portkey.aws.iot/get-indexing-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-indexing-configuration-response/thing-indexing-configuration :portkey.aws.iot.get-indexing-configuration-response/thing-group-indexing-configuration]))

(clojure.spec.alpha/def :portkey.aws.iot/auth-decision #{"IMPLICIT_DENY" :explicit-deny "ALLOWED" :implicit-deny "EXPLICIT_DENY" :allowed})

(clojure.spec.alpha/def :portkey.aws.iot/attribute-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-authorizers-response/authorizers (clojure.spec.alpha/and :portkey.aws.iot/authorizers))
(clojure.spec.alpha/def :portkey.aws.iot.list-authorizers-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-authorizers-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-authorizers-response/authorizers :portkey.aws.iot.list-authorizers-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot/billing-group-name-and-arn-list (clojure.spec.alpha/coll-of :portkey.aws.iot/group-name-and-arn))

(clojure.spec.alpha/def :portkey.aws.iot.internal-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/internal-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.internal-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.file-location/stream (clojure.spec.alpha/and :portkey.aws.iot/stream))
(clojure.spec.alpha/def :portkey.aws.iot.file-location/s-3-location (clojure.spec.alpha/and :portkey.aws.iot/s-3-location))
(clojure.spec.alpha/def :portkey.aws.iot/file-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.file-location/stream :portkey.aws.iot.file-location/s-3-location]))

(clojure.spec.alpha/def :portkey.aws.iot.log-target/target-type (clojure.spec.alpha/and :portkey.aws.iot/log-target-type))
(clojure.spec.alpha/def :portkey.aws.iot.log-target/target-name (clojure.spec.alpha/and :portkey.aws.iot/log-target-name))
(clojure.spec.alpha/def :portkey.aws.iot/log-target (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.log-target/target-type] :opt-un [:portkey.aws.iot.log-target/target-name]))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/default-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/generation-id (clojure.spec.alpha/and :portkey.aws.iot/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-policy-response/policy-name :portkey.aws.iot.get-policy-response/policy-arn :portkey.aws.iot.get-policy-response/policy-document :portkey.aws.iot.get-policy-response/default-version-id :portkey.aws.iot.get-policy-response/creation-date :portkey.aws.iot.get-policy-response/last-modified-date :portkey.aws.iot.get-policy-response/generation-id]))

(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-namespace (clojure.spec.alpha/and :portkey.aws.iot/string))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-name (clojure.spec.alpha/and :portkey.aws.iot/string))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-value (clojure.spec.alpha/and :portkey.aws.iot/string))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-unit (clojure.spec.alpha/and :portkey.aws.iot/string))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-timestamp (clojure.spec.alpha/and :portkey.aws.iot/string))
(clojure.spec.alpha/def :portkey.aws.iot/cloudwatch-metric-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.cloudwatch-metric-action/role-arn :portkey.aws.iot.cloudwatch-metric-action/metric-namespace :portkey.aws.iot.cloudwatch-metric-action/metric-name :portkey.aws.iot.cloudwatch-metric-action/metric-value :portkey.aws.iot.cloudwatch-metric-action/metric-unit] :opt-un [:portkey.aws.iot.cloudwatch-metric-action/metric-timestamp]))

(clojure.spec.alpha/def :portkey.aws.iot.set-default-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot/set-default-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.set-default-authorizer-request/authorizer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.version-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/version-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.version-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.audit-notification-target/target-arn (clojure.spec.alpha/and :portkey.aws.iot/target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.audit-notification-target/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.audit-notification-target/enabled (clojure.spec.alpha/and :portkey.aws.iot/enabled))
(clojure.spec.alpha/def :portkey.aws.iot/audit-notification-target (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.audit-notification-target/target-arn :portkey.aws.iot.audit-notification-target/role-arn :portkey.aws.iot.audit-notification-target/enabled]))

(clojure.spec.alpha/def :portkey.aws.iot.job-executions-rollout-config/maximum-per-minute (clojure.spec.alpha/and :portkey.aws.iot/max-job-executions-per-min))
(clojure.spec.alpha/def :portkey.aws.iot.job-executions-rollout-config/exponential-rate (clojure.spec.alpha/and :portkey.aws.iot/exponential-rollout-rate))
(clojure.spec.alpha/def :portkey.aws.iot/job-executions-rollout-config (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-executions-rollout-config/maximum-per-minute :portkey.aws.iot.job-executions-rollout-config/exponential-rate]))

(clojure.spec.alpha/def :portkey.aws.iot.stream-summary/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.stream-summary/stream-arn (clojure.spec.alpha/and :portkey.aws.iot/stream-arn))
(clojure.spec.alpha/def :portkey.aws.iot.stream-summary/stream-version (clojure.spec.alpha/and :portkey.aws.iot/stream-version))
(clojure.spec.alpha/def :portkey.aws.iot.stream-summary/description (clojure.spec.alpha/and :portkey.aws.iot/stream-description))
(clojure.spec.alpha/def :portkey.aws.iot/stream-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.stream-summary/stream-id :portkey.aws.iot.stream-summary/stream-arn :portkey.aws.iot.stream-summary/stream-version :portkey.aws.iot.stream-summary/description]))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-policy-response/policy-name :portkey.aws.iot.create-policy-response/policy-arn :portkey.aws.iot.create-policy-response/policy-document :portkey.aws.iot.create-policy-response/policy-version-id]))

(clojure.spec.alpha/def :portkey.aws.iot/describe-account-audit-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/delete-behaviors clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-thing-group-request/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-thing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-thing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot/remove-thing-from-thing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.remove-thing-from-thing-group-request/thing-group-name :portkey.aws.iot.remove-thing-from-thing-group-request/thing-group-arn :portkey.aws.iot.remove-thing-from-thing-group-request/thing-name :portkey.aws.iot.remove-thing-from-thing-group-request/thing-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.error-info/code (clojure.spec.alpha/and :portkey.aws.iot/code))
(clojure.spec.alpha/def :portkey.aws.iot.error-info/message (clojure.spec.alpha/and :portkey.aws.iot/ota-update-error-message))
(clojure.spec.alpha/def :portkey.aws.iot/error-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.error-info/code :portkey.aws.iot.error-info/message]))

(clojure.spec.alpha/def :portkey.aws.iot/attributes-map (clojure.spec.alpha/map-of :portkey.aws.iot/attribute-key :portkey.aws.iot/value))

(clojure.spec.alpha/def :portkey.aws.iot/job-document-source (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1350))))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-request/parent-group (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-request/name-prefix-filter (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-groups-request/recursive (clojure.spec.alpha/and :portkey.aws.iot/recursive-without-default))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-groups-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-groups-request/next-token :portkey.aws.iot.list-thing-groups-request/max-results :portkey.aws.iot.list-thing-groups-request/parent-group :portkey.aws.iot.list-thing-groups-request/name-prefix-filter :portkey.aws.iot.list-thing-groups-request/recursive]))

(clojure.spec.alpha/def :portkey.aws.iot/remove-thing-type clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.thing-group-document/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-document/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-document/thing-group-description (clojure.spec.alpha/and :portkey.aws.iot/thing-group-description))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-document/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.thing-group-document/parent-group-names (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name-list))
(clojure.spec.alpha/def :portkey.aws.iot/thing-group-document (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-group-document/thing-group-name :portkey.aws.iot.thing-group-document/thing-group-id :portkey.aws.iot.thing-group-document/thing-group-description :portkey.aws.iot.thing-group-document/attributes :portkey.aws.iot.thing-group-document/parent-group-names]))

(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-billing-group-request/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-billing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.remove-thing-from-billing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot/remove-thing-from-billing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.remove-thing-from-billing-group-request/billing-group-name :portkey.aws.iot.remove-thing-from-billing-group-request/billing-group-arn :portkey.aws.iot.remove-thing-from-billing-group-request/thing-name :portkey.aws.iot.remove-thing-from-billing-group-request/thing-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/authorizer-function-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/token-key-name (clojure.spec.alpha/and :portkey.aws.iot/token-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/token-signing-public-keys (clojure.spec.alpha/and :portkey.aws.iot/public-key-map))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/status (clojure.spec.alpha/and :portkey.aws.iot/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.authorizer-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/authorizer-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.authorizer-description/authorizer-name :portkey.aws.iot.authorizer-description/authorizer-arn :portkey.aws.iot.authorizer-description/authorizer-function-arn :portkey.aws.iot.authorizer-description/token-key-name :portkey.aws.iot.authorizer-description/token-signing-public-keys :portkey.aws.iot.authorizer-description/status :portkey.aws.iot.authorizer-description/creation-date :portkey.aws.iot.authorizer-description/last-modified-date]))

(clojure.spec.alpha/def :portkey.aws.iot/delivery-stream-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-response/findings (clojure.spec.alpha/and :portkey.aws.iot/audit-findings))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-findings-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-audit-findings-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-audit-findings-response/findings :portkey.aws.iot.list-audit-findings-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.attach-thing-principal-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.attach-thing-principal-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/attach-thing-principal-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.attach-thing-principal-request/thing-name :portkey.aws.iot.attach-thing-principal-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/billing-group-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.resource-registration-failure-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/resource-registration-failure-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.resource-registration-failure-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.sqs-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.sqs-action/queue-url (clojure.spec.alpha/and :portkey.aws.iot/queue-url))
(clojure.spec.alpha/def :portkey.aws.iot.sqs-action/use-base-64 (clojure.spec.alpha/and :portkey.aws.iot/use-base-64))
(clojure.spec.alpha/def :portkey.aws.iot/sqs-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.sqs-action/role-arn :portkey.aws.iot.sqs-action/queue-url] :opt-un [:portkey.aws.iot.sqs-action/use-base-64]))

(clojure.spec.alpha/def :portkey.aws.iot/add-thing-to-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/s-3-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.delete-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-scheduled-audit-request/scheduled-audit-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-versions-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-policy-versions-request/policy-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/cognito-identity-pool-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/delete-additional-metrics-to-retain clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/parameter (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/details-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 1024)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[^\p{C}]*+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/ports (clojure.spec.alpha/coll-of :portkey.aws.iot/port))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.get-policy-version-request/policy-name :portkey.aws.iot.get-policy-version-request/policy-version-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.allowed/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot/allowed (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.allowed/policies]))

(clojure.spec.alpha/def :portkey.aws.iot/percentage (clojure.spec.alpha/int-in 0 100))

(clojure.spec.alpha/def :portkey.aws.iot/job-targets (clojure.spec.alpha/coll-of :portkey.aws.iot/target-arn :min-count 1))

(clojure.spec.alpha/def :portkey.aws.iot/missing-context-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/thing-connectivity-indexing-mode #{"STATUS" :status :off "OFF"})

(clojure.spec.alpha/def :portkey.aws.iot.denied/implicit-deny (clojure.spec.alpha/and :portkey.aws.iot/implicit-deny))
(clojure.spec.alpha/def :portkey.aws.iot.denied/explicit-deny (clojure.spec.alpha/and :portkey.aws.iot/explicit-deny))
(clojure.spec.alpha/def :portkey.aws.iot/denied (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.denied/implicit-deny :portkey.aws.iot.denied/explicit-deny]))

(clojure.spec.alpha/def :portkey.aws.iot/update-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/policy-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.code-signing-signature/inline-document (clojure.spec.alpha/and :portkey.aws.iot/signature))
(clojure.spec.alpha/def :portkey.aws.iot/code-signing-signature (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.code-signing-signature/inline-document]))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-things-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-principal-things-request/principal] :opt-un [:portkey.aws.iot.list-principal-things-request/next-token :portkey.aws.iot.list-principal-things-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.invalid-state-transition-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/invalid-state-transition-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.invalid-state-transition-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-certificate-response/certificate-description (clojure.spec.alpha/and :portkey.aws.iot/certificate-description))
(clojure.spec.alpha/def :portkey.aws.iot/describe-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-certificate-response/certificate-description]))

(clojure.spec.alpha/def :portkey.aws.iot.conflicting-resource-update-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/conflicting-resource-update-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.conflicting-resource-update-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/alert-target-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.describe-endpoint-request/endpoint-type (clojure.spec.alpha/and :portkey.aws.iot/endpoint-type))
(clojure.spec.alpha/def :portkey.aws.iot/describe-endpoint-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-endpoint-request/endpoint-type]))

(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-security-profile-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-targets-for-security-profile-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-targets-for-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-targets-for-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.list-targets-for-security-profile-request/next-token :portkey.aws.iot.list-targets-for-security-profile-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-by-ca-request/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-by-ca-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-by-ca-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-by-ca-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-by-ca-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-certificates-by-ca-request/ca-certificate-id] :opt-un [:portkey.aws.iot.list-certificates-by-ca-request/page-size :portkey.aws.iot.list-certificates-by-ca-request/marker :portkey.aws.iot.list-certificates-by-ca-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/abort-threshold-percentage clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.iot/audit-notification-type #{:sns "SNS"})

(clojure.spec.alpha/def :portkey.aws.iot/s-3-file-url (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 65535))))

(clojure.spec.alpha/def :portkey.aws.iot/report-type #{:errors "RESULTS" "ERRORS" :results})

(clojure.spec.alpha/def :portkey.aws.iot.describe-role-alias-response/role-alias-description (clojure.spec.alpha/and :portkey.aws.iot/role-alias-description))
(clojure.spec.alpha/def :portkey.aws.iot/describe-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-role-alias-response/role-alias-description]))

(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/delete-behaviors (clojure.spec.alpha/and :portkey.aws.iot/delete-behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/behaviors (clojure.spec.alpha/and :portkey.aws.iot/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/delete-alert-targets (clojure.spec.alpha/and :portkey.aws.iot/delete-alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/delete-additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot/delete-additional-metrics-to-retain))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-security-profile-request/alert-targets (clojure.spec.alpha/and :portkey.aws.iot/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot/update-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-security-profile-request/security-profile-name] :opt-un [:portkey.aws.iot.update-security-profile-request/delete-behaviors :portkey.aws.iot.update-security-profile-request/additional-metrics-to-retain :portkey.aws.iot.update-security-profile-request/behaviors :portkey.aws.iot.update-security-profile-request/security-profile-description :portkey.aws.iot.update-security-profile-request/expected-version :portkey.aws.iot.update-security-profile-request/delete-alert-targets :portkey.aws.iot.update-security-profile-request/delete-additional-metrics-to-retain :portkey.aws.iot.update-security-profile-request/alert-targets]))

(clojure.spec.alpha/def :portkey.aws.iot.get-job-document-response/document (clojure.spec.alpha/and :portkey.aws.iot/job-document))
(clojure.spec.alpha/def :portkey.aws.iot/get-job-document-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-job-document-response/document]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/resource-type #{:ca-certificate "ACCOUNT_SETTINGS" "CLIENT_ID" :client-id :account-settings "CA_CERTIFICATE" :device-certificate "IOT_POLICY" "COGNITO_IDENTITY_POOL" "DEVICE_CERTIFICATE" :iot-policy :cognito-identity-pool})

(clojure.spec.alpha/def :portkey.aws.iot/alarm-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.job-execution-status-details/details-map (clojure.spec.alpha/and :portkey.aws.iot/details-map))
(clojure.spec.alpha/def :portkey.aws.iot/job-execution-status-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-execution-status-details/details-map]))

(clojure.spec.alpha/def :portkey.aws.iot/hash-key-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/targets (clojure.spec.alpha/coll-of :portkey.aws.iot/target :min-count 1))

(clojure.spec.alpha/def :portkey.aws.iot/thing-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.delete-account-audit-configuration-request/delete-scheduled-audits (clojure.spec.alpha/and :portkey.aws.iot/delete-scheduled-audits))
(clojure.spec.alpha/def :portkey.aws.iot/delete-account-audit-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.delete-account-audit-configuration-request/delete-scheduled-audits]))

(clojure.spec.alpha/def :portkey.aws.iot.republish-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.republish-action/topic (clojure.spec.alpha/and :portkey.aws.iot/topic-pattern))
(clojure.spec.alpha/def :portkey.aws.iot/republish-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.republish-action/role-arn :portkey.aws.iot.republish-action/topic] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.describe-job-response/document-source (clojure.spec.alpha/and :portkey.aws.iot/job-document-source))
(clojure.spec.alpha/def :portkey.aws.iot.describe-job-response/job (clojure.spec.alpha/and :portkey.aws.iot/job))
(clojure.spec.alpha/def :portkey.aws.iot/describe-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-job-response/document-source :portkey.aws.iot.describe-job-response/job]))

(clojure.spec.alpha/def :portkey.aws.iot.resource-identifier/device-certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.resource-identifier/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.resource-identifier/cognito-identity-pool-id (clojure.spec.alpha/and :portkey.aws.iot/cognito-identity-pool-id))
(clojure.spec.alpha/def :portkey.aws.iot.resource-identifier/client-id (clojure.spec.alpha/and :portkey.aws.iot/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.resource-identifier/policy-version-identifier (clojure.spec.alpha/and :portkey.aws.iot/policy-version-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.resource-identifier/account (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot/resource-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.resource-identifier/device-certificate-id :portkey.aws.iot.resource-identifier/ca-certificate-id :portkey.aws.iot.resource-identifier/cognito-identity-pool-id :portkey.aws.iot.resource-identifier/client-id :portkey.aws.iot.resource-identifier/policy-version-identifier :portkey.aws.iot.resource-identifier/account]))

(clojure.spec.alpha/def :portkey.aws.iot/s-3-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.list-v-2-logging-levels-response/log-target-configurations (clojure.spec.alpha/and :portkey.aws.iot/log-target-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.list-v-2-logging-levels-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-v-2-logging-levels-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-v-2-logging-levels-response/log-target-configurations :portkey.aws.iot.list-v-2-logging-levels-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/authorizer-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-ota-update-request/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-ota-update-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.get-ota-update-request/ota-update-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/clear-default-authorizer-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-request/ca-certificate (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-request/verification-certificate (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-request/allow-auto-registration (clojure.spec.alpha/and :portkey.aws.iot/allow-auto-registration))
(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-request/registration-config (clojure.spec.alpha/and :portkey.aws.iot/registration-config))
(clojure.spec.alpha/def :portkey.aws.iot/register-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.register-ca-certificate-request/ca-certificate :portkey.aws.iot.register-ca-certificate-request/verification-certificate] :opt-un [:portkey.aws.iot.register-ca-certificate-request/set-as-active :portkey.aws.iot.register-ca-certificate-request/allow-auto-registration :portkey.aws.iot.register-ca-certificate-request/registration-config]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-policies-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-policies-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-policies-request/marker :portkey.aws.iot.list-policies-request/page-size :portkey.aws.iot.list-policies-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/stream-version (clojure.spec.alpha/int-in 0 65535))

(clojure.spec.alpha/def :portkey.aws.iot.describe-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-scheduled-audit-request/scheduled-audit-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/job-execution-status #{"CANCELED" :timed-out "IN_PROGRESS" "TIMED_OUT" :in-progress :rejected "REMOVED" :queued :canceled "SUCCEEDED" "REJECTED" "QUEUED" "FAILED" :removed :failed :succeeded})

(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/register-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.register-certificate-response/certificate-arn :portkey.aws.iot.register-certificate-response/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot.metric-value/count (clojure.spec.alpha/and :portkey.aws.iot/unsigned-long))
(clojure.spec.alpha/def :portkey.aws.iot.metric-value/cidrs (clojure.spec.alpha/and :portkey.aws.iot/cidrs))
(clojure.spec.alpha/def :portkey.aws.iot.metric-value/ports (clojure.spec.alpha/and :portkey.aws.iot/ports))
(clojure.spec.alpha/def :portkey.aws.iot/metric-value (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.metric-value/count :portkey.aws.iot.metric-value/cidrs :portkey.aws.iot.metric-value/ports]))

(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-timed-out-things (clojure.spec.alpha/and :portkey.aws.iot/timed-out-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-canceled-things (clojure.spec.alpha/and :portkey.aws.iot/canceled-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-queued-things (clojure.spec.alpha/and :portkey.aws.iot/queued-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-in-progress-things (clojure.spec.alpha/and :portkey.aws.iot/in-progress-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-removed-things (clojure.spec.alpha/and :portkey.aws.iot/removed-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-failed-things (clojure.spec.alpha/and :portkey.aws.iot/failed-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-succeeded-things (clojure.spec.alpha/and :portkey.aws.iot/succeeded-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/number-of-rejected-things (clojure.spec.alpha/and :portkey.aws.iot/rejected-things))
(clojure.spec.alpha/def :portkey.aws.iot.job-process-details/processing-targets (clojure.spec.alpha/and :portkey.aws.iot/processing-target-name-list))
(clojure.spec.alpha/def :portkey.aws.iot/job-process-details (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-process-details/number-of-timed-out-things :portkey.aws.iot.job-process-details/number-of-canceled-things :portkey.aws.iot.job-process-details/number-of-queued-things :portkey.aws.iot.job-process-details/number-of-in-progress-things :portkey.aws.iot.job-process-details/number-of-removed-things :portkey.aws.iot.job-process-details/number-of-failed-things :portkey.aws.iot.job-process-details/number-of-succeeded-things :portkey.aws.iot.job-process-details/number-of-rejected-things :portkey.aws.iot.job-process-details/processing-targets]))

(clojure.spec.alpha/def :portkey.aws.iot/client-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-already-completed-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-already-completed-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.transfer-already-completed-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-request/authorizer-function-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-request/token-key-name (clojure.spec.alpha/and :portkey.aws.iot/token-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-request/token-signing-public-keys (clojure.spec.alpha/and :portkey.aws.iot/public-key-map))
(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-request/status (clojure.spec.alpha/and :portkey.aws.iot/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot/create-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-authorizer-request/authorizer-name :portkey.aws.iot.create-authorizer-request/authorizer-function-arn :portkey.aws.iot.create-authorizer-request/token-key-name :portkey.aws.iot.create-authorizer-request/token-signing-public-keys] :opt-un [:portkey.aws.iot.create-authorizer-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot/audit-check-configurations (clojure.spec.alpha/map-of :portkey.aws.iot/audit-check-name :portkey.aws.iot/audit-check-configuration))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-principals-response/principals (clojure.spec.alpha/and :portkey.aws.iot/principals))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-principals-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-principals-response/principals]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-scheduled-audits clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/endpoint (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-endpoint))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/index (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-index))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/type (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-type))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/id (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-id))
(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.elasticsearch-action/role-arn :portkey.aws.iot.elasticsearch-action/endpoint :portkey.aws.iot.elasticsearch-action/index :portkey.aws.iot.elasticsearch-action/type :portkey.aws.iot.elasticsearch-action/id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.s-3-location/bucket (clojure.spec.alpha/and :portkey.aws.iot/s-3-bucket))
(clojure.spec.alpha/def :portkey.aws.iot.s-3-location/key (clojure.spec.alpha/and :portkey.aws.iot/s-3-key))
(clojure.spec.alpha/def :portkey.aws.iot.s-3-location/version (clojure.spec.alpha/and :portkey.aws.iot/s-3-version))
(clojure.spec.alpha/def :portkey.aws.iot/s-3-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.s-3-location/bucket :portkey.aws.iot.s-3-location/key :portkey.aws.iot.s-3-location/version]))

(clojure.spec.alpha/def :portkey.aws.iot.set-v-2-logging-level-request/log-target (clojure.spec.alpha/and :portkey.aws.iot/log-target))
(clojure.spec.alpha/def :portkey.aws.iot.set-v-2-logging-level-request/log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot/set-v-2-logging-level-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.set-v-2-logging-level-request/log-target :portkey.aws.iot.set-v-2-logging-level-request/log-level] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/total-checks (clojure.spec.alpha/and :portkey.aws.iot/total-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/in-progress-checks (clojure.spec.alpha/and :portkey.aws.iot/in-progress-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/waiting-for-data-collection-checks (clojure.spec.alpha/and :portkey.aws.iot/waiting-for-data-collection-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/compliant-checks (clojure.spec.alpha/and :portkey.aws.iot/compliant-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/non-compliant-checks (clojure.spec.alpha/and :portkey.aws.iot/non-compliant-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/failed-checks (clojure.spec.alpha/and :portkey.aws.iot/failed-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot.task-statistics/canceled-checks (clojure.spec.alpha/and :portkey.aws.iot/canceled-checks-count))
(clojure.spec.alpha/def :portkey.aws.iot/task-statistics (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.task-statistics/total-checks :portkey.aws.iot.task-statistics/in-progress-checks :portkey.aws.iot.task-statistics/waiting-for-data-collection-checks :portkey.aws.iot.task-statistics/compliant-checks :portkey.aws.iot.task-statistics/non-compliant-checks :portkey.aws.iot.task-statistics/failed-checks :portkey.aws.iot.task-statistics/canceled-checks]))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-index (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-job-document-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-job-document-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.get-job-document-request/job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/policies (clojure.spec.alpha/coll-of :portkey.aws.iot/policy))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-response/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-response/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-group-response/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-thing-group-response/thing-group-name :portkey.aws.iot.create-thing-group-response/thing-group-arn :portkey.aws.iot.create-thing-group-response/thing-group-id]))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.custom-code-signing/signature (clojure.spec.alpha/and :portkey.aws.iot/code-signing-signature))
(clojure.spec.alpha/def :portkey.aws.iot.custom-code-signing/certificate-chain (clojure.spec.alpha/and :portkey.aws.iot/code-signing-certificate-chain))
(clojure.spec.alpha/def :portkey.aws.iot.custom-code-signing/hash-algorithm (clojure.spec.alpha/and :portkey.aws.iot/hash-algorithm))
(clojure.spec.alpha/def :portkey.aws.iot.custom-code-signing/signature-algorithm (clojure.spec.alpha/and :portkey.aws.iot/signature-algorithm))
(clojure.spec.alpha/def :portkey.aws.iot/custom-code-signing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.custom-code-signing/signature :portkey.aws.iot.custom-code-signing/certificate-chain :portkey.aws.iot.custom-code-signing/hash-algorithm :portkey.aws.iot.custom-code-signing/signature-algorithm]))

(clojure.spec.alpha/def :portkey.aws.iot/set-as-active clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/table-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/stop-thing-registration-task-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/s-3-bucket (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot/billing-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.describe-stream-request/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-stream-request/stream-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/aws-iot-sql-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.update-billing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot/update-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-billing-group-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot.disable-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/disable-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.disable-topic-rule-request/rule-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/auth-infos (clojure.spec.alpha/coll-of :portkey.aws.iot/auth-info :min-count 1 :max-count 10))

(clojure.spec.alpha/def :portkey.aws.iot.detach-security-profile-request/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.detach-security-profile-request/security-profile-target-arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot/detach-security-profile-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.detach-security-profile-request/security-profile-name :portkey.aws.iot.detach-security-profile-request/security-profile-target-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.stream/stream-id (clojure.spec.alpha/and :portkey.aws.iot/stream-id))
(clojure.spec.alpha/def :portkey.aws.iot.stream/file-id (clojure.spec.alpha/and :portkey.aws.iot/file-id))
(clojure.spec.alpha/def :portkey.aws.iot/stream (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.stream/stream-id :portkey.aws.iot.stream/file-id]))

(clojure.spec.alpha/def :portkey.aws.iot/sql (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.validate-security-profile-behaviors-response/valid (clojure.spec.alpha/and :portkey.aws.iot/valid))
(clojure.spec.alpha/def :portkey.aws.iot.validate-security-profile-behaviors-response/validation-errors (clojure.spec.alpha/and :portkey.aws.iot/validation-errors))
(clojure.spec.alpha/def :portkey.aws.iot/validate-security-profile-behaviors-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.validate-security-profile-behaviors-response/valid :portkey.aws.iot.validate-security-profile-behaviors-response/validation-errors]))

(clojure.spec.alpha/def :portkey.aws.iot/details-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/registry-s-3-bucket-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 3 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 256)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9._-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-job-request/status (clojure.spec.alpha/and :portkey.aws.iot/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-job-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/laser-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-job-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-job-executions-for-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-job-executions-for-job-request/job-id] :opt-un [:portkey.aws.iot.list-job-executions-for-job-request/status :portkey.aws.iot.list-job-executions-for-job-request/max-results :portkey.aws.iot.list-job-executions-for-job-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/creation-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot/abort-action #{"CANCEL" :cancel})

(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/range-key-value (clojure.spec.alpha/and :portkey.aws.iot/range-key-value))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/table-name (clojure.spec.alpha/and :portkey.aws.iot/table-name))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/hash-key-value (clojure.spec.alpha/and :portkey.aws.iot/hash-key-value))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/range-key-field (clojure.spec.alpha/and :portkey.aws.iot/range-key-field))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/hash-key-type (clojure.spec.alpha/and :portkey.aws.iot/dynamo-key-type))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/operation (clojure.spec.alpha/and :portkey.aws.iot/dynamo-operation))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/payload-field (clojure.spec.alpha/and :portkey.aws.iot/payload-field))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/hash-key-field (clojure.spec.alpha/and :portkey.aws.iot/hash-key-field))
(clojure.spec.alpha/def :portkey.aws.iot.dynamo-db-action/range-key-type (clojure.spec.alpha/and :portkey.aws.iot/dynamo-key-type))
(clojure.spec.alpha/def :portkey.aws.iot/dynamo-db-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.dynamo-db-action/table-name :portkey.aws.iot.dynamo-db-action/role-arn :portkey.aws.iot.dynamo-db-action/hash-key-field :portkey.aws.iot.dynamo-db-action/hash-key-value] :opt-un [:portkey.aws.iot.dynamo-db-action/range-key-value :portkey.aws.iot.dynamo-db-action/range-key-field :portkey.aws.iot.dynamo-db-action/hash-key-type :portkey.aws.iot.dynamo-db-action/operation :portkey.aws.iot.dynamo-db-action/payload-field :portkey.aws.iot.dynamo-db-action/range-key-type]))

(clojure.spec.alpha/def :portkey.aws.iot.update-thing-groups-for-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-groups-for-thing-request/thing-groups-to-add (clojure.spec.alpha/and :portkey.aws.iot/thing-group-list))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-groups-for-thing-request/thing-groups-to-remove (clojure.spec.alpha/and :portkey.aws.iot/thing-group-list))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-groups-for-thing-request/override-dynamic-groups (clojure.spec.alpha/and :portkey.aws.iot/override-dynamic-groups))
(clojure.spec.alpha/def :portkey.aws.iot/update-thing-groups-for-thing-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-thing-groups-for-thing-request/thing-name :portkey.aws.iot.update-thing-groups-for-thing-request/thing-groups-to-add :portkey.aws.iot.update-thing-groups-for-thing-request/thing-groups-to-remove :portkey.aws.iot.update-thing-groups-for-thing-request/override-dynamic-groups]))

(clojure.spec.alpha/def :portkey.aws.iot/violation-event-type #{:inalarm "alarm-invalidated" :alarmcleared "in-alarm" "alarm-cleared" :alarminvalidated})

(clojure.spec.alpha/def :portkey.aws.iot/total-resources-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-response/principals (clojure.spec.alpha/and :portkey.aws.iot/principals))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-principals-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-policy-principals-response/principals :portkey.aws.iot.list-policy-principals-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-request/frequency (clojure.spec.alpha/and :portkey.aws.iot/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-request/day-of-month (clojure.spec.alpha/and :portkey.aws.iot/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-request/day-of-week (clojure.spec.alpha/and :portkey.aws.iot/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-request/target-check-names (clojure.spec.alpha/and :portkey.aws.iot/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot/create-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-scheduled-audit-request/frequency :portkey.aws.iot.create-scheduled-audit-request/target-check-names :portkey.aws.iot.create-scheduled-audit-request/scheduled-audit-name] :opt-un [:portkey.aws.iot.create-scheduled-audit-request/day-of-month :portkey.aws.iot.create-scheduled-audit-request/day-of-week :portkey.aws.iot.create-scheduled-audit-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot/topic-rule-list (clojure.spec.alpha/coll-of :portkey.aws.iot/topic-rule-list-item))

(clojure.spec.alpha/def :portkey.aws.iot/security-profile-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/remove-thing-type (clojure.spec.alpha/and :portkey.aws.iot/remove-thing-type))
(clojure.spec.alpha/def :portkey.aws.iot/update-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-thing-request/thing-name] :opt-un [:portkey.aws.iot.update-thing-request/thing-type-name :portkey.aws.iot.update-thing-request/attribute-payload :portkey.aws.iot.update-thing-request/expected-version :portkey.aws.iot.update-thing-request/remove-thing-type]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-version-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[0-9]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.alert-target/alert-target-arn (clojure.spec.alpha/and :portkey.aws.iot/alert-target-arn))
(clojure.spec.alpha/def :portkey.aws.iot.alert-target/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot/alert-target (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.alert-target/alert-target-arn :portkey.aws.iot.alert-target/role-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-response/thing-types (clojure.spec.alpha/and :portkey.aws.iot/thing-type-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-types-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-types-response/thing-types :portkey.aws.iot.list-thing-types-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-ca-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-ca-certificate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-ca-certificate-request/certificate-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot/dynamo-operation (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/resource-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/authorizers (clojure.spec.alpha/coll-of :portkey.aws.iot/authorizer-summary))

(clojure.spec.alpha/def :portkey.aws.iot/processing-target-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot/processing-target-name))

(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-thing-response/execution-summaries (clojure.spec.alpha/and :portkey.aws.iot/job-execution-summary-for-thing-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-thing-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-job-executions-for-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-job-executions-for-thing-response/execution-summaries :portkey.aws.iot.list-job-executions-for-thing-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-response/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-response/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-response/thing-id (clojure.spec.alpha/and :portkey.aws.iot/thing-id))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-thing-response/thing-name :portkey.aws.iot.create-thing-response/thing-arn :portkey.aws.iot.create-thing-response/thing-id]))

(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-request/cognito-identity-pool-id (clojure.spec.alpha/and :portkey.aws.iot/cognito-identity-pool-id))
(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-request/auth-infos (clojure.spec.alpha/and :portkey.aws.iot/auth-infos))
(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-request/client-id (clojure.spec.alpha/and :portkey.aws.iot/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-request/policy-names-to-add (clojure.spec.alpha/and :portkey.aws.iot/policy-names))
(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-request/policy-names-to-skip (clojure.spec.alpha/and :portkey.aws.iot/policy-names))
(clojure.spec.alpha/def :portkey.aws.iot/test-authorization-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.test-authorization-request/auth-infos] :opt-un [:portkey.aws.iot.test-authorization-request/principal :portkey.aws.iot.test-authorization-request/cognito-identity-pool-id :portkey.aws.iot.test-authorization-request/client-id :portkey.aws.iot.test-authorization-request/policy-names-to-add :portkey.aws.iot.test-authorization-request/policy-names-to-skip]))

(clojure.spec.alpha/def :portkey.aws.iot/clear-default-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/hash-algorithm (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-response/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-response/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-response/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-response/index-name (clojure.spec.alpha/and :portkey.aws.iot/index-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-response/query-string (clojure.spec.alpha/and :portkey.aws.iot/query-string))
(clojure.spec.alpha/def :portkey.aws.iot.create-dynamic-thing-group-response/query-version (clojure.spec.alpha/and :portkey.aws.iot/query-version))
(clojure.spec.alpha/def :portkey.aws.iot/create-dynamic-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-dynamic-thing-group-response/thing-group-name :portkey.aws.iot.create-dynamic-thing-group-response/thing-group-arn :portkey.aws.iot.create-dynamic-thing-group-response/thing-group-id :portkey.aws.iot.create-dynamic-thing-group-response/index-name :portkey.aws.iot.create-dynamic-thing-group-response/query-string :portkey.aws.iot.create-dynamic-thing-group-response/query-version]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-principals-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-policy-principals-request/policy-name] :opt-un [:portkey.aws.iot.list-policy-principals-request/marker :portkey.aws.iot.list-policy-principals-request/page-size :portkey.aws.iot.list-policy-principals-request/ascending-order]))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-status #{:inactive "REGISTER_INACTIVE" "REVOKED" :revoked :pending-activation :register-inactive :pending-transfer :active "INACTIVE" "PENDING_ACTIVATION" "ACTIVE" "PENDING_TRANSFER"})

(clojure.spec.alpha/def :portkey.aws.iot.policy-version-identifier/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.policy-version-identifier/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/policy-version-identifier (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.policy-version-identifier/policy-name :portkey.aws.iot.policy-version-identifier/policy-version-id]))

(clojure.spec.alpha/def :portkey.aws.iot.security-profile-identifier/name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.security-profile-identifier/arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot/security-profile-identifier (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.security-profile-identifier/name :portkey.aws.iot.security-profile-identifier/arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.describe-authorizer-response/authorizer-description (clojure.spec.alpha/and :portkey.aws.iot/authorizer-description))
(clojure.spec.alpha/def :portkey.aws.iot/describe-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-authorizer-response/authorizer-description]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-name-and-arn-list (clojure.spec.alpha/coll-of :portkey.aws.iot/group-name-and-arn))

(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-response/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-authorizer-response/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-authorizer-response/authorizer-name :portkey.aws.iot.create-authorizer-response/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.validate-security-profile-behaviors-request/behaviors (clojure.spec.alpha/and :portkey.aws.iot/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot/validate-security-profile-behaviors-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.validate-security-profile-behaviors-request/behaviors] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/customer-version (clojure.spec.alpha/int-in 1 Long/MAX_VALUE))

(clojure.spec.alpha/def :portkey.aws.iot/authorizer-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\w=,@-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.policy/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.policy/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot/policy (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.policy/policy-name :portkey.aws.iot.policy/policy-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-connectivity/connected (clojure.spec.alpha/and :portkey.aws.iot/boolean))
(clojure.spec.alpha/def :portkey.aws.iot.thing-connectivity/timestamp (clojure.spec.alpha/and :portkey.aws.iot/connectivity-timestamp))
(clojure.spec.alpha/def :portkey.aws.iot/thing-connectivity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-connectivity/connected :portkey.aws.iot.thing-connectivity/timestamp]))

(clojure.spec.alpha/def :portkey.aws.iot/key-pair (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot/public-key :portkey.aws.iot/private-key]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/maximum-per-minute (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.iot/behavior-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/max-results (clojure.spec.alpha/int-in 1 250))

(clojure.spec.alpha/def :portkey.aws.iot.detach-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.detach-policy-request/target (clojure.spec.alpha/and :portkey.aws.iot/policy-target))
(clojure.spec.alpha/def :portkey.aws.iot/detach-policy-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.detach-policy-request/policy-name :portkey.aws.iot.detach-policy-request/target] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.tag/key (clojure.spec.alpha/and :portkey.aws.iot/tag-key))
(clojure.spec.alpha/def :portkey.aws.iot.tag/value (clojure.spec.alpha/and :portkey.aws.iot/tag-value))
(clojure.spec.alpha/def :portkey.aws.iot/tag (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.tag/key :portkey.aws.iot.tag/value]))

(clojure.spec.alpha/def :portkey.aws.iot.s-3-destination/bucket (clojure.spec.alpha/and :portkey.aws.iot/s-3-bucket))
(clojure.spec.alpha/def :portkey.aws.iot.s-3-destination/prefix (clojure.spec.alpha/and :portkey.aws.iot/prefix))
(clojure.spec.alpha/def :portkey.aws.iot/s-3-destination (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.s-3-destination/bucket :portkey.aws.iot.s-3-destination/prefix]))

(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-job-response/execution-summaries (clojure.spec.alpha/and :portkey.aws.iot/job-execution-summary-for-job-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-job-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-job-executions-for-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-job-executions-for-job-response/execution-summaries :portkey.aws.iot.list-job-executions-for-job-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.malformed-policy-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/malformed-policy-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.malformed-policy-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/set-as-default clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/resource (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.get-ota-update-response/ota-update-info (clojure.spec.alpha/and :portkey.aws.iot/ota-update-info))
(clojure.spec.alpha/def :portkey.aws.iot/get-ota-update-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-ota-update-response/ota-update-info]))

(clojure.spec.alpha/def :portkey.aws.iot/reason-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[\p{Upper}\p{Digit}_]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.register-ca-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/register-ca-certificate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.register-ca-certificate-response/certificate-arn :portkey.aws.iot.register-ca-certificate-response/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot/job-execution-failure-type #{:timed-out "TIMED_OUT" :rejected :all "REJECTED" "FAILED" "ALL" :failed})

(clojure.spec.alpha/def :portkey.aws.iot/add-thing-to-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/state-machine-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-thing-group-request/thing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-thing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-thing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-thing-group-request/override-dynamic-groups (clojure.spec.alpha/and :portkey.aws.iot/override-dynamic-groups))
(clojure.spec.alpha/def :portkey.aws.iot/add-thing-to-thing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.add-thing-to-thing-group-request/thing-group-name :portkey.aws.iot.add-thing-to-thing-group-request/thing-group-arn :portkey.aws.iot.add-thing-to-thing-group-request/thing-name :portkey.aws.iot.add-thing-to-thing-group-request/thing-arn :portkey.aws.iot.add-thing-to-thing-group-request/override-dynamic-groups]))

(clojure.spec.alpha/def :portkey.aws.iot.create-scheduled-audit-response/scheduled-audit-arn (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-scheduled-audit-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-scheduled-audit-response/scheduled-audit-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.update-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.update-job-request/description (clojure.spec.alpha/and :portkey.aws.iot/job-description))
(clojure.spec.alpha/def :portkey.aws.iot.update-job-request/presigned-url-config (clojure.spec.alpha/and :portkey.aws.iot/presigned-url-config))
(clojure.spec.alpha/def :portkey.aws.iot.update-job-request/job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot/job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.update-job-request/abort-config (clojure.spec.alpha/and :portkey.aws.iot/abort-config))
(clojure.spec.alpha/def :portkey.aws.iot.update-job-request/timeout-config (clojure.spec.alpha/and :portkey.aws.iot/timeout-config))
(clojure.spec.alpha/def :portkey.aws.iot/update-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-job-request/job-id] :opt-un [:portkey.aws.iot.update-job-request/description :portkey.aws.iot.update-job-request/presigned-url-config :portkey.aws.iot.update-job-request/job-executions-rollout-config :portkey.aws.iot.update-job-request/abort-config :portkey.aws.iot.update-job-request/timeout-config]))

(clojure.spec.alpha/def :portkey.aws.iot.logging-options-payload/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.logging-options-payload/log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot/logging-options-payload (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.logging-options-payload/role-arn] :opt-un [:portkey.aws.iot.logging-options-payload/log-level]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-response/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-response/billing-group-id (clojure.spec.alpha/and :portkey.aws.iot/billing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-response/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-response/billing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/billing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-response/billing-group-metadata (clojure.spec.alpha/and :portkey.aws.iot/billing-group-metadata))
(clojure.spec.alpha/def :portkey.aws.iot/describe-billing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-billing-group-response/billing-group-name :portkey.aws.iot.describe-billing-group-response/billing-group-id :portkey.aws.iot.describe-billing-group-response/billing-group-arn :portkey.aws.iot.describe-billing-group-response/version :portkey.aws.iot.describe-billing-group-response/billing-group-properties :portkey.aws.iot.describe-billing-group-response/billing-group-metadata]))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.throttling-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/throttling-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.throttling-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/file-id (clojure.spec.alpha/int-in 0 255))

(clojure.spec.alpha/def :portkey.aws.iot/processing-target-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/creation-date (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/security-profile-arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/additional-metrics-to-retain (clojure.spec.alpha/and :portkey.aws.iot/additional-metrics-to-retain-list))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/behaviors (clojure.spec.alpha/and :portkey.aws.iot/behaviors))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/security-profile-description (clojure.spec.alpha/and :portkey.aws.iot/security-profile-description))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-security-profile-response/alert-targets (clojure.spec.alpha/and :portkey.aws.iot/alert-targets))
(clojure.spec.alpha/def :portkey.aws.iot/describe-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-security-profile-response/creation-date :portkey.aws.iot.describe-security-profile-response/security-profile-arn :portkey.aws.iot.describe-security-profile-response/additional-metrics-to-retain :portkey.aws.iot.describe-security-profile-response/behaviors :portkey.aws.iot.describe-security-profile-response/last-modified-date :portkey.aws.iot.describe-security-profile-response/security-profile-description :portkey.aws.iot.describe-security-profile-response/version :portkey.aws.iot.describe-security-profile-response/security-profile-name :portkey.aws.iot.describe-security-profile-response/alert-targets]))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-thing-group-request/recursive (clojure.spec.alpha/and :portkey.aws.iot/recursive))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-thing-group-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-in-thing-group-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-in-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-things-in-thing-group-request/thing-group-name] :opt-un [:portkey.aws.iot.list-things-in-thing-group-request/recursive :portkey.aws.iot.list-things-in-thing-group-request/next-token :portkey.aws.iot.list-things-in-thing-group-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/resource-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.salesforce-action/token (clojure.spec.alpha/and :portkey.aws.iot/salesforce-token))
(clojure.spec.alpha/def :portkey.aws.iot.salesforce-action/url (clojure.spec.alpha/and :portkey.aws.iot/salesforce-endpoint))
(clojure.spec.alpha/def :portkey.aws.iot/salesforce-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.salesforce-action/token :portkey.aws.iot.salesforce-action/url] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.delete-job-request/force (clojure.spec.alpha/and :portkey.aws.iot/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot/delete-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-job-request/job-id] :opt-un [:portkey.aws.iot.delete-job-request/force]))

(clojure.spec.alpha/def :portkey.aws.iot/event-configurations (clojure.spec.alpha/map-of :portkey.aws.iot/event-type :portkey.aws.iot/configuration))

(clojure.spec.alpha/def :portkey.aws.iot/version-number clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/salesforce-endpoint (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2000)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"https://ingestion-[a-zA-Z0-9]{1,12}\.[a-zA-Z0-9]+\.((sfdc-matrix\.net)|(sfdcnow\.com))/streams/\w{1,20}/\w{1,20}/event" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.cancel-audit-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot/audit-task-id))
(clojure.spec.alpha/def :portkey.aws.iot/cancel-audit-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.cancel-audit-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.step-functions-action/execution-name-prefix (clojure.spec.alpha/and :portkey.aws.iot/execution-name-prefix))
(clojure.spec.alpha/def :portkey.aws.iot.step-functions-action/state-machine-name (clojure.spec.alpha/and :portkey.aws.iot/state-machine-name))
(clojure.spec.alpha/def :portkey.aws.iot.step-functions-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot/step-functions-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.step-functions-action/state-machine-name :portkey.aws.iot.step-functions-action/role-arn] :opt-un [:portkey.aws.iot.step-functions-action/execution-name-prefix]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot.list-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-policies-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-policies-response/policies :portkey.aws.iot.list-policies-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot/ascending-order clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.job/target-selection (clojure.spec.alpha/and :portkey.aws.iot/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.job/created-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job/timeout-config (clojure.spec.alpha/and :portkey.aws.iot/timeout-config))
(clojure.spec.alpha/def :portkey.aws.iot.job/completed-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job/abort-config (clojure.spec.alpha/and :portkey.aws.iot/abort-config))
(clojure.spec.alpha/def :portkey.aws.iot.job/status (clojure.spec.alpha/and :portkey.aws.iot/job-status))
(clojure.spec.alpha/def :portkey.aws.iot.job/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job/targets (clojure.spec.alpha/and :portkey.aws.iot/job-targets))
(clojure.spec.alpha/def :portkey.aws.iot.job/job-arn (clojure.spec.alpha/and :portkey.aws.iot/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.job/presigned-url-config (clojure.spec.alpha/and :portkey.aws.iot/presigned-url-config))
(clojure.spec.alpha/def :portkey.aws.iot.job/reason-code (clojure.spec.alpha/and :portkey.aws.iot/reason-code))
(clojure.spec.alpha/def :portkey.aws.iot.job/job-process-details (clojure.spec.alpha/and :portkey.aws.iot/job-process-details))
(clojure.spec.alpha/def :portkey.aws.iot.job/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.job/comment (clojure.spec.alpha/and :portkey.aws.iot/comment))
(clojure.spec.alpha/def :portkey.aws.iot.job/job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot/job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.job/force-canceled (clojure.spec.alpha/and :portkey.aws.iot/forced))
(clojure.spec.alpha/def :portkey.aws.iot.job/description (clojure.spec.alpha/and :portkey.aws.iot/job-description))
(clojure.spec.alpha/def :portkey.aws.iot/job (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job/target-selection :portkey.aws.iot.job/created-at :portkey.aws.iot.job/timeout-config :portkey.aws.iot.job/completed-at :portkey.aws.iot.job/abort-config :portkey.aws.iot.job/status :portkey.aws.iot.job/last-updated-at :portkey.aws.iot.job/targets :portkey.aws.iot.job/job-arn :portkey.aws.iot.job/presigned-url-config :portkey.aws.iot.job/reason-code :portkey.aws.iot.job/job-process-details :portkey.aws.iot.job/job-id :portkey.aws.iot.job/comment :portkey.aws.iot.job/job-executions-rollout-config :portkey.aws.iot.job/force-canceled :portkey.aws.iot.job/description]))

(clojure.spec.alpha/def :portkey.aws.iot/is-default-version clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.auth-info/action-type (clojure.spec.alpha/and :portkey.aws.iot/action-type))
(clojure.spec.alpha/def :portkey.aws.iot.auth-info/resources (clojure.spec.alpha/and :portkey.aws.iot/resources))
(clojure.spec.alpha/def :portkey.aws.iot/auth-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.auth-info/action-type :portkey.aws.iot.auth-info/resources]))

(clojure.spec.alpha/def :portkey.aws.iot/target (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.transfer-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/ge-max-results (clojure.spec.alpha/int-in 1 10000))

(clojure.spec.alpha/def :portkey.aws.iot/rollout-rate-per-minute (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.iot/attach-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/code (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-validity/not-before (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-validity/not-after (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-validity (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.certificate-validity/not-before :portkey.aws.iot.certificate-validity/not-after]))

(clojure.spec.alpha/def :portkey.aws.iot/violation-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/optional-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-request/start-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-request/end-time (clojure.spec.alpha/and :portkey.aws.iot/timestamp))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-request/task-type (clojure.spec.alpha/and :portkey.aws.iot/audit-task-type))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-request/task-status (clojure.spec.alpha/and :portkey.aws.iot/audit-task-status))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-audit-tasks-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-audit-tasks-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-audit-tasks-request/start-time :portkey.aws.iot.list-audit-tasks-request/end-time] :opt-un [:portkey.aws.iot.list-audit-tasks-request/task-type :portkey.aws.iot.list-audit-tasks-request/task-status :portkey.aws.iot.list-audit-tasks-request/next-token :portkey.aws.iot.list-audit-tasks-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/action-type #{"SUBSCRIBE" "PUBLISH" :connect :receive "CONNECT" "RECEIVE" :subscribe :publish})

(clojure.spec.alpha/def :portkey.aws.iot/job-execution-summary-for-thing-list (clojure.spec.alpha/coll-of :portkey.aws.iot/job-execution-summary-for-thing))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.describe-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-billing-group-request/billing-group-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/principal (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/policy-target (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/customer-version (clojure.spec.alpha/and :portkey.aws.iot/customer-version))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/validity (clojure.spec.alpha/and :portkey.aws.iot/certificate-validity))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/owned-by (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/auto-registration-status (clojure.spec.alpha/and :portkey.aws.iot/auto-registration-status))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/generation-id (clojure.spec.alpha/and :portkey.aws.iot/generation-id))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/status (clojure.spec.alpha/and :portkey.aws.iot/ca-certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate-description/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/ca-certificate-description (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.ca-certificate-description/customer-version :portkey.aws.iot.ca-certificate-description/creation-date :portkey.aws.iot.ca-certificate-description/certificate-pem :portkey.aws.iot.ca-certificate-description/validity :portkey.aws.iot.ca-certificate-description/last-modified-date :portkey.aws.iot.ca-certificate-description/owned-by :portkey.aws.iot.ca-certificate-description/auto-registration-status :portkey.aws.iot.ca-certificate-description/generation-id :portkey.aws.iot.ca-certificate-description/status :portkey.aws.iot.ca-certificate-description/certificate-arn :portkey.aws.iot.ca-certificate-description/certificate-id]))

(clojure.spec.alpha/def :portkey.aws.iot/execution-name-prefix (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.update-thing-group-request/thing-group-name (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-group-request/thing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-group-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/update-thing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-thing-group-request/thing-group-name :portkey.aws.iot.update-thing-group-request/thing-group-properties] :opt-un [:portkey.aws.iot.update-thing-group-request/expected-version]))

(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-billing-group-request/billing-group-arn (clojure.spec.alpha/and :portkey.aws.iot/billing-group-arn))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-billing-group-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.add-thing-to-billing-group-request/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot/add-thing-to-billing-group-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.add-thing-to-billing-group-request/billing-group-name :portkey.aws.iot.add-thing-to-billing-group-request/billing-group-arn :portkey.aws.iot.add-thing-to-billing-group-request/thing-name :portkey.aws.iot.add-thing-to-billing-group-request/thing-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/transfer-message (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/reject-reason (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/transfer-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/accept-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/reject-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-data (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.transfer-data/transfer-message :portkey.aws.iot.transfer-data/reject-reason :portkey.aws.iot.transfer-data/transfer-date :portkey.aws.iot.transfer-data/accept-date :portkey.aws.iot.transfer-data/reject-date]))

(clojure.spec.alpha/def :portkey.aws.iot/evaluation-statistic (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"(p0|p0\.1|p0\.01|p1|p10|p50|p90|p99|p99\.9|p99\.99|p100)" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/scheduled-audit-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.start-thing-registration-task-request/template-body (clojure.spec.alpha/and :portkey.aws.iot/template-body))
(clojure.spec.alpha/def :portkey.aws.iot.start-thing-registration-task-request/input-file-bucket (clojure.spec.alpha/and :portkey.aws.iot/registry-s-3-bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.start-thing-registration-task-request/input-file-key (clojure.spec.alpha/and :portkey.aws.iot/registry-s-3-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.start-thing-registration-task-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot/start-thing-registration-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.start-thing-registration-task-request/template-body :portkey.aws.iot.start-thing-registration-task-request/input-file-bucket :portkey.aws.iot.start-thing-registration-task-request/input-file-key :portkey.aws.iot.start-thing-registration-task-request/role-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.registration-code-validation-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/registration-code-validation-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.registration-code-validation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-versions (clojure.spec.alpha/coll-of :portkey.aws.iot/policy-version))

(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-security-profiles-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-security-profiles-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-security-profiles-request/next-token :portkey.aws.iot.list-security-profiles-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/alarm-name (clojure.spec.alpha/and :portkey.aws.iot/alarm-name))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/state-reason (clojure.spec.alpha/and :portkey.aws.iot/state-reason))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/state-value (clojure.spec.alpha/and :portkey.aws.iot/state-value))
(clojure.spec.alpha/def :portkey.aws.iot/cloudwatch-alarm-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.cloudwatch-alarm-action/role-arn :portkey.aws.iot.cloudwatch-alarm-action/alarm-name :portkey.aws.iot.cloudwatch-alarm-action/state-reason :portkey.aws.iot.cloudwatch-alarm-action/state-value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/signing-job-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.test-authorization-response/auth-results (clojure.spec.alpha/and :portkey.aws.iot/auth-results))
(clojure.spec.alpha/def :portkey.aws.iot/test-authorization-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.test-authorization-response/auth-results]))

(clojure.spec.alpha/def :portkey.aws.iot.lambda-action/function-arn (clojure.spec.alpha/and :portkey.aws.iot/function-arn))
(clojure.spec.alpha/def :portkey.aws.iot/lambda-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.lambda-action/function-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-response/jobs (clojure.spec.alpha/and :portkey.aws.iot/job-summary-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-jobs-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-jobs-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-jobs-response/jobs :portkey.aws.iot.list-jobs-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.set-logging-options-request/logging-options-payload (clojure.spec.alpha/and :portkey.aws.iot/logging-options-payload))
(clojure.spec.alpha/def :portkey.aws.iot/set-logging-options-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.set-logging-options-request/logging-options-payload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-request/task-id (clojure.spec.alpha/and :portkey.aws.iot/task-id))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-request/report-type (clojure.spec.alpha/and :portkey.aws.iot/report-type))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-registration-task-reports-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-registration-task-reports-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-thing-registration-task-reports-request/task-id :portkey.aws.iot.list-thing-registration-task-reports-request/report-type] :opt-un [:portkey.aws.iot.list-thing-registration-task-reports-request/next-token :portkey.aws.iot.list-thing-registration-task-reports-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/bucket-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/failed-checks-count clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/certificate-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 64 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 64)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"(0x)?[a-fA-F0-9]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/ota-updates-summary (clojure.spec.alpha/coll-of :portkey.aws.iot/ota-update-summary))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-status #{"CREATE_PENDING" :create-complete "CREATE_FAILED" "CREATE_IN_PROGRESS" :create-failed :create-in-progress "CREATE_COMPLETE" :create-pending})

(clojure.spec.alpha/def :portkey.aws.iot/attach-thing-principal-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-v-2-logging-levels-request/target-type (clojure.spec.alpha/and :portkey.aws.iot/log-target-type))
(clojure.spec.alpha/def :portkey.aws.iot.list-v-2-logging-levels-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-v-2-logging-levels-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/skyfall-max-results))
(clojure.spec.alpha/def :portkey.aws.iot/list-v-2-logging-levels-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-v-2-logging-levels-request/target-type :portkey.aws.iot.list-v-2-logging-levels-request/next-token :portkey.aws.iot.list-v-2-logging-levels-request/max-results]))

(clojure.spec.alpha/def :portkey.aws.iot/related-resources (clojure.spec.alpha/coll-of :portkey.aws.iot/related-resource))

(clojure.spec.alpha/def :portkey.aws.iot/endpoint-address (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/in-progress-things clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/certificate-pem (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 65536))))

(clojure.spec.alpha/def :portkey.aws.iot/file-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.job-summary/job-arn (clojure.spec.alpha/and :portkey.aws.iot/job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/thing-group-id (clojure.spec.alpha/and :portkey.aws.iot/thing-group-id))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/target-selection (clojure.spec.alpha/and :portkey.aws.iot/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/status (clojure.spec.alpha/and :portkey.aws.iot/job-status))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/created-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-summary/completed-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/job-summary (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-summary/job-arn :portkey.aws.iot.job-summary/job-id :portkey.aws.iot.job-summary/thing-group-id :portkey.aws.iot.job-summary/target-selection :portkey.aws.iot.job-summary/status :portkey.aws.iot.job-summary/created-at :portkey.aws.iot.job-summary/last-updated-at :portkey.aws.iot.job-summary/completed-at]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-document/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-document/thing-id (clojure.spec.alpha/and :portkey.aws.iot/thing-id))
(clojure.spec.alpha/def :portkey.aws.iot.thing-document/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-document/thing-group-names (clojure.spec.alpha/and :portkey.aws.iot/thing-group-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.thing-document/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.thing-document/shadow (clojure.spec.alpha/and :portkey.aws.iot/json-document))
(clojure.spec.alpha/def :portkey.aws.iot.thing-document/connectivity (clojure.spec.alpha/and :portkey.aws.iot/thing-connectivity))
(clojure.spec.alpha/def :portkey.aws.iot/thing-document (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.thing-document/thing-name :portkey.aws.iot.thing-document/thing-id :portkey.aws.iot.thing-document/thing-type-name :portkey.aws.iot.thing-document/thing-group-names :portkey.aws.iot.thing-document/attributes :portkey.aws.iot.thing-document/shadow :portkey.aws.iot.thing-document/connectivity]))

(clojure.spec.alpha/def :portkey.aws.iot/ota-update-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 128)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-request/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-type-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-thing-type-request/thing-type-name] :opt-un [:portkey.aws.iot.create-thing-type-request/thing-type-properties :portkey.aws.iot.create-thing-type-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.action/dynamo-db (clojure.spec.alpha/and :portkey.aws.iot/dynamo-db-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/sns (clojure.spec.alpha/and :portkey.aws.iot/sns-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/cloudwatch-alarm (clojure.spec.alpha/and :portkey.aws.iot/cloudwatch-alarm-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/iot-analytics (clojure.spec.alpha/and :portkey.aws.iot/iot-analytics-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/republish (clojure.spec.alpha/and :portkey.aws.iot/republish-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/kinesis (clojure.spec.alpha/and :portkey.aws.iot/kinesis-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/s-3 (clojure.spec.alpha/and :portkey.aws.iot/s-3-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/salesforce (clojure.spec.alpha/and :portkey.aws.iot/salesforce-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/sqs (clojure.spec.alpha/and :portkey.aws.iot/sqs-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/elasticsearch (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/cloudwatch-metric (clojure.spec.alpha/and :portkey.aws.iot/cloudwatch-metric-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/firehose (clojure.spec.alpha/and :portkey.aws.iot/firehose-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/dynamo-d-bv-2 (clojure.spec.alpha/and :portkey.aws.iot/dynamo-d-bv-2-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/lambda (clojure.spec.alpha/and :portkey.aws.iot/lambda-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/step-functions (clojure.spec.alpha/and :portkey.aws.iot/step-functions-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/iot-events (clojure.spec.alpha/and :portkey.aws.iot/iot-events-action))
(clojure.spec.alpha/def :portkey.aws.iot/action (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.action/dynamo-db :portkey.aws.iot.action/sns :portkey.aws.iot.action/cloudwatch-alarm :portkey.aws.iot.action/iot-analytics :portkey.aws.iot.action/republish :portkey.aws.iot.action/kinesis :portkey.aws.iot.action/s-3 :portkey.aws.iot.action/salesforce :portkey.aws.iot.action/sqs :portkey.aws.iot.action/elasticsearch :portkey.aws.iot.action/cloudwatch-metric :portkey.aws.iot.action/firehose :portkey.aws.iot.action/dynamo-d-bv-2 :portkey.aws.iot.action/lambda :portkey.aws.iot.action/step-functions :portkey.aws.iot.action/iot-events]))

(clojure.spec.alpha/def :portkey.aws.iot/configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot/enabled]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-type-definition))

(clojure.spec.alpha/def :portkey.aws.iot.create-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-topic-rule-request/topic-rule-payload (clojure.spec.alpha/and :portkey.aws.iot/topic-rule-payload))
(clojure.spec.alpha/def :portkey.aws.iot.create-topic-rule-request/tags (clojure.spec.alpha/and :portkey.aws.iot/string))
(clojure.spec.alpha/def :portkey.aws.iot/create-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-topic-rule-request/rule-name :portkey.aws.iot.create-topic-rule-request/topic-rule-payload] :opt-un [:portkey.aws.iot.create-topic-rule-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.update-dynamic-thing-group-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot/update-dynamic-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-dynamic-thing-group-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot/created-at-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary-for-thing/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution-summary-for-thing/job-execution-summary (clojure.spec.alpha/and :portkey.aws.iot/job-execution-summary))
(clojure.spec.alpha/def :portkey.aws.iot/job-execution-summary-for-thing (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-execution-summary-for-thing/job-id :portkey.aws.iot.job-execution-summary-for-thing/job-execution-summary]))

(clojure.spec.alpha/def :portkey.aws.iot/token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 6144))))

(clojure.spec.alpha/def :portkey.aws.iot.certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate/status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.certificate/certificate-arn :portkey.aws.iot.certificate/certificate-id :portkey.aws.iot.certificate/status :portkey.aws.iot.certificate/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot/increment-factor clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.iot/untag-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-job-execution-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.delete-job-execution-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-job-execution-request/execution-number (clojure.spec.alpha/and :portkey.aws.iot/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot.delete-job-execution-request/force (clojure.spec.alpha/and :portkey.aws.iot/force-flag))
(clojure.spec.alpha/def :portkey.aws.iot/delete-job-execution-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-job-execution-request/job-id :portkey.aws.iot.delete-job-execution-request/thing-name :portkey.aws.iot.delete-job-execution-request/execution-number] :opt-un [:portkey.aws.iot.delete-job-execution-request/force]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-stream-response/stream-info (clojure.spec.alpha/and :portkey.aws.iot/stream-info))
(clojure.spec.alpha/def :portkey.aws.iot/describe-stream-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-stream-response/stream-info]))

(clojure.spec.alpha/def :portkey.aws.iot.update-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot.update-role-alias-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.update-role-alias-request/credential-duration-seconds (clojure.spec.alpha/and :portkey.aws.iot/credential-duration-seconds))
(clojure.spec.alpha/def :portkey.aws.iot/update-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-role-alias-request/role-alias] :opt-un [:portkey.aws.iot.update-role-alias-request/role-arn :portkey.aws.iot.update-role-alias-request/credential-duration-seconds]))

(clojure.spec.alpha/def :portkey.aws.iot/job-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 2028)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[^\p{C}]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/is-default-version (clojure.spec.alpha/and :portkey.aws.iot/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-version-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-policy-version-response/policy-arn :portkey.aws.iot.create-policy-version-response/policy-document :portkey.aws.iot.create-policy-version-response/policy-version-id :portkey.aws.iot.create-policy-version-response/is-default-version]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-authorizer-request/authorizer-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/state-reason (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/aws-iot-job-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-response/security-profile-name (clojure.spec.alpha/and :portkey.aws.iot/security-profile-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-security-profile-response/security-profile-arn (clojure.spec.alpha/and :portkey.aws.iot/security-profile-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-security-profile-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-security-profile-response/security-profile-name :portkey.aws.iot.create-security-profile-response/security-profile-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/approximate-seconds-before-timed-out clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-endpoint (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"https?://.*" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/aws-job-executions-rollout-config (clojure.spec.alpha/and :portkey.aws.iot/aws-job-executions-rollout-config))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/target-selection (clojure.spec.alpha/and :portkey.aws.iot/target-selection))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/ota-update-id (clojure.spec.alpha/and :portkey.aws.iot/ota-update-id))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/ota-update-status (clojure.spec.alpha/and :portkey.aws.iot/ota-update-status))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/ota-update-files (clojure.spec.alpha/and :portkey.aws.iot/ota-update-files))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/error-info (clojure.spec.alpha/and :portkey.aws.iot/error-info))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/ota-update-arn (clojure.spec.alpha/and :portkey.aws.iot/ota-update-arn))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/targets (clojure.spec.alpha/and :portkey.aws.iot/targets))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/aws-iot-job-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-job-arn))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/aws-iot-job-id (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-job-id))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/description (clojure.spec.alpha/and :portkey.aws.iot/ota-update-description))
(clojure.spec.alpha/def :portkey.aws.iot.ota-update-info/additional-parameters (clojure.spec.alpha/and :portkey.aws.iot/additional-parameter-map))
(clojure.spec.alpha/def :portkey.aws.iot/ota-update-info (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.ota-update-info/creation-date :portkey.aws.iot.ota-update-info/aws-job-executions-rollout-config :portkey.aws.iot.ota-update-info/target-selection :portkey.aws.iot.ota-update-info/ota-update-id :portkey.aws.iot.ota-update-info/ota-update-status :portkey.aws.iot.ota-update-info/ota-update-files :portkey.aws.iot.ota-update-info/error-info :portkey.aws.iot.ota-update-info/last-modified-date :portkey.aws.iot.ota-update-info/ota-update-arn :portkey.aws.iot.ota-update-info/targets :portkey.aws.iot.ota-update-info/aws-iot-job-arn :portkey.aws.iot.ota-update-info/aws-iot-job-id :portkey.aws.iot.ota-update-info/description :portkey.aws.iot.ota-update-info/additional-parameters]))

(clojure.spec.alpha/def :portkey.aws.iot/signing-profile-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.effective-policy/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.effective-policy/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.effective-policy/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot/effective-policy (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.effective-policy/policy-name :portkey.aws.iot.effective-policy/policy-arn :portkey.aws.iot.effective-policy/policy-document]))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/attribute-name (clojure.spec.alpha/and :portkey.aws.iot/attribute-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/attribute-value (clojure.spec.alpha/and :portkey.aws.iot/attribute-value))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-things-request/next-token :portkey.aws.iot.list-things-request/max-results :portkey.aws.iot.list-things-request/attribute-name :portkey.aws.iot.list-things-request/attribute-value :portkey.aws.iot.list-things-request/thing-type-name]))

(clojure.spec.alpha/def :portkey.aws.iot/details-map (clojure.spec.alpha/map-of :portkey.aws.iot/details-key :portkey.aws.iot/details-value))

(clojure.spec.alpha/def :portkey.aws.iot.describe-endpoint-response/endpoint-address (clojure.spec.alpha/and :portkey.aws.iot/endpoint-address))
(clojure.spec.alpha/def :portkey.aws.iot/describe-endpoint-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.describe-endpoint-response/endpoint-address]))

(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-request/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-request/authorizer-function-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-function-arn))
(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-request/token-key-name (clojure.spec.alpha/and :portkey.aws.iot/token-key-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-request/token-signing-public-keys (clojure.spec.alpha/and :portkey.aws.iot/public-key-map))
(clojure.spec.alpha/def :portkey.aws.iot.update-authorizer-request/status (clojure.spec.alpha/and :portkey.aws.iot/authorizer-status))
(clojure.spec.alpha/def :portkey.aws.iot/update-authorizer-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-authorizer-request/authorizer-name] :opt-un [:portkey.aws.iot.update-authorizer-request/authorizer-function-arn :portkey.aws.iot.update-authorizer-request/token-key-name :portkey.aws.iot.update-authorizer-request/token-signing-public-keys :portkey.aws.iot.update-authorizer-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-registration-task-request/task-id (clojure.spec.alpha/and :portkey.aws.iot/task-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-registration-task-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.describe-thing-registration-task-request/task-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/consecutive-datapoints-to-clear (clojure.spec.alpha/int-in 1 10))

(clojure.spec.alpha/def :portkey.aws.iot/force-delete clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/get-indexing-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/recursive clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.audit-check-configuration/enabled (clojure.spec.alpha/and :portkey.aws.iot/enabled))
(clojure.spec.alpha/def :portkey.aws.iot/audit-check-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.audit-check-configuration/enabled]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-group-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/audit-task-status #{"COMPLETED" "CANCELED" "IN_PROGRESS" :in-progress :completed :canceled "FAILED" :failed})

(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-thing-request/status (clojure.spec.alpha/and :portkey.aws.iot/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-thing-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/laser-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-job-executions-for-thing-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-job-executions-for-thing-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.list-job-executions-for-thing-request/thing-name] :opt-un [:portkey.aws.iot.list-job-executions-for-thing-request/status :portkey.aws.iot.list-job-executions-for-thing-request/max-results :portkey.aws.iot.list-job-executions-for-thing-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.replace-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.replace-topic-rule-request/topic-rule-payload (clojure.spec.alpha/and :portkey.aws.iot/topic-rule-payload))
(clojure.spec.alpha/def :portkey.aws.iot/replace-topic-rule-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.replace-topic-rule-request/rule-name :portkey.aws.iot.replace-topic-rule-request/topic-rule-payload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.s-3-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.s-3-action/bucket-name (clojure.spec.alpha/and :portkey.aws.iot/bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.s-3-action/key (clojure.spec.alpha/and :portkey.aws.iot/key))
(clojure.spec.alpha/def :portkey.aws.iot.s-3-action/canned-acl (clojure.spec.alpha/and :portkey.aws.iot/canned-access-control-list))
(clojure.spec.alpha/def :portkey.aws.iot/s-3-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.s-3-action/role-arn :portkey.aws.iot.s-3-action/bucket-name :portkey.aws.iot.s-3-action/key] :opt-un [:portkey.aws.iot.s-3-action/canned-acl]))

(clojure.spec.alpha/def :portkey.aws.iot.job-execution/queued-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/started-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/approximate-seconds-before-timed-out (clojure.spec.alpha/and :portkey.aws.iot/approximate-seconds-before-timed-out))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/status-details (clojure.spec.alpha/and :portkey.aws.iot/job-execution-status-details))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/execution-number (clojure.spec.alpha/and :portkey.aws.iot/execution-number))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/status (clojure.spec.alpha/and :portkey.aws.iot/job-execution-status))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/last-updated-at (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/version-number (clojure.spec.alpha/and :portkey.aws.iot/version-number))
(clojure.spec.alpha/def :portkey.aws.iot.job-execution/force-canceled (clojure.spec.alpha/and :portkey.aws.iot/forced))
(clojure.spec.alpha/def :portkey.aws.iot/job-execution (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.job-execution/queued-at :portkey.aws.iot.job-execution/started-at :portkey.aws.iot.job-execution/approximate-seconds-before-timed-out :portkey.aws.iot.job-execution/status-details :portkey.aws.iot.job-execution/execution-number :portkey.aws.iot.job-execution/status :portkey.aws.iot.job-execution/last-updated-at :portkey.aws.iot.job-execution/thing-arn :portkey.aws.iot.job-execution/job-id :portkey.aws.iot.job-execution/version-number :portkey.aws.iot.job-execution/force-canceled]))

(clojure.spec.alpha/def :portkey.aws.iot.iot-analytics-action/channel-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.iot-analytics-action/channel-name (clojure.spec.alpha/and :portkey.aws.iot/channel-name))
(clojure.spec.alpha/def :portkey.aws.iot.iot-analytics-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot/iot-analytics-action (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.iot-analytics-action/channel-arn :portkey.aws.iot.iot-analytics-action/channel-name :portkey.aws.iot.iot-analytics-action/role-arn]))

(clojure.spec.alpha/def :portkey.aws.iot.untag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.iot/resource-arn))
(clojure.spec.alpha/def :portkey.aws.iot.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.iot/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.iot/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.untag-resource-request/resource-arn :portkey.aws.iot.untag-resource-request/tag-keys] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.security-profile-target-mapping/security-profile-identifier (clojure.spec.alpha/and :portkey.aws.iot/security-profile-identifier))
(clojure.spec.alpha/def :portkey.aws.iot.security-profile-target-mapping/target (clojure.spec.alpha/and :portkey.aws.iot/security-profile-target))
(clojure.spec.alpha/def :portkey.aws.iot/security-profile-target-mapping (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.security-profile-target-mapping/security-profile-identifier :portkey.aws.iot.security-profile-target-mapping/target]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-account-audit-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.set-default-authorizer-response/authorizer-name (clojure.spec.alpha/and :portkey.aws.iot/authorizer-name))
(clojure.spec.alpha/def :portkey.aws.iot.set-default-authorizer-response/authorizer-arn (clojure.spec.alpha/and :portkey.aws.iot/authorizer-arn))
(clojure.spec.alpha/def :portkey.aws.iot/set-default-authorizer-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.set-default-authorizer-response/authorizer-name :portkey.aws.iot.set-default-authorizer-response/authorizer-arn]))

(clojure.spec.alpha/def :portkey.aws.iot/get-registration-code-request (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.update-account-audit-configuration-request/role-arn (clojure.spec.alpha/and :portkey.aws.iot/role-arn))
(clojure.spec.alpha/def :portkey.aws.iot.update-account-audit-configuration-request/audit-notification-target-configurations (clojure.spec.alpha/and :portkey.aws.iot/audit-notification-target-configurations))
(clojure.spec.alpha/def :portkey.aws.iot.update-account-audit-configuration-request/audit-check-configurations (clojure.spec.alpha/and :portkey.aws.iot/audit-check-configurations))
(clojure.spec.alpha/def :portkey.aws.iot/update-account-audit-configuration-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.update-account-audit-configuration-request/role-arn :portkey.aws.iot.update-account-audit-configuration-request/audit-notification-target-configurations :portkey.aws.iot.update-account-audit-configuration-request/audit-check-configurations]))

(clojure.spec.alpha/def :portkey.aws.iot/generation-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-billing-groups-response/billing-groups (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name-and-arn-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-billing-groups-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-billing-groups-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-billing-groups-response/billing-groups :portkey.aws.iot.list-billing-groups-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.kinesis-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.kinesis-action/stream-name (clojure.spec.alpha/and :portkey.aws.iot/stream-name))
(clojure.spec.alpha/def :portkey.aws.iot.kinesis-action/partition-key (clojure.spec.alpha/and :portkey.aws.iot/partition-key))
(clojure.spec.alpha/def :portkey.aws.iot/kinesis-action (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.kinesis-action/role-arn :portkey.aws.iot.kinesis-action/stream-name] :opt-un [:portkey.aws.iot.kinesis-action/partition-key]))

(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate/status (clojure.spec.alpha/and :portkey.aws.iot/ca-certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.ca-certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/ca-certificate (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.ca-certificate/certificate-arn :portkey.aws.iot.ca-certificate/certificate-id :portkey.aws.iot.ca-certificate/status :portkey.aws.iot.ca-certificate/creation-date]))

(clojure.spec.alpha/def :portkey.aws.iot/query-max-results (clojure.spec.alpha/int-in 1 500))

(clojure.spec.alpha/def :portkey.aws.iot/update-indexing-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/public-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot/job-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/valid clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.list-things-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-attribute-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-things-response/things :portkey.aws.iot.list-things-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-request/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-request/set-as-default (clojure.spec.alpha/and :portkey.aws.iot/set-as-default))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-policy-version-request/policy-name :portkey.aws.iot.create-policy-version-request/policy-document] :opt-un [:portkey.aws.iot.create-policy-version-request/set-as-default]))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-response/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-response/thing-type-id (clojure.spec.alpha/and :portkey.aws.iot/thing-type-id))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-type-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.create-thing-type-response/thing-type-name :portkey.aws.iot.create-thing-type-response/thing-type-arn :portkey.aws.iot.create-thing-type-response/thing-type-id]))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-conflict-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.certificate-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-response/outgoing-certificates (clojure.spec.alpha/and :portkey.aws.iot/outgoing-certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-outgoing-certificates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-outgoing-certificates-response/outgoing-certificates :portkey.aws.iot.list-outgoing-certificates-response/next-marker]))

(clojure.spec.alpha/def :portkey.aws.iot/audit-task-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 40)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9\-]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/thing-group-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-group-name))

(clojure.spec.alpha/def :portkey.aws.iot/payload-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/authorizer-function-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/rule-arn (clojure.spec.alpha/and :portkey.aws.iot/rule-arn))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/topic-pattern (clojure.spec.alpha/and :portkey.aws.iot/topic-pattern))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/created-at (clojure.spec.alpha/and :portkey.aws.iot/created-at-date))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot/topic-rule-list-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.topic-rule-list-item/rule-arn :portkey.aws.iot.topic-rule-list-item/rule-name :portkey.aws.iot.topic-rule-list-item/topic-pattern :portkey.aws.iot.topic-rule-list-item/created-at :portkey.aws.iot.topic-rule-list-item/rule-disabled]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-role-alias-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/is-authenticated clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/firehose-separator (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"([\n\t])|(\r\n)|(,)" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.delete-role-alias-request/role-alias (clojure.spec.alpha/and :portkey.aws.iot/role-alias))
(clojure.spec.alpha/def :portkey.aws.iot/delete-role-alias-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.delete-role-alias-request/role-alias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/seconds clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/delete-ota-update-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.auth-result/auth-info (clojure.spec.alpha/and :portkey.aws.iot/auth-info))
(clojure.spec.alpha/def :portkey.aws.iot.auth-result/allowed (clojure.spec.alpha/and :portkey.aws.iot/allowed))
(clojure.spec.alpha/def :portkey.aws.iot.auth-result/denied (clojure.spec.alpha/and :portkey.aws.iot/denied))
(clojure.spec.alpha/def :portkey.aws.iot.auth-result/auth-decision (clojure.spec.alpha/and :portkey.aws.iot/auth-decision))
(clojure.spec.alpha/def :portkey.aws.iot.auth-result/missing-context-values (clojure.spec.alpha/and :portkey.aws.iot/missing-context-values))
(clojure.spec.alpha/def :portkey.aws.iot/auth-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.auth-result/auth-info :portkey.aws.iot.auth-result/allowed :portkey.aws.iot.auth-result/denied :portkey.aws.iot.auth-result/auth-decision :portkey.aws.iot.auth-result/missing-context-values]))

(clojure.spec.alpha/def :portkey.aws.iot.associate-targets-with-job-request/targets (clojure.spec.alpha/and :portkey.aws.iot/job-targets))
(clojure.spec.alpha/def :portkey.aws.iot.associate-targets-with-job-request/job-id (clojure.spec.alpha/and :portkey.aws.iot/job-id))
(clojure.spec.alpha/def :portkey.aws.iot.associate-targets-with-job-request/comment (clojure.spec.alpha/and :portkey.aws.iot/comment))
(clojure.spec.alpha/def :portkey.aws.iot/associate-targets-with-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.associate-targets-with-job-request/targets :portkey.aws.iot.associate-targets-with-job-request/job-id] :opt-un [:portkey.aws.iot.associate-targets-with-job-request/comment]))

(clojure.spec.alpha/def :portkey.aws.iot.create-billing-group-request/billing-group-name (clojure.spec.alpha/and :portkey.aws.iot/billing-group-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-billing-group-request/billing-group-properties (clojure.spec.alpha/and :portkey.aws.iot/billing-group-properties))
(clojure.spec.alpha/def :portkey.aws.iot.create-billing-group-request/tags (clojure.spec.alpha/and :portkey.aws.iot/tag-list))
(clojure.spec.alpha/def :portkey.aws.iot/create-billing-group-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.create-billing-group-request/billing-group-name] :opt-un [:portkey.aws.iot.create-billing-group-request/billing-group-properties :portkey.aws.iot.create-billing-group-request/tags]))

(clojure.spec.alpha/def :portkey.aws.iot.register-thing-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-thing-response/resource-arns (clojure.spec.alpha/and :portkey.aws.iot/resource-arns))
(clojure.spec.alpha/def :portkey.aws.iot/register-thing-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.register-thing-response/certificate-pem :portkey.aws.iot.register-thing-response/resource-arns]))

(clojure.spec.alpha/def :portkey.aws.iot.get-effective-policies-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot.get-effective-policies-request/cognito-identity-pool-id (clojure.spec.alpha/and :portkey.aws.iot/cognito-identity-pool-id))
(clojure.spec.alpha/def :portkey.aws.iot.get-effective-policies-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot/get-effective-policies-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.get-effective-policies-request/principal :portkey.aws.iot.get-effective-policies-request/cognito-identity-pool-id :portkey.aws.iot.get-effective-policies-request/thing-name]))

(clojure.spec.alpha/def :portkey.aws.iot/update-account-audit-configuration-response (clojure.spec.alpha/keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-ota-updates-response/ota-updates (clojure.spec.alpha/and :portkey.aws.iot/ota-updates-summary))
(clojure.spec.alpha/def :portkey.aws.iot.list-ota-updates-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-ota-updates-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.list-ota-updates-response/ota-updates :portkey.aws.iot.list-ota-updates-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.iot/principals (clojure.spec.alpha/coll-of :portkey.aws.iot/principal-arn))

(clojure.spec.alpha/def :portkey.aws.iot/validation-errors (clojure.spec.alpha/coll-of :portkey.aws.iot/validation-error))

(clojure.spec.alpha/def :portkey.aws.iot/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/sql (clojure.spec.alpha/and :portkey.aws.iot/sql))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/description (clojure.spec.alpha/and :portkey.aws.iot/description))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/created-at (clojure.spec.alpha/and :portkey.aws.iot/created-at-date))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/actions (clojure.spec.alpha/and :portkey.aws.iot/action-list))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/aws-iot-sql-version (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-sql-version))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/error-action (clojure.spec.alpha/and :portkey.aws.iot/action))
(clojure.spec.alpha/def :portkey.aws.iot/topic-rule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.iot.topic-rule/rule-name :portkey.aws.iot.topic-rule/sql :portkey.aws.iot.topic-rule/description :portkey.aws.iot.topic-rule/created-at :portkey.aws.iot.topic-rule/actions :portkey.aws.iot.topic-rule/rule-disabled :portkey.aws.iot.topic-rule/aws-iot-sql-version :portkey.aws.iot.topic-rule/error-action]))

(clojure.spec.alpha/def :portkey.aws.iot/registration-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 64 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 64)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"(0x)?[a-fA-F0-9]+" s__1012854__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.update-scheduled-audit-request/frequency (clojure.spec.alpha/and :portkey.aws.iot/audit-frequency))
(clojure.spec.alpha/def :portkey.aws.iot.update-scheduled-audit-request/day-of-month (clojure.spec.alpha/and :portkey.aws.iot/day-of-month))
(clojure.spec.alpha/def :portkey.aws.iot.update-scheduled-audit-request/day-of-week (clojure.spec.alpha/and :portkey.aws.iot/day-of-week))
(clojure.spec.alpha/def :portkey.aws.iot.update-scheduled-audit-request/target-check-names (clojure.spec.alpha/and :portkey.aws.iot/target-audit-check-names))
(clojure.spec.alpha/def :portkey.aws.iot.update-scheduled-audit-request/scheduled-audit-name (clojure.spec.alpha/and :portkey.aws.iot/scheduled-audit-name))
(clojure.spec.alpha/def :portkey.aws.iot/update-scheduled-audit-request (clojure.spec.alpha/keys :req-un [:portkey.aws.iot.update-scheduled-audit-request/scheduled-audit-name] :opt-un [:portkey.aws.iot.update-scheduled-audit-request/frequency :portkey.aws.iot.update-scheduled-audit-request/day-of-month :portkey.aws.iot.update-scheduled-audit-request/day-of-week :portkey.aws.iot.update-scheduled-audit-request/target-check-names]))

(clojure.spec.alpha/def :portkey.aws.iot/job-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__1012852__auto__] (clojure.core/<= 1 (clojure.core/count s__1012852__auto__))) (clojure.core/fn [s__1012853__auto__] (clojure.core/< (clojure.core/count s__1012853__auto__) 64)) (clojure.core/fn [s__1012854__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_-]+" s__1012854__auto__))))

(clojure.core/defn describe-audit-task ([describe-audit-task-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-audit-task-request describe-audit-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-audit-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks/{taskId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-audit-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAuditTask", :http.request.configuration/output-deser-fn response-describe-audit-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-audit-task :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-audit-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-audit-task-response))

(clojure.core/defn tag-resource ([tag-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/tag-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/tag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn response-tag-resource-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.iot/tag-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/tag-resource-response))

(clojure.core/defn update-role-alias ([update-role-alias-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-role-alias-request update-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateRoleAlias", :http.request.configuration/output-deser-fn response-update-role-alias-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-role-alias-response))

(clojure.core/defn delete-billing-group ([delete-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-billing-group-request delete-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBillingGroup", :http.request.configuration/output-deser-fn response-delete-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-billing-group-response))

(clojure.core/defn get-ota-update ([get-ota-update-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-ota-update-request get-ota-update-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-ota-update-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates/{otaUpdateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-ota-update-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetOTAUpdate", :http.request.configuration/output-deser-fn response-get-ota-update-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef get-ota-update :args (clojure.spec.alpha/tuple :portkey.aws.iot/get-ota-update-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-ota-update-response))

(clojure.core/defn list-indices ([] (list-indices {})) ([list-indices-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-indices-request list-indices-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-indices-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indices", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-indices-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListIndices", :http.request.configuration/output-deser-fn response-list-indices-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-indices :args (clojure.spec.alpha/? :portkey.aws.iot/list-indices-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-indices-response))

(clojure.core/defn list-policy-versions ([list-policy-versions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-policy-versions-request list-policy-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-policy-versions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-policy-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPolicyVersions", :http.request.configuration/output-deser-fn response-list-policy-versions-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-policy-versions :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-policy-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-policy-versions-response))

(clojure.core/defn delete-policy-version ([delete-policy-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-policy-version-request delete-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version/{policyVersionId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePolicyVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-policy-version-request) :ret clojure.core/true?)

(clojure.core/defn create-role-alias ([create-role-alias-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-role-alias-request create-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateRoleAlias", :http.request.configuration/output-deser-fn response-create-role-alias-response, :http.request.spec/error-spec {"ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-role-alias-response))

(clojure.core/defn update-authorizer ([update-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-authorizer-request update-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAuthorizer", :http.request.configuration/output-deser-fn response-update-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-authorizer-response))

(clojure.core/defn attach-principal-policy ([attach-principal-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-attach-principal-policy-request attach-principal-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principal-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/attach-principal-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachPrincipalPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef attach-principal-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/attach-principal-policy-request) :ret clojure.core/true?)

(clojure.core/defn list-authorizers ([] (list-authorizers {})) ([list-authorizers-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-authorizers-request list-authorizers-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-authorizers-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizers/", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-authorizers-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAuthorizers", :http.request.configuration/output-deser-fn response-list-authorizers-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-authorizers :args (clojure.spec.alpha/? :portkey.aws.iot/list-authorizers-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-authorizers-response))

(clojure.core/defn detach-policy ([detach-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-detach-policy-request detach-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/target-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/detach-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef detach-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/detach-policy-request) :ret clojure.core/true?)

(clojure.core/defn search-index ([search-index-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-search-index-request search-index-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/search-index-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indices/search", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/search-index-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SearchIndex", :http.request.configuration/output-deser-fn response-search-index-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidQueryException" :portkey.aws.iot/invalid-query-exception, "IndexNotReadyException" :portkey.aws.iot/index-not-ready-exception}})))))
(clojure.spec.alpha/fdef search-index :args (clojure.spec.alpha/tuple :portkey.aws.iot/search-index-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/search-index-response))

(clojure.core/defn delete-job-execution ([delete-job-execution-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-job-execution-request delete-job-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-job-execution-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteJobExecution", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InvalidStateTransitionException" :portkey.aws.iot/invalid-state-transition-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-job-execution :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-job-execution-request) :ret clojure.core/true?)

(clojure.core/defn list-certificates-by-ca ([list-certificates-by-ca-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-certificates-by-ca-request list-certificates-by-ca-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-certificates-by-ca-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates-by-ca/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-certificates-by-ca-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCertificatesByCA", :http.request.configuration/output-deser-fn response-list-certificates-by-ca-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-certificates-by-ca :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-certificates-by-ca-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-certificates-by-ca-response))

(clojure.core/defn delete-stream ([delete-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-stream-request delete-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteStream", :http.request.configuration/output-deser-fn response-delete-stream-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-stream-response))

(clojure.core/defn get-policy-version ([get-policy-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-policy-version-request get-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-policy-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version/{policyVersionId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPolicyVersion", :http.request.configuration/output-deser-fn response-get-policy-version-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef get-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot/get-policy-version-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-policy-version-response))

(clojure.core/defn cancel-certificate-transfer ([cancel-certificate-transfer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-cancel-certificate-transfer-request cancel-certificate-transfer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cancel-certificate-transfer/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/cancel-certificate-transfer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelCertificateTransfer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef cancel-certificate-transfer :args (clojure.spec.alpha/tuple :portkey.aws.iot/cancel-certificate-transfer-request) :ret clojure.core/true?)

(clojure.core/defn get-job-document ([get-job-document-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-job-document-request get-job-document-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-job-document-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/job-document", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-job-document-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetJobDocument", :http.request.configuration/output-deser-fn response-get-job-document-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-job-document :args (clojure.spec.alpha/tuple :portkey.aws.iot/get-job-document-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-job-document-response))

(clojure.core/defn set-v-2-logging-options ([] (set-v-2-logging-options {})) ([set-v-2-logging-options-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-set-v-2-logging-options-request set-v-2-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/set-v-2-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetV2LoggingOptions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef set-v-2-logging-options :args (clojure.spec.alpha/? :portkey.aws.iot/set-v-2-logging-options-request) :ret clojure.core/true?)

(clojure.core/defn update-indexing-configuration ([] (update-indexing-configuration {})) ([update-indexing-configuration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-indexing-configuration-request update-indexing-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-indexing-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indexing/config", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-indexing-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateIndexingConfiguration", :http.request.configuration/output-deser-fn response-update-indexing-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-indexing-configuration :args (clojure.spec.alpha/? :portkey.aws.iot/update-indexing-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-indexing-configuration-response))

(clojure.core/defn create-authorizer ([create-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-authorizer-request create-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateAuthorizer", :http.request.configuration/output-deser-fn response-create-authorizer-response, :http.request.spec/error-spec {"ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-authorizer-response))

(clojure.core/defn list-scheduled-audits ([] (list-scheduled-audits {})) ([list-scheduled-audits-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-scheduled-audits-request list-scheduled-audits-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-scheduled-audits-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-scheduled-audits-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListScheduledAudits", :http.request.configuration/output-deser-fn response-list-scheduled-audits-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-scheduled-audits :args (clojure.spec.alpha/? :portkey.aws.iot/list-scheduled-audits-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-scheduled-audits-response))

(clojure.core/defn list-ca-certificates ([] (list-ca-certificates {})) ([list-ca-certificates-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-ca-certificates-request list-ca-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-ca-certificates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-ca-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCACertificates", :http.request.configuration/output-deser-fn response-list-ca-certificates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-ca-certificates :args (clojure.spec.alpha/? :portkey.aws.iot/list-ca-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-ca-certificates-response))

(clojure.core/defn create-ota-update ([create-ota-update-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-ota-update-request create-ota-update-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-ota-update-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates/{otaUpdateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-ota-update-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateOTAUpdate", :http.request.configuration/output-deser-fn response-create-ota-update-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-ota-update :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-ota-update-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-ota-update-response))

(clojure.core/defn list-violation-events ([list-violation-events-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-violation-events-request list-violation-events-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-violation-events-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/violation-events", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-violation-events-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListViolationEvents", :http.request.configuration/output-deser-fn response-list-violation-events-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-violation-events :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-violation-events-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-violation-events-response))

(clojure.core/defn list-v-2-logging-levels ([] (list-v-2-logging-levels {})) ([list-v-2-logging-levels-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-v-2-logging-levels-request list-v-2-logging-levels-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-v-2-logging-levels-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingLevel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-v-2-logging-levels-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListV2LoggingLevels", :http.request.configuration/output-deser-fn response-list-v-2-logging-levels-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "NotConfiguredException" :portkey.aws.iot/not-configured-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-v-2-logging-levels :args (clojure.spec.alpha/? :portkey.aws.iot/list-v-2-logging-levels-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-v-2-logging-levels-response))

(clojure.core/defn list-security-profiles ([] (list-security-profiles {})) ([list-security-profiles-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-security-profiles-request list-security-profiles-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-security-profiles-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-security-profiles-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListSecurityProfiles", :http.request.configuration/output-deser-fn response-list-security-profiles-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-security-profiles :args (clojure.spec.alpha/? :portkey.aws.iot/list-security-profiles-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-security-profiles-response))

(clojure.core/defn create-thing ([create-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-thing-request create-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateThing", :http.request.configuration/output-deser-fn response-create-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef create-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-thing-response))

(clojure.core/defn delete-account-audit-configuration ([] (delete-account-audit-configuration {})) ([delete-account-audit-configuration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-account-audit-configuration-request delete-account-audit-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-account-audit-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/configuration", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-account-audit-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAccountAuditConfiguration", :http.request.configuration/output-deser-fn response-delete-account-audit-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-account-audit-configuration :args (clojure.spec.alpha/? :portkey.aws.iot/delete-account-audit-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-account-audit-configuration-response))

(clojure.core/defn delete-scheduled-audit ([delete-scheduled-audit-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-scheduled-audit-request delete-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteScheduledAudit", :http.request.configuration/output-deser-fn response-delete-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-scheduled-audit-response))

(clojure.core/defn update-event-configurations ([] (update-event-configurations {})) ([update-event-configurations-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-event-configurations-request update-event-configurations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-event-configurations-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/event-configurations", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-event-configurations-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateEventConfigurations", :http.request.configuration/output-deser-fn response-update-event-configurations-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef update-event-configurations :args (clojure.spec.alpha/? :portkey.aws.iot/update-event-configurations-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-event-configurations-response))

(clojure.core/defn create-topic-rule ([create-topic-rule-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-topic-rule-request create-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"SqlParseException" :portkey.aws.iot/sql-parse-exception, "InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "ConflictingResourceUpdateException" :portkey.aws.iot/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef create-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn update-billing-group ([update-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-billing-group-request update-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateBillingGroup", :http.request.configuration/output-deser-fn response-update-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-billing-group-response))

(clojure.core/defn accept-certificate-transfer ([accept-certificate-transfer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-accept-certificate-transfer-request accept-certificate-transfer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/accept-certificate-transfer/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/accept-certificate-transfer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AcceptCertificateTransfer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef accept-certificate-transfer :args (clojure.spec.alpha/tuple :portkey.aws.iot/accept-certificate-transfer-request) :ret clojure.core/true?)

(clojure.core/defn get-registration-code ([] (get-registration-code {})) ([get-registration-code-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-registration-code-request get-registration-code-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-registration-code-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/registrationcode", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-registration-code-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetRegistrationCode", :http.request.configuration/output-deser-fn response-get-registration-code-response, :http.request.spec/error-spec {"ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception}})))))
(clojure.spec.alpha/fdef get-registration-code :args (clojure.spec.alpha/? :portkey.aws.iot/get-registration-code-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-registration-code-response))

(clojure.core/defn list-policies ([] (list-policies {})) ([list-policies-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-policies-request list-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPolicies", :http.request.configuration/output-deser-fn response-list-policies-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-policies :args (clojure.spec.alpha/? :portkey.aws.iot/list-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-policies-response))

(clojure.core/defn list-thing-registration-task-reports ([list-thing-registration-task-reports-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-thing-registration-task-reports-request list-thing-registration-task-reports-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-thing-registration-task-reports-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks/{taskId}/reports", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-thing-registration-task-reports-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingRegistrationTaskReports", :http.request.configuration/output-deser-fn response-list-thing-registration-task-reports-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-thing-registration-task-reports :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-thing-registration-task-reports-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-thing-registration-task-reports-response))

(clojure.core/defn set-v-2-logging-level ([set-v-2-logging-level-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-set-v-2-logging-level-request set-v-2-logging-level-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingLevel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/set-v-2-logging-level-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetV2LoggingLevel", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "NotConfiguredException" :portkey.aws.iot/not-configured-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef set-v-2-logging-level :args (clojure.spec.alpha/tuple :portkey.aws.iot/set-v-2-logging-level-request) :ret clojure.core/true?)

(clojure.core/defn delete-registration-code ([] (delete-registration-code {})) ([delete-registration-code-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-registration-code-request delete-registration-code-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-registration-code-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/registrationcode", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-registration-code-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRegistrationCode", :http.request.configuration/output-deser-fn response-delete-registration-code-response, :http.request.spec/error-spec {"ThrottlingException" :portkey.aws.iot/throttling-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-registration-code :args (clojure.spec.alpha/? :portkey.aws.iot/delete-registration-code-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-registration-code-response))

(clojure.core/defn describe-ca-certificate ([describe-ca-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-ca-certificate-request describe-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-ca-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeCACertificate", :http.request.configuration/output-deser-fn response-describe-ca-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-ca-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-ca-certificate-response))

(clojure.core/defn detach-thing-principal ([detach-thing-principal-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-detach-thing-principal-request detach-thing-principal-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/detach-thing-principal-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/detach-thing-principal-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachThingPrincipal", :http.request.configuration/output-deser-fn response-detach-thing-principal-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef detach-thing-principal :args (clojure.spec.alpha/tuple :portkey.aws.iot/detach-thing-principal-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/detach-thing-principal-response))

(clojure.core/defn list-billing-groups ([] (list-billing-groups {})) ([list-billing-groups-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-billing-groups-request list-billing-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-billing-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-billing-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListBillingGroups", :http.request.configuration/output-deser-fn response-list-billing-groups-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef list-billing-groups :args (clojure.spec.alpha/? :portkey.aws.iot/list-billing-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-billing-groups-response))

(clojure.core/defn create-security-profile ([create-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-security-profile-request create-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSecurityProfile", :http.request.configuration/output-deser-fn response-create-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-security-profile-response))

(clojure.core/defn list-thing-registration-tasks ([] (list-thing-registration-tasks {})) ([list-thing-registration-tasks-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-thing-registration-tasks-request list-thing-registration-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-thing-registration-tasks-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-thing-registration-tasks-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingRegistrationTasks", :http.request.configuration/output-deser-fn response-list-thing-registration-tasks-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-thing-registration-tasks :args (clojure.spec.alpha/? :portkey.aws.iot/list-thing-registration-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-thing-registration-tasks-response))

(clojure.core/defn associate-targets-with-job ([associate-targets-with-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-associate-targets-with-job-request associate-targets-with-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/associate-targets-with-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/associate-targets-with-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AssociateTargetsWithJob", :http.request.configuration/output-deser-fn response-associate-targets-with-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef associate-targets-with-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/associate-targets-with-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/associate-targets-with-job-response))

(clojure.core/defn get-indexing-configuration ([] (get-indexing-configuration {})) ([get-indexing-configuration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-indexing-configuration-request get-indexing-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-indexing-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indexing/config", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-indexing-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetIndexingConfiguration", :http.request.configuration/output-deser-fn response-get-indexing-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef get-indexing-configuration :args (clojure.spec.alpha/? :portkey.aws.iot/get-indexing-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-indexing-configuration-response))

(clojure.core/defn cancel-job-execution ([cancel-job-execution-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-cancel-job-execution-request cancel-job-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs/{jobId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/cancel-job-execution-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelJobExecution", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InvalidStateTransitionException" :portkey.aws.iot/invalid-state-transition-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception}})))))
(clojure.spec.alpha/fdef cancel-job-execution :args (clojure.spec.alpha/tuple :portkey.aws.iot/cancel-job-execution-request) :ret clojure.core/true?)

(clojure.core/defn create-dynamic-thing-group ([create-dynamic-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-dynamic-thing-group-request create-dynamic-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-dynamic-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/dynamic-thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-dynamic-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateDynamicThingGroup", :http.request.configuration/output-deser-fn response-create-dynamic-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "InvalidQueryException" :portkey.aws.iot/invalid-query-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef create-dynamic-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-dynamic-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-dynamic-thing-group-response))

(clojure.core/defn list-outgoing-certificates ([] (list-outgoing-certificates {})) ([list-outgoing-certificates-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-outgoing-certificates-request list-outgoing-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-outgoing-certificates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates-out-going", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-outgoing-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListOutgoingCertificates", :http.request.configuration/output-deser-fn response-list-outgoing-certificates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-outgoing-certificates :args (clojure.spec.alpha/? :portkey.aws.iot/list-outgoing-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-outgoing-certificates-response))

(clojure.core/defn start-thing-registration-task ([start-thing-registration-task-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-start-thing-registration-task-request start-thing-registration-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/start-thing-registration-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/start-thing-registration-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartThingRegistrationTask", :http.request.configuration/output-deser-fn response-start-thing-registration-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef start-thing-registration-task :args (clojure.spec.alpha/tuple :portkey.aws.iot/start-thing-registration-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/start-thing-registration-task-response))

(clojure.core/defn update-account-audit-configuration ([] (update-account-audit-configuration {})) ([update-account-audit-configuration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-account-audit-configuration-request update-account-audit-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-account-audit-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/configuration", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-account-audit-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAccountAuditConfiguration", :http.request.configuration/output-deser-fn response-update-account-audit-configuration-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-account-audit-configuration :args (clojure.spec.alpha/? :portkey.aws.iot/update-account-audit-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-account-audit-configuration-response))

(clojure.core/defn list-streams ([] (list-streams {})) ([list-streams-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-streams-request list-streams-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-streams-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-streams-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListStreams", :http.request.configuration/output-deser-fn response-list-streams-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-streams :args (clojure.spec.alpha/? :portkey.aws.iot/list-streams-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-streams-response))

(clojure.core/defn list-thing-groups-for-thing ([list-thing-groups-for-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-thing-groups-for-thing-request list-thing-groups-for-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-thing-groups-for-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/thing-groups", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-thing-groups-for-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingGroupsForThing", :http.request.configuration/output-deser-fn response-list-thing-groups-for-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-thing-groups-for-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-thing-groups-for-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-thing-groups-for-thing-response))

(clojure.core/defn delete-v-2-logging-level ([delete-v-2-logging-level-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-v-2-logging-level-request delete-v-2-logging-level-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingLevel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-v-2-logging-level-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteV2LoggingLevel", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-v-2-logging-level :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-v-2-logging-level-request) :ret clojure.core/true?)

(clojure.core/defn delete-ca-certificate ([delete-ca-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-ca-certificate-request delete-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-ca-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCACertificate", :http.request.configuration/output-deser-fn response-delete-ca-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-ca-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-ca-certificate-response))

(clojure.core/defn list-tags-for-resource ([list-tags-for-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-tags-for-resource-request list-tags-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-tags-for-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-tags-for-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-list-tags-for-resource-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-tags-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-tags-for-resource-response))

(clojure.core/defn list-principal-things ([list-principal-things-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-principal-things-request list-principal-things-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-principal-things-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principals/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-principal-things-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPrincipalThings", :http.request.configuration/output-deser-fn response-list-principal-things-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-principal-things :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-principal-things-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-principal-things-response))

(clojure.core/defn test-invoke-authorizer ([test-invoke-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-test-invoke-authorizer-request test-invoke-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/test-invoke-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}/test", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/test-invoke-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestInvokeAuthorizer", :http.request.configuration/output-deser-fn response-test-invoke-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "InvalidResponseException" :portkey.aws.iot/invalid-response-exception}})))))
(clojure.spec.alpha/fdef test-invoke-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot/test-invoke-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/test-invoke-authorizer-response))

(clojure.core/defn describe-account-audit-configuration ([] (describe-account-audit-configuration {})) ([describe-account-audit-configuration-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-account-audit-configuration-request describe-account-audit-configuration-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-account-audit-configuration-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/configuration", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-account-audit-configuration-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAccountAuditConfiguration", :http.request.configuration/output-deser-fn response-describe-account-audit-configuration-response, :http.request.spec/error-spec {"ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-account-audit-configuration :args (clojure.spec.alpha/? :portkey.aws.iot/describe-account-audit-configuration-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-account-audit-configuration-response))

(clojure.core/defn delete-role-alias ([delete-role-alias-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-role-alias-request delete-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteRoleAlias", :http.request.configuration/output-deser-fn response-delete-role-alias-response, :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-role-alias-response))

(clojure.core/defn list-audit-findings ([] (list-audit-findings {})) ([list-audit-findings-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-audit-findings-request list-audit-findings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-audit-findings-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/findings", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-audit-findings-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAuditFindings", :http.request.configuration/output-deser-fn response-list-audit-findings-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-audit-findings :args (clojure.spec.alpha/? :portkey.aws.iot/list-audit-findings-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-audit-findings-response))

(clojure.core/defn create-policy-version ([create-policy-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-policy-version-request create-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-policy-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePolicyVersion", :http.request.configuration/output-deser-fn response-create-policy-version-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "MalformedPolicyException" :portkey.aws.iot/malformed-policy-exception, "VersionsLimitExceededException" :portkey.aws.iot/versions-limit-exceeded-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-policy-version-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-policy-version-response))

(clojure.core/defn list-role-aliases ([] (list-role-aliases {})) ([list-role-aliases-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-role-aliases-request list-role-aliases-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-role-aliases-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-role-aliases-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListRoleAliases", :http.request.configuration/output-deser-fn response-list-role-aliases-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-role-aliases :args (clojure.spec.alpha/? :portkey.aws.iot/list-role-aliases-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-role-aliases-response))

(clojure.core/defn describe-job ([describe-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-job-request describe-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeJob", :http.request.configuration/output-deser-fn response-describe-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-job-response))

(clojure.core/defn describe-endpoint ([] (describe-endpoint {})) ([describe-endpoint-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-endpoint-request describe-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-endpoint-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/endpoint", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-endpoint-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEndpoint", :http.request.configuration/output-deser-fn response-describe-endpoint-response, :http.request.spec/error-spec {"InternalFailureException" :portkey.aws.iot/internal-failure-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef describe-endpoint :args (clojure.spec.alpha/? :portkey.aws.iot/describe-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-endpoint-response))

(clojure.core/defn list-ota-updates ([] (list-ota-updates {})) ([list-ota-updates-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-ota-updates-request list-ota-updates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-ota-updates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-ota-updates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListOTAUpdates", :http.request.configuration/output-deser-fn response-list-ota-updates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-ota-updates :args (clojure.spec.alpha/? :portkey.aws.iot/list-ota-updates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-ota-updates-response))

(clojure.core/defn register-certificate ([register-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-register-certificate-request register-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/register-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificate/register", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/register-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterCertificate", :http.request.configuration/output-deser-fn response-register-certificate-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "CertificateValidationException" :portkey.aws.iot/certificate-validation-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "CertificateConflictException" :portkey.aws.iot/certificate-conflict-exception}})))))
(clojure.spec.alpha/fdef register-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/register-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/register-certificate-response))

(clojure.core/defn list-job-executions-for-job ([list-job-executions-for-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-job-executions-for-job-request list-job-executions-for-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-job-executions-for-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-job-executions-for-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListJobExecutionsForJob", :http.request.configuration/output-deser-fn response-list-job-executions-for-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-job-executions-for-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-job-executions-for-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-job-executions-for-job-response))

(clojure.core/defn describe-thing-group ([describe-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-thing-group-request describe-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThingGroup", :http.request.configuration/output-deser-fn response-describe-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-thing-group-response))

(clojure.core/defn list-security-profiles-for-target ([list-security-profiles-for-target-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-security-profiles-for-target-request list-security-profiles-for-target-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-security-profiles-for-target-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles-for-target", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-security-profiles-for-target-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListSecurityProfilesForTarget", :http.request.configuration/output-deser-fn response-list-security-profiles-for-target-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-security-profiles-for-target :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-security-profiles-for-target-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-security-profiles-for-target-response))

(clojure.core/defn list-job-executions-for-thing ([list-job-executions-for-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-job-executions-for-thing-request list-job-executions-for-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-job-executions-for-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-job-executions-for-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListJobExecutionsForThing", :http.request.configuration/output-deser-fn response-list-job-executions-for-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-job-executions-for-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-job-executions-for-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-job-executions-for-thing-response))

(clojure.core/defn register-thing ([register-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-register-thing-request register-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/register-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/register-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterThing", :http.request.configuration/output-deser-fn response-register-thing-response, :http.request.spec/error-spec {"InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ConflictingResourceUpdateException" :portkey.aws.iot/conflicting-resource-update-exception, "ResourceRegistrationFailureException" :portkey.aws.iot/resource-registration-failure-exception}})))))
(clojure.spec.alpha/fdef register-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/register-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/register-thing-response))

(clojure.core/defn delete-ota-update ([delete-ota-update-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-ota-update-request delete-ota-update-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-ota-update-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/otaUpdates/{otaUpdateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-ota-update-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteOTAUpdate", :http.request.configuration/output-deser-fn response-delete-ota-update-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception}})))))
(clojure.spec.alpha/fdef delete-ota-update :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-ota-update-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-ota-update-response))

(clojure.core/defn update-stream ([update-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-stream-request update-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateStream", :http.request.configuration/output-deser-fn response-update-stream-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-stream-response))

(clojure.core/defn update-thing-group ([update-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-thing-group-request update-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateThingGroup", :http.request.configuration/output-deser-fn response-update-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-thing-group-response))

(clojure.core/defn describe-index ([describe-index-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-index-request describe-index-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-index-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/indices/{indexName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-index-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeIndex", :http.request.configuration/output-deser-fn response-describe-index-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-index :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-index-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-index-response))

(clojure.core/defn get-policy ([get-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-policy-request get-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-policy-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetPolicy", :http.request.configuration/output-deser-fn response-get-policy-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef get-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/get-policy-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-policy-response))

(clojure.core/defn cancel-audit-task ([cancel-audit-task-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-cancel-audit-task-request cancel-audit-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/cancel-audit-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks/{taskId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/cancel-audit-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelAuditTask", :http.request.configuration/output-deser-fn response-cancel-audit-task-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef cancel-audit-task :args (clojure.spec.alpha/tuple :portkey.aws.iot/cancel-audit-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/cancel-audit-task-response))

(clojure.core/defn delete-security-profile ([delete-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-security-profile-request delete-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSecurityProfile", :http.request.configuration/output-deser-fn response-delete-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception}})))))
(clojure.spec.alpha/fdef delete-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-security-profile-response))

(clojure.core/defn enable-topic-rule ([enable-topic-rule-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-enable-topic-rule-request enable-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}/enable", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/enable-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "EnableTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef enable-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot/enable-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn deprecate-thing-type ([deprecate-thing-type-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-deprecate-thing-type-request deprecate-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/deprecate-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}/deprecate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/deprecate-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeprecateThingType", :http.request.configuration/output-deser-fn response-deprecate-thing-type-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef deprecate-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot/deprecate-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/deprecate-thing-type-response))

(clojure.core/defn list-targets-for-security-profile ([list-targets-for-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-targets-for-security-profile-request list-targets-for-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-targets-for-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-targets-for-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTargetsForSecurityProfile", :http.request.configuration/output-deser-fn response-list-targets-for-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-targets-for-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-targets-for-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-targets-for-security-profile-response))

(clojure.core/defn delete-thing-type ([delete-thing-type-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-thing-type-request delete-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteThingType", :http.request.configuration/output-deser-fn response-delete-thing-type-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-thing-type-response))

(clojure.core/defn update-dynamic-thing-group ([update-dynamic-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-dynamic-thing-group-request update-dynamic-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-dynamic-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/dynamic-thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-dynamic-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateDynamicThingGroup", :http.request.configuration/output-deser-fn response-update-dynamic-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidQueryException" :portkey.aws.iot/invalid-query-exception}})))))
(clojure.spec.alpha/fdef update-dynamic-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-dynamic-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-dynamic-thing-group-response))

(clojure.core/defn list-thing-groups ([] (list-thing-groups {})) ([list-thing-groups-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-thing-groups-request list-thing-groups-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-thing-groups-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-thing-groups-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingGroups", :http.request.configuration/output-deser-fn response-list-thing-groups-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-thing-groups :args (clojure.spec.alpha/? :portkey.aws.iot/list-thing-groups-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-thing-groups-response))

(clojure.core/defn list-targets-for-policy ([list-targets-for-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-targets-for-policy-request list-targets-for-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-targets-for-policy-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policy-targets/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-targets-for-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTargetsForPolicy", :http.request.configuration/output-deser-fn response-list-targets-for-policy-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef list-targets-for-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-targets-for-policy-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-targets-for-policy-response))

(clojure.core/defn replace-topic-rule ([replace-topic-rule-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-replace-topic-rule-request replace-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/replace-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ReplaceTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"SqlParseException" :portkey.aws.iot/sql-parse-exception, "InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef replace-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot/replace-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn get-topic-rule ([get-topic-rule-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-topic-rule-request get-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-topic-rule-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetTopicRule", :http.request.configuration/output-deser-fn response-get-topic-rule-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception}})))))
(clojure.spec.alpha/fdef get-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot/get-topic-rule-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-topic-rule-response))

(clojure.core/defn attach-security-profile ([attach-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-attach-security-profile-request attach-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/attach-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/attach-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachSecurityProfile", :http.request.configuration/output-deser-fn response-attach-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef attach-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/attach-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/attach-security-profile-response))

(clojure.core/defn reject-certificate-transfer ([reject-certificate-transfer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-reject-certificate-transfer-request reject-certificate-transfer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/reject-certificate-transfer/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/reject-certificate-transfer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RejectCertificateTransfer", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef reject-certificate-transfer :args (clojure.spec.alpha/tuple :portkey.aws.iot/reject-certificate-transfer-request) :ret clojure.core/true?)

(clojure.core/defn remove-thing-from-thing-group ([] (remove-thing-from-thing-group {})) ([remove-thing-from-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-remove-thing-from-thing-group-request remove-thing-from-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/remove-thing-from-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/removeThingFromThingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/remove-thing-from-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveThingFromThingGroup", :http.request.configuration/output-deser-fn response-remove-thing-from-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef remove-thing-from-thing-group :args (clojure.spec.alpha/? :portkey.aws.iot/remove-thing-from-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/remove-thing-from-thing-group-response))

(clojure.core/defn delete-authorizer ([delete-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-authorizer-request delete-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAuthorizer", :http.request.configuration/output-deser-fn response-delete-authorizer-response, :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-authorizer-response))

(clojure.core/defn delete-thing ([delete-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-thing-request delete-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteThing", :http.request.configuration/output-deser-fn response-delete-thing-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-thing-response))

(clojure.core/defn get-v-2-logging-options ([] (get-v-2-logging-options {})) ([get-v-2-logging-options-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-v-2-logging-options-request get-v-2-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-v-2-logging-options-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v2LoggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-v-2-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetV2LoggingOptions", :http.request.configuration/output-deser-fn response-get-v-2-logging-options-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "NotConfiguredException" :portkey.aws.iot/not-configured-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-v-2-logging-options :args (clojure.spec.alpha/? :portkey.aws.iot/get-v-2-logging-options-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-v-2-logging-options-response))

(clojure.core/defn list-certificates ([] (list-certificates {})) ([list-certificates-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-certificates-request list-certificates-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-certificates-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-certificates-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListCertificates", :http.request.configuration/output-deser-fn response-list-certificates-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-certificates :args (clojure.spec.alpha/? :portkey.aws.iot/list-certificates-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-certificates-response))

(clojure.core/defn list-thing-types ([] (list-thing-types {})) ([list-thing-types-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-thing-types-request list-thing-types-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-thing-types-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-thing-types-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingTypes", :http.request.configuration/output-deser-fn response-list-thing-types-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-thing-types :args (clojure.spec.alpha/? :portkey.aws.iot/list-thing-types-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-thing-types-response))

(clojure.core/defn detach-security-profile ([detach-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-detach-security-profile-request detach-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/detach-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}/targets", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/detach-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachSecurityProfile", :http.request.configuration/output-deser-fn response-detach-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef detach-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/detach-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/detach-security-profile-response))

(clojure.core/defn describe-thing ([describe-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-thing-request describe-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThing", :http.request.configuration/output-deser-fn response-describe-thing-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-thing-response))

(clojure.core/defn list-policy-principals ([list-policy-principals-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-policy-principals-request list-policy-principals-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-policy-principals-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policy-principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-policy-principals-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPolicyPrincipals", :http.request.configuration/output-deser-fn response-list-policy-principals-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-policy-principals :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-policy-principals-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-policy-principals-response))

(clojure.core/defn update-security-profile ([update-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-security-profile-request update-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateSecurityProfile", :http.request.configuration/output-deser-fn response-update-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-security-profile-response))

(clojure.core/defn validate-security-profile-behaviors ([validate-security-profile-behaviors-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-validate-security-profile-behaviors-request validate-security-profile-behaviors-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/validate-security-profile-behaviors-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profile-behaviors/validate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/validate-security-profile-behaviors-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ValidateSecurityProfileBehaviors", :http.request.configuration/output-deser-fn response-validate-security-profile-behaviors-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef validate-security-profile-behaviors :args (clojure.spec.alpha/tuple :portkey.aws.iot/validate-security-profile-behaviors-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/validate-security-profile-behaviors-response))

(clojure.core/defn create-scheduled-audit ([create-scheduled-audit-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-scheduled-audit-request create-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateScheduledAudit", :http.request.configuration/output-deser-fn response-create-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef create-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-scheduled-audit-response))

(clojure.core/defn set-default-policy-version ([set-default-policy-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-set-default-policy-version-request set-default-policy-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}/version/{policyVersionId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/set-default-policy-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetDefaultPolicyVersion", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef set-default-policy-version :args (clojure.spec.alpha/tuple :portkey.aws.iot/set-default-policy-version-request) :ret clojure.core/true?)

(clojure.core/defn create-policy ([create-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-policy-request create-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-policy-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreatePolicy", :http.request.configuration/output-deser-fn response-create-policy-response, :http.request.spec/error-spec {"ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "MalformedPolicyException" :portkey.aws.iot/malformed-policy-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-policy-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-policy-response))

(clojure.core/defn describe-thing-type ([describe-thing-type-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-thing-type-request describe-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThingType", :http.request.configuration/output-deser-fn response-describe-thing-type-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-thing-type-response))

(clojure.core/defn attach-thing-principal ([attach-thing-principal-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-attach-thing-principal-request attach-thing-principal-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/attach-thing-principal-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/attach-thing-principal-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachThingPrincipal", :http.request.configuration/output-deser-fn response-attach-thing-principal-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef attach-thing-principal :args (clojure.spec.alpha/tuple :portkey.aws.iot/attach-thing-principal-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/attach-thing-principal-response))

(clojure.core/defn delete-thing-group ([delete-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-thing-group-request delete-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteThingGroup", :http.request.configuration/output-deser-fn response-delete-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-thing-group-response))

(clojure.core/defn list-attached-policies ([list-attached-policies-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-attached-policies-request list-attached-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-attached-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/attached-policies/{target}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-attached-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAttachedPolicies", :http.request.configuration/output-deser-fn response-list-attached-policies-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef list-attached-policies :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-attached-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-attached-policies-response))

(clojure.core/defn create-keys-and-certificate ([] (create-keys-and-certificate {})) ([create-keys-and-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-keys-and-certificate-request create-keys-and-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-keys-and-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/keys-and-certificate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-keys-and-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateKeysAndCertificate", :http.request.configuration/output-deser-fn response-create-keys-and-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-keys-and-certificate :args (clojure.spec.alpha/? :portkey.aws.iot/create-keys-and-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-keys-and-certificate-response))

(clojure.core/defn create-job ([create-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-job-request create-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateJob", :http.request.configuration/output-deser-fn response-create-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef create-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-job-response))

(clojure.core/defn describe-authorizer ([describe-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-authorizer-request describe-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/authorizer/{authorizerName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeAuthorizer", :http.request.configuration/output-deser-fn response-describe-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-authorizer-response))

(clojure.core/defn register-ca-certificate ([register-ca-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-register-ca-certificate-request register-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/register-ca-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/register-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RegisterCACertificate", :http.request.configuration/output-deser-fn response-register-ca-certificate-response, :http.request.spec/error-spec {"UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "CertificateValidationException" :portkey.aws.iot/certificate-validation-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "RegistrationCodeValidationException" :portkey.aws.iot/registration-code-validation-exception}})))))
(clojure.spec.alpha/fdef register-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/register-ca-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/register-ca-certificate-response))

(clojure.core/defn untag-resource ([untag-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/untag-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/untag", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/untag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn response-untag-resource-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.iot/untag-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/untag-resource-response))

(clojure.core/defn delete-job ([delete-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-job-request delete-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteJob", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InvalidStateTransitionException" :portkey.aws.iot/invalid-state-transition-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef delete-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-job-request) :ret clojure.core/true?)

(clojure.core/defn start-on-demand-audit-task ([start-on-demand-audit-task-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-start-on-demand-audit-task-request start-on-demand-audit-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/start-on-demand-audit-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/start-on-demand-audit-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartOnDemandAuditTask", :http.request.configuration/output-deser-fn response-start-on-demand-audit-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef start-on-demand-audit-task :args (clojure.spec.alpha/tuple :portkey.aws.iot/start-on-demand-audit-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/start-on-demand-audit-task-response))

(clojure.core/defn describe-event-configurations ([] (describe-event-configurations {})) ([describe-event-configurations-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-event-configurations-request describe-event-configurations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-event-configurations-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/event-configurations", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-event-configurations-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeEventConfigurations", :http.request.configuration/output-deser-fn response-describe-event-configurations-response, :http.request.spec/error-spec {"InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef describe-event-configurations :args (clojure.spec.alpha/? :portkey.aws.iot/describe-event-configurations-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-event-configurations-response))

(clojure.core/defn disable-topic-rule ([disable-topic-rule-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-disable-topic-rule-request disable-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}/disable", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/disable-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DisableTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef disable-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot/disable-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn describe-thing-registration-task ([describe-thing-registration-task-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-thing-registration-task-request describe-thing-registration-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-thing-registration-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks/{taskId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-thing-registration-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeThingRegistrationTask", :http.request.configuration/output-deser-fn response-describe-thing-registration-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-thing-registration-task :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-thing-registration-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-thing-registration-task-response))

(clojure.core/defn list-topic-rules ([] (list-topic-rules {})) ([list-topic-rules-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-topic-rules-request list-topic-rules-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-topic-rules-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-topic-rules-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTopicRules", :http.request.configuration/output-deser-fn response-list-topic-rules-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-topic-rules :args (clojure.spec.alpha/? :portkey.aws.iot/list-topic-rules-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-topic-rules-response))

(clojure.core/defn list-active-violations ([] (list-active-violations {})) ([list-active-violations-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-active-violations-request list-active-violations-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-active-violations-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/active-violations", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-active-violations-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListActiveViolations", :http.request.configuration/output-deser-fn response-list-active-violations-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-active-violations :args (clojure.spec.alpha/? :portkey.aws.iot/list-active-violations-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-active-violations-response))

(clojure.core/defn update-scheduled-audit ([update-scheduled-audit-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-scheduled-audit-request update-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateScheduledAudit", :http.request.configuration/output-deser-fn response-update-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-scheduled-audit-response))

(clojure.core/defn detach-principal-policy ([detach-principal-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-detach-principal-policy-request detach-principal-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principal-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/detach-principal-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DetachPrincipalPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef detach-principal-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/detach-principal-policy-request) :ret clojure.core/true?)

(clojure.core/defn create-stream ([create-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-stream-request create-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateStream", :http.request.configuration/output-deser-fn response-create-stream-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-stream-response))

(clojure.core/defn update-ca-certificate ([update-ca-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-ca-certificate-request update-ca-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/cacertificate/{caCertificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-ca-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateCACertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-ca-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-ca-certificate-request) :ret clojure.core/true?)

(clojure.core/defn describe-scheduled-audit ([describe-scheduled-audit-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-scheduled-audit-request describe-scheduled-audit-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-scheduled-audit-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/scheduledaudits/{scheduledAuditName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-scheduled-audit-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeScheduledAudit", :http.request.configuration/output-deser-fn response-describe-scheduled-audit-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-scheduled-audit :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-scheduled-audit-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-scheduled-audit-response))

(clojure.core/defn describe-security-profile ([describe-security-profile-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-security-profile-request describe-security-profile-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-security-profile-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/security-profiles/{securityProfileName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-security-profile-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeSecurityProfile", :http.request.configuration/output-deser-fn response-describe-security-profile-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-security-profile :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-security-profile-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-security-profile-response))

(clojure.core/defn describe-billing-group ([describe-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-billing-group-request describe-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeBillingGroup", :http.request.configuration/output-deser-fn response-describe-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-billing-group-response))

(clojure.core/defn delete-topic-rule ([delete-topic-rule-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-topic-rule-request delete-topic-rule-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/rules/{ruleName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-topic-rule-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteTopicRule", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ConflictingResourceUpdateException" :portkey.aws.iot/conflicting-resource-update-exception}})))))
(clojure.spec.alpha/fdef delete-topic-rule :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-topic-rule-request) :ret clojure.core/true?)

(clojure.core/defn describe-stream ([describe-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-stream-request describe-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/streams/{streamId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeStream", :http.request.configuration/output-deser-fn response-describe-stream-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-stream :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-stream-response))

(clojure.core/defn describe-certificate ([describe-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-certificate-request describe-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeCertificate", :http.request.configuration/output-deser-fn response-describe-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-certificate-response))

(clojure.core/defn delete-dynamic-thing-group ([delete-dynamic-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-dynamic-thing-group-request delete-dynamic-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/delete-dynamic-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/dynamic-thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-dynamic-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteDynamicThingGroup", :http.request.configuration/output-deser-fn response-delete-dynamic-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-dynamic-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-dynamic-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/delete-dynamic-thing-group-response))

(clojure.core/defn update-job ([update-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-job-request update-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateJob", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef update-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-job-request) :ret clojure.core/true?)

(clojure.core/defn set-logging-options ([set-logging-options-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-set-logging-options-request set-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/loggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/set-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetLoggingOptions", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef set-logging-options :args (clojure.spec.alpha/tuple :portkey.aws.iot/set-logging-options-request) :ret clojure.core/true?)

(clojure.core/defn test-authorization ([test-authorization-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-test-authorization-request test-authorization-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/test-authorization-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/test-authorization", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/test-authorization-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TestAuthorization", :http.request.configuration/output-deser-fn response-test-authorization-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef test-authorization :args (clojure.spec.alpha/tuple :portkey.aws.iot/test-authorization-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/test-authorization-response))

(clojure.core/defn describe-default-authorizer ([] (describe-default-authorizer {})) ([describe-default-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-default-authorizer-request describe-default-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-default-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/default-authorizer", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-default-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeDefaultAuthorizer", :http.request.configuration/output-deser-fn response-describe-default-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef describe-default-authorizer :args (clojure.spec.alpha/? :portkey.aws.iot/describe-default-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-default-authorizer-response))

(clojure.core/defn attach-policy ([attach-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-attach-policy-request attach-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/target-policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/attach-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AttachPolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef attach-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/attach-policy-request) :ret clojure.core/true?)

(clojure.core/defn add-thing-to-billing-group ([] (add-thing-to-billing-group {})) ([add-thing-to-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-add-thing-to-billing-group-request add-thing-to-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/add-thing-to-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/addThingToBillingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/add-thing-to-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddThingToBillingGroup", :http.request.configuration/output-deser-fn response-add-thing-to-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef add-thing-to-billing-group :args (clojure.spec.alpha/? :portkey.aws.iot/add-thing-to-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/add-thing-to-billing-group-response))

(clojure.core/defn describe-job-execution ([describe-job-execution-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-job-execution-request describe-job-execution-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-job-execution-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/jobs/{jobId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-job-execution-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeJobExecution", :http.request.configuration/output-deser-fn response-describe-job-execution-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef describe-job-execution :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-job-execution-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-job-execution-response))

(clojure.core/defn update-thing-groups-for-thing ([] (update-thing-groups-for-thing {})) ([update-thing-groups-for-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-thing-groups-for-thing-request update-thing-groups-for-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-thing-groups-for-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/updateThingGroupsForThing", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-thing-groups-for-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateThingGroupsForThing", :http.request.configuration/output-deser-fn response-update-thing-groups-for-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-thing-groups-for-thing :args (clojure.spec.alpha/? :portkey.aws.iot/update-thing-groups-for-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-thing-groups-for-thing-response))

(clojure.core/defn list-thing-principals ([list-thing-principals-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-thing-principals-request list-thing-principals-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-thing-principals-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}/principals", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-thing-principals-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingPrincipals", :http.request.configuration/output-deser-fn response-list-thing-principals-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-thing-principals :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-thing-principals-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-thing-principals-response))

(clojure.core/defn stop-thing-registration-task ([stop-thing-registration-task-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-stop-thing-registration-task-request stop-thing-registration-task-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/stop-thing-registration-task-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-registration-tasks/{taskId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/stop-thing-registration-task-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopThingRegistrationTask", :http.request.configuration/output-deser-fn response-stop-thing-registration-task-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef stop-thing-registration-task :args (clojure.spec.alpha/tuple :portkey.aws.iot/stop-thing-registration-task-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/stop-thing-registration-task-response))

(clojure.core/defn list-principal-policies ([list-principal-policies-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-principal-policies-request list-principal-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-principal-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/principal-policies", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-principal-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListPrincipalPolicies", :http.request.configuration/output-deser-fn response-list-principal-policies-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-principal-policies :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-principal-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-principal-policies-response))

(clojure.core/defn describe-role-alias ([describe-role-alias-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-describe-role-alias-request describe-role-alias-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/describe-role-alias-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/role-aliases/{roleAlias}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/describe-role-alias-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeRoleAlias", :http.request.configuration/output-deser-fn response-describe-role-alias-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef describe-role-alias :args (clojure.spec.alpha/tuple :portkey.aws.iot/describe-role-alias-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/describe-role-alias-response))

(clojure.core/defn list-things-in-billing-group ([list-things-in-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-things-in-billing-group-request list-things-in-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-things-in-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-things-in-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingsInBillingGroup", :http.request.configuration/output-deser-fn response-list-things-in-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}})))))
(clojure.spec.alpha/fdef list-things-in-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-things-in-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-things-in-billing-group-response))

(clojure.core/defn transfer-certificate ([transfer-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-transfer-certificate-request transfer-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/transfer-certificate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/transfer-certificate/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/transfer-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TransferCertificate", :http.request.configuration/output-deser-fn response-transfer-certificate-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "TransferConflictException" :portkey.aws.iot/transfer-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef transfer-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/transfer-certificate-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/transfer-certificate-response))

(clojure.core/defn list-audit-tasks ([list-audit-tasks-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-audit-tasks-request list-audit-tasks-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-audit-tasks-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/audit/tasks", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-audit-tasks-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListAuditTasks", :http.request.configuration/output-deser-fn response-list-audit-tasks-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-audit-tasks :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-audit-tasks-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-audit-tasks-response))

(clojure.core/defn delete-policy ([delete-policy-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-policy-request delete-policy-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/policies/{policyName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-policy-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeletePolicy", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef delete-policy :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-policy-request) :ret clojure.core/true?)

(clojure.core/defn update-thing ([update-thing-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-thing-request update-thing-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/update-thing-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things/{thingName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-thing-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :patch, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateThing", :http.request.configuration/output-deser-fn response-update-thing-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef update-thing :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-thing-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/update-thing-response))

(clojure.core/defn delete-certificate ([delete-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-certificate-request delete-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/delete-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"CertificateStateException" :portkey.aws.iot/certificate-state-exception, "DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef delete-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/delete-certificate-request) :ret clojure.core/true?)

(clojure.core/defn get-logging-options ([] (get-logging-options {})) ([get-logging-options-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-logging-options-request get-logging-options-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-logging-options-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/loggingOptions", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-logging-options-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetLoggingOptions", :http.request.configuration/output-deser-fn response-get-logging-options-response, :http.request.spec/error-spec {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef get-logging-options :args (clojure.spec.alpha/? :portkey.aws.iot/get-logging-options-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-logging-options-response))

(clojure.core/defn create-thing-group ([create-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-thing-group-request create-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateThingGroup", :http.request.configuration/output-deser-fn response-create-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-thing-group-response))

(clojure.core/defn remove-thing-from-billing-group ([] (remove-thing-from-billing-group {})) ([remove-thing-from-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-remove-thing-from-billing-group-request remove-thing-from-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/remove-thing-from-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/removeThingFromBillingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/remove-thing-from-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveThingFromBillingGroup", :http.request.configuration/output-deser-fn response-remove-thing-from-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef remove-thing-from-billing-group :args (clojure.spec.alpha/? :portkey.aws.iot/remove-thing-from-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/remove-thing-from-billing-group-response))

(clojure.core/defn clear-default-authorizer ([] (clear-default-authorizer {})) ([clear-default-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-clear-default-authorizer-request clear-default-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/clear-default-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/default-authorizer", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/clear-default-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ClearDefaultAuthorizer", :http.request.configuration/output-deser-fn response-clear-default-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef clear-default-authorizer :args (clojure.spec.alpha/? :portkey.aws.iot/clear-default-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/clear-default-authorizer-response))

(clojure.core/defn create-billing-group ([create-billing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-billing-group-request create-billing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-billing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/billing-groups/{billingGroupName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-billing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateBillingGroup", :http.request.configuration/output-deser-fn response-create-billing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-billing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-billing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-billing-group-response))

(clojure.core/defn add-thing-to-thing-group ([] (add-thing-to-thing-group {})) ([add-thing-to-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-add-thing-to-thing-group-request add-thing-to-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/add-thing-to-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/addThingToThingGroup", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/add-thing-to-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddThingToThingGroup", :http.request.configuration/output-deser-fn response-add-thing-to-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef add-thing-to-thing-group :args (clojure.spec.alpha/? :portkey.aws.iot/add-thing-to-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/add-thing-to-thing-group-response))

(clojure.core/defn get-effective-policies ([] (get-effective-policies {})) ([get-effective-policies-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-effective-policies-request get-effective-policies-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/get-effective-policies-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/effective-policies", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/get-effective-policies-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetEffectivePolicies", :http.request.configuration/output-deser-fn response-get-effective-policies-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}})))))
(clojure.spec.alpha/fdef get-effective-policies :args (clojure.spec.alpha/? :portkey.aws.iot/get-effective-policies-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/get-effective-policies-response))

(clojure.core/defn list-things-in-thing-group ([list-things-in-thing-group-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-things-in-thing-group-request list-things-in-thing-group-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-things-in-thing-group-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-groups/{thingGroupName}/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-things-in-thing-group-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThingsInThingGroup", :http.request.configuration/output-deser-fn response-list-things-in-thing-group-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}})))))
(clojure.spec.alpha/fdef list-things-in-thing-group :args (clojure.spec.alpha/tuple :portkey.aws.iot/list-things-in-thing-group-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-things-in-thing-group-response))

(clojure.core/defn create-thing-type ([create-thing-type-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-thing-type-request create-thing-type-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-thing-type-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/thing-types/{thingTypeName}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-thing-type-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateThingType", :http.request.configuration/output-deser-fn response-create-thing-type-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception}})))))
(clojure.spec.alpha/fdef create-thing-type :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-thing-type-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-thing-type-response))

(clojure.core/defn set-default-authorizer ([set-default-authorizer-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-set-default-authorizer-request set-default-authorizer-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/set-default-authorizer-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/default-authorizer", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/set-default-authorizer-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SetDefaultAuthorizer", :http.request.configuration/output-deser-fn response-set-default-authorizer-response, :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception}})))))
(clojure.spec.alpha/fdef set-default-authorizer :args (clojure.spec.alpha/tuple :portkey.aws.iot/set-default-authorizer-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/set-default-authorizer-response))

(clojure.core/defn update-certificate ([update-certificate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-certificate-request update-certificate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates/{certificateId}", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/update-certificate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateCertificate", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef update-certificate :args (clojure.spec.alpha/tuple :portkey.aws.iot/update-certificate-request) :ret clojure.core/true?)

(clojure.core/defn create-certificate-from-csr ([create-certificate-from-csr-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-certificate-from-csr-request create-certificate-from-csr-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/create-certificate-from-csr-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/certificates", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/create-certificate-from-csr-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCertificateFromCsr", :http.request.configuration/output-deser-fn response-create-certificate-from-csr-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef create-certificate-from-csr :args (clojure.spec.alpha/tuple :portkey.aws.iot/create-certificate-from-csr-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/create-certificate-from-csr-response))

(clojure.core/defn list-jobs ([] (list-jobs {})) ([list-jobs-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-jobs-request list-jobs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-jobs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-jobs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListJobs", :http.request.configuration/output-deser-fn response-list-jobs-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef list-jobs :args (clojure.spec.alpha/? :portkey.aws.iot/list-jobs-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-jobs-response))

(clojure.core/defn list-things ([] (list-things {})) ([list-things-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-things-request list-things-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/list-things-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/things", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/list-things-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListThings", :http.request.configuration/output-deser-fn response-list-things-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}})))))
(clojure.spec.alpha/fdef list-things :args (clojure.spec.alpha/? :portkey.aws.iot/list-things-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/list-things-response))

(clojure.core/defn cancel-job ([cancel-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-cancel-job-request cancel-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.iot/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.iot/cancel-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/jobs/{jobId}/cancel", :http.request.configuration/version "2015-05-28", :http.request.configuration/service-id "IoT", :http.request.spec/input-spec :portkey.aws.iot/cancel-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code nil, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CancelJob", :http.request.configuration/output-deser-fn response-cancel-job-response, :http.request.spec/error-spec {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}})))))
(clojure.spec.alpha/fdef cancel-job :args (clojure.spec.alpha/tuple :portkey.aws.iot/cancel-job-request) :ret (clojure.spec.alpha/and :portkey.aws.iot/cancel-job-response))
