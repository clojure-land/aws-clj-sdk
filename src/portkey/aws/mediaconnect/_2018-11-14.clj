(ns portkey.aws.mediaconnect.-2018-11-14 (:require [portkey.aws]))

(def endpoints 'nil)

(clojure.core/declare ser-add-output-request)

(clojure.core/declare ser-grant-entitlement-request)

(clojure.core/declare ser-string)

(clojure.core/declare ser-update-encryption)

(clojure.core/declare ser-list-of-grant-entitlement-request)

(clojure.core/declare ser-algorithm)

(clojure.core/declare ser-list-of-string)

(clojure.core/declare ser-protocol)

(clojure.core/declare ser-set-source-request)

(clojure.core/declare ser-encryption)

(clojure.core/declare ser-max-results)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-key-type)

(clojure.core/declare ser-map-of-string)

(clojure.core/declare ser-list-of-add-output-request)

(clojure.core/defn- ser-add-output-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:destination input)) #:http.request.field{:name "Destination", :shape "__string", :location-name "destination"}) (clojure.core/into (ser-integer (:port input)) #:http.request.field{:name "Port", :shape "__integer", :location-name "port"}) (clojure.core/into (ser-protocol (:protocol input)) #:http.request.field{:name "Protocol", :shape "Protocol", :location-name "protocol"})], :shape "AddOutputRequest", :type "structure"} (clojure.core/contains? input :stream-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stream-id)) #:http.request.field{:name "StreamId", :shape "__string", :location-name "streamId"})) (clojure.core/contains? input :max-latency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-latency)) #:http.request.field{:name "MaxLatency", :shape "__integer", :location-name "maxLatency"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string", :location-name "description"})) (clojure.core/contains? input :encryption) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-encryption (input :encryption)) #:http.request.field{:name "Encryption", :shape "Encryption", :location-name "encryption"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string", :location-name "name"})) (clojure.core/contains? input :smoothing-latency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :smoothing-latency)) #:http.request.field{:name "SmoothingLatency", :shape "__integer", :location-name "smoothingLatency"}))))

(clojure.core/defn- ser-grant-entitlement-request [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-list-of-string (:subscribers input)) #:http.request.field{:name "Subscribers", :shape "__listOf__string", :location-name "subscribers"})], :shape "GrantEntitlementRequest", :type "structure"} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string", :location-name "description"})) (clojure.core/contains? input :encryption) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-encryption (input :encryption)) #:http.request.field{:name "Encryption", :shape "Encryption", :location-name "encryption"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string", :location-name "name"}))))

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "__string"})

(clojure.core/defn- ser-update-encryption [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "UpdateEncryption", :type "structure"} (clojure.core/contains? input :algorithm) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-algorithm (input :algorithm)) #:http.request.field{:name "Algorithm", :shape "Algorithm", :location-name "algorithm"})) (clojure.core/contains? input :key-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-key-type (input :key-type)) #:http.request.field{:name "KeyType", :shape "KeyType", :location-name "keyType"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-arn)) #:http.request.field{:name "RoleArn", :shape "__string", :location-name "roleArn"})) (clojure.core/contains? input :secret-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :secret-arn)) #:http.request.field{:name "SecretArn", :shape "__string", :location-name "secretArn"}))))

(clojure.core/defn- ser-list-of-grant-entitlement-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-grant-entitlement-request coll) #:http.request.field{:shape "GrantEntitlementRequest"}))) input), :shape "__listOfGrantEntitlementRequest", :type "list"})

(clojure.core/defn- ser-algorithm [input] #:http.request.field{:value (clojure.core/get {"aes128" "aes128", :aes-128 "aes128", "aes192" "aes192", :aes-192 "aes192", "aes256" "aes256", :aes-256 "aes256"} input), :shape "Algorithm"})

(clojure.core/defn- ser-list-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "__string"}))) input), :shape "__listOf__string", :type "list"})

(clojure.core/defn- ser-protocol [input] #:http.request.field{:value (clojure.core/get {"zixi-push" "zixi-push", :zixipush "zixi-push", "rtp-fec" "rtp-fec", :rtpfec "rtp-fec", "rtp" "rtp", :rtp "rtp"} input), :shape "Protocol"})

(clojure.core/defn- ser-set-source-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SetSourceRequest", :type "structure"} (clojure.core/contains? input :stream-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stream-id)) #:http.request.field{:name "StreamId", :shape "__string", :location-name "streamId"})) (clojure.core/contains? input :decryption) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-encryption (input :decryption)) #:http.request.field{:name "Decryption", :shape "Encryption", :location-name "decryption"})) (clojure.core/contains? input :max-latency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-latency)) #:http.request.field{:name "MaxLatency", :shape "__integer", :location-name "maxLatency"})) (clojure.core/contains? input :whitelist-cidr) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :whitelist-cidr)) #:http.request.field{:name "WhitelistCidr", :shape "__string", :location-name "whitelistCidr"})) (clojure.core/contains? input :entitlement-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :entitlement-arn)) #:http.request.field{:name "EntitlementArn", :shape "__string", :location-name "entitlementArn"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string", :location-name "description"})) (clojure.core/contains? input :protocol) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-protocol (input :protocol)) #:http.request.field{:name "Protocol", :shape "Protocol", :location-name "protocol"})) (clojure.core/contains? input :ingest-port) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ingest-port)) #:http.request.field{:name "IngestPort", :shape "__integer", :location-name "ingestPort"})) (clojure.core/contains? input :max-bitrate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-bitrate)) #:http.request.field{:name "MaxBitrate", :shape "__integer", :location-name "maxBitrate"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string", :location-name "name"}))))

(clojure.core/defn- ser-encryption [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-string (:secret-arn input)) #:http.request.field{:name "SecretArn", :shape "__string", :location-name "secretArn"}) (clojure.core/into (ser-algorithm (:algorithm input)) #:http.request.field{:name "Algorithm", :shape "Algorithm", :location-name "algorithm"}) (clojure.core/into (ser-string (:role-arn input)) #:http.request.field{:name "RoleArn", :shape "__string", :location-name "roleArn"})], :shape "Encryption", :type "structure"} (clojure.core/contains? input :key-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-key-type (input :key-type)) #:http.request.field{:name "KeyType", :shape "KeyType", :location-name "keyType"}))))

(clojure.core/defn- ser-max-results [input] #:http.request.field{:value input, :shape "MaxResults"})

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "__integer"})

(clojure.core/defn- ser-key-type [input] #:http.request.field{:value (clojure.core/get {"static-key" "static-key", :statickey "static-key"} input), :shape "KeyType"})

(clojure.core/defn- ser-map-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-string v) #:http.request.field{:map-info "value", :shape "__string"})])) input), :shape "__mapOf__string", :type "map"})

(clojure.core/defn- ser-list-of-add-output-request [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-add-output-request coll) #:http.request.field{:shape "AddOutputRequest"}))) input), :shape "__listOfAddOutputRequest", :type "list"})

(clojure.core/defn- req-create-flow-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-set-source-request (input :source)) #:http.request.field{:name "Source", :shape "SetSourceRequest", :location-name "source"}) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string", :location-name "name"})]} (clojure.core/contains? input :availability-zone) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :availability-zone)) #:http.request.field{:name "AvailabilityZone", :shape "__string", :location-name "availabilityZone"})) (clojure.core/contains? input :entitlements) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-grant-entitlement-request (input :entitlements)) #:http.request.field{:name "Entitlements", :shape "__listOfGrantEntitlementRequest", :location-name "entitlements"})) (clojure.core/contains? input :outputs) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-add-output-request (input :outputs)) #:http.request.field{:name "Outputs", :shape "__listOfAddOutputRequest", :location-name "outputs"}))))

(clojure.core/defn- req-update-flow-source-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"}) (clojure.core/into (ser-string (input :source-arn)) #:http.request.field{:name "SourceArn", :shape "__string", :location "uri", :location-name "sourceArn"})]} (clojure.core/contains? input :stream-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stream-id)) #:http.request.field{:name "StreamId", :shape "__string", :location-name "streamId"})) (clojure.core/contains? input :decryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-update-encryption (input :decryption)) #:http.request.field{:name "Decryption", :shape "UpdateEncryption", :location-name "decryption"})) (clojure.core/contains? input :max-latency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-latency)) #:http.request.field{:name "MaxLatency", :shape "__integer", :location-name "maxLatency"})) (clojure.core/contains? input :whitelist-cidr) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :whitelist-cidr)) #:http.request.field{:name "WhitelistCidr", :shape "__string", :location-name "whitelistCidr"})) (clojure.core/contains? input :entitlement-arn) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :entitlement-arn)) #:http.request.field{:name "EntitlementArn", :shape "__string", :location-name "entitlementArn"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string", :location-name "description"})) (clojure.core/contains? input :protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-protocol (input :protocol)) #:http.request.field{:name "Protocol", :shape "Protocol", :location-name "protocol"})) (clojure.core/contains? input :ingest-port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :ingest-port)) #:http.request.field{:name "IngestPort", :shape "__integer", :location-name "ingestPort"})) (clojure.core/contains? input :max-bitrate) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-bitrate)) #:http.request.field{:name "MaxBitrate", :shape "__integer", :location-name "maxBitrate"}))))

(clojure.core/defn- req-add-flow-outputs-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"})], :body [(clojure.core/into (ser-list-of-add-output-request (input :outputs)) #:http.request.field{:name "Outputs", :shape "__listOfAddOutputRequest", :location-name "outputs"})]}))

(clojure.core/defn- req-list-tags-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "__string", :location "uri", :location-name "resourceArn"})]}))

(clojure.core/defn- req-list-entitlements-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "__string", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-update-flow-output-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"}) (clojure.core/into (ser-string (input :output-arn)) #:http.request.field{:name "OutputArn", :shape "__string", :location "uri", :location-name "outputArn"})]} (clojure.core/contains? input :stream-id) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stream-id)) #:http.request.field{:name "StreamId", :shape "__string", :location-name "streamId"})) (clojure.core/contains? input :max-latency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :max-latency)) #:http.request.field{:name "MaxLatency", :shape "__integer", :location-name "maxLatency"})) (clojure.core/contains? input :destination) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination)) #:http.request.field{:name "Destination", :shape "__string", :location-name "destination"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string", :location-name "description"})) (clojure.core/contains? input :protocol) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-protocol (input :protocol)) #:http.request.field{:name "Protocol", :shape "Protocol", :location-name "protocol"})) (clojure.core/contains? input :port) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :port)) #:http.request.field{:name "Port", :shape "__integer", :location-name "port"})) (clojure.core/contains? input :encryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-update-encryption (input :encryption)) #:http.request.field{:name "Encryption", :shape "UpdateEncryption", :location-name "encryption"})) (clojure.core/contains? input :smoothing-latency) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :smoothing-latency)) #:http.request.field{:name "SmoothingLatency", :shape "__integer", :location-name "smoothingLatency"}))))

(clojure.core/defn- req-describe-flow-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"})]}))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "__string", :location "uri", :location-name "resourceArn"})], :body [(clojure.core/into (ser-map-of-string (input :tags)) #:http.request.field{:name "Tags", :shape "__mapOf__string", :location-name "tags"})]}))

(clojure.core/defn- req-update-flow-entitlement-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"}) (clojure.core/into (ser-string (input :entitlement-arn)) #:http.request.field{:name "EntitlementArn", :shape "__string", :location "uri", :location-name "entitlementArn"})]} (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string", :location-name "description"})) (clojure.core/contains? input :encryption) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-update-encryption (input :encryption)) #:http.request.field{:name "Encryption", :shape "UpdateEncryption", :location-name "encryption"})) (clojure.core/contains? input :subscribers) (clojure.core/update-in [:http.request.configuration/body] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :subscribers)) #:http.request.field{:name "Subscribers", :shape "__listOf__string", :location-name "subscribers"}))))

(clojure.core/defn- req-start-flow-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"})]}))

(clojure.core/defn- req-list-flows-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :max-results) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-max-results (input :max-results)) #:http.request.field{:name "MaxResults", :shape "MaxResults", :location "querystring", :location-name "maxResults"})) (clojure.core/contains? input :next-token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :next-token)) #:http.request.field{:name "NextToken", :shape "__string", :location "querystring", :location-name "nextToken"}))))

(clojure.core/defn- req-revoke-flow-entitlement-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"}) (clojure.core/into (ser-string (input :entitlement-arn)) #:http.request.field{:name "EntitlementArn", :shape "__string", :location "uri", :location-name "entitlementArn"})]}))

(clojure.core/defn- req-remove-flow-output-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"}) (clojure.core/into (ser-string (input :output-arn)) #:http.request.field{:name "OutputArn", :shape "__string", :location "uri", :location-name "outputArn"})]}))

(clojure.core/defn- req-delete-flow-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"})]}))

(clojure.core/defn- req-stop-flow-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"})]}))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-list-of-string (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "__listOf__string", :location "querystring", :location-name "tagKeys"})], :uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "__string", :location "uri", :location-name "resourceArn"})]}))

(clojure.core/defn- req-grant-flow-entitlements-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :flow-arn)) #:http.request.field{:name "FlowArn", :shape "__string", :location "uri", :location-name "flowArn"})], :body [(clojure.core/into (ser-list-of-grant-entitlement-request (input :entitlements)) #:http.request.field{:name "Entitlements", :shape "__listOfGrantEntitlementRequest", :location-name "entitlements"})]}))

(clojure.core/declare deser-messages)

(clojure.core/declare deser-listed-entitlement)

(clojure.core/declare deser-source)

(clojure.core/declare deser-list-of-listed-entitlement)

(clojure.core/declare deser-list-of-listed-flow)

(clojure.core/declare deser-string)

(clojure.core/declare deser-transport)

(clojure.core/declare deser-source-type)

(clojure.core/declare deser-status)

(clojure.core/declare deser-listed-flow)

(clojure.core/declare deser-entitlement)

(clojure.core/declare deser-algorithm)

(clojure.core/declare deser-list-of-string)

(clojure.core/declare deser-protocol)

(clojure.core/declare deser-list-of-output)

(clojure.core/declare deser-encryption)

(clojure.core/declare deser-output)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-list-of-entitlement)

(clojure.core/declare deser-key-type)

(clojure.core/declare deser-map-of-string)

(clojure.core/declare deser-flow)

(clojure.core/defn- deser-messages [input] (clojure.core/cond-> {:errors (deser-list-of-string (input "errors"))}))

(clojure.core/defn- deser-listed-entitlement [input] (clojure.core/cond-> {:entitlement-arn (deser-string (input "entitlementArn")), :entitlement-name (deser-string (input "entitlementName"))}))

(clojure.core/defn- deser-source [input] (clojure.core/cond-> {:source-arn (deser-string (input "sourceArn")), :name (deser-string (input "name"))} (clojure.core/contains? input "decryption") (clojure.core/assoc :decryption (deser-encryption (input "decryption"))) (clojure.core/contains? input "whitelistCidr") (clojure.core/assoc :whitelist-cidr (deser-string (input "whitelistCidr"))) (clojure.core/contains? input "transport") (clojure.core/assoc :transport (deser-transport (input "transport"))) (clojure.core/contains? input "entitlementArn") (clojure.core/assoc :entitlement-arn (deser-string (input "entitlementArn"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "ingestIp") (clojure.core/assoc :ingest-ip (deser-string (input "ingestIp"))) (clojure.core/contains? input "ingestPort") (clojure.core/assoc :ingest-port (deser-integer (input "ingestPort")))))

(clojure.core/defn- deser-list-of-listed-entitlement [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-listed-entitlement coll))) input))

(clojure.core/defn- deser-list-of-listed-flow [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-listed-flow coll))) input))

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-transport [input] (clojure.core/cond-> {:protocol (deser-protocol (input "protocol"))} (clojure.core/contains? input "maxBitrate") (clojure.core/assoc :max-bitrate (deser-integer (input "maxBitrate"))) (clojure.core/contains? input "maxLatency") (clojure.core/assoc :max-latency (deser-integer (input "maxLatency"))) (clojure.core/contains? input "smoothingLatency") (clojure.core/assoc :smoothing-latency (deser-integer (input "smoothingLatency"))) (clojure.core/contains? input "streamId") (clojure.core/assoc :stream-id (deser-string (input "streamId")))))

(clojure.core/defn- deser-source-type [input] (clojure.core/get {"OWNED" :owned, "ENTITLED" :entitled} input))

(clojure.core/defn- deser-status [input] (clojure.core/get {"STANDBY" :standby, "ACTIVE" :active, "UPDATING" :updating, "DELETING" :deleting, "STARTING" :starting, "STOPPING" :stopping, "ERROR" :error} input))

(clojure.core/defn- deser-listed-flow [input] (clojure.core/cond-> {:status (deser-status (input "status")), :description (deser-string (input "description")), :source-type (deser-source-type (input "sourceType")), :availability-zone (deser-string (input "availabilityZone")), :flow-arn (deser-string (input "flowArn")), :name (deser-string (input "name"))}))

(clojure.core/defn- deser-entitlement [input] (clojure.core/cond-> {:entitlement-arn (deser-string (input "entitlementArn")), :subscribers (deser-list-of-string (input "subscribers")), :name (deser-string (input "name"))} (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "encryption") (clojure.core/assoc :encryption (deser-encryption (input "encryption")))))

(clojure.core/defn- deser-algorithm [input] (clojure.core/get {"aes128" :aes-128, "aes192" :aes-192, "aes256" :aes-256} input))

(clojure.core/defn- deser-list-of-string [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-protocol [input] (clojure.core/get {"zixi-push" :zixipush, "rtp-fec" :rtpfec, "rtp" :rtp} input))

(clojure.core/defn- deser-list-of-output [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-output coll))) input))

(clojure.core/defn- deser-encryption [input] (clojure.core/cond-> {:secret-arn (deser-string (input "secretArn")), :algorithm (deser-algorithm (input "algorithm")), :role-arn (deser-string (input "roleArn"))} (clojure.core/contains? input "keyType") (clojure.core/assoc :key-type (deser-key-type (input "keyType")))))

(clojure.core/defn- deser-output [input] (clojure.core/cond-> {:output-arn (deser-string (input "outputArn")), :name (deser-string (input "name"))} (clojure.core/contains? input "destination") (clojure.core/assoc :destination (deser-string (input "destination"))) (clojure.core/contains? input "mediaLiveInputArn") (clojure.core/assoc :media-live-input-arn (deser-string (input "mediaLiveInputArn"))) (clojure.core/contains? input "transport") (clojure.core/assoc :transport (deser-transport (input "transport"))) (clojure.core/contains? input "entitlementArn") (clojure.core/assoc :entitlement-arn (deser-string (input "entitlementArn"))) (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "port") (clojure.core/assoc :port (deser-integer (input "port"))) (clojure.core/contains? input "encryption") (clojure.core/assoc :encryption (deser-encryption (input "encryption")))))

(clojure.core/defn- deser-integer [input] input)

(clojure.core/defn- deser-list-of-entitlement [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-entitlement coll))) input))

(clojure.core/defn- deser-key-type [input] (clojure.core/get {"static-key" :statickey} input))

(clojure.core/defn- deser-map-of-string [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-flow [input] (clojure.core/cond-> {:status (deser-status (input "status")), :entitlements (deser-list-of-entitlement (input "entitlements")), :outputs (deser-list-of-output (input "outputs")), :availability-zone (deser-string (input "availabilityZone")), :flow-arn (deser-string (input "flowArn")), :source (deser-source (input "source")), :name (deser-string (input "name"))} (clojure.core/contains? input "description") (clojure.core/assoc :description (deser-string (input "description"))) (clojure.core/contains? input "egressIp") (clojure.core/assoc :egress-ip (deser-string (input "egressIp")))))

(clojure.core/defn- response-internal-server-error-exception ([input] (response-internal-server-error-exception nil input)) ([resultWrapper285984 input] (clojure.core/let [rawinput285983 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar285985 {"message" (rawinput285983 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar285985 ["message"]))}))))

(clojure.core/defn- response-remove-flow-output-response ([input] (response-remove-flow-output-response nil input)) ([resultWrapper285987 input] (clojure.core/let [rawinput285986 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar285988 {"flowArn" (rawinput285986 "flowArn"), "outputArn" (rawinput285986 "outputArn")}] (clojure.core/cond-> {} (letvar285988 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar285988 ["flowArn"]))) (letvar285988 "outputArn") (clojure.core/assoc :output-arn (deser-string (clojure.core/get-in letvar285988 ["outputArn"])))))))

(clojure.core/defn- response-add-flow-outputs-response ([input] (response-add-flow-outputs-response nil input)) ([resultWrapper285990 input] (clojure.core/let [rawinput285989 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar285991 {"flowArn" (rawinput285989 "flowArn"), "outputs" (rawinput285989 "outputs")}] (clojure.core/cond-> {} (letvar285991 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar285991 ["flowArn"]))) (letvar285991 "outputs") (clojure.core/assoc :outputs (deser-list-of-output (clojure.core/get-in letvar285991 ["outputs"])))))))

(clojure.core/defn- response-list-flows-response ([input] (response-list-flows-response nil input)) ([resultWrapper285993 input] (clojure.core/let [rawinput285992 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar285994 {"flows" (rawinput285992 "flows"), "nextToken" (rawinput285992 "nextToken")}] (clojure.core/cond-> {} (letvar285994 "flows") (clojure.core/assoc :flows (deser-list-of-listed-flow (clojure.core/get-in letvar285994 ["flows"]))) (letvar285994 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar285994 ["nextToken"])))))))

(clojure.core/defn- response-bad-request-exception ([input] (response-bad-request-exception nil input)) ([resultWrapper285996 input] (clojure.core/let [rawinput285995 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar285997 {"message" (rawinput285995 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar285997 ["message"]))}))))

(clojure.core/defn- response-update-flow-source-response ([input] (response-update-flow-source-response nil input)) ([resultWrapper285999 input] (clojure.core/let [rawinput285998 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286000 {"flowArn" (rawinput285998 "flowArn"), "source" (rawinput285998 "source")}] (clojure.core/cond-> {} (letvar286000 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286000 ["flowArn"]))) (letvar286000 "source") (clojure.core/assoc :source (deser-source (clojure.core/get-in letvar286000 ["source"])))))))

(clojure.core/defn- response-list-tags-for-resource-response ([input] (response-list-tags-for-resource-response nil input)) ([resultWrapper286002 input] (clojure.core/let [rawinput286001 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286003 {"tags" (rawinput286001 "tags")}] (clojure.core/cond-> {} (letvar286003 "tags") (clojure.core/assoc :tags (deser-map-of-string (clojure.core/get-in letvar286003 ["tags"])))))))

(clojure.core/defn- response-create-flow-response ([input] (response-create-flow-response nil input)) ([resultWrapper286005 input] (clojure.core/let [rawinput286004 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286006 {"flow" (rawinput286004 "flow")}] (clojure.core/cond-> {} (letvar286006 "flow") (clojure.core/assoc :flow (deser-flow (clojure.core/get-in letvar286006 ["flow"])))))))

(clojure.core/defn- response-forbidden-exception ([input] (response-forbidden-exception nil input)) ([resultWrapper286008 input] (clojure.core/let [rawinput286007 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286009 {"message" (rawinput286007 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286009 ["message"]))}))))

(clojure.core/defn- response-describe-flow-response ([input] (response-describe-flow-response nil input)) ([resultWrapper286011 input] (clojure.core/let [rawinput286010 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286012 {"flow" (rawinput286010 "flow"), "messages" (rawinput286010 "messages")}] (clojure.core/cond-> {} (letvar286012 "flow") (clojure.core/assoc :flow (deser-flow (clojure.core/get-in letvar286012 ["flow"]))) (letvar286012 "messages") (clojure.core/assoc :messages (deser-messages (clojure.core/get-in letvar286012 ["messages"])))))))

(clojure.core/defn- response-service-unavailable-exception ([input] (response-service-unavailable-exception nil input)) ([resultWrapper286014 input] (clojure.core/let [rawinput286013 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286015 {"message" (rawinput286013 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286015 ["message"]))}))))

(clojure.core/defn- response-too-many-requests-exception ([input] (response-too-many-requests-exception nil input)) ([resultWrapper286017 input] (clojure.core/let [rawinput286016 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286018 {"message" (rawinput286016 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286018 ["message"]))}))))

(clojure.core/defn- response-delete-flow-response ([input] (response-delete-flow-response nil input)) ([resultWrapper286020 input] (clojure.core/let [rawinput286019 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286021 {"flowArn" (rawinput286019 "flowArn"), "status" (rawinput286019 "status")}] (clojure.core/cond-> {} (letvar286021 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286021 ["flowArn"]))) (letvar286021 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar286021 ["status"])))))))

(clojure.core/defn- response-update-flow-entitlement-response ([input] (response-update-flow-entitlement-response nil input)) ([resultWrapper286023 input] (clojure.core/let [rawinput286022 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286024 {"entitlement" (rawinput286022 "entitlement"), "flowArn" (rawinput286022 "flowArn")}] (clojure.core/cond-> {} (letvar286024 "entitlement") (clojure.core/assoc :entitlement (deser-entitlement (clojure.core/get-in letvar286024 ["entitlement"]))) (letvar286024 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286024 ["flowArn"])))))))

(clojure.core/defn- response-stop-flow-response ([input] (response-stop-flow-response nil input)) ([resultWrapper286026 input] (clojure.core/let [rawinput286025 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286027 {"flowArn" (rawinput286025 "flowArn"), "status" (rawinput286025 "status")}] (clojure.core/cond-> {} (letvar286027 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286027 ["flowArn"]))) (letvar286027 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar286027 ["status"])))))))

(clojure.core/defn- response-grant-flow-entitlements-response ([input] (response-grant-flow-entitlements-response nil input)) ([resultWrapper286029 input] (clojure.core/let [rawinput286028 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286030 {"entitlements" (rawinput286028 "entitlements"), "flowArn" (rawinput286028 "flowArn")}] (clojure.core/cond-> {} (letvar286030 "entitlements") (clojure.core/assoc :entitlements (deser-list-of-entitlement (clojure.core/get-in letvar286030 ["entitlements"]))) (letvar286030 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286030 ["flowArn"])))))))

(clojure.core/defn- response-create-flow-420-exception ([input] (response-create-flow-420-exception nil input)) ([resultWrapper286032 input] (clojure.core/let [rawinput286031 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286033 {"message" (rawinput286031 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286033 ["message"]))}))))

(clojure.core/defn- response-not-found-exception ([input] (response-not-found-exception nil input)) ([resultWrapper286035 input] (clojure.core/let [rawinput286034 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286036 {"message" (rawinput286034 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286036 ["message"]))}))))

(clojure.core/defn- response-update-flow-output-response ([input] (response-update-flow-output-response nil input)) ([resultWrapper286038 input] (clojure.core/let [rawinput286037 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286039 {"flowArn" (rawinput286037 "flowArn"), "output" (rawinput286037 "output")}] (clojure.core/cond-> {} (letvar286039 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286039 ["flowArn"]))) (letvar286039 "output") (clojure.core/assoc :output (deser-output (clojure.core/get-in letvar286039 ["output"])))))))

(clojure.core/defn- response-list-entitlements-response ([input] (response-list-entitlements-response nil input)) ([resultWrapper286041 input] (clojure.core/let [rawinput286040 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286042 {"entitlements" (rawinput286040 "entitlements"), "nextToken" (rawinput286040 "nextToken")}] (clojure.core/cond-> {} (letvar286042 "entitlements") (clojure.core/assoc :entitlements (deser-list-of-listed-entitlement (clojure.core/get-in letvar286042 ["entitlements"]))) (letvar286042 "nextToken") (clojure.core/assoc :next-token (deser-string (clojure.core/get-in letvar286042 ["nextToken"])))))))

(clojure.core/defn- response-revoke-flow-entitlement-response ([input] (response-revoke-flow-entitlement-response nil input)) ([resultWrapper286044 input] (clojure.core/let [rawinput286043 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286045 {"entitlementArn" (rawinput286043 "entitlementArn"), "flowArn" (rawinput286043 "flowArn")}] (clojure.core/cond-> {} (letvar286045 "entitlementArn") (clojure.core/assoc :entitlement-arn (deser-string (clojure.core/get-in letvar286045 ["entitlementArn"]))) (letvar286045 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286045 ["flowArn"])))))))

(clojure.core/defn- response-grant-flow-entitlements-420-exception ([input] (response-grant-flow-entitlements-420-exception nil input)) ([resultWrapper286047 input] (clojure.core/let [rawinput286046 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286048 {"message" (rawinput286046 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286048 ["message"]))}))))

(clojure.core/defn- response-start-flow-response ([input] (response-start-flow-response nil input)) ([resultWrapper286050 input] (clojure.core/let [rawinput286049 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286051 {"flowArn" (rawinput286049 "flowArn"), "status" (rawinput286049 "status")}] (clojure.core/cond-> {} (letvar286051 "flowArn") (clojure.core/assoc :flow-arn (deser-string (clojure.core/get-in letvar286051 ["flowArn"]))) (letvar286051 "status") (clojure.core/assoc :status (deser-status (clojure.core/get-in letvar286051 ["status"])))))))

(clojure.core/defn- response-add-flow-outputs-420-exception ([input] (response-add-flow-outputs-420-exception nil input)) ([resultWrapper286053 input] (clojure.core/let [rawinput286052 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar286054 {"message" (rawinput286052 "message")}] (clojure.core/cond-> {:message (deser-string (clojure.core/get-in letvar286054 ["message"]))}))))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.response-error/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/response-error (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.response-error/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.messages/errors (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/messages (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.messages/errors] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.internal-server-error-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.internal-server-error-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/availability-zone (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/entitlements (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-grant-entitlement-request))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/outputs (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-add-output-request))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/source (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/set-source-request))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/create-flow-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.create-flow-request/source :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/name] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.create-flow-request/availability-zone :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/entitlements :portkey.aws.mediaconnect.-2018-11-14.create-flow-request/outputs]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-response/output-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/remove-flow-output-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-response/output-arn]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/stream-id (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/max-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/destination (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/port (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-output-request/smoothing-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/add-output-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.add-output-request/destination :portkey.aws.mediaconnect.-2018-11-14.add-output-request/port :portkey.aws.mediaconnect.-2018-11-14/protocol] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.add-output-request/stream-id :portkey.aws.mediaconnect.-2018-11-14.add-output-request/max-latency :portkey.aws.mediaconnect.-2018-11-14.add-output-request/description :portkey.aws.mediaconnect.-2018-11-14/encryption :portkey.aws.mediaconnect.-2018-11-14.add-output-request/name :portkey.aws.mediaconnect.-2018-11-14.add-output-request/smoothing-latency]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-response/outputs (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-output))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-response/outputs]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-flows-response/flows (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-listed-flow))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-flows-response/next-token (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-flows-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.list-flows-response/flows :portkey.aws.mediaconnect.-2018-11-14.list-flows-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.bad-request-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.bad-request-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.listed-entitlement/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.listed-entitlement/entitlement-name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/listed-entitlement (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.listed-entitlement/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.listed-entitlement/entitlement-name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/stream-id (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/decryption (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/update-encryption))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/max-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/whitelist-cidr (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/source-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/ingest-port (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/max-bitrate (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-flow-source-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/source-arn] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/stream-id :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/decryption :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/max-latency :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/whitelist-cidr :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/description :portkey.aws.mediaconnect.-2018-11-14/protocol :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/ingest-port :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-request/max-bitrate]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-source-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-flow-source-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-source-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14/source]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-tags-for-resource-response/tags (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/map-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-tags-for-resource-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.list-tags-for-resource-response/tags]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/create-flow-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/flow]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-request/outputs (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-add-output-request))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-request/outputs] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/decryption (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/encryption))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/whitelist-cidr (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/source-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/ingest-ip (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/ingest-port (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.source/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/source (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.source/source-arn :portkey.aws.mediaconnect.-2018-11-14.source/name] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.source/decryption :portkey.aws.mediaconnect.-2018-11-14.source/whitelist-cidr :portkey.aws.mediaconnect.-2018-11-14/transport :portkey.aws.mediaconnect.-2018-11-14.source/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.source/description :portkey.aws.mediaconnect.-2018-11-14.source/ingest-ip :portkey.aws.mediaconnect.-2018-11-14.source/ingest-port]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-listed-entitlement (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/listed-entitlement))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-entitlement-request/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-entitlement-request/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-entitlement-request/subscribers (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/grant-entitlement-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.grant-entitlement-request/subscribers] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.grant-entitlement-request/description :portkey.aws.mediaconnect.-2018-11-14/encryption :portkey.aws.mediaconnect.-2018-11-14.grant-entitlement-request/name]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-listed-flow (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/listed-flow))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-tags-for-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-tags-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.list-tags-for-resource-request/resource-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.forbidden-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.forbidden-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/describe-flow-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/flow :portkey.aws.mediaconnect.-2018-11-14/messages]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.transport/max-bitrate (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.transport/max-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.transport/smoothing-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.transport/stream-id (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/transport (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14/protocol] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.transport/max-bitrate :portkey.aws.mediaconnect.-2018-11-14.transport/max-latency :portkey.aws.mediaconnect.-2018-11-14.transport/smoothing-latency :portkey.aws.mediaconnect.-2018-11-14.transport/stream-id]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/source-type #{"ENTITLED" "OWNED" :entitled :owned})

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.service-unavailable-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-entitlements-request/next-token (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-entitlements-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/max-results :portkey.aws.mediaconnect.-2018-11-14.list-entitlements-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/status #{:standby :starting "UPDATING" :deleting "ERROR" :stopping "STANDBY" "STARTING" :active "DELETING" "ACTIVE" :updating :error "STOPPING"})

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/stream-id (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/max-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/output-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/destination (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/port (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/encryption (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/update-encryption))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/smoothing-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-flow-output-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/output-arn] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/stream-id :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/max-latency :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/destination :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/description :portkey.aws.mediaconnect.-2018-11-14/protocol :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/port :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/encryption :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-request/smoothing-latency]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.describe-flow-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/describe-flow-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.describe-flow-request/flow-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.listed-flow/availability-zone (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.listed-flow/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.listed-flow/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.listed-flow/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/listed-flow (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14/status :portkey.aws.mediaconnect.-2018-11-14.listed-flow/description :portkey.aws.mediaconnect.-2018-11-14/source-type :portkey.aws.mediaconnect.-2018-11-14.listed-flow/availability-zone :portkey.aws.mediaconnect.-2018-11-14.listed-flow/flow-arn :portkey.aws.mediaconnect.-2018-11-14.listed-flow/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.too-many-requests-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.too-many-requests-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-encryption/role-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-encryption/secret-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-encryption (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/algorithm :portkey.aws.mediaconnect.-2018-11-14/key-type :portkey.aws.mediaconnect.-2018-11-14.update-encryption/role-arn :portkey.aws.mediaconnect.-2018-11-14.update-encryption/secret-arn]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.tag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.tag-resource-request/tags (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/map-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.tag-resource-request/resource-arn :portkey.aws.mediaconnect.-2018-11-14.tag-resource-request/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.delete-flow-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/delete-flow-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.delete-flow-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14/status]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-grant-entitlement-request (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/grant-entitlement-request))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/encryption (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/update-encryption))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/subscribers (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-flow-entitlement-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/entitlement-arn] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/description :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/encryption :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-request/subscribers]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.entitlement/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.entitlement/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.entitlement/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.entitlement/subscribers (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/entitlement (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.entitlement/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.entitlement/subscribers :portkey.aws.mediaconnect.-2018-11-14.entitlement/name] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.entitlement/description :portkey.aws.mediaconnect.-2018-11-14/encryption]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/algorithm #{:aes-128 :aes-256 "aes192" :aes-192 "aes256" "aes128"})

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-flow-entitlement-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/entitlement :portkey.aws.mediaconnect.-2018-11-14.update-flow-entitlement-response/flow-arn]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-string (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/string))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.stop-flow-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/stop-flow-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.stop-flow-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14/status]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-response/entitlements (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-entitlement))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-response/entitlements :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-response/flow-arn]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/protocol #{"rtp" :rtp :rtpfec "rtp-fec" "zixi-push" :zixipush})

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.create-flow-420-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/create-flow-420-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.create-flow-420-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.start-flow-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/start-flow-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.start-flow-request/flow-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.not-found-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/not-found-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.not-found-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-flows-request/next-token (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-flows-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/max-results :portkey.aws.mediaconnect.-2018-11-14.list-flows-request/next-token]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.update-flow-output-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/update-flow-output-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.update-flow-output-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14/output]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-output (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/output))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-entitlements-response/entitlements (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-listed-entitlement))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.list-entitlements-response/next-token (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-entitlements-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.list-entitlements-response/entitlements :portkey.aws.mediaconnect.-2018-11-14.list-entitlements-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-response/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/revoke-flow-entitlement-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-response/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-response/flow-arn]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-request/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/revoke-flow-entitlement-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.revoke-flow-entitlement-request/entitlement-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/timestamp-iso-8601 clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-request/output-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/remove-flow-output-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.remove-flow-output-request/output-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.delete-flow-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/delete-flow-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.delete-flow-request/flow-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/stream-id (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/decryption (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/encryption))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/max-latency (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/whitelist-cidr (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/ingest-port (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/max-bitrate (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.set-source-request/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/set-source-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.set-source-request/stream-id :portkey.aws.mediaconnect.-2018-11-14.set-source-request/decryption :portkey.aws.mediaconnect.-2018-11-14.set-source-request/max-latency :portkey.aws.mediaconnect.-2018-11-14.set-source-request/whitelist-cidr :portkey.aws.mediaconnect.-2018-11-14.set-source-request/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.set-source-request/description :portkey.aws.mediaconnect.-2018-11-14/protocol :portkey.aws.mediaconnect.-2018-11-14.set-source-request/ingest-port :portkey.aws.mediaconnect.-2018-11-14.set-source-request/max-bitrate :portkey.aws.mediaconnect.-2018-11-14.set-source-request/name]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.encryption/role-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.encryption/secret-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/encryption (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.encryption/secret-arn :portkey.aws.mediaconnect.-2018-11-14/algorithm :portkey.aws.mediaconnect.-2018-11-14.encryption/role-arn] :opt-un [:portkey.aws.mediaconnect.-2018-11-14/key-type]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/max-results (clojure.spec.alpha/int-in 1 1000))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/output-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/destination (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/media-live-input-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/entitlement-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/port (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/integer))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.output/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/output (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.output/output-arn :portkey.aws.mediaconnect.-2018-11-14.output/name] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.output/destination :portkey.aws.mediaconnect.-2018-11-14.output/media-live-input-arn :portkey.aws.mediaconnect.-2018-11-14/transport :portkey.aws.mediaconnect.-2018-11-14.output/entitlement-arn :portkey.aws.mediaconnect.-2018-11-14.output/description :portkey.aws.mediaconnect.-2018-11-14.output/port :portkey.aws.mediaconnect.-2018-11-14/encryption]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/timestamp-unix clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-420-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-420-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-420-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.stop-flow-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/stop-flow-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.stop-flow-request/flow-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-entitlement (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/entitlement))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.start-flow-response/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/start-flow-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.start-flow-response/flow-arn :portkey.aws.mediaconnect.-2018-11-14/status]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-420-exception/message (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-420-exception (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.add-flow-outputs-420-exception/message] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/key-type #{:statickey "static-key"})

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.untag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.untag-resource-request/tag-keys :portkey.aws.mediaconnect.-2018-11-14.untag-resource-request/resource-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/map-of-string (clojure.spec.alpha/map-of :portkey.aws.mediaconnect.-2018-11-14/string :portkey.aws.mediaconnect.-2018-11-14/string))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/availability-zone (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/outputs (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-output))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/description (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/egress-ip (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/name (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.flow/entitlements (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-entitlement))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/flow (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14/status :portkey.aws.mediaconnect.-2018-11-14.flow/entitlements :portkey.aws.mediaconnect.-2018-11-14.flow/outputs :portkey.aws.mediaconnect.-2018-11-14.flow/availability-zone :portkey.aws.mediaconnect.-2018-11-14.flow/flow-arn :portkey.aws.mediaconnect.-2018-11-14/source :portkey.aws.mediaconnect.-2018-11-14.flow/name] :opt-un [:portkey.aws.mediaconnect.-2018-11-14.flow/description :portkey.aws.mediaconnect.-2018-11-14.flow/egress-ip]))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/list-of-add-output-request (clojure.spec.alpha/coll-of :portkey.aws.mediaconnect.-2018-11-14/add-output-request))

(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-request/entitlements (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-of-grant-entitlement-request))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-request/flow-arn (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/string))
(clojure.spec.alpha/def :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-request (clojure.spec.alpha/keys :req-un [:portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-request/flow-arn :portkey.aws.mediaconnect.-2018-11-14.grant-flow-entitlements-request/entitlements] :opt-un []))

(clojure.core/defn grant-flow-entitlements "Grants entitlements to an existing flow." ([grant-flow-entitlements-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-grant-flow-entitlements-request grant-flow-entitlements-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/entitlements", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GrantFlowEntitlements", :http.request.configuration/output-deser-fn response-grant-flow-entitlements-response, :http.request.spec/error-spec {"GrantFlowEntitlements420Exception" :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-420-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef grant-flow-entitlements :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/grant-flow-entitlements-response))

(clojure.core/defn tag-resource "Associates the specified tags to a resource. If the request does not mention an\nexisting tag associated with the resource, that tag is not changed." ([tag-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resourceArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/tag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/tag-resource-request) :ret clojure.core/true?)

(clojure.core/defn add-flow-outputs "Adds outputs to an existing flow. You can create up to 20 outputs per flow." ([add-flow-outputs-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-add-flow-outputs-request add-flow-outputs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/outputs", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "AddFlowOutputs", :http.request.configuration/output-deser-fn response-add-flow-outputs-response, :http.request.spec/error-spec {"AddFlowOutputs420Exception" :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-420-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef add-flow-outputs :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/add-flow-outputs-response))

(clojure.core/defn stop-flow "Stops a flow." ([stop-flow-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-stop-flow-request stop-flow-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/stop-flow-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/stop/{flowArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/stop-flow-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StopFlow", :http.request.configuration/output-deser-fn response-stop-flow-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef stop-flow :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/stop-flow-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/stop-flow-response))

(clojure.core/defn delete-flow "Deletes a flow. Before you can delete a flow, you must stop the flow." ([delete-flow-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-delete-flow-request delete-flow-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/delete-flow-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/delete-flow-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteFlow", :http.request.configuration/output-deser-fn response-delete-flow-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-flow :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/delete-flow-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/delete-flow-response))

(clojure.core/defn list-entitlements "Displays a list of all entitlements that have been granted to this account. This\nrequest returns 20 results per page." ([] (list-entitlements {})) ([list-entitlements-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-entitlements-request list-entitlements-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/list-entitlements-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/entitlements", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/list-entitlements-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListEntitlements", :http.request.configuration/output-deser-fn response-list-entitlements-response, :http.request.spec/error-spec {"ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception}})))))
(clojure.spec.alpha/fdef list-entitlements :args (clojure.spec.alpha/? :portkey.aws.mediaconnect.-2018-11-14/list-entitlements-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-entitlements-response))

(clojure.core/defn list-flows "Displays a list of flows that are associated with this account. This request\nreturns a paginated result." ([] (list-flows {})) ([list-flows-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-flows-request list-flows-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/list-flows-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/list-flows-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListFlows", :http.request.configuration/output-deser-fn response-list-flows-response, :http.request.spec/error-spec {"ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception}})))))
(clojure.spec.alpha/fdef list-flows :args (clojure.spec.alpha/? :portkey.aws.mediaconnect.-2018-11-14/list-flows-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-flows-response))

(clojure.core/defn remove-flow-output "Removes an output from an existing flow. This request can be made only on an\noutput that does not have an entitlement associated with it. If the output has\nan entitlement, you must revoke the entitlement instead. When an entitlement is\nrevoked from a flow, the service automatically removes the associated output." ([remove-flow-output-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-remove-flow-output-request remove-flow-output-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/remove-flow-output-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/outputs/{outputArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/remove-flow-output-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveFlowOutput", :http.request.configuration/output-deser-fn response-remove-flow-output-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef remove-flow-output :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/remove-flow-output-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/remove-flow-output-response))

(clojure.core/defn list-tags-for-resource "Lists all tags associated with the resource." ([list-tags-for-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-list-tags-for-resource-request list-tags-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/list-tags-for-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resourceArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/list-tags-for-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-list-tags-for-resource-response, :http.request.spec/error-spec {"NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/list-tags-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/list-tags-for-resource-response))

(clojure.core/defn update-flow-output "Updates an existing flow output." ([update-flow-output-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-flow-output-request update-flow-output-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/update-flow-output-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/outputs/{outputArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/update-flow-output-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateFlowOutput", :http.request.configuration/output-deser-fn response-update-flow-output-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-flow-output :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/update-flow-output-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/update-flow-output-response))

(clojure.core/defn revoke-flow-entitlement "Revokes an entitlement from a flow. Once an entitlement is revoked, the content\nbecomes unavailable to the subscriber and the associated output is removed." ([revoke-flow-entitlement-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-revoke-flow-entitlement-request revoke-flow-entitlement-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/revoke-flow-entitlement-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/entitlements/{entitlementArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/revoke-flow-entitlement-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RevokeFlowEntitlement", :http.request.configuration/output-deser-fn response-revoke-flow-entitlement-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef revoke-flow-entitlement :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/revoke-flow-entitlement-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/revoke-flow-entitlement-response))

(clojure.core/defn create-flow "Creates a new flow. The request must include one source. The request optionally\ncan include outputs (up to 20) and entitlements (up to 50)." ([create-flow-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-create-flow-request create-flow-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/create-flow-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/create-flow-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateFlow", :http.request.configuration/output-deser-fn response-create-flow-response, :http.request.spec/error-spec {"CreateFlow420Exception" :portkey.aws.mediaconnect.-2018-11-14/create-flow-420-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-flow :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/create-flow-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/create-flow-response))

(clojure.core/defn start-flow "Starts a flow." ([start-flow-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-start-flow-request start-flow-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/start-flow-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/start/{flowArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/start-flow-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "StartFlow", :http.request.configuration/output-deser-fn response-start-flow-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef start-flow :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/start-flow-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/start-flow-response))

(clojure.core/defn update-flow-entitlement "You can change an entitlement's description, subscribers, and encryption. If you\nchange the subscribers, the service will remove the outputs that are are used by\nthe subscribers that are removed." ([update-flow-entitlement-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-flow-entitlement-request update-flow-entitlement-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/update-flow-entitlement-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/entitlements/{entitlementArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/update-flow-entitlement-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateFlowEntitlement", :http.request.configuration/output-deser-fn response-update-flow-entitlement-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-flow-entitlement :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/update-flow-entitlement-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/update-flow-entitlement-response))

(clojure.core/defn untag-resource "Deletes the specified tags from a resource." ([untag-resource-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/tags/{resourceArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/untag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__22152__auto__] {}), :http.request.spec/error-spec {"NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/untag-resource-request) :ret clojure.core/true?)

(clojure.core/defn describe-flow "Displays the details of a flow. The response includes the flow ARN, name, and\nAvailability Zone, as well as details about the source, outputs, and\nentitlements." ([describe-flow-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-describe-flow-request describe-flow-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/describe-flow-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/describe-flow-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DescribeFlow", :http.request.configuration/output-deser-fn response-describe-flow-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef describe-flow :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/describe-flow-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/describe-flow-response))

(clojure.core/defn update-flow-source "Updates the source of a flow." ([update-flow-source-requestinput] (clojure.core/let [request-function-result__22153__auto__ (req-update-flow-source-request update-flow-source-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__22153__auto__ {:http.request.configuration/endpoints portkey.aws.mediaconnect.-2018-11-14/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.mediaconnect.-2018-11-14/update-flow-source-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/flows/{flowArn}/source/{sourceArn}", :http.request.configuration/version "2018-11-14", :http.request.configuration/service-id "MediaConnect", :http.request.spec/input-spec :portkey.aws.mediaconnect.-2018-11-14/update-flow-source-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateFlowSource", :http.request.configuration/output-deser-fn response-update-flow-source-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.mediaconnect.-2018-11-14/bad-request-exception, "InternalServerErrorException" :portkey.aws.mediaconnect.-2018-11-14/internal-server-error-exception, "ForbiddenException" :portkey.aws.mediaconnect.-2018-11-14/forbidden-exception, "NotFoundException" :portkey.aws.mediaconnect.-2018-11-14/not-found-exception, "ServiceUnavailableException" :portkey.aws.mediaconnect.-2018-11-14/service-unavailable-exception, "TooManyRequestsException" :portkey.aws.mediaconnect.-2018-11-14/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-flow-source :args (clojure.spec.alpha/tuple :portkey.aws.mediaconnect.-2018-11-14/update-flow-source-request) :ret (clojure.spec.alpha/and :portkey.aws.mediaconnect.-2018-11-14/update-flow-source-response))
