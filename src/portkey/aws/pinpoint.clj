(ns portkey.aws.pinpoint (:require [portkey.aws]))

(def
 endpoints
 '{"eu-west-1"
   {:credential-scope
    {:service "mobiletargeting", :region "eu-west-1"},
    :ssl-common-name "pinpoint.eu-west-1.amazonaws.com",
    :endpoint "https://pinpoint.eu-west-1.amazonaws.com",
    :signature-version :v4},
   "eu-central-1"
   {:credential-scope
    {:service "mobiletargeting", :region "eu-central-1"},
    :ssl-common-name "pinpoint.eu-central-1.amazonaws.com",
    :endpoint "https://pinpoint.eu-central-1.amazonaws.com",
    :signature-version :v4},
   "us-west-2"
   {:credential-scope
    {:service "mobiletargeting", :region "us-west-2"},
    :ssl-common-name "pinpoint.us-west-2.amazonaws.com",
    :endpoint "https://pinpoint.us-west-2.amazonaws.com",
    :signature-version :v4},
   "us-east-1"
   {:credential-scope
    {:service "mobiletargeting", :region "us-east-1"},
    :ssl-common-name "pinpoint.us-east-1.amazonaws.com",
    :endpoint "https://pinpoint.us-east-1.amazonaws.com",
    :signature-version :v4}})

(clojure.core/declare ser-attribute-type)

(clojure.core/declare ser-import-job-request)

(clojure.core/declare ser-raw-email)

(clojure.core/declare ser-segment-group-list)

(clojure.core/declare ser-simple-email-part)

(clojure.core/declare ser-write-campaign-request)

(clojure.core/declare ser-gcm-message)

(clojure.core/declare ser-voice-channel-request)

(clojure.core/declare ser-message-request)

(clojure.core/declare ser-campaign-limits)

(clojure.core/declare ser-quiet-time)

(clojure.core/declare ser-baidu-message)

(clojure.core/declare ser-simple-email)

(clojure.core/declare ser-type)

(clojure.core/declare ser-create-application-request)

(clojure.core/declare ser-attribute-dimension)

(clojure.core/declare ser-recency-type)

(clojure.core/declare ser-write-application-settings-request)

(clojure.core/declare ser-endpoint-user)

(clojure.core/declare ser-string)

(clojure.core/declare ser-campaign-event-filter)

(clojure.core/declare ser-map-of-events-batch)

(clojure.core/declare ser-apns-voip-sandbox-channel-request)

(clojure.core/declare ser-campaign-sms-message)

(clojure.core/declare ser-map-of-list-of-string)

(clojure.core/declare ser-endpoint-demographic)

(clojure.core/declare ser-source-type)

(clojure.core/declare ser-format)

(clojure.core/declare ser-event)

(clojure.core/declare ser-mode)

(clojure.core/declare ser-event-dimensions)

(clojure.core/declare ser-list-of-string)

(clojure.core/declare ser-list-of-endpoint-batch-item)

(clojure.core/declare ser-list-of-segment-dimensions)

(clojure.core/declare ser-endpoint-send-configuration)

(clojure.core/declare ser-baidu-channel-request)

(clojure.core/declare ser-write-event-stream)

(clojure.core/declare ser-map-of-metric-dimension)

(clojure.core/declare ser-boolean)

(clojure.core/declare ser-map-of-double)

(clojure.core/declare ser-email-channel-request)

(clojure.core/declare ser-number-validate-request)

(clojure.core/declare ser-set-dimension)

(clojure.core/declare ser-segment-behaviors)

(clojure.core/declare ser-export-job-request)

(clojure.core/declare ser-adm-message)

(clojure.core/declare ser-segment-dimensions)

(clojure.core/declare ser-default-message)

(clojure.core/declare ser-message)

(clojure.core/declare ser-map-of-address-configuration)

(clojure.core/declare ser-apns-channel-request)

(clojure.core/declare ser-dimension-type)

(clojure.core/declare ser-public-endpoint)

(clojure.core/declare ser-campaign-hook)

(clojure.core/declare ser-duration)

(clojure.core/declare ser-metric-dimension)

(clojure.core/declare ser-filter-type)

(clojure.core/declare ser-gps-point-dimension)

(clojure.core/declare ser-write-segment-request)

(clojure.core/declare ser-map-of-attribute-dimension)

(clojure.core/declare ser-endpoint-request)

(clojure.core/declare ser-endpoint-batch-request)

(clojure.core/declare ser-sms-channel-request)

(clojure.core/declare ser-recency-dimension)

(clojure.core/declare ser-address-configuration)

(clojure.core/declare ser-endpoint-batch-item)

(clojure.core/declare ser-list-of-write-treatment-resource)

(clojure.core/declare ser-write-treatment-resource)

(clojure.core/declare ser-list-of-segment-reference)

(clojure.core/declare ser-sms-message)

(clojure.core/declare ser-campaign-email-message)

(clojure.core/declare ser-include)

(clojure.core/declare ser-segment-reference)

(clojure.core/declare ser-message-configuration)

(clojure.core/declare ser-message-type)

(clojure.core/declare ser-events-request)

(clojure.core/declare ser-frequency)

(clojure.core/declare ser-double)

(clojure.core/declare ser-adm-channel-request)

(clojure.core/declare ser-map-of-event)

(clojure.core/declare ser-voice-message)

(clojure.core/declare ser-blob)

(clojure.core/declare ser-map-of-endpoint-send-configuration)

(clojure.core/declare ser-integer)

(clojure.core/declare ser-apns-voip-channel-request)

(clojure.core/declare ser-schedule)

(clojure.core/declare ser-segment-group)

(clojure.core/declare ser-default-push-notification-message)

(clojure.core/declare ser-apns-message)

(clojure.core/declare ser-list-of-segment-group)

(clojure.core/declare ser-direct-message-configuration)

(clojure.core/declare ser-apns-sandbox-channel-request)

(clojure.core/declare ser-send-users-message-request)

(clojure.core/declare ser-session)

(clojure.core/declare ser-gps-coordinates)

(clojure.core/declare ser-segment-location)

(clojure.core/declare ser-endpoint-location)

(clojure.core/declare ser-action)

(clojure.core/declare ser-tags-model)

(clojure.core/declare ser-update-attributes-request)

(clojure.core/declare ser-gcm-channel-request)

(clojure.core/declare ser-email-message)

(clojure.core/declare ser-map-of-string)

(clojure.core/declare ser-channel-type)

(clojure.core/declare ser-events-batch)

(clojure.core/declare ser-segment-demographics)

(clojure.core/defn- ser-attribute-type [input] #:http.request.field{:value (clojure.core/get {"INCLUSIVE" "INCLUSIVE", :inclusive "INCLUSIVE", "EXCLUSIVE" "EXCLUSIVE", :exclusive "EXCLUSIVE"} input), :shape "AttributeType"})

(clojure.core/defn- ser-import-job-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ImportJobRequest", :type "structure"} (clojure.core/contains? input :define-segment) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :define-segment)) #:http.request.field{:name "DefineSegment", :shape "__boolean"})) (clojure.core/contains? input :external-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :external-id)) #:http.request.field{:name "ExternalId", :shape "__string"})) (clojure.core/contains? input :format) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-format (input :format)) #:http.request.field{:name "Format", :shape "Format"})) (clojure.core/contains? input :register-endpoints) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :register-endpoints)) #:http.request.field{:name "RegisterEndpoints", :shape "__boolean"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-arn)) #:http.request.field{:name "RoleArn", :shape "__string"})) (clojure.core/contains? input :s-3-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-url)) #:http.request.field{:name "S3Url", :shape "__string"})) (clojure.core/contains? input :segment-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string"})) (clojure.core/contains? input :segment-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :segment-name)) #:http.request.field{:name "SegmentName", :shape "__string"}))))

(clojure.core/defn- ser-raw-email [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RawEmail", :type "structure"} (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-blob (input :data)) #:http.request.field{:name "Data", :shape "__blob"}))))

(clojure.core/defn- ser-segment-group-list [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentGroupList", :type "structure"} (clojure.core/contains? input :groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-segment-group (input :groups)) #:http.request.field{:name "Groups", :shape "ListOfSegmentGroup"})) (clojure.core/contains? input :include) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-include (input :include)) #:http.request.field{:name "Include", :shape "Include"}))))

(clojure.core/defn- ser-simple-email-part [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SimpleEmailPart", :type "structure"} (clojure.core/contains? input :charset) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :charset)) #:http.request.field{:name "Charset", :shape "__string"})) (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :data)) #:http.request.field{:name "Data", :shape "__string"}))))

(clojure.core/defn- ser-write-campaign-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "WriteCampaignRequest", :type "structure"} (clojure.core/contains? input :additional-treatments) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-write-treatment-resource (input :additional-treatments)) #:http.request.field{:name "AdditionalTreatments", :shape "ListOfWriteTreatmentResource"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOf__string", :location-name "tags"})) (clojure.core/contains? input :treatment-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :treatment-description)) #:http.request.field{:name "TreatmentDescription", :shape "__string"})) (clojure.core/contains? input :treatment-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :treatment-name)) #:http.request.field{:name "TreatmentName", :shape "__string"})) (clojure.core/contains? input :limits) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-limits (input :limits)) #:http.request.field{:name "Limits", :shape "CampaignLimits"})) (clojure.core/contains? input :segment-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :segment-version)) #:http.request.field{:name "SegmentVersion", :shape "__integer"})) (clojure.core/contains? input :description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :description)) #:http.request.field{:name "Description", :shape "__string"})) (clojure.core/contains? input :is-paused) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :is-paused)) #:http.request.field{:name "IsPaused", :shape "__boolean"})) (clojure.core/contains? input :hook) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-hook (input :hook)) #:http.request.field{:name "Hook", :shape "CampaignHook"})) (clojure.core/contains? input :message-configuration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-configuration (input :message-configuration)) #:http.request.field{:name "MessageConfiguration", :shape "MessageConfiguration"})) (clojure.core/contains? input :segment-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string"})) (clojure.core/contains? input :schedule) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule (input :schedule)) #:http.request.field{:name "Schedule", :shape "Schedule"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string"})) (clojure.core/contains? input :holdout-percent) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :holdout-percent)) #:http.request.field{:name "HoldoutPercent", :shape "__integer"}))))

(clojure.core/defn- ser-gcm-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "GCMMessage", :type "structure"} (clojure.core/contains? input :collapse-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :collapse-key)) #:http.request.field{:name "CollapseKey", :shape "__string"})) (clojure.core/contains? input :restricted-package-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :restricted-package-name)) #:http.request.field{:name "RestrictedPackageName", :shape "__string"})) (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :image-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-url)) #:http.request.field{:name "ImageUrl", :shape "__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"})) (clojure.core/contains? input :silent-push) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :silent-push)) #:http.request.field{:name "SilentPush", :shape "__boolean"})) (clojure.core/contains? input :sound) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sound)) #:http.request.field{:name "Sound", :shape "__string"})) (clojure.core/contains? input :time-to-live) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :time-to-live)) #:http.request.field{:name "TimeToLive", :shape "__integer"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :priority)) #:http.request.field{:name "Priority", :shape "__string"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :small-image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :small-image-icon-url)) #:http.request.field{:name "SmallImageIconUrl", :shape "__string"})) (clojure.core/contains? input :icon-reference) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :icon-reference)) #:http.request.field{:name "IconReference", :shape "__string"})) (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :data)) #:http.request.field{:name "Data", :shape "MapOf__string"})) (clojure.core/contains? input :image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-icon-url)) #:http.request.field{:name "ImageIconUrl", :shape "__string"})) (clojure.core/contains? input :action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :action)) #:http.request.field{:name "Action", :shape "Action"}))))

(clojure.core/defn- ser-voice-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "VoiceChannelRequest", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"}))))

(clojure.core/defn- ser-message-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MessageRequest", :type "structure"} (clojure.core/contains? input :addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-address-configuration (input :addresses)) #:http.request.field{:name "Addresses", :shape "MapOfAddressConfiguration"})) (clojure.core/contains? input :context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :context)) #:http.request.field{:name "Context", :shape "MapOf__string"})) (clojure.core/contains? input :endpoints) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-endpoint-send-configuration (input :endpoints)) #:http.request.field{:name "Endpoints", :shape "MapOfEndpointSendConfiguration"})) (clojure.core/contains? input :message-configuration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-direct-message-configuration (input :message-configuration)) #:http.request.field{:name "MessageConfiguration", :shape "DirectMessageConfiguration"})) (clojure.core/contains? input :trace-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :trace-id)) #:http.request.field{:name "TraceId", :shape "__string"}))))

(clojure.core/defn- ser-campaign-limits [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CampaignLimits", :type "structure"} (clojure.core/contains? input :daily) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :daily)) #:http.request.field{:name "Daily", :shape "__integer"})) (clojure.core/contains? input :maximum-duration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :maximum-duration)) #:http.request.field{:name "MaximumDuration", :shape "__integer"})) (clojure.core/contains? input :messages-per-second) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :messages-per-second)) #:http.request.field{:name "MessagesPerSecond", :shape "__integer"})) (clojure.core/contains? input :total) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :total)) #:http.request.field{:name "Total", :shape "__integer"}))))

(clojure.core/defn- ser-quiet-time [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "QuietTime", :type "structure"} (clojure.core/contains? input :end) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :end)) #:http.request.field{:name "End", :shape "__string"})) (clojure.core/contains? input :start) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :start)) #:http.request.field{:name "Start", :shape "__string"}))))

(clojure.core/defn- ser-baidu-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BaiduMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :image-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-url)) #:http.request.field{:name "ImageUrl", :shape "__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"})) (clojure.core/contains? input :silent-push) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :silent-push)) #:http.request.field{:name "SilentPush", :shape "__boolean"})) (clojure.core/contains? input :sound) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sound)) #:http.request.field{:name "Sound", :shape "__string"})) (clojure.core/contains? input :time-to-live) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :time-to-live)) #:http.request.field{:name "TimeToLive", :shape "__integer"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :small-image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :small-image-icon-url)) #:http.request.field{:name "SmallImageIconUrl", :shape "__string"})) (clojure.core/contains? input :icon-reference) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :icon-reference)) #:http.request.field{:name "IconReference", :shape "__string"})) (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :data)) #:http.request.field{:name "Data", :shape "MapOf__string"})) (clojure.core/contains? input :image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-icon-url)) #:http.request.field{:name "ImageIconUrl", :shape "__string"})) (clojure.core/contains? input :action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :action)) #:http.request.field{:name "Action", :shape "Action"}))))

(clojure.core/defn- ser-simple-email [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SimpleEmail", :type "structure"} (clojure.core/contains? input :html-part) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-simple-email-part (input :html-part)) #:http.request.field{:name "HtmlPart", :shape "SimpleEmailPart"})) (clojure.core/contains? input :subject) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-simple-email-part (input :subject)) #:http.request.field{:name "Subject", :shape "SimpleEmailPart"})) (clojure.core/contains? input :text-part) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-simple-email-part (input :text-part)) #:http.request.field{:name "TextPart", :shape "SimpleEmailPart"}))))

(clojure.core/defn- ser-type [input] #:http.request.field{:value (clojure.core/get {"ALL" "ALL", :all "ALL", "ANY" "ANY", :any "ANY", "NONE" "NONE", :none "NONE"} input), :shape "Type"})

(clojure.core/defn- ser-create-application-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CreateApplicationRequest", :type "structure"} (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOf__string", :location-name "tags"}))))

(clojure.core/defn- ser-attribute-dimension [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AttributeDimension", :type "structure"} (clojure.core/contains? input :attribute-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-attribute-type (input :attribute-type)) #:http.request.field{:name "AttributeType", :shape "AttributeType"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :values)) #:http.request.field{:name "Values", :shape "ListOf__string"}))))

(clojure.core/defn- ser-recency-type [input] #:http.request.field{:value (clojure.core/get {"ACTIVE" "ACTIVE", :active "ACTIVE", "INACTIVE" "INACTIVE", :inactive "INACTIVE"} input), :shape "RecencyType"})

(clojure.core/defn- ser-write-application-settings-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "WriteApplicationSettingsRequest", :type "structure"} (clojure.core/contains? input :campaign-hook) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-hook (input :campaign-hook)) #:http.request.field{:name "CampaignHook", :shape "CampaignHook"})) (clojure.core/contains? input :cloud-watch-metrics-enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :cloud-watch-metrics-enabled)) #:http.request.field{:name "CloudWatchMetricsEnabled", :shape "__boolean"})) (clojure.core/contains? input :limits) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-limits (input :limits)) #:http.request.field{:name "Limits", :shape "CampaignLimits"})) (clojure.core/contains? input :quiet-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-quiet-time (input :quiet-time)) #:http.request.field{:name "QuietTime", :shape "QuietTime"}))))

(clojure.core/defn- ser-endpoint-user [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointUser", :type "structure"} (clojure.core/contains? input :user-attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :user-attributes)) #:http.request.field{:name "UserAttributes", :shape "MapOfListOf__string"})) (clojure.core/contains? input :user-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "__string"}))))

(clojure.core/defn- ser-string [input] #:http.request.field{:value input, :shape "__string"})

(clojure.core/defn- ser-campaign-event-filter [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CampaignEventFilter", :type "structure"} (clojure.core/contains? input :dimensions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-event-dimensions (input :dimensions)) #:http.request.field{:name "Dimensions", :shape "EventDimensions"})) (clojure.core/contains? input :filter-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-filter-type (input :filter-type)) #:http.request.field{:name "FilterType", :shape "FilterType"}))))

(clojure.core/defn- ser-map-of-events-batch [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-events-batch v) #:http.request.field{:map-info "value", :shape "EventsBatch"})])) input), :shape "MapOfEventsBatch", :type "map"})

(clojure.core/defn- ser-apns-voip-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "APNSVoipSandboxChannelRequest", :type "structure"} (clojure.core/contains? input :bundle-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :bundle-id)) #:http.request.field{:name "BundleId", :shape "__string"})) (clojure.core/contains? input :certificate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate)) #:http.request.field{:name "Certificate", :shape "__string"})) (clojure.core/contains? input :default-authentication-method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :default-authentication-method)) #:http.request.field{:name "DefaultAuthenticationMethod", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :private-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-key)) #:http.request.field{:name "PrivateKey", :shape "__string"})) (clojure.core/contains? input :team-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :team-id)) #:http.request.field{:name "TeamId", :shape "__string"})) (clojure.core/contains? input :token-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key)) #:http.request.field{:name "TokenKey", :shape "__string"})) (clojure.core/contains? input :token-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key-id)) #:http.request.field{:name "TokenKeyId", :shape "__string"}))))

(clojure.core/defn- ser-campaign-sms-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CampaignSmsMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :message-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-type (input :message-type)) #:http.request.field{:name "MessageType", :shape "MessageType"})) (clojure.core/contains? input :sender-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sender-id)) #:http.request.field{:name "SenderId", :shape "__string"}))))

(clojure.core/defn- ser-map-of-list-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-list-of-string v) #:http.request.field{:map-info "value", :shape "ListOf__string"})])) input), :shape "MapOfListOf__string", :type "map"})

(clojure.core/defn- ser-endpoint-demographic [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointDemographic", :type "structure"} (clojure.core/contains? input :app-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :app-version)) #:http.request.field{:name "AppVersion", :shape "__string"})) (clojure.core/contains? input :locale) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :locale)) #:http.request.field{:name "Locale", :shape "__string"})) (clojure.core/contains? input :make) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :make)) #:http.request.field{:name "Make", :shape "__string"})) (clojure.core/contains? input :model) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :model)) #:http.request.field{:name "Model", :shape "__string"})) (clojure.core/contains? input :model-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :model-version)) #:http.request.field{:name "ModelVersion", :shape "__string"})) (clojure.core/contains? input :platform) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :platform)) #:http.request.field{:name "Platform", :shape "__string"})) (clojure.core/contains? input :platform-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :platform-version)) #:http.request.field{:name "PlatformVersion", :shape "__string"})) (clojure.core/contains? input :timezone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :timezone)) #:http.request.field{:name "Timezone", :shape "__string"}))))

(clojure.core/defn- ser-source-type [input] #:http.request.field{:value (clojure.core/get {"ALL" "ALL", :all "ALL", "ANY" "ANY", :any "ANY", "NONE" "NONE", :none "NONE"} input), :shape "SourceType"})

(clojure.core/defn- ser-format [input] #:http.request.field{:value (clojure.core/get {"CSV" "CSV", :csv "CSV", "JSON" "JSON", :json "JSON"} input), :shape "Format"})

(clojure.core/defn- ser-event [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Event", :type "structure"} (clojure.core/contains? input :client-sdk-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-sdk-version)) #:http.request.field{:name "ClientSdkVersion", :shape "__string"})) (clojure.core/contains? input :sdk-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sdk-name)) #:http.request.field{:name "SdkName", :shape "__string"})) (clojure.core/contains? input :event-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :event-type)) #:http.request.field{:name "EventType", :shape "__string"})) (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :attributes)) #:http.request.field{:name "Attributes", :shape "MapOf__string"})) (clojure.core/contains? input :app-title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :app-title)) #:http.request.field{:name "AppTitle", :shape "__string"})) (clojure.core/contains? input :app-package-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :app-package-name)) #:http.request.field{:name "AppPackageName", :shape "__string"})) (clojure.core/contains? input :timestamp) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :timestamp)) #:http.request.field{:name "Timestamp", :shape "__string"})) (clojure.core/contains? input :app-version-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :app-version-code)) #:http.request.field{:name "AppVersionCode", :shape "__string"})) (clojure.core/contains? input :session) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-session (input :session)) #:http.request.field{:name "Session", :shape "Session"})) (clojure.core/contains? input :metrics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-double (input :metrics)) #:http.request.field{:name "Metrics", :shape "MapOf__double"}))))

(clojure.core/defn- ser-mode [input] #:http.request.field{:value (clojure.core/get {"DELIVERY" "DELIVERY", :delivery "DELIVERY", "FILTER" "FILTER", :filter "FILTER"} input), :shape "Mode"})

(clojure.core/defn- ser-event-dimensions [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EventDimensions", :type "structure"} (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-attribute-dimension (input :attributes)) #:http.request.field{:name "Attributes", :shape "MapOfAttributeDimension"})) (clojure.core/contains? input :event-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :event-type)) #:http.request.field{:name "EventType", :shape "SetDimension"})) (clojure.core/contains? input :metrics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-metric-dimension (input :metrics)) #:http.request.field{:name "Metrics", :shape "MapOfMetricDimension"}))))

(clojure.core/defn- ser-list-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-string coll) #:http.request.field{:shape "__string"}))) input), :shape "ListOf__string", :type "list"})

(clojure.core/defn- ser-list-of-endpoint-batch-item [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-endpoint-batch-item coll) #:http.request.field{:shape "EndpointBatchItem"}))) input), :shape "ListOfEndpointBatchItem", :type "list"})

(clojure.core/defn- ser-list-of-segment-dimensions [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-segment-dimensions coll) #:http.request.field{:shape "SegmentDimensions"}))) input), :shape "ListOfSegmentDimensions", :type "list"})

(clojure.core/defn- ser-endpoint-send-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointSendConfiguration", :type "structure"} (clojure.core/contains? input :body-override) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body-override)) #:http.request.field{:name "BodyOverride", :shape "__string"})) (clojure.core/contains? input :context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :context)) #:http.request.field{:name "Context", :shape "MapOf__string"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :title-override) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title-override)) #:http.request.field{:name "TitleOverride", :shape "__string"}))))

(clojure.core/defn- ser-baidu-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "BaiduChannelRequest", :type "structure"} (clojure.core/contains? input :api-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "ApiKey", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :secret-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :secret-key)) #:http.request.field{:name "SecretKey", :shape "__string"}))))

(clojure.core/defn- ser-write-event-stream [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "WriteEventStream", :type "structure"} (clojure.core/contains? input :destination-stream-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :destination-stream-arn)) #:http.request.field{:name "DestinationStreamArn", :shape "__string"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-arn)) #:http.request.field{:name "RoleArn", :shape "__string"}))))

(clojure.core/defn- ser-map-of-metric-dimension [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-metric-dimension v) #:http.request.field{:map-info "value", :shape "MetricDimension"})])) input), :shape "MapOfMetricDimension", :type "map"})

(clojure.core/defn- ser-boolean [input] #:http.request.field{:value input, :shape "__boolean"})

(clojure.core/defn- ser-map-of-double [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-double v) #:http.request.field{:map-info "value", :shape "__double"})])) input), :shape "MapOf__double", :type "map"})

(clojure.core/defn- ser-email-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EmailChannelRequest", :type "structure"} (clojure.core/contains? input :configuration-set) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :configuration-set)) #:http.request.field{:name "ConfigurationSet", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :from-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :from-address)) #:http.request.field{:name "FromAddress", :shape "__string"})) (clojure.core/contains? input :identity) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :identity)) #:http.request.field{:name "Identity", :shape "__string"})) (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-arn)) #:http.request.field{:name "RoleArn", :shape "__string"}))))

(clojure.core/defn- ser-number-validate-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "NumberValidateRequest", :type "structure"} (clojure.core/contains? input :iso-country-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :iso-country-code)) #:http.request.field{:name "IsoCountryCode", :shape "__string"})) (clojure.core/contains? input :phone-number) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :phone-number)) #:http.request.field{:name "PhoneNumber", :shape "__string"}))))

(clojure.core/defn- ser-set-dimension [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SetDimension", :type "structure"} (clojure.core/contains? input :dimension-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-dimension-type (input :dimension-type)) #:http.request.field{:name "DimensionType", :shape "DimensionType"})) (clojure.core/contains? input :values) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :values)) #:http.request.field{:name "Values", :shape "ListOf__string"}))))

(clojure.core/defn- ser-segment-behaviors [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentBehaviors", :type "structure"} (clojure.core/contains? input :recency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recency-dimension (input :recency)) #:http.request.field{:name "Recency", :shape "RecencyDimension"}))))

(clojure.core/defn- ser-export-job-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ExportJobRequest", :type "structure"} (clojure.core/contains? input :role-arn) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :role-arn)) #:http.request.field{:name "RoleArn", :shape "__string"})) (clojure.core/contains? input :s-3-url-prefix) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :s-3-url-prefix)) #:http.request.field{:name "S3UrlPrefix", :shape "__string"})) (clojure.core/contains? input :segment-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string"})) (clojure.core/contains? input :segment-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :segment-version)) #:http.request.field{:name "SegmentVersion", :shape "__integer"}))))

(clojure.core/defn- ser-adm-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ADMMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :image-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-url)) #:http.request.field{:name "ImageUrl", :shape "__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"})) (clojure.core/contains? input :silent-push) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :silent-push)) #:http.request.field{:name "SilentPush", :shape "__boolean"})) (clojure.core/contains? input :consolidation-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :consolidation-key)) #:http.request.field{:name "ConsolidationKey", :shape "__string"})) (clojure.core/contains? input :sound) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sound)) #:http.request.field{:name "Sound", :shape "__string"})) (clojure.core/contains? input :expires-after) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :expires-after)) #:http.request.field{:name "ExpiresAfter", :shape "__string"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :small-image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :small-image-icon-url)) #:http.request.field{:name "SmallImageIconUrl", :shape "__string"})) (clojure.core/contains? input :icon-reference) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :icon-reference)) #:http.request.field{:name "IconReference", :shape "__string"})) (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :data)) #:http.request.field{:name "Data", :shape "MapOf__string"})) (clojure.core/contains? input :image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-icon-url)) #:http.request.field{:name "ImageIconUrl", :shape "__string"})) (clojure.core/contains? input :action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :action)) #:http.request.field{:name "Action", :shape "Action"})) (clojure.core/contains? input :md-5) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :md-5)) #:http.request.field{:name "MD5", :shape "__string"}))))

(clojure.core/defn- ser-segment-dimensions [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentDimensions", :type "structure"} (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-attribute-dimension (input :attributes)) #:http.request.field{:name "Attributes", :shape "MapOfAttributeDimension"})) (clojure.core/contains? input :behavior) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-segment-behaviors (input :behavior)) #:http.request.field{:name "Behavior", :shape "SegmentBehaviors"})) (clojure.core/contains? input :demographic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-segment-demographics (input :demographic)) #:http.request.field{:name "Demographic", :shape "SegmentDemographics"})) (clojure.core/contains? input :location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-segment-location (input :location)) #:http.request.field{:name "Location", :shape "SegmentLocation"})) (clojure.core/contains? input :metrics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-metric-dimension (input :metrics)) #:http.request.field{:name "Metrics", :shape "MapOfMetricDimension"})) (clojure.core/contains? input :user-attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-attribute-dimension (input :user-attributes)) #:http.request.field{:name "UserAttributes", :shape "MapOfAttributeDimension"}))))

(clojure.core/defn- ser-default-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DefaultMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"}))))

(clojure.core/defn- ser-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Message", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :image-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-url)) #:http.request.field{:name "ImageUrl", :shape "__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"})) (clojure.core/contains? input :silent-push) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :silent-push)) #:http.request.field{:name "SilentPush", :shape "__boolean"})) (clojure.core/contains? input :time-to-live) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :time-to-live)) #:http.request.field{:name "TimeToLive", :shape "__integer"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "__string"})) (clojure.core/contains? input :json-body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :json-body)) #:http.request.field{:name "JsonBody", :shape "__string"})) (clojure.core/contains? input :image-small-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-small-icon-url)) #:http.request.field{:name "ImageSmallIconUrl", :shape "__string"})) (clojure.core/contains? input :media-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :media-url)) #:http.request.field{:name "MediaUrl", :shape "__string"})) (clojure.core/contains? input :image-icon-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :image-icon-url)) #:http.request.field{:name "ImageIconUrl", :shape "__string"})) (clojure.core/contains? input :action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :action)) #:http.request.field{:name "Action", :shape "Action"}))))

(clojure.core/defn- ser-map-of-address-configuration [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-address-configuration v) #:http.request.field{:map-info "value", :shape "AddressConfiguration"})])) input), :shape "MapOfAddressConfiguration", :type "map"})

(clojure.core/defn- ser-apns-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "APNSChannelRequest", :type "structure"} (clojure.core/contains? input :bundle-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :bundle-id)) #:http.request.field{:name "BundleId", :shape "__string"})) (clojure.core/contains? input :certificate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate)) #:http.request.field{:name "Certificate", :shape "__string"})) (clojure.core/contains? input :default-authentication-method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :default-authentication-method)) #:http.request.field{:name "DefaultAuthenticationMethod", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :private-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-key)) #:http.request.field{:name "PrivateKey", :shape "__string"})) (clojure.core/contains? input :team-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :team-id)) #:http.request.field{:name "TeamId", :shape "__string"})) (clojure.core/contains? input :token-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key)) #:http.request.field{:name "TokenKey", :shape "__string"})) (clojure.core/contains? input :token-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key-id)) #:http.request.field{:name "TokenKeyId", :shape "__string"}))))

(clojure.core/defn- ser-dimension-type [input] #:http.request.field{:value (clojure.core/get {"INCLUSIVE" "INCLUSIVE", :inclusive "INCLUSIVE", "EXCLUSIVE" "EXCLUSIVE", :exclusive "EXCLUSIVE"} input), :shape "DimensionType"})

(clojure.core/defn- ser-public-endpoint [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "PublicEndpoint", :type "structure"} (clojure.core/contains? input :address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :address)) #:http.request.field{:name "Address", :shape "__string"})) (clojure.core/contains? input :endpoint-status) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :endpoint-status)) #:http.request.field{:name "EndpointStatus", :shape "__string"})) (clojure.core/contains? input :request-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :request-id)) #:http.request.field{:name "RequestId", :shape "__string"})) (clojure.core/contains? input :location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-location (input :location)) #:http.request.field{:name "Location", :shape "EndpointLocation"})) (clojure.core/contains? input :demographic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-demographic (input :demographic)) #:http.request.field{:name "Demographic", :shape "EndpointDemographic"})) (clojure.core/contains? input :user) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-user (input :user)) #:http.request.field{:name "User", :shape "EndpointUser"})) (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :attributes)) #:http.request.field{:name "Attributes", :shape "MapOfListOf__string"})) (clojure.core/contains? input :effective-date) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :effective-date)) #:http.request.field{:name "EffectiveDate", :shape "__string"})) (clojure.core/contains? input :opt-out) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :opt-out)) #:http.request.field{:name "OptOut", :shape "__string"})) (clojure.core/contains? input :channel-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-channel-type (input :channel-type)) #:http.request.field{:name "ChannelType", :shape "ChannelType"})) (clojure.core/contains? input :metrics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-double (input :metrics)) #:http.request.field{:name "Metrics", :shape "MapOf__double"}))))

(clojure.core/defn- ser-campaign-hook [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CampaignHook", :type "structure"} (clojure.core/contains? input :lambda-function-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :lambda-function-name)) #:http.request.field{:name "LambdaFunctionName", :shape "__string"})) (clojure.core/contains? input :mode) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-mode (input :mode)) #:http.request.field{:name "Mode", :shape "Mode"})) (clojure.core/contains? input :web-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :web-url)) #:http.request.field{:name "WebUrl", :shape "__string"}))))

(clojure.core/defn- ser-duration [input] #:http.request.field{:value (clojure.core/get {"HR_24" "HR_24", :hr-24 "HR_24", "DAY_7" "DAY_7", :day-7 "DAY_7", "DAY_14" "DAY_14", :day-14 "DAY_14", "DAY_30" "DAY_30", :day-30 "DAY_30"} input), :shape "Duration"})

(clojure.core/defn- ser-metric-dimension [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MetricDimension", :type "structure"} (clojure.core/contains? input :comparison-operator) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :comparison-operator)) #:http.request.field{:name "ComparisonOperator", :shape "__string"})) (clojure.core/contains? input :value) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :value)) #:http.request.field{:name "Value", :shape "__double"}))))

(clojure.core/defn- ser-filter-type [input] #:http.request.field{:value (clojure.core/get {"SYSTEM" "SYSTEM", :system "SYSTEM", "ENDPOINT" "ENDPOINT", :endpoint "ENDPOINT"} input), :shape "FilterType"})

(clojure.core/defn- ser-gps-point-dimension [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "GPSPointDimension", :type "structure"} (clojure.core/contains? input :coordinates) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-gps-coordinates (input :coordinates)) #:http.request.field{:name "Coordinates", :shape "GPSCoordinates"})) (clojure.core/contains? input :range-in-kilometers) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :range-in-kilometers)) #:http.request.field{:name "RangeInKilometers", :shape "__double"}))))

(clojure.core/defn- ser-write-segment-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "WriteSegmentRequest", :type "structure"} (clojure.core/contains? input :dimensions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-segment-dimensions (input :dimensions)) #:http.request.field{:name "Dimensions", :shape "SegmentDimensions"})) (clojure.core/contains? input :name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :name)) #:http.request.field{:name "Name", :shape "__string"})) (clojure.core/contains? input :segment-groups) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-segment-group-list (input :segment-groups)) #:http.request.field{:name "SegmentGroups", :shape "SegmentGroupList"})) (clojure.core/contains? input :tags) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :tags)) #:http.request.field{:name "tags", :shape "MapOf__string", :location-name "tags"}))))

(clojure.core/defn- ser-map-of-attribute-dimension [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-attribute-dimension v) #:http.request.field{:map-info "value", :shape "AttributeDimension"})])) input), :shape "MapOfAttributeDimension", :type "map"})

(clojure.core/defn- ser-endpoint-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointRequest", :type "structure"} (clojure.core/contains? input :address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :address)) #:http.request.field{:name "Address", :shape "__string"})) (clojure.core/contains? input :endpoint-status) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :endpoint-status)) #:http.request.field{:name "EndpointStatus", :shape "__string"})) (clojure.core/contains? input :request-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :request-id)) #:http.request.field{:name "RequestId", :shape "__string"})) (clojure.core/contains? input :location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-location (input :location)) #:http.request.field{:name "Location", :shape "EndpointLocation"})) (clojure.core/contains? input :demographic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-demographic (input :demographic)) #:http.request.field{:name "Demographic", :shape "EndpointDemographic"})) (clojure.core/contains? input :user) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-user (input :user)) #:http.request.field{:name "User", :shape "EndpointUser"})) (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :attributes)) #:http.request.field{:name "Attributes", :shape "MapOfListOf__string"})) (clojure.core/contains? input :effective-date) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :effective-date)) #:http.request.field{:name "EffectiveDate", :shape "__string"})) (clojure.core/contains? input :opt-out) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :opt-out)) #:http.request.field{:name "OptOut", :shape "__string"})) (clojure.core/contains? input :channel-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-channel-type (input :channel-type)) #:http.request.field{:name "ChannelType", :shape "ChannelType"})) (clojure.core/contains? input :metrics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-double (input :metrics)) #:http.request.field{:name "Metrics", :shape "MapOf__double"}))))

(clojure.core/defn- ser-endpoint-batch-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointBatchRequest", :type "structure"} (clojure.core/contains? input :item) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-endpoint-batch-item (input :item)) #:http.request.field{:name "Item", :shape "ListOfEndpointBatchItem"}))))

(clojure.core/defn- ser-sms-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SMSChannelRequest", :type "structure"} (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :sender-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sender-id)) #:http.request.field{:name "SenderId", :shape "__string"})) (clojure.core/contains? input :short-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :short-code)) #:http.request.field{:name "ShortCode", :shape "__string"}))))

(clojure.core/defn- ser-recency-dimension [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "RecencyDimension", :type "structure"} (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-duration (input :duration)) #:http.request.field{:name "Duration", :shape "Duration"})) (clojure.core/contains? input :recency-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-recency-type (input :recency-type)) #:http.request.field{:name "RecencyType", :shape "RecencyType"}))))

(clojure.core/defn- ser-address-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "AddressConfiguration", :type "structure"} (clojure.core/contains? input :body-override) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body-override)) #:http.request.field{:name "BodyOverride", :shape "__string"})) (clojure.core/contains? input :channel-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-channel-type (input :channel-type)) #:http.request.field{:name "ChannelType", :shape "ChannelType"})) (clojure.core/contains? input :context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :context)) #:http.request.field{:name "Context", :shape "MapOf__string"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :title-override) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title-override)) #:http.request.field{:name "TitleOverride", :shape "__string"}))))

(clojure.core/defn- ser-endpoint-batch-item [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointBatchItem", :type "structure"} (clojure.core/contains? input :address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :address)) #:http.request.field{:name "Address", :shape "__string"})) (clojure.core/contains? input :endpoint-status) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :endpoint-status)) #:http.request.field{:name "EndpointStatus", :shape "__string"})) (clojure.core/contains? input :request-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :request-id)) #:http.request.field{:name "RequestId", :shape "__string"})) (clojure.core/contains? input :location) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-location (input :location)) #:http.request.field{:name "Location", :shape "EndpointLocation"})) (clojure.core/contains? input :demographic) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-demographic (input :demographic)) #:http.request.field{:name "Demographic", :shape "EndpointDemographic"})) (clojure.core/contains? input :user) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-endpoint-user (input :user)) #:http.request.field{:name "User", :shape "EndpointUser"})) (clojure.core/contains? input :attributes) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :attributes)) #:http.request.field{:name "Attributes", :shape "MapOfListOf__string"})) (clojure.core/contains? input :effective-date) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :effective-date)) #:http.request.field{:name "EffectiveDate", :shape "__string"})) (clojure.core/contains? input :opt-out) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :opt-out)) #:http.request.field{:name "OptOut", :shape "__string"})) (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :id)) #:http.request.field{:name "Id", :shape "__string"})) (clojure.core/contains? input :channel-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-channel-type (input :channel-type)) #:http.request.field{:name "ChannelType", :shape "ChannelType"})) (clojure.core/contains? input :metrics) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-double (input :metrics)) #:http.request.field{:name "Metrics", :shape "MapOf__double"}))))

(clojure.core/defn- ser-list-of-write-treatment-resource [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-write-treatment-resource coll) #:http.request.field{:shape "WriteTreatmentResource"}))) input), :shape "ListOfWriteTreatmentResource", :type "list"})

(clojure.core/defn- ser-write-treatment-resource [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "WriteTreatmentResource", :type "structure"} (clojure.core/contains? input :message-configuration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-configuration (input :message-configuration)) #:http.request.field{:name "MessageConfiguration", :shape "MessageConfiguration"})) (clojure.core/contains? input :schedule) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-schedule (input :schedule)) #:http.request.field{:name "Schedule", :shape "Schedule"})) (clojure.core/contains? input :size-percent) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :size-percent)) #:http.request.field{:name "SizePercent", :shape "__integer"})) (clojure.core/contains? input :treatment-description) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :treatment-description)) #:http.request.field{:name "TreatmentDescription", :shape "__string"})) (clojure.core/contains? input :treatment-name) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :treatment-name)) #:http.request.field{:name "TreatmentName", :shape "__string"}))))

(clojure.core/defn- ser-list-of-segment-reference [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-segment-reference coll) #:http.request.field{:shape "SegmentReference"}))) input), :shape "ListOfSegmentReference", :type "list"})

(clojure.core/defn- ser-sms-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SMSMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :keyword) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :keyword)) #:http.request.field{:name "Keyword", :shape "__string"})) (clojure.core/contains? input :message-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message-type (input :message-type)) #:http.request.field{:name "MessageType", :shape "MessageType"})) (clojure.core/contains? input :origination-number) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :origination-number)) #:http.request.field{:name "OriginationNumber", :shape "__string"})) (clojure.core/contains? input :sender-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sender-id)) #:http.request.field{:name "SenderId", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"}))))

(clojure.core/defn- ser-campaign-email-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "CampaignEmailMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :from-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :from-address)) #:http.request.field{:name "FromAddress", :shape "__string"})) (clojure.core/contains? input :html-body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :html-body)) #:http.request.field{:name "HtmlBody", :shape "__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"}))))

(clojure.core/defn- ser-include [input] #:http.request.field{:value (clojure.core/get {"ALL" "ALL", :all "ALL", "ANY" "ANY", :any "ANY", "NONE" "NONE", :none "NONE"} input), :shape "Include"})

(clojure.core/defn- ser-segment-reference [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentReference", :type "structure"} (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :id)) #:http.request.field{:name "Id", :shape "__string"})) (clojure.core/contains? input :version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :version)) #:http.request.field{:name "Version", :shape "__integer"}))))

(clojure.core/defn- ser-message-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "MessageConfiguration", :type "structure"} (clojure.core/contains? input :adm-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :adm-message)) #:http.request.field{:name "ADMMessage", :shape "Message"})) (clojure.core/contains? input :apns-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :apns-message)) #:http.request.field{:name "APNSMessage", :shape "Message"})) (clojure.core/contains? input :baidu-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :baidu-message)) #:http.request.field{:name "BaiduMessage", :shape "Message"})) (clojure.core/contains? input :default-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :default-message)) #:http.request.field{:name "DefaultMessage", :shape "Message"})) (clojure.core/contains? input :email-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-email-message (input :email-message)) #:http.request.field{:name "EmailMessage", :shape "CampaignEmailMessage"})) (clojure.core/contains? input :gcm-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-message (input :gcm-message)) #:http.request.field{:name "GCMMessage", :shape "Message"})) (clojure.core/contains? input :sms-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-sms-message (input :sms-message)) #:http.request.field{:name "SMSMessage", :shape "CampaignSmsMessage"}))))

(clojure.core/defn- ser-message-type [input] #:http.request.field{:value (clojure.core/get {"TRANSACTIONAL" "TRANSACTIONAL", :transactional "TRANSACTIONAL", "PROMOTIONAL" "PROMOTIONAL", :promotional "PROMOTIONAL"} input), :shape "MessageType"})

(clojure.core/defn- ser-events-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EventsRequest", :type "structure"} (clojure.core/contains? input :batch-item) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-events-batch (input :batch-item)) #:http.request.field{:name "BatchItem", :shape "MapOfEventsBatch"}))))

(clojure.core/defn- ser-frequency [input] #:http.request.field{:value (clojure.core/get {:daily "DAILY", "EVENT" "EVENT", "ONCE" "ONCE", :monthly "MONTHLY", "MONTHLY" "MONTHLY", "WEEKLY" "WEEKLY", :event "EVENT", :hourly "HOURLY", :once "ONCE", "DAILY" "DAILY", :weekly "WEEKLY", "HOURLY" "HOURLY"} input), :shape "Frequency"})

(clojure.core/defn- ser-double [input] #:http.request.field{:value input, :shape "__double"})

(clojure.core/defn- ser-adm-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "ADMChannelRequest", :type "structure"} (clojure.core/contains? input :client-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-id)) #:http.request.field{:name "ClientId", :shape "__string"})) (clojure.core/contains? input :client-secret) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :client-secret)) #:http.request.field{:name "ClientSecret", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"}))))

(clojure.core/defn- ser-map-of-event [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-event v) #:http.request.field{:map-info "value", :shape "Event"})])) input), :shape "MapOfEvent", :type "map"})

(clojure.core/defn- ser-voice-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "VoiceMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :language-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :language-code)) #:http.request.field{:name "LanguageCode", :shape "__string"})) (clojure.core/contains? input :origination-number) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :origination-number)) #:http.request.field{:name "OriginationNumber", :shape "__string"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :voice-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :voice-id)) #:http.request.field{:name "VoiceId", :shape "__string"}))))

(clojure.core/defn- ser-blob [input] #:http.request.field{:value (portkey.aws/base64-encode input), :shape "__blob"})

(clojure.core/defn- ser-map-of-endpoint-send-configuration [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-endpoint-send-configuration v) #:http.request.field{:map-info "value", :shape "EndpointSendConfiguration"})])) input), :shape "MapOfEndpointSendConfiguration", :type "map"})

(clojure.core/defn- ser-integer [input] #:http.request.field{:value input, :shape "__integer"})

(clojure.core/defn- ser-apns-voip-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "APNSVoipChannelRequest", :type "structure"} (clojure.core/contains? input :bundle-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :bundle-id)) #:http.request.field{:name "BundleId", :shape "__string"})) (clojure.core/contains? input :certificate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate)) #:http.request.field{:name "Certificate", :shape "__string"})) (clojure.core/contains? input :default-authentication-method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :default-authentication-method)) #:http.request.field{:name "DefaultAuthenticationMethod", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :private-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-key)) #:http.request.field{:name "PrivateKey", :shape "__string"})) (clojure.core/contains? input :team-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :team-id)) #:http.request.field{:name "TeamId", :shape "__string"})) (clojure.core/contains? input :token-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key)) #:http.request.field{:name "TokenKey", :shape "__string"})) (clojure.core/contains? input :token-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key-id)) #:http.request.field{:name "TokenKeyId", :shape "__string"}))))

(clojure.core/defn- ser-schedule [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Schedule", :type "structure"} (clojure.core/contains? input :end-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :end-time)) #:http.request.field{:name "EndTime", :shape "__string"})) (clojure.core/contains? input :event-filter) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-campaign-event-filter (input :event-filter)) #:http.request.field{:name "EventFilter", :shape "CampaignEventFilter"})) (clojure.core/contains? input :frequency) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-frequency (input :frequency)) #:http.request.field{:name "Frequency", :shape "Frequency"})) (clojure.core/contains? input :is-local-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :is-local-time)) #:http.request.field{:name "IsLocalTime", :shape "__boolean"})) (clojure.core/contains? input :quiet-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-quiet-time (input :quiet-time)) #:http.request.field{:name "QuietTime", :shape "QuietTime"})) (clojure.core/contains? input :start-time) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :start-time)) #:http.request.field{:name "StartTime", :shape "__string"})) (clojure.core/contains? input :timezone) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :timezone)) #:http.request.field{:name "Timezone", :shape "__string"}))))

(clojure.core/defn- ser-segment-group [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentGroup", :type "structure"} (clojure.core/contains? input :dimensions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-segment-dimensions (input :dimensions)) #:http.request.field{:name "Dimensions", :shape "ListOfSegmentDimensions"})) (clojure.core/contains? input :source-segments) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-segment-reference (input :source-segments)) #:http.request.field{:name "SourceSegments", :shape "ListOfSegmentReference"})) (clojure.core/contains? input :source-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-source-type (input :source-type)) #:http.request.field{:name "SourceType", :shape "SourceType"})) (clojure.core/contains? input :type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-type (input :type)) #:http.request.field{:name "Type", :shape "Type"}))))

(clojure.core/defn- ser-default-push-notification-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DefaultPushNotificationMessage", :type "structure"} (clojure.core/contains? input :action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :action)) #:http.request.field{:name "Action", :shape "Action"})) (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :data)) #:http.request.field{:name "Data", :shape "MapOf__string"})) (clojure.core/contains? input :silent-push) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :silent-push)) #:http.request.field{:name "SilentPush", :shape "__boolean"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "__string"}))))

(clojure.core/defn- ser-apns-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "APNSMessage", :type "structure"} (clojure.core/contains? input :category) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :category)) #:http.request.field{:name "Category", :shape "__string"})) (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :title) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :title)) #:http.request.field{:name "Title", :shape "__string"})) (clojure.core/contains? input :silent-push) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :silent-push)) #:http.request.field{:name "SilentPush", :shape "__boolean"})) (clojure.core/contains? input :sound) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :sound)) #:http.request.field{:name "Sound", :shape "__string"})) (clojure.core/contains? input :time-to-live) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :time-to-live)) #:http.request.field{:name "TimeToLive", :shape "__integer"})) (clojure.core/contains? input :priority) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :priority)) #:http.request.field{:name "Priority", :shape "__string"})) (clojure.core/contains? input :raw-content) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :raw-content)) #:http.request.field{:name "RawContent", :shape "__string"})) (clojure.core/contains? input :thread-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :thread-id)) #:http.request.field{:name "ThreadId", :shape "__string"})) (clojure.core/contains? input :url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :url)) #:http.request.field{:name "Url", :shape "__string"})) (clojure.core/contains? input :badge) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :badge)) #:http.request.field{:name "Badge", :shape "__integer"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"})) (clojure.core/contains? input :data) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :data)) #:http.request.field{:name "Data", :shape "MapOf__string"})) (clojure.core/contains? input :media-url) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :media-url)) #:http.request.field{:name "MediaUrl", :shape "__string"})) (clojure.core/contains? input :collapse-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :collapse-id)) #:http.request.field{:name "CollapseId", :shape "__string"})) (clojure.core/contains? input :action) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-action (input :action)) #:http.request.field{:name "Action", :shape "Action"})) (clojure.core/contains? input :preferred-authentication-method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :preferred-authentication-method)) #:http.request.field{:name "PreferredAuthenticationMethod", :shape "__string"}))))

(clojure.core/defn- ser-list-of-segment-group [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (clojure.core/merge (ser-segment-group coll) #:http.request.field{:shape "SegmentGroup"}))) input), :shape "ListOfSegmentGroup", :type "list"})

(clojure.core/defn- ser-direct-message-configuration [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "DirectMessageConfiguration", :type "structure"} (clojure.core/contains? input :gcm-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-gcm-message (input :gcm-message)) #:http.request.field{:name "GCMMessage", :shape "GCMMessage"})) (clojure.core/contains? input :baidu-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-baidu-message (input :baidu-message)) #:http.request.field{:name "BaiduMessage", :shape "BaiduMessage"})) (clojure.core/contains? input :adm-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-adm-message (input :adm-message)) #:http.request.field{:name "ADMMessage", :shape "ADMMessage"})) (clojure.core/contains? input :default-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-message (input :default-message)) #:http.request.field{:name "DefaultMessage", :shape "DefaultMessage"})) (clojure.core/contains? input :sms-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-sms-message (input :sms-message)) #:http.request.field{:name "SMSMessage", :shape "SMSMessage"})) (clojure.core/contains? input :voice-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-voice-message (input :voice-message)) #:http.request.field{:name "VoiceMessage", :shape "VoiceMessage"})) (clojure.core/contains? input :default-push-notification-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-default-push-notification-message (input :default-push-notification-message)) #:http.request.field{:name "DefaultPushNotificationMessage", :shape "DefaultPushNotificationMessage"})) (clojure.core/contains? input :apns-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-apns-message (input :apns-message)) #:http.request.field{:name "APNSMessage", :shape "APNSMessage"})) (clojure.core/contains? input :email-message) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-email-message (input :email-message)) #:http.request.field{:name "EmailMessage", :shape "EmailMessage"}))))

(clojure.core/defn- ser-apns-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "APNSSandboxChannelRequest", :type "structure"} (clojure.core/contains? input :bundle-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :bundle-id)) #:http.request.field{:name "BundleId", :shape "__string"})) (clojure.core/contains? input :certificate) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :certificate)) #:http.request.field{:name "Certificate", :shape "__string"})) (clojure.core/contains? input :default-authentication-method) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :default-authentication-method)) #:http.request.field{:name "DefaultAuthenticationMethod", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"})) (clojure.core/contains? input :private-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :private-key)) #:http.request.field{:name "PrivateKey", :shape "__string"})) (clojure.core/contains? input :team-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :team-id)) #:http.request.field{:name "TeamId", :shape "__string"})) (clojure.core/contains? input :token-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key)) #:http.request.field{:name "TokenKey", :shape "__string"})) (clojure.core/contains? input :token-key-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token-key-id)) #:http.request.field{:name "TokenKeyId", :shape "__string"}))))

(clojure.core/defn- ser-send-users-message-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SendUsersMessageRequest", :type "structure"} (clojure.core/contains? input :context) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-string (input :context)) #:http.request.field{:name "Context", :shape "MapOf__string"})) (clojure.core/contains? input :message-configuration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-direct-message-configuration (input :message-configuration)) #:http.request.field{:name "MessageConfiguration", :shape "DirectMessageConfiguration"})) (clojure.core/contains? input :trace-id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :trace-id)) #:http.request.field{:name "TraceId", :shape "__string"})) (clojure.core/contains? input :users) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-endpoint-send-configuration (input :users)) #:http.request.field{:name "Users", :shape "MapOfEndpointSendConfiguration"}))))

(clojure.core/defn- ser-session [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "Session", :type "structure"} (clojure.core/contains? input :duration) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-integer (input :duration)) #:http.request.field{:name "Duration", :shape "__integer"})) (clojure.core/contains? input :id) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :id)) #:http.request.field{:name "Id", :shape "__string"})) (clojure.core/contains? input :start-timestamp) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :start-timestamp)) #:http.request.field{:name "StartTimestamp", :shape "__string"})) (clojure.core/contains? input :stop-timestamp) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :stop-timestamp)) #:http.request.field{:name "StopTimestamp", :shape "__string"}))))

(clojure.core/defn- ser-gps-coordinates [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "GPSCoordinates", :type "structure"} (clojure.core/contains? input :latitude) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :latitude)) #:http.request.field{:name "Latitude", :shape "__double"})) (clojure.core/contains? input :longitude) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :longitude)) #:http.request.field{:name "Longitude", :shape "__double"}))))

(clojure.core/defn- ser-segment-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentLocation", :type "structure"} (clojure.core/contains? input :country) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :country)) #:http.request.field{:name "Country", :shape "SetDimension"})) (clojure.core/contains? input :gps-point) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-gps-point-dimension (input :gps-point)) #:http.request.field{:name "GPSPoint", :shape "GPSPointDimension"}))))

(clojure.core/defn- ser-endpoint-location [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EndpointLocation", :type "structure"} (clojure.core/contains? input :city) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :city)) #:http.request.field{:name "City", :shape "__string"})) (clojure.core/contains? input :country) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :country)) #:http.request.field{:name "Country", :shape "__string"})) (clojure.core/contains? input :latitude) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :latitude)) #:http.request.field{:name "Latitude", :shape "__double"})) (clojure.core/contains? input :longitude) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-double (input :longitude)) #:http.request.field{:name "Longitude", :shape "__double"})) (clojure.core/contains? input :postal-code) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :postal-code)) #:http.request.field{:name "PostalCode", :shape "__string"})) (clojure.core/contains? input :region) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :region)) #:http.request.field{:name "Region", :shape "__string"}))))

(clojure.core/defn- ser-action [input] #:http.request.field{:value (clojure.core/get {"OPEN_APP" "OPEN_APP", :open-app "OPEN_APP", "DEEP_LINK" "DEEP_LINK", :deep-link "DEEP_LINK", "URL" "URL", :url "URL"} input), :shape "Action"})

(clojure.core/defn- ser-tags-model [input] (clojure.core/cond-> #:http.request.field{:value [(clojure.core/into (ser-map-of-string (:tags input)) #:http.request.field{:name "tags", :shape "MapOf__string", :location-name "tags"})], :shape "TagsModel", :type "structure"}))

(clojure.core/defn- ser-update-attributes-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "UpdateAttributesRequest", :type "structure"} (clojure.core/contains? input :blacklist) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :blacklist)) #:http.request.field{:name "Blacklist", :shape "ListOf__string"}))))

(clojure.core/defn- ser-gcm-channel-request [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "GCMChannelRequest", :type "structure"} (clojure.core/contains? input :api-key) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :api-key)) #:http.request.field{:name "ApiKey", :shape "__string"})) (clojure.core/contains? input :enabled) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-boolean (input :enabled)) #:http.request.field{:name "Enabled", :shape "__boolean"}))))

(clojure.core/defn- ser-email-message [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EmailMessage", :type "structure"} (clojure.core/contains? input :body) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :body)) #:http.request.field{:name "Body", :shape "__string"})) (clojure.core/contains? input :feedback-forwarding-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :feedback-forwarding-address)) #:http.request.field{:name "FeedbackForwardingAddress", :shape "__string"})) (clojure.core/contains? input :from-address) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :from-address)) #:http.request.field{:name "FromAddress", :shape "__string"})) (clojure.core/contains? input :raw-email) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-raw-email (input :raw-email)) #:http.request.field{:name "RawEmail", :shape "RawEmail"})) (clojure.core/contains? input :reply-to-addresses) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-list-of-string (input :reply-to-addresses)) #:http.request.field{:name "ReplyToAddresses", :shape "ListOf__string"})) (clojure.core/contains? input :simple-email) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-simple-email (input :simple-email)) #:http.request.field{:name "SimpleEmail", :shape "SimpleEmail"})) (clojure.core/contains? input :substitutions) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-list-of-string (input :substitutions)) #:http.request.field{:name "Substitutions", :shape "MapOfListOf__string"}))))

(clojure.core/defn- ser-map-of-string [input] #:http.request.field{:value (clojure.core/into [] (clojure.core/map (clojure.core/fn [[k v]] [(clojure.core/into (ser-string k) #:http.request.field{:map-info "key", :shape "__string"}) (clojure.core/into (ser-string v) #:http.request.field{:map-info "value", :shape "__string"})])) input), :shape "MapOf__string", :type "map"})

(clojure.core/defn- ser-channel-type [input] #:http.request.field{:value (clojure.core/get {"VOICE" "VOICE", :email "EMAIL", "CUSTOM" "CUSTOM", "SMS" "SMS", "APNS_VOIP" "APNS_VOIP", "ADM" "ADM", "BAIDU" "BAIDU", "GCM" "GCM", "APNS" "APNS", :custom "CUSTOM", :voice "VOICE", :apns-voip "APNS_VOIP", :apns-sandbox "APNS_SANDBOX", "APNS_VOIP_SANDBOX" "APNS_VOIP_SANDBOX", :gcm "GCM", :sms "SMS", :adm "ADM", "APNS_SANDBOX" "APNS_SANDBOX", "EMAIL" "EMAIL", :baidu "BAIDU", :apns-voip-sandbox "APNS_VOIP_SANDBOX", :apns "APNS"} input), :shape "ChannelType"})

(clojure.core/defn- ser-events-batch [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "EventsBatch", :type "structure"} (clojure.core/contains? input :endpoint) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-public-endpoint (input :endpoint)) #:http.request.field{:name "Endpoint", :shape "PublicEndpoint"})) (clojure.core/contains? input :events) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-map-of-event (input :events)) #:http.request.field{:name "Events", :shape "MapOfEvent"}))))

(clojure.core/defn- ser-segment-demographics [input] (clojure.core/cond-> #:http.request.field{:value [], :shape "SegmentDemographics", :type "structure"} (clojure.core/contains? input :app-version) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :app-version)) #:http.request.field{:name "AppVersion", :shape "SetDimension"})) (clojure.core/contains? input :channel) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :channel)) #:http.request.field{:name "Channel", :shape "SetDimension"})) (clojure.core/contains? input :device-type) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :device-type)) #:http.request.field{:name "DeviceType", :shape "SetDimension"})) (clojure.core/contains? input :make) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :make)) #:http.request.field{:name "Make", :shape "SetDimension"})) (clojure.core/contains? input :model) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :model)) #:http.request.field{:name "Model", :shape "SetDimension"})) (clojure.core/contains? input :platform) (clojure.core/update-in [:http.request.field/value] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-set-dimension (input :platform)) #:http.request.field{:name "Platform", :shape "SetDimension"}))))

(clojure.core/defn- req-update-apns-voip-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-apns-voip-sandbox-channel-request (input :apns-voip-sandbox-channel-request)) #:http.request.field{:name "APNSVoipSandboxChannelRequest", :shape "APNSVoipSandboxChannelRequest"})]}))

(clojure.core/defn- req-delete-gcm-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-delete-baidu-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-voice-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-voice-channel-request (input :voice-channel-request)) #:http.request.field{:name "VoiceChannelRequest", :shape "VoiceChannelRequest"})]}))

(clojure.core/defn- req-create-export-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-export-job-request (input :export-job-request)) #:http.request.field{:name "ExportJobRequest", :shape "ExportJobRequest"})]}))

(clojure.core/defn- req-get-segment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-campaign-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :version)) #:http.request.field{:name "Version", :shape "__string", :location "uri", :location-name "version"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :campaign-id)) #:http.request.field{:name "CampaignId", :shape "__string", :location "uri", :location-name "campaign-id"})]}))

(clojure.core/defn- req-phone-number-validate-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-number-validate-request (input :number-validate-request)) #:http.request.field{:name "NumberValidateRequest", :shape "NumberValidateRequest"})]}))

(clojure.core/defn- req-create-campaign-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-write-campaign-request (input :write-campaign-request)) #:http.request.field{:name "WriteCampaignRequest", :shape "WriteCampaignRequest"})]}))

(clojure.core/defn- req-delete-apns-voip-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-create-app-request [input] (clojure.core/cond-> #:http.request.configuration{:body [(clojure.core/into (ser-create-application-request (input :create-application-request)) #:http.request.field{:name "CreateApplicationRequest", :shape "CreateApplicationRequest"})]}))

(clojure.core/defn- req-get-gcm-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-voice-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-delete-apns-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-apns-voip-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-apns-voip-channel-request (input :apns-voip-channel-request)) #:http.request.field{:name "APNSVoipChannelRequest", :shape "APNSVoipChannelRequest"})]}))

(clojure.core/defn- req-get-adm-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-segment-import-jobs-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-list-tags-for-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "__string", :location "uri", :location-name "resource-arn"})]}))

(clojure.core/defn- req-get-import-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :job-id)) #:http.request.field{:name "JobId", :shape "__string", :location "uri", :location-name "job-id"})]}))

(clojure.core/defn- req-get-apns-voip-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-apns-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-apns-channel-request (input :apns-channel-request)) #:http.request.field{:name "APNSChannelRequest", :shape "APNSChannelRequest"})]}))

(clojure.core/defn- req-update-adm-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-adm-channel-request (input :adm-channel-request)) #:http.request.field{:name "ADMChannelRequest", :shape "ADMChannelRequest"})]}))

(clojure.core/defn- req-get-event-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-email-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-email-channel-request (input :email-channel-request)) #:http.request.field{:name "EmailChannelRequest", :shape "EmailChannelRequest"})]}))

(clojure.core/defn- req-delete-apns-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-delete-voice-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-delete-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :endpoint-id)) #:http.request.field{:name "EndpointId", :shape "__string", :location "uri", :location-name "endpoint-id"})]}))

(clojure.core/defn- req-update-gcm-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-gcm-channel-request (input :gcm-channel-request)) #:http.request.field{:name "GCMChannelRequest", :shape "GCMChannelRequest"})]}))

(clojure.core/defn- req-update-apns-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-apns-sandbox-channel-request (input :apns-sandbox-channel-request)) #:http.request.field{:name "APNSSandboxChannelRequest", :shape "APNSSandboxChannelRequest"})]}))

(clojure.core/defn- req-get-export-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :job-id)) #:http.request.field{:name "JobId", :shape "__string", :location "uri", :location-name "job-id"})]}))

(clojure.core/defn- req-tag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "__string", :location "uri", :location-name "resource-arn"})], :body [(clojure.core/into (ser-tags-model (input :tags-model)) #:http.request.field{:name "TagsModel", :shape "TagsModel"})]}))

(clojure.core/defn- req-get-apns-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-delete-apns-voip-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :endpoint-id)) #:http.request.field{:name "EndpointId", :shape "__string", :location "uri", :location-name "endpoint-id"})]}))

(clojure.core/defn- req-get-segments-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-get-apns-sandbox-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-segment-export-jobs-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-get-channels-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-send-messages-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-message-request (input :message-request)) #:http.request.field{:name "MessageRequest", :shape "MessageRequest"})]}))

(clojure.core/defn- req-get-apns-voip-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-sms-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-sms-channel-request (input :sms-channel-request)) #:http.request.field{:name "SMSChannelRequest", :shape "SMSChannelRequest"})]}))

(clojure.core/defn- req-update-baidu-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-baidu-channel-request (input :baidu-channel-request)) #:http.request.field{:name "BaiduChannelRequest", :shape "BaiduChannelRequest"})]}))

(clojure.core/defn- req-get-email-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-endpoints-batch-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-endpoint-batch-request (input :endpoint-batch-request)) #:http.request.field{:name "EndpointBatchRequest", :shape "EndpointBatchRequest"})]}))

(clojure.core/defn- req-delete-app-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-put-event-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-write-event-stream (input :write-event-stream)) #:http.request.field{:name "WriteEventStream", :shape "WriteEventStream"})]}))

(clojure.core/defn- req-get-campaign-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :campaign-id)) #:http.request.field{:name "CampaignId", :shape "__string", :location "uri", :location-name "campaign-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-delete-email-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-segment-version-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :version)) #:http.request.field{:name "Version", :shape "__string", :location "uri", :location-name "version"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-export-jobs-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-update-application-settings-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-write-application-settings-request (input :write-application-settings-request)) #:http.request.field{:name "WriteApplicationSettingsRequest", :shape "WriteApplicationSettingsRequest"})]}))

(clojure.core/defn- req-delete-segment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-app-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-application-settings-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-segment-versions-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-get-apps-request [input] (clojure.core/cond-> {} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-send-users-messages-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-send-users-message-request (input :send-users-message-request)) #:http.request.field{:name "SendUsersMessageRequest", :shape "SendUsersMessageRequest"})]}))

(clojure.core/defn- req-get-user-endpoints-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "__string", :location "uri", :location-name "user-id"})]}))

(clojure.core/defn- req-get-campaigns-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-get-campaign-activities-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :campaign-id)) #:http.request.field{:name "CampaignId", :shape "__string", :location "uri", :location-name "campaign-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-create-import-job-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-import-job-request (input :import-job-request)) #:http.request.field{:name "ImportJobRequest", :shape "ImportJobRequest"})]}))

(clojure.core/defn- req-update-segment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :segment-id)) #:http.request.field{:name "SegmentId", :shape "__string", :location "uri", :location-name "segment-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-write-segment-request (input :write-segment-request)) #:http.request.field{:name "WriteSegmentRequest", :shape "WriteSegmentRequest"})]}))

(clojure.core/defn- req-delete-sms-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-update-endpoint-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :endpoint-id)) #:http.request.field{:name "EndpointId", :shape "__string", :location "uri", :location-name "endpoint-id"})], :body [(clojure.core/into (ser-endpoint-request (input :endpoint-request)) #:http.request.field{:name "EndpointRequest", :shape "EndpointRequest"})]}))

(clojure.core/defn- req-put-events-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-events-request (input :events-request)) #:http.request.field{:name "EventsRequest", :shape "EventsRequest"})]}))

(clojure.core/defn- req-create-segment-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-write-segment-request (input :write-segment-request)) #:http.request.field{:name "WriteSegmentRequest", :shape "WriteSegmentRequest"})]}))

(clojure.core/defn- req-get-baidu-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-delete-user-endpoints-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"}) (clojure.core/into (ser-string (input :user-id)) #:http.request.field{:name "UserId", :shape "__string", :location "uri", :location-name "user-id"})]}))

(clojure.core/defn- req-delete-campaign-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :campaign-id)) #:http.request.field{:name "CampaignId", :shape "__string", :location "uri", :location-name "campaign-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-campaign-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :campaign-id)) #:http.request.field{:name "CampaignId", :shape "__string", :location "uri", :location-name "campaign-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-sms-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-remove-attributes-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :attribute-type)) #:http.request.field{:name "AttributeType", :shape "__string", :location "uri", :location-name "attribute-type"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-update-attributes-request (input :update-attributes-request)) #:http.request.field{:name "UpdateAttributesRequest", :shape "UpdateAttributesRequest"})]}))

(clojure.core/defn- req-delete-adm-channel-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-untag-resource-request [input] (clojure.core/cond-> #:http.request.configuration{:querystring [(clojure.core/into (ser-list-of-string (input :tag-keys)) #:http.request.field{:name "TagKeys", :shape "ListOf__string", :location "querystring", :location-name "tagKeys"})], :uri [(clojure.core/into (ser-string (input :resource-arn)) #:http.request.field{:name "ResourceArn", :shape "__string", :location "uri", :location-name "resource-arn"})]}))

(clojure.core/defn- req-delete-event-stream-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]}))

(clojure.core/defn- req-get-import-jobs-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})]} (clojure.core/contains? input :page-size) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :page-size)) #:http.request.field{:name "PageSize", :shape "__string", :location "querystring", :location-name "page-size"})) (clojure.core/contains? input :token) (clojure.core/update-in [:http.request.configuration/querystring] (clojure.core/fnil clojure.core/conj []) (clojure.core/into (ser-string (input :token)) #:http.request.field{:name "Token", :shape "__string", :location "querystring", :location-name "token"}))))

(clojure.core/defn- req-update-campaign-request [input] (clojure.core/cond-> #:http.request.configuration{:uri [(clojure.core/into (ser-string (input :campaign-id)) #:http.request.field{:name "CampaignId", :shape "__string", :location "uri", :location-name "campaign-id"}) (clojure.core/into (ser-string (input :application-id)) #:http.request.field{:name "ApplicationId", :shape "__string", :location "uri", :location-name "application-id"})], :body [(clojure.core/into (ser-write-campaign-request (input :write-campaign-request)) #:http.request.field{:name "WriteCampaignRequest", :shape "WriteCampaignRequest"})]}))

(clojure.core/declare deser-treatment-resource)

(clojure.core/declare deser-export-jobs-response)

(clojure.core/declare deser-attribute-type)

(clojure.core/declare deser-segment-group-list)

(clojure.core/declare deser-message-response)

(clojure.core/declare deser-import-job-response)

(clojure.core/declare deser-list-of-segment-response)

(clojure.core/declare deser-campaign-state)

(clojure.core/declare deser-voice-channel-response)

(clojure.core/declare deser-campaign-limits)

(clojure.core/declare deser-gcm-channel-response)

(clojure.core/declare deser-quiet-time)

(clojure.core/declare deser-export-job-resource)

(clojure.core/declare deser-events-response)

(clojure.core/declare deser-list-of-export-job-response)

(clojure.core/declare deser-activity-response)

(clojure.core/declare deser-job-status)

(clojure.core/declare deser-type)

(clojure.core/declare deser-campaign-response)

(clojure.core/declare deser-segment-type)

(clojure.core/declare deser-attribute-dimension)

(clojure.core/declare deser-export-job-response)

(clojure.core/declare deser-send-users-message-response)

(clojure.core/declare deser-recency-type)

(clojure.core/declare deser-application-response)

(clojure.core/declare deser-list-of-treatment-resource)

(clojure.core/declare deser-map-of-message-result)

(clojure.core/declare deser-endpoint-user)

(clojure.core/declare deser-string)

(clojure.core/declare deser-endpoint-item-response)

(clojure.core/declare deser-activities-response)

(clojure.core/declare deser-campaign-event-filter)

(clojure.core/declare deser-campaigns-response)

(clojure.core/declare deser-delivery-status)

(clojure.core/declare deser-campaign-sms-message)

(clojure.core/declare deser-attributes-resource)

(clojure.core/declare deser-map-of-list-of-string)

(clojure.core/declare deser-endpoint-demographic)

(clojure.core/declare deser-number-validate-response)

(clojure.core/declare deser-source-type)

(clojure.core/declare deser-format)

(clojure.core/declare deser-endpoints-response)

(clojure.core/declare deser-mode)

(clojure.core/declare deser-import-jobs-response)

(clojure.core/declare deser-event-dimensions)

(clojure.core/declare deser-apns-voip-sandbox-channel-response)

(clojure.core/declare deser-import-job-resource)

(clojure.core/declare deser-list-of-string)

(clojure.core/declare deser-sms-channel-response)

(clojure.core/declare deser-list-of-segment-dimensions)

(clojure.core/declare deser-message-body)

(clojure.core/declare deser-apns-sandbox-channel-response)

(clojure.core/declare deser-map-of-endpoint-message-result)

(clojure.core/declare deser-map-of-item-response)

(clojure.core/declare deser-map-of-metric-dimension)

(clojure.core/declare deser-boolean)

(clojure.core/declare deser-map-of-double)

(clojure.core/declare deser-map-of-event-item-response)

(clojure.core/declare deser-endpoint-message-result)

(clojure.core/declare deser-set-dimension)

(clojure.core/declare deser-segment-behaviors)

(clojure.core/declare deser-apns-voip-channel-response)

(clojure.core/declare deser-segment-dimensions)

(clojure.core/declare deser-message)

(clojure.core/declare deser-dimension-type)

(clojure.core/declare deser-application-settings-resource)

(clojure.core/declare deser-campaign-hook)

(clojure.core/declare deser-duration)

(clojure.core/declare deser-metric-dimension)

(clojure.core/declare deser-filter-type)

(clojure.core/declare deser-gps-point-dimension)

(clojure.core/declare deser-map-of-attribute-dimension)

(clojure.core/declare deser-recency-dimension)

(clojure.core/declare deser-event-stream)

(clojure.core/declare deser-list-of-segment-reference)

(clojure.core/declare deser-channels-response)

(clojure.core/declare deser-campaign-email-message)

(clojure.core/declare deser-list-of-import-job-response)

(clojure.core/declare deser-include)

(clojure.core/declare deser-segment-reference)

(clojure.core/declare deser-message-configuration)

(clojure.core/declare deser-message-type)

(clojure.core/declare deser-frequency)

(clojure.core/declare deser-segment-response)

(clojure.core/declare deser-double)

(clojure.core/declare deser-list-of-campaign-response)

(clojure.core/declare deser-endpoint-response)

(clojure.core/declare deser-campaign-status)

(clojure.core/declare deser-applications-response)

(clojure.core/declare deser-event-item-response)

(clojure.core/declare deser-item-response)

(clojure.core/declare deser-list-of-endpoint-response)

(clojure.core/declare deser-integer)

(clojure.core/declare deser-schedule)

(clojure.core/declare deser-segment-group)

(clojure.core/declare deser-segment-import-resource)

(clojure.core/declare deser-map-of-channel-response)

(clojure.core/declare deser-channel-response)

(clojure.core/declare deser-map-of-integer)

(clojure.core/declare deser-email-channel-response)

(clojure.core/declare deser-list-of-segment-group)

(clojure.core/declare deser-list-of-application-response)

(clojure.core/declare deser-gps-coordinates)

(clojure.core/declare deser-adm-channel-response)

(clojure.core/declare deser-segment-location)

(clojure.core/declare deser-endpoint-location)

(clojure.core/declare deser-action)

(clojure.core/declare deser-tags-model)

(clojure.core/declare deser-list-of-activity-response)

(clojure.core/declare deser-baidu-channel-response)

(clojure.core/declare deser-map-of-map-of-endpoint-message-result)

(clojure.core/declare deser-message-result)

(clojure.core/declare deser-apns-channel-response)

(clojure.core/declare deser-map-of-string)

(clojure.core/declare deser-segments-response)

(clojure.core/declare deser-channel-type)

(clojure.core/declare deser-segment-demographics)

(clojure.core/defn- deser-treatment-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "MessageConfiguration") (clojure.core/assoc :message-configuration (deser-message-configuration (input "MessageConfiguration"))) (clojure.core/contains? input "Schedule") (clojure.core/assoc :schedule (deser-schedule (input "Schedule"))) (clojure.core/contains? input "SizePercent") (clojure.core/assoc :size-percent (deser-integer (input "SizePercent"))) (clojure.core/contains? input "State") (clojure.core/assoc :state (deser-campaign-state (input "State"))) (clojure.core/contains? input "TreatmentDescription") (clojure.core/assoc :treatment-description (deser-string (input "TreatmentDescription"))) (clojure.core/contains? input "TreatmentName") (clojure.core/assoc :treatment-name (deser-string (input "TreatmentName")))))

(clojure.core/defn- deser-export-jobs-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-export-job-response (input "Item"))) (clojure.core/contains? input "NextToken") (clojure.core/assoc :next-token (deser-string (input "NextToken")))))

(clojure.core/defn- deser-attribute-type [input] (clojure.core/get {"INCLUSIVE" :inclusive, "EXCLUSIVE" :exclusive} input))

(clojure.core/defn- deser-segment-group-list [input] (clojure.core/cond-> {} (clojure.core/contains? input "Groups") (clojure.core/assoc :groups (deser-list-of-segment-group (input "Groups"))) (clojure.core/contains? input "Include") (clojure.core/assoc :include (deser-include (input "Include")))))

(clojure.core/defn- deser-message-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "EndpointResult") (clojure.core/assoc :endpoint-result (deser-map-of-endpoint-message-result (input "EndpointResult"))) (clojure.core/contains? input "RequestId") (clojure.core/assoc :request-id (deser-string (input "RequestId"))) (clojure.core/contains? input "Result") (clojure.core/assoc :result (deser-map-of-message-result (input "Result")))))

(clojure.core/defn- deser-import-job-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "JobStatus") (clojure.core/assoc :job-status (deser-job-status (input "JobStatus"))) (clojure.core/contains? input "Failures") (clojure.core/assoc :failures (deser-list-of-string (input "Failures"))) (clojure.core/contains? input "CompletionDate") (clojure.core/assoc :completion-date (deser-string (input "CompletionDate"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-string (input "Type"))) (clojure.core/contains? input "TotalPieces") (clojure.core/assoc :total-pieces (deser-integer (input "TotalPieces"))) (clojure.core/contains? input "TotalFailures") (clojure.core/assoc :total-failures (deser-integer (input "TotalFailures"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "Definition") (clojure.core/assoc :definition (deser-import-job-resource (input "Definition"))) (clojure.core/contains? input "FailedPieces") (clojure.core/assoc :failed-pieces (deser-integer (input "FailedPieces"))) (clojure.core/contains? input "CompletedPieces") (clojure.core/assoc :completed-pieces (deser-integer (input "CompletedPieces"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "TotalProcessed") (clojure.core/assoc :total-processed (deser-integer (input "TotalProcessed")))))

(clojure.core/defn- deser-list-of-segment-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-segment-response coll))) input))

(clojure.core/defn- deser-campaign-state [input] (clojure.core/cond-> {} (clojure.core/contains? input "CampaignStatus") (clojure.core/assoc :campaign-status (deser-campaign-status (input "CampaignStatus")))))

(clojure.core/defn- deser-voice-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-campaign-limits [input] (clojure.core/cond-> {} (clojure.core/contains? input "Daily") (clojure.core/assoc :daily (deser-integer (input "Daily"))) (clojure.core/contains? input "MaximumDuration") (clojure.core/assoc :maximum-duration (deser-integer (input "MaximumDuration"))) (clojure.core/contains? input "MessagesPerSecond") (clojure.core/assoc :messages-per-second (deser-integer (input "MessagesPerSecond"))) (clojure.core/contains? input "Total") (clojure.core/assoc :total (deser-integer (input "Total")))))

(clojure.core/defn- deser-gcm-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "Credential") (clojure.core/assoc :credential (deser-string (input "Credential"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-quiet-time [input] (clojure.core/cond-> {} (clojure.core/contains? input "End") (clojure.core/assoc :end (deser-string (input "End"))) (clojure.core/contains? input "Start") (clojure.core/assoc :start (deser-string (input "Start")))))

(clojure.core/defn- deser-export-job-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "RoleArn") (clojure.core/assoc :role-arn (deser-string (input "RoleArn"))) (clojure.core/contains? input "S3UrlPrefix") (clojure.core/assoc :s-3-url-prefix (deser-string (input "S3UrlPrefix"))) (clojure.core/contains? input "SegmentId") (clojure.core/assoc :segment-id (deser-string (input "SegmentId"))) (clojure.core/contains? input "SegmentVersion") (clojure.core/assoc :segment-version (deser-integer (input "SegmentVersion")))))

(clojure.core/defn- deser-events-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Results") (clojure.core/assoc :results (deser-map-of-item-response (input "Results")))))

(clojure.core/defn- deser-list-of-export-job-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-export-job-response coll))) input))

(clojure.core/defn- deser-activity-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "TotalEndpointCount") (clojure.core/assoc :total-endpoint-count (deser-integer (input "TotalEndpointCount"))) (clojure.core/contains? input "TimezonesCompletedCount") (clojure.core/assoc :timezones-completed-count (deser-integer (input "TimezonesCompletedCount"))) (clojure.core/contains? input "Start") (clojure.core/assoc :start (deser-string (input "Start"))) (clojure.core/contains? input "End") (clojure.core/assoc :end (deser-string (input "End"))) (clojure.core/contains? input "Result") (clojure.core/assoc :result (deser-string (input "Result"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "SuccessfulEndpointCount") (clojure.core/assoc :successful-endpoint-count (deser-integer (input "SuccessfulEndpointCount"))) (clojure.core/contains? input "State") (clojure.core/assoc :state (deser-string (input "State"))) (clojure.core/contains? input "ScheduledStart") (clojure.core/assoc :scheduled-start (deser-string (input "ScheduledStart"))) (clojure.core/contains? input "TimezonesTotalCount") (clojure.core/assoc :timezones-total-count (deser-integer (input "TimezonesTotalCount"))) (clojure.core/contains? input "CampaignId") (clojure.core/assoc :campaign-id (deser-string (input "CampaignId"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "TreatmentId") (clojure.core/assoc :treatment-id (deser-string (input "TreatmentId")))))

(clojure.core/defn- deser-job-status [input] (clojure.core/get {"CREATED" :created, "INITIALIZING" :initializing, "PROCESSING" :processing, "COMPLETING" :completing, "COMPLETED" :completed, "FAILING" :failing, "FAILED" :failed} input))

(clojure.core/defn- deser-type [input] (clojure.core/get {"ALL" :all, "ANY" :any, "NONE" :none} input))

(clojure.core/defn- deser-campaign-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "DefaultState") (clojure.core/assoc :default-state (deser-campaign-state (input "DefaultState"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "AdditionalTreatments") (clojure.core/assoc :additional-treatments (deser-list-of-treatment-resource (input "AdditionalTreatments"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-map-of-string (input "tags"))) (clojure.core/contains? input "TreatmentDescription") (clojure.core/assoc :treatment-description (deser-string (input "TreatmentDescription"))) (clojure.core/contains? input "TreatmentName") (clojure.core/assoc :treatment-name (deser-string (input "TreatmentName"))) (clojure.core/contains? input "Limits") (clojure.core/assoc :limits (deser-campaign-limits (input "Limits"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "SegmentVersion") (clojure.core/assoc :segment-version (deser-integer (input "SegmentVersion"))) (clojure.core/contains? input "Description") (clojure.core/assoc :description (deser-string (input "Description"))) (clojure.core/contains? input "IsPaused") (clojure.core/assoc :is-paused (deser-boolean (input "IsPaused"))) (clojure.core/contains? input "Hook") (clojure.core/assoc :hook (deser-campaign-hook (input "Hook"))) (clojure.core/contains? input "Arn") (clojure.core/assoc :arn (deser-string (input "Arn"))) (clojure.core/contains? input "MessageConfiguration") (clojure.core/assoc :message-configuration (deser-message-configuration (input "MessageConfiguration"))) (clojure.core/contains? input "SegmentId") (clojure.core/assoc :segment-id (deser-string (input "SegmentId"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "State") (clojure.core/assoc :state (deser-campaign-state (input "State"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "Schedule") (clojure.core/assoc :schedule (deser-schedule (input "Schedule"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-string (input "Name"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "HoldoutPercent") (clojure.core/assoc :holdout-percent (deser-integer (input "HoldoutPercent")))))

(clojure.core/defn- deser-segment-type [input] (clojure.core/get {"DIMENSIONAL" :dimensional, "IMPORT" :import} input))

(clojure.core/defn- deser-attribute-dimension [input] (clojure.core/cond-> {} (clojure.core/contains? input "AttributeType") (clojure.core/assoc :attribute-type (deser-attribute-type (input "AttributeType"))) (clojure.core/contains? input "Values") (clojure.core/assoc :values (deser-list-of-string (input "Values")))))

(clojure.core/defn- deser-export-job-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "JobStatus") (clojure.core/assoc :job-status (deser-job-status (input "JobStatus"))) (clojure.core/contains? input "Failures") (clojure.core/assoc :failures (deser-list-of-string (input "Failures"))) (clojure.core/contains? input "CompletionDate") (clojure.core/assoc :completion-date (deser-string (input "CompletionDate"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-string (input "Type"))) (clojure.core/contains? input "TotalPieces") (clojure.core/assoc :total-pieces (deser-integer (input "TotalPieces"))) (clojure.core/contains? input "TotalFailures") (clojure.core/assoc :total-failures (deser-integer (input "TotalFailures"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "Definition") (clojure.core/assoc :definition (deser-export-job-resource (input "Definition"))) (clojure.core/contains? input "FailedPieces") (clojure.core/assoc :failed-pieces (deser-integer (input "FailedPieces"))) (clojure.core/contains? input "CompletedPieces") (clojure.core/assoc :completed-pieces (deser-integer (input "CompletedPieces"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "TotalProcessed") (clojure.core/assoc :total-processed (deser-integer (input "TotalProcessed")))))

(clojure.core/defn- deser-send-users-message-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "RequestId") (clojure.core/assoc :request-id (deser-string (input "RequestId"))) (clojure.core/contains? input "Result") (clojure.core/assoc :result (deser-map-of-map-of-endpoint-message-result (input "Result")))))

(clojure.core/defn- deser-recency-type [input] (clojure.core/get {"ACTIVE" :active, "INACTIVE" :inactive} input))

(clojure.core/defn- deser-application-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Arn") (clojure.core/assoc :arn (deser-string (input "Arn"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-string (input "Name"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-map-of-string (input "tags")))))

(clojure.core/defn- deser-list-of-treatment-resource [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-treatment-resource coll))) input))

(clojure.core/defn- deser-map-of-message-result [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-message-result v)])) input))

(clojure.core/defn- deser-endpoint-user [input] (clojure.core/cond-> {} (clojure.core/contains? input "UserAttributes") (clojure.core/assoc :user-attributes (deser-map-of-list-of-string (input "UserAttributes"))) (clojure.core/contains? input "UserId") (clojure.core/assoc :user-id (deser-string (input "UserId")))))

(clojure.core/defn- deser-string [input] input)

(clojure.core/defn- deser-endpoint-item-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Message") (clojure.core/assoc :message (deser-string (input "Message"))) (clojure.core/contains? input "StatusCode") (clojure.core/assoc :status-code (deser-integer (input "StatusCode")))))

(clojure.core/defn- deser-activities-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-activity-response (input "Item"))) (clojure.core/contains? input "NextToken") (clojure.core/assoc :next-token (deser-string (input "NextToken")))))

(clojure.core/defn- deser-campaign-event-filter [input] (clojure.core/cond-> {} (clojure.core/contains? input "Dimensions") (clojure.core/assoc :dimensions (deser-event-dimensions (input "Dimensions"))) (clojure.core/contains? input "FilterType") (clojure.core/assoc :filter-type (deser-filter-type (input "FilterType")))))

(clojure.core/defn- deser-campaigns-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-campaign-response (input "Item"))) (clojure.core/contains? input "NextToken") (clojure.core/assoc :next-token (deser-string (input "NextToken")))))

(clojure.core/defn- deser-delivery-status [input] (clojure.core/get {"SUCCESSFUL" :successful, "THROTTLED" :throttled, "TEMPORARY_FAILURE" :temporary-failure, "PERMANENT_FAILURE" :permanent-failure, "UNKNOWN_FAILURE" :unknown-failure, "OPT_OUT" :opt-out, "DUPLICATE" :duplicate} input))

(clojure.core/defn- deser-campaign-sms-message [input] (clojure.core/cond-> {} (clojure.core/contains? input "Body") (clojure.core/assoc :body (deser-string (input "Body"))) (clojure.core/contains? input "MessageType") (clojure.core/assoc :message-type (deser-message-type (input "MessageType"))) (clojure.core/contains? input "SenderId") (clojure.core/assoc :sender-id (deser-string (input "SenderId")))))

(clojure.core/defn- deser-attributes-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "AttributeType") (clojure.core/assoc :attribute-type (deser-string (input "AttributeType"))) (clojure.core/contains? input "Attributes") (clojure.core/assoc :attributes (deser-list-of-string (input "Attributes")))))

(clojure.core/defn- deser-map-of-list-of-string [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-list-of-string v)])) input))

(clojure.core/defn- deser-endpoint-demographic [input] (clojure.core/cond-> {} (clojure.core/contains? input "AppVersion") (clojure.core/assoc :app-version (deser-string (input "AppVersion"))) (clojure.core/contains? input "Locale") (clojure.core/assoc :locale (deser-string (input "Locale"))) (clojure.core/contains? input "Make") (clojure.core/assoc :make (deser-string (input "Make"))) (clojure.core/contains? input "Model") (clojure.core/assoc :model (deser-string (input "Model"))) (clojure.core/contains? input "ModelVersion") (clojure.core/assoc :model-version (deser-string (input "ModelVersion"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "PlatformVersion") (clojure.core/assoc :platform-version (deser-string (input "PlatformVersion"))) (clojure.core/contains? input "Timezone") (clojure.core/assoc :timezone (deser-string (input "Timezone")))))

(clojure.core/defn- deser-number-validate-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Carrier") (clojure.core/assoc :carrier (deser-string (input "Carrier"))) (clojure.core/contains? input "CleansedPhoneNumberE164") (clojure.core/assoc :cleansed-phone-number-e-164 (deser-string (input "CleansedPhoneNumberE164"))) (clojure.core/contains? input "PhoneTypeCode") (clojure.core/assoc :phone-type-code (deser-integer (input "PhoneTypeCode"))) (clojure.core/contains? input "Country") (clojure.core/assoc :country (deser-string (input "Country"))) (clojure.core/contains? input "CountryCodeIso2") (clojure.core/assoc :country-code-iso-2 (deser-string (input "CountryCodeIso2"))) (clojure.core/contains? input "ZipCode") (clojure.core/assoc :zip-code (deser-string (input "ZipCode"))) (clojure.core/contains? input "Timezone") (clojure.core/assoc :timezone (deser-string (input "Timezone"))) (clojure.core/contains? input "CountryCodeNumeric") (clojure.core/assoc :country-code-numeric (deser-string (input "CountryCodeNumeric"))) (clojure.core/contains? input "OriginalPhoneNumber") (clojure.core/assoc :original-phone-number (deser-string (input "OriginalPhoneNumber"))) (clojure.core/contains? input "City") (clojure.core/assoc :city (deser-string (input "City"))) (clojure.core/contains? input "County") (clojure.core/assoc :county (deser-string (input "County"))) (clojure.core/contains? input "PhoneType") (clojure.core/assoc :phone-type (deser-string (input "PhoneType"))) (clojure.core/contains? input "OriginalCountryCodeIso2") (clojure.core/assoc :original-country-code-iso-2 (deser-string (input "OriginalCountryCodeIso2"))) (clojure.core/contains? input "CleansedPhoneNumberNational") (clojure.core/assoc :cleansed-phone-number-national (deser-string (input "CleansedPhoneNumberNational")))))

(clojure.core/defn- deser-source-type [input] (clojure.core/get {"ALL" :all, "ANY" :any, "NONE" :none} input))

(clojure.core/defn- deser-format [input] (clojure.core/get {"CSV" :csv, "JSON" :json} input))

(clojure.core/defn- deser-endpoints-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-endpoint-response (input "Item")))))

(clojure.core/defn- deser-mode [input] (clojure.core/get {"DELIVERY" :delivery, "FILTER" :filter} input))

(clojure.core/defn- deser-import-jobs-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-import-job-response (input "Item"))) (clojure.core/contains? input "NextToken") (clojure.core/assoc :next-token (deser-string (input "NextToken")))))

(clojure.core/defn- deser-event-dimensions [input] (clojure.core/cond-> {} (clojure.core/contains? input "Attributes") (clojure.core/assoc :attributes (deser-map-of-attribute-dimension (input "Attributes"))) (clojure.core/contains? input "EventType") (clojure.core/assoc :event-type (deser-set-dimension (input "EventType"))) (clojure.core/contains? input "Metrics") (clojure.core/assoc :metrics (deser-map-of-metric-dimension (input "Metrics")))))

(clojure.core/defn- deser-apns-voip-sandbox-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "HasTokenKey") (clojure.core/assoc :has-token-key (deser-boolean (input "HasTokenKey"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "DefaultAuthenticationMethod") (clojure.core/assoc :default-authentication-method (deser-string (input "DefaultAuthenticationMethod"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-import-job-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "DefineSegment") (clojure.core/assoc :define-segment (deser-boolean (input "DefineSegment"))) (clojure.core/contains? input "ExternalId") (clojure.core/assoc :external-id (deser-string (input "ExternalId"))) (clojure.core/contains? input "Format") (clojure.core/assoc :format (deser-format (input "Format"))) (clojure.core/contains? input "RegisterEndpoints") (clojure.core/assoc :register-endpoints (deser-boolean (input "RegisterEndpoints"))) (clojure.core/contains? input "RoleArn") (clojure.core/assoc :role-arn (deser-string (input "RoleArn"))) (clojure.core/contains? input "S3Url") (clojure.core/assoc :s-3-url (deser-string (input "S3Url"))) (clojure.core/contains? input "SegmentId") (clojure.core/assoc :segment-id (deser-string (input "SegmentId"))) (clojure.core/contains? input "SegmentName") (clojure.core/assoc :segment-name (deser-string (input "SegmentName")))))

(clojure.core/defn- deser-list-of-string [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-string coll))) input))

(clojure.core/defn- deser-sms-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "TransactionalMessagesPerSecond") (clojure.core/assoc :transactional-messages-per-second (deser-integer (input "TransactionalMessagesPerSecond"))) (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "ShortCode") (clojure.core/assoc :short-code (deser-string (input "ShortCode"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "SenderId") (clojure.core/assoc :sender-id (deser-string (input "SenderId"))) (clojure.core/contains? input "PromotionalMessagesPerSecond") (clojure.core/assoc :promotional-messages-per-second (deser-integer (input "PromotionalMessagesPerSecond"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-list-of-segment-dimensions [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-segment-dimensions coll))) input))

(clojure.core/defn- deser-message-body [input] (clojure.core/cond-> {} (clojure.core/contains? input "Message") (clojure.core/assoc :message (deser-string (input "Message"))) (clojure.core/contains? input "RequestID") (clojure.core/assoc :request-id (deser-string (input "RequestID")))))

(clojure.core/defn- deser-apns-sandbox-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "HasTokenKey") (clojure.core/assoc :has-token-key (deser-boolean (input "HasTokenKey"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "DefaultAuthenticationMethod") (clojure.core/assoc :default-authentication-method (deser-string (input "DefaultAuthenticationMethod"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-map-of-endpoint-message-result [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-endpoint-message-result v)])) input))

(clojure.core/defn- deser-map-of-item-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-item-response v)])) input))

(clojure.core/defn- deser-map-of-metric-dimension [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-metric-dimension v)])) input))

(clojure.core/defn- deser-boolean [input] input)

(clojure.core/defn- deser-map-of-double [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-double v)])) input))

(clojure.core/defn- deser-map-of-event-item-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-event-item-response v)])) input))

(clojure.core/defn- deser-endpoint-message-result [input] (clojure.core/cond-> {} (clojure.core/contains? input "Address") (clojure.core/assoc :address (deser-string (input "Address"))) (clojure.core/contains? input "DeliveryStatus") (clojure.core/assoc :delivery-status (deser-delivery-status (input "DeliveryStatus"))) (clojure.core/contains? input "MessageId") (clojure.core/assoc :message-id (deser-string (input "MessageId"))) (clojure.core/contains? input "StatusCode") (clojure.core/assoc :status-code (deser-integer (input "StatusCode"))) (clojure.core/contains? input "StatusMessage") (clojure.core/assoc :status-message (deser-string (input "StatusMessage"))) (clojure.core/contains? input "UpdatedToken") (clojure.core/assoc :updated-token (deser-string (input "UpdatedToken")))))

(clojure.core/defn- deser-set-dimension [input] (clojure.core/cond-> {} (clojure.core/contains? input "DimensionType") (clojure.core/assoc :dimension-type (deser-dimension-type (input "DimensionType"))) (clojure.core/contains? input "Values") (clojure.core/assoc :values (deser-list-of-string (input "Values")))))

(clojure.core/defn- deser-segment-behaviors [input] (clojure.core/cond-> {} (clojure.core/contains? input "Recency") (clojure.core/assoc :recency (deser-recency-dimension (input "Recency")))))

(clojure.core/defn- deser-apns-voip-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "HasTokenKey") (clojure.core/assoc :has-token-key (deser-boolean (input "HasTokenKey"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "DefaultAuthenticationMethod") (clojure.core/assoc :default-authentication-method (deser-string (input "DefaultAuthenticationMethod"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-segment-dimensions [input] (clojure.core/cond-> {} (clojure.core/contains? input "Attributes") (clojure.core/assoc :attributes (deser-map-of-attribute-dimension (input "Attributes"))) (clojure.core/contains? input "Behavior") (clojure.core/assoc :behavior (deser-segment-behaviors (input "Behavior"))) (clojure.core/contains? input "Demographic") (clojure.core/assoc :demographic (deser-segment-demographics (input "Demographic"))) (clojure.core/contains? input "Location") (clojure.core/assoc :location (deser-segment-location (input "Location"))) (clojure.core/contains? input "Metrics") (clojure.core/assoc :metrics (deser-map-of-metric-dimension (input "Metrics"))) (clojure.core/contains? input "UserAttributes") (clojure.core/assoc :user-attributes (deser-map-of-attribute-dimension (input "UserAttributes")))))

(clojure.core/defn- deser-message [input] (clojure.core/cond-> {} (clojure.core/contains? input "Body") (clojure.core/assoc :body (deser-string (input "Body"))) (clojure.core/contains? input "ImageUrl") (clojure.core/assoc :image-url (deser-string (input "ImageUrl"))) (clojure.core/contains? input "Title") (clojure.core/assoc :title (deser-string (input "Title"))) (clojure.core/contains? input "SilentPush") (clojure.core/assoc :silent-push (deser-boolean (input "SilentPush"))) (clojure.core/contains? input "TimeToLive") (clojure.core/assoc :time-to-live (deser-integer (input "TimeToLive"))) (clojure.core/contains? input "RawContent") (clojure.core/assoc :raw-content (deser-string (input "RawContent"))) (clojure.core/contains? input "Url") (clojure.core/assoc :url (deser-string (input "Url"))) (clojure.core/contains? input "JsonBody") (clojure.core/assoc :json-body (deser-string (input "JsonBody"))) (clojure.core/contains? input "ImageSmallIconUrl") (clojure.core/assoc :image-small-icon-url (deser-string (input "ImageSmallIconUrl"))) (clojure.core/contains? input "MediaUrl") (clojure.core/assoc :media-url (deser-string (input "MediaUrl"))) (clojure.core/contains? input "ImageIconUrl") (clojure.core/assoc :image-icon-url (deser-string (input "ImageIconUrl"))) (clojure.core/contains? input "Action") (clojure.core/assoc :action (deser-action (input "Action")))))

(clojure.core/defn- deser-dimension-type [input] (clojure.core/get {"INCLUSIVE" :inclusive, "EXCLUSIVE" :exclusive} input))

(clojure.core/defn- deser-application-settings-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "CampaignHook") (clojure.core/assoc :campaign-hook (deser-campaign-hook (input "CampaignHook"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Limits") (clojure.core/assoc :limits (deser-campaign-limits (input "Limits"))) (clojure.core/contains? input "QuietTime") (clojure.core/assoc :quiet-time (deser-quiet-time (input "QuietTime")))))

(clojure.core/defn- deser-campaign-hook [input] (clojure.core/cond-> {} (clojure.core/contains? input "LambdaFunctionName") (clojure.core/assoc :lambda-function-name (deser-string (input "LambdaFunctionName"))) (clojure.core/contains? input "Mode") (clojure.core/assoc :mode (deser-mode (input "Mode"))) (clojure.core/contains? input "WebUrl") (clojure.core/assoc :web-url (deser-string (input "WebUrl")))))

(clojure.core/defn- deser-duration [input] (clojure.core/get {"HR_24" :hr-24, "DAY_7" :day-7, "DAY_14" :day-14, "DAY_30" :day-30} input))

(clojure.core/defn- deser-metric-dimension [input] (clojure.core/cond-> {} (clojure.core/contains? input "ComparisonOperator") (clojure.core/assoc :comparison-operator (deser-string (input "ComparisonOperator"))) (clojure.core/contains? input "Value") (clojure.core/assoc :value (deser-double (input "Value")))))

(clojure.core/defn- deser-filter-type [input] (clojure.core/get {"SYSTEM" :system, "ENDPOINT" :endpoint} input))

(clojure.core/defn- deser-gps-point-dimension [input] (clojure.core/cond-> {} (clojure.core/contains? input "Coordinates") (clojure.core/assoc :coordinates (deser-gps-coordinates (input "Coordinates"))) (clojure.core/contains? input "RangeInKilometers") (clojure.core/assoc :range-in-kilometers (deser-double (input "RangeInKilometers")))))

(clojure.core/defn- deser-map-of-attribute-dimension [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-attribute-dimension v)])) input))

(clojure.core/defn- deser-recency-dimension [input] (clojure.core/cond-> {} (clojure.core/contains? input "Duration") (clojure.core/assoc :duration (deser-duration (input "Duration"))) (clojure.core/contains? input "RecencyType") (clojure.core/assoc :recency-type (deser-recency-type (input "RecencyType")))))

(clojure.core/defn- deser-event-stream [input] (clojure.core/cond-> {} (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "DestinationStreamArn") (clojure.core/assoc :destination-stream-arn (deser-string (input "DestinationStreamArn"))) (clojure.core/contains? input "ExternalId") (clojure.core/assoc :external-id (deser-string (input "ExternalId"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "LastUpdatedBy") (clojure.core/assoc :last-updated-by (deser-string (input "LastUpdatedBy"))) (clojure.core/contains? input "RoleArn") (clojure.core/assoc :role-arn (deser-string (input "RoleArn")))))

(clojure.core/defn- deser-list-of-segment-reference [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-segment-reference coll))) input))

(clojure.core/defn- deser-channels-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Channels") (clojure.core/assoc :channels (deser-map-of-channel-response (input "Channels")))))

(clojure.core/defn- deser-campaign-email-message [input] (clojure.core/cond-> {} (clojure.core/contains? input "Body") (clojure.core/assoc :body (deser-string (input "Body"))) (clojure.core/contains? input "FromAddress") (clojure.core/assoc :from-address (deser-string (input "FromAddress"))) (clojure.core/contains? input "HtmlBody") (clojure.core/assoc :html-body (deser-string (input "HtmlBody"))) (clojure.core/contains? input "Title") (clojure.core/assoc :title (deser-string (input "Title")))))

(clojure.core/defn- deser-list-of-import-job-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-import-job-response coll))) input))

(clojure.core/defn- deser-include [input] (clojure.core/get {"ALL" :all, "ANY" :any, "NONE" :none} input))

(clojure.core/defn- deser-segment-reference [input] (clojure.core/cond-> {} (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version")))))

(clojure.core/defn- deser-message-configuration [input] (clojure.core/cond-> {} (clojure.core/contains? input "ADMMessage") (clojure.core/assoc :adm-message (deser-message (input "ADMMessage"))) (clojure.core/contains? input "APNSMessage") (clojure.core/assoc :apns-message (deser-message (input "APNSMessage"))) (clojure.core/contains? input "BaiduMessage") (clojure.core/assoc :baidu-message (deser-message (input "BaiduMessage"))) (clojure.core/contains? input "DefaultMessage") (clojure.core/assoc :default-message (deser-message (input "DefaultMessage"))) (clojure.core/contains? input "EmailMessage") (clojure.core/assoc :email-message (deser-campaign-email-message (input "EmailMessage"))) (clojure.core/contains? input "GCMMessage") (clojure.core/assoc :gcm-message (deser-message (input "GCMMessage"))) (clojure.core/contains? input "SMSMessage") (clojure.core/assoc :sms-message (deser-campaign-sms-message (input "SMSMessage")))))

(clojure.core/defn- deser-message-type [input] (clojure.core/get {"TRANSACTIONAL" :transactional, "PROMOTIONAL" :promotional} input))

(clojure.core/defn- deser-frequency [input] (clojure.core/get {"ONCE" :once, "HOURLY" :hourly, "DAILY" :daily, "WEEKLY" :weekly, "MONTHLY" :monthly, "EVENT" :event} input))

(clojure.core/defn- deser-segment-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "SegmentGroups") (clojure.core/assoc :segment-groups (deser-segment-group-list (input "SegmentGroups"))) (clojure.core/contains? input "SegmentType") (clojure.core/assoc :segment-type (deser-segment-type (input "SegmentType"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "tags") (clojure.core/assoc :tags (deser-map-of-string (input "tags"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "Dimensions") (clojure.core/assoc :dimensions (deser-segment-dimensions (input "Dimensions"))) (clojure.core/contains? input "ImportDefinition") (clojure.core/assoc :import-definition (deser-segment-import-resource (input "ImportDefinition"))) (clojure.core/contains? input "Arn") (clojure.core/assoc :arn (deser-string (input "Arn"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "Name") (clojure.core/assoc :name (deser-string (input "Name"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-double [input] input)

(clojure.core/defn- deser-list-of-campaign-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-campaign-response coll))) input))

(clojure.core/defn- deser-endpoint-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Address") (clojure.core/assoc :address (deser-string (input "Address"))) (clojure.core/contains? input "CohortId") (clojure.core/assoc :cohort-id (deser-string (input "CohortId"))) (clojure.core/contains? input "EndpointStatus") (clojure.core/assoc :endpoint-status (deser-string (input "EndpointStatus"))) (clojure.core/contains? input "RequestId") (clojure.core/assoc :request-id (deser-string (input "RequestId"))) (clojure.core/contains? input "Location") (clojure.core/assoc :location (deser-endpoint-location (input "Location"))) (clojure.core/contains? input "Demographic") (clojure.core/assoc :demographic (deser-endpoint-demographic (input "Demographic"))) (clojure.core/contains? input "User") (clojure.core/assoc :user (deser-endpoint-user (input "User"))) (clojure.core/contains? input "Attributes") (clojure.core/assoc :attributes (deser-map-of-list-of-string (input "Attributes"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "EffectiveDate") (clojure.core/assoc :effective-date (deser-string (input "EffectiveDate"))) (clojure.core/contains? input "OptOut") (clojure.core/assoc :opt-out (deser-string (input "OptOut"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id"))) (clojure.core/contains? input "ChannelType") (clojure.core/assoc :channel-type (deser-channel-type (input "ChannelType"))) (clojure.core/contains? input "Metrics") (clojure.core/assoc :metrics (deser-map-of-double (input "Metrics")))))

(clojure.core/defn- deser-campaign-status [input] (clojure.core/get {"SCHEDULED" :scheduled, "EXECUTING" :executing, "PENDING_NEXT_RUN" :pending-next-run, "COMPLETED" :completed, "PAUSED" :paused, "DELETED" :deleted} input))

(clojure.core/defn- deser-applications-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-application-response (input "Item"))) (clojure.core/contains? input "NextToken") (clojure.core/assoc :next-token (deser-string (input "NextToken")))))

(clojure.core/defn- deser-event-item-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Message") (clojure.core/assoc :message (deser-string (input "Message"))) (clojure.core/contains? input "StatusCode") (clojure.core/assoc :status-code (deser-integer (input "StatusCode")))))

(clojure.core/defn- deser-item-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "EndpointItemResponse") (clojure.core/assoc :endpoint-item-response (deser-endpoint-item-response (input "EndpointItemResponse"))) (clojure.core/contains? input "EventsItemResponse") (clojure.core/assoc :events-item-response (deser-map-of-event-item-response (input "EventsItemResponse")))))

(clojure.core/defn- deser-list-of-endpoint-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-endpoint-response coll))) input))

(clojure.core/defn- deser-integer [input] input)

(clojure.core/defn- deser-schedule [input] (clojure.core/cond-> {} (clojure.core/contains? input "EndTime") (clojure.core/assoc :end-time (deser-string (input "EndTime"))) (clojure.core/contains? input "EventFilter") (clojure.core/assoc :event-filter (deser-campaign-event-filter (input "EventFilter"))) (clojure.core/contains? input "Frequency") (clojure.core/assoc :frequency (deser-frequency (input "Frequency"))) (clojure.core/contains? input "IsLocalTime") (clojure.core/assoc :is-local-time (deser-boolean (input "IsLocalTime"))) (clojure.core/contains? input "QuietTime") (clojure.core/assoc :quiet-time (deser-quiet-time (input "QuietTime"))) (clojure.core/contains? input "StartTime") (clojure.core/assoc :start-time (deser-string (input "StartTime"))) (clojure.core/contains? input "Timezone") (clojure.core/assoc :timezone (deser-string (input "Timezone")))))

(clojure.core/defn- deser-segment-group [input] (clojure.core/cond-> {} (clojure.core/contains? input "Dimensions") (clojure.core/assoc :dimensions (deser-list-of-segment-dimensions (input "Dimensions"))) (clojure.core/contains? input "SourceSegments") (clojure.core/assoc :source-segments (deser-list-of-segment-reference (input "SourceSegments"))) (clojure.core/contains? input "SourceType") (clojure.core/assoc :source-type (deser-source-type (input "SourceType"))) (clojure.core/contains? input "Type") (clojure.core/assoc :type (deser-type (input "Type")))))

(clojure.core/defn- deser-segment-import-resource [input] (clojure.core/cond-> {} (clojure.core/contains? input "ChannelCounts") (clojure.core/assoc :channel-counts (deser-map-of-integer (input "ChannelCounts"))) (clojure.core/contains? input "ExternalId") (clojure.core/assoc :external-id (deser-string (input "ExternalId"))) (clojure.core/contains? input "Format") (clojure.core/assoc :format (deser-format (input "Format"))) (clojure.core/contains? input "RoleArn") (clojure.core/assoc :role-arn (deser-string (input "RoleArn"))) (clojure.core/contains? input "S3Url") (clojure.core/assoc :s-3-url (deser-string (input "S3Url"))) (clojure.core/contains? input "Size") (clojure.core/assoc :size (deser-integer (input "Size")))))

(clojure.core/defn- deser-map-of-channel-response [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-channel-response v)])) input))

(clojure.core/defn- deser-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-map-of-integer [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-integer v)])) input))

(clojure.core/defn- deser-email-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "ConfigurationSet") (clojure.core/assoc :configuration-set (deser-string (input "ConfigurationSet"))) (clojure.core/contains? input "RoleArn") (clojure.core/assoc :role-arn (deser-string (input "RoleArn"))) (clojure.core/contains? input "MessagesPerSecond") (clojure.core/assoc :messages-per-second (deser-integer (input "MessagesPerSecond"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "Identity") (clojure.core/assoc :identity (deser-string (input "Identity"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "FromAddress") (clojure.core/assoc :from-address (deser-string (input "FromAddress"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-list-of-segment-group [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-segment-group coll))) input))

(clojure.core/defn- deser-list-of-application-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-application-response coll))) input))

(clojure.core/defn- deser-gps-coordinates [input] (clojure.core/cond-> {} (clojure.core/contains? input "Latitude") (clojure.core/assoc :latitude (deser-double (input "Latitude"))) (clojure.core/contains? input "Longitude") (clojure.core/assoc :longitude (deser-double (input "Longitude")))))

(clojure.core/defn- deser-adm-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-segment-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "Country") (clojure.core/assoc :country (deser-set-dimension (input "Country"))) (clojure.core/contains? input "GPSPoint") (clojure.core/assoc :gps-point (deser-gps-point-dimension (input "GPSPoint")))))

(clojure.core/defn- deser-endpoint-location [input] (clojure.core/cond-> {} (clojure.core/contains? input "City") (clojure.core/assoc :city (deser-string (input "City"))) (clojure.core/contains? input "Country") (clojure.core/assoc :country (deser-string (input "Country"))) (clojure.core/contains? input "Latitude") (clojure.core/assoc :latitude (deser-double (input "Latitude"))) (clojure.core/contains? input "Longitude") (clojure.core/assoc :longitude (deser-double (input "Longitude"))) (clojure.core/contains? input "PostalCode") (clojure.core/assoc :postal-code (deser-string (input "PostalCode"))) (clojure.core/contains? input "Region") (clojure.core/assoc :region (deser-string (input "Region")))))

(clojure.core/defn- deser-action [input] (clojure.core/get {"OPEN_APP" :open-app, "DEEP_LINK" :deep-link, "URL" :url} input))

(clojure.core/defn- deser-tags-model [input] (clojure.core/cond-> {:tags (deser-map-of-string (input "tags"))}))

(clojure.core/defn- deser-list-of-activity-response [input] (clojure.core/into [] (clojure.core/map (clojure.core/fn [coll] (deser-activity-response coll))) input))

(clojure.core/defn- deser-baidu-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "Credential") (clojure.core/assoc :credential (deser-string (input "Credential"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-map-of-map-of-endpoint-message-result [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-map-of-endpoint-message-result v)])) input))

(clojure.core/defn- deser-message-result [input] (clojure.core/cond-> {} (clojure.core/contains? input "DeliveryStatus") (clojure.core/assoc :delivery-status (deser-delivery-status (input "DeliveryStatus"))) (clojure.core/contains? input "MessageId") (clojure.core/assoc :message-id (deser-string (input "MessageId"))) (clojure.core/contains? input "StatusCode") (clojure.core/assoc :status-code (deser-integer (input "StatusCode"))) (clojure.core/contains? input "StatusMessage") (clojure.core/assoc :status-message (deser-string (input "StatusMessage"))) (clojure.core/contains? input "UpdatedToken") (clojure.core/assoc :updated-token (deser-string (input "UpdatedToken")))))

(clojure.core/defn- deser-apns-channel-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "HasCredential") (clojure.core/assoc :has-credential (deser-boolean (input "HasCredential"))) (clojure.core/contains? input "HasTokenKey") (clojure.core/assoc :has-token-key (deser-boolean (input "HasTokenKey"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-string (input "Platform"))) (clojure.core/contains? input "LastModifiedDate") (clojure.core/assoc :last-modified-date (deser-string (input "LastModifiedDate"))) (clojure.core/contains? input "Enabled") (clojure.core/assoc :enabled (deser-boolean (input "Enabled"))) (clojure.core/contains? input "ApplicationId") (clojure.core/assoc :application-id (deser-string (input "ApplicationId"))) (clojure.core/contains? input "IsArchived") (clojure.core/assoc :is-archived (deser-boolean (input "IsArchived"))) (clojure.core/contains? input "DefaultAuthenticationMethod") (clojure.core/assoc :default-authentication-method (deser-string (input "DefaultAuthenticationMethod"))) (clojure.core/contains? input "CreationDate") (clojure.core/assoc :creation-date (deser-string (input "CreationDate"))) (clojure.core/contains? input "Version") (clojure.core/assoc :version (deser-integer (input "Version"))) (clojure.core/contains? input "LastModifiedBy") (clojure.core/assoc :last-modified-by (deser-string (input "LastModifiedBy"))) (clojure.core/contains? input "Id") (clojure.core/assoc :id (deser-string (input "Id")))))

(clojure.core/defn- deser-map-of-string [input] (clojure.core/into {} (clojure.core/map (clojure.core/fn [[k v]] [(deser-string k) (deser-string v)])) input))

(clojure.core/defn- deser-segments-response [input] (clojure.core/cond-> {} (clojure.core/contains? input "Item") (clojure.core/assoc :item (deser-list-of-segment-response (input "Item"))) (clojure.core/contains? input "NextToken") (clojure.core/assoc :next-token (deser-string (input "NextToken")))))

(clojure.core/defn- deser-channel-type [input] (clojure.core/get {"VOICE" :voice, "CUSTOM" :custom, "SMS" :sms, "APNS_VOIP" :apns-voip, "ADM" :adm, "BAIDU" :baidu, "GCM" :gcm, "APNS" :apns, "APNS_VOIP_SANDBOX" :apns-voip-sandbox, "APNS_SANDBOX" :apns-sandbox, "EMAIL" :email} input))

(clojure.core/defn- deser-segment-demographics [input] (clojure.core/cond-> {} (clojure.core/contains? input "AppVersion") (clojure.core/assoc :app-version (deser-set-dimension (input "AppVersion"))) (clojure.core/contains? input "Channel") (clojure.core/assoc :channel (deser-set-dimension (input "Channel"))) (clojure.core/contains? input "DeviceType") (clojure.core/assoc :device-type (deser-set-dimension (input "DeviceType"))) (clojure.core/contains? input "Make") (clojure.core/assoc :make (deser-set-dimension (input "Make"))) (clojure.core/contains? input "Model") (clojure.core/assoc :model (deser-set-dimension (input "Model"))) (clojure.core/contains? input "Platform") (clojure.core/assoc :platform (deser-set-dimension (input "Platform")))))

(clojure.core/defn- response-internal-server-error-exception ([input] (response-internal-server-error-exception nil input)) ([resultWrapper1396560 input] (clojure.core/let [rawinput1396559 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396561 {"Message" (rawinput1396559 "Message"), "RequestID" (rawinput1396559 "RequestID")}] (clojure.core/cond-> {} (letvar1396561 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1396561 ["Message"]))) (letvar1396561 "RequestID") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar1396561 ["RequestID"])))))))

(clojure.core/defn- response-method-not-allowed-exception ([input] (response-method-not-allowed-exception nil input)) ([resultWrapper1396563 input] (clojure.core/let [rawinput1396562 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396564 {"Message" (rawinput1396562 "Message"), "RequestID" (rawinput1396562 "RequestID")}] (clojure.core/cond-> {} (letvar1396564 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1396564 ["Message"]))) (letvar1396564 "RequestID") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar1396564 ["RequestID"])))))))

(clojure.core/defn- response-create-export-job-response ([input] (response-create-export-job-response nil input)) ([resultWrapper1396566 input] (clojure.core/let [rawinput1396565 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396567 {"ExportJobResponse" (rawinput1396565 "ExportJobResponse")}] (clojure.core/cond-> {:export-job-response (deser-export-job-response (clojure.core/get-in letvar1396567 ["ExportJobResponse"]))}))))

(clojure.core/defn- response-update-application-settings-response ([input] (response-update-application-settings-response nil input)) ([resultWrapper1396569 input] (clojure.core/let [rawinput1396568 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396570 {"ApplicationSettingsResource" (rawinput1396568 "ApplicationSettingsResource")}] (clojure.core/cond-> {:application-settings-resource (deser-application-settings-resource (clojure.core/get-in letvar1396570 ["ApplicationSettingsResource"]))}))))

(clojure.core/defn- response-send-messages-response ([input] (response-send-messages-response nil input)) ([resultWrapper1396572 input] (clojure.core/let [rawinput1396571 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396573 {"MessageResponse" (rawinput1396571 "MessageResponse")}] (clojure.core/cond-> {:message-response (deser-message-response (clojure.core/get-in letvar1396573 ["MessageResponse"]))}))))

(clojure.core/defn- response-delete-voice-channel-response ([input] (response-delete-voice-channel-response nil input)) ([resultWrapper1396575 input] (clojure.core/let [rawinput1396574 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396576 {"VoiceChannelResponse" (rawinput1396574 "VoiceChannelResponse")}] (clojure.core/cond-> {:voice-channel-response (deser-voice-channel-response (clojure.core/get-in letvar1396576 ["VoiceChannelResponse"]))}))))

(clojure.core/defn- response-delete-apns-sandbox-channel-response ([input] (response-delete-apns-sandbox-channel-response nil input)) ([resultWrapper1396578 input] (clojure.core/let [rawinput1396577 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396579 {"APNSSandboxChannelResponse" (rawinput1396577 "APNSSandboxChannelResponse")}] (clojure.core/cond-> {:apns-sandbox-channel-response (deser-apns-sandbox-channel-response (clojure.core/get-in letvar1396579 ["APNSSandboxChannelResponse"]))}))))

(clojure.core/defn- response-create-app-response ([input] (response-create-app-response nil input)) ([resultWrapper1396581 input] (clojure.core/let [rawinput1396580 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396582 {"ApplicationResponse" (rawinput1396580 "ApplicationResponse")}] (clojure.core/cond-> {:application-response (deser-application-response (clojure.core/get-in letvar1396582 ["ApplicationResponse"]))}))))

(clojure.core/defn- response-send-users-messages-response ([input] (response-send-users-messages-response nil input)) ([resultWrapper1396584 input] (clojure.core/let [rawinput1396583 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396585 {"SendUsersMessageResponse" (rawinput1396583 "SendUsersMessageResponse")}] (clojure.core/cond-> {:send-users-message-response (deser-send-users-message-response (clojure.core/get-in letvar1396585 ["SendUsersMessageResponse"]))}))))

(clojure.core/defn- response-get-endpoint-response ([input] (response-get-endpoint-response nil input)) ([resultWrapper1396587 input] (clojure.core/let [rawinput1396586 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396588 {"EndpointResponse" (rawinput1396586 "EndpointResponse")}] (clojure.core/cond-> {:endpoint-response (deser-endpoint-response (clojure.core/get-in letvar1396588 ["EndpointResponse"]))}))))

(clojure.core/defn- response-get-apps-response ([input] (response-get-apps-response nil input)) ([resultWrapper1396590 input] (clojure.core/let [rawinput1396589 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396591 {"ApplicationsResponse" (rawinput1396589 "ApplicationsResponse")}] (clojure.core/cond-> {:applications-response (deser-applications-response (clojure.core/get-in letvar1396591 ["ApplicationsResponse"]))}))))

(clojure.core/defn- response-get-adm-channel-response ([input] (response-get-adm-channel-response nil input)) ([resultWrapper1396593 input] (clojure.core/let [rawinput1396592 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396594 {"ADMChannelResponse" (rawinput1396592 "ADMChannelResponse")}] (clojure.core/cond-> {:adm-channel-response (deser-adm-channel-response (clojure.core/get-in letvar1396594 ["ADMChannelResponse"]))}))))

(clojure.core/defn- response-get-application-settings-response ([input] (response-get-application-settings-response nil input)) ([resultWrapper1396596 input] (clojure.core/let [rawinput1396595 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396597 {"ApplicationSettingsResource" (rawinput1396595 "ApplicationSettingsResource")}] (clojure.core/cond-> {:application-settings-resource (deser-application-settings-resource (clojure.core/get-in letvar1396597 ["ApplicationSettingsResource"]))}))))

(clojure.core/defn- response-get-app-response ([input] (response-get-app-response nil input)) ([resultWrapper1396599 input] (clojure.core/let [rawinput1396598 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396600 {"ApplicationResponse" (rawinput1396598 "ApplicationResponse")}] (clojure.core/cond-> {:application-response (deser-application-response (clojure.core/get-in letvar1396600 ["ApplicationResponse"]))}))))

(clojure.core/defn- response-bad-request-exception ([input] (response-bad-request-exception nil input)) ([resultWrapper1396602 input] (clojure.core/let [rawinput1396601 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396603 {"Message" (rawinput1396601 "Message"), "RequestID" (rawinput1396601 "RequestID")}] (clojure.core/cond-> {} (letvar1396603 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1396603 ["Message"]))) (letvar1396603 "RequestID") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar1396603 ["RequestID"])))))))

(clojure.core/defn- response-get-campaigns-response ([input] (response-get-campaigns-response nil input)) ([resultWrapper1396605 input] (clojure.core/let [rawinput1396604 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396606 {"CampaignsResponse" (rawinput1396604 "CampaignsResponse")}] (clojure.core/cond-> {:campaigns-response (deser-campaigns-response (clojure.core/get-in letvar1396606 ["CampaignsResponse"]))}))))

(clojure.core/defn- response-list-tags-for-resource-response ([input] (response-list-tags-for-resource-response nil input)) ([resultWrapper1396608 input] (clojure.core/let [rawinput1396607 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396609 {"TagsModel" (rawinput1396607 "TagsModel")}] (clojure.core/cond-> {:tags-model (deser-tags-model (clojure.core/get-in letvar1396609 ["TagsModel"]))}))))

(clojure.core/defn- response-get-voice-channel-response ([input] (response-get-voice-channel-response nil input)) ([resultWrapper1396611 input] (clojure.core/let [rawinput1396610 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396612 {"VoiceChannelResponse" (rawinput1396610 "VoiceChannelResponse")}] (clojure.core/cond-> {:voice-channel-response (deser-voice-channel-response (clojure.core/get-in letvar1396612 ["VoiceChannelResponse"]))}))))

(clojure.core/defn- response-delete-adm-channel-response ([input] (response-delete-adm-channel-response nil input)) ([resultWrapper1396614 input] (clojure.core/let [rawinput1396613 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396615 {"ADMChannelResponse" (rawinput1396613 "ADMChannelResponse")}] (clojure.core/cond-> {:adm-channel-response (deser-adm-channel-response (clojure.core/get-in letvar1396615 ["ADMChannelResponse"]))}))))

(clojure.core/defn- response-phone-number-validate-response ([input] (response-phone-number-validate-response nil input)) ([resultWrapper1396617 input] (clojure.core/let [rawinput1396616 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396618 {"NumberValidateResponse" (rawinput1396616 "NumberValidateResponse")}] (clojure.core/cond-> {:number-validate-response (deser-number-validate-response (clojure.core/get-in letvar1396618 ["NumberValidateResponse"]))}))))

(clojure.core/defn- response-get-campaign-versions-response ([input] (response-get-campaign-versions-response nil input)) ([resultWrapper1396620 input] (clojure.core/let [rawinput1396619 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396621 {"CampaignsResponse" (rawinput1396619 "CampaignsResponse")}] (clojure.core/cond-> {:campaigns-response (deser-campaigns-response (clojure.core/get-in letvar1396621 ["CampaignsResponse"]))}))))

(clojure.core/defn- response-delete-apns-channel-response ([input] (response-delete-apns-channel-response nil input)) ([resultWrapper1396623 input] (clojure.core/let [rawinput1396622 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396624 {"APNSChannelResponse" (rawinput1396622 "APNSChannelResponse")}] (clojure.core/cond-> {:apns-channel-response (deser-apns-channel-response (clojure.core/get-in letvar1396624 ["APNSChannelResponse"]))}))))

(clojure.core/defn- response-forbidden-exception ([input] (response-forbidden-exception nil input)) ([resultWrapper1396626 input] (clojure.core/let [rawinput1396625 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396627 {"Message" (rawinput1396625 "Message"), "RequestID" (rawinput1396625 "RequestID")}] (clojure.core/cond-> {} (letvar1396627 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1396627 ["Message"]))) (letvar1396627 "RequestID") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar1396627 ["RequestID"])))))))

(clojure.core/defn- response-get-campaign-activities-response ([input] (response-get-campaign-activities-response nil input)) ([resultWrapper1396629 input] (clojure.core/let [rawinput1396628 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396630 {"ActivitiesResponse" (rawinput1396628 "ActivitiesResponse")}] (clojure.core/cond-> {:activities-response (deser-activities-response (clojure.core/get-in letvar1396630 ["ActivitiesResponse"]))}))))

(clojure.core/defn- response-update-segment-response ([input] (response-update-segment-response nil input)) ([resultWrapper1396632 input] (clojure.core/let [rawinput1396631 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396633 {"SegmentResponse" (rawinput1396631 "SegmentResponse")}] (clojure.core/cond-> {:segment-response (deser-segment-response (clojure.core/get-in letvar1396633 ["SegmentResponse"]))}))))

(clojure.core/defn- response-update-adm-channel-response ([input] (response-update-adm-channel-response nil input)) ([resultWrapper1396635 input] (clojure.core/let [rawinput1396634 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396636 {"ADMChannelResponse" (rawinput1396634 "ADMChannelResponse")}] (clojure.core/cond-> {:adm-channel-response (deser-adm-channel-response (clojure.core/get-in letvar1396636 ["ADMChannelResponse"]))}))))

(clojure.core/defn- response-get-apns-channel-response ([input] (response-get-apns-channel-response nil input)) ([resultWrapper1396638 input] (clojure.core/let [rawinput1396637 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396639 {"APNSChannelResponse" (rawinput1396637 "APNSChannelResponse")}] (clojure.core/cond-> {:apns-channel-response (deser-apns-channel-response (clojure.core/get-in letvar1396639 ["APNSChannelResponse"]))}))))

(clojure.core/defn- response-get-campaign-version-response ([input] (response-get-campaign-version-response nil input)) ([resultWrapper1396641 input] (clojure.core/let [rawinput1396640 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396642 {"CampaignResponse" (rawinput1396640 "CampaignResponse")}] (clojure.core/cond-> {:campaign-response (deser-campaign-response (clojure.core/get-in letvar1396642 ["CampaignResponse"]))}))))

(clojure.core/defn- response-delete-campaign-response ([input] (response-delete-campaign-response nil input)) ([resultWrapper1396644 input] (clojure.core/let [rawinput1396643 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396645 {"CampaignResponse" (rawinput1396643 "CampaignResponse")}] (clojure.core/cond-> {:campaign-response (deser-campaign-response (clojure.core/get-in letvar1396645 ["CampaignResponse"]))}))))

(clojure.core/defn- response-create-segment-response ([input] (response-create-segment-response nil input)) ([resultWrapper1396647 input] (clojure.core/let [rawinput1396646 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396648 {"SegmentResponse" (rawinput1396646 "SegmentResponse")}] (clojure.core/cond-> {:segment-response (deser-segment-response (clojure.core/get-in letvar1396648 ["SegmentResponse"]))}))))

(clojure.core/defn- response-update-sms-channel-response ([input] (response-update-sms-channel-response nil input)) ([resultWrapper1396650 input] (clojure.core/let [rawinput1396649 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396651 {"SMSChannelResponse" (rawinput1396649 "SMSChannelResponse")}] (clojure.core/cond-> {:sms-channel-response (deser-sms-channel-response (clojure.core/get-in letvar1396651 ["SMSChannelResponse"]))}))))

(clojure.core/defn- response-get-segments-response ([input] (response-get-segments-response nil input)) ([resultWrapper1396653 input] (clojure.core/let [rawinput1396652 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396654 {"SegmentsResponse" (rawinput1396652 "SegmentsResponse")}] (clojure.core/cond-> {:segments-response (deser-segments-response (clojure.core/get-in letvar1396654 ["SegmentsResponse"]))}))))

(clojure.core/defn- response-delete-sms-channel-response ([input] (response-delete-sms-channel-response nil input)) ([resultWrapper1396656 input] (clojure.core/let [rawinput1396655 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396657 {"SMSChannelResponse" (rawinput1396655 "SMSChannelResponse")}] (clojure.core/cond-> {:sms-channel-response (deser-sms-channel-response (clojure.core/get-in letvar1396657 ["SMSChannelResponse"]))}))))

(clojure.core/defn- response-get-baidu-channel-response ([input] (response-get-baidu-channel-response nil input)) ([resultWrapper1396659 input] (clojure.core/let [rawinput1396658 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396660 {"BaiduChannelResponse" (rawinput1396658 "BaiduChannelResponse")}] (clojure.core/cond-> {:baidu-channel-response (deser-baidu-channel-response (clojure.core/get-in letvar1396660 ["BaiduChannelResponse"]))}))))

(clojure.core/defn- response-delete-apns-voip-channel-response ([input] (response-delete-apns-voip-channel-response nil input)) ([resultWrapper1396662 input] (clojure.core/let [rawinput1396661 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396663 {"APNSVoipChannelResponse" (rawinput1396661 "APNSVoipChannelResponse")}] (clojure.core/cond-> {:apns-voip-channel-response (deser-apns-voip-channel-response (clojure.core/get-in letvar1396663 ["APNSVoipChannelResponse"]))}))))

(clojure.core/defn- response-put-events-response ([input] (response-put-events-response nil input)) ([resultWrapper1396665 input] (clojure.core/let [rawinput1396664 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396666 {"EventsResponse" (rawinput1396664 "EventsResponse")}] (clojure.core/cond-> {:events-response (deser-events-response (clojure.core/get-in letvar1396666 ["EventsResponse"]))}))))

(clojure.core/defn- response-update-endpoint-response ([input] (response-update-endpoint-response nil input)) ([resultWrapper1396668 input] (clojure.core/let [rawinput1396667 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396669 {"MessageBody" (rawinput1396667 "MessageBody")}] (clojure.core/cond-> {:message-body (deser-message-body (clojure.core/get-in letvar1396669 ["MessageBody"]))}))))

(clojure.core/defn- response-update-baidu-channel-response ([input] (response-update-baidu-channel-response nil input)) ([resultWrapper1396671 input] (clojure.core/let [rawinput1396670 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396672 {"BaiduChannelResponse" (rawinput1396670 "BaiduChannelResponse")}] (clojure.core/cond-> {:baidu-channel-response (deser-baidu-channel-response (clojure.core/get-in letvar1396672 ["BaiduChannelResponse"]))}))))

(clojure.core/defn- response-get-segment-versions-response ([input] (response-get-segment-versions-response nil input)) ([resultWrapper1396674 input] (clojure.core/let [rawinput1396673 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396675 {"SegmentsResponse" (rawinput1396673 "SegmentsResponse")}] (clojure.core/cond-> {:segments-response (deser-segments-response (clojure.core/get-in letvar1396675 ["SegmentsResponse"]))}))))

(clojure.core/defn- response-delete-app-response ([input] (response-delete-app-response nil input)) ([resultWrapper1396677 input] (clojure.core/let [rawinput1396676 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396678 {"ApplicationResponse" (rawinput1396676 "ApplicationResponse")}] (clojure.core/cond-> {:application-response (deser-application-response (clojure.core/get-in letvar1396678 ["ApplicationResponse"]))}))))

(clojure.core/defn- response-too-many-requests-exception ([input] (response-too-many-requests-exception nil input)) ([resultWrapper1396680 input] (clojure.core/let [rawinput1396679 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396681 {"Message" (rawinput1396679 "Message"), "RequestID" (rawinput1396679 "RequestID")}] (clojure.core/cond-> {} (letvar1396681 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1396681 ["Message"]))) (letvar1396681 "RequestID") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar1396681 ["RequestID"])))))))

(clojure.core/defn- response-get-gcm-channel-response ([input] (response-get-gcm-channel-response nil input)) ([resultWrapper1396683 input] (clojure.core/let [rawinput1396682 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396684 {"GCMChannelResponse" (rawinput1396682 "GCMChannelResponse")}] (clojure.core/cond-> {:gcm-channel-response (deser-gcm-channel-response (clojure.core/get-in letvar1396684 ["GCMChannelResponse"]))}))))

(clojure.core/defn- response-get-event-stream-response ([input] (response-get-event-stream-response nil input)) ([resultWrapper1396686 input] (clojure.core/let [rawinput1396685 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396687 {"EventStream" (rawinput1396685 "EventStream")}] (clojure.core/cond-> {:event-stream (deser-event-stream (clojure.core/get-in letvar1396687 ["EventStream"]))}))))

(clojure.core/defn- response-update-apns-voip-sandbox-channel-response ([input] (response-update-apns-voip-sandbox-channel-response nil input)) ([resultWrapper1396689 input] (clojure.core/let [rawinput1396688 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396690 {"APNSVoipSandboxChannelResponse" (rawinput1396688 "APNSVoipSandboxChannelResponse")}] (clojure.core/cond-> {:apns-voip-sandbox-channel-response (deser-apns-voip-sandbox-channel-response (clojure.core/get-in letvar1396690 ["APNSVoipSandboxChannelResponse"]))}))))

(clojure.core/defn- response-remove-attributes-response ([input] (response-remove-attributes-response nil input)) ([resultWrapper1396692 input] (clojure.core/let [rawinput1396691 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396693 {"AttributesResource" (rawinput1396691 "AttributesResource")}] (clojure.core/cond-> {:attributes-resource (deser-attributes-resource (clojure.core/get-in letvar1396693 ["AttributesResource"]))}))))

(clojure.core/defn- response-get-import-job-response ([input] (response-get-import-job-response nil input)) ([resultWrapper1396695 input] (clojure.core/let [rawinput1396694 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396696 {"ImportJobResponse" (rawinput1396694 "ImportJobResponse")}] (clojure.core/cond-> {:import-job-response (deser-import-job-response (clojure.core/get-in letvar1396696 ["ImportJobResponse"]))}))))

(clojure.core/defn- response-get-export-jobs-response ([input] (response-get-export-jobs-response nil input)) ([resultWrapper1396698 input] (clojure.core/let [rawinput1396697 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396699 {"ExportJobsResponse" (rawinput1396697 "ExportJobsResponse")}] (clojure.core/cond-> {:export-jobs-response (deser-export-jobs-response (clojure.core/get-in letvar1396699 ["ExportJobsResponse"]))}))))

(clojure.core/defn- response-delete-endpoint-response ([input] (response-delete-endpoint-response nil input)) ([resultWrapper1396701 input] (clojure.core/let [rawinput1396700 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396702 {"EndpointResponse" (rawinput1396700 "EndpointResponse")}] (clojure.core/cond-> {:endpoint-response (deser-endpoint-response (clojure.core/get-in letvar1396702 ["EndpointResponse"]))}))))

(clojure.core/defn- response-not-found-exception ([input] (response-not-found-exception nil input)) ([resultWrapper1396704 input] (clojure.core/let [rawinput1396703 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396705 {"Message" (rawinput1396703 "Message"), "RequestID" (rawinput1396703 "RequestID")}] (clojure.core/cond-> {} (letvar1396705 "Message") (clojure.core/assoc :message (deser-string (clojure.core/get-in letvar1396705 ["Message"]))) (letvar1396705 "RequestID") (clojure.core/assoc :request-id (deser-string (clojure.core/get-in letvar1396705 ["RequestID"])))))))

(clojure.core/defn- response-update-gcm-channel-response ([input] (response-update-gcm-channel-response nil input)) ([resultWrapper1396707 input] (clojure.core/let [rawinput1396706 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396708 {"GCMChannelResponse" (rawinput1396706 "GCMChannelResponse")}] (clojure.core/cond-> {:gcm-channel-response (deser-gcm-channel-response (clojure.core/get-in letvar1396708 ["GCMChannelResponse"]))}))))

(clojure.core/defn- response-update-apns-voip-channel-response ([input] (response-update-apns-voip-channel-response nil input)) ([resultWrapper1396710 input] (clojure.core/let [rawinput1396709 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396711 {"APNSVoipChannelResponse" (rawinput1396709 "APNSVoipChannelResponse")}] (clojure.core/cond-> {:apns-voip-channel-response (deser-apns-voip-channel-response (clojure.core/get-in letvar1396711 ["APNSVoipChannelResponse"]))}))))

(clojure.core/defn- response-get-campaign-response ([input] (response-get-campaign-response nil input)) ([resultWrapper1396713 input] (clojure.core/let [rawinput1396712 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396714 {"CampaignResponse" (rawinput1396712 "CampaignResponse")}] (clojure.core/cond-> {:campaign-response (deser-campaign-response (clojure.core/get-in letvar1396714 ["CampaignResponse"]))}))))

(clojure.core/defn- response-delete-gcm-channel-response ([input] (response-delete-gcm-channel-response nil input)) ([resultWrapper1396716 input] (clojure.core/let [rawinput1396715 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396717 {"GCMChannelResponse" (rawinput1396715 "GCMChannelResponse")}] (clojure.core/cond-> {:gcm-channel-response (deser-gcm-channel-response (clojure.core/get-in letvar1396717 ["GCMChannelResponse"]))}))))

(clojure.core/defn- response-get-segment-version-response ([input] (response-get-segment-version-response nil input)) ([resultWrapper1396719 input] (clojure.core/let [rawinput1396718 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396720 {"SegmentResponse" (rawinput1396718 "SegmentResponse")}] (clojure.core/cond-> {:segment-response (deser-segment-response (clojure.core/get-in letvar1396720 ["SegmentResponse"]))}))))

(clojure.core/defn- response-put-event-stream-response ([input] (response-put-event-stream-response nil input)) ([resultWrapper1396722 input] (clojure.core/let [rawinput1396721 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396723 {"EventStream" (rawinput1396721 "EventStream")}] (clojure.core/cond-> {:event-stream (deser-event-stream (clojure.core/get-in letvar1396723 ["EventStream"]))}))))

(clojure.core/defn- response-update-apns-channel-response ([input] (response-update-apns-channel-response nil input)) ([resultWrapper1396725 input] (clojure.core/let [rawinput1396724 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396726 {"APNSChannelResponse" (rawinput1396724 "APNSChannelResponse")}] (clojure.core/cond-> {:apns-channel-response (deser-apns-channel-response (clojure.core/get-in letvar1396726 ["APNSChannelResponse"]))}))))

(clojure.core/defn- response-create-import-job-response ([input] (response-create-import-job-response nil input)) ([resultWrapper1396728 input] (clojure.core/let [rawinput1396727 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396729 {"ImportJobResponse" (rawinput1396727 "ImportJobResponse")}] (clojure.core/cond-> {:import-job-response (deser-import-job-response (clojure.core/get-in letvar1396729 ["ImportJobResponse"]))}))))

(clojure.core/defn- response-get-user-endpoints-response ([input] (response-get-user-endpoints-response nil input)) ([resultWrapper1396731 input] (clojure.core/let [rawinput1396730 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396732 {"EndpointsResponse" (rawinput1396730 "EndpointsResponse")}] (clojure.core/cond-> {:endpoints-response (deser-endpoints-response (clojure.core/get-in letvar1396732 ["EndpointsResponse"]))}))))

(clojure.core/defn- response-delete-email-channel-response ([input] (response-delete-email-channel-response nil input)) ([resultWrapper1396734 input] (clojure.core/let [rawinput1396733 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396735 {"EmailChannelResponse" (rawinput1396733 "EmailChannelResponse")}] (clojure.core/cond-> {:email-channel-response (deser-email-channel-response (clojure.core/get-in letvar1396735 ["EmailChannelResponse"]))}))))

(clojure.core/defn- response-get-segment-export-jobs-response ([input] (response-get-segment-export-jobs-response nil input)) ([resultWrapper1396737 input] (clojure.core/let [rawinput1396736 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396738 {"ExportJobsResponse" (rawinput1396736 "ExportJobsResponse")}] (clojure.core/cond-> {:export-jobs-response (deser-export-jobs-response (clojure.core/get-in letvar1396738 ["ExportJobsResponse"]))}))))

(clojure.core/defn- response-get-segment-import-jobs-response ([input] (response-get-segment-import-jobs-response nil input)) ([resultWrapper1396740 input] (clojure.core/let [rawinput1396739 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396741 {"ImportJobsResponse" (rawinput1396739 "ImportJobsResponse")}] (clojure.core/cond-> {:import-jobs-response (deser-import-jobs-response (clojure.core/get-in letvar1396741 ["ImportJobsResponse"]))}))))

(clojure.core/defn- response-update-campaign-response ([input] (response-update-campaign-response nil input)) ([resultWrapper1396743 input] (clojure.core/let [rawinput1396742 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396744 {"CampaignResponse" (rawinput1396742 "CampaignResponse")}] (clojure.core/cond-> {:campaign-response (deser-campaign-response (clojure.core/get-in letvar1396744 ["CampaignResponse"]))}))))

(clojure.core/defn- response-update-voice-channel-response ([input] (response-update-voice-channel-response nil input)) ([resultWrapper1396746 input] (clojure.core/let [rawinput1396745 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396747 {"VoiceChannelResponse" (rawinput1396745 "VoiceChannelResponse")}] (clojure.core/cond-> {:voice-channel-response (deser-voice-channel-response (clojure.core/get-in letvar1396747 ["VoiceChannelResponse"]))}))))

(clojure.core/defn- response-update-endpoints-batch-response ([input] (response-update-endpoints-batch-response nil input)) ([resultWrapper1396749 input] (clojure.core/let [rawinput1396748 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396750 {"MessageBody" (rawinput1396748 "MessageBody")}] (clojure.core/cond-> {:message-body (deser-message-body (clojure.core/get-in letvar1396750 ["MessageBody"]))}))))

(clojure.core/defn- response-delete-segment-response ([input] (response-delete-segment-response nil input)) ([resultWrapper1396752 input] (clojure.core/let [rawinput1396751 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396753 {"SegmentResponse" (rawinput1396751 "SegmentResponse")}] (clojure.core/cond-> {:segment-response (deser-segment-response (clojure.core/get-in letvar1396753 ["SegmentResponse"]))}))))

(clojure.core/defn- response-get-apns-voip-sandbox-channel-response ([input] (response-get-apns-voip-sandbox-channel-response nil input)) ([resultWrapper1396755 input] (clojure.core/let [rawinput1396754 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396756 {"APNSVoipSandboxChannelResponse" (rawinput1396754 "APNSVoipSandboxChannelResponse")}] (clojure.core/cond-> {:apns-voip-sandbox-channel-response (deser-apns-voip-sandbox-channel-response (clojure.core/get-in letvar1396756 ["APNSVoipSandboxChannelResponse"]))}))))

(clojure.core/defn- response-create-campaign-response ([input] (response-create-campaign-response nil input)) ([resultWrapper1396758 input] (clojure.core/let [rawinput1396757 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396759 {"CampaignResponse" (rawinput1396757 "CampaignResponse")}] (clojure.core/cond-> {:campaign-response (deser-campaign-response (clojure.core/get-in letvar1396759 ["CampaignResponse"]))}))))

(clojure.core/defn- response-delete-user-endpoints-response ([input] (response-delete-user-endpoints-response nil input)) ([resultWrapper1396761 input] (clojure.core/let [rawinput1396760 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396762 {"EndpointsResponse" (rawinput1396760 "EndpointsResponse")}] (clojure.core/cond-> {:endpoints-response (deser-endpoints-response (clojure.core/get-in letvar1396762 ["EndpointsResponse"]))}))))

(clojure.core/defn- response-delete-apns-voip-sandbox-channel-response ([input] (response-delete-apns-voip-sandbox-channel-response nil input)) ([resultWrapper1396764 input] (clojure.core/let [rawinput1396763 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396765 {"APNSVoipSandboxChannelResponse" (rawinput1396763 "APNSVoipSandboxChannelResponse")}] (clojure.core/cond-> {:apns-voip-sandbox-channel-response (deser-apns-voip-sandbox-channel-response (clojure.core/get-in letvar1396765 ["APNSVoipSandboxChannelResponse"]))}))))

(clojure.core/defn- response-get-segment-response ([input] (response-get-segment-response nil input)) ([resultWrapper1396767 input] (clojure.core/let [rawinput1396766 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396768 {"SegmentResponse" (rawinput1396766 "SegmentResponse")}] (clojure.core/cond-> {:segment-response (deser-segment-response (clojure.core/get-in letvar1396768 ["SegmentResponse"]))}))))

(clojure.core/defn- response-get-export-job-response ([input] (response-get-export-job-response nil input)) ([resultWrapper1396770 input] (clojure.core/let [rawinput1396769 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396771 {"ExportJobResponse" (rawinput1396769 "ExportJobResponse")}] (clojure.core/cond-> {:export-job-response (deser-export-job-response (clojure.core/get-in letvar1396771 ["ExportJobResponse"]))}))))

(clojure.core/defn- response-get-import-jobs-response ([input] (response-get-import-jobs-response nil input)) ([resultWrapper1396773 input] (clojure.core/let [rawinput1396772 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396774 {"ImportJobsResponse" (rawinput1396772 "ImportJobsResponse")}] (clojure.core/cond-> {:import-jobs-response (deser-import-jobs-response (clojure.core/get-in letvar1396774 ["ImportJobsResponse"]))}))))

(clojure.core/defn- response-get-channels-response ([input] (response-get-channels-response nil input)) ([resultWrapper1396776 input] (clojure.core/let [rawinput1396775 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396777 {"ChannelsResponse" (rawinput1396775 "ChannelsResponse")}] (clojure.core/cond-> {:channels-response (deser-channels-response (clojure.core/get-in letvar1396777 ["ChannelsResponse"]))}))))

(clojure.core/defn- response-delete-event-stream-response ([input] (response-delete-event-stream-response nil input)) ([resultWrapper1396779 input] (clojure.core/let [rawinput1396778 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396780 {"EventStream" (rawinput1396778 "EventStream")}] (clojure.core/cond-> {:event-stream (deser-event-stream (clojure.core/get-in letvar1396780 ["EventStream"]))}))))

(clojure.core/defn- response-update-apns-sandbox-channel-response ([input] (response-update-apns-sandbox-channel-response nil input)) ([resultWrapper1396782 input] (clojure.core/let [rawinput1396781 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396783 {"APNSSandboxChannelResponse" (rawinput1396781 "APNSSandboxChannelResponse")}] (clojure.core/cond-> {:apns-sandbox-channel-response (deser-apns-sandbox-channel-response (clojure.core/get-in letvar1396783 ["APNSSandboxChannelResponse"]))}))))

(clojure.core/defn- response-get-sms-channel-response ([input] (response-get-sms-channel-response nil input)) ([resultWrapper1396785 input] (clojure.core/let [rawinput1396784 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396786 {"SMSChannelResponse" (rawinput1396784 "SMSChannelResponse")}] (clojure.core/cond-> {:sms-channel-response (deser-sms-channel-response (clojure.core/get-in letvar1396786 ["SMSChannelResponse"]))}))))

(clojure.core/defn- response-get-apns-sandbox-channel-response ([input] (response-get-apns-sandbox-channel-response nil input)) ([resultWrapper1396788 input] (clojure.core/let [rawinput1396787 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396789 {"APNSSandboxChannelResponse" (rawinput1396787 "APNSSandboxChannelResponse")}] (clojure.core/cond-> {:apns-sandbox-channel-response (deser-apns-sandbox-channel-response (clojure.core/get-in letvar1396789 ["APNSSandboxChannelResponse"]))}))))

(clojure.core/defn- response-delete-baidu-channel-response ([input] (response-delete-baidu-channel-response nil input)) ([resultWrapper1396791 input] (clojure.core/let [rawinput1396790 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396792 {"BaiduChannelResponse" (rawinput1396790 "BaiduChannelResponse")}] (clojure.core/cond-> {:baidu-channel-response (deser-baidu-channel-response (clojure.core/get-in letvar1396792 ["BaiduChannelResponse"]))}))))

(clojure.core/defn- response-get-email-channel-response ([input] (response-get-email-channel-response nil input)) ([resultWrapper1396794 input] (clojure.core/let [rawinput1396793 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396795 {"EmailChannelResponse" (rawinput1396793 "EmailChannelResponse")}] (clojure.core/cond-> {:email-channel-response (deser-email-channel-response (clojure.core/get-in letvar1396795 ["EmailChannelResponse"]))}))))

(clojure.core/defn- response-get-apns-voip-channel-response ([input] (response-get-apns-voip-channel-response nil input)) ([resultWrapper1396797 input] (clojure.core/let [rawinput1396796 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396798 {"APNSVoipChannelResponse" (rawinput1396796 "APNSVoipChannelResponse")}] (clojure.core/cond-> {:apns-voip-channel-response (deser-apns-voip-channel-response (clojure.core/get-in letvar1396798 ["APNSVoipChannelResponse"]))}))))

(clojure.core/defn- response-update-email-channel-response ([input] (response-update-email-channel-response nil input)) ([resultWrapper1396800 input] (clojure.core/let [rawinput1396799 (clojure.core/some-> input :body portkey.aws/parse-json-body) letvar1396801 {"EmailChannelResponse" (rawinput1396799 "EmailChannelResponse")}] (clojure.core/cond-> {:email-channel-response (deser-email-channel-response (clojure.core/get-in letvar1396801 ["EmailChannelResponse"]))}))))

(clojure.spec.alpha/def :portkey.aws.pinpoint.treatment-resource/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.treatment-resource/size-percent (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.treatment-resource/state (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-state))
(clojure.spec.alpha/def :portkey.aws.pinpoint.treatment-resource/treatment-description (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.treatment-resource/treatment-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/treatment-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.treatment-resource/id :portkey.aws.pinpoint/message-configuration :portkey.aws.pinpoint/schedule :portkey.aws.pinpoint.treatment-resource/size-percent :portkey.aws.pinpoint.treatment-resource/state :portkey.aws.pinpoint.treatment-resource/treatment-description :portkey.aws.pinpoint.treatment-resource/treatment-name]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.export-jobs-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-export-job-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-jobs-response/next-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/export-jobs-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.export-jobs-response/item :portkey.aws.pinpoint.export-jobs-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/attribute-type #{:exclusive :inclusive "EXCLUSIVE" "INCLUSIVE"})

(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/define-segment (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/external-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/register-endpoints (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/s-3-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-request/segment-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/import-job-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.import-job-request/define-segment :portkey.aws.pinpoint.import-job-request/external-id :portkey.aws.pinpoint/format :portkey.aws.pinpoint.import-job-request/register-endpoints :portkey.aws.pinpoint.import-job-request/role-arn :portkey.aws.pinpoint.import-job-request/s-3-url :portkey.aws.pinpoint.import-job-request/segment-id :portkey.aws.pinpoint.import-job-request/segment-name]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-apns-voip-sandbox-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-voip-sandbox-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-apns-voip-sandbox-channel-request/application-id :portkey.aws.pinpoint/apns-voip-sandbox-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.raw-email/data (clojure.spec.alpha/and :portkey.aws.pinpoint/blob))
(clojure.spec.alpha/def :portkey.aws.pinpoint/raw-email (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.raw-email/data]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.internal-server-error-exception/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.internal-server-error-exception/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/internal-server-error-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.internal-server-error-exception/message :portkey.aws.pinpoint.internal-server-error-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-group-list/groups (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-segment-group))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-group-list (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-group-list/groups :portkey.aws.pinpoint/include]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.simple-email-part/charset (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.simple-email-part/data (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/simple-email-part (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.simple-email-part/charset :portkey.aws.pinpoint.simple-email-part/data]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.method-not-allowed-exception/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.method-not-allowed-exception/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/method-not-allowed-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.method-not-allowed-exception/message :portkey.aws.pinpoint.method-not-allowed-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/additional-treatments (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-write-treatment-resource))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/treatment-description (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/treatment-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/limits (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-limits))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/segment-version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/description (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/is-paused (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/hook (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-hook))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-campaign-request/holdout-percent (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/write-campaign-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.write-campaign-request/additional-treatments :portkey.aws.pinpoint.write-campaign-request/tags :portkey.aws.pinpoint.write-campaign-request/treatment-description :portkey.aws.pinpoint.write-campaign-request/treatment-name :portkey.aws.pinpoint.write-campaign-request/limits :portkey.aws.pinpoint.write-campaign-request/segment-version :portkey.aws.pinpoint.write-campaign-request/description :portkey.aws.pinpoint.write-campaign-request/is-paused :portkey.aws.pinpoint.write-campaign-request/hook :portkey.aws.pinpoint/message-configuration :portkey.aws.pinpoint.write-campaign-request/segment-id :portkey.aws.pinpoint/schedule :portkey.aws.pinpoint.write-campaign-request/name :portkey.aws.pinpoint.write-campaign-request/holdout-percent]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/create-export-job-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/export-job-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/collapse-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/restricted-package-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/image-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/silent-push (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/sound (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/time-to-live (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/priority (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/small-image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/icon-reference (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/data (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-message/image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/gcm-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.gcm-message/collapse-key :portkey.aws.pinpoint.gcm-message/restricted-package-name :portkey.aws.pinpoint.gcm-message/body :portkey.aws.pinpoint.gcm-message/image-url :portkey.aws.pinpoint.gcm-message/title :portkey.aws.pinpoint.gcm-message/silent-push :portkey.aws.pinpoint.gcm-message/sound :portkey.aws.pinpoint.gcm-message/time-to-live :portkey.aws.pinpoint.gcm-message/priority :portkey.aws.pinpoint.gcm-message/raw-content :portkey.aws.pinpoint.gcm-message/url :portkey.aws.pinpoint.gcm-message/substitutions :portkey.aws.pinpoint.gcm-message/small-image-icon-url :portkey.aws.pinpoint.gcm-message/icon-reference :portkey.aws.pinpoint.gcm-message/data :portkey.aws.pinpoint.gcm-message/image-icon-url :portkey.aws.pinpoint/action]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-application-settings-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/application-settings-resource] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/send-messages-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/message-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.message-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-response/endpoint-result (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-endpoint-message-result))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-response/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-response/result (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-message-result))
(clojure.spec.alpha/def :portkey.aws.pinpoint/message-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.message-response/application-id :portkey.aws.pinpoint.message-response/endpoint-result :portkey.aws.pinpoint.message-response/request-id :portkey.aws.pinpoint.message-response/result]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint/voice-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.voice-channel-request/enabled]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-gcm-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-gcm-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-gcm-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-voice-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/voice-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-sandbox-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-sandbox-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/failures (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/completion-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/type (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/total-pieces (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/total-failures (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/definition (clojure.spec.alpha/and :portkey.aws.pinpoint/import-job-resource))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/failed-pieces (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/completed-pieces (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-response/total-processed (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/import-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/job-status :portkey.aws.pinpoint.import-job-response/failures :portkey.aws.pinpoint.import-job-response/completion-date :portkey.aws.pinpoint.import-job-response/type :portkey.aws.pinpoint.import-job-response/total-pieces :portkey.aws.pinpoint.import-job-response/total-failures :portkey.aws.pinpoint.import-job-response/application-id :portkey.aws.pinpoint.import-job-response/definition :portkey.aws.pinpoint.import-job-response/failed-pieces :portkey.aws.pinpoint.import-job-response/completed-pieces :portkey.aws.pinpoint.import-job-response/creation-date :portkey.aws.pinpoint.import-job-response/id :portkey.aws.pinpoint.import-job-response/total-processed]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-baidu-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-baidu-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-baidu-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/create-app-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/application-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-voice-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-voice-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-voice-channel-request/application-id :portkey.aws.pinpoint/voice-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.create-export-job-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/create-export-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.create-export-job-request/application-id :portkey.aws.pinpoint/export-job-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-segment-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/segment-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint.message-request/addresses (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-address-configuration))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-request/context (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-request/endpoints (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-endpoint-send-configuration))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-request/message-configuration (clojure.spec.alpha/and :portkey.aws.pinpoint/direct-message-configuration))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-request/trace-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/message-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.message-request/addresses :portkey.aws.pinpoint.message-request/context :portkey.aws.pinpoint.message-request/endpoints :portkey.aws.pinpoint.message-request/message-configuration :portkey.aws.pinpoint.message-request/trace-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-segment-request/segment-id :portkey.aws.pinpoint.get-segment-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-state (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/campaign-status]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/send-users-messages-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/send-users-message-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-endpoint-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/endpoint-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-version-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-version-request/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-version-request/version (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-campaign-version-request/version :portkey.aws.pinpoint.get-campaign-version-request/application-id :portkey.aws.pinpoint.get-campaign-version-request/campaign-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/voice-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.voice-channel-response/has-credential :portkey.aws.pinpoint.voice-channel-response/platform :portkey.aws.pinpoint.voice-channel-response/last-modified-date :portkey.aws.pinpoint.voice-channel-response/enabled :portkey.aws.pinpoint.voice-channel-response/application-id :portkey.aws.pinpoint.voice-channel-response/is-archived :portkey.aws.pinpoint.voice-channel-response/creation-date :portkey.aws.pinpoint.voice-channel-response/version :portkey.aws.pinpoint.voice-channel-response/last-modified-by :portkey.aws.pinpoint.voice-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-limits/daily (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-limits/maximum-duration (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-limits/messages-per-second (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-limits/total (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-limits (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaign-limits/daily :portkey.aws.pinpoint.campaign-limits/maximum-duration :portkey.aws.pinpoint.campaign-limits/messages-per-second :portkey.aws.pinpoint.campaign-limits/total]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apps-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/applications-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/phone-number-validate-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/number-validate-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-adm-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/adm-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.create-campaign-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/create-campaign-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.create-campaign-request/application-id :portkey.aws.pinpoint/write-campaign-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/credential (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/gcm-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.gcm-channel-response/has-credential :portkey.aws.pinpoint.gcm-channel-response/platform :portkey.aws.pinpoint.gcm-channel-response/credential :portkey.aws.pinpoint.gcm-channel-response/last-modified-date :portkey.aws.pinpoint.gcm-channel-response/enabled :portkey.aws.pinpoint.gcm-channel-response/application-id :portkey.aws.pinpoint.gcm-channel-response/is-archived :portkey.aws.pinpoint.gcm-channel-response/creation-date :portkey.aws.pinpoint.gcm-channel-response/version :portkey.aws.pinpoint.gcm-channel-response/last-modified-by :portkey.aws.pinpoint.gcm-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.quiet-time/end (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.quiet-time/start (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/quiet-time (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.quiet-time/end :portkey.aws.pinpoint.quiet-time/start]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-application-settings-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/application-settings-resource] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-apns-voip-sandbox-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-voip-sandbox-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-apns-voip-sandbox-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-app-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/application-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-resource/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-resource/s-3-url-prefix (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-resource/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-resource/segment-version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/export-job-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.export-job-resource/role-arn :portkey.aws.pinpoint.export-job-resource/s-3-url-prefix :portkey.aws.pinpoint.export-job-resource/segment-id :portkey.aws.pinpoint.export-job-resource/segment-version]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.bad-request-exception/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.bad-request-exception/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/bad-request-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.bad-request-exception/message :portkey.aws.pinpoint.bad-request-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaigns-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaigns-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.events-response/results (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-item-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint/events-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.events-response/results]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-export-job-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/export-job-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/total-endpoint-count (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/timezones-completed-count (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/start (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/end (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/result (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/successful-endpoint-count (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/state (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/scheduled-start (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/timezones-total-count (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activity-response/treatment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/activity-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.activity-response/total-endpoint-count :portkey.aws.pinpoint.activity-response/timezones-completed-count :portkey.aws.pinpoint.activity-response/start :portkey.aws.pinpoint.activity-response/end :portkey.aws.pinpoint.activity-response/result :portkey.aws.pinpoint.activity-response/application-id :portkey.aws.pinpoint.activity-response/successful-endpoint-count :portkey.aws.pinpoint.activity-response/state :portkey.aws.pinpoint.activity-response/scheduled-start :portkey.aws.pinpoint.activity-response/timezones-total-count :portkey.aws.pinpoint.activity-response/campaign-id :portkey.aws.pinpoint.activity-response/id :portkey.aws.pinpoint.activity-response/treatment-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/job-status #{"COMPLETED" :initializing "FAILING" :processing :completed :created "COMPLETING" :failing "FAILED" :completing "INITIALIZING" "PROCESSING" :failed "CREATED"})

(clojure.spec.alpha/def :portkey.aws.pinpoint/create-app-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/create-application-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/image-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/silent-push (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/sound (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/time-to-live (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/small-image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/icon-reference (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/data (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-message/image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/baidu-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.baidu-message/body :portkey.aws.pinpoint.baidu-message/image-url :portkey.aws.pinpoint.baidu-message/title :portkey.aws.pinpoint.baidu-message/silent-push :portkey.aws.pinpoint.baidu-message/sound :portkey.aws.pinpoint.baidu-message/time-to-live :portkey.aws.pinpoint.baidu-message/raw-content :portkey.aws.pinpoint.baidu-message/url :portkey.aws.pinpoint.baidu-message/substitutions :portkey.aws.pinpoint.baidu-message/small-image-icon-url :portkey.aws.pinpoint.baidu-message/icon-reference :portkey.aws.pinpoint.baidu-message/data :portkey.aws.pinpoint.baidu-message/image-icon-url :portkey.aws.pinpoint/action]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.simple-email/html-part (clojure.spec.alpha/and :portkey.aws.pinpoint/simple-email-part))
(clojure.spec.alpha/def :portkey.aws.pinpoint.simple-email/subject (clojure.spec.alpha/and :portkey.aws.pinpoint/simple-email-part))
(clojure.spec.alpha/def :portkey.aws.pinpoint.simple-email/text-part (clojure.spec.alpha/and :portkey.aws.pinpoint/simple-email-part))
(clojure.spec.alpha/def :portkey.aws.pinpoint/simple-email (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.simple-email/html-part :portkey.aws.pinpoint.simple-email/subject :portkey.aws.pinpoint.simple-email/text-part]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-tags-for-resource-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/tags-model] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/type #{:all "NONE" "ANY" "ALL" :none :any})

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-gcm-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-gcm-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-gcm-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/default-state (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-state))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/additional-treatments (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-treatment-resource))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/treatment-description (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/treatment-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/limits (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-limits))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/segment-version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/description (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/is-paused (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/hook (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-hook))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/state (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-state))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-response/holdout-percent (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaign-response/default-state :portkey.aws.pinpoint.campaign-response/last-modified-date :portkey.aws.pinpoint.campaign-response/additional-treatments :portkey.aws.pinpoint.campaign-response/tags :portkey.aws.pinpoint.campaign-response/treatment-description :portkey.aws.pinpoint.campaign-response/treatment-name :portkey.aws.pinpoint.campaign-response/limits :portkey.aws.pinpoint.campaign-response/application-id :portkey.aws.pinpoint.campaign-response/segment-version :portkey.aws.pinpoint.campaign-response/description :portkey.aws.pinpoint.campaign-response/is-paused :portkey.aws.pinpoint.campaign-response/hook :portkey.aws.pinpoint.campaign-response/arn :portkey.aws.pinpoint/message-configuration :portkey.aws.pinpoint.campaign-response/segment-id :portkey.aws.pinpoint.campaign-response/creation-date :portkey.aws.pinpoint.campaign-response/state :portkey.aws.pinpoint.campaign-response/version :portkey.aws.pinpoint/schedule :portkey.aws.pinpoint.campaign-response/name :portkey.aws.pinpoint.campaign-response/id :portkey.aws.pinpoint.campaign-response/holdout-percent]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.create-application-request/name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.create-application-request/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/create-application-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.create-application-request/name :portkey.aws.pinpoint.create-application-request/tags]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-type #{:dimensional "IMPORT" "DIMENSIONAL" :import})

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-voice-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-voice-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-voice-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-apns-sandbox-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-sandbox-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-apns-sandbox-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.attribute-dimension/values (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/attribute-dimension (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/attribute-type :portkey.aws.pinpoint.attribute-dimension/values]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-apns-voip-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-voip-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-apns-voip-channel-request/application-id :portkey.aws.pinpoint/apns-voip-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-voice-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/voice-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/failures (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/completion-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/type (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/total-pieces (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/total-failures (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/definition (clojure.spec.alpha/and :portkey.aws.pinpoint/export-job-resource))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/failed-pieces (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/completed-pieces (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-response/total-processed (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/export-job-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/job-status :portkey.aws.pinpoint.export-job-response/failures :portkey.aws.pinpoint.export-job-response/completion-date :portkey.aws.pinpoint.export-job-response/type :portkey.aws.pinpoint.export-job-response/total-pieces :portkey.aws.pinpoint.export-job-response/total-failures :portkey.aws.pinpoint.export-job-response/application-id :portkey.aws.pinpoint.export-job-response/definition :portkey.aws.pinpoint.export-job-response/failed-pieces :portkey.aws.pinpoint.export-job-response/completed-pieces :portkey.aws.pinpoint.export-job-response/creation-date :portkey.aws.pinpoint.export-job-response/id :portkey.aws.pinpoint.export-job-response/total-processed]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-adm-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/adm-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-response/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-response/result (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-map-of-endpoint-message-result))
(clojure.spec.alpha/def :portkey.aws.pinpoint/send-users-message-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.send-users-message-response/application-id :portkey.aws.pinpoint.send-users-message-response/request-id :portkey.aws.pinpoint.send-users-message-response/result]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/recency-type #{:inactive :active "INACTIVE" "ACTIVE"})

(clojure.spec.alpha/def :portkey.aws.pinpoint/phone-number-validate-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/number-validate-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.application-response/arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.application-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.application-response/name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.application-response/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/application-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.application-response/arn :portkey.aws.pinpoint.application-response/id :portkey.aws.pinpoint.application-response/name :portkey.aws.pinpoint.application-response/tags]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-versions-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaigns-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.write-application-settings-request/cloud-watch-metrics-enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-application-settings-request/limits (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-limits))
(clojure.spec.alpha/def :portkey.aws.pinpoint/write-application-settings-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/campaign-hook :portkey.aws.pinpoint.write-application-settings-request/cloud-watch-metrics-enabled :portkey.aws.pinpoint.write-application-settings-request/limits :portkey.aws.pinpoint/quiet-time]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-adm-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-adm-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-adm-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-treatment-resource (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/treatment-resource))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-import-jobs-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-import-jobs-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-import-jobs-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-import-jobs-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-import-jobs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-segment-import-jobs-request/segment-id :portkey.aws.pinpoint.get-segment-import-jobs-request/application-id] :opt-un [:portkey.aws.pinpoint.get-segment-import-jobs-request/page-size :portkey.aws.pinpoint.get-segment-import-jobs-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.list-tags-for-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/list-tags-for-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.list-tags-for-resource-request/resource-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.forbidden-exception/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.forbidden-exception/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/forbidden-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.forbidden-exception/message :portkey.aws.pinpoint.forbidden-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-message-result (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/message-result))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-user/user-attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-user/user-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-user (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-user/user-attributes :portkey.aws.pinpoint.endpoint-user/user-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-import-job-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-import-job-request/job-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-import-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-import-job-request/application-id :portkey.aws.pinpoint.get-import-job-request/job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-item-response/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-item-response/status-code (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-item-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-item-response/message :portkey.aws.pinpoint.endpoint-item-response/status-code]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.activities-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-activity-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint.activities-response/next-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/activities-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.activities-response/item :portkey.aws.pinpoint.activities-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-event-filter/dimensions (clojure.spec.alpha/and :portkey.aws.pinpoint/event-dimensions))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-event-filter (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaign-event-filter/dimensions :portkey.aws.pinpoint/filter-type]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-events-batch (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/events-batch))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/bundle-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/certificate (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/private-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/team-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/token-key-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-voip-sandbox-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-voip-sandbox-channel-request/bundle-id :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/certificate :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/default-authentication-method :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/enabled :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/private-key :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/team-id :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/token-key :portkey.aws.pinpoint.apns-voip-sandbox-channel-request/token-key-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaigns-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-campaign-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaigns-response/next-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaigns-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaigns-response/item :portkey.aws.pinpoint.campaigns-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-activities-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/activities-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-apns-voip-sandbox-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-voip-sandbox-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-apns-voip-sandbox-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.pinpoint/delivery-status #{:permanent-failure :duplicate "PERMANENT_FAILURE" :unknown-failure :opt-out :successful "OPT_OUT" "TEMPORARY_FAILURE" "UNKNOWN_FAILURE" :throttled :temporary-failure "DUPLICATE" "THROTTLED" "SUCCESSFUL"})

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-segment-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segment-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-sms-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-sms-message/sender-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-sms-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaign-sms-message/body :portkey.aws.pinpoint/message-type :portkey.aws.pinpoint.campaign-sms-message/sender-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.attributes-resource/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.attributes-resource/attribute-type (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.attributes-resource/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/attributes-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.attributes-resource/application-id :portkey.aws.pinpoint.attributes-resource/attribute-type :portkey.aws.pinpoint.attributes-resource/attributes]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-adm-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/adm-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-apns-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-apns-channel-request/application-id :portkey.aws.pinpoint/apns-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-adm-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-adm-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-adm-channel-request/application-id :portkey.aws.pinpoint/adm-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-version-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaign-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-event-stream-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-event-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-event-stream-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-list-of-string (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/list-of-string))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-campaign-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaign-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/app-version (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/locale (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/make (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/model (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/model-version (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/platform-version (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-demographic/timezone (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-demographic (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-demographic/app-version :portkey.aws.pinpoint.endpoint-demographic/locale :portkey.aws.pinpoint.endpoint-demographic/make :portkey.aws.pinpoint.endpoint-demographic/model :portkey.aws.pinpoint.endpoint-demographic/model-version :portkey.aws.pinpoint.endpoint-demographic/platform :portkey.aws.pinpoint.endpoint-demographic/platform-version :portkey.aws.pinpoint.endpoint-demographic/timezone]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/create-segment-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segment-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-email-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-email-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-email-channel-request/application-id :portkey.aws.pinpoint/email-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-apns-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-apns-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/carrier (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/cleansed-phone-number-e-164 (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/phone-type-code (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/country (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/country-code-iso-2 (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/zip-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/timezone (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/country-code-numeric (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/original-phone-number (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/city (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/county (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/phone-type (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/original-country-code-iso-2 (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-response/cleansed-phone-number-national (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/number-validate-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.number-validate-response/carrier :portkey.aws.pinpoint.number-validate-response/cleansed-phone-number-e-164 :portkey.aws.pinpoint.number-validate-response/phone-type-code :portkey.aws.pinpoint.number-validate-response/country :portkey.aws.pinpoint.number-validate-response/country-code-iso-2 :portkey.aws.pinpoint.number-validate-response/zip-code :portkey.aws.pinpoint.number-validate-response/timezone :portkey.aws.pinpoint.number-validate-response/country-code-numeric :portkey.aws.pinpoint.number-validate-response/original-phone-number :portkey.aws.pinpoint.number-validate-response/city :portkey.aws.pinpoint.number-validate-response/county :portkey.aws.pinpoint.number-validate-response/phone-type :portkey.aws.pinpoint.number-validate-response/original-country-code-iso-2 :portkey.aws.pinpoint.number-validate-response/cleansed-phone-number-national]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/source-type #{:all "NONE" "ANY" "ALL" :none :any})

(clojure.spec.alpha/def :portkey.aws.pinpoint/format #{"CSV" :csv "JSON" :json})

(clojure.spec.alpha/def :portkey.aws.pinpoint.event/client-sdk-version (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/sdk-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/event-type (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/app-title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/app-package-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/timestamp (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/app-version-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/event (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.event/client-sdk-version :portkey.aws.pinpoint.event/sdk-name :portkey.aws.pinpoint.event/event-type :portkey.aws.pinpoint.event/attributes :portkey.aws.pinpoint.event/app-title :portkey.aws.pinpoint.event/app-package-name :portkey.aws.pinpoint.event/timestamp :portkey.aws.pinpoint.event/app-version-code :portkey.aws.pinpoint/session :portkey.aws.pinpoint.event/metrics]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoints-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-endpoint-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoints-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoints-response/item]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-voice-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-voice-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-voice-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/mode #{:delivery :filter "FILTER" "DELIVERY"})

(clojure.spec.alpha/def :portkey.aws.pinpoint.import-jobs-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-import-job-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-jobs-response/next-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/import-jobs-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.import-jobs-response/item :portkey.aws.pinpoint.import-jobs-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-sms-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/sms-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-endpoint-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-endpoint-request/endpoint-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-endpoint-request/application-id :portkey.aws.pinpoint.delete-endpoint-request/endpoint-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.event-dimensions/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-attribute-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-dimensions/event-type (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-dimensions/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-metric-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint/event-dimensions (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.event-dimensions/attributes :portkey.aws.pinpoint.event-dimensions/event-type :portkey.aws.pinpoint.event-dimensions/metrics]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segments-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segments-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-sms-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/sms-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/has-token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-voip-sandbox-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-voip-sandbox-channel-response/has-credential :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/has-token-key :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/platform :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/last-modified-date :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/enabled :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/application-id :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/is-archived :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/default-authentication-method :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/creation-date :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/version :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/last-modified-by :portkey.aws.pinpoint.apns-voip-sandbox-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-baidu-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/baidu-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-gcm-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-gcm-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-gcm-channel-request/application-id :portkey.aws.pinpoint/gcm-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-voip-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-voip-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/define-segment (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/external-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/register-endpoints (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/s-3-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.import-job-resource/segment-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/import-job-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.import-job-resource/define-segment :portkey.aws.pinpoint.import-job-resource/external-id :portkey.aws.pinpoint/format :portkey.aws.pinpoint.import-job-resource/register-endpoints :portkey.aws.pinpoint.import-job-resource/role-arn :portkey.aws.pinpoint.import-job-resource/s-3-url :portkey.aws.pinpoint.import-job-resource/segment-id :portkey.aws.pinpoint.import-job-resource/segment-name]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/put-events-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/events-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-string (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/string))

(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/transactional-messages-per-second (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/short-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/sender-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/promotional-messages-per-second (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/sms-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.sms-channel-response/transactional-messages-per-second :portkey.aws.pinpoint.sms-channel-response/has-credential :portkey.aws.pinpoint.sms-channel-response/platform :portkey.aws.pinpoint.sms-channel-response/short-code :portkey.aws.pinpoint.sms-channel-response/last-modified-date :portkey.aws.pinpoint.sms-channel-response/enabled :portkey.aws.pinpoint.sms-channel-response/sender-id :portkey.aws.pinpoint.sms-channel-response/promotional-messages-per-second :portkey.aws.pinpoint.sms-channel-response/application-id :portkey.aws.pinpoint.sms-channel-response/is-archived :portkey.aws.pinpoint.sms-channel-response/creation-date :portkey.aws.pinpoint.sms-channel-response/version :portkey.aws.pinpoint.sms-channel-response/last-modified-by :portkey.aws.pinpoint.sms-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-endpoint-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/message-body] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-baidu-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/baidu-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-endpoint-batch-item (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/endpoint-batch-item))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-versions-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segments-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-app-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/application-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.too-many-requests-exception/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.too-many-requests-exception/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/too-many-requests-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.too-many-requests-exception/message :portkey.aws.pinpoint.too-many-requests-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-gcm-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/gcm-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-segment-dimensions (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/segment-dimensions))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-send-configuration/body-override (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-send-configuration/context (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-send-configuration/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-send-configuration/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-send-configuration/title-override (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-send-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-send-configuration/body-override :portkey.aws.pinpoint.endpoint-send-configuration/context :portkey.aws.pinpoint.endpoint-send-configuration/raw-content :portkey.aws.pinpoint.endpoint-send-configuration/substitutions :portkey.aws.pinpoint.endpoint-send-configuration/title-override]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-request/api-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-request/secret-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/baidu-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.baidu-channel-request/api-key :portkey.aws.pinpoint.baidu-channel-request/enabled :portkey.aws.pinpoint.baidu-channel-request/secret-key]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-apns-sandbox-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-sandbox-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-apns-sandbox-channel-request/application-id :portkey.aws.pinpoint/apns-sandbox-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-event-stream-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/event-stream] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.message-body/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-body/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/message-body (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.message-body/message :portkey.aws.pinpoint.message-body/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-voip-sandbox-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-voip-sandbox-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-export-job-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-export-job-request/job-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-export-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-export-job-request/application-id :portkey.aws.pinpoint.get-export-job-request/job-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.tag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/tag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.tag-resource-request/resource-arn :portkey.aws.pinpoint/tags-model] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-apns-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-apns-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-apns-voip-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-voip-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-apns-voip-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-endpoint-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-endpoint-request/endpoint-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-endpoint-request/application-id :portkey.aws.pinpoint.get-endpoint-request/endpoint-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.write-event-stream/destination-stream-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-event-stream/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/write-event-stream (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.write-event-stream/destination-stream-arn :portkey.aws.pinpoint.write-event-stream/role-arn]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/has-token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-sandbox-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-sandbox-channel-response/has-credential :portkey.aws.pinpoint.apns-sandbox-channel-response/has-token-key :portkey.aws.pinpoint.apns-sandbox-channel-response/platform :portkey.aws.pinpoint.apns-sandbox-channel-response/last-modified-date :portkey.aws.pinpoint.apns-sandbox-channel-response/enabled :portkey.aws.pinpoint.apns-sandbox-channel-response/application-id :portkey.aws.pinpoint.apns-sandbox-channel-response/is-archived :portkey.aws.pinpoint.apns-sandbox-channel-response/default-authentication-method :portkey.aws.pinpoint.apns-sandbox-channel-response/creation-date :portkey.aws.pinpoint.apns-sandbox-channel-response/version :portkey.aws.pinpoint.apns-sandbox-channel-response/last-modified-by :portkey.aws.pinpoint.apns-sandbox-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segments-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segments-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segments-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segments-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-segments-request/application-id] :opt-un [:portkey.aws.pinpoint.get-segments-request/page-size :portkey.aws.pinpoint.get-segments-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-endpoint-message-result (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/endpoint-message-result))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-apns-sandbox-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-sandbox-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-apns-sandbox-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-export-jobs-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-export-jobs-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-export-jobs-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-export-jobs-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-export-jobs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-segment-export-jobs-request/segment-id :portkey.aws.pinpoint.get-segment-export-jobs-request/application-id] :opt-un [:portkey.aws.pinpoint.get-segment-export-jobs-request/page-size :portkey.aws.pinpoint.get-segment-export-jobs-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-channels-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-channels-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-channels-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.send-messages-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/send-messages-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.send-messages-request/application-id :portkey.aws.pinpoint/message-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/remove-attributes-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/attributes-resource] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-item-response (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/item-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-import-job-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/import-job-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-apns-voip-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-voip-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-apns-voip-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-metric-dimension (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/metric-dimension))

(clojure.spec.alpha/def :portkey.aws.pinpoint/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-sms-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-sms-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-sms-channel-request/application-id :portkey.aws.pinpoint/sms-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-export-jobs-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/export-jobs-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-double (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/double))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-event-item-response (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/event-item-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-message-result/address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-message-result/message-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-message-result/status-code (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-message-result/status-message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-message-result/updated-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-message-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-message-result/address :portkey.aws.pinpoint/delivery-status :portkey.aws.pinpoint.endpoint-message-result/message-id :portkey.aws.pinpoint.endpoint-message-result/status-code :portkey.aws.pinpoint.endpoint-message-result/status-message :portkey.aws.pinpoint.endpoint-message-result/updated-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-request/configuration-set (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-request/from-address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-request/identity (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-request/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/email-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.email-channel-request/configuration-set :portkey.aws.pinpoint.email-channel-request/enabled :portkey.aws.pinpoint.email-channel-request/from-address :portkey.aws.pinpoint.email-channel-request/identity :portkey.aws.pinpoint.email-channel-request/role-arn]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-request/iso-country-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.number-validate-request/phone-number (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/number-validate-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.number-validate-request/iso-country-code :portkey.aws.pinpoint.number-validate-request/phone-number]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.set-dimension/values (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/set-dimension (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/dimension-type :portkey.aws.pinpoint.set-dimension/values]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-behaviors/recency (clojure.spec.alpha/and :portkey.aws.pinpoint/recency-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-behaviors (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-behaviors/recency]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-baidu-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-baidu-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-baidu-channel-request/application-id :portkey.aws.pinpoint/baidu-channel-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/has-token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-voip-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-voip-channel-response/has-credential :portkey.aws.pinpoint.apns-voip-channel-response/has-token-key :portkey.aws.pinpoint.apns-voip-channel-response/platform :portkey.aws.pinpoint.apns-voip-channel-response/last-modified-date :portkey.aws.pinpoint.apns-voip-channel-response/enabled :portkey.aws.pinpoint.apns-voip-channel-response/application-id :portkey.aws.pinpoint.apns-voip-channel-response/is-archived :portkey.aws.pinpoint.apns-voip-channel-response/default-authentication-method :portkey.aws.pinpoint.apns-voip-channel-response/creation-date :portkey.aws.pinpoint.apns-voip-channel-response/version :portkey.aws.pinpoint.apns-voip-channel-response/last-modified-by :portkey.aws.pinpoint.apns-voip-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-request/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-request/s-3-url-prefix (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.export-job-request/segment-version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/export-job-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.export-job-request/role-arn :portkey.aws.pinpoint.export-job-request/s-3-url-prefix :portkey.aws.pinpoint.export-job-request/segment-id :portkey.aws.pinpoint.export-job-request/segment-version]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/image-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/silent-push (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/consolidation-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/sound (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/expires-after (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/small-image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/icon-reference (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/data (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-message/md-5 (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/adm-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.adm-message/body :portkey.aws.pinpoint.adm-message/image-url :portkey.aws.pinpoint.adm-message/title :portkey.aws.pinpoint.adm-message/silent-push :portkey.aws.pinpoint.adm-message/consolidation-key :portkey.aws.pinpoint.adm-message/sound :portkey.aws.pinpoint.adm-message/expires-after :portkey.aws.pinpoint.adm-message/raw-content :portkey.aws.pinpoint.adm-message/url :portkey.aws.pinpoint.adm-message/substitutions :portkey.aws.pinpoint.adm-message/small-image-icon-url :portkey.aws.pinpoint.adm-message/icon-reference :portkey.aws.pinpoint.adm-message/data :portkey.aws.pinpoint.adm-message/image-icon-url :portkey.aws.pinpoint/action :portkey.aws.pinpoint.adm-message/md-5]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-dimensions/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-attribute-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-dimensions/behavior (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-behaviors))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-dimensions/demographic (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-demographics))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-dimensions/location (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-location))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-dimensions/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-metric-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-dimensions/user-attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-attribute-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-dimensions (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-dimensions/attributes :portkey.aws.pinpoint.segment-dimensions/behavior :portkey.aws.pinpoint.segment-dimensions/demographic :portkey.aws.pinpoint.segment-dimensions/location :portkey.aws.pinpoint.segment-dimensions/metrics :portkey.aws.pinpoint.segment-dimensions/user-attributes]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-email-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-email-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-email-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-endpoint-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/endpoint-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.default-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.default-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/default-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.default-message/body :portkey.aws.pinpoint.default-message/substitutions]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/image-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/silent-push (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/time-to-live (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/json-body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/image-small-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/media-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message/image-icon-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.message/body :portkey.aws.pinpoint.message/image-url :portkey.aws.pinpoint.message/title :portkey.aws.pinpoint.message/silent-push :portkey.aws.pinpoint.message/time-to-live :portkey.aws.pinpoint.message/raw-content :portkey.aws.pinpoint.message/url :portkey.aws.pinpoint.message/json-body :portkey.aws.pinpoint.message/image-small-icon-url :portkey.aws.pinpoint.message/media-url :portkey.aws.pinpoint.message/image-icon-url :portkey.aws.pinpoint/action]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-address-configuration (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/address-configuration))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-endpoints-batch-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-endpoints-batch-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-endpoints-batch-request/application-id :portkey.aws.pinpoint/endpoint-batch-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/bundle-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/certificate (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/private-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/team-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-request/token-key-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-channel-request/bundle-id :portkey.aws.pinpoint.apns-channel-request/certificate :portkey.aws.pinpoint.apns-channel-request/default-authentication-method :portkey.aws.pinpoint.apns-channel-request/enabled :portkey.aws.pinpoint.apns-channel-request/private-key :portkey.aws.pinpoint.apns-channel-request/team-id :portkey.aws.pinpoint.apns-channel-request/token-key :portkey.aws.pinpoint.apns-channel-request/token-key-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/dimension-type #{:exclusive :inclusive "EXCLUSIVE" "INCLUSIVE"})

(clojure.spec.alpha/def :portkey.aws.pinpoint.application-settings-resource/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.application-settings-resource/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.application-settings-resource/limits (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-limits))
(clojure.spec.alpha/def :portkey.aws.pinpoint/application-settings-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.application-settings-resource/application-id :portkey.aws.pinpoint/campaign-hook :portkey.aws.pinpoint.application-settings-resource/last-modified-date :portkey.aws.pinpoint.application-settings-resource/limits :portkey.aws.pinpoint/quiet-time]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/endpoint-status (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/location (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-location))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/demographic (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-demographic))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/user (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-user))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/effective-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/opt-out (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.public-endpoint/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/public-endpoint (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.public-endpoint/address :portkey.aws.pinpoint.public-endpoint/endpoint-status :portkey.aws.pinpoint.public-endpoint/request-id :portkey.aws.pinpoint.public-endpoint/location :portkey.aws.pinpoint.public-endpoint/demographic :portkey.aws.pinpoint.public-endpoint/user :portkey.aws.pinpoint.public-endpoint/attributes :portkey.aws.pinpoint.public-endpoint/effective-date :portkey.aws.pinpoint.public-endpoint/opt-out :portkey.aws.pinpoint/channel-type :portkey.aws.pinpoint.public-endpoint/metrics]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-hook/lambda-function-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-hook/web-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-hook (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaign-hook/lambda-function-name :portkey.aws.pinpoint/mode :portkey.aws.pinpoint.campaign-hook/web-url]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-app-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-app-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-app-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.put-event-stream-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/put-event-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.put-event-stream-request/application-id :portkey.aws.pinpoint/write-event-stream] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.not-found-exception/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.not-found-exception/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/not-found-exception (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.not-found-exception/message :portkey.aws.pinpoint.not-found-exception/request-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-versions-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-versions-request/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-versions-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-versions-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-campaign-versions-request/application-id :portkey.aws.pinpoint.get-campaign-versions-request/campaign-id] :opt-un [:portkey.aws.pinpoint.get-campaign-versions-request/page-size :portkey.aws.pinpoint.get-campaign-versions-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/duration #{"DAY_14" :day-30 "HR_24" :day-7 :hr-24 "DAY_30" :day-14 "DAY_7"})

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-gcm-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/gcm-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.metric-dimension/comparison-operator (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.metric-dimension/value (clojure.spec.alpha/and :portkey.aws.pinpoint/double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/metric-dimension (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.metric-dimension/comparison-operator :portkey.aws.pinpoint.metric-dimension/value]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-email-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-email-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-email-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-version-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-version-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-version-request/version (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-version-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-segment-version-request/segment-id :portkey.aws.pinpoint.get-segment-version-request/version :portkey.aws.pinpoint.get-segment-version-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/filter-type #{"SYSTEM" :system "ENDPOINT" :endpoint})

(clojure.spec.alpha/def :portkey.aws.pinpoint.gps-point-dimension/coordinates (clojure.spec.alpha/and :portkey.aws.pinpoint/gps-coordinates))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gps-point-dimension/range-in-kilometers (clojure.spec.alpha/and :portkey.aws.pinpoint/double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/gps-point-dimension (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.gps-point-dimension/coordinates :portkey.aws.pinpoint.gps-point-dimension/range-in-kilometers]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.write-segment-request/dimensions (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-dimensions))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-segment-request/name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-segment-request/segment-groups (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-group-list))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-segment-request/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/write-segment-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.write-segment-request/dimensions :portkey.aws.pinpoint.write-segment-request/name :portkey.aws.pinpoint.write-segment-request/segment-groups :portkey.aws.pinpoint.write-segment-request/tags]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-voip-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-voip-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-export-jobs-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-export-jobs-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-export-jobs-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-export-jobs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-export-jobs-request/application-id] :opt-un [:portkey.aws.pinpoint.get-export-jobs-request/page-size :portkey.aws.pinpoint.get-export-jobs-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaign-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-application-settings-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-application-settings-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-application-settings-request/application-id :portkey.aws.pinpoint/write-application-settings-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-gcm-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/gcm-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-attribute-dimension (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/attribute-dimension))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-segment-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-segment-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-segment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-segment-request/segment-id :portkey.aws.pinpoint.delete-segment-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-app-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-app-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-app-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/endpoint-status (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/location (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-location))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/demographic (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-demographic))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/user (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-user))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/effective-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/opt-out (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-request/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-request/address :portkey.aws.pinpoint.endpoint-request/endpoint-status :portkey.aws.pinpoint.endpoint-request/request-id :portkey.aws.pinpoint.endpoint-request/location :portkey.aws.pinpoint.endpoint-request/demographic :portkey.aws.pinpoint.endpoint-request/user :portkey.aws.pinpoint.endpoint-request/attributes :portkey.aws.pinpoint.endpoint-request/effective-date :portkey.aws.pinpoint.endpoint-request/opt-out :portkey.aws.pinpoint/channel-type :portkey.aws.pinpoint.endpoint-request/metrics]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-request/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-endpoint-batch-item))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-batch-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-batch-request/item]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-request/sender-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-channel-request/short-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/sms-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.sms-channel-request/enabled :portkey.aws.pinpoint.sms-channel-request/sender-id :portkey.aws.pinpoint.sms-channel-request/short-code]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-version-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segment-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/recency-dimension (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/duration :portkey.aws.pinpoint/recency-type]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.address-configuration/body-override (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.address-configuration/context (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.address-configuration/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.address-configuration/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.address-configuration/title-override (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/address-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.address-configuration/body-override :portkey.aws.pinpoint/channel-type :portkey.aws.pinpoint.address-configuration/context :portkey.aws.pinpoint.address-configuration/raw-content :portkey.aws.pinpoint.address-configuration/substitutions :portkey.aws.pinpoint.address-configuration/title-override]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/put-event-stream-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/event-stream] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/endpoint-status (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/location (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-location))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/demographic (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-demographic))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/user (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-user))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/effective-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/opt-out (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-batch-item/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-batch-item (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-batch-item/address :portkey.aws.pinpoint.endpoint-batch-item/endpoint-status :portkey.aws.pinpoint.endpoint-batch-item/request-id :portkey.aws.pinpoint.endpoint-batch-item/location :portkey.aws.pinpoint.endpoint-batch-item/demographic :portkey.aws.pinpoint.endpoint-batch-item/user :portkey.aws.pinpoint.endpoint-batch-item/attributes :portkey.aws.pinpoint.endpoint-batch-item/effective-date :portkey.aws.pinpoint.endpoint-batch-item/opt-out :portkey.aws.pinpoint.endpoint-batch-item/id :portkey.aws.pinpoint/channel-type :portkey.aws.pinpoint.endpoint-batch-item/metrics]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-application-settings-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-application-settings-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-application-settings-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/create-import-job-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/import-job-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-write-treatment-resource (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/write-treatment-resource))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-user-endpoints-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/endpoints-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.write-treatment-resource/size-percent (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-treatment-resource/treatment-description (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.write-treatment-resource/treatment-name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/write-treatment-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/message-configuration :portkey.aws.pinpoint/schedule :portkey.aws.pinpoint.write-treatment-resource/size-percent :portkey.aws.pinpoint.write-treatment-resource/treatment-description :portkey.aws.pinpoint.write-treatment-resource/treatment-name]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.event-stream/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-stream/destination-stream-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-stream/external-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-stream/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-stream/last-updated-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-stream/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/event-stream (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.event-stream/application-id :portkey.aws.pinpoint.event-stream/destination-stream-arn :portkey.aws.pinpoint.event-stream/external-id :portkey.aws.pinpoint.event-stream/last-modified-date :portkey.aws.pinpoint.event-stream/last-updated-by :portkey.aws.pinpoint.event-stream/role-arn]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-versions-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-versions-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-versions-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-segment-versions-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-versions-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-segment-versions-request/segment-id :portkey.aws.pinpoint.get-segment-versions-request/application-id] :opt-un [:portkey.aws.pinpoint.get-segment-versions-request/page-size :portkey.aws.pinpoint.get-segment-versions-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-email-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/email-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-segment-reference (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/segment-reference))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-export-jobs-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/export-jobs-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-message/keyword (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-message/origination-number (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-message/sender-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.sms-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/sms-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.sms-message/body :portkey.aws.pinpoint.sms-message/keyword :portkey.aws.pinpoint/message-type :portkey.aws.pinpoint.sms-message/origination-number :portkey.aws.pinpoint.sms-message/sender-id :portkey.aws.pinpoint.sms-message/substitutions]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-apps-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-apps-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apps-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.get-apps-request/page-size :portkey.aws.pinpoint.get-apps-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-messages-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/send-users-messages-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.send-users-messages-request/application-id :portkey.aws.pinpoint/send-users-message-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-user-endpoints-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-user-endpoints-request/user-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-user-endpoints-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-user-endpoints-request/application-id :portkey.aws.pinpoint.get-user-endpoints-request/user-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.channels-response/channels (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-channel-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint/channels-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.channels-response/channels]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaigns-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaigns-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaigns-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaigns-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-campaigns-request/application-id] :opt-un [:portkey.aws.pinpoint.get-campaigns-request/page-size :portkey.aws.pinpoint.get-campaigns-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-email-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-email-message/from-address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-email-message/html-body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.campaign-email-message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-email-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.campaign-email-message/body :portkey.aws.pinpoint.campaign-email-message/from-address :portkey.aws.pinpoint.campaign-email-message/html-body :portkey.aws.pinpoint.campaign-email-message/title]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-import-job-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/import-job-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint/include #{:all "NONE" "ANY" "ALL" :none :any})

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-reference/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-reference/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-reference (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-reference/id :portkey.aws.pinpoint.segment-reference/version]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/adm-message (clojure.spec.alpha/and :portkey.aws.pinpoint/message))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/apns-message (clojure.spec.alpha/and :portkey.aws.pinpoint/message))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/baidu-message (clojure.spec.alpha/and :portkey.aws.pinpoint/message))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/default-message (clojure.spec.alpha/and :portkey.aws.pinpoint/message))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/email-message (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-email-message))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/gcm-message (clojure.spec.alpha/and :portkey.aws.pinpoint/message))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-configuration/sms-message (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-sms-message))
(clojure.spec.alpha/def :portkey.aws.pinpoint/message-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.message-configuration/adm-message :portkey.aws.pinpoint.message-configuration/apns-message :portkey.aws.pinpoint.message-configuration/baidu-message :portkey.aws.pinpoint.message-configuration/default-message :portkey.aws.pinpoint.message-configuration/email-message :portkey.aws.pinpoint.message-configuration/gcm-message :portkey.aws.pinpoint.message-configuration/sms-message]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-activities-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-activities-request/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-activities-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-activities-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-activities-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-campaign-activities-request/application-id :portkey.aws.pinpoint.get-campaign-activities-request/campaign-id] :opt-un [:portkey.aws.pinpoint.get-campaign-activities-request/page-size :portkey.aws.pinpoint.get-campaign-activities-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.create-import-job-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/create-import-job-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.create-import-job-request/application-id :portkey.aws.pinpoint/import-job-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-import-jobs-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/import-jobs-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/message-type #{"TRANSACTIONAL" :transactional "PROMOTIONAL" :promotional})

(clojure.spec.alpha/def :portkey.aws.pinpoint.events-request/batch-item (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-events-batch))
(clojure.spec.alpha/def :portkey.aws.pinpoint/events-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.events-request/batch-item]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-campaign-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaign-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/frequency #{:daily "EVENT" "ONCE" :monthly "MONTHLY" "WEEKLY" :event :hourly :once "DAILY" :weekly "HOURLY"})

(clojure.spec.alpha/def :portkey.aws.pinpoint/timestamp-iso-8601 clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/segment-groups (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-group-list))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/dimensions (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-dimensions))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/import-definition (clojure.spec.alpha/and :portkey.aws.pinpoint/segment-import-resource))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/name (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-response/segment-groups :portkey.aws.pinpoint/segment-type :portkey.aws.pinpoint.segment-response/last-modified-date :portkey.aws.pinpoint.segment-response/tags :portkey.aws.pinpoint.segment-response/application-id :portkey.aws.pinpoint.segment-response/dimensions :portkey.aws.pinpoint.segment-response/import-definition :portkey.aws.pinpoint.segment-response/arn :portkey.aws.pinpoint.segment-response/creation-date :portkey.aws.pinpoint.segment-response/version :portkey.aws.pinpoint.segment-response/name :portkey.aws.pinpoint.segment-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/double clojure.core/double?)

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-voice-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/voice-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-endpoints-batch-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/message-body] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-segment-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segment-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-campaign-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/campaign-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-voip-sandbox-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-voip-sandbox-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/cohort-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/endpoint-status (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/request-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/location (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-location))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/demographic (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-demographic))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/user (clojure.spec.alpha/and :portkey.aws.pinpoint/endpoint-user))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/attributes (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/effective-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/opt-out (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-response/metrics (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-response/address :portkey.aws.pinpoint.endpoint-response/cohort-id :portkey.aws.pinpoint.endpoint-response/endpoint-status :portkey.aws.pinpoint.endpoint-response/request-id :portkey.aws.pinpoint.endpoint-response/location :portkey.aws.pinpoint.endpoint-response/demographic :portkey.aws.pinpoint.endpoint-response/user :portkey.aws.pinpoint.endpoint-response/attributes :portkey.aws.pinpoint.endpoint-response/application-id :portkey.aws.pinpoint.endpoint-response/creation-date :portkey.aws.pinpoint.endpoint-response/effective-date :portkey.aws.pinpoint.endpoint-response/opt-out :portkey.aws.pinpoint.endpoint-response/id :portkey.aws.pinpoint/channel-type :portkey.aws.pinpoint.endpoint-response/metrics]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-request/client-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-request/client-secret (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint/adm-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.adm-channel-request/client-id :portkey.aws.pinpoint.adm-channel-request/client-secret :portkey.aws.pinpoint.adm-channel-request/enabled]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/campaign-status #{"COMPLETED" :paused :deleted :completed "EXECUTING" "SCHEDULED" :executing :pending-next-run :scheduled "DELETED" "PAUSED" "PENDING_NEXT_RUN"})

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-segment-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.update-segment-request/segment-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-segment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-segment-request/segment-id :portkey.aws.pinpoint.update-segment-request/application-id :portkey.aws.pinpoint/write-segment-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.applications-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-application-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint.applications-response/next-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/applications-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.applications-response/item :portkey.aws.pinpoint.applications-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.event-item-response/message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.event-item-response/status-code (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/event-item-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.event-item-response/message :portkey.aws.pinpoint.event-item-response/status-code]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/create-campaign-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/campaign-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-user-endpoints-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/endpoints-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-event (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/event))

(clojure.spec.alpha/def :portkey.aws.pinpoint.item-response/events-item-response (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-event-item-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint/item-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/endpoint-item-response :portkey.aws.pinpoint.item-response/events-item-response]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-message/language-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-message/origination-number (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.voice-message/voice-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/voice-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.voice-message/body :portkey.aws.pinpoint.voice-message/language-code :portkey.aws.pinpoint.voice-message/origination-number :portkey.aws.pinpoint.voice-message/substitutions :portkey.aws.pinpoint.voice-message/voice-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-endpoint-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/endpoint-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-apns-voip-sandbox-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-voip-sandbox-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/blob clojure.core/bytes?)

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-endpoint-send-configuration (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/endpoint-send-configuration))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-sms-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-sms-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-sms-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/integer clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-segment-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/segment-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-endpoint-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.update-endpoint-request/endpoint-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-endpoint-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-endpoint-request/application-id :portkey.aws.pinpoint.update-endpoint-request/endpoint-id :portkey.aws.pinpoint/endpoint-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/bundle-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/certificate (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/private-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/team-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-voip-channel-request/token-key-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-voip-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-voip-channel-request/bundle-id :portkey.aws.pinpoint.apns-voip-channel-request/certificate :portkey.aws.pinpoint.apns-voip-channel-request/default-authentication-method :portkey.aws.pinpoint.apns-voip-channel-request/enabled :portkey.aws.pinpoint.apns-voip-channel-request/private-key :portkey.aws.pinpoint.apns-voip-channel-request/team-id :portkey.aws.pinpoint.apns-voip-channel-request/token-key :portkey.aws.pinpoint.apns-voip-channel-request/token-key-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.schedule/end-time (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.schedule/event-filter (clojure.spec.alpha/and :portkey.aws.pinpoint/campaign-event-filter))
(clojure.spec.alpha/def :portkey.aws.pinpoint.schedule/is-local-time (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.schedule/start-time (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.schedule/timezone (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/schedule (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.schedule/end-time :portkey.aws.pinpoint.schedule/event-filter :portkey.aws.pinpoint/frequency :portkey.aws.pinpoint.schedule/is-local-time :portkey.aws.pinpoint/quiet-time :portkey.aws.pinpoint.schedule/start-time :portkey.aws.pinpoint.schedule/timezone]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.put-events-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/put-events-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.put-events-request/application-id :portkey.aws.pinpoint/events-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/timestamp-unix clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-group/dimensions (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-segment-dimensions))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-group/source-segments (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-segment-reference))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-group (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-group/dimensions :portkey.aws.pinpoint.segment-group/source-segments :portkey.aws.pinpoint/source-type :portkey.aws.pinpoint/type]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-import-resource/channel-counts (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-import-resource/external-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-import-resource/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-import-resource/s-3-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-import-resource/size (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-import-resource (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-import-resource/channel-counts :portkey.aws.pinpoint.segment-import-resource/external-id :portkey.aws.pinpoint/format :portkey.aws.pinpoint.segment-import-resource/role-arn :portkey.aws.pinpoint.segment-import-resource/s-3-url :portkey.aws.pinpoint.segment-import-resource/size]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-export-job-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/export-job-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.create-segment-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/create-segment-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.create-segment-request/application-id :portkey.aws.pinpoint/write-segment-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-channel-response (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/channel-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-baidu-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-baidu-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-baidu-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.default-push-notification-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.default-push-notification-message/data (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.default-push-notification-message/silent-push (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.default-push-notification-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.default-push-notification-message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.default-push-notification-message/url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/default-push-notification-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/action :portkey.aws.pinpoint.default-push-notification-message/body :portkey.aws.pinpoint.default-push-notification-message/data :portkey.aws.pinpoint.default-push-notification-message/silent-push :portkey.aws.pinpoint.default-push-notification-message/substitutions :portkey.aws.pinpoint.default-push-notification-message/title :portkey.aws.pinpoint.default-push-notification-message/url]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.channel-response/has-credential :portkey.aws.pinpoint.channel-response/last-modified-date :portkey.aws.pinpoint.channel-response/enabled :portkey.aws.pinpoint.channel-response/application-id :portkey.aws.pinpoint.channel-response/is-archived :portkey.aws.pinpoint.channel-response/creation-date :portkey.aws.pinpoint.channel-response/version :portkey.aws.pinpoint.channel-response/last-modified-by :portkey.aws.pinpoint.channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/category (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/title (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/silent-push (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/sound (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/time-to-live (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/priority (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/raw-content (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/thread-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/badge (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/data (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/media-url (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/collapse-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-message/preferred-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-message/category :portkey.aws.pinpoint.apns-message/body :portkey.aws.pinpoint.apns-message/title :portkey.aws.pinpoint.apns-message/silent-push :portkey.aws.pinpoint.apns-message/sound :portkey.aws.pinpoint.apns-message/time-to-live :portkey.aws.pinpoint.apns-message/priority :portkey.aws.pinpoint.apns-message/raw-content :portkey.aws.pinpoint.apns-message/thread-id :portkey.aws.pinpoint.apns-message/url :portkey.aws.pinpoint.apns-message/badge :portkey.aws.pinpoint.apns-message/substitutions :portkey.aws.pinpoint.apns-message/data :portkey.aws.pinpoint.apns-message/media-url :portkey.aws.pinpoint.apns-message/collapse-id :portkey.aws.pinpoint/action :portkey.aws.pinpoint.apns-message/preferred-authentication-method]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-integer (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/integer))

(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/configuration-set (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/role-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/messages-per-second (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/identity (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/from-address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/email-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.email-channel-response/has-credential :portkey.aws.pinpoint.email-channel-response/platform :portkey.aws.pinpoint.email-channel-response/last-modified-date :portkey.aws.pinpoint.email-channel-response/configuration-set :portkey.aws.pinpoint.email-channel-response/role-arn :portkey.aws.pinpoint.email-channel-response/messages-per-second :portkey.aws.pinpoint.email-channel-response/enabled :portkey.aws.pinpoint.email-channel-response/application-id :portkey.aws.pinpoint.email-channel-response/is-archived :portkey.aws.pinpoint.email-channel-response/identity :portkey.aws.pinpoint.email-channel-response/creation-date :portkey.aws.pinpoint.email-channel-response/from-address :portkey.aws.pinpoint.email-channel-response/version :portkey.aws.pinpoint.email-channel-response/last-modified-by :portkey.aws.pinpoint.email-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-import-jobs-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/import-jobs-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-segment-group (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/segment-group))

(clojure.spec.alpha/def :portkey.aws.pinpoint/direct-message-configuration (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/gcm-message :portkey.aws.pinpoint/baidu-message :portkey.aws.pinpoint/adm-message :portkey.aws.pinpoint/default-message :portkey.aws.pinpoint/sms-message :portkey.aws.pinpoint/voice-message :portkey.aws.pinpoint/default-push-notification-message :portkey.aws.pinpoint/apns-message :portkey.aws.pinpoint/email-message]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-application-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/application-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/bundle-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/certificate (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/private-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/team-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-sandbox-channel-request/token-key-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-sandbox-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-sandbox-channel-request/bundle-id :portkey.aws.pinpoint.apns-sandbox-channel-request/certificate :portkey.aws.pinpoint.apns-sandbox-channel-request/default-authentication-method :portkey.aws.pinpoint.apns-sandbox-channel-request/enabled :portkey.aws.pinpoint.apns-sandbox-channel-request/private-key :portkey.aws.pinpoint.apns-sandbox-channel-request/team-id :portkey.aws.pinpoint.apns-sandbox-channel-request/token-key :portkey.aws.pinpoint.apns-sandbox-channel-request/token-key-id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-request/context (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-request/message-configuration (clojure.spec.alpha/and :portkey.aws.pinpoint/direct-message-configuration))
(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-request/trace-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.send-users-message-request/users (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-endpoint-send-configuration))
(clojure.spec.alpha/def :portkey.aws.pinpoint/send-users-message-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.send-users-message-request/context :portkey.aws.pinpoint.send-users-message-request/message-configuration :portkey.aws.pinpoint.send-users-message-request/trace-id :portkey.aws.pinpoint.send-users-message-request/users]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.session/duration (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.session/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.session/start-timestamp (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.session/stop-timestamp (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/session (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.session/duration :portkey.aws.pinpoint.session/id :portkey.aws.pinpoint.session/start-timestamp :portkey.aws.pinpoint.session/stop-timestamp]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-channels-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/channels-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-user-endpoints-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-user-endpoints-request/user-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-user-endpoints-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-user-endpoints-request/application-id :portkey.aws.pinpoint.delete-user-endpoints-request/user-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.gps-coordinates/latitude (clojure.spec.alpha/and :portkey.aws.pinpoint/double))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gps-coordinates/longitude (clojure.spec.alpha/and :portkey.aws.pinpoint/double))
(clojure.spec.alpha/def :portkey.aws.pinpoint/gps-coordinates (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.gps-coordinates/latitude :portkey.aws.pinpoint.gps-coordinates/longitude]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.adm-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/adm-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.adm-channel-response/has-credential :portkey.aws.pinpoint.adm-channel-response/platform :portkey.aws.pinpoint.adm-channel-response/last-modified-date :portkey.aws.pinpoint.adm-channel-response/enabled :portkey.aws.pinpoint.adm-channel-response/application-id :portkey.aws.pinpoint.adm-channel-response/is-archived :portkey.aws.pinpoint.adm-channel-response/creation-date :portkey.aws.pinpoint.adm-channel-response/version :portkey.aws.pinpoint.adm-channel-response/last-modified-by :portkey.aws.pinpoint.adm-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-event-stream-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/event-stream] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-campaign-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-campaign-request/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-campaign-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-campaign-request/campaign-id :portkey.aws.pinpoint.delete-campaign-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-location/country (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-location/gps-point (clojure.spec.alpha/and :portkey.aws.pinpoint/gps-point-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-location/country :portkey.aws.pinpoint.segment-location/gps-point]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-campaign-request/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-campaign-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-campaign-request/campaign-id :portkey.aws.pinpoint.get-campaign-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-location/city (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-location/country (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-location/latitude (clojure.spec.alpha/and :portkey.aws.pinpoint/double))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-location/longitude (clojure.spec.alpha/and :portkey.aws.pinpoint/double))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-location/postal-code (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.endpoint-location/region (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/endpoint-location (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.endpoint-location/city :portkey.aws.pinpoint.endpoint-location/country :portkey.aws.pinpoint.endpoint-location/latitude :portkey.aws.pinpoint.endpoint-location/longitude :portkey.aws.pinpoint.endpoint-location/postal-code :portkey.aws.pinpoint.endpoint-location/region]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-sms-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-sms-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-sms-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-apns-sandbox-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-sandbox-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/action #{"URL" :deep-link :open-app "OPEN_APP" :url "DEEP_LINK"})

(clojure.spec.alpha/def :portkey.aws.pinpoint.tags-model/tags (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/tags-model (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.tags-model/tags] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/list-of-activity-response (clojure.spec.alpha/coll-of :portkey.aws.pinpoint/activity-response))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-sms-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/sms-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.remove-attributes-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.remove-attributes-request/attribute-type (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/remove-attributes-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.remove-attributes-request/attribute-type :portkey.aws.pinpoint.remove-attributes-request/application-id :portkey.aws.pinpoint/update-attributes-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-adm-channel-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-adm-channel-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-adm-channel-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-attributes-request/blacklist (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-attributes-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.update-attributes-request/blacklist]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-request/api-key (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.gcm-channel-request/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint/gcm-channel-request (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.gcm-channel-request/api-key :portkey.aws.pinpoint.gcm-channel-request/enabled]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/credential (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.baidu-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/baidu-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.baidu-channel-response/has-credential :portkey.aws.pinpoint.baidu-channel-response/platform :portkey.aws.pinpoint.baidu-channel-response/credential :portkey.aws.pinpoint.baidu-channel-response/last-modified-date :portkey.aws.pinpoint.baidu-channel-response/enabled :portkey.aws.pinpoint.baidu-channel-response/application-id :portkey.aws.pinpoint.baidu-channel-response/is-archived :portkey.aws.pinpoint.baidu-channel-response/creation-date :portkey.aws.pinpoint.baidu-channel-response/version :portkey.aws.pinpoint.baidu-channel-response/last-modified-by :portkey.aws.pinpoint.baidu-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-sandbox-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-sandbox-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-map-of-endpoint-message-result (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/map-of-endpoint-message-result))

(clojure.spec.alpha/def :portkey.aws.pinpoint.untag-resource-request/resource-arn (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.untag-resource-request/tag-keys (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/untag-resource-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.untag-resource-request/tag-keys :portkey.aws.pinpoint.untag-resource-request/resource-arn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.message-result/message-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-result/status-code (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-result/status-message (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.message-result/updated-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/message-result (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint/delivery-status :portkey.aws.pinpoint.message-result/message-id :portkey.aws.pinpoint.message-result/status-code :portkey.aws.pinpoint.message-result/status-message :portkey.aws.pinpoint.message-result/updated-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.email-message/body (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-message/feedback-forwarding-address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-message/from-address (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-message/reply-to-addresses (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.email-message/substitutions (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-list-of-string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/email-message (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.email-message/body :portkey.aws.pinpoint.email-message/feedback-forwarding-address :portkey.aws.pinpoint.email-message/from-address :portkey.aws.pinpoint/raw-email :portkey.aws.pinpoint.email-message/reply-to-addresses :portkey.aws.pinpoint/simple-email :portkey.aws.pinpoint.email-message/substitutions]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-baidu-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/baidu-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/has-credential (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/has-token-key (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/last-modified-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/enabled (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/is-archived (clojure.spec.alpha/and :portkey.aws.pinpoint/boolean))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/default-authentication-method (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/creation-date (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/version (clojure.spec.alpha/and :portkey.aws.pinpoint/integer))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/last-modified-by (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.apns-channel-response/id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/apns-channel-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.apns-channel-response/has-credential :portkey.aws.pinpoint.apns-channel-response/has-token-key :portkey.aws.pinpoint.apns-channel-response/platform :portkey.aws.pinpoint.apns-channel-response/last-modified-date :portkey.aws.pinpoint.apns-channel-response/enabled :portkey.aws.pinpoint.apns-channel-response/application-id :portkey.aws.pinpoint.apns-channel-response/is-archived :portkey.aws.pinpoint.apns-channel-response/default-authentication-method :portkey.aws.pinpoint.apns-channel-response/creation-date :portkey.aws.pinpoint.apns-channel-response/version :portkey.aws.pinpoint.apns-channel-response/last-modified-by :portkey.aws.pinpoint.apns-channel-response/id]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/map-of-string (clojure.spec.alpha/map-of :portkey.aws.pinpoint/string :portkey.aws.pinpoint/string))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segments-response/item (clojure.spec.alpha/and :portkey.aws.pinpoint/list-of-segment-response))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segments-response/next-token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segments-response (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segments-response/item :portkey.aws.pinpoint.segments-response/next-token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.delete-event-stream-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/delete-event-stream-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.delete-event-stream-request/application-id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-email-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/email-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint/channel-type #{"VOICE" :email "CUSTOM" "SMS" "APNS_VOIP" "ADM" "BAIDU" "GCM" "APNS" :custom :voice :apns-voip :apns-sandbox "APNS_VOIP_SANDBOX" :gcm :sms :adm "APNS_SANDBOX" "EMAIL" :baidu :apns-voip-sandbox :apns})

(clojure.spec.alpha/def :portkey.aws.pinpoint.get-import-jobs-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-import-jobs-request/page-size (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.get-import-jobs-request/token (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/get-import-jobs-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.get-import-jobs-request/application-id] :opt-un [:portkey.aws.pinpoint.get-import-jobs-request/page-size :portkey.aws.pinpoint.get-import-jobs-request/token]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/get-apns-voip-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/apns-voip-channel-response] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.events-batch/endpoint (clojure.spec.alpha/and :portkey.aws.pinpoint/public-endpoint))
(clojure.spec.alpha/def :portkey.aws.pinpoint.events-batch/events (clojure.spec.alpha/and :portkey.aws.pinpoint/map-of-event))
(clojure.spec.alpha/def :portkey.aws.pinpoint/events-batch (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.events-batch/endpoint :portkey.aws.pinpoint.events-batch/events]))

(clojure.spec.alpha/def :portkey.aws.pinpoint.update-campaign-request/application-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint.update-campaign-request/campaign-id (clojure.spec.alpha/and :portkey.aws.pinpoint/string))
(clojure.spec.alpha/def :portkey.aws.pinpoint/update-campaign-request (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint.update-campaign-request/campaign-id :portkey.aws.pinpoint.update-campaign-request/application-id :portkey.aws.pinpoint/write-campaign-request] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-demographics/app-version (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-demographics/channel (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-demographics/device-type (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-demographics/make (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-demographics/model (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint.segment-demographics/platform (clojure.spec.alpha/and :portkey.aws.pinpoint/set-dimension))
(clojure.spec.alpha/def :portkey.aws.pinpoint/segment-demographics (clojure.spec.alpha/keys :req-un [] :opt-un [:portkey.aws.pinpoint.segment-demographics/app-version :portkey.aws.pinpoint.segment-demographics/channel :portkey.aws.pinpoint.segment-demographics/device-type :portkey.aws.pinpoint.segment-demographics/make :portkey.aws.pinpoint.segment-demographics/model :portkey.aws.pinpoint.segment-demographics/platform]))

(clojure.spec.alpha/def :portkey.aws.pinpoint/update-email-channel-response (clojure.spec.alpha/keys :req-un [:portkey.aws.pinpoint/email-channel-response] :opt-un []))

(clojure.core/defn tag-resource ([tag-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-tag-resource-request tag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/tags/{resource-arn}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/tag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "TagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef tag-resource :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/tag-resource-request) :ret clojure.core/true?)

(clojure.core/defn get-apns-voip-sandbox-channel ([get-apns-voip-sandbox-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-apns-voip-sandbox-channel-request get-apns-voip-sandbox-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-apns-voip-sandbox-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_voip_sandbox", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-apns-voip-sandbox-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApnsVoipSandboxChannel", :http.request.configuration/output-deser-fn response-get-apns-voip-sandbox-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-apns-voip-sandbox-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-apns-voip-sandbox-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-apns-voip-sandbox-channel-response))

(clojure.core/defn get-baidu-channel ([get-baidu-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-baidu-channel-request get-baidu-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-baidu-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/baidu", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-baidu-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetBaiduChannel", :http.request.configuration/output-deser-fn response-get-baidu-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-baidu-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-baidu-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-baidu-channel-response))

(clojure.core/defn update-apns-channel ([update-apns-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-apns-channel-request update-apns-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-apns-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-apns-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApnsChannel", :http.request.configuration/output-deser-fn response-update-apns-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-apns-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-apns-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-apns-channel-response))

(clojure.core/defn get-export-job ([get-export-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-export-job-request get-export-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-export-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/jobs/export/{job-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-export-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetExportJob", :http.request.configuration/output-deser-fn response-get-export-job-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-export-job :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-export-job-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-export-job-response))

(clojure.core/defn delete-apns-voip-channel ([delete-apns-voip-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-apns-voip-channel-request delete-apns-voip-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-apns-voip-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_voip", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-apns-voip-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApnsVoipChannel", :http.request.configuration/output-deser-fn response-delete-apns-voip-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-apns-voip-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-apns-voip-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-apns-voip-channel-response))

(clojure.core/defn create-export-job ([create-export-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-export-job-request create-export-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/create-export-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/jobs/export", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/create-export-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateExportJob", :http.request.configuration/output-deser-fn response-create-export-job-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-export-job :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/create-export-job-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/create-export-job-response))

(clojure.core/defn get-apns-channel ([get-apns-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-apns-channel-request get-apns-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-apns-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-apns-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApnsChannel", :http.request.configuration/output-deser-fn response-get-apns-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-apns-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-apns-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-apns-channel-response))

(clojure.core/defn update-apns-voip-channel ([update-apns-voip-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-apns-voip-channel-request update-apns-voip-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-apns-voip-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_voip", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-apns-voip-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApnsVoipChannel", :http.request.configuration/output-deser-fn response-update-apns-voip-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-apns-voip-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-apns-voip-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-apns-voip-channel-response))

(clojure.core/defn update-adm-channel ([update-adm-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-adm-channel-request update-adm-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-adm-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/adm", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-adm-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateAdmChannel", :http.request.configuration/output-deser-fn response-update-adm-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-adm-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-adm-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-adm-channel-response))

(clojure.core/defn update-endpoints-batch ([update-endpoints-batch-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-endpoints-batch-request update-endpoints-batch-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-endpoints-batch-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/endpoints", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-endpoints-batch-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateEndpointsBatch", :http.request.configuration/output-deser-fn response-update-endpoints-batch-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-endpoints-batch :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-endpoints-batch-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-endpoints-batch-response))

(clojure.core/defn get-import-jobs ([get-import-jobs-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-import-jobs-request get-import-jobs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-import-jobs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/jobs/import", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-import-jobs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetImportJobs", :http.request.configuration/output-deser-fn response-get-import-jobs-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-import-jobs :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-import-jobs-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-import-jobs-response))

(clojure.core/defn delete-baidu-channel ([delete-baidu-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-baidu-channel-request delete-baidu-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-baidu-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/baidu", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-baidu-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteBaiduChannel", :http.request.configuration/output-deser-fn response-delete-baidu-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-baidu-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-baidu-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-baidu-channel-response))

(clojure.core/defn get-voice-channel ([get-voice-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-voice-channel-request get-voice-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-voice-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/voice", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-voice-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetVoiceChannel", :http.request.configuration/output-deser-fn response-get-voice-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-voice-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-voice-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-voice-channel-response))

(clojure.core/defn get-sms-channel ([get-sms-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-sms-channel-request get-sms-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-sms-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/sms", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-sms-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSmsChannel", :http.request.configuration/output-deser-fn response-get-sms-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-sms-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-sms-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-sms-channel-response))

(clojure.core/defn get-segment-version ([get-segment-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-segment-version-request get-segment-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-segment-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}/versions/{version}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-segment-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSegmentVersion", :http.request.configuration/output-deser-fn response-get-segment-version-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-segment-version :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-segment-version-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-segment-version-response))

(clojure.core/defn get-apns-sandbox-channel ([get-apns-sandbox-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-apns-sandbox-channel-request get-apns-sandbox-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-apns-sandbox-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_sandbox", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-apns-sandbox-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApnsSandboxChannel", :http.request.configuration/output-deser-fn response-get-apns-sandbox-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-apns-sandbox-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-apns-sandbox-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-apns-sandbox-channel-response))

(clojure.core/defn get-segment-import-jobs ([get-segment-import-jobs-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-segment-import-jobs-request get-segment-import-jobs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-segment-import-jobs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}/jobs/import", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-segment-import-jobs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSegmentImportJobs", :http.request.configuration/output-deser-fn response-get-segment-import-jobs-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-segment-import-jobs :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-segment-import-jobs-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-segment-import-jobs-response))

(clojure.core/defn get-campaign-activities ([get-campaign-activities-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-campaign-activities-request get-campaign-activities-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-campaign-activities-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns/{campaign-id}/activities", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-campaign-activities-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCampaignActivities", :http.request.configuration/output-deser-fn response-get-campaign-activities-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-campaign-activities :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-campaign-activities-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-campaign-activities-response))

(clojure.core/defn delete-email-channel ([delete-email-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-email-channel-request delete-email-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-email-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/email", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-email-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteEmailChannel", :http.request.configuration/output-deser-fn response-delete-email-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-email-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-email-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-email-channel-response))

(clojure.core/defn get-segment ([get-segment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-segment-request get-segment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-segment-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-segment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSegment", :http.request.configuration/output-deser-fn response-get-segment-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-segment :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-segment-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-segment-response))

(clojure.core/defn send-users-messages ([send-users-messages-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-send-users-messages-request send-users-messages-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/send-users-messages-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/users-messages", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/send-users-messages-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SendUsersMessages", :http.request.configuration/output-deser-fn response-send-users-messages-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef send-users-messages :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/send-users-messages-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/send-users-messages-response))

(clojure.core/defn get-event-stream ([get-event-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-event-stream-request get-event-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-event-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/eventstream", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-event-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetEventStream", :http.request.configuration/output-deser-fn response-get-event-stream-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-event-stream :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-event-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-event-stream-response))

(clojure.core/defn update-baidu-channel ([update-baidu-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-baidu-channel-request update-baidu-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-baidu-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/baidu", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-baidu-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateBaiduChannel", :http.request.configuration/output-deser-fn response-update-baidu-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-baidu-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-baidu-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-baidu-channel-response))

(clojure.core/defn get-campaign-version ([get-campaign-version-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-campaign-version-request get-campaign-version-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-campaign-version-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns/{campaign-id}/versions/{version}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-campaign-version-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCampaignVersion", :http.request.configuration/output-deser-fn response-get-campaign-version-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-campaign-version :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-campaign-version-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-campaign-version-response))

(clojure.core/defn get-campaign-versions ([get-campaign-versions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-campaign-versions-request get-campaign-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-campaign-versions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns/{campaign-id}/versions", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-campaign-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCampaignVersions", :http.request.configuration/output-deser-fn response-get-campaign-versions-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-campaign-versions :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-campaign-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-campaign-versions-response))

(clojure.core/defn get-export-jobs ([get-export-jobs-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-export-jobs-request get-export-jobs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-export-jobs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/jobs/export", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-export-jobs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetExportJobs", :http.request.configuration/output-deser-fn response-get-export-jobs-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-export-jobs :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-export-jobs-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-export-jobs-response))

(clojure.core/defn delete-apns-voip-sandbox-channel ([delete-apns-voip-sandbox-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-apns-voip-sandbox-channel-request delete-apns-voip-sandbox-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-apns-voip-sandbox-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_voip_sandbox", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-apns-voip-sandbox-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApnsVoipSandboxChannel", :http.request.configuration/output-deser-fn response-delete-apns-voip-sandbox-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-apns-voip-sandbox-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-apns-voip-sandbox-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-apns-voip-sandbox-channel-response))

(clojure.core/defn get-gcm-channel ([get-gcm-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-gcm-channel-request get-gcm-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-gcm-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/gcm", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-gcm-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetGcmChannel", :http.request.configuration/output-deser-fn response-get-gcm-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-gcm-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-gcm-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-gcm-channel-response))

(clojure.core/defn delete-voice-channel ([delete-voice-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-voice-channel-request delete-voice-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-voice-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/voice", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-voice-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteVoiceChannel", :http.request.configuration/output-deser-fn response-delete-voice-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-voice-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-voice-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-voice-channel-response))

(clojure.core/defn update-campaign ([update-campaign-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-campaign-request update-campaign-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-campaign-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns/{campaign-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-campaign-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateCampaign", :http.request.configuration/output-deser-fn response-update-campaign-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-campaign :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-campaign-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-campaign-response))

(clojure.core/defn list-tags-for-resource ([list-tags-for-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-list-tags-for-resource-request list-tags-for-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/list-tags-for-resource-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/tags/{resource-arn}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/list-tags-for-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "ListTagsForResource", :http.request.configuration/output-deser-fn response-list-tags-for-resource-response, :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef list-tags-for-resource :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/list-tags-for-resource-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/list-tags-for-resource-response))

(clojure.core/defn get-segments ([get-segments-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-segments-request get-segments-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-segments-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-segments-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSegments", :http.request.configuration/output-deser-fn response-get-segments-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-segments :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-segments-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-segments-response))

(clojure.core/defn get-user-endpoints ([get-user-endpoints-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-user-endpoints-request get-user-endpoints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-user-endpoints-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/users/{user-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-user-endpoints-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetUserEndpoints", :http.request.configuration/output-deser-fn response-get-user-endpoints-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-user-endpoints :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-user-endpoints-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-user-endpoints-response))

(clojure.core/defn create-import-job ([create-import-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-import-job-request create-import-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/create-import-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/jobs/import", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/create-import-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateImportJob", :http.request.configuration/output-deser-fn response-create-import-job-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-import-job :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/create-import-job-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/create-import-job-response))

(clojure.core/defn update-application-settings ([update-application-settings-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-application-settings-request update-application-settings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-application-settings-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/settings", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-application-settings-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApplicationSettings", :http.request.configuration/output-deser-fn response-update-application-settings-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-application-settings :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-application-settings-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-application-settings-response))

(clojure.core/defn get-campaign ([get-campaign-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-campaign-request get-campaign-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-campaign-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns/{campaign-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-campaign-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCampaign", :http.request.configuration/output-deser-fn response-get-campaign-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-campaign :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-campaign-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-campaign-response))

(clojure.core/defn phone-number-validate ([phone-number-validate-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-phone-number-validate-request phone-number-validate-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/phone-number-validate-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/phone/number/validate", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/phone-number-validate-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PhoneNumberValidate", :http.request.configuration/output-deser-fn response-phone-number-validate-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef phone-number-validate :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/phone-number-validate-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/phone-number-validate-response))

(clojure.core/defn get-import-job ([get-import-job-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-import-job-request get-import-job-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-import-job-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/jobs/import/{job-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-import-job-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetImportJob", :http.request.configuration/output-deser-fn response-get-import-job-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-import-job :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-import-job-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-import-job-response))

(clojure.core/defn update-voice-channel ([update-voice-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-voice-channel-request update-voice-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-voice-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/voice", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-voice-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateVoiceChannel", :http.request.configuration/output-deser-fn response-update-voice-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-voice-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-voice-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-voice-channel-response))

(clojure.core/defn delete-adm-channel ([delete-adm-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-adm-channel-request delete-adm-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-adm-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/adm", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-adm-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteAdmChannel", :http.request.configuration/output-deser-fn response-delete-adm-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-adm-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-adm-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-adm-channel-response))

(clojure.core/defn get-channels ([get-channels-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-channels-request get-channels-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-channels-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-channels-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetChannels", :http.request.configuration/output-deser-fn response-get-channels-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-channels :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-channels-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-channels-response))

(clojure.core/defn update-endpoint ([update-endpoint-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-endpoint-request update-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-endpoint-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/endpoints/{endpoint-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-endpoint-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateEndpoint", :http.request.configuration/output-deser-fn response-update-endpoint-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-endpoint-response))

(clojure.core/defn get-application-settings ([get-application-settings-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-application-settings-request get-application-settings-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-application-settings-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/settings", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-application-settings-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApplicationSettings", :http.request.configuration/output-deser-fn response-get-application-settings-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-application-settings :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-application-settings-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-application-settings-response))

(clojure.core/defn get-campaigns ([get-campaigns-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-campaigns-request get-campaigns-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-campaigns-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-campaigns-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetCampaigns", :http.request.configuration/output-deser-fn response-get-campaigns-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-campaigns :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-campaigns-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-campaigns-response))

(clojure.core/defn update-email-channel ([update-email-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-email-channel-request update-email-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-email-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/email", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-email-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateEmailChannel", :http.request.configuration/output-deser-fn response-update-email-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-email-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-email-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-email-channel-response))

(clojure.core/defn create-campaign ([create-campaign-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-campaign-request create-campaign-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/create-campaign-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/create-campaign-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateCampaign", :http.request.configuration/output-deser-fn response-create-campaign-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-campaign :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/create-campaign-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/create-campaign-response))

(clojure.core/defn send-messages ([send-messages-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-send-messages-request send-messages-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/send-messages-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/messages", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/send-messages-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "SendMessages", :http.request.configuration/output-deser-fn response-send-messages-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef send-messages :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/send-messages-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/send-messages-response))

(clojure.core/defn update-gcm-channel ([update-gcm-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-gcm-channel-request update-gcm-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-gcm-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/gcm", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-gcm-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateGcmChannel", :http.request.configuration/output-deser-fn response-update-gcm-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-gcm-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-gcm-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-gcm-channel-response))

(clojure.core/defn get-segment-versions ([get-segment-versions-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-segment-versions-request get-segment-versions-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-segment-versions-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}/versions", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-segment-versions-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSegmentVersions", :http.request.configuration/output-deser-fn response-get-segment-versions-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-segment-versions :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-segment-versions-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-segment-versions-response))

(clojure.core/defn get-adm-channel ([get-adm-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-adm-channel-request get-adm-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-adm-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/adm", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-adm-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetAdmChannel", :http.request.configuration/output-deser-fn response-get-adm-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-adm-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-adm-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-adm-channel-response))

(clojure.core/defn delete-app ([delete-app-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-app-request delete-app-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-app-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-app-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApp", :http.request.configuration/output-deser-fn response-delete-app-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-app :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-app-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-app-response))

(clojure.core/defn create-app ([create-app-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-app-request create-app-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/create-app-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/create-app-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateApp", :http.request.configuration/output-deser-fn response-create-app-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-app :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/create-app-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/create-app-response))

(clojure.core/defn delete-apns-sandbox-channel ([delete-apns-sandbox-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-apns-sandbox-channel-request delete-apns-sandbox-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-apns-sandbox-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_sandbox", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-apns-sandbox-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApnsSandboxChannel", :http.request.configuration/output-deser-fn response-delete-apns-sandbox-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-apns-sandbox-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-apns-sandbox-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-apns-sandbox-channel-response))

(clojure.core/defn delete-user-endpoints ([delete-user-endpoints-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-user-endpoints-request delete-user-endpoints-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-user-endpoints-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/users/{user-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-user-endpoints-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteUserEndpoints", :http.request.configuration/output-deser-fn response-delete-user-endpoints-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-user-endpoints :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-user-endpoints-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-user-endpoints-response))

(clojure.core/defn delete-gcm-channel ([delete-gcm-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-gcm-channel-request delete-gcm-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-gcm-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/gcm", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-gcm-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteGcmChannel", :http.request.configuration/output-deser-fn response-delete-gcm-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-gcm-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-gcm-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-gcm-channel-response))

(clojure.core/defn get-apns-voip-channel ([get-apns-voip-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-apns-voip-channel-request get-apns-voip-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-apns-voip-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_voip", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-apns-voip-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApnsVoipChannel", :http.request.configuration/output-deser-fn response-get-apns-voip-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-apns-voip-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-apns-voip-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-apns-voip-channel-response))

(clojure.core/defn delete-campaign ([delete-campaign-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-campaign-request delete-campaign-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-campaign-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/campaigns/{campaign-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-campaign-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteCampaign", :http.request.configuration/output-deser-fn response-delete-campaign-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-campaign :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-campaign-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-campaign-response))

(clojure.core/defn remove-attributes ([remove-attributes-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-remove-attributes-request remove-attributes-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/remove-attributes-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/attributes/{attribute-type}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/remove-attributes-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "RemoveAttributes", :http.request.configuration/output-deser-fn response-remove-attributes-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef remove-attributes :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/remove-attributes-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/remove-attributes-response))

(clojure.core/defn untag-resource ([untag-resource-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-untag-resource-request untag-resource-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec nil, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/tags/{resource-arn}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/untag-resource-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 204, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UntagResource", :http.request.configuration/output-deser-fn (clojure.core/fn [& args__1013883__auto__] {}), :http.request.spec/error-spec {}})))))
(clojure.spec.alpha/fdef untag-resource :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/untag-resource-request) :ret clojure.core/true?)

(clojure.core/defn get-app ([get-app-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-app-request get-app-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-app-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-app-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApp", :http.request.configuration/output-deser-fn response-get-app-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-app :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-app-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-app-response))

(clojure.core/defn update-apns-voip-sandbox-channel ([update-apns-voip-sandbox-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-apns-voip-sandbox-channel-request update-apns-voip-sandbox-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-apns-voip-sandbox-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_voip_sandbox", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-apns-voip-sandbox-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApnsVoipSandboxChannel", :http.request.configuration/output-deser-fn response-update-apns-voip-sandbox-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-apns-voip-sandbox-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-apns-voip-sandbox-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-apns-voip-sandbox-channel-response))

(clojure.core/defn delete-segment ([delete-segment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-segment-request delete-segment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-segment-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-segment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSegment", :http.request.configuration/output-deser-fn response-delete-segment-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-segment :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-segment-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-segment-response))

(clojure.core/defn delete-apns-channel ([delete-apns-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-apns-channel-request delete-apns-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-apns-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-apns-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteApnsChannel", :http.request.configuration/output-deser-fn response-delete-apns-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-apns-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-apns-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-apns-channel-response))

(clojure.core/defn update-segment ([update-segment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-segment-request update-segment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-segment-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-segment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateSegment", :http.request.configuration/output-deser-fn response-update-segment-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-segment :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-segment-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-segment-response))

(clojure.core/defn delete-event-stream ([delete-event-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-event-stream-request delete-event-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-event-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/eventstream", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-event-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteEventStream", :http.request.configuration/output-deser-fn response-delete-event-stream-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-event-stream :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-event-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-event-stream-response))

(clojure.core/defn get-apps ([] (get-apps {})) ([get-apps-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-apps-request get-apps-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-apps-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-apps-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetApps", :http.request.configuration/output-deser-fn response-get-apps-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-apps :args (clojure.spec.alpha/? :portkey.aws.pinpoint/get-apps-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-apps-response))

(clojure.core/defn get-endpoint ([get-endpoint-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-endpoint-request get-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-endpoint-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/endpoints/{endpoint-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-endpoint-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetEndpoint", :http.request.configuration/output-deser-fn response-get-endpoint-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-endpoint-response))

(clojure.core/defn put-events ([put-events-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-events-request put-events-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/put-events-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/events", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/put-events-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutEvents", :http.request.configuration/output-deser-fn response-put-events-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-events :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/put-events-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/put-events-response))

(clojure.core/defn delete-endpoint ([delete-endpoint-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-endpoint-request delete-endpoint-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-endpoint-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/endpoints/{endpoint-id}", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-endpoint-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 202, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteEndpoint", :http.request.configuration/output-deser-fn response-delete-endpoint-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-endpoint :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-endpoint-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-endpoint-response))

(clojure.core/defn update-apns-sandbox-channel ([update-apns-sandbox-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-apns-sandbox-channel-request update-apns-sandbox-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-apns-sandbox-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/apns_sandbox", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-apns-sandbox-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateApnsSandboxChannel", :http.request.configuration/output-deser-fn response-update-apns-sandbox-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-apns-sandbox-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-apns-sandbox-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-apns-sandbox-channel-response))

(clojure.core/defn get-email-channel ([get-email-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-email-channel-request get-email-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-email-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/email", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-email-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetEmailChannel", :http.request.configuration/output-deser-fn response-get-email-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-email-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-email-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-email-channel-response))

(clojure.core/defn update-sms-channel ([update-sms-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-update-sms-channel-request update-sms-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/update-sms-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/sms", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/update-sms-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :put, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "UpdateSmsChannel", :http.request.configuration/output-deser-fn response-update-sms-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef update-sms-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/update-sms-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/update-sms-channel-response))

(clojure.core/defn get-segment-export-jobs ([get-segment-export-jobs-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-get-segment-export-jobs-request get-segment-export-jobs-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/get-segment-export-jobs-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments/{segment-id}/jobs/export", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/get-segment-export-jobs-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :get, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "GetSegmentExportJobs", :http.request.configuration/output-deser-fn response-get-segment-export-jobs-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef get-segment-export-jobs :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/get-segment-export-jobs-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/get-segment-export-jobs-response))

(clojure.core/defn create-segment ([create-segment-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-create-segment-request create-segment-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/create-segment-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/segments", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/create-segment-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 201, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "CreateSegment", :http.request.configuration/output-deser-fn response-create-segment-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef create-segment :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/create-segment-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/create-segment-response))

(clojure.core/defn delete-sms-channel ([delete-sms-channel-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-delete-sms-channel-request delete-sms-channel-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/delete-sms-channel-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/channels/sms", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/delete-sms-channel-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :delete, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "DeleteSmsChannel", :http.request.configuration/output-deser-fn response-delete-sms-channel-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef delete-sms-channel :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/delete-sms-channel-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/delete-sms-channel-response))

(clojure.core/defn put-event-stream ([put-event-stream-requestinput] (clojure.core/let [request-function-result__1013884__auto__ (req-put-event-stream-request put-event-stream-requestinput)] (portkey.aws/-call-http (clojure.core/into request-function-result__1013884__auto__ {:http.request.configuration/endpoints portkey.aws.pinpoint/endpoints, :http.request.configuration/target-prefix nil, :http.request.spec/output-spec :portkey.aws.pinpoint/put-event-stream-response, :http.request.configuration/mime-type {"content-type" "application/json"}, :http.request.configuration/request-uri "/v1/apps/{application-id}/eventstream", :http.request.configuration/version "2016-12-01", :http.request.configuration/service-id "Pinpoint", :http.request.spec/input-spec :portkey.aws.pinpoint/put-event-stream-request, :http.request.configuration/protocol "rest-json", :http.request.configuration/method :post, :http.request.configuration/response-code 200, :http.request.configuration/result-wrapper nil, :http.request.configuration/action "PutEventStream", :http.request.configuration/output-deser-fn response-put-event-stream-response, :http.request.spec/error-spec {"BadRequestException" :portkey.aws.pinpoint/bad-request-exception, "InternalServerErrorException" :portkey.aws.pinpoint/internal-server-error-exception, "ForbiddenException" :portkey.aws.pinpoint/forbidden-exception, "NotFoundException" :portkey.aws.pinpoint/not-found-exception, "MethodNotAllowedException" :portkey.aws.pinpoint/method-not-allowed-exception, "TooManyRequestsException" :portkey.aws.pinpoint/too-many-requests-exception}})))))
(clojure.spec.alpha/fdef put-event-stream :args (clojure.spec.alpha/tuple :portkey.aws.pinpoint/put-event-stream-request) :ret (clojure.spec.alpha/and :portkey.aws.pinpoint/put-event-stream-response))
