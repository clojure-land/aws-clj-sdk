(ns portkey.step1-req-generation
  (:require [cheshire.core :as json]
            [clojure.java.io :as io]
            [clojure.spec.alpha :as spec]
            [clojure.string :as s]
            [clojure.test :refer :all]
            [net.cgrand.xforms :as x]
            [portkey.aws :as aws]
            [portkey.aws.s3 :as s3]
            [portkey.awsgen :as gen :refer :all]))

;; Keep it here but no longer in used
;; Used it to validate ser-fns but it seems too complex on the long run
(defmacro deftest-aws-ser
  ([name {:keys [description-schema shape-to-test apply-on-protocols inputs expected-result] :as test-input}]
   `(deftest-aws-ser ~name nil ~test-input))
  ([name doc-string? {:keys [description-schema shape-to-test apply-on-protocols inputs expected-result]}]
   (assert (-> doc-string? (some-fn string? nil?)) "doc-string? must be a string or nil")
   `(deftest ~name
      ~doc-string?
      (doseq [protocol# ~apply-on-protocols
              input#    ~inputs
              :let      [description-schema# (assoc-in ~description-schema ["metadata" "protocol"] protocol#)
                         _#                  (doseq [shape# (keys (description-schema# "shapes"))]
                                               (eval (gen/generate-serialization-declare shape#)))
                         ser-fns#            (into {}
                                                   (map (fn [[sh#]]
                                                          [sh# (eval (gen/generate-serialization-function description-schema# sh#))]))
                                                   (get description-schema# "shapes"))
                         serialization-fun#  (ser-fns# ~shape-to-test)]]
        (is (= ~expected-result (serialization-fun# input#)))))))


(defmacro deftest-aws-request
  "Test whether the request payload that is generated by request-fn
  generates proper body as generated by aws cli.
  Don't send any request, expected-result is taken from aws cli results."    
  ([name {:keys [user-input lib-ns request-fn method body-fun expected-result] :as test-input}]
   `(deftest-aws-request ~name nil ~test-input))
  ([name doc-string? {:keys [user-input lib-ns request-fn method body-fun expected-result]}]
   (assert (-> doc-string? (some-fn string? nil?)) "doc-string? must be a string or nil")
   `(deftest ~name
      ~doc-string?
      (let [request-fn# (var-get (ns-resolve (find-ns (quote ~lib-ns))
                                             (quote ~request-fn)))]
        (is (= ~expected-result
               (-> ~user-input
                   request-fn#
                   (assoc :http.request.configuration/method ~method)
                   ~body-fun
                   :ring.request
                   :body)))))))


;;;;;;;;;;;;;;;;
;; TEST BEGIN ;;
;;;;;;;;;;;;;;;;


;; REST-XML protocol :
;; we should look at how this types generates xml considering all options (flattened, xml-attribute, xml-order...) :
;; - list
;; - map
;; - structure

    
;;;;;;;;;;;;;;;;;;;;;;;
;; TESTING LIST TYPE ;;
;;;;;;;;;;;;;;;;;;;;;;;


(deftest-aws-ser rest-xml-s3-put-bucket-tagging-list-with-locationName-ser
  "TEST LIST 1 : list with location-name set.

  We have to make
  sure that location-name is assoced on it's http.request.field when
  present in order to be taken into account at runtime when generating
  body input."
  {:description-schema {"shapes" {"TagSet"
                                  {"type" "list", "member" {"shape" "Tag", "locationName" "Tag"}}
                                  "Tag"
                                  {"type" "structure", "required" ["Key" "Value"], "members" {"Key" {"shape" "ObjectKey"}, "Value" {"shape" "Value"}}}
                                  "ObjectKey"
                                  {"type" "string", "min" 1}
                                  "Value"
                                  {"type" "string"}
                                  "BucketName"
                                  {"type" "string"}}}
   :shape-to-test      "TagSet"
   :apply-on-protocols ["rest-xml"]
   :inputs             [[{:key   "cle1"
                          :value "value1"}
                         {:key   "cle2"
                          :value "value2"}]]
   :expected-result    #:http.request.field {:value [#:http.request.field{:value         [#:http.request.field{:value "cle1", :shape "ObjectKey", :name "Key"}
                                                                                          #:http.request.field{:value "value1", :shape "Value", :name "Value"}]
                                                                          :shape         "Tag"
                                                                          :type          "structure"
                                                                          :location-name "Tag"}
                                                     #:http.request.field{:value         [#:http.request.field{:value "cle2", :shape "ObjectKey", :name "Key"}
                                                                                          #:http.request.field{:value "value2", :shape "Value", :name "Value"}]
                                                                          :shape         "Tag"
                                                                          :type          "structure"
                                                                          :location-name "Tag"}]
                                             :shape "TagSet"
                                             :type  "list"}})


(deftest-aws-request rest-xml-s3-put-bucket-tagging-list-with-locationName-req
  "TEST LIST 1 : list with location-name set.

   With shape TagSet which is a type list with a locationName.
   LocationName should be used as key in the xml ouput instead of
   usual shape name.
   
  {\"TagSet\" {\"type\" \"list\", \"member\" {\"shape\" \"Tag\",\"locationName\" \"Tag\"}}}"
  {:method                    :post
   :user-input                {:bucket "monbucket",
                               :tagging
                               {:tag-set
                                [{:key "cle1", :value "valeur1"}
                                 {:key "cle2", :value "valeur2"}]}}
   :request-fn                req-put-bucket-tagging-request
   :body-fun                  aws/params-to-body-rest-xml
   :lib-ns                    portkey.aws.s3
   :expected-result           "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Tagging xmlns:a=\"http://s3.amazonaws.com/doc/2006-03-01/\"><TagSet><Tag><Key>cle1</Key><Value>valeur1</Value></Tag><Tag><Key>cle2</Key><Value>valeur2</Value></Tag></TagSet></Tagging>"
   :expected-result-formatted "
<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<Tagging xmlns:a=\"http://s3.amazonaws.com/doc/2006-03-01/\">
  <TagSet>
    <Tag>
      <Key>cle1</Key>
      <Value>valeur1</Value>
    </Tag>
    <Tag>
      <Key>cle2</Key>
      <Value>valeur2</Value>
    </Tag>
  </TagSet>
</Tagging>"})


(deftest-aws-ser  rest-xml-s3-put-bucket-notification-configuration-list-with-flatten-ser
  "TEST LIST 2 : list with flatten attribute.

   When list is flattened, we have to propagate flattened value.
   The value is then used at runtime for generating proper xml
   e.g : ignoring the parent tag for flattened lists."
  {:description-schema {"shapes" {"TopicConfigurationList"
                                  {"type" "list", "member" {"shape" "TopicConfiguration"}, "flattened" true}
                                  "TopicConfiguration"
                                  {"type"     "structure"
                                   "required" ["TopicArn" "Events"]
                                   "members"  {"Id"       {"shape" "NotificationId"},
                                               "TopicArn" {"shape" "TopicArn", "locationName" "Topic"},
                                               "Events"   {"shape" "EventList", "locationName" "Event"}}}
                                  "NotificationId"
                                  {"type" "string"}
                                  "TopicArn"
                                  {"type" "string"}
                                  "EventList"
                                  {"type" "list", "member" {"shape" "Event"}, "flattened" true}
                                  "Event"
                                  {"type" "string",
                                   "enum" ["s3:ReducedRedundancyLostObject"
                                           "s3:ObjectCreated:*"
                                           "s3:ObjectCreated:Put"
                                           "s3:ObjectCreated:Post"
                                           "s3:ObjectCreated:Copy"
                                           "s3:ObjectCreated:CompleteMultipartUpload"
                                           "s3:ObjectRemoved:*"
                                           "s3:ObjectRemoved:Delete"
                                           "s3:ObjectRemoved:DeleteMarkerCreated"]}}}
   :shape-to-test      "TopicConfigurationList"
   :apply-on-protocols ["rest-xml"]
   :inputs             [[{:topic-arn "arn1",
                          :id        "id1"
                          :events    ["s3:ObjectRemoved:Delete"]}
                         {:topic-arn "arn2",
                          :id        "id2"
                          :events    ["s3:ObjectCreated:CompleteMultipartUpload"
                                      "s3:ObjectRemoved:Delete"]}]]
   :expected-result    #:http.request.field {:value     [#:http.request.field{:value [#:http.request.field{:value "arn1", :shape "TopicArn", :name "TopicArn", :location-name "Topic"}
                                                                                      #:http.request.field{:value         [#:http.request.field{:value "s3:ObjectRemoved:Delete", :shape "Event"}],
                                                                                                           :shape         "EventList",
                                                                                                           :type          "list",
                                                                                                           :flattened     true,
                                                                                                           :name          "Events",
                                                                                                           :location-name "Event"}
                                                                                      #:http.request.field{:value "id1", :shape "NotificationId", :name "Id"}],
                                                                              :shape "TopicConfiguration",
                                                                              :type  "structure"}
                                                         #:http.request.field{:value [#:http.request.field{:value "arn2", :shape "TopicArn", :name "TopicArn", :location-name "Topic"}
                                                                                      #:http.request.field{:value [#:http.request.field{:value "s3:ObjectCreated:CompleteMultipartUpload", :shape "Event"}
                                                                                                                   #:http.request.field{:value "s3:ObjectRemoved:Delete", :shape "Event"}],
                                                                                                           :shape "EventList",
                                                                                                           :type "list",
                                                                                                           :flattened true,
                                                                                                           :name "Events",
                                                                                                           :location-name "Event"}
                                                                                      #:http.request.field{:value "id2", :shape "NotificationId", :name "Id"}],
                                                                              :shape "TopicConfiguration",
                                                                              :type  "structure"}]
                                             :shape     "TopicConfigurationList",
                                             :type      "list",
                                             :flattened true}})


(deftest-aws-request rest-xml-s3-put-bucket-notification-configuration-list-with-flatten-req
  "TEST LIST 2 : list with flatten attribute"
  {:method                    :post
   :user-input                {:bucket "monbucket",
                               :notification-configuration
                               {:topic-configurations
                                [{:topic-arn "arn1",
                                  :id        "id1"
                                  :events    ["s3:ObjectRemoved:Delete"]}
                                 {:topic-arn "arn2",
                                  :id        "id2"
                                  :events    ["s3:ObjectCreated:CompleteMultipartUpload"
                                              "s3:ObjectRemoved:Delete"]}]}}
   :request-fn                req-put-bucket-notification-configuration-request
   :body-fun                  aws/params-to-body-rest-xml
   :lib-ns                    portkey.aws.s3
   :expected-result           "<?xml version=\"1.0\" encoding=\"UTF-8\"?><NotificationConfiguration xmlns:a=\"http://s3.amazonaws.com/doc/2006-03-01/\"><TopicConfiguration><Topic>arn1</Topic><Event>s3:ObjectRemoved:Delete</Event><Id>id1</Id></TopicConfiguration><TopicConfiguration><Topic>arn2</Topic><Event>s3:ObjectCreated:CompleteMultipartUpload</Event><Event>s3:ObjectRemoved:Delete</Event><Id>id2</Id></TopicConfiguration></NotificationConfiguration>"
   :expected-result-formatted "
<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<NotificationConfiguration xmlns:a=\"http://s3.amazonaws.com/doc/2006-03-01/\">
  <TopicConfiguration>
    <Topic>arn1</Topic>
    <Event>s3:ObjectRemoved:Delete</Event>
    <Id>id1</Id>
  </TopicConfiguration>
  <TopicConfiguration>
    <Topic>arn2</Topic>
    <Event>s3:ObjectCreated:CompleteMultipartUpload</Event>
    <Event>s3:ObjectRemoved:Delete</Event>
    <Id>id2</Id>
  </TopicConfiguration>
</NotificationConfiguration>"})


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; END LIST TYPE TESTING ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;
;; TESTING MAP TYPE ;;
;;;;;;;;;;;;;;;;;;;;;;




(deftest-aws-ser  rest-xml-s3-put-object-request-map-ser
  "TEST MAP 1 : map type should generate a vector of [key value] http.request.field."
  {:description-schema {"shapes" {"Metadata"
                                  {"type" "map", "key" {"shape" "MetadataKey"}, "value" {"shape" "MetadataValue"}}
                                  "MetadataKey"
                                  {"type" "string"}
                                  "MetadataValue"
                                  {"type" "string"}}}
   :shape-to-test      "Metadata"
   :apply-on-protocols ["rest-xml"]
   :inputs             [{"map-key1" "map-value1"
                         "map-key2" "map-value2"}]
   :expected-result    #:http.request.field{:value [[#:http.request.field{:value "map-key1", :shape "MetadataKey", :map-info "key"}
                                                     #:http.request.field{:value "map-value1", :shape "MetadataValue", :map-info "value"}]
                                                    [#:http.request.field{:value "map-key2", :shape "MetadataKey", :map-info "key"}
                                                     #:http.request.field{:value "map-value2", :shape "MetadataValue", :map-info "value"}]],
                                            :shape "Metadata",
                                            :type "map"}})


(deftest-aws-request  rest-xml-s3-put-object-request-map-request
  "TEST MAP 1 :

   Map are only applied on headers for the rest-xml protocol.  Here is
   an example when updating an object to s3.  The streaming attribute
   is set to true which take bytes as input body and bypass XML
   generation."
  {:method          :post
   :user-input      {:bucket        "monbucket"
                     :key           "macle"
                     :body          (bytes (byte-array (map (comp byte int) "body")))
                     :metadata      {"map-key1" "map-value1"
                                     "map-key2" "map-value2"}
                     :storage-class "ONEZONE_IA"}
   :request-fn      req-put-object-request
   :body-fun        aws/params-to-body-rest-xml
   :lib-ns          portkey.aws.s3
   :expected-result "Ym9keQ=="})

(comment

  `(defmethod compile-time-shape-spec "map" [_]
     (strict-strs
      :req {"type"  string?
            "key"   (strict-strs :req {"shape" string?} :opt {"locationName" string?})
            "value" (strict-strs :req {"shape" string?} :opt {"locationName" string?})}
      :opt {"sensitive"    boolean?
            "max"          int?
            "min"          int?
            "flattened"    boolean?
            "locationName" string?}))

  

  (s3/put-object {:bucket        "testbucketforawsclj346223"
                  :key           "myobjkey2"
                  :body          (let [f   (io/file "src/portkey/aws.clj")
                                       ary (byte-array (.length f))
                                       is  (java.io.FileInputStream. f)]
                                   (.read is ary)
                                   (.close is)
                                   ary)
                  :metadata      {"a" "b" "baptiste" "dupuch"}
                  :storage-class "ONEZONE_IA"})

  (require '[portkey.helpers :as h])
  (use 'clojure.repl)
  (dir s3)
  (h/def-api-2-json "rest-xml")

  (get-in rest-xml-protocol-s3-api-2-json ["shapes"  "MetadataValue"])
  (get-in rest-xml-protocol-s3-api-2-json ["shapes" "NotificationConfiguration"])
  (get-in rest-xml-protocol-s3-api-2-json ["shapes""NotificationConfigurationFilter"])
  

  (spec/exercise ::s3/put-bucket-notification-configuration-request)
  


  )

